From paul.sandoz at oracle.com  Tue Dec  1 05:36:45 2015
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Tue, 1 Dec 2015 11:36:45 +0100
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
	<561FC6F9.1080701@cs.oswego.edu>
	<25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
	<562BC968.70603@cs.oswego.edu>
	<8917A25C-4A16-4291-B145-FA7180E09F78@azul.com>
	<4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
Message-ID: <87110734-3922-434C-B2D7-11F9AD0A5D0E@oracle.com>


> On 1 Dec 2015, at 03:58, Gil Tene <gil at azul.com> wrote:
> 
> Update: After some significant back-and-forth between Doug and I on naming and JavaDoc'ing, and with Martin (Thompson) stepping in to help, we have what we think is a good spec and name selection for this thing. We're proposing to add a new static method to the Runtime class:
> 
> class Runtime { /...
>    /**
>      * Method signifying that the caller is momentarily unable to
>      * progress until the occurrence of one or more actions of one or
>      * more other activities.  When invoked within each iteration, this
>      * method typically improves performance of spin wait loop
>      * constructions.
>      */
>     public static void onSpinWait() {};
> }
> 

Short and sweet. I like it. I think it would be useful to add an @apiNote with explanatory text similar to that in the motivation section of the JEP.

If you like I can help guide this through the JEP process.


> See updated details, including a link to the updated JEP draft, as well as links to working prototype implementations, webrevs against OpenJDK9b94, and example here: https://github.com/giltene/GilExamples/tree/master/SpinWaitTest <https://github.com/giltene/GilExamples/tree/master/SpinWaitTest> . All names have changed to reflect the new naming (onSpinWait, -XX:+UseOnSpinWaitIntrinsic, SpinWaitTest, etc.).
> 
> As an interesting stat, the total changes in the WebRevs amount to 78 added lines (across 14 files) , and 0 lines removed or changed. Hopefully a good indication of relatively low footprint and risk.
> 

I agree, the JDK and hotspot patches (for x86 support) are quite small.

Paul.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/5e4908d8/attachment.bin>

From vitalyd at gmail.com  Tue Dec  1 07:16:24 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 07:16:24 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
	<561FC6F9.1080701@cs.oswego.edu>
	<25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
	<562BC968.70603@cs.oswego.edu>
	<8917A25C-4A16-4291-B145-FA7180E09F78@azul.com>
	<4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
Message-ID: <CAHjP37Gck+wc5RAVmMVqA5TedeMPmgQYFKt8mbPFHCXOskOhMw@mail.gmail.com>

Minor quibble, but why the "on" prefix in the name? Maybe just me, but
onXYX is typically used for event notification style APIs.

Also, the "wait" part seems inappropriate as the method itself isn't doing
any waiting.  What was wrong with the original spinLoopHint name? Or
cpuRelax()?

sent from my phone
On Nov 30, 2015 9:59 PM, "Gil Tene" <gil at azul.com> wrote:

> Update: After some significant back-and-forth between Doug and I on naming
> and JavaDoc'ing, and with Martin (Thompson) stepping in to help, we have
> what we think is a good spec and name selection for this thing. We're
> proposing to add a new static method to the Runtime class:
>
> class Runtime { /...
>     /**
>       * Method signifying that the caller is momentarily unable to
>       * progress until the occurrence of one or more actions of one or
>       * more other activities.  When invoked within each iteration, this
>       * method typically improves performance of spin wait loop
>       * constructions.
>       */
>      public static void onSpinWait() {};
> }
>
> See updated details, including a link to the updated JEP draft, as well as
> links to working prototype implementations, webrevs against OpenJDK9b94,
> and example here:
> https://github.com/giltene/GilExamples/tree/master/SpinWaitTest <
> https://github.com/giltene/GilExamples/tree/master/SpinWaitTest> . All
> names have changed to reflect the new naming (onSpinWait,
> -XX:+UseOnSpinWaitIntrinsic, SpinWaitTest, etc.).
>
> As an interesting stat, the total changes in the WebRevs amount to 78
> added lines (across 14 files) , and 0 lines removed or changed. Hopefully a
> good indication of relatively low footprint and risk.
>
> ? Gil.
>
>
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/bf1ddcd8/attachment.html>

From dl at cs.oswego.edu  Tue Dec  1 07:43:41 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 1 Dec 2015 07:43:41 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <87110734-3922-434C-B2D7-11F9AD0A5D0E@oracle.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
	<561FC6F9.1080701@cs.oswego.edu>
	<25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
	<562BC968.70603@cs.oswego.edu>
	<8917A25C-4A16-4291-B145-FA7180E09F78@azul.com>
	<4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
	<87110734-3922-434C-B2D7-11F9AD0A5D0E@oracle.com>
Message-ID: <565D95FD.3000906@cs.oswego.edu>

On 12/01/2015 05:36 AM, Paul Sandoz wrote:
>
>> On 1 Dec 2015, at 03:58, Gil Tene <gil at azul.com> wrote:
>>
>> class Runtime { /...
>>     /**
>>       * Method signifying that the caller is momentarily unable to
>>       * progress until the occurrence of one or more actions of one or
>>       * more other activities.  When invoked within each iteration, this
>>       * method typically improves performance of spin wait loop
>>       * constructions.
>>       */
>>      public static void onSpinWait() {};
>> }
>>
>
> Short and sweet. I like it. I think it would be useful to add an @apiNote with explanatory text similar to that in the motivation section of the JEP.
>


Or maybe not. Recent experience suggests that it is hard to add a brief
explanatory note or usage guidance without saying something
confusing or wrong wrt usages focussing on latency, throughput,
or power -- these effects may vary across processors with
different instructions (possibly just no-op) used to implement it.
Not a lot, but this accounts for the bland wording of
"typically improves performance".

-Doug


From viktor.klang at gmail.com  Tue Dec  1 07:47:43 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 1 Dec 2015 13:47:43 +0100
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <CAHjP37Gck+wc5RAVmMVqA5TedeMPmgQYFKt8mbPFHCXOskOhMw@mail.gmail.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
	<561FC6F9.1080701@cs.oswego.edu>
	<25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
	<562BC968.70603@cs.oswego.edu>
	<8917A25C-4A16-4291-B145-FA7180E09F78@azul.com>
	<4A8EF318-A674-4619-94A6-6321AA198AEF@azul.com>
	<CAHjP37Gck+wc5RAVmMVqA5TedeMPmgQYFKt8mbPFHCXOskOhMw@mail.gmail.com>
Message-ID: <CANPzfU9dSRWgRw-kb1r1qK-Cd0BxpgoM5if4C6iW9fz-hdzT5A@mail.gmail.com>

While we are painting the bikeshed, what about `powerNap()`

On Tue, Dec 1, 2015 at 1:16 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Minor quibble, but why the "on" prefix in the name? Maybe just me, but
> onXYX is typically used for event notification style APIs.
>
> Also, the "wait" part seems inappropriate as the method itself isn't doing
> any waiting.  What was wrong with the original spinLoopHint name? Or
> cpuRelax()?
>
> sent from my phone
> On Nov 30, 2015 9:59 PM, "Gil Tene" <gil at azul.com> wrote:
>
>> Update: After some significant back-and-forth between Doug and I on
>> naming and JavaDoc'ing, and with Martin (Thompson) stepping in to help, we
>> have what we think is a good spec and name selection for this thing. We're
>> proposing to add a new static method to the Runtime class:
>>
>> class Runtime { /...
>>     /**
>>       * Method signifying that the caller is momentarily unable to
>>       * progress until the occurrence of one or more actions of one or
>>       * more other activities.  When invoked within each iteration, this
>>       * method typically improves performance of spin wait loop
>>       * constructions.
>>       */
>>      public static void onSpinWait() {};
>> }
>>
>> See updated details, including a link to the updated JEP draft, as well
>> as links to working prototype implementations, webrevs against OpenJDK9b94,
>> and example here:
>> https://github.com/giltene/GilExamples/tree/master/SpinWaitTest <
>> https://github.com/giltene/GilExamples/tree/master/SpinWaitTest> . All
>> names have changed to reflect the new naming (onSpinWait,
>> -XX:+UseOnSpinWaitIntrinsic, SpinWaitTest, etc.).
>>
>> As an interesting stat, the total changes in the WebRevs amount to 78
>> added lines (across 14 files) , and 0 lines removed or changed. Hopefully a
>> good indication of relatively low footprint and risk.
>>
>> ? Gil.
>>
>>
>>
>>
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/5c003fcf/attachment-0001.html>

From mjpt777 at gmail.com  Tue Dec  1 08:17:02 2015
From: mjpt777 at gmail.com (Martin Thompson)
Date: Tue, 1 Dec 2015 13:17:02 +0000
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
Message-ID: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>

> Date: Tue, 1 Dec 2015 07:16:24 -0500
> From: Vitaly Davidovich <vitalyd at gmail.com>
>         <hotspot-dev at openjdk.java.net>, concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Spin Loop Hint support: Draft JEP
>         proposal
>
> Minor quibble, but why the "on" prefix in the name? Maybe just me, but
> onXYX is typically used for event notification style APIs.
>
> Also, the "wait" part seems inappropriate as the method itself isn't doing
> any waiting.  What was wrong with the original spinLoopHint name? Or
> cpuRelax()?


Relax was a suggested name that fits with the current Linux kernel
convention. However it was felt this suggested implementation rather than
notifying state.

The "on" prefix was suggested as the caller is notifying the runtime that
it is in a spin-wait loop. This allows the runtime the option of reacting
to the event, or not, and allows flexibility in how it chooses to react to
this information. The method is not waiting; the method is notifying that
the caller is waiting.

Martin...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/bf351c78/attachment.html>

From vitalyd at gmail.com  Tue Dec  1 08:46:13 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 08:46:13 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
Message-ID: <CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>

>
> Relax was a suggested name that fits with the current Linux kernel
> convention. However it was felt this suggested implementation rather than
> notifying state.


Yes, 'relax' is a well known term for this, and sticking to known
conventions/terms is desirable.  I don't see how it suggests implementation
though, nor even if it did suggest anything, why that's a bad thing.  If we
want to avoid any suggestions, let's call it "foobar" :).

The "on" prefix was suggested as the caller is notifying the runtime that
> it is in a spin-wait loop. This allows the runtime the option of reacting
> to the event, or not, and allows flexibility in how it chooses to react to
> this information. The method is not waiting; the method is notifying that
> the caller is waiting.


Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(), and
both of those are documented as "suggesting" the VM perform those actions.
 spinLoopHint() sounded much better than what's proposed here, and carries
the suggestion/hint/optionality that's desired.  IMHO, onSpinWait() is the
least appealing options proposed thus far.


On Tue, Dec 1, 2015 at 8:17 AM, Martin Thompson <mjpt777 at gmail.com> wrote:

>
> Date: Tue, 1 Dec 2015 07:16:24 -0500
>> From: Vitaly Davidovich <vitalyd at gmail.com>
>>         <hotspot-dev at openjdk.java.net>,
>> concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Spin Loop Hint support: Draft JEP
>>         proposal
>>
>> Minor quibble, but why the "on" prefix in the name? Maybe just me, but
>> onXYX is typically used for event notification style APIs.
>>
>> Also, the "wait" part seems inappropriate as the method itself isn't doing
>> any waiting.  What was wrong with the original spinLoopHint name? Or
>> cpuRelax()?
>
>
> Relax was a suggested name that fits with the current Linux kernel
> convention. However it was felt this suggested implementation rather than
> notifying state.
>
> The "on" prefix was suggested as the caller is notifying the runtime that
> it is in a spin-wait loop. This allows the runtime the option of reacting
> to the event, or not, and allows flexibility in how it chooses to react to
> this information. The method is not waiting; the method is notifying that
> the caller is waiting.
>
> Martin...
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/244e048e/attachment.html>

From mjpt777 at gmail.com  Tue Dec  1 09:13:44 2015
From: mjpt777 at gmail.com (Martin Thompson)
Date: Tue, 1 Dec 2015 14:13:44 +0000
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
Message-ID: <CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>

On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Relax was a suggested name that fits with the current Linux kernel
>> convention. However it was felt this suggested implementation rather than
>> notifying state.
>
>
> Yes, 'relax' is a well known term for this, and sticking to known
> conventions/terms is desirable.  I don't see how it suggests implementation
> though, nor even if it did suggest anything, why that's a bad thing.  If we
> want to avoid any suggestions, let's call it "foobar" :).
>

Thread.relax() was my initial suggestion. I'll leave it to the others for
why they did not think this was suitable.


> The "on" prefix was suggested as the caller is notifying the runtime that
>> it is in a spin-wait loop. This allows the runtime the option of reacting
>> to the event, or not, and allows flexibility in how it chooses to react to
>> this information. The method is not waiting; the method is notifying that
>> the caller is waiting.
>
>
> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(), and
> both of those are documented as "suggesting" the VM perform those actions.
>  spinLoopHint() sounded much better than what's proposed here, and carries
> the suggestion/hint/optionality that's desired.  IMHO, onSpinWait() is the
> least appealing options proposed thus far.
>

System.gc() and Runtime.runFinalizersOnExit(boolean) are clear instructions
to the system/runtime to do something in an imperative fashion. The
onSpinWait() is a declarative statement about the state of the current
thread. I can understand a dislike to a name. We all have personal taste on
this but I don't think you are comparing similar semantics.

Consider the runtime as an object. You send it a message via a method. What
exactly is spinLoopHint() telling the Runtime what to do? It is applying an
event but not expressing it via any convention. "spinLoopHint()" works for
me on a Thread to an extent. We should express intent or declare status for
this. Hints don't fit comfortably in a programming model.

The actual naming does not matter so much as this will only be used by
minority of programmers. I'll prepare to be flamed on that :-) However it
is desperately needed and anything that makes it slip the date to make Java
9 would be such a let down.

Martin...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/0e13328b/attachment.html>

From vitalyd at gmail.com  Tue Dec  1 09:22:50 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 09:22:50 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
Message-ID: <CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>

>
> Thread.relax() was my initial suggestion. I'll leave it to the others for
> why they did not think this was suitable.


Yes, that would work for me as well although I'd prefer to have 'cpu' in
the name to be more clear.  But either way, sticking to known/common
nomenclature is good; ad-hoc names are not.

System.gc() and Runtime.runFinalizersOnExit(boolean) are clear instructions
> to the system/runtime to do something in an imperative fashion. The
> onSpinWait() is a declarative statement about the state of the current
> thread. I can understand a dislike to a name. We all have personal taste on
> this but I don't think you are comparing similar semantics.


System.gc() can be thought of as "I'm suggesting to the JVM that now is a
good time to perform GC", so it's as much about the state of things (known
to caller, unknown to JVM or else this wouldn't be needed).  We can agree
to disagree here, but I don't see "good time to run GC" vs "good time to
relax the CPU" as having any strong semantic differences.

Consider the runtime as an object. You send it a message via a method. What
> exactly is spinLoopHint() telling the Runtime what to do? It is applying an
> event but not expressing it via any convention. "spinLoopHint()" works for
> me on a Thread to an extent. We should express intent or declare status for
> this. Hints don't fit comfortably in a programming model.


I should've been clearer, but I meant spinLoopHint on Thread was a better
proposal.  I agree that Runtime isn't the right place for something of that
name.

The actual naming does not matter so much as this will only be used by
> minority of programmers. I'll prepare to be flamed on that :-) However it
> is desperately needed and anything that makes it slip the date to make Java
> 9 would be such a let down.


Agreed.  Ultimately someone will be unhappy with the name and/or placement,
but while these options are being discussed I think it'd be good to hear
multiple viewpoints.

On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com> wrote:

>
> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
>> Relax was a suggested name that fits with the current Linux kernel
>>> convention. However it was felt this suggested implementation rather than
>>> notifying state.
>>
>>
>> Yes, 'relax' is a well known term for this, and sticking to known
>> conventions/terms is desirable.  I don't see how it suggests implementation
>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>> want to avoid any suggestions, let's call it "foobar" :).
>>
>
> Thread.relax() was my initial suggestion. I'll leave it to the others for
> why they did not think this was suitable.
>
>
>> The "on" prefix was suggested as the caller is notifying the runtime that
>>> it is in a spin-wait loop. This allows the runtime the option of reacting
>>> to the event, or not, and allows flexibility in how it chooses to react to
>>> this information. The method is not waiting; the method is notifying that
>>> the caller is waiting.
>>
>>
>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(), and
>> both of those are documented as "suggesting" the VM perform those actions.
>>  spinLoopHint() sounded much better than what's proposed here, and carries
>> the suggestion/hint/optionality that's desired.  IMHO, onSpinWait() is the
>> least appealing options proposed thus far.
>>
>
> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
> instructions to the system/runtime to do something in an imperative
> fashion. The onSpinWait() is a declarative statement about the state of the
> current thread. I can understand a dislike to a name. We all have personal
> taste on this but I don't think you are comparing similar semantics.
>
> Consider the runtime as an object. You send it a message via a method.
> What exactly is spinLoopHint() telling the Runtime what to do? It is
> applying an event but not expressing it via any convention.
> "spinLoopHint()" works for me on a Thread to an extent. We should express
> intent or declare status for this. Hints don't fit comfortably in a
> programming model.
>
> The actual naming does not matter so much as this will only be used by
> minority of programmers. I'll prepare to be flamed on that :-) However it
> is desperately needed and anything that makes it slip the date to make Java
> 9 would be such a let down.
>
> Martin...
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/6aafb7d0/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  1 10:32:52 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 10:32:52 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <302AB4FF-6C68-487B-B4A3-7F0C51BA07CE@azul.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
	<CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>
	<302AB4FF-6C68-487B-B4A3-7F0C51BA07CE@azul.com>
Message-ID: <CAHjP37FcbWqSJsUcGSspy7HxE7xOpNxi+ZGoLLCiF_SJe-UmVg@mail.gmail.com>

>
> On why "relax" (or other "this is how it will be achieved" naming options)
> are not a good fit IMO:


But relax, although a common term for this scenario, is still vague enough
as to not indicate exactly how it does this, so I don't see any leakage of
implementation details.  Moreover, the niche target users of this API are
likely going to know exactly what they want at the machine instruction
level on the platform(s) they care about.  This isn't some widely
applicable general purpose API -- it's a low level API, and low level APIs
should not be intentionally vague.  I'm almost certain that 99% of people
using this API will know, either ahead of time or by researching, exactly
what happens under the hood.  When trying to control things at this level,
implementation details start to matter.

As for optionality, yes, you may want to convey that.  But I don't think it
necessarily has to be in the name - javadoc is more than sufficient.
Again, let's keep in mind target audience.

System.gc() says "Runs the garbage collector". A name like System.onGC()
> would mean "I'm running the garbage collector, and you may want to know
> that (and do something about it)...".
> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
> know about that (and do something about it)"


The 2nd sentence of Runtime.gc() javadoc begins with (emphasis mine)
"Calling this method *suggests* that the Java virtual machine expend effort
...".  We all know that there's ways to disable explicit GC from doing
anything at all, so although the name isn't Runtime.maybeGC() or
Runtime.gcHint() or whatever, anyone exploring this (also somewhat niche,
relatively speaking) API will quickly learn that it doesn't guarantee
anything.

I'll just reiterate that I think target audience of this API should be kept
in mind; it's low level functionality and there's no need to try and
obfuscate it.


On Tue, Dec 1, 2015 at 10:15 AM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 1, 2015, at 6:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> Thread.relax() was my initial suggestion. I'll leave it to the others for
>> why they did not think this was suitable.
>
>
> Yes, that would work for me as well although I'd prefer to have 'cpu' in
> the name to be more clear.  But either way, sticking to known/common
> nomenclature is good; ad-hoc names are not.
>
>
> On why "relax" (or other "this is how it will be achieved" naming options)
> are not a good fit IMO:
>
> "Relaxing" the CPU is one specific possibility for what the JVM might want
> to do to improve the performance and responsiveness of a spin wait loop.
> E.g. The JVM might achieve the desired improvement by doing other things in
> conjunction with, or in place of relaxing the CPU. Such as affecting
> scheduling priority or affinity, or doing some other thing that might
> reduce the likelihood of yielding the CPU. In addition , depending on
> platform, relaxing the CPU may be the wing thing to do: i.e. Some of the
> CPU-relaxing options on some platforms dramatically reduce the performance
> of a spin wait loops and increase their reaction time (rather than improve
> and reduce).
>
> I wanted the name to suggest intent without dictating implementation, and
> for the spec to make it clear that improving the performance of a spin wait
> loop construct is the intended (or hoped for) result without committing to
> actually achieving that. The runtime may choose to ignore the indication,
> but it would be surprising for it to make things "worse" for the calling
> spin wait loop compared to code that doesn't make the same call.
>
>
> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>> instructions to the system/runtime to do something in an imperative
>> fashion. The onSpinWait() is a declarative statement about the state of the
>> current thread. I can understand a dislike to a name. We all have personal
>> taste on this but I don't think you are comparing similar semantics.
>
>
> System.gc() can be thought of as "I'm suggesting to the JVM that now is a
> good time to perform GC", so it's as much about the state of things (known
> to caller, unknown to JVM or else this wouldn't be needed).  We can agree
> to disagree here, but I don't see "good time to run GC" vs "good time to
> relax the CPU" as having any strong semantic differences.
>
>
> System.gc() says "Runs the garbage collector". A name like System.onGC()
> would mean "I'm running the garbage collector, and you may want to know
> that (and do something about it)...".
>
> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
> know about that (and do something about it)"
>
>
> Consider the runtime as an object. You send it a message via a method.
>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>> applying an event but not expressing it via any convention.
>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>> intent or declare status for this. Hints don't fit comfortably in a
>> programming model.
>
>
> I should've been clearer, but I meant spinLoopHint on Thread was a better
> proposal.  I agree that Runtime isn't the right place for something of that
> name.
>
> The actual naming does not matter so much as this will only be used by
>> minority of programmers. I'll prepare to be flamed on that :-) However it
>> is desperately needed and anything that makes it slip the date to make Java
>> 9 would be such a let down.
>
>
> Agreed.  Ultimately someone will be unhappy with the name and/or
> placement, but while these options are being discussed I think it'd be good
> to hear multiple viewpoints.
>
> On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com> wrote:
>
>>
>> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>>> Relax was a suggested name that fits with the current Linux kernel
>>>> convention. However it was felt this suggested implementation rather than
>>>> notifying state.
>>>
>>>
>>> Yes, 'relax' is a well known term for this, and sticking to known
>>> conventions/terms is desirable.  I don't see how it suggests implementation
>>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>>> want to avoid any suggestions, let's call it "foobar" :).
>>>
>>
>> Thread.relax() was my initial suggestion. I'll leave it to the others for
>> why they did not think this was suitable.
>>
>>
>>> The "on" prefix was suggested as the caller is notifying the runtime
>>>> that it is in a spin-wait loop. This allows the runtime the option of
>>>> reacting to the event, or not, and allows flexibility in how it chooses to
>>>> react to this information. The method is not waiting; the method is
>>>> notifying that the caller is waiting.
>>>
>>>
>>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(),
>>> and both of those are documented as "suggesting" the VM perform those
>>> actions.  spinLoopHint() sounded much better than what's proposed here, and
>>> carries the suggestion/hint/optionality that's desired.  IMHO, onSpinWait()
>>> is the least appealing options proposed thus far.
>>>
>>
>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>> instructions to the system/runtime to do something in an imperative
>> fashion. The onSpinWait() is a declarative statement about the state of the
>> current thread. I can understand a dislike to a name. We all have personal
>> taste on this but I don't think you are comparing similar semantics.
>>
>> Consider the runtime as an object. You send it a message via a method.
>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>> applying an event but not expressing it via any convention.
>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>> intent or declare status for this. Hints don't fit comfortably in a
>> programming model.
>>
>> The actual naming does not matter so much as this will only be used by
>> minority of programmers. I'll prepare to be flamed on that :-) However it
>> is desperately needed and anything that makes it slip the date to make Java
>> 9 would be such a let down.
>>
>> Martin...
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/3dffd6e6/attachment.html>

From vitalyd at gmail.com  Tue Dec  1 11:02:17 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 11:02:17 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <28B1781D-7616-4BB1-BAC5-ECA492F72E44@azul.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
	<CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>
	<28B1781D-7616-4BB1-BAC5-ECA492F72E44@azul.com>
Message-ID: <CAHjP37Gkx6qcN=Z-7Gc0f6DtqGBs-kNgmAacUXZa16Zgtzu0Zw@mail.gmail.com>

See my earlier suggestion about keeping target user of this API in mind and
the level of this API (i.e. low).

As for doing nothing in the implementation, OK.  But I bet if someone using
this API finds out it does nothing on their platform they're going to stop
using this API and go back to manual hacks that have at least some chance
of achieving desired results.  So while I understand the general motivation
of not leaking implementation details, I don't agree this API is the
appropriate place for that.

On Tue, Dec 1, 2015 at 10:45 AM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 1, 2015, at 6:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> Thread.relax() was my initial suggestion. I'll leave it to the others for
>> why they did not think this was suitable.
>
>
> Yes, that would work for me as well although I'd prefer to have 'cpu' in
> the name to be more clear.  But either way, sticking to known/common
> nomenclature is good; ad-hoc names are not.
>
> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>> instructions to the system/runtime to do something in an imperative
>> fashion. The onSpinWait() is a declarative statement about the state of the
>> current thread. I can understand a dislike to a name. We all have personal
>> taste on this but I don't think you are comparing similar semantics.
>
>
> System.gc() can be thought of as "I'm suggesting to the JVM that now is a
> good time to perform GC", so it's as much about the state of things (known
> to caller, unknown to JVM or else this wouldn't be needed).  We can agree
> to disagree here, but I don't see "good time to run GC" vs "good time to
> relax the CPU" as having any strong semantic differences.
>
> Consider the runtime as an object. You send it a message via a method.
>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>> applying an event but not expressing it via any convention.
>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>> intent or declare status for this. Hints don't fit comfortably in a
>> programming model.
>
>
> I should've been clearer, but I meant spinLoopHint on Thread was a better
> proposal.  I agree that Runtime isn't the right place for something of that
> name.
>
>
> Thread.spinLoopHint() was my first choice as well. But I was swayed by
> strong arguments against "hint" in the method name. Including the lack of
> "action" and ambiguity about roles. We looked at various names that were
> either clear and way too long or way too short or implementation specific
> (or narrowing), like skip, pause, relax, etc.
>
> Given the spec we agreed n, the name we were looking for was something
> that would be equivalent to the obvious expectations from something named
> as elaborately as:
>
> maybeYouShouldTryToImproveThePerformanceOfTheSpinWaitLoopMakingThisCall(),
> with the receiver being either the thread or the runtime.
>
> The "maybe you should try" part is important because doing nothing is a
> valid option, and accidentally failing to achieve the goal is probably ok,
> but consistently working in the opposite direction of the goal would be
> "surprising behavior". The "...making this call" part is important because
> of ambiguities around roles and actions (the call is not expected to spin,
> or wait, it's the caller that is doing those things).
>
> Given the natural way we'd describe what the options are for the receiver
> in plain language, it became clear that Runtime fit better: we naturally
> say "the runtime may..." and "indicate to the runtime...", not "the thread
> may" or "indicate to the thread...". In addition, some of the
> implementation possibilities (e.g. switch this thread to spin on a
> dedicated core) may involve actions that are natural runtime actions but
> far outside of the scope of what Thread might do.
>
> With an event delivery paradigm ("I'm in a spin wait loop, you may want to
> do something about that") Runtime.onSpinWait() fits common naming
> conventions and roles. It's also  readable enough to understand that the
> Runtime is being told that a spin wait is going on. And in that sense, it
> is just as expressive as spinLoopHint(), while actually following a naming
> convention. We left the "try to improve the performance" to the
> spec/JavaDoc because it was very hard to fit in the name.
>
>
> The actual naming does not matter so much as this will only be used by
>> minority of programmers. I'll prepare to be flamed on that :-) However it
>> is desperately needed and anything that makes it slip the date to make Java
>> 9 would be such a let down.
>
>
> Agreed.  Ultimately someone will be unhappy with the name and/or
> placement, but while these options are being discussed I think it'd be good
> to hear multiple viewpoints.
>
> On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com> wrote:
>
>>
>> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>>> Relax was a suggested name that fits with the current Linux kernel
>>>> convention. However it was felt this suggested implementation rather than
>>>> notifying state.
>>>
>>>
>>> Yes, 'relax' is a well known term for this, and sticking to known
>>> conventions/terms is desirable.  I don't see how it suggests implementation
>>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>>> want to avoid any suggestions, let's call it "foobar" :).
>>>
>>
>> Thread.relax() was my initial suggestion. I'll leave it to the others for
>> why they did not think this was suitable.
>>
>>
>>> The "on" prefix was suggested as the caller is notifying the runtime
>>>> that it is in a spin-wait loop. This allows the runtime the option of
>>>> reacting to the event, or not, and allows flexibility in how it chooses to
>>>> react to this information. The method is not waiting; the method is
>>>> notifying that the caller is waiting.
>>>
>>>
>>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(),
>>> and both of those are documented as "suggesting" the VM perform those
>>> actions.  spinLoopHint() sounded much better than what's proposed here, and
>>> carries the suggestion/hint/optionality that's desired.  IMHO, onSpinWait()
>>> is the least appealing options proposed thus far.
>>>
>>
>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>> instructions to the system/runtime to do something in an imperative
>> fashion. The onSpinWait() is a declarative statement about the state of the
>> current thread. I can understand a dislike to a name. We all have personal
>> taste on this but I don't think you are comparing similar semantics.
>>
>> Consider the runtime as an object. You send it a message via a method.
>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>> applying an event but not expressing it via any convention.
>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>> intent or declare status for this. Hints don't fit comfortably in a
>> programming model.
>>
>> The actual naming does not matter so much as this will only be used by
>> minority of programmers. I'll prepare to be flamed on that :-) However it
>> is desperately needed and anything that makes it slip the date to make Java
>> 9 would be such a let down.
>>
>> Martin...
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/a9da984b/attachment-0001.html>

From vitalyd at gmail.com  Tue Dec  1 11:29:10 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 11:29:10 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <7E31ACCE-0EA6-41D9-BBBE-ED19246FF834@azul.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
	<CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>
	<302AB4FF-6C68-487B-B4A3-7F0C51BA07CE@azul.com>
	<CAHjP37FcbWqSJsUcGSspy7HxE7xOpNxi+ZGoLLCiF_SJe-UmVg@mail.gmail.com>
	<7E31ACCE-0EA6-41D9-BBBE-ED19246FF834@azul.com>
Message-ID: <CAHjP37GYiEt1t-ODouB90mpqzzsH6cY411CZadd_KQt5AFTWTw@mail.gmail.com>

I suggested relax because it's a commonly used name for this effect.  With
no prior art in this area, I'd agree that relax can be misinterpreted.  But
I'm just as happy with your original spinLoopHint on the Thread class, to
be honest.  I just don't like onSpinWait() on the Runtime class.

On Tue, Dec 1, 2015 at 11:19 AM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 1, 2015, at 7:32 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> On why "relax" (or other "this is how it will be achieved" naming options)
>> are not a good fit IMO:
>
>
> But relax, although a common term for this scenario, is still vague enough
> as to not indicate exactly how it does this, so I don't see any leakage of
> implementation details.  Moreover, the niche target users of this API are
> likely going to know exactly what they want at the machine instruction
> level on the platform(s) they care about.  This isn't some widely
> applicable general purpose API -- it's a low level API, and low level APIs
> should not be intentionally vague.  I'm almost certain that 99% of people
> using this API will know, either ahead of time or by researching, exactly
> what happens under the hood.  When trying to control things at this level,
> implementation details start to matter.
>
>
> The goal of the call is not to relax the CPU. It is to improve the
> performance of the spin loop.
>
> This makes goal the opposite of what "relax" suggests. While the spec
> rules (and clearly says that performance improvement is the goal), we'd
> probably agree that names like "chill()", "slowDown()", or
> "dontBotherWithSpeed()" would be a bad fit. "Relax" fits right in with
> those...
>
> The fact that the performance-enhancing goal can actually be technically
> achieved in some specific CPUs by relaxing their execution in specific ways
> is surprising in itself. It makes for interesting conversation ("wow, who
> knew that relaxing the aggressiveness of speculation might actually make
> the reaction time faster?"), but the fact that it's interesting and
> surprising is a good indication that it is a bad name choice.
>
> There are various ways to relax CPUs that are wrong to use for the goal of
> the call, but would be natural for something called "relax". These include
> deeper cstates in x86, variations of MWAIT with short timeouts on various
> CPUs, and even instructions named "pause" on some platforms that
> consistently hurt performance but help save power. These make it clear that
> if we used "relax" as a name in this spin wait loop performance context, we
> actually mean "relaxInA2015x86PauseInstructionSense()"...
>
>
> As for optionality, yes, you may want to convey that.  But I don't think
> it necessarily has to be in the name - javadoc is more than sufficient.
> Again, let's keep in mind target audience.
>
> System.gc() says "Runs the garbage collector". A name like System.onGC()
>> would mean "I'm running the garbage collector, and you may want to know
>> that (and do something about it)...".
>> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
>> know about that (and do something about it)"
>
>
> The 2nd sentence of Runtime.gc() javadoc begins with (emphasis mine)
> "Calling this method *suggests* that the Java virtual machine expend
> effort ...".  We all know that there's ways to disable explicit GC from
> doing anything at all, so although the name isn't Runtime.maybeGC() or
> Runtime.gcHint() or whatever, anyone exploring this (also somewhat niche,
> relatively speaking) API will quickly learn that it doesn't guarantee
> anything.
>
> I'll just reiterate that I think target audience of this API should be
> kept in mind; it's low level functionality and there's no need to try and
> obfuscate it.
>
>
> On Tue, Dec 1, 2015 at 10:15 AM, Gil Tene <gil at azul.com> wrote:
>
>>
>>
>> Sent from Gil's iPhone
>>
>> On Dec 1, 2015, at 6:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> Thread.relax() was my initial suggestion. I'll leave it to the others for
>>> why they did not think this was suitable.
>>
>>
>> Yes, that would work for me as well although I'd prefer to have 'cpu' in
>> the name to be more clear.  But either way, sticking to known/common
>> nomenclature is good; ad-hoc names are not.
>>
>>
>> On why "relax" (or other "this is how it will be achieved" naming
>> options) are not a good fit IMO:
>>
>> "Relaxing" the CPU is one specific possibility for what the JVM might
>> want to do to improve the performance and responsiveness of a spin wait
>> loop. E.g. The JVM might achieve the desired improvement by doing other
>> things in conjunction with, or in place of relaxing the CPU. Such as
>> affecting scheduling priority or affinity, or doing some other thing that
>> might reduce the likelihood of yielding the CPU. In addition , depending on
>> platform, relaxing the CPU may be the wing thing to do: i.e. Some of the
>> CPU-relaxing options on some platforms dramatically reduce the performance
>> of a spin wait loops and increase their reaction time (rather than improve
>> and reduce).
>>
>> I wanted the name to suggest intent without dictating implementation, and
>> for the spec to make it clear that improving the performance of a spin wait
>> loop construct is the intended (or hoped for) result without committing to
>> actually achieving that. The runtime may choose to ignore the indication,
>> but it would be surprising for it to make things "worse" for the calling
>> spin wait loop compared to code that doesn't make the same call.
>>
>>
>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>> instructions to the system/runtime to do something in an imperative
>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>> current thread. I can understand a dislike to a name. We all have personal
>>> taste on this but I don't think you are comparing similar semantics.
>>
>>
>> System.gc() can be thought of as "I'm suggesting to the JVM that now is a
>> good time to perform GC", so it's as much about the state of things (known
>> to caller, unknown to JVM or else this wouldn't be needed).  We can agree
>> to disagree here, but I don't see "good time to run GC" vs "good time to
>> relax the CPU" as having any strong semantic differences.
>>
>>
>> System.gc() says "Runs the garbage collector". A name like System.onGC()
>> would mean "I'm running the garbage collector, and you may want to know
>> that (and do something about it)...".
>>
>> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
>> know about that (and do something about it)"
>>
>>
>> Consider the runtime as an object. You send it a message via a method.
>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>> applying an event but not expressing it via any convention.
>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>> intent or declare status for this. Hints don't fit comfortably in a
>>> programming model.
>>
>>
>> I should've been clearer, but I meant spinLoopHint on Thread was a better
>> proposal.  I agree that Runtime isn't the right place for something of that
>> name.
>>
>> The actual naming does not matter so much as this will only be used by
>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>> is desperately needed and anything that makes it slip the date to make Java
>>> 9 would be such a let down.
>>
>>
>> Agreed.  Ultimately someone will be unhappy with the name and/or
>> placement, but while these options are being discussed I think it'd be good
>> to hear multiple viewpoints.
>>
>> On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com>
>> wrote:
>>
>>>
>>> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>>
>>>> Relax was a suggested name that fits with the current Linux kernel
>>>>> convention. However it was felt this suggested implementation rather than
>>>>> notifying state.
>>>>
>>>>
>>>> Yes, 'relax' is a well known term for this, and sticking to known
>>>> conventions/terms is desirable.  I don't see how it suggests implementation
>>>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>>>> want to avoid any suggestions, let's call it "foobar" :).
>>>>
>>>
>>> Thread.relax() was my initial suggestion. I'll leave it to the others
>>> for why they did not think this was suitable.
>>>
>>>
>>>> The "on" prefix was suggested as the caller is notifying the runtime
>>>>> that it is in a spin-wait loop. This allows the runtime the option of
>>>>> reacting to the event, or not, and allows flexibility in how it chooses to
>>>>> react to this information. The method is not waiting; the method is
>>>>> notifying that the caller is waiting.
>>>>
>>>>
>>>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(),
>>>> and both of those are documented as "suggesting" the VM perform those
>>>> actions.  spinLoopHint() sounded much better than what's proposed here, and
>>>> carries the suggestion/hint/optionality that's desired.  IMHO, onSpinWait()
>>>> is the least appealing options proposed thus far.
>>>>
>>>
>>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>> instructions to the system/runtime to do something in an imperative
>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>> current thread. I can understand a dislike to a name. We all have personal
>>> taste on this but I don't think you are comparing similar semantics.
>>>
>>> Consider the runtime as an object. You send it a message via a method.
>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>> applying an event but not expressing it via any convention.
>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>> intent or declare status for this. Hints don't fit comfortably in a
>>> programming model.
>>>
>>> The actual naming does not matter so much as this will only be used by
>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>> is desperately needed and anything that makes it slip the date to make Java
>>> 9 would be such a let down.
>>>
>>> Martin...
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/d8e3f013/attachment.html>

From vitalyd at gmail.com  Tue Dec  1 11:38:17 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 11:38:17 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <AA611CDA-B112-47EC-B449-18D1F7D2DFC4@azul.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
	<CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>
	<28B1781D-7616-4BB1-BAC5-ECA492F72E44@azul.com>
	<CAHjP37Gkx6qcN=Z-7Gc0f6DtqGBs-kNgmAacUXZa16Zgtzu0Zw@mail.gmail.com>
	<AA611CDA-B112-47EC-B449-18D1F7D2DFC4@azul.com>
Message-ID: <CAHjP37FTTzHBG3=JBrMQxqHd4up6P2xP50nOQJJ+POp1mQx10w@mail.gmail.com>

Ok, carry on then :) Thanks for working on this, by the way -- I don't mean
to let the naming debate imply otherwise.

On Tue, Dec 1, 2015 at 11:35 AM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 1, 2015, at 8:02 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> See my earlier suggestion about keeping target user of this API in mind
> and the level of this API (i.e. low).
>
>
> In this sense (limited target audience that is very technical)
> Thread.foobar(), Thread.spinLoopHint(), Thread.relax(), and
> Runtime.onSpinWait() are all equivalent.
>
> The naming debate is mostly driven by longer term thinking, wanting to
> avoid unforeseen consequences, and s wish for readability. Which are the
> things that seem to drive most naming debates and make naming one of those
> hard things to do in CS.
>
> Given that it's already cost a month of elapsed time, I'd like to try to
> push forward with what we ended up with.
>
> As for doing nothing in the implementation, OK.  But I bet if someone
> using this API finds out it does nothing on their platform they're going to
> stop using this API and go back to manual hacks that have at least some
> chance of achieving desired results.  So while I understand the general
> motivation of not leaking implementation details, I don't agree this API is
> the appropriate place for that.
>
>
> The main driver for this JEP is the fact that in Java today, there are no
> good manual hack options, and on platforms that do support
> enhanced-performance spinning, spin wait loops written in Java remain
> inferior (in performance and reaction time) to ones written in other
> languages.
>
> I expect spin-loop writers to naturally use Runtime.onSpinWait() across
> platforms, accepting that it may do nothing on some (e.g. On platforms
> where no HW support for better spinning performance exists) and improve
> spinning performance on others. E.g. I fully expect the various disruptor
> waitFor() variants will still exist, but half of them will probably end up
> using Runtime.onSpinWait() for enhanced performance, and would do nothing
> different (in their Java code) for x86, Aarch64, Aarch32, Power, SPARC, or
> MIPS.
>
>
> On Tue, Dec 1, 2015 at 10:45 AM, Gil Tene <gil at azul.com> wrote:
>
>>
>>
>> Sent from Gil's iPhone
>>
>> On Dec 1, 2015, at 6:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> Thread.relax() was my initial suggestion. I'll leave it to the others for
>>> why they did not think this was suitable.
>>
>>
>> Yes, that would work for me as well although I'd prefer to have 'cpu' in
>> the name to be more clear.  But either way, sticking to known/common
>> nomenclature is good; ad-hoc names are not.
>>
>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>> instructions to the system/runtime to do something in an imperative
>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>> current thread. I can understand a dislike to a name. We all have personal
>>> taste on this but I don't think you are comparing similar semantics.
>>
>>
>> System.gc() can be thought of as "I'm suggesting to the JVM that now is a
>> good time to perform GC", so it's as much about the state of things (known
>> to caller, unknown to JVM or else this wouldn't be needed).  We can agree
>> to disagree here, but I don't see "good time to run GC" vs "good time to
>> relax the CPU" as having any strong semantic differences.
>>
>> Consider the runtime as an object. You send it a message via a method.
>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>> applying an event but not expressing it via any convention.
>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>> intent or declare status for this. Hints don't fit comfortably in a
>>> programming model.
>>
>>
>> I should've been clearer, but I meant spinLoopHint on Thread was a better
>> proposal.  I agree that Runtime isn't the right place for something of that
>> name.
>>
>>
>> Thread.spinLoopHint() was my first choice as well. But I was swayed by
>> strong arguments against "hint" in the method name. Including the lack of
>> "action" and ambiguity about roles. We looked at various names that were
>> either clear and way too long or way too short or implementation specific
>> (or narrowing), like skip, pause, relax, etc.
>>
>> Given the spec we agreed n, the name we were looking for was something
>> that would be equivalent to the obvious expectations from something named
>> as elaborately as:
>>
>> maybeYouShouldTryToImproveThePerformanceOfTheSpinWaitLoopMakingThisCall(),
>> with the receiver being either the thread or the runtime.
>>
>> The "maybe you should try" part is important because doing nothing is a
>> valid option, and accidentally failing to achieve the goal is probably ok,
>> but consistently working in the opposite direction of the goal would be
>> "surprising behavior". The "...making this call" part is important because
>> of ambiguities around roles and actions (the call is not expected to spin,
>> or wait, it's the caller that is doing those things).
>>
>> Given the natural way we'd describe what the options are for the receiver
>> in plain language, it became clear that Runtime fit better: we naturally
>> say "the runtime may..." and "indicate to the runtime...", not "the thread
>> may" or "indicate to the thread...". In addition, some of the
>> implementation possibilities (e.g. switch this thread to spin on a
>> dedicated core) may involve actions that are natural runtime actions but
>> far outside of the scope of what Thread might do.
>>
>> With an event delivery paradigm ("I'm in a spin wait loop, you may want
>> to do something about that") Runtime.onSpinWait() fits common naming
>> conventions and roles. It's also  readable enough to understand that the
>> Runtime is being told that a spin wait is going on. And in that sense, it
>> is just as expressive as spinLoopHint(), while actually following a naming
>> convention. We left the "try to improve the performance" to the
>> spec/JavaDoc because it was very hard to fit in the name.
>>
>>
>> The actual naming does not matter so much as this will only be used by
>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>> is desperately needed and anything that makes it slip the date to make Java
>>> 9 would be such a let down.
>>
>>
>> Agreed.  Ultimately someone will be unhappy with the name and/or
>> placement, but while these options are being discussed I think it'd be good
>> to hear multiple viewpoints.
>>
>> On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com>
>> wrote:
>>
>>>
>>> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>>
>>>> Relax was a suggested name that fits with the current Linux kernel
>>>>> convention. However it was felt this suggested implementation rather than
>>>>> notifying state.
>>>>
>>>>
>>>> Yes, 'relax' is a well known term for this, and sticking to known
>>>> conventions/terms is desirable.  I don't see how it suggests implementation
>>>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>>>> want to avoid any suggestions, let's call it "foobar" :).
>>>>
>>>
>>> Thread.relax() was my initial suggestion. I'll leave it to the others
>>> for why they did not think this was suitable.
>>>
>>>
>>>> The "on" prefix was suggested as the caller is notifying the runtime
>>>>> that it is in a spin-wait loop. This allows the runtime the option of
>>>>> reacting to the event, or not, and allows flexibility in how it chooses to
>>>>> react to this information. The method is not waiting; the method is
>>>>> notifying that the caller is waiting.
>>>>
>>>>
>>>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(),
>>>> and both of those are documented as "suggesting" the VM perform those
>>>> actions.  spinLoopHint() sounded much better than what's proposed here, and
>>>> carries the suggestion/hint/optionality that's desired.  IMHO, onSpinWait()
>>>> is the least appealing options proposed thus far.
>>>>
>>>
>>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>> instructions to the system/runtime to do something in an imperative
>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>> current thread. I can understand a dislike to a name. We all have personal
>>> taste on this but I don't think you are comparing similar semantics.
>>>
>>> Consider the runtime as an object. You send it a message via a method.
>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>> applying an event but not expressing it via any convention.
>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>> intent or declare status for this. Hints don't fit comfortably in a
>>> programming model.
>>>
>>> The actual naming does not matter so much as this will only be used by
>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>> is desperately needed and anything that makes it slip the date to make Java
>>> 9 would be such a let down.
>>>
>>> Martin...
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/238d1a5f/attachment-0001.html>

From thurston at nomagicsoftware.com  Tue Dec  1 15:50:38 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 1 Dec 2015 13:50:38 -0700 (MST)
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <87110734-3922-434C-B2D7-11F9AD0A5D0E@oracle.com>
References: <561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<561FC6F9.1080701@cs.oswego.edu> <562BC968.70603@cs.oswego.edu>
	<87110734-3922-434C-B2D7-11F9AD0A5D0E@oracle.com>
Message-ID: <1449003038953-12914.post@n7.nabble.com>

+1 for the API note

OK, I guess it is inherently fraught, but I still think it would be useful,
e.g. when clarifying when  (how often) to invoke it. i.e. someone might
(reasonably?) conclude that you should do:


Runtime.onSpinLoop()
while (spin-until-condition) {}


instead of:

while (spin-until-condition) 
{
    Runtime.onSpinLoop()
}





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Re-Spin-Loop-Hint-support-Draft-JEP-proposal-tp12784p12914.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vitalyd at gmail.com  Tue Dec  1 17:09:38 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 1 Dec 2015 17:09:38 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
In-Reply-To: <5588751D-240B-412A-AEB5-804C1A265617@azul.com>
References: <CAChYfd-i3MhHgVsrxOkV8qY8qQr-in_vjdktNFeQP-aUuwbU1Q@mail.gmail.com>
	<CAHjP37E2QKVPkZBxximH0+D_eoNPcoLY-j2N_Twe5hcxNdSSCw@mail.gmail.com>
	<CAChYfd9RxFw2WhDbKnG1pQtWNXONJrteiHjBhVkmDqT-W4wCWg@mail.gmail.com>
	<CAHjP37EJ2WS0TjGa0PD9U8hTOJHztwejzkXXyitDXpuQ4EVLGA@mail.gmail.com>
	<302AB4FF-6C68-487B-B4A3-7F0C51BA07CE@azul.com>
	<CAHjP37FcbWqSJsUcGSspy7HxE7xOpNxi+ZGoLLCiF_SJe-UmVg@mail.gmail.com>
	<7E31ACCE-0EA6-41D9-BBBE-ED19246FF834@azul.com>
	<CAHjP37GYiEt1t-ODouB90mpqzzsH6cY411CZadd_KQt5AFTWTw@mail.gmail.com>
	<5588751D-240B-412A-AEB5-804C1A265617@azul.com>
Message-ID: <CAHjP37GetK8DUetN3tcoUg5quSrzXu5VsSLZ=Z8QCK1JwCNPrw@mail.gmail.com>

>
> But can you live with it? Trust me, it grows on you... ;-). Especially
> when you end up defending it in an e-mail thread.


I can live with just about anything :).  I care more about the
functionality than the naming (despite what this thread may lead you to
believe), but I doubt it'll grow on me :).

On Tue, Dec 1, 2015 at 11:38 AM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 1, 2015, at 8:29 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> I suggested relax because it's a commonly used name for this effect.  With
> no prior art in this area, I'd agree that relax can be misinterpreted.  But
> I'm just as happy with your original spinLoopHint on the Thread class, to
> be honest.
>
>
> I liked it too. But was willing to give up on it given the strong
> arguments and opinions against it, and in the interest of getting something
> acceptable done.
>
> I just don't like onSpinWait() on the Runtime class.
>
>
> But can you live with it? Trust me, it grows on you... ;-). Especially
> when you end up defending it in an e-mail thread.
>
>
>
> On Tue, Dec 1, 2015 at 11:19 AM, Gil Tene <gil at azul.com> wrote:
>
>>
>>
>> Sent from Gil's iPhone
>>
>> On Dec 1, 2015, at 7:32 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> On why "relax" (or other "this is how it will be achieved" naming
>>> options) are not a good fit IMO:
>>
>>
>> But relax, although a common term for this scenario, is still vague
>> enough as to not indicate exactly how it does this, so I don't see any
>> leakage of implementation details.  Moreover, the niche target users of
>> this API are likely going to know exactly what they want at the machine
>> instruction level on the platform(s) they care about.  This isn't some
>> widely applicable general purpose API -- it's a low level API, and low
>> level APIs should not be intentionally vague.  I'm almost certain that 99%
>> of people using this API will know, either ahead of time or by researching,
>> exactly what happens under the hood.  When trying to control things at this
>> level, implementation details start to matter.
>>
>>
>> The goal of the call is not to relax the CPU. It is to improve the
>> performance of the spin loop.
>>
>> This makes goal the opposite of what "relax" suggests. While the spec
>> rules (and clearly says that performance improvement is the goal), we'd
>> probably agree that names like "chill()", "slowDown()", or
>> "dontBotherWithSpeed()" would be a bad fit. "Relax" fits right in with
>> those...
>>
>> The fact that the performance-enhancing goal can actually be technically
>> achieved in some specific CPUs by relaxing their execution in specific ways
>> is surprising in itself. It makes for interesting conversation ("wow, who
>> knew that relaxing the aggressiveness of speculation might actually make
>> the reaction time faster?"), but the fact that it's interesting and
>> surprising is a good indication that it is a bad name choice.
>>
>> There are various ways to relax CPUs that are wrong to use for the goal
>> of the call, but would be natural for something called "relax". These
>> include deeper cstates in x86, variations of MWAIT with short timeouts on
>> various CPUs, and even instructions named "pause" on some platforms that
>> consistently hurt performance but help save power. These make it clear that
>> if we used "relax" as a name in this spin wait loop performance context, we
>> actually mean "relaxInA2015x86PauseInstructionSense()"...
>>
>>
>> As for optionality, yes, you may want to convey that.  But I don't think
>> it necessarily has to be in the name - javadoc is more than sufficient.
>> Again, let's keep in mind target audience.
>>
>> System.gc() says "Runs the garbage collector". A name like System.onGC()
>>> would mean "I'm running the garbage collector, and you may want to know
>>> that (and do something about it)...".
>>> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
>>> know about that (and do something about it)"
>>
>>
>> The 2nd sentence of Runtime.gc() javadoc begins with (emphasis mine)
>> "Calling this method *suggests* that the Java virtual machine expend
>> effort ...".  We all know that there's ways to disable explicit GC from
>> doing anything at all, so although the name isn't Runtime.maybeGC() or
>> Runtime.gcHint() or whatever, anyone exploring this (also somewhat niche,
>> relatively speaking) API will quickly learn that it doesn't guarantee
>> anything.
>>
>> I'll just reiterate that I think target audience of this API should be
>> kept in mind; it's low level functionality and there's no need to try and
>> obfuscate it.
>>
>>
>> On Tue, Dec 1, 2015 at 10:15 AM, Gil Tene <gil at azul.com> wrote:
>>
>>>
>>>
>>> Sent from Gil's iPhone
>>>
>>> On Dec 1, 2015, at 6:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>>
>>> Thread.relax() was my initial suggestion. I'll leave it to the others
>>>> for why they did not think this was suitable.
>>>
>>>
>>> Yes, that would work for me as well although I'd prefer to have 'cpu' in
>>> the name to be more clear.  But either way, sticking to known/common
>>> nomenclature is good; ad-hoc names are not.
>>>
>>>
>>> On why "relax" (or other "this is how it will be achieved" naming
>>> options) are not a good fit IMO:
>>>
>>> "Relaxing" the CPU is one specific possibility for what the JVM might
>>> want to do to improve the performance and responsiveness of a spin wait
>>> loop. E.g. The JVM might achieve the desired improvement by doing other
>>> things in conjunction with, or in place of relaxing the CPU. Such as
>>> affecting scheduling priority or affinity, or doing some other thing that
>>> might reduce the likelihood of yielding the CPU. In addition , depending on
>>> platform, relaxing the CPU may be the wing thing to do: i.e. Some of the
>>> CPU-relaxing options on some platforms dramatically reduce the performance
>>> of a spin wait loops and increase their reaction time (rather than improve
>>> and reduce).
>>>
>>> I wanted the name to suggest intent without dictating implementation,
>>> and for the spec to make it clear that improving the performance of a spin
>>> wait loop construct is the intended (or hoped for) result without
>>> committing to actually achieving that. The runtime may choose to ignore the
>>> indication, but it would be surprising for it to make things "worse" for
>>> the calling spin wait loop compared to code that doesn't make the same call.
>>>
>>>
>>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>>> instructions to the system/runtime to do something in an imperative
>>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>>> current thread. I can understand a dislike to a name. We all have personal
>>>> taste on this but I don't think you are comparing similar semantics.
>>>
>>>
>>> System.gc() can be thought of as "I'm suggesting to the JVM that now is
>>> a good time to perform GC", so it's as much about the state of things
>>> (known to caller, unknown to JVM or else this wouldn't be needed).  We can
>>> agree to disagree here, but I don't see "good time to run GC" vs "good time
>>> to relax the CPU" as having any strong semantic differences.
>>>
>>>
>>> System.gc() says "Runs the garbage collector". A name like System.onGC()
>>> would mean "I'm running the garbage collector, and you may want to know
>>> that (and do something about it)...".
>>>
>>> Runtime.onSpinWait() means "I'm doing a spin wait, and you might want to
>>> know about that (and do something about it)"
>>>
>>>
>>> Consider the runtime as an object. You send it a message via a method.
>>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>>> applying an event but not expressing it via any convention.
>>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>>> intent or declare status for this. Hints don't fit comfortably in a
>>>> programming model.
>>>
>>>
>>> I should've been clearer, but I meant spinLoopHint on Thread was a
>>> better proposal.  I agree that Runtime isn't the right place for something
>>> of that name.
>>>
>>> The actual naming does not matter so much as this will only be used by
>>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>>> is desperately needed and anything that makes it slip the date to make Java
>>>> 9 would be such a let down.
>>>
>>>
>>> Agreed.  Ultimately someone will be unhappy with the name and/or
>>> placement, but while these options are being discussed I think it'd be good
>>> to hear multiple viewpoints.
>>>
>>> On Tue, Dec 1, 2015 at 9:13 AM, Martin Thompson <mjpt777 at gmail.com>
>>> wrote:
>>>
>>>>
>>>> On 1 December 2015 at 13:46, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>>
>>>>> Relax was a suggested name that fits with the current Linux kernel
>>>>>> convention. However it was felt this suggested implementation rather than
>>>>>> notifying state.
>>>>>
>>>>>
>>>>> Yes, 'relax' is a well known term for this, and sticking to known
>>>>> conventions/terms is desirable.  I don't see how it suggests implementation
>>>>> though, nor even if it did suggest anything, why that's a bad thing.  If we
>>>>> want to avoid any suggestions, let's call it "foobar" :).
>>>>>
>>>>
>>>> Thread.relax() was my initial suggestion. I'll leave it to the others
>>>> for why they did not think this was suitable.
>>>>
>>>>
>>>>> The "on" prefix was suggested as the caller is notifying the runtime
>>>>>> that it is in a spin-wait loop. This allows the runtime the option of
>>>>>> reacting to the event, or not, and allows flexibility in how it chooses to
>>>>>> react to this information. The method is not waiting; the method is
>>>>>> notifying that the caller is waiting.
>>>>>
>>>>>
>>>>> Yes, but we don't have Runtime.onGC() or Runtime.onRunFinalization(),
>>>>> and both of those are documented as "suggesting" the VM perform those
>>>>> actions.  spinLoopHint() sounded much better than what's proposed here, and
>>>>> carries the suggestion/hint/optionality that's desired.  IMHO, onSpinWait()
>>>>> is the least appealing options proposed thus far.
>>>>>
>>>>
>>>> System.gc() and Runtime.runFinalizersOnExit(boolean) are clear
>>>> instructions to the system/runtime to do something in an imperative
>>>> fashion. The onSpinWait() is a declarative statement about the state of the
>>>> current thread. I can understand a dislike to a name. We all have personal
>>>> taste on this but I don't think you are comparing similar semantics.
>>>>
>>>> Consider the runtime as an object. You send it a message via a method.
>>>> What exactly is spinLoopHint() telling the Runtime what to do? It is
>>>> applying an event but not expressing it via any convention.
>>>> "spinLoopHint()" works for me on a Thread to an extent. We should express
>>>> intent or declare status for this. Hints don't fit comfortably in a
>>>> programming model.
>>>>
>>>> The actual naming does not matter so much as this will only be used by
>>>> minority of programmers. I'll prepare to be flamed on that :-) However it
>>>> is desperately needed and anything that makes it slip the date to make Java
>>>> 9 would be such a let down.
>>>>
>>>> Martin...
>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151201/8faff789/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Wed Dec  2 05:34:13 2015
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 2 Dec 2015 10:34:13 +0000
Subject: [concurrency-interest] A puzzle about recursive functions in
	CompletableFuture
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>

Hello there,

I have thought of a way of doing tail-recursion elimination with CompletableFuture. It works, but I do not understand why. There must be some inter-thread communication going on about which I have not been able to find documentation. Perhaps someone here can enlighten me.

This particular way of doing TRE is not in itself especially worthwhile, because it is almost trivial to transform a tail-recursive function into a loop manually. However, I think it?s still interesting. So, as an example let's use this tail-recursive definition of the Fibonacci series:

public static BigInteger fibTailRecursive(int n) {
    return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
}

private static BigInteger fibTailRecursiveAux(int n, BigInteger a, BigInteger b) {
    return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
}

And here is the "optimized" version with TRE, in which the elementary case and recursive case are wrapped in methods that return a CompletableFuture:

public static BigInteger fibCF(int n) {
        return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
}

private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a, BigInteger b) {
        return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b, a.add(b)));
}

This is similar to Pierre-Yves Saumont's approach (cf. http://www.javacodegeeks.com/2015/10/stack-safe-recursion-in-java.html). However, his implementation uses custom classes and an explicit while-loop. With TRE I can compute e. g. fibCF(5000), although the recursive version normally encounters a StackOverflowError at around n = 1550 on my machine.

Finally, here are my problematic implementations of terminate() and tailcall():

public static <T> CompletableFuture<T> terminate(T t) {
        return completedFuture(t);
}

public static <T> CompletableFuture<T> tailcall(Supplier<CompletableFuture<T>> s) {
        return CF.thenComposeAsync(_x -> s.get(), THREAD);
}

private static final CompletableFuture<?> CF = completedFuture(null);
private static final Executor THREAD = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).build());

(The ThreadFactoryBuilder is from Guava.)

The interesting thing is that the recursive call is inside the lambda, so cannot be seen by the completion handler. It is essential that I use thenComposeAsync() and a dedicated thread. Using either thenCompose() or a current-thread Executor (Executor e = Runnable::run) will lead to the dreaded SOE. So there must be some implicit interaction between the current thread and the dedicated thread that prevents this.

I suspect it may have to do with the fact that the "dummy" future CF is already completed, so the downstream task would by default be completed in the client thread, but is then somehow handed off to the explicitly required dedicated thread, with the "recursive" call being landed in the client thread again. But how would this prevent SOE?

Could anyone explain to me, please, how my coding works?

-- Sebastian Millies




Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com



From viktor.klang at gmail.com  Wed Dec  2 05:52:45 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 2 Dec 2015 11:52:45 +0100
Subject: [concurrency-interest] A puzzle about recursive functions in
	CompletableFuture
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU-+Ti2dyr-S7t0txDo9OHoTEijw5tZuUWbL7tf2Rauntg@mail.gmail.com>

Isn't this "simply" trampolining on the submission queue of the Executor?

(I informally call it async tailcalls)

On Wed, Dec 2, 2015 at 11:34 AM, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> Hello there,
>
> I have thought of a way of doing tail-recursion elimination with
> CompletableFuture. It works, but I do not understand why. There must be
> some inter-thread communication going on about which I have not been able
> to find documentation. Perhaps someone here can enlighten me.
>
> This particular way of doing TRE is not in itself especially worthwhile,
> because it is almost trivial to transform a tail-recursive function into a
> loop manually. However, I think it?s still interesting. So, as an example
> let's use this tail-recursive definition of the Fibonacci series:
>
> public static BigInteger fibTailRecursive(int n) {
>     return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
> }
>
> private static BigInteger fibTailRecursiveAux(int n, BigInteger a,
> BigInteger b) {
>     return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
> }
>
> And here is the "optimized" version with TRE, in which the elementary case
> and recursive case are wrapped in methods that return a CompletableFuture:
>
> public static BigInteger fibCF(int n) {
>         return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
> }
>
> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a,
> BigInteger b) {
>         return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b,
> a.add(b)));
> }
>
> This is similar to Pierre-Yves Saumont's approach (cf.
> http://www.javacodegeeks.com/2015/10/stack-safe-recursion-in-java.html).
> However, his implementation uses custom classes and an explicit while-loop.
> With TRE I can compute e. g. fibCF(5000), although the recursive version
> normally encounters a StackOverflowError at around n = 1550 on my machine.
>
> Finally, here are my problematic implementations of terminate() and
> tailcall():
>
> public static <T> CompletableFuture<T> terminate(T t) {
>         return completedFuture(t);
> }
>
> public static <T> CompletableFuture<T>
> tailcall(Supplier<CompletableFuture<T>> s) {
>         return CF.thenComposeAsync(_x -> s.get(), THREAD);
> }
>
> private static final CompletableFuture<?> CF = completedFuture(null);
> private static final Executor THREAD =
> Executors.newSingleThreadExecutor(new
> ThreadFactoryBuilder().setDaemon(true).build());
>
> (The ThreadFactoryBuilder is from Guava.)
>
> The interesting thing is that the recursive call is inside the lambda, so
> cannot be seen by the completion handler. It is essential that I use
> thenComposeAsync() and a dedicated thread. Using either thenCompose() or a
> current-thread Executor (Executor e = Runnable::run) will lead to the
> dreaded SOE. So there must be some implicit interaction between the current
> thread and the dedicated thread that prevents this.
>
> I suspect it may have to do with the fact that the "dummy" future CF is
> already completed, so the downstream task would by default be completed in
> the client thread, but is then somehow handed off to the explicitly
> required dedicated thread, with the "recursive" call being landed in the
> client thread again. But how would this prevent SOE?
>
> Could anyone explain to me, please, how my coding works?
>
> -- Sebastian Millies
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - http://www.softwareag.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/524fab82/attachment.html>

From Sebastian.Millies at softwareag.com  Wed Dec  2 06:18:23 2015
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 2 Dec 2015 11:18:23 +0000
Subject: [concurrency-interest] A puzzle about recursive functions in
 CompletableFuture
In-Reply-To: <CANPzfU-+Ti2dyr-S7t0txDo9OHoTEijw5tZuUWbL7tf2Rauntg@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<CANPzfU-+Ti2dyr-S7t0txDo9OHoTEijw5tZuUWbL7tf2Rauntg@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102DE71C9@HQMBX5.eur.ad.sag>

if that were all there is to it, should it not work also when using the current thread executor? What would then be different about the trampolining?

n  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Wednesday, December 02, 2015 11:53 AM
To: Millies, Sebastian
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] A puzzle about recursive functions in CompletableFuture

Isn't this "simply" trampolining on the submission queue of the Executor?

(I informally call it async tailcalls)

On Wed, Dec 2, 2015 at 11:34 AM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Hello there,

I have thought of a way of doing tail-recursion elimination with CompletableFuture. It works, but I do not understand why. There must be some inter-thread communication going on about which I have not been able to find documentation. Perhaps someone here can enlighten me.

This particular way of doing TRE is not in itself especially worthwhile, because it is almost trivial to transform a tail-recursive function into a loop manually. However, I think it?s still interesting. So, as an example let's use this tail-recursive definition of the Fibonacci series:

public static BigInteger fibTailRecursive(int n) {
    return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
}

private static BigInteger fibTailRecursiveAux(int n, BigInteger a, BigInteger b) {
    return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
}

And here is the "optimized" version with TRE, in which the elementary case and recursive case are wrapped in methods that return a CompletableFuture:

public static BigInteger fibCF(int n) {
        return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
}

private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a, BigInteger b) {
        return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b, a.add(b)));
}

This is similar to Pierre-Yves Saumont's approach (cf. http://www.javacodegeeks.com/2015/10/stack-safe-recursion-in-java.html). However, his implementation uses custom classes and an explicit while-loop. With TRE I can compute e. g. fibCF(5000), although the recursive version normally encounters a StackOverflowError at around n = 1550 on my machine.

Finally, here are my problematic implementations of terminate() and tailcall():

public static <T> CompletableFuture<T> terminate(T t) {
        return completedFuture(t);
}

public static <T> CompletableFuture<T> tailcall(Supplier<CompletableFuture<T>> s) {
        return CF.thenComposeAsync(_x -> s.get(), THREAD);
}

private static final CompletableFuture<?> CF = completedFuture(null);
private static final Executor THREAD = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).build());

(The ThreadFactoryBuilder is from Guava.)

The interesting thing is that the recursive call is inside the lambda, so cannot be seen by the completion handler. It is essential that I use thenComposeAsync() and a dedicated thread. Using either thenCompose() or a current-thread Executor (Executor e = Runnable::run) will lead to the dreaded SOE. So there must be some implicit interaction between the current thread and the dedicated thread that prevents this.

I suspect it may have to do with the fact that the "dummy" future CF is already completed, so the downstream task would by default be completed in the client thread, but is then somehow handed off to the explicitly required dedicated thread, with the "recursive" call being landed in the client thread again. But how would this prevent SOE?

Could anyone explain to me, please, how my coding works?

-- Sebastian Millies




Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



--
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/5abace8b/attachment-0001.html>

From viktor.klang at gmail.com  Wed Dec  2 06:56:43 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 2 Dec 2015 12:56:43 +0100
Subject: [concurrency-interest] A puzzle about recursive functions in
	CompletableFuture
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102DE71C9@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<CANPzfU-+Ti2dyr-S7t0txDo9OHoTEijw5tZuUWbL7tf2Rauntg@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102DE71C9@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU98uQyi49sZmRNqfuhB-VV=jJNzG0WA6X8HTtR=Axrsnw@mail.gmail.com>

Sadly, as the JVM (still) does not support tail call optimization so it has
to grow the stack instead.

On Wed, Dec 2, 2015 at 12:18 PM, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> if that were all there is to it, should it not work also when using the
> current thread executor? What would then be different about the
> trampolining?
>
> n  Sebastian
>
>
>
> *From:* Viktor Klang [mailto:viktor.klang at gmail.com]
> *Sent:* Wednesday, December 02, 2015 11:53 AM
> *To:* Millies, Sebastian
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] A puzzle about recursive functions
> in CompletableFuture
>
>
>
> Isn't this "simply" trampolining on the submission queue of the Executor?
>
> (I informally call it async tailcalls)
>
>
>
> On Wed, Dec 2, 2015 at 11:34 AM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
> Hello there,
>
> I have thought of a way of doing tail-recursion elimination with
> CompletableFuture. It works, but I do not understand why. There must be
> some inter-thread communication going on about which I have not been able
> to find documentation. Perhaps someone here can enlighten me.
>
> This particular way of doing TRE is not in itself especially worthwhile,
> because it is almost trivial to transform a tail-recursive function into a
> loop manually. However, I think it?s still interesting. So, as an example
> let's use this tail-recursive definition of the Fibonacci series:
>
> public static BigInteger fibTailRecursive(int n) {
>     return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
> }
>
> private static BigInteger fibTailRecursiveAux(int n, BigInteger a,
> BigInteger b) {
>     return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
> }
>
> And here is the "optimized" version with TRE, in which the elementary case
> and recursive case are wrapped in methods that return a CompletableFuture:
>
> public static BigInteger fibCF(int n) {
>         return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
> }
>
> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a,
> BigInteger b) {
>         return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b,
> a.add(b)));
> }
>
> This is similar to Pierre-Yves Saumont's approach (cf.
> http://www.javacodegeeks.com/2015/10/stack-safe-recursion-in-java.html).
> However, his implementation uses custom classes and an explicit while-loop.
> With TRE I can compute e. g. fibCF(5000), although the recursive version
> normally encounters a StackOverflowError at around n = 1550 on my machine.
>
> Finally, here are my problematic implementations of terminate() and
> tailcall():
>
> public static <T> CompletableFuture<T> terminate(T t) {
>         return completedFuture(t);
> }
>
> public static <T> CompletableFuture<T>
> tailcall(Supplier<CompletableFuture<T>> s) {
>         return CF.thenComposeAsync(_x -> s.get(), THREAD);
> }
>
> private static final CompletableFuture<?> CF = completedFuture(null);
> private static final Executor THREAD =
> Executors.newSingleThreadExecutor(new
> ThreadFactoryBuilder().setDaemon(true).build());
>
> (The ThreadFactoryBuilder is from Guava.)
>
> The interesting thing is that the recursive call is inside the lambda, so
> cannot be seen by the completion handler. It is essential that I use
> thenComposeAsync() and a dedicated thread. Using either thenCompose() or a
> current-thread Executor (Executor e = Runnable::run) will lead to the
> dreaded SOE. So there must be some implicit interaction between the current
> thread and the dedicated thread that prevents this.
>
> I suspect it may have to do with the fact that the "dummy" future CF is
> already completed, so the downstream task would by default be completed in
> the client thread, but is then somehow handed off to the explicitly
> required dedicated thread, with the "recursive" call being landed in the
> client thread again. But how would this prevent SOE?
>
> Could anyone explain to me, please, how my coding works?
>
> -- Sebastian Millies
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - http://www.softwareag.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/d1c2b745/attachment.html>

From aaron.grunthal at infinite-source.de  Wed Dec  2 07:48:45 2015
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Wed, 2 Dec 2015 13:48:45 +0100
Subject: [concurrency-interest] A puzzle about recursive functions in
 CompletableFuture
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102DE71C9@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<CANPzfU-+Ti2dyr-S7t0txDo9OHoTEijw5tZuUWbL7tf2Rauntg@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102DE71C9@HQMBX5.eur.ad.sag>
Message-ID: <565EE8AD.5030607@infinite-source.de>

That depends how the current-thread-executor is implemented. If the
execute method always executes the submitted tasks down-stack then it'll
lead to a SOE. If it uses an internal queue when it knows that there is
a loop polling tasks from the queue somewhere up-stack then you
effectively have trampolining implemented in the executor.

On 02.12.2015 12:18, Millies, Sebastian wrote:
> if that were all there is to it, should it not work also when using the
> current thread executor? What would then be different about the
> trampolining?


From dl at cs.oswego.edu  Wed Dec  2 07:52:07 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 2 Dec 2015 07:52:07 -0500
Subject: [concurrency-interest] A puzzle about recursive functions in
 CompletableFuture
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
Message-ID: <565EE977.3020009@cs.oswego.edu>

On 12/02/2015 05:34 AM, Millies, Sebastian wrote:
> I have thought of a way of doing tail-recursion elimination with CompletableFuture. It works, but I do not understand why. There must be some inter-thread communication going on about which I have not been able to find documentation. Perhaps someone here can enlighten me.
>
> public static BigInteger fibTailRecursive(int n) {
>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
> }
>
> private static BigInteger fibTailRecursiveAux(int n, BigInteger a, BigInteger b) {
>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
> }
>
> And here is the "optimized" version with TRE,
>
> public static BigInteger fibCF(int n) {
>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
> }
>
> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a, BigInteger b) {
>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b, a.add(b)));
> }
>
> Finally, here are my problematic implementations of terminate() and tailcall():
>
> public static <T> CompletableFuture<T> terminate(T t) {
>          return completedFuture(t);
> }
>
> public static <T> CompletableFuture<T> tailcall(Supplier<CompletableFuture<T>> s) {
>          return CF.thenComposeAsync(_x -> s.get(), THREAD);
> }

(Using default Async would work at least as well.
Aside: using direct executors (run in the same thread as caller)
is almost never a good idea with CompletableFutures.)

>
> private static final CompletableFuture<?> CF = completedFuture(null);
> private static final Executor THREAD = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).build());
>

This is a variation of the issues brought up by Chris Purcell a few months
ago. In async mode, CF generally avoids StackOverflowError (SOE),
because threads help clear out dependent tasks, which they do anyway to
maximize parallelism.

In non-async mode, you can still get SOE because java compilers do not
loopify tail recursion. It would be possible to better avoid this
kind of non-async SOE by thread-local trampolining at the expense
of reducing parallelism, so we don't want to do it.

It's still an open question whether we can find some scheme that
combines both advantages.

In the mean time, there is some sentiment that default thread stack
sizes on 64bit JVMs should be expanded keep up with the times. On
32bit systems the 1MB limit is completely defensible. But expanding
to say 64MB on 64bit systems would reduce practical encounters with
SOE in these kinds of constructions by a factor of 64 or so.

-Doug



From nathan.reynolds at oracle.com  Wed Dec  2 12:40:01 2015
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Wed, 2 Dec 2015 10:40:01 -0700
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <565EE977.3020009@cs.oswego.edu>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu>
Message-ID: <565F2CF1.90204@oracle.com>

 > In the mean time, there is some sentiment that default thread stack 
sizes on 64bit JVMs should be expanded keep up with the times. On 32bit 
systems the 1MB limit is completely defensible. But expanding to say 
64MB on 64bit systems would reduce practical encounters with SOE in 
these kinds of constructions by a factor of 64 or so.

I've had this debate on a C++ application as well.  The debate started 
because a lot of people were working on stack overflow issues.  Each 
time I would tell them to first fix the infinite recursion issue.  They 
would try to take the easy route and would set the stack size to 
something very large and hope the problem would go away.  It didn't.  
After the recursion bugs were eliminated, we got to the point where the 
application really did need to do that much recursion and the recursion 
was acceptably finite.  We then went with larger stack sizes and chose a 
sane default size.  After changing the default size, we bumped into a 
couple of problems.  Nothing that says we shouldn't increase the stack 
size but maybe it should be documented.

First, the larger stack size eats up address space.  As far as resources 
go, it is very cheap at this point in time on a 64-bit machine.  25 
years ago we said the same thing about virtual address space on 32-bit 
machines.  We've got about 60 years before we will start exhausting the 
64-bit address space.  So, let's ignore that for now.  Today's problem 
comes when doing sizing calculations. People will see the address space 
size and figure that is what is needed for the process in terms of RAM.  
Then the entire sizing calculation goes haywire and machines end up over 
sized.  As a cloud provider, I don't mind people spending more money on 
RAM they aren't using.  :)

Second, it can take a while to overflow the 1 MB stack.  I've had a 
couple of situations where it took several minutes in Java to cause a 
stack overflow.  Obviously, the program isn't just doing recursive 
calls.  There is a computation or GC happening all the way down the 
stack.  A 64 MB stack would take a couple of hours.  This means the 
thread is busy for a long time and other operations will *hopefully* 
timeout waiting for it.

I think a smart approach would be to examine code (open source?) or 
production deployments and see how often the stack sizing parameter is 
used and what value it is set to.  This will give us a good idea if the 
default stack size needs to be adjusted and what is a good stack size to 
use.

-Nathan

On 12/2/2015 5:52 AM, Doug Lea wrote:
> On 12/02/2015 05:34 AM, Millies, Sebastian wrote:
>> I have thought of a way of doing tail-recursion elimination with 
>> CompletableFuture. It works, but I do not understand why. There must 
>> be some inter-thread communication going on about which I have not 
>> been able to find documentation. Perhaps someone here can enlighten me.
>>
>> public static BigInteger fibTailRecursive(int n) {
>>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
>> }
>>
>> private static BigInteger fibTailRecursiveAux(int n, BigInteger a, 
>> BigInteger b) {
>>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
>> }
>>
>> And here is the "optimized" version with TRE,
>>
>> public static BigInteger fibCF(int n) {
>>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
>> }
>>
>> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger 
>> a, BigInteger b) {
>>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, 
>> b, a.add(b)));
>> }
>>
>> Finally, here are my problematic implementations of terminate() and 
>> tailcall():
>>
>> public static <T> CompletableFuture<T> terminate(T t) {
>>          return completedFuture(t);
>> }
>>
>> public static <T> CompletableFuture<T> 
>> tailcall(Supplier<CompletableFuture<T>> s) {
>>          return CF.thenComposeAsync(_x -> s.get(), THREAD);
>> }
>
> (Using default Async would work at least as well.
> Aside: using direct executors (run in the same thread as caller)
> is almost never a good idea with CompletableFutures.)
>
>>
>> private static final CompletableFuture<?> CF = completedFuture(null);
>> private static final Executor THREAD = 
>> Executors.newSingleThreadExecutor(new 
>> ThreadFactoryBuilder().setDaemon(true).build());
>>
>
> This is a variation of the issues brought up by Chris Purcell a few 
> months
> ago. In async mode, CF generally avoids StackOverflowError (SOE),
> because threads help clear out dependent tasks, which they do anyway to
> maximize parallelism.
>
> In non-async mode, you can still get SOE because java compilers do not
> loopify tail recursion. It would be possible to better avoid this
> kind of non-async SOE by thread-local trampolining at the expense
> of reducing parallelism, so we don't want to do it.
>
> It's still an open question whether we can find some scheme that
> combines both advantages.
>
> In the mean time, there is some sentiment that default thread stack
> sizes on 64bit JVMs should be expanded keep up with the times. On
> 32bit systems the 1MB limit is completely defensible. But expanding
> to say 64MB on 64bit systems would reduce practical encounters with
> SOE in these kinds of constructions by a factor of 64 or so.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/62aa4b49/attachment.html>

From vitalyd at gmail.com  Wed Dec  2 13:23:59 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 2 Dec 2015 13:23:59 -0500
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <565F2CF1.90204@oracle.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
Message-ID: <CAHjP37EfhPVDf0qxhqwNrwmamG8_M53SqLijzWxKYtvuNxPfXg@mail.gmail.com>

On linux, thread stacks count in commit charge, even if some/most of the VA
space is unused.  If you disable overcommit and bump stack size
significantly, you may start to hit OOM issues even on 64bit machines if
you create enough threads.

C++ stack usage is expected to be higher than Java since C++ apps stack
alloc a lot more.

On Wed, Dec 2, 2015 at 12:40 PM, Nathan Reynolds <nathan.reynolds at oracle.com
> wrote:

> > In the mean time, there is some sentiment that default thread stack
> sizes on 64bit JVMs should be expanded keep up with the times. On 32bit
> systems the 1MB limit is completely defensible. But expanding to say 64MB
> on 64bit systems would reduce practical encounters with SOE in these kinds
> of constructions by a factor of 64 or so.
>
> I've had this debate on a C++ application as well.  The debate started
> because a lot of people were working on stack overflow issues.  Each time I
> would tell them to first fix the infinite recursion issue.  They would try
> to take the easy route and would set the stack size to something very large
> and hope the problem would go away.  It didn't.  After the recursion bugs
> were eliminated, we got to the point where the application really did need
> to do that much recursion and the recursion was acceptably finite.  We then
> went with larger stack sizes and chose a sane default size.  After changing
> the default size, we bumped into a couple of problems.  Nothing that says
> we shouldn't increase the stack size but maybe it should be documented.
>
> First, the larger stack size eats up address space.  As far as resources
> go, it is very cheap at this point in time on a 64-bit machine.  25 years
> ago we said the same thing about virtual address space on 32-bit machines.
> We've got about 60 years before we will start exhausting the 64-bit address
> space.  So, let's ignore that for now.  Today's problem comes when doing
> sizing calculations.  People will see the address space size and figure
> that is what is needed for the process in terms of RAM.  Then the entire
> sizing calculation goes haywire and machines end up over sized.  As a cloud
> provider, I don't mind people spending more money on RAM they aren't
> using.  :)
>
> Second, it can take a while to overflow the 1 MB stack.  I've had a couple
> of situations where it took several minutes in Java to cause a stack
> overflow.  Obviously, the program isn't just doing recursive calls.  There
> is a computation or GC happening all the way down the stack.  A 64 MB stack
> would take a couple of hours.  This means the thread is busy for a long
> time and other operations will *hopefully* timeout waiting for it.
>
> I think a smart approach would be to examine code (open source?) or
> production deployments and see how often the stack sizing parameter is used
> and what value it is set to.  This will give us a good idea if the default
> stack size needs to be adjusted and what is a good stack size to use.
>
> -Nathan
>
> On 12/2/2015 5:52 AM, Doug Lea wrote:
>
> On 12/02/2015 05:34 AM, Millies, Sebastian wrote:
>
> I have thought of a way of doing tail-recursion elimination with
> CompletableFuture. It works, but I do not understand why. There must be
> some inter-thread communication going on about which I have not been able
> to find documentation. Perhaps someone here can enlighten me.
>
> public static BigInteger fibTailRecursive(int n) {
>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
> }
>
> private static BigInteger fibTailRecursiveAux(int n, BigInteger a,
> BigInteger b) {
>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
> }
>
> And here is the "optimized" version with TRE,
>
> public static BigInteger fibCF(int n) {
>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
> }
>
> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a,
> BigInteger b) {
>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b,
> a.add(b)));
> }
>
> Finally, here are my problematic implementations of terminate() and
> tailcall():
>
> public static <T> CompletableFuture<T> terminate(T t) {
>          return completedFuture(t);
> }
>
> public static <T> CompletableFuture<T>
> tailcall(Supplier<CompletableFuture<T>> s) {
>          return CF.thenComposeAsync(_x -> s.get(), THREAD);
> }
>
>
> (Using default Async would work at least as well.
> Aside: using direct executors (run in the same thread as caller)
> is almost never a good idea with CompletableFutures.)
>
>
> private static final CompletableFuture<?> CF = completedFuture(null);
> private static final Executor THREAD =
> Executors.newSingleThreadExecutor(new
> ThreadFactoryBuilder().setDaemon(true).build());
>
>
> This is a variation of the issues brought up by Chris Purcell a few months
> ago. In async mode, CF generally avoids StackOverflowError (SOE),
> because threads help clear out dependent tasks, which they do anyway to
> maximize parallelism.
>
> In non-async mode, you can still get SOE because java compilers do not
> loopify tail recursion. It would be possible to better avoid this
> kind of non-async SOE by thread-local trampolining at the expense
> of reducing parallelism, so we don't want to do it.
>
> It's still an open question whether we can find some scheme that
> combines both advantages.
>
> In the mean time, there is some sentiment that default thread stack
> sizes on 64bit JVMs should be expanded keep up with the times. On
> 32bit systems the 1MB limit is completely defensible. But expanding
> to say 64MB on 64bit systems would reduce practical encounters with
> SOE in these kinds of constructions by a factor of 64 or so.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/40b44d4f/attachment-0001.html>

From hanson.char at gmail.com  Wed Dec  2 13:29:32 2015
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 2 Dec 2015 10:29:32 -0800
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <565F2CF1.90204@oracle.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
Message-ID: <CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>

Has it been considered to eliminate the use of recursion entirely from the
concurrency library (or for that matter the JDK) ?  Any need for recursion
can be readily transformed into the use of a stack.  This doesn't help
prevent anyone abusing the library, but would eliminate the need to explain
StackOverFlow error.  Shift the usage responsibility to the caller.

2 cents.

Hanson

On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <nathan.reynolds at oracle.com>
wrote:

> > In the mean time, there is some sentiment that default thread stack
> sizes on 64bit JVMs should be expanded keep up with the times. On 32bit
> systems the 1MB limit is completely defensible. But expanding to say 64MB
> on 64bit systems would reduce practical encounters with SOE in these kinds
> of constructions by a factor of 64 or so.
>
> I've had this debate on a C++ application as well.  The debate started
> because a lot of people were working on stack overflow issues.  Each time I
> would tell them to first fix the infinite recursion issue.  They would try
> to take the easy route and would set the stack size to something very large
> and hope the problem would go away.  It didn't.  After the recursion bugs
> were eliminated, we got to the point where the application really did need
> to do that much recursion and the recursion was acceptably finite.  We then
> went with larger stack sizes and chose a sane default size.  After changing
> the default size, we bumped into a couple of problems.  Nothing that says
> we shouldn't increase the stack size but maybe it should be documented.
>
> First, the larger stack size eats up address space.  As far as resources
> go, it is very cheap at this point in time on a 64-bit machine.  25 years
> ago we said the same thing about virtual address space on 32-bit machines.
> We've got about 60 years before we will start exhausting the 64-bit address
> space.  So, let's ignore that for now.  Today's problem comes when doing
> sizing calculations.  People will see the address space size and figure
> that is what is needed for the process in terms of RAM.  Then the entire
> sizing calculation goes haywire and machines end up over sized.  As a cloud
> provider, I don't mind people spending more money on RAM they aren't
> using.  :)
>
> Second, it can take a while to overflow the 1 MB stack.  I've had a couple
> of situations where it took several minutes in Java to cause a stack
> overflow.  Obviously, the program isn't just doing recursive calls.  There
> is a computation or GC happening all the way down the stack.  A 64 MB stack
> would take a couple of hours.  This means the thread is busy for a long
> time and other operations will *hopefully* timeout waiting for it.
>
> I think a smart approach would be to examine code (open source?) or
> production deployments and see how often the stack sizing parameter is used
> and what value it is set to.  This will give us a good idea if the default
> stack size needs to be adjusted and what is a good stack size to use.
>
> -Nathan
>
> On 12/2/2015 5:52 AM, Doug Lea wrote:
>
> On 12/02/2015 05:34 AM, Millies, Sebastian wrote:
>
> I have thought of a way of doing tail-recursion elimination with
> CompletableFuture. It works, but I do not understand why. There must be
> some inter-thread communication going on about which I have not been able
> to find documentation. Perhaps someone here can enlighten me.
>
> public static BigInteger fibTailRecursive(int n) {
>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
> }
>
> private static BigInteger fibTailRecursiveAux(int n, BigInteger a,
> BigInteger b) {
>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
> }
>
> And here is the "optimized" version with TRE,
>
> public static BigInteger fibCF(int n) {
>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
> }
>
> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a,
> BigInteger b) {
>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b,
> a.add(b)));
> }
>
> Finally, here are my problematic implementations of terminate() and
> tailcall():
>
> public static <T> CompletableFuture<T> terminate(T t) {
>          return completedFuture(t);
> }
>
> public static <T> CompletableFuture<T>
> tailcall(Supplier<CompletableFuture<T>> s) {
>          return CF.thenComposeAsync(_x -> s.get(), THREAD);
> }
>
>
> (Using default Async would work at least as well.
> Aside: using direct executors (run in the same thread as caller)
> is almost never a good idea with CompletableFutures.)
>
>
> private static final CompletableFuture<?> CF = completedFuture(null);
> private static final Executor THREAD =
> Executors.newSingleThreadExecutor(new
> ThreadFactoryBuilder().setDaemon(true).build());
>
>
> This is a variation of the issues brought up by Chris Purcell a few months
> ago. In async mode, CF generally avoids StackOverflowError (SOE),
> because threads help clear out dependent tasks, which they do anyway to
> maximize parallelism.
>
> In non-async mode, you can still get SOE because java compilers do not
> loopify tail recursion. It would be possible to better avoid this
> kind of non-async SOE by thread-local trampolining at the expense
> of reducing parallelism, so we don't want to do it.
>
> It's still an open question whether we can find some scheme that
> combines both advantages.
>
> In the mean time, there is some sentiment that default thread stack
> sizes on 64bit JVMs should be expanded keep up with the times. On
> 32bit systems the 1MB limit is completely defensible. But expanding
> to say 64MB on 64bit systems would reduce practical encounters with
> SOE in these kinds of constructions by a factor of 64 or so.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/8df4cbd8/attachment.html>

From thurston at nomagicsoftware.com  Wed Dec  2 14:16:53 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Wed, 2 Dec 2015 12:16:53 -0700 (MST)
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
Message-ID: <1449083813569-12925.post@n7.nabble.com>

Why  would you do this?
Recursion is one of the most beautiful tools in software, and TCO has been
well understood for what? since the '70s?
If ever there was a "problem" that should be pushed to the compiler/runtime,
it's TCO.

I thought I read/saw that Brian Goetz mentioning that the JVM security
implementation had finally been refactored out of the JVM and was no longer
an impediment



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/A-puzzle-about-recursive-functions-in-CompletableFuture-tp12916p12925.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From jorge.d.f.branco at gmail.com  Wed Dec  2 15:25:28 2015
From: jorge.d.f.branco at gmail.com (Jorge Branco)
Date: Wed, 2 Dec 2015 21:25:28 +0100
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
Message-ID: <CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>

> Has it been considered to eliminate the use of recursion entirely from
the concurrency library (or for that matter the JDK) ?  Any need for
recursion can be readily transformed into the use of a stack.

Wouldn't that entail a huge performance cost? Some very raw experiments
I've done in the past seemed to imply that a (Java) stack would give a
terrible performance in comparison with equivalent algorithms using plain
recursion.

On Wed, Dec 2, 2015 at 7:29 PM, Hanson Char <hanson.char at gmail.com> wrote:

> Has it been considered to eliminate the use of recursion entirely from the
> concurrency library (or for that matter the JDK) ?  Any need for recursion
> can be readily transformed into the use of a stack.  This doesn't help
> prevent anyone abusing the library, but would eliminate the need to explain
> StackOverFlow error.  Shift the usage responsibility to the caller.
>
> 2 cents.
>
> Hanson
>
> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <
> nathan.reynolds at oracle.com> wrote:
>
>> > In the mean time, there is some sentiment that default thread stack
>> sizes on 64bit JVMs should be expanded keep up with the times. On 32bit
>> systems the 1MB limit is completely defensible. But expanding to say 64MB
>> on 64bit systems would reduce practical encounters with SOE in these kinds
>> of constructions by a factor of 64 or so.
>>
>> I've had this debate on a C++ application as well.  The debate started
>> because a lot of people were working on stack overflow issues.  Each time I
>> would tell them to first fix the infinite recursion issue.  They would try
>> to take the easy route and would set the stack size to something very large
>> and hope the problem would go away.  It didn't.  After the recursion bugs
>> were eliminated, we got to the point where the application really did need
>> to do that much recursion and the recursion was acceptably finite.  We then
>> went with larger stack sizes and chose a sane default size.  After changing
>> the default size, we bumped into a couple of problems.  Nothing that says
>> we shouldn't increase the stack size but maybe it should be documented.
>>
>> First, the larger stack size eats up address space.  As far as resources
>> go, it is very cheap at this point in time on a 64-bit machine.  25 years
>> ago we said the same thing about virtual address space on 32-bit machines.
>> We've got about 60 years before we will start exhausting the 64-bit address
>> space.  So, let's ignore that for now.  Today's problem comes when doing
>> sizing calculations.  People will see the address space size and figure
>> that is what is needed for the process in terms of RAM.  Then the entire
>> sizing calculation goes haywire and machines end up over sized.  As a cloud
>> provider, I don't mind people spending more money on RAM they aren't
>> using.  :)
>>
>> Second, it can take a while to overflow the 1 MB stack.  I've had a
>> couple of situations where it took several minutes in Java to cause a stack
>> overflow.  Obviously, the program isn't just doing recursive calls.  There
>> is a computation or GC happening all the way down the stack.  A 64 MB stack
>> would take a couple of hours.  This means the thread is busy for a long
>> time and other operations will *hopefully* timeout waiting for it.
>>
>> I think a smart approach would be to examine code (open source?) or
>> production deployments and see how often the stack sizing parameter is used
>> and what value it is set to.  This will give us a good idea if the default
>> stack size needs to be adjusted and what is a good stack size to use.
>>
>> -Nathan
>>
>> On 12/2/2015 5:52 AM, Doug Lea wrote:
>>
>> On 12/02/2015 05:34 AM, Millies, Sebastian wrote:
>>
>> I have thought of a way of doing tail-recursion elimination with
>> CompletableFuture. It works, but I do not understand why. There must be
>> some inter-thread communication going on about which I have not been able
>> to find documentation. Perhaps someone here can enlighten me.
>>
>> public static BigInteger fibTailRecursive(int n) {
>>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE);
>> }
>>
>> private static BigInteger fibTailRecursiveAux(int n, BigInteger a,
>> BigInteger b) {
>>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b));
>> }
>>
>> And here is the "optimized" version with TRE,
>>
>> public static BigInteger fibCF(int n) {
>>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join();
>> }
>>
>> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a,
>> BigInteger b) {
>>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b,
>> a.add(b)));
>> }
>>
>> Finally, here are my problematic implementations of terminate() and
>> tailcall():
>>
>> public static <T> CompletableFuture<T> terminate(T t) {
>>          return completedFuture(t);
>> }
>>
>> public static <T> CompletableFuture<T>
>> tailcall(Supplier<CompletableFuture<T>> s) {
>>          return CF.thenComposeAsync(_x -> s.get(), THREAD);
>> }
>>
>>
>> (Using default Async would work at least as well.
>> Aside: using direct executors (run in the same thread as caller)
>> is almost never a good idea with CompletableFutures.)
>>
>>
>> private static final CompletableFuture<?> CF = completedFuture(null);
>> private static final Executor THREAD =
>> Executors.newSingleThreadExecutor(new
>> ThreadFactoryBuilder().setDaemon(true).build());
>>
>>
>> This is a variation of the issues brought up by Chris Purcell a few
>> months
>> ago. In async mode, CF generally avoids StackOverflowError (SOE),
>> because threads help clear out dependent tasks, which they do anyway to
>> maximize parallelism.
>>
>> In non-async mode, you can still get SOE because java compilers do not
>> loopify tail recursion. It would be possible to better avoid this
>> kind of non-async SOE by thread-local trampolining at the expense
>> of reducing parallelism, so we don't want to do it.
>>
>> It's still an open question whether we can find some scheme that
>> combines both advantages.
>>
>> In the mean time, there is some sentiment that default thread stack
>> sizes on 64bit JVMs should be expanded keep up with the times. On
>> 32bit systems the 1MB limit is completely defensible. But expanding
>> to say 64MB on 64bit systems would reduce practical encounters with
>> SOE in these kinds of constructions by a factor of 64 or so.
>>
>> -Doug
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/b79f922b/attachment-0001.html>

From martinrb at google.com  Wed Dec  2 19:12:53 2015
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 2 Dec 2015 16:12:53 -0800
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <565F2CF1.90204@oracle.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
Message-ID: <CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>

On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <nathan.reynolds at oracle.com>
wrote:

>
> First, the larger stack size eats up address space.  As far as resources
> go, it is very cheap at this point in time on a 64-bit machine.  25 years
> ago we said the same thing about virtual address space on 32-bit machines.
> We've got about 60 years before we will start exhausting the 64-bit address
> space.  So, let's ignore that for now.  Today's problem comes when doing
> sizing calculations.  People will see the address space size and figure
> that is what is needed for the process in terms of RAM.  Then the entire
> sizing calculation goes haywire and machines end up over sized.  As a cloud
> provider, I don't mind people spending more money on RAM they aren't
> using.  :)
>

The assumption is that the VM implementers can manage to spend _only_
address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE),
whatever it takes to convince the OS (and ps!) that you're not really using
that memory ... yet

... and of course start working on the difficult task of being able to move
the stack so that if you run out of room, simply realloc and move
elsewhere, like the competition is doing.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/0e748aaf/attachment.html>

From vitalyd at gmail.com  Wed Dec  2 19:45:20 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 2 Dec 2015 19:45:20 -0500
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
Message-ID: <CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>

>
> and of course start working on the difficult task of being able to move
> the stack so that if you run out of room, simply realloc and move
> elsewhere, like the competition is doing.


IIRC, Rust moved away from segmented stacks.  Go I guess still uses them?
It's likely a performance loss for ordinary threading, but would be
required for coroutine/fiber support (like Go has).

On Wed, Dec 2, 2015 at 7:12 PM, Martin Buchholz <martinrb at google.com> wrote:

>
>
> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <
> nathan.reynolds at oracle.com> wrote:
>
>>
>> First, the larger stack size eats up address space.  As far as resources
>> go, it is very cheap at this point in time on a 64-bit machine.  25 years
>> ago we said the same thing about virtual address space on 32-bit machines.
>> We've got about 60 years before we will start exhausting the 64-bit address
>> space.  So, let's ignore that for now.  Today's problem comes when doing
>> sizing calculations.  People will see the address space size and figure
>> that is what is needed for the process in terms of RAM.  Then the entire
>> sizing calculation goes haywire and machines end up over sized.  As a cloud
>> provider, I don't mind people spending more money on RAM they aren't
>> using.  :)
>>
>
> The assumption is that the VM implementers can manage to spend _only_
> address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE),
> whatever it takes to convince the OS (and ps!) that you're not really using
> that memory ... yet
>
> ... and of course start working on the difficult task of being able to
> move the stack so that if you run out of room, simply realloc and move
> elsewhere, like the competition is doing.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151202/ca58f23a/attachment.html>

From martinrb at google.com  Wed Dec  2 23:44:47 2015
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 2 Dec 2015 20:44:47 -0800
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
Message-ID: <CA+kOe086tOQ_HdpbLQq8yEP_-4UE3q0eujPnQuurBQ936O3ceA@mail.gmail.com>

On Wed, Dec 2, 2015 at 4:45 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>> and of course start working on the difficult task of being able to move
>> the stack so that if you run out of room, simply realloc and move elsewhere,
>> like the competition is doing.
>
>
> IIRC, Rust moved away from segmented stacks.  Go I guess still uses them?
> It's likely a performance loss for ordinary threading, but would be required
> for coroutine/fiber support (like Go has).

You're right!  Wishful thinking.  Go has moved away from segmented
stacks, but tries to resize them as needed.  They need to keep track
of every pointer that could ever point inside a stack.

This certainly weakens my case.

From dahankzter at gmail.com  Thu Dec  3 01:54:07 2015
From: dahankzter at gmail.com (Henrik Johansson)
Date: Thu, 03 Dec 2015 06:54:07 +0000
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CA+kOe086tOQ_HdpbLQq8yEP_-4UE3q0eujPnQuurBQ936O3ceA@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
	<CA+kOe086tOQ_HdpbLQq8yEP_-4UE3q0eujPnQuurBQ936O3ceA@mail.gmail.com>
Message-ID: <CAKOF695deXUA80EWt7qNUBNtfa+e7scQdKb99m1iZ7R1_L_ywg@mail.gmail.com>

However Go does it nicely and the concept of small growable stacks is in
itself very appealing. Wouldn't it help many use cases like parallel
streams of small computational units as well not just recursion?

On Thu, Dec 3, 2015, 05:53 Martin Buchholz <martinrb at google.com> wrote:

> On Wed, Dec 2, 2015 at 4:45 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> >> and of course start working on the difficult task of being able to move
> >> the stack so that if you run out of room, simply realloc and move
> elsewhere,
> >> like the competition is doing.
> >
> >
> > IIRC, Rust moved away from segmented stacks.  Go I guess still uses them?
> > It's likely a performance loss for ordinary threading, but would be
> required
> > for coroutine/fiber support (like Go has).
>
> You're right!  Wishful thinking.  Go has moved away from segmented
> stacks, but tries to resize them as needed.  They need to keep track
> of every pointer that could ever point inside a stack.
>
> This certainly weakens my case.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151203/27e3007b/attachment.html>

From oleksandr.otenko at gmail.com  Mon Dec  7 04:39:10 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 7 Dec 2015 09:39:10 +0000
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
Message-ID: <0477F704-A0BD-4B3F-A28E-5CA09767BA2F@gmail.com>

For my benefit, what is a segmented stack?

Alex

> On 3 Dec 2015, at 00:45, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> 
> and of course start working on the difficult task of being able to move the stack so that if you run out of room, simply realloc and move elsewhere, like the competition is doing.
> 
> IIRC, Rust moved away from segmented stacks.  Go I guess still uses them? It's likely a performance loss for ordinary threading, but would be required for coroutine/fiber support (like Go has). 
> 
> On Wed, Dec 2, 2015 at 7:12 PM, Martin Buchholz <martinrb at google.com <mailto:martinrb at google.com>> wrote:
> 
> 
> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
> 
> First, the larger stack size eats up address space.  As far as resources go, it is very cheap at this point in time on a 64-bit machine.  25 years ago we said the same thing about virtual address space on 32-bit machines.  We've got about 60 years before we will start exhausting the 64-bit address space.  So, let's ignore that for now.  Today's problem comes when doing sizing calculations.  People will see the address space size and figure that is what is needed for the process in terms of RAM.  Then the entire sizing calculation goes haywire and machines end up over sized.  As a cloud provider, I don't mind people spending more money on RAM they aren't using.  :)
> 
> The assumption is that the VM implementers can manage to spend _only_ address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE), whatever it takes to convince the OS (and ps!) that you're not really using that memory ... yet 
> 
> ... and of course start working on the difficult task of being able to move the stack so that if you run out of room, simply realloc and move elsewhere, like the competition is doing.
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/720957dc/attachment.html>

From oleksandr.otenko at gmail.com  Mon Dec  7 04:39:45 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 7 Dec 2015 09:39:45 +0000
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
	<CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
Message-ID: <79A636EA-CBAC-4834-BDFE-E3FE3BD1E7F0@gmail.com>

What?s the difference between ?plain recursion? and ?Java stack??

Alex

> On 2 Dec 2015, at 20:25, Jorge Branco <jorge.d.f.branco at gmail.com> wrote:
> 
> > Has it been considered to eliminate the use of recursion entirely from the concurrency library (or for that matter the JDK) ?  Any need for recursion can be readily transformed into the use of a stack.
> 
> Wouldn't that entail a huge performance cost? Some very raw experiments I've done in the past seemed to imply that a (Java) stack would give a terrible performance in comparison with equivalent algorithms using plain recursion.
> 
> On Wed, Dec 2, 2015 at 7:29 PM, Hanson Char <hanson.char at gmail.com <mailto:hanson.char at gmail.com>> wrote:
> Has it been considered to eliminate the use of recursion entirely from the concurrency library (or for that matter the JDK) ?  Any need for recursion can be readily transformed into the use of a stack.  This doesn't help prevent anyone abusing the library, but would eliminate the need to explain StackOverFlow error.  Shift the usage responsibility to the caller.
> 
> 2 cents.
> 
> Hanson 
> 
> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
> > In the mean time, there is some sentiment that default thread stack sizes on 64bit JVMs should be expanded keep up with the times. On 32bit systems the 1MB limit is completely defensible. But expanding to say 64MB on 64bit systems would reduce practical encounters with SOE in these kinds of constructions by a factor of 64 or so. 
> 
> I've had this debate on a C++ application as well.  The debate started because a lot of people were working on stack overflow issues.  Each time I would tell them to first fix the infinite recursion issue.  They would try to take the easy route and would set the stack size to something very large and hope the problem would go away.  It didn't.  After the recursion bugs were eliminated, we got to the point where the application really did need to do that much recursion and the recursion was acceptably finite.  We then went with larger stack sizes and chose a sane default size.  After changing the default size, we bumped into a couple of problems.  Nothing that says we shouldn't increase the stack size but maybe it should be documented.
> 
> First, the larger stack size eats up address space.  As far as resources go, it is very cheap at this point in time on a 64-bit machine.  25 years ago we said the same thing about virtual address space on 32-bit machines.  We've got about 60 years before we will start exhausting the 64-bit address space.  So, let's ignore that for now.  Today's problem comes when doing sizing calculations.  People will see the address space size and figure that is what is needed for the process in terms of RAM.  Then the entire sizing calculation goes haywire and machines end up over sized.  As a cloud provider, I don't mind people spending more money on RAM they aren't using.  :)
> 
> Second, it can take a while to overflow the 1 MB stack.  I've had a couple of situations where it took several minutes in Java to cause a stack overflow.  Obviously, the program isn't just doing recursive calls.  There is a computation or GC happening all the way down the stack.  A 64 MB stack would take a couple of hours.  This means the thread is busy for a long time and other operations will *hopefully* timeout waiting for it.
> 
> I think a smart approach would be to examine code (open source?) or production deployments and see how often the stack sizing parameter is used and what value it is set to.  This will give us a good idea if the default stack size needs to be adjusted and what is a good stack size to use.
> -Nathan
> On 12/2/2015 5:52 AM, Doug Lea wrote:
>> On 12/02/2015 05:34 AM, Millies, Sebastian wrote: 
>>> I have thought of a way of doing tail-recursion elimination with CompletableFuture. It works, but I do not understand why. There must be some inter-thread communication going on about which I have not been able to find documentation. Perhaps someone here can enlighten me. 
>>> 
>>> public static BigInteger fibTailRecursive(int n) { 
>>>      return n <= 2 ? ONE : fibTailRecursiveAux(n, ZERO, ONE); 
>>> } 
>>> 
>>> private static BigInteger fibTailRecursiveAux(int n, BigInteger a, BigInteger b) { 
>>>      return n <= 0 ? a : fibTailRecursiveAux(n - 1, b, a.add(b)); 
>>> } 
>>> 
>>> And here is the "optimized" version with TRE, 
>>> 
>>> public static BigInteger fibCF(int n) { 
>>>          return n <= 2 ? ONE : fibCF(n, ZERO, ONE).join(); 
>>> } 
>>> 
>>> private static CompletableFuture<BigInteger> fibCF(int n, BigInteger a, BigInteger b) { 
>>>          return n <= 0 ? terminate(a) : tailcall(() -> fibCF(n - 1, b, a.add(b))); 
>>> } 
>>> 
>>> Finally, here are my problematic implementations of terminate() and tailcall(): 
>>> 
>>> public static <T> CompletableFuture<T> terminate(T t) { 
>>>          return completedFuture(t); 
>>> } 
>>> 
>>> public static <T> CompletableFuture<T> tailcall(Supplier<CompletableFuture<T>> s) { 
>>>          return CF.thenComposeAsync(_x -> s.get(), THREAD); 
>>> } 
>> 
>> (Using default Async would work at least as well. 
>> Aside: using direct executors (run in the same thread as caller) 
>> is almost never a good idea with CompletableFutures.) 
>> 
>>> 
>>> private static final CompletableFuture<?> CF = completedFuture(null); 
>>> private static final Executor THREAD = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).build()); 
>>> 
>> 
>> This is a variation of the issues brought up by Chris Purcell a few months 
>> ago. In async mode, CF generally avoids StackOverflowError (SOE), 
>> because threads help clear out dependent tasks, which they do anyway to 
>> maximize parallelism. 
>> 
>> In non-async mode, you can still get SOE because java compilers do not 
>> loopify tail recursion. It would be possible to better avoid this 
>> kind of non-async SOE by thread-local trampolining at the expense 
>> of reducing parallelism, so we don't want to do it. 
>> 
>> It's still an open question whether we can find some scheme that 
>> combines both advantages. 
>> 
>> In the mean time, there is some sentiment that default thread stack 
>> sizes on 64bit JVMs should be expanded keep up with the times. On 
>> 32bit systems the 1MB limit is completely defensible. But expanding 
>> to say 64MB on 64bit systems would reduce practical encounters with 
>> SOE in these kinds of constructions by a factor of 64 or so. 
>> 
>> -Doug 
>> 
>> 
>> _______________________________________________ 
>> Concurrency-interest mailing list 
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> 
>> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/bda7bc1f/attachment-0001.html>

From aph at redhat.com  Mon Dec  7 05:40:54 2015
From: aph at redhat.com (Andrew Haley)
Date: Mon, 7 Dec 2015 10:40:54 +0000
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
	<CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
Message-ID: <56656236.4040902@redhat.com>

On 02/12/15 20:25, Jorge Branco wrote:
>> Has it been considered to eliminate the use of recursion entirely from
>> the concurrency library (or for that matter the JDK) ?  Any need for
>> recursion can be readily transformed into the use of a stack.
> 
> Wouldn't that entail a huge performance cost? Some very raw experiments
> I've done in the past seemed to imply that a (Java) stack would give a
> terrible performance in comparison with equivalent algorithms using plain
> recursion.

I can't immediately see any reason it should.  There's no way to tell
for sure without real code.

Andrew.


From david.lloyd at redhat.com  Mon Dec  7 07:38:05 2015
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 7 Dec 2015 06:38:05 -0600
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <56656236.4040902@redhat.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
	<CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
	<56656236.4040902@redhat.com>
Message-ID: <56657DAD.8040401@redhat.com>

On 12/07/2015 04:40 AM, Andrew Haley wrote:
> On 02/12/15 20:25, Jorge Branco wrote:
>>> Has it been considered to eliminate the use of recursion entirely from
>>> the concurrency library (or for that matter the JDK) ?  Any need for
>>> recursion can be readily transformed into the use of a stack.
>>
>> Wouldn't that entail a huge performance cost? Some very raw experiments
>> I've done in the past seemed to imply that a (Java) stack would give a
>> terrible performance in comparison with equivalent algorithms using plain
>> recursion.
>
> I can't immediately see any reason it should.  There's no way to tell
> for sure without real code.

Using ArrayDeque instead of Stack would be a good first step, as the 
latter uses synchronization everywhere.  Also, proper initial sizing is 
very important to performance for large operations to avoid copying.
-- 
- DML

From adc at quartetfs.com  Mon Dec  7 07:40:18 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Mon, 7 Dec 2015 13:40:18 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
Message-ID: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>

Hi all,

I recently had a look at the discussion started by Peter Levart on October
21 (
http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
).

It was a very insightful discussion, and made me aware that the "this"
object could be garbage collected while being inside a call of one of its
method.

However, this got me concerned about the java.nio.DirectByteBuffer read and
write methods:
If the "this" object is garbage collected when making a call like
ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
that is passed to sun.misc.Unsafe might be freed, and accessing it will
cause the read/write to occur in an invalid memory area, which might lead
to a segfault, or other major issues.
This would be quite unlikely: JIT compilation needs to occur while keeping
a safepoint, then a GC must happen, and finally the ReferenceHandler thread
needs to perform its cleanup fast enough.

I am particularly concerned by the get(byte[] dst, int offset, int length)
method, that in turns calls Bits.copyToArray, which purposely splits its
calls to Unsafe.copyMemory to allow for safepoints to sneak in.

Am I correct, or does the JVM performs specific protection for instances of
DirectByteBuffer?

Regards,

Alexandre de Champeaux
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/c0af94be/attachment.html>

From vitalyd at gmail.com  Mon Dec  7 08:04:46 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 08:04:46 -0500
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <0477F704-A0BD-4B3F-A28E-5CA09767BA2F@gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
	<0477F704-A0BD-4B3F-A28E-5CA09767BA2F@gmail.com>
Message-ID: <CAHjP37EN9vHZ8xLAM3=of-JJZX3NhiSRzeosH99Ee6cicT1dBQ@mail.gmail.com>

http://llvm.org/releases/3.0/docs/SegmentedStacks.html

Rust discussion on them:
https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html

sent from my phone
On Dec 7, 2015 4:39 AM, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:

> For my benefit, what is a segmented stack?
>
> Alex
>
> On 3 Dec 2015, at 00:45, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> and of course start working on the difficult task of being able to move
>> the stack so that if you run out of room, simply realloc and move
>> elsewhere, like the competition is doing.
>
>
> IIRC, Rust moved away from segmented stacks.  Go I guess still uses them?
> It's likely a performance loss for ordinary threading, but would be
> required for coroutine/fiber support (like Go has).
>
> On Wed, Dec 2, 2015 at 7:12 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
>>
>>
>> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <
>> nathan.reynolds at oracle.com> wrote:
>>
>>>
>>> First, the larger stack size eats up address space.  As far as resources
>>> go, it is very cheap at this point in time on a 64-bit machine.  25 years
>>> ago we said the same thing about virtual address space on 32-bit machines.
>>> We've got about 60 years before we will start exhausting the 64-bit address
>>> space.  So, let's ignore that for now.  Today's problem comes when doing
>>> sizing calculations.  People will see the address space size and figure
>>> that is what is needed for the process in terms of RAM.  Then the entire
>>> sizing calculation goes haywire and machines end up over sized.  As a cloud
>>> provider, I don't mind people spending more money on RAM they aren't
>>> using.  :)
>>>
>>
>> The assumption is that the VM implementers can manage to spend _only_
>> address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE),
>> whatever it takes to convince the OS (and ps!) that you're not really using
>> that memory ... yet
>>
>> ... and of course start working on the difficult task of being able to
>> move the stack so that if you run out of room, simply realloc and move
>> elsewhere, like the competition is doing.
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/850fb8e0/attachment.html>

From vitalyd at gmail.com  Mon Dec  7 08:07:58 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 08:07:58 -0500
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <56657DAD.8040401@redhat.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CABWgujbxrtfPt35NznTUfSAMMRQUX17hZFDgitOUOvXCfON1nQ@mail.gmail.com>
	<CAMfCbE8a-NdXFt91pV78-cThMMsR_UkCvOyHh3pbvMwsHCaofw@mail.gmail.com>
	<56656236.4040902@redhat.com> <56657DAD.8040401@redhat.com>
Message-ID: <CAHjP37FkmdU9PO=ueHs_fAfSFKpqGCnn0ue8xp5bXWbMiyfAYw@mail.gmail.com>

The bigger problem would be the allocation of an explicit data structure to
maintain the stack (i.e. GC pressure).

sent from my phone
On Dec 7, 2015 8:03 AM, "David M. Lloyd" <david.lloyd at redhat.com> wrote:

> On 12/07/2015 04:40 AM, Andrew Haley wrote:
>
>> On 02/12/15 20:25, Jorge Branco wrote:
>>
>>> Has it been considered to eliminate the use of recursion entirely from
>>>> the concurrency library (or for that matter the JDK) ?  Any need for
>>>> recursion can be readily transformed into the use of a stack.
>>>>
>>>
>>> Wouldn't that entail a huge performance cost? Some very raw experiments
>>> I've done in the past seemed to imply that a (Java) stack would give a
>>> terrible performance in comparison with equivalent algorithms using plain
>>> recursion.
>>>
>>
>> I can't immediately see any reason it should.  There's no way to tell
>> for sure without real code.
>>
>
> Using ArrayDeque instead of Stack would be a good first step, as the
> latter uses synchronization everywhere.  Also, proper initial sizing is
> very important to performance for large operations to avoid copying.
> --
> - DML
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/8b2643f7/attachment.html>

From oleksandr.otenko at gmail.com  Mon Dec  7 08:35:39 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 7 Dec 2015 13:35:39 +0000
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <CAHjP37EN9vHZ8xLAM3=of-JJZX3NhiSRzeosH99Ee6cicT1dBQ@mail.gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
	<0477F704-A0BD-4B3F-A28E-5CA09767BA2F@gmail.com>
	<CAHjP37EN9vHZ8xLAM3=of-JJZX3NhiSRzeosH99Ee6cicT1dBQ@mail.gmail.com>
Message-ID: <35C4121B-50C6-4031-8F1B-E5A0E550F1C2@gmail.com>

Got it. It looks quite different from what (I think) Java uses. Doesn?t HotSpot use ?guard pages? rather than in-code stack size checks + linked lists of stack frames?

Alex

> On 7 Dec 2015, at 13:04, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> 
> http://llvm.org/releases/3.0/docs/SegmentedStacks.html <http://llvm.org/releases/3.0/docs/SegmentedStacks.html>
> Rust discussion on them: https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html <https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html>
> sent from my phone
> 
> On Dec 7, 2015 4:39 AM, "Alex Otenko" <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> For my benefit, what is a segmented stack?
> 
> Alex
> 
>> On 3 Dec 2015, at 00:45, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>> 
>> and of course start working on the difficult task of being able to move the stack so that if you run out of room, simply realloc and move elsewhere, like the competition is doing.
>> 
>> IIRC, Rust moved away from segmented stacks.  Go I guess still uses them? It's likely a performance loss for ordinary threading, but would be required for coroutine/fiber support (like Go has). 
>> 
>> On Wed, Dec 2, 2015 at 7:12 PM, Martin Buchholz <martinrb at google.com <mailto:martinrb at google.com>> wrote:
>> 
>> 
>> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
>> 
>> First, the larger stack size eats up address space.  As far as resources go, it is very cheap at this point in time on a 64-bit machine.  25 years ago we said the same thing about virtual address space on 32-bit machines.  We've got about 60 years before we will start exhausting the 64-bit address space.  So, let's ignore that for now.  Today's problem comes when doing sizing calculations.  People will see the address space size and figure that is what is needed for the process in terms of RAM.  Then the entire sizing calculation goes haywire and machines end up over sized.  As a cloud provider, I don't mind people spending more money on RAM they aren't using.  :)
>> 
>> The assumption is that the VM implementers can manage to spend _only_ address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE), whatever it takes to convince the OS (and ps!) that you're not really using that memory ... yet 
>> 
>> ... and of course start working on the difficult task of being able to move the stack so that if you run out of room, simply realloc and move elsewhere, like the competition is doing.
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/eea644c3/attachment-0001.html>

From vitalyd at gmail.com  Mon Dec  7 09:35:35 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 09:35:35 -0500
Subject: [concurrency-interest] Default Stack Size on 64-bit JVMs
In-Reply-To: <35C4121B-50C6-4031-8F1B-E5A0E550F1C2@gmail.com>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DE7130@HQMBX5.eur.ad.sag>
	<565EE977.3020009@cs.oswego.edu> <565F2CF1.90204@oracle.com>
	<CA+kOe09cB1kXa8s13s100+OEbQ3Sq2jHKpbZK9wWpwUL8fvs4A@mail.gmail.com>
	<CAHjP37H=+bs8bMAd5qUuMGcK7=oQdWVCY0MEwAzCHREkvcfv=Q@mail.gmail.com>
	<0477F704-A0BD-4B3F-A28E-5CA09767BA2F@gmail.com>
	<CAHjP37EN9vHZ8xLAM3=of-JJZX3NhiSRzeosH99Ee6cicT1dBQ@mail.gmail.com>
	<35C4121B-50C6-4031-8F1B-E5A0E550F1C2@gmail.com>
Message-ID: <CAHjP37GRmy3jZdy0MxKS80BXmjVOrSA1uSTuK9WZDoSZqcdypg@mail.gmail.com>

Right, Hotspot uses traditional OS stacks with guard pages.  As for size
checks, prior to calling a method the stack is probed to see if guard page
access is tripped (i.e. stack banging).

sent from my phone
On Dec 7, 2015 8:35 AM, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:

> Got it. It looks quite different from what (I think) Java uses. Doesn?t
> HotSpot use ?guard pages? rather than in-code stack size checks + linked
> lists of stack frames?
>
> Alex
>
> On 7 Dec 2015, at 13:04, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> http://llvm.org/releases/3.0/docs/SegmentedStacks.html
>
> Rust discussion on them:
> https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html
>
> sent from my phone
> On Dec 7, 2015 4:39 AM, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:
>
>> For my benefit, what is a segmented stack?
>>
>> Alex
>>
>> On 3 Dec 2015, at 00:45, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> and of course start working on the difficult task of being able to move
>>> the stack so that if you run out of room, simply realloc and move
>>> elsewhere, like the competition is doing.
>>
>>
>> IIRC, Rust moved away from segmented stacks.  Go I guess still uses them?
>> It's likely a performance loss for ordinary threading, but would be
>> required for coroutine/fiber support (like Go has).
>>
>> On Wed, Dec 2, 2015 at 7:12 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>>>
>>>
>>> On Wed, Dec 2, 2015 at 9:40 AM, Nathan Reynolds <
>>> nathan.reynolds at oracle.com> wrote:
>>>
>>>>
>>>> First, the larger stack size eats up address space.  As far as
>>>> resources go, it is very cheap at this point in time on a 64-bit machine.
>>>> 25 years ago we said the same thing about virtual address space on 32-bit
>>>> machines.  We've got about 60 years before we will start exhausting the
>>>> 64-bit address space.  So, let's ignore that for now.  Today's problem
>>>> comes when doing sizing calculations.  People will see the address space
>>>> size and figure that is what is needed for the process in terms of RAM.
>>>> Then the entire sizing calculation goes haywire and machines end up over
>>>> sized.  As a cloud provider, I don't mind people spending more money on RAM
>>>> they aren't using.  :)
>>>>
>>>
>>> The assumption is that the VM implementers can manage to spend _only_
>>> address space.  Maybe mmap with PROT_NONE, maybe madvise(DONT_USE),
>>> whatever it takes to convince the OS (and ps!) that you're not really using
>>> that memory ... yet
>>>
>>> ... and of course start working on the difficult task of being able to
>>> move the stack so that if you run out of room, simply realloc and move
>>> elsewhere, like the competition is doing.
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/b2edec3e/attachment.html>

From aph at redhat.com  Mon Dec  7 09:41:26 2015
From: aph at redhat.com (Andrew Haley)
Date: Mon, 7 Dec 2015 14:41:26 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
Message-ID: <56659A96.7090706@redhat.com>

On 12/07/2015 12:40 PM, Alexandre De Champeaux wrote:
> However, this got me concerned about the java.nio.DirectByteBuffer read and
> write methods:
> If the "this" object is garbage collected when making a call like
> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
> that is passed to sun.misc.Unsafe might be freed, and accessing it will
> cause the read/write to occur in an invalid memory area, which might lead
> to a segfault, or other major issues.
> This would be quite unlikely: JIT compilation needs to occur while keeping
> a safepoint, then a GC must happen, and finally the ReferenceHandler thread
> needs to perform its cleanup fast enough.
> 
> I am particularly concerned by the get(byte[] dst, int offset, int length)
> method, that in turns calls Bits.copyToArray, which purposely splits its
> calls to Unsafe.copyMemory to allow for safepoints to sneak in.
> 
> Am I correct, or does the JVM performs specific protection for instances of
> DirectByteBuffer?

There are many places where we need to insert a reachabilityFence.
This is one such.  Some non-HotSpot JVMs perform their cleanups
very aggressively, so it's more likely there.

Andrew.


From vitalyd at gmail.com  Mon Dec  7 10:15:04 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 10:15:04 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
Message-ID: <CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>

JIT knows about Unsafe operations, and it also knows the type of memory
being accessed (or sometimes knows it doesn't know :)).  So I don't think
it'll mark a DBB as unreachable while these operations are in-flight.

Peter's scenario is unique to WeakReference since it's intentionally not
considered a strong reference and there's otherwise plain java code in his
example (that JIT can reason about easily otherwise).

sent from my phone
On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com> wrote:

> Hi all,
>
> I recently had a look at the discussion started by Peter Levart on October
> 21 (
> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
> ).
>
> It was a very insightful discussion, and made me aware that the "this"
> object could be garbage collected while being inside a call of one of its
> method.
>
> However, this got me concerned about the java.nio.DirectByteBuffer read
> and write methods:
> If the "this" object is garbage collected when making a call like
> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
> that is passed to sun.misc.Unsafe might be freed, and accessing it will
> cause the read/write to occur in an invalid memory area, which might lead
> to a segfault, or other major issues.
> This would be quite unlikely: JIT compilation needs to occur while keeping
> a safepoint, then a GC must happen, and finally the ReferenceHandler thread
> needs to perform its cleanup fast enough.
>
> I am particularly concerned by the get(byte[] dst, int offset, int length)
> method, that in turns calls Bits.copyToArray, which purposely splits its
> calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>
> Am I correct, or does the JVM performs specific protection for instances
> of DirectByteBuffer?
>
> Regards,
>
> Alexandre de Champeaux
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/4251c4af/attachment.html>

From vitalyd at gmail.com  Mon Dec  7 10:20:22 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 10:20:22 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56659A96.7090706@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<56659A96.7090706@redhat.com>
Message-ID: <CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>

If reachabilityFence use is going to proliferate, especially in perf
sensitive places, Hotspot will need to make this method simply a liveness
marker and not emit a call like the current prototype/version is doing.

sent from my phone
On Dec 7, 2015 10:07 AM, "Andrew Haley" <aph at redhat.com> wrote:

> On 12/07/2015 12:40 PM, Alexandre De Champeaux wrote:
> > However, this got me concerned about the java.nio.DirectByteBuffer read
> and
> > write methods:
> > If the "this" object is garbage collected when making a call like
> > ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
> > that is passed to sun.misc.Unsafe might be freed, and accessing it will
> > cause the read/write to occur in an invalid memory area, which might lead
> > to a segfault, or other major issues.
> > This would be quite unlikely: JIT compilation needs to occur while
> keeping
> > a safepoint, then a GC must happen, and finally the ReferenceHandler
> thread
> > needs to perform its cleanup fast enough.
> >
> > I am particularly concerned by the get(byte[] dst, int offset, int
> length)
> > method, that in turns calls Bits.copyToArray, which purposely splits its
> > calls to Unsafe.copyMemory to allow for safepoints to sneak in.
> >
> > Am I correct, or does the JVM performs specific protection for instances
> of
> > DirectByteBuffer?
>
> There are many places where we need to insert a reachabilityFence.
> This is one such.  Some non-HotSpot JVMs perform their cleanups
> very aggressively, so it's more likely there.
>
> Andrew.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/f0c0e752/attachment-0001.html>

From adc at quartetfs.com  Mon Dec  7 12:08:15 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Mon, 7 Dec 2015 18:08:15 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
Message-ID: <CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>

I have actually written a test class that reproduces a segfault. It uses an
structure similar to DBB and an updated version of the Bits.copyToArray
method which forces a GC and waits a bit from within it to simulate a
safepoint stop and a GC, and leaves time to the reference handler to clean
up.
Is this test too far away from the DBB code to actually simulate a possible
behavior of DBB? Or is hotspot only able to not mark as unreachable vanilla
java DBB, but not customer classes?

Here is the test class:


import sun.misc.Cleaner;
import sun.misc.Unsafe;

/**
 * This test checks whether or not the JVM will dereference "this" and
destroy the buffer while
 * accessing it.
 * <p>
 * Run the main method of this class to run the test.
 * <p>
 * Note that the test segfaults each time if using a JNI call to
mmap/munmap to do the memory
 * management but not as often using Unsafe (malloc recycling memory?).
 * <p>
 * Example output of a failure:
 *
 * <pre>
TestGcThisAndDestroyBuffer.main() 0 -- 0
TestGcThisAndDestroyBuffer.main() 0 -- 1
TestGcThisAndDestroyBuffer.main() 0 -- 2
TestGcThisAndDestroyBuffer.main() 0 -- 3
TestGcThisAndDestroyBuffer.main() 0 -- 4
TestGcThisAndDestroyBuffer.main() 0 -- 5
TestGcThisAndDestroyBuffer.main() 0 -- 6
TestGcThisAndDestroyBuffer.main() 0 -- 7
TestGcThisAndDestroyBuffer.main() 0 -- 8
TestGcThisAndDestroyBuffer.main() 0 -- 9
TestGcThisAndDestroyBuffer.main() 0 -- 10
TestGcThisAndDestroyBuffer.main() 0 -- 11
TestGcThisAndDestroyBuffer.main() 0 -- 12
TestGcThisAndDestroyBuffer.main() 0 -- 13
TestGcThisAndDestroyBuffer.main() 0 -- 14
Must be compiled now, start doing some GCs 30001
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949, tid=139949914818304
#
# JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
1.8.0_60-b27)
# Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
linux-amd64 compressed oops)
# Problematic frame:
# V  [libjvm.so+0x7f7220]
#
# Failed to write core dump. Core dumps have been disabled. To enable core
dumping, try "ulimit -c unlimited" before starting Java again
#
# An error report file with more information is saved as:
# /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
Compiled method (nm)   10180   18     n 0       sun.misc.Unsafe::copyMemory
(native)
total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
main code      [0x00007f488910f440,0x00007f488910f640] = 512
Compiled method (nm)   10180   18     n 0       sun.misc.Unsafe::copyMemory
(native)
total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
main code      [0x00007f488910f440,0x00007f488910f640] = 512
#
# If you would like to submit a bug report, please visit:
#   http://bugreport.java.com/bugreport/crash.jsp
#
 * </pre>
 */
@SuppressWarnings("restriction")
public class TestGcThisAndDestroyBuffer {

/** The threshold found in Bits.copyMemory */
static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
private static final Unsafe unsafe = retrieveUnsafe();

static long ctr = 0;

// The tested method
// See the method in Bits.copyToArray
/* For Bits.copyToArray to segfault we need:
*
* 1) The buffer to be garbage collected while calling the method, for that
we need:
* - A safepoint exist in the method
* - The buffer needs to not be held, so JIT compil must have occured,
* and JIT must have dereferenced the DBB at the time of the call
* 2) The reference handler thread to have run the associated cleaner
*/
static void copyToArray(long srcAddr, Object dst, long dstBaseOffset, long
dstPos, long length) {
long offset = dstBaseOffset + dstPos;
while (length > 0) {
// Code differing from Bits.
if (ctr++ >= 30_000) {
// Counter is there to wait for JIT compilation
System.out.println("Must be compiled now, start doing some GCs " + ctr);
// Here we simulate a safepoint, and a GC at this safepoint
System.gc();
try {
// And here we wait for the reference handler to perform the cleaning to
simulate a fast cleaning.
Thread.sleep(1000);
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
}

long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
length;
unsafe.copyMemory(null, srcAddr, dst, offset, size);
length -= size;
srcAddr += size;
offset += size;
}
}

// A basic class inspired from java.nio.DirectByteBuffer
static class SimpleBuffer {
static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
static final long arrayBaseOffset = (long)
unsafe.arrayBaseOffset(byte[].class);

final long addr;

public SimpleBuffer() {
addr = unsafe.allocateMemory(SIZE);
unsafe.setMemory(addr, SIZE, (byte) 0);
Cleaner.create(this, new Deallocator(addr));
}

public byte[] copy() {
final byte[] a = new byte[SIZE];
copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
return a;
}

private static class Deallocator implements Runnable {

private long address;

private Deallocator(long address) {
assert (address != 0);
this.address = address;
}

@Override
public void run() {
if (address == 0) {
// Paranoia
return;
}
unsafe.freeMemory(address);
address = 0;
}

}

}

static byte[] aBunchOfCopies() {
byte[] res = null;
for (int i = 0; i < 1000; ++i) {
res = new SimpleBuffer().copy();
if (res[0] == -1) {
return res;
}
}
return res;
}

public static void main(String[] args) {
int i = 0;
while (true) {
final byte[] res = aBunchOfCopies();
System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + " -- " +
i++);
}
}

private static final sun.misc.Unsafe retrieveUnsafe() {
try {
return sun.misc.Unsafe.getUnsafe();
} catch (SecurityException se) {
try {
return java.security.AccessController
.doPrivileged(new
java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
@Override
public sun.misc.Unsafe run() throws Exception {
java.lang.reflect.Field f =
sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
return (sun.misc.Unsafe) f.get(null);
}
});
} catch (java.security.PrivilegedActionException e) {
throw new RuntimeException("Could not initialize intrinsics", e.getCause());
}
}
}

}


On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> JIT knows about Unsafe operations, and it also knows the type of memory
> being accessed (or sometimes knows it doesn't know :)).  So I don't think
> it'll mark a DBB as unreachable while these operations are in-flight.
>
> Peter's scenario is unique to WeakReference since it's intentionally not
> considered a strong reference and there's otherwise plain java code in his
> example (that JIT can reason about easily otherwise).
>
> sent from my phone
> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
> wrote:
>
>> Hi all,
>>
>> I recently had a look at the discussion started by Peter Levart on
>> October 21 (
>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>> ).
>>
>> It was a very insightful discussion, and made me aware that the "this"
>> object could be garbage collected while being inside a call of one of its
>> method.
>>
>> However, this got me concerned about the java.nio.DirectByteBuffer read
>> and write methods:
>> If the "this" object is garbage collected when making a call like
>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
>> that is passed to sun.misc.Unsafe might be freed, and accessing it will
>> cause the read/write to occur in an invalid memory area, which might lead
>> to a segfault, or other major issues.
>> This would be quite unlikely: JIT compilation needs to occur while
>> keeping a safepoint, then a GC must happen, and finally the
>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>
>> I am particularly concerned by the get(byte[] dst, int offset, int
>> length) method, that in turns calls Bits.copyToArray, which purposely
>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>
>> Am I correct, or does the JVM performs specific protection for instances
>> of DirectByteBuffer?
>>
>> Regards,
>>
>> Alexandre de Champeaux
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>


-- 
Alexandre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/46d94bb0/attachment-0001.html>

From vitalyd at gmail.com  Mon Dec  7 12:23:10 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 12:23:10 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
Message-ID: <CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>

Can you more closely mirror DBB by updating some state of your SimpleBuffer
after calling copyToArray()? DBB returns 'this' from its get(byte[], ...)
and also sets position after the Bits.copyToArray() method.

On Mon, Dec 7, 2015 at 12:08 PM, Alexandre De Champeaux <adc at quartetfs.com>
wrote:

> I have actually written a test class that reproduces a segfault. It uses
> an structure similar to DBB and an updated version of the Bits.copyToArray
> method which forces a GC and waits a bit from within it to simulate a
> safepoint stop and a GC, and leaves time to the reference handler to clean
> up.
> Is this test too far away from the DBB code to actually simulate a
> possible behavior of DBB? Or is hotspot only able to not mark as
> unreachable vanilla java DBB, but not customer classes?
>
> Here is the test class:
>
>
> import sun.misc.Cleaner;
> import sun.misc.Unsafe;
>
> /**
>  * This test checks whether or not the JVM will dereference "this" and
> destroy the buffer while
>  * accessing it.
>  * <p>
>  * Run the main method of this class to run the test.
>  * <p>
>  * Note that the test segfaults each time if using a JNI call to
> mmap/munmap to do the memory
>  * management but not as often using Unsafe (malloc recycling memory?).
>  * <p>
>  * Example output of a failure:
>  *
>  * <pre>
> TestGcThisAndDestroyBuffer.main() 0 -- 0
> TestGcThisAndDestroyBuffer.main() 0 -- 1
> TestGcThisAndDestroyBuffer.main() 0 -- 2
> TestGcThisAndDestroyBuffer.main() 0 -- 3
> TestGcThisAndDestroyBuffer.main() 0 -- 4
> TestGcThisAndDestroyBuffer.main() 0 -- 5
> TestGcThisAndDestroyBuffer.main() 0 -- 6
> TestGcThisAndDestroyBuffer.main() 0 -- 7
> TestGcThisAndDestroyBuffer.main() 0 -- 8
> TestGcThisAndDestroyBuffer.main() 0 -- 9
> TestGcThisAndDestroyBuffer.main() 0 -- 10
> TestGcThisAndDestroyBuffer.main() 0 -- 11
> TestGcThisAndDestroyBuffer.main() 0 -- 12
> TestGcThisAndDestroyBuffer.main() 0 -- 13
> TestGcThisAndDestroyBuffer.main() 0 -- 14
> Must be compiled now, start doing some GCs 30001
> #
> # A fatal error has been detected by the Java Runtime Environment:
> #
> #  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949, tid=139949914818304
> #
> # JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
> 1.8.0_60-b27)
> # Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
> linux-amd64 compressed oops)
> # Problematic frame:
> # V  [libjvm.so+0x7f7220]
> #
> # Failed to write core dump. Core dumps have been disabled. To enable core
> dumping, try "ulimit -c unlimited" before starting Java again
> #
> # An error report file with more information is saved as:
> #
> /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
> Compiled method (nm)   10180   18     n 0
> sun.misc.Unsafe::copyMemory (native)
> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
> main code      [0x00007f488910f440,0x00007f488910f640] = 512
> Compiled method (nm)   10180   18     n 0
> sun.misc.Unsafe::copyMemory (native)
> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
> main code      [0x00007f488910f440,0x00007f488910f640] = 512
> #
> # If you would like to submit a bug report, please visit:
> #   http://bugreport.java.com/bugreport/crash.jsp
> #
>  * </pre>
>  */
> @SuppressWarnings("restriction")
> public class TestGcThisAndDestroyBuffer {
>
> /** The threshold found in Bits.copyMemory */
> static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
> private static final Unsafe unsafe = retrieveUnsafe();
>
> static long ctr = 0;
>
> // The tested method
> // See the method in Bits.copyToArray
> /* For Bits.copyToArray to segfault we need:
> *
> * 1) The buffer to be garbage collected while calling the method, for that
> we need:
> * - A safepoint exist in the method
> * - The buffer needs to not be held, so JIT compil must have occured,
> * and JIT must have dereferenced the DBB at the time of the call
> * 2) The reference handler thread to have run the associated cleaner
> */
> static void copyToArray(long srcAddr, Object dst, long dstBaseOffset, long
> dstPos, long length) {
> long offset = dstBaseOffset + dstPos;
> while (length > 0) {
> // Code differing from Bits.
> if (ctr++ >= 30_000) {
> // Counter is there to wait for JIT compilation
> System.out.println("Must be compiled now, start doing some GCs " + ctr);
> // Here we simulate a safepoint, and a GC at this safepoint
> System.gc();
> try {
> // And here we wait for the reference handler to perform the cleaning to
> simulate a fast cleaning.
> Thread.sleep(1000);
> } catch (InterruptedException e) {
> Thread.currentThread().interrupt();
> }
> }
>
> long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
> length;
> unsafe.copyMemory(null, srcAddr, dst, offset, size);
> length -= size;
> srcAddr += size;
> offset += size;
> }
> }
>
> // A basic class inspired from java.nio.DirectByteBuffer
> static class SimpleBuffer {
> static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
> static final long arrayBaseOffset = (long)
> unsafe.arrayBaseOffset(byte[].class);
>
> final long addr;
>
> public SimpleBuffer() {
> addr = unsafe.allocateMemory(SIZE);
> unsafe.setMemory(addr, SIZE, (byte) 0);
> Cleaner.create(this, new Deallocator(addr));
> }
>
> public byte[] copy() {
> final byte[] a = new byte[SIZE];
> copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
> return a;
> }
>
> private static class Deallocator implements Runnable {
>
> private long address;
>
> private Deallocator(long address) {
> assert (address != 0);
> this.address = address;
> }
>
> @Override
> public void run() {
> if (address == 0) {
> // Paranoia
> return;
> }
> unsafe.freeMemory(address);
> address = 0;
> }
>
> }
>
> }
>
> static byte[] aBunchOfCopies() {
> byte[] res = null;
> for (int i = 0; i < 1000; ++i) {
> res = new SimpleBuffer().copy();
> if (res[0] == -1) {
> return res;
> }
> }
> return res;
> }
>
> public static void main(String[] args) {
> int i = 0;
> while (true) {
> final byte[] res = aBunchOfCopies();
> System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + " -- "
> + i++);
> }
> }
>
> private static final sun.misc.Unsafe retrieveUnsafe() {
> try {
> return sun.misc.Unsafe.getUnsafe();
> } catch (SecurityException se) {
> try {
> return java.security.AccessController
> .doPrivileged(new
> java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
> @Override
> public sun.misc.Unsafe run() throws Exception {
> java.lang.reflect.Field f =
> sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
> f.setAccessible(true);
> return (sun.misc.Unsafe) f.get(null);
> }
> });
> } catch (java.security.PrivilegedActionException e) {
> throw new RuntimeException("Could not initialize intrinsics",
> e.getCause());
> }
> }
> }
>
> }
>
>
> On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>> JIT knows about Unsafe operations, and it also knows the type of memory
>> being accessed (or sometimes knows it doesn't know :)).  So I don't think
>> it'll mark a DBB as unreachable while these operations are in-flight.
>>
>> Peter's scenario is unique to WeakReference since it's intentionally not
>> considered a strong reference and there's otherwise plain java code in his
>> example (that JIT can reason about easily otherwise).
>>
>> sent from my phone
>> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>> wrote:
>>
>>> Hi all,
>>>
>>> I recently had a look at the discussion started by Peter Levart on
>>> October 21 (
>>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>>> ).
>>>
>>> It was a very insightful discussion, and made me aware that the "this"
>>> object could be garbage collected while being inside a call of one of its
>>> method.
>>>
>>> However, this got me concerned about the java.nio.DirectByteBuffer read
>>> and write methods:
>>> If the "this" object is garbage collected when making a call like
>>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native pointer
>>> that is passed to sun.misc.Unsafe might be freed, and accessing it will
>>> cause the read/write to occur in an invalid memory area, which might lead
>>> to a segfault, or other major issues.
>>> This would be quite unlikely: JIT compilation needs to occur while
>>> keeping a safepoint, then a GC must happen, and finally the
>>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>>
>>> I am particularly concerned by the get(byte[] dst, int offset, int
>>> length) method, that in turns calls Bits.copyToArray, which purposely
>>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>>
>>> Am I correct, or does the JVM performs specific protection for instances
>>> of DirectByteBuffer?
>>>
>>> Regards,
>>>
>>> Alexandre de Champeaux
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>
>
> --
> Alexandre
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/c55d3fd9/attachment-0001.html>

From adc at quartetfs.com  Mon Dec  7 12:46:23 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Mon, 7 Dec 2015 18:46:23 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
Message-ID: <CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>

Yep things are fine if I add a call to a method similar to the position()
method of DBB after calling copyToArray().

On Mon, Dec 7, 2015 at 6:23 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Can you more closely mirror DBB by updating some state of your
> SimpleBuffer after calling copyToArray()? DBB returns 'this' from its
> get(byte[], ...) and also sets position after the Bits.copyToArray() method.
>
> On Mon, Dec 7, 2015 at 12:08 PM, Alexandre De Champeaux <adc at quartetfs.com
> > wrote:
>
>> I have actually written a test class that reproduces a segfault. It uses
>> an structure similar to DBB and an updated version of the Bits.copyToArray
>> method which forces a GC and waits a bit from within it to simulate a
>> safepoint stop and a GC, and leaves time to the reference handler to clean
>> up.
>> Is this test too far away from the DBB code to actually simulate a
>> possible behavior of DBB? Or is hotspot only able to not mark as
>> unreachable vanilla java DBB, but not customer classes?
>>
>> Here is the test class:
>>
>>
>> import sun.misc.Cleaner;
>> import sun.misc.Unsafe;
>>
>> /**
>>  * This test checks whether or not the JVM will dereference "this" and
>> destroy the buffer while
>>  * accessing it.
>>  * <p>
>>  * Run the main method of this class to run the test.
>>  * <p>
>>  * Note that the test segfaults each time if using a JNI call to
>> mmap/munmap to do the memory
>>  * management but not as often using Unsafe (malloc recycling memory?).
>>  * <p>
>>  * Example output of a failure:
>>  *
>>  * <pre>
>> TestGcThisAndDestroyBuffer.main() 0 -- 0
>> TestGcThisAndDestroyBuffer.main() 0 -- 1
>> TestGcThisAndDestroyBuffer.main() 0 -- 2
>> TestGcThisAndDestroyBuffer.main() 0 -- 3
>> TestGcThisAndDestroyBuffer.main() 0 -- 4
>> TestGcThisAndDestroyBuffer.main() 0 -- 5
>> TestGcThisAndDestroyBuffer.main() 0 -- 6
>> TestGcThisAndDestroyBuffer.main() 0 -- 7
>> TestGcThisAndDestroyBuffer.main() 0 -- 8
>> TestGcThisAndDestroyBuffer.main() 0 -- 9
>> TestGcThisAndDestroyBuffer.main() 0 -- 10
>> TestGcThisAndDestroyBuffer.main() 0 -- 11
>> TestGcThisAndDestroyBuffer.main() 0 -- 12
>> TestGcThisAndDestroyBuffer.main() 0 -- 13
>> TestGcThisAndDestroyBuffer.main() 0 -- 14
>> Must be compiled now, start doing some GCs 30001
>> #
>> # A fatal error has been detected by the Java Runtime Environment:
>> #
>> #  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949, tid=139949914818304
>> #
>> # JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
>> 1.8.0_60-b27)
>> # Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
>> linux-amd64 compressed oops)
>> # Problematic frame:
>> # V  [libjvm.so+0x7f7220]
>> #
>> # Failed to write core dump. Core dumps have been disabled. To enable
>> core dumping, try "ulimit -c unlimited" before starting Java again
>> #
>> # An error report file with more information is saved as:
>> #
>> /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
>> Compiled method (nm)   10180   18     n 0
>> sun.misc.Unsafe::copyMemory (native)
>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>> Compiled method (nm)   10180   18     n 0
>> sun.misc.Unsafe::copyMemory (native)
>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>> #
>> # If you would like to submit a bug report, please visit:
>> #   http://bugreport.java.com/bugreport/crash.jsp
>> #
>>  * </pre>
>>  */
>> @SuppressWarnings("restriction")
>> public class TestGcThisAndDestroyBuffer {
>>
>> /** The threshold found in Bits.copyMemory */
>> static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
>> private static final Unsafe unsafe = retrieveUnsafe();
>>
>> static long ctr = 0;
>>
>> // The tested method
>> // See the method in Bits.copyToArray
>> /* For Bits.copyToArray to segfault we need:
>> *
>> * 1) The buffer to be garbage collected while calling the method, for
>> that we need:
>> * - A safepoint exist in the method
>> * - The buffer needs to not be held, so JIT compil must have occured,
>> * and JIT must have dereferenced the DBB at the time of the call
>> * 2) The reference handler thread to have run the associated cleaner
>> */
>> static void copyToArray(long srcAddr, Object dst, long dstBaseOffset,
>> long dstPos, long length) {
>> long offset = dstBaseOffset + dstPos;
>> while (length > 0) {
>> // Code differing from Bits.
>> if (ctr++ >= 30_000) {
>> // Counter is there to wait for JIT compilation
>> System.out.println("Must be compiled now, start doing some GCs " + ctr);
>> // Here we simulate a safepoint, and a GC at this safepoint
>> System.gc();
>> try {
>> // And here we wait for the reference handler to perform the cleaning to
>> simulate a fast cleaning.
>> Thread.sleep(1000);
>> } catch (InterruptedException e) {
>> Thread.currentThread().interrupt();
>> }
>> }
>>
>> long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
>> length;
>> unsafe.copyMemory(null, srcAddr, dst, offset, size);
>> length -= size;
>> srcAddr += size;
>> offset += size;
>> }
>> }
>>
>> // A basic class inspired from java.nio.DirectByteBuffer
>> static class SimpleBuffer {
>> static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
>> static final long arrayBaseOffset = (long)
>> unsafe.arrayBaseOffset(byte[].class);
>>
>> final long addr;
>>
>> public SimpleBuffer() {
>> addr = unsafe.allocateMemory(SIZE);
>> unsafe.setMemory(addr, SIZE, (byte) 0);
>> Cleaner.create(this, new Deallocator(addr));
>> }
>>
>> public byte[] copy() {
>> final byte[] a = new byte[SIZE];
>> copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
>> return a;
>> }
>>
>> private static class Deallocator implements Runnable {
>>
>> private long address;
>>
>> private Deallocator(long address) {
>> assert (address != 0);
>> this.address = address;
>> }
>>
>> @Override
>> public void run() {
>> if (address == 0) {
>> // Paranoia
>> return;
>> }
>> unsafe.freeMemory(address);
>> address = 0;
>> }
>>
>> }
>>
>> }
>>
>> static byte[] aBunchOfCopies() {
>> byte[] res = null;
>> for (int i = 0; i < 1000; ++i) {
>> res = new SimpleBuffer().copy();
>> if (res[0] == -1) {
>> return res;
>> }
>> }
>> return res;
>> }
>>
>> public static void main(String[] args) {
>> int i = 0;
>> while (true) {
>> final byte[] res = aBunchOfCopies();
>> System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + " -- "
>> + i++);
>> }
>> }
>>
>> private static final sun.misc.Unsafe retrieveUnsafe() {
>> try {
>> return sun.misc.Unsafe.getUnsafe();
>> } catch (SecurityException se) {
>> try {
>> return java.security.AccessController
>> .doPrivileged(new
>> java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
>> @Override
>> public sun.misc.Unsafe run() throws Exception {
>> java.lang.reflect.Field f =
>> sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
>> f.setAccessible(true);
>> return (sun.misc.Unsafe) f.get(null);
>> }
>> });
>> } catch (java.security.PrivilegedActionException e) {
>> throw new RuntimeException("Could not initialize intrinsics",
>> e.getCause());
>> }
>> }
>> }
>>
>> }
>>
>>
>> On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>
>>> JIT knows about Unsafe operations, and it also knows the type of memory
>>> being accessed (or sometimes knows it doesn't know :)).  So I don't think
>>> it'll mark a DBB as unreachable while these operations are in-flight.
>>>
>>> Peter's scenario is unique to WeakReference since it's intentionally not
>>> considered a strong reference and there's otherwise plain java code in his
>>> example (that JIT can reason about easily otherwise).
>>>
>>> sent from my phone
>>> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>>> wrote:
>>>
>>>> Hi all,
>>>>
>>>> I recently had a look at the discussion started by Peter Levart on
>>>> October 21 (
>>>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>>>> ).
>>>>
>>>> It was a very insightful discussion, and made me aware that the "this"
>>>> object could be garbage collected while being inside a call of one of its
>>>> method.
>>>>
>>>> However, this got me concerned about the java.nio.DirectByteBuffer read
>>>> and write methods:
>>>> If the "this" object is garbage collected when making a call like
>>>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native
>>>> pointer that is passed to sun.misc.Unsafe might be freed, and accessing it
>>>> will cause the read/write to occur in an invalid memory area, which might
>>>> lead to a segfault, or other major issues.
>>>> This would be quite unlikely: JIT compilation needs to occur while
>>>> keeping a safepoint, then a GC must happen, and finally the
>>>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>>>
>>>> I am particularly concerned by the get(byte[] dst, int offset, int
>>>> length) method, that in turns calls Bits.copyToArray, which purposely
>>>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>>>
>>>> Am I correct, or does the JVM performs specific protection for
>>>> instances of DirectByteBuffer?
>>>>
>>>> Regards,
>>>>
>>>> Alexandre de Champeaux
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>
>>
>> --
>> Alexandre
>>
>
>


-- 
Alexandre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/1a5ab067/attachment-0001.html>

From vitalyd at gmail.com  Mon Dec  7 13:03:52 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 13:03:52 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
Message-ID: <CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>

Ok, good :).

So the difference between your original case and what DBB has is that the
"natural" lifetime of your SimpleBuffer ends prior to the unsafe
operation.  Once you "detach" a piece of unmanaged memory from a managed
wrapper (e.g. take the long address and start passing it around without the
wrapper), all bets are off.  But while the managed wrapper is "naturally"
live (i.e. as interpreter would treat it, or at least without subsequent
compiler optimizations) I'd expect (hope!) that the wrapper does not become
unreachable while those ops are in flight.

On Mon, Dec 7, 2015 at 12:46 PM, Alexandre De Champeaux <adc at quartetfs.com>
wrote:

> Yep things are fine if I add a call to a method similar to the position()
> method of DBB after calling copyToArray().
>
> On Mon, Dec 7, 2015 at 6:23 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>> Can you more closely mirror DBB by updating some state of your
>> SimpleBuffer after calling copyToArray()? DBB returns 'this' from its
>> get(byte[], ...) and also sets position after the Bits.copyToArray() method.
>>
>> On Mon, Dec 7, 2015 at 12:08 PM, Alexandre De Champeaux <
>> adc at quartetfs.com> wrote:
>>
>>> I have actually written a test class that reproduces a segfault. It uses
>>> an structure similar to DBB and an updated version of the Bits.copyToArray
>>> method which forces a GC and waits a bit from within it to simulate a
>>> safepoint stop and a GC, and leaves time to the reference handler to clean
>>> up.
>>> Is this test too far away from the DBB code to actually simulate a
>>> possible behavior of DBB? Or is hotspot only able to not mark as
>>> unreachable vanilla java DBB, but not customer classes?
>>>
>>> Here is the test class:
>>>
>>>
>>> import sun.misc.Cleaner;
>>> import sun.misc.Unsafe;
>>>
>>> /**
>>>  * This test checks whether or not the JVM will dereference "this" and
>>> destroy the buffer while
>>>  * accessing it.
>>>  * <p>
>>>  * Run the main method of this class to run the test.
>>>  * <p>
>>>  * Note that the test segfaults each time if using a JNI call to
>>> mmap/munmap to do the memory
>>>  * management but not as often using Unsafe (malloc recycling memory?).
>>>  * <p>
>>>  * Example output of a failure:
>>>  *
>>>  * <pre>
>>> TestGcThisAndDestroyBuffer.main() 0 -- 0
>>> TestGcThisAndDestroyBuffer.main() 0 -- 1
>>> TestGcThisAndDestroyBuffer.main() 0 -- 2
>>> TestGcThisAndDestroyBuffer.main() 0 -- 3
>>> TestGcThisAndDestroyBuffer.main() 0 -- 4
>>> TestGcThisAndDestroyBuffer.main() 0 -- 5
>>> TestGcThisAndDestroyBuffer.main() 0 -- 6
>>> TestGcThisAndDestroyBuffer.main() 0 -- 7
>>> TestGcThisAndDestroyBuffer.main() 0 -- 8
>>> TestGcThisAndDestroyBuffer.main() 0 -- 9
>>> TestGcThisAndDestroyBuffer.main() 0 -- 10
>>> TestGcThisAndDestroyBuffer.main() 0 -- 11
>>> TestGcThisAndDestroyBuffer.main() 0 -- 12
>>> TestGcThisAndDestroyBuffer.main() 0 -- 13
>>> TestGcThisAndDestroyBuffer.main() 0 -- 14
>>> Must be compiled now, start doing some GCs 30001
>>> #
>>> # A fatal error has been detected by the Java Runtime Environment:
>>> #
>>> #  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949, tid=139949914818304
>>> #
>>> # JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
>>> 1.8.0_60-b27)
>>> # Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
>>> linux-amd64 compressed oops)
>>> # Problematic frame:
>>> # V  [libjvm.so+0x7f7220]
>>> #
>>> # Failed to write core dump. Core dumps have been disabled. To enable
>>> core dumping, try "ulimit -c unlimited" before starting Java again
>>> #
>>> # An error report file with more information is saved as:
>>> #
>>> /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
>>> Compiled method (nm)   10180   18     n 0
>>> sun.misc.Unsafe::copyMemory (native)
>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>> Compiled method (nm)   10180   18     n 0
>>> sun.misc.Unsafe::copyMemory (native)
>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>> #
>>> # If you would like to submit a bug report, please visit:
>>> #   http://bugreport.java.com/bugreport/crash.jsp
>>> #
>>>  * </pre>
>>>  */
>>> @SuppressWarnings("restriction")
>>> public class TestGcThisAndDestroyBuffer {
>>>
>>> /** The threshold found in Bits.copyMemory */
>>> static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
>>> private static final Unsafe unsafe = retrieveUnsafe();
>>>
>>> static long ctr = 0;
>>>
>>> // The tested method
>>> // See the method in Bits.copyToArray
>>> /* For Bits.copyToArray to segfault we need:
>>> *
>>> * 1) The buffer to be garbage collected while calling the method, for
>>> that we need:
>>> * - A safepoint exist in the method
>>> * - The buffer needs to not be held, so JIT compil must have occured,
>>> * and JIT must have dereferenced the DBB at the time of the call
>>> * 2) The reference handler thread to have run the associated cleaner
>>> */
>>> static void copyToArray(long srcAddr, Object dst, long dstBaseOffset,
>>> long dstPos, long length) {
>>> long offset = dstBaseOffset + dstPos;
>>> while (length > 0) {
>>> // Code differing from Bits.
>>> if (ctr++ >= 30_000) {
>>> // Counter is there to wait for JIT compilation
>>> System.out.println("Must be compiled now, start doing some GCs " + ctr);
>>> // Here we simulate a safepoint, and a GC at this safepoint
>>> System.gc();
>>> try {
>>> // And here we wait for the reference handler to perform the cleaning to
>>> simulate a fast cleaning.
>>> Thread.sleep(1000);
>>> } catch (InterruptedException e) {
>>> Thread.currentThread().interrupt();
>>> }
>>> }
>>>
>>> long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
>>> length;
>>> unsafe.copyMemory(null, srcAddr, dst, offset, size);
>>> length -= size;
>>> srcAddr += size;
>>> offset += size;
>>> }
>>> }
>>>
>>> // A basic class inspired from java.nio.DirectByteBuffer
>>> static class SimpleBuffer {
>>> static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
>>> static final long arrayBaseOffset = (long)
>>> unsafe.arrayBaseOffset(byte[].class);
>>>
>>> final long addr;
>>>
>>> public SimpleBuffer() {
>>> addr = unsafe.allocateMemory(SIZE);
>>> unsafe.setMemory(addr, SIZE, (byte) 0);
>>> Cleaner.create(this, new Deallocator(addr));
>>> }
>>>
>>> public byte[] copy() {
>>> final byte[] a = new byte[SIZE];
>>> copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
>>> return a;
>>> }
>>>
>>> private static class Deallocator implements Runnable {
>>>
>>> private long address;
>>>
>>> private Deallocator(long address) {
>>> assert (address != 0);
>>> this.address = address;
>>> }
>>>
>>> @Override
>>> public void run() {
>>> if (address == 0) {
>>> // Paranoia
>>> return;
>>> }
>>> unsafe.freeMemory(address);
>>> address = 0;
>>> }
>>>
>>> }
>>>
>>> }
>>>
>>> static byte[] aBunchOfCopies() {
>>> byte[] res = null;
>>> for (int i = 0; i < 1000; ++i) {
>>> res = new SimpleBuffer().copy();
>>> if (res[0] == -1) {
>>> return res;
>>> }
>>> }
>>> return res;
>>> }
>>>
>>> public static void main(String[] args) {
>>> int i = 0;
>>> while (true) {
>>> final byte[] res = aBunchOfCopies();
>>> System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + " --
>>> " + i++);
>>> }
>>> }
>>>
>>> private static final sun.misc.Unsafe retrieveUnsafe() {
>>> try {
>>> return sun.misc.Unsafe.getUnsafe();
>>> } catch (SecurityException se) {
>>> try {
>>> return java.security.AccessController
>>> .doPrivileged(new
>>> java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
>>> @Override
>>> public sun.misc.Unsafe run() throws Exception {
>>> java.lang.reflect.Field f =
>>> sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
>>> f.setAccessible(true);
>>> return (sun.misc.Unsafe) f.get(null);
>>> }
>>> });
>>> } catch (java.security.PrivilegedActionException e) {
>>> throw new RuntimeException("Could not initialize intrinsics",
>>> e.getCause());
>>> }
>>> }
>>> }
>>>
>>> }
>>>
>>>
>>> On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>>
>>>> JIT knows about Unsafe operations, and it also knows the type of memory
>>>> being accessed (or sometimes knows it doesn't know :)).  So I don't think
>>>> it'll mark a DBB as unreachable while these operations are in-flight.
>>>>
>>>> Peter's scenario is unique to WeakReference since it's intentionally
>>>> not considered a strong reference and there's otherwise plain java code in
>>>> his example (that JIT can reason about easily otherwise).
>>>>
>>>> sent from my phone
>>>> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>>>> wrote:
>>>>
>>>>> Hi all,
>>>>>
>>>>> I recently had a look at the discussion started by Peter Levart on
>>>>> October 21 (
>>>>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>>>>> ).
>>>>>
>>>>> It was a very insightful discussion, and made me aware that the "this"
>>>>> object could be garbage collected while being inside a call of one of its
>>>>> method.
>>>>>
>>>>> However, this got me concerned about the java.nio.DirectByteBuffer
>>>>> read and write methods:
>>>>> If the "this" object is garbage collected when making a call like
>>>>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native
>>>>> pointer that is passed to sun.misc.Unsafe might be freed, and accessing it
>>>>> will cause the read/write to occur in an invalid memory area, which might
>>>>> lead to a segfault, or other major issues.
>>>>> This would be quite unlikely: JIT compilation needs to occur while
>>>>> keeping a safepoint, then a GC must happen, and finally the
>>>>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>>>>
>>>>> I am particularly concerned by the get(byte[] dst, int offset, int
>>>>> length) method, that in turns calls Bits.copyToArray, which purposely
>>>>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>>>>
>>>>> Am I correct, or does the JVM performs specific protection for
>>>>> instances of DirectByteBuffer?
>>>>>
>>>>> Regards,
>>>>>
>>>>> Alexandre de Champeaux
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>
>>>
>>> --
>>> Alexandre
>>>
>>
>>
>
>
> --
> Alexandre
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/1e82cdeb/attachment-0001.html>

From adc at quartetfs.com  Mon Dec  7 13:36:29 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Mon, 7 Dec 2015 19:36:29 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
Message-ID: <CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>

Ok thanks.
Correct me if I'm wrong, but basically what you are saying is that hotspot
does not perform advanced enough analysis to see that 'this' is actually
unnecessary after the call to unsafe. So there is no practical risk to read
invalid data/crash, but only a theoretical one.
What about the standard get() methods of DBB? Since they do not update the
state of the buffer after the call, are they also protected in some way at
the practical level? Or is it unlikely (impossible?) to have a GC safepoint
just at the end of the ix(int) method? I guess even if this happen, you
would need to be very very unlucky to have the reference handler clean the
Cleaners fast enough...


On Mon, Dec 7, 2015 at 7:03 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> Ok, good :).
>
> So the difference between your original case and what DBB has is that the
> "natural" lifetime of your SimpleBuffer ends prior to the unsafe
> operation.  Once you "detach" a piece of unmanaged memory from a managed
> wrapper (e.g. take the long address and start passing it around without the
> wrapper), all bets are off.  But while the managed wrapper is "naturally"
> live (i.e. as interpreter would treat it, or at least without subsequent
> compiler optimizations) I'd expect (hope!) that the wrapper does not become
> unreachable while those ops are in flight.
>
> On Mon, Dec 7, 2015 at 12:46 PM, Alexandre De Champeaux <adc at quartetfs.com
> > wrote:
>
>> Yep things are fine if I add a call to a method similar to the position()
>> method of DBB after calling copyToArray().
>>
>> On Mon, Dec 7, 2015 at 6:23 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>
>>> Can you more closely mirror DBB by updating some state of your
>>> SimpleBuffer after calling copyToArray()? DBB returns 'this' from its
>>> get(byte[], ...) and also sets position after the Bits.copyToArray() method.
>>>
>>> On Mon, Dec 7, 2015 at 12:08 PM, Alexandre De Champeaux <
>>> adc at quartetfs.com> wrote:
>>>
>>>> I have actually written a test class that reproduces a segfault. It
>>>> uses an structure similar to DBB and an updated version of the
>>>> Bits.copyToArray method which forces a GC and waits a bit from within it to
>>>> simulate a safepoint stop and a GC, and leaves time to the reference
>>>> handler to clean up.
>>>> Is this test too far away from the DBB code to actually simulate a
>>>> possible behavior of DBB? Or is hotspot only able to not mark as
>>>> unreachable vanilla java DBB, but not customer classes?
>>>>
>>>> Here is the test class:
>>>>
>>>>
>>>> import sun.misc.Cleaner;
>>>> import sun.misc.Unsafe;
>>>>
>>>> /**
>>>>  * This test checks whether or not the JVM will dereference "this" and
>>>> destroy the buffer while
>>>>  * accessing it.
>>>>  * <p>
>>>>  * Run the main method of this class to run the test.
>>>>  * <p>
>>>>  * Note that the test segfaults each time if using a JNI call to
>>>> mmap/munmap to do the memory
>>>>  * management but not as often using Unsafe (malloc recycling memory?).
>>>>  * <p>
>>>>  * Example output of a failure:
>>>>  *
>>>>  * <pre>
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 0
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 1
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 2
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 3
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 4
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 5
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 6
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 7
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 8
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 9
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 10
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 11
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 12
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 13
>>>> TestGcThisAndDestroyBuffer.main() 0 -- 14
>>>> Must be compiled now, start doing some GCs 30001
>>>> #
>>>> # A fatal error has been detected by the Java Runtime Environment:
>>>> #
>>>> #  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949,
>>>> tid=139949914818304
>>>> #
>>>> # JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
>>>> 1.8.0_60-b27)
>>>> # Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
>>>> linux-amd64 compressed oops)
>>>> # Problematic frame:
>>>> # V  [libjvm.so+0x7f7220]
>>>> #
>>>> # Failed to write core dump. Core dumps have been disabled. To enable
>>>> core dumping, try "ulimit -c unlimited" before starting Java again
>>>> #
>>>> # An error report file with more information is saved as:
>>>> #
>>>> /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
>>>> Compiled method (nm)   10180   18     n 0
>>>> sun.misc.Unsafe::copyMemory (native)
>>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>>> Compiled method (nm)   10180   18     n 0
>>>> sun.misc.Unsafe::copyMemory (native)
>>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>>> #
>>>> # If you would like to submit a bug report, please visit:
>>>> #   http://bugreport.java.com/bugreport/crash.jsp
>>>> #
>>>>  * </pre>
>>>>  */
>>>> @SuppressWarnings("restriction")
>>>> public class TestGcThisAndDestroyBuffer {
>>>>
>>>> /** The threshold found in Bits.copyMemory */
>>>> static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
>>>> private static final Unsafe unsafe = retrieveUnsafe();
>>>>
>>>> static long ctr = 0;
>>>>
>>>> // The tested method
>>>> // See the method in Bits.copyToArray
>>>> /* For Bits.copyToArray to segfault we need:
>>>> *
>>>> * 1) The buffer to be garbage collected while calling the method, for
>>>> that we need:
>>>> * - A safepoint exist in the method
>>>> * - The buffer needs to not be held, so JIT compil must have occured,
>>>> * and JIT must have dereferenced the DBB at the time of the call
>>>> * 2) The reference handler thread to have run the associated cleaner
>>>> */
>>>> static void copyToArray(long srcAddr, Object dst, long dstBaseOffset,
>>>> long dstPos, long length) {
>>>> long offset = dstBaseOffset + dstPos;
>>>> while (length > 0) {
>>>> // Code differing from Bits.
>>>> if (ctr++ >= 30_000) {
>>>> // Counter is there to wait for JIT compilation
>>>> System.out.println("Must be compiled now, start doing some GCs " + ctr);
>>>> // Here we simulate a safepoint, and a GC at this safepoint
>>>> System.gc();
>>>> try {
>>>> // And here we wait for the reference handler to perform the cleaning
>>>> to simulate a fast cleaning.
>>>> Thread.sleep(1000);
>>>> } catch (InterruptedException e) {
>>>> Thread.currentThread().interrupt();
>>>> }
>>>> }
>>>>
>>>> long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
>>>> length;
>>>> unsafe.copyMemory(null, srcAddr, dst, offset, size);
>>>> length -= size;
>>>> srcAddr += size;
>>>> offset += size;
>>>> }
>>>> }
>>>>
>>>> // A basic class inspired from java.nio.DirectByteBuffer
>>>> static class SimpleBuffer {
>>>> static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
>>>> static final long arrayBaseOffset = (long)
>>>> unsafe.arrayBaseOffset(byte[].class);
>>>>
>>>> final long addr;
>>>>
>>>> public SimpleBuffer() {
>>>> addr = unsafe.allocateMemory(SIZE);
>>>> unsafe.setMemory(addr, SIZE, (byte) 0);
>>>> Cleaner.create(this, new Deallocator(addr));
>>>> }
>>>>
>>>> public byte[] copy() {
>>>> final byte[] a = new byte[SIZE];
>>>> copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
>>>> return a;
>>>> }
>>>>
>>>> private static class Deallocator implements Runnable {
>>>>
>>>> private long address;
>>>>
>>>> private Deallocator(long address) {
>>>> assert (address != 0);
>>>> this.address = address;
>>>> }
>>>>
>>>> @Override
>>>> public void run() {
>>>> if (address == 0) {
>>>> // Paranoia
>>>> return;
>>>> }
>>>> unsafe.freeMemory(address);
>>>> address = 0;
>>>> }
>>>>
>>>> }
>>>>
>>>> }
>>>>
>>>> static byte[] aBunchOfCopies() {
>>>> byte[] res = null;
>>>> for (int i = 0; i < 1000; ++i) {
>>>> res = new SimpleBuffer().copy();
>>>> if (res[0] == -1) {
>>>> return res;
>>>> }
>>>> }
>>>> return res;
>>>> }
>>>>
>>>> public static void main(String[] args) {
>>>> int i = 0;
>>>> while (true) {
>>>> final byte[] res = aBunchOfCopies();
>>>> System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + " --
>>>> " + i++);
>>>> }
>>>> }
>>>>
>>>> private static final sun.misc.Unsafe retrieveUnsafe() {
>>>> try {
>>>> return sun.misc.Unsafe.getUnsafe();
>>>> } catch (SecurityException se) {
>>>> try {
>>>> return java.security.AccessController
>>>> .doPrivileged(new
>>>> java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
>>>> @Override
>>>> public sun.misc.Unsafe run() throws Exception {
>>>> java.lang.reflect.Field f =
>>>> sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
>>>> f.setAccessible(true);
>>>> return (sun.misc.Unsafe) f.get(null);
>>>> }
>>>> });
>>>> } catch (java.security.PrivilegedActionException e) {
>>>> throw new RuntimeException("Could not initialize intrinsics",
>>>> e.getCause());
>>>> }
>>>> }
>>>> }
>>>>
>>>> }
>>>>
>>>>
>>>> On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>>
>>>>> JIT knows about Unsafe operations, and it also knows the type of
>>>>> memory being accessed (or sometimes knows it doesn't know :)).  So I don't
>>>>> think it'll mark a DBB as unreachable while these operations are in-flight.
>>>>>
>>>>> Peter's scenario is unique to WeakReference since it's intentionally
>>>>> not considered a strong reference and there's otherwise plain java code in
>>>>> his example (that JIT can reason about easily otherwise).
>>>>>
>>>>> sent from my phone
>>>>> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>>>>> wrote:
>>>>>
>>>>>> Hi all,
>>>>>>
>>>>>> I recently had a look at the discussion started by Peter Levart on
>>>>>> October 21 (
>>>>>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>>>>>> ).
>>>>>>
>>>>>> It was a very insightful discussion, and made me aware that the
>>>>>> "this" object could be garbage collected while being inside a call of one
>>>>>> of its method.
>>>>>>
>>>>>> However, this got me concerned about the java.nio.DirectByteBuffer
>>>>>> read and write methods:
>>>>>> If the "this" object is garbage collected when making a call like
>>>>>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native
>>>>>> pointer that is passed to sun.misc.Unsafe might be freed, and accessing it
>>>>>> will cause the read/write to occur in an invalid memory area, which might
>>>>>> lead to a segfault, or other major issues.
>>>>>> This would be quite unlikely: JIT compilation needs to occur while
>>>>>> keeping a safepoint, then a GC must happen, and finally the
>>>>>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>>>>>
>>>>>> I am particularly concerned by the get(byte[] dst, int offset, int
>>>>>> length) method, that in turns calls Bits.copyToArray, which purposely
>>>>>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>>>>>
>>>>>> Am I correct, or does the JVM performs specific protection for
>>>>>> instances of DirectByteBuffer?
>>>>>>
>>>>>> Regards,
>>>>>>
>>>>>> Alexandre de Champeaux
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>
>>>>
>>>> --
>>>> Alexandre
>>>>
>>>
>>>
>>
>>
>> --
>> Alexandre
>>
>
>


-- 
Alexandre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/fd8cadb7/attachment-0001.html>

From vitalyd at gmail.com  Mon Dec  7 14:17:26 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 7 Dec 2015 14:17:26 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
Message-ID: <CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>

>
> Correct me if I'm wrong, but basically what you are saying is that hotspot
> does not perform advanced enough analysis to see that 'this' is actually
> unnecessary after the call to unsafe.


In which case? In DBB, `this` is still necessary after the Unsafe call
since it needs to update position.  In theory, it could move position
update prior to calling Bits.copyToArray() but it would have to prove that
it's safe to do so.  Part of that safety check would require it to reason
about memory effects, side effects, and failure cases (i.e. position update
isn't reached if there's an exception, it would need to preserve that
effect, also taking into account that it may not be able to speculatively
write to memory and then undo those effects in case of exception).  So the
answer is probably "yes" to your question above, in a theoretical sense
only.

What about the standard get() methods of DBB? Since they do not update the
> state of the buffer after the call, are they also protected in some way at
> the practical level? Or is it unlikely (impossible?) to have a GC safepoint
> just at the end of the ix(int) method? I guess even if this happen, you
> would need to be very very unlucky to have the reference handler clean the
> Cleaners fast enough...


I think the reasoning here is similar to the above.  ByteBuffer.get() is
invoked on a DBB instance, compiler sees a call to Unsafe.getXXX at some
point.  The "natural" lifetime of the instance survives until the instance
method returns.  So if compiler now wanted to shorten this by observing
that `this` is unreachable sooner than method exit, it has to prove a bunch
of things like I mentioned above.

Mind you, this is just my understanding -- I'm not speaking to this in any
authoritative manner :).

On Mon, Dec 7, 2015 at 1:36 PM, Alexandre De Champeaux <adc at quartetfs.com>
wrote:

> Ok thanks.
> Correct me if I'm wrong, but basically what you are saying is that hotspot
> does not perform advanced enough analysis to see that 'this' is actually
> unnecessary after the call to unsafe. So there is no practical risk to read
> invalid data/crash, but only a theoretical one.
> What about the standard get() methods of DBB? Since they do not update the
> state of the buffer after the call, are they also protected in some way at
> the practical level? Or is it unlikely (impossible?) to have a GC safepoint
> just at the end of the ix(int) method? I guess even if this happen, you
> would need to be very very unlucky to have the reference handler clean the
> Cleaners fast enough...
>
>
> On Mon, Dec 7, 2015 at 7:03 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>> Ok, good :).
>>
>> So the difference between your original case and what DBB has is that the
>> "natural" lifetime of your SimpleBuffer ends prior to the unsafe
>> operation.  Once you "detach" a piece of unmanaged memory from a managed
>> wrapper (e.g. take the long address and start passing it around without the
>> wrapper), all bets are off.  But while the managed wrapper is "naturally"
>> live (i.e. as interpreter would treat it, or at least without subsequent
>> compiler optimizations) I'd expect (hope!) that the wrapper does not become
>> unreachable while those ops are in flight.
>>
>> On Mon, Dec 7, 2015 at 12:46 PM, Alexandre De Champeaux <
>> adc at quartetfs.com> wrote:
>>
>>> Yep things are fine if I add a call to a method similar to the
>>> position() method of DBB after calling copyToArray().
>>>
>>> On Mon, Dec 7, 2015 at 6:23 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>> wrote:
>>>
>>>> Can you more closely mirror DBB by updating some state of your
>>>> SimpleBuffer after calling copyToArray()? DBB returns 'this' from its
>>>> get(byte[], ...) and also sets position after the Bits.copyToArray() method.
>>>>
>>>> On Mon, Dec 7, 2015 at 12:08 PM, Alexandre De Champeaux <
>>>> adc at quartetfs.com> wrote:
>>>>
>>>>> I have actually written a test class that reproduces a segfault. It
>>>>> uses an structure similar to DBB and an updated version of the
>>>>> Bits.copyToArray method which forces a GC and waits a bit from within it to
>>>>> simulate a safepoint stop and a GC, and leaves time to the reference
>>>>> handler to clean up.
>>>>> Is this test too far away from the DBB code to actually simulate a
>>>>> possible behavior of DBB? Or is hotspot only able to not mark as
>>>>> unreachable vanilla java DBB, but not customer classes?
>>>>>
>>>>> Here is the test class:
>>>>>
>>>>>
>>>>> import sun.misc.Cleaner;
>>>>> import sun.misc.Unsafe;
>>>>>
>>>>> /**
>>>>>  * This test checks whether or not the JVM will dereference "this" and
>>>>> destroy the buffer while
>>>>>  * accessing it.
>>>>>  * <p>
>>>>>  * Run the main method of this class to run the test.
>>>>>  * <p>
>>>>>  * Note that the test segfaults each time if using a JNI call to
>>>>> mmap/munmap to do the memory
>>>>>  * management but not as often using Unsafe (malloc recycling memory?).
>>>>>  * <p>
>>>>>  * Example output of a failure:
>>>>>  *
>>>>>  * <pre>
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 0
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 1
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 2
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 3
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 4
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 5
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 6
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 7
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 8
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 9
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 10
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 11
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 12
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 13
>>>>> TestGcThisAndDestroyBuffer.main() 0 -- 14
>>>>> Must be compiled now, start doing some GCs 30001
>>>>> #
>>>>> # A fatal error has been detected by the Java Runtime Environment:
>>>>> #
>>>>> #  SIGSEGV (0xb) at pc=0x00007f489fb86220, pid=16949,
>>>>> tid=139949914818304
>>>>> #
>>>>> # JRE version: Java(TM) SE Runtime Environment (8.0_60-b27) (build
>>>>> 1.8.0_60-b27)
>>>>> # Java VM: Java HotSpot(TM) 64-Bit Server VM (25.60-b23 mixed mode
>>>>> linux-amd64 compressed oops)
>>>>> # Problematic frame:
>>>>> # V  [libjvm.so+0x7f7220]
>>>>> #
>>>>> # Failed to write core dump. Core dumps have been disabled. To enable
>>>>> core dumping, try "ulimit -c unlimited" before starting Java again
>>>>> #
>>>>> # An error report file with more information is saved as:
>>>>> #
>>>>> /SSDhome/alexandre/ActivePivot5/scripts/adc/java_tests/hs_err_pid16949.log
>>>>> Compiled method (nm)   10180   18     n 0
>>>>> sun.misc.Unsafe::copyMemory (native)
>>>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>>>> Compiled method (nm)   10180   18     n 0
>>>>> sun.misc.Unsafe::copyMemory (native)
>>>>> total in heap  [0x00007f488910f2d0,0x00007f488910f640] = 880
>>>>> relocation     [0x00007f488910f3f8,0x00007f488910f440] = 72
>>>>> main code      [0x00007f488910f440,0x00007f488910f640] = 512
>>>>> #
>>>>> # If you would like to submit a bug report, please visit:
>>>>> #   http://bugreport.java.com/bugreport/crash.jsp
>>>>> #
>>>>>  * </pre>
>>>>>  */
>>>>> @SuppressWarnings("restriction")
>>>>> public class TestGcThisAndDestroyBuffer {
>>>>>
>>>>> /** The threshold found in Bits.copyMemory */
>>>>> static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
>>>>> private static final Unsafe unsafe = retrieveUnsafe();
>>>>>
>>>>> static long ctr = 0;
>>>>>
>>>>> // The tested method
>>>>> // See the method in Bits.copyToArray
>>>>> /* For Bits.copyToArray to segfault we need:
>>>>> *
>>>>> * 1) The buffer to be garbage collected while calling the method, for
>>>>> that we need:
>>>>> * - A safepoint exist in the method
>>>>> * - The buffer needs to not be held, so JIT compil must have occured,
>>>>> * and JIT must have dereferenced the DBB at the time of the call
>>>>> * 2) The reference handler thread to have run the associated cleaner
>>>>> */
>>>>> static void copyToArray(long srcAddr, Object dst, long dstBaseOffset,
>>>>> long dstPos, long length) {
>>>>> long offset = dstBaseOffset + dstPos;
>>>>> while (length > 0) {
>>>>> // Code differing from Bits.
>>>>> if (ctr++ >= 30_000) {
>>>>> // Counter is there to wait for JIT compilation
>>>>> System.out.println("Must be compiled now, start doing some GCs " +
>>>>> ctr);
>>>>> // Here we simulate a safepoint, and a GC at this safepoint
>>>>> System.gc();
>>>>> try {
>>>>> // And here we wait for the reference handler to perform the cleaning
>>>>> to simulate a fast cleaning.
>>>>> Thread.sleep(1000);
>>>>> } catch (InterruptedException e) {
>>>>> Thread.currentThread().interrupt();
>>>>> }
>>>>> }
>>>>>
>>>>> long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD :
>>>>> length;
>>>>> unsafe.copyMemory(null, srcAddr, dst, offset, size);
>>>>> length -= size;
>>>>> srcAddr += size;
>>>>> offset += size;
>>>>> }
>>>>> }
>>>>>
>>>>> // A basic class inspired from java.nio.DirectByteBuffer
>>>>> static class SimpleBuffer {
>>>>> static int SIZE = (int) (2 * UNSAFE_COPY_THRESHOLD);
>>>>> static final long arrayBaseOffset = (long)
>>>>> unsafe.arrayBaseOffset(byte[].class);
>>>>>
>>>>> final long addr;
>>>>>
>>>>> public SimpleBuffer() {
>>>>> addr = unsafe.allocateMemory(SIZE);
>>>>> unsafe.setMemory(addr, SIZE, (byte) 0);
>>>>> Cleaner.create(this, new Deallocator(addr));
>>>>> }
>>>>>
>>>>> public byte[] copy() {
>>>>> final byte[] a = new byte[SIZE];
>>>>> copyToArray(addr, a, arrayBaseOffset, 0, SIZE);
>>>>> return a;
>>>>> }
>>>>>
>>>>> private static class Deallocator implements Runnable {
>>>>>
>>>>> private long address;
>>>>>
>>>>> private Deallocator(long address) {
>>>>> assert (address != 0);
>>>>> this.address = address;
>>>>> }
>>>>>
>>>>> @Override
>>>>> public void run() {
>>>>> if (address == 0) {
>>>>> // Paranoia
>>>>> return;
>>>>> }
>>>>> unsafe.freeMemory(address);
>>>>> address = 0;
>>>>> }
>>>>>
>>>>> }
>>>>>
>>>>> }
>>>>>
>>>>> static byte[] aBunchOfCopies() {
>>>>> byte[] res = null;
>>>>> for (int i = 0; i < 1000; ++i) {
>>>>> res = new SimpleBuffer().copy();
>>>>> if (res[0] == -1) {
>>>>> return res;
>>>>> }
>>>>> }
>>>>> return res;
>>>>> }
>>>>>
>>>>> public static void main(String[] args) {
>>>>> int i = 0;
>>>>> while (true) {
>>>>> final byte[] res = aBunchOfCopies();
>>>>> System.out.println("TestGcThisAndDestroyBuffer.main() " + res[0] + "
>>>>> -- " + i++);
>>>>> }
>>>>> }
>>>>>
>>>>> private static final sun.misc.Unsafe retrieveUnsafe() {
>>>>> try {
>>>>> return sun.misc.Unsafe.getUnsafe();
>>>>> } catch (SecurityException se) {
>>>>> try {
>>>>> return java.security.AccessController
>>>>> .doPrivileged(new
>>>>> java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
>>>>> @Override
>>>>> public sun.misc.Unsafe run() throws Exception {
>>>>> java.lang.reflect.Field f =
>>>>> sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
>>>>> f.setAccessible(true);
>>>>> return (sun.misc.Unsafe) f.get(null);
>>>>> }
>>>>> });
>>>>> } catch (java.security.PrivilegedActionException e) {
>>>>> throw new RuntimeException("Could not initialize intrinsics",
>>>>> e.getCause());
>>>>> }
>>>>> }
>>>>> }
>>>>>
>>>>> }
>>>>>
>>>>>
>>>>> On Mon, Dec 7, 2015 at 4:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> JIT knows about Unsafe operations, and it also knows the type of
>>>>>> memory being accessed (or sometimes knows it doesn't know :)).  So I don't
>>>>>> think it'll mark a DBB as unreachable while these operations are in-flight.
>>>>>>
>>>>>> Peter's scenario is unique to WeakReference since it's intentionally
>>>>>> not considered a strong reference and there's otherwise plain java code in
>>>>>> his example (that JIT can reason about easily otherwise).
>>>>>>
>>>>>> sent from my phone
>>>>>> On Dec 7, 2015 8:10 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>>>>>> wrote:
>>>>>>
>>>>>>> Hi all,
>>>>>>>
>>>>>>> I recently had a look at the discussion started by Peter Levart on
>>>>>>> October 21 (
>>>>>>> http://cs.oswego.edu/pipermail/concurrency-interest/2015-October/014493.html
>>>>>>> ).
>>>>>>>
>>>>>>> It was a very insightful discussion, and made me aware that the
>>>>>>> "this" object could be garbage collected while being inside a call of one
>>>>>>> of its method.
>>>>>>>
>>>>>>> However, this got me concerned about the java.nio.DirectByteBuffer
>>>>>>> read and write methods:
>>>>>>> If the "this" object is garbage collected when making a call like
>>>>>>> ByteBuffer.allocateDirect(int).someGetOrPutMethod(), the native
>>>>>>> pointer that is passed to sun.misc.Unsafe might be freed, and accessing it
>>>>>>> will cause the read/write to occur in an invalid memory area, which might
>>>>>>> lead to a segfault, or other major issues.
>>>>>>> This would be quite unlikely: JIT compilation needs to occur while
>>>>>>> keeping a safepoint, then a GC must happen, and finally the
>>>>>>> ReferenceHandler thread needs to perform its cleanup fast enough.
>>>>>>>
>>>>>>> I am particularly concerned by the get(byte[] dst, int offset, int
>>>>>>> length) method, that in turns calls Bits.copyToArray, which purposely
>>>>>>> splits its calls to Unsafe.copyMemory to allow for safepoints to sneak in.
>>>>>>>
>>>>>>> Am I correct, or does the JVM performs specific protection for
>>>>>>> instances of DirectByteBuffer?
>>>>>>>
>>>>>>> Regards,
>>>>>>>
>>>>>>> Alexandre de Champeaux
>>>>>>>
>>>>>>> _______________________________________________
>>>>>>> Concurrency-interest mailing list
>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Alexandre
>>>>>
>>>>
>>>>
>>>
>>>
>>> --
>>> Alexandre
>>>
>>
>>
>
>
> --
> Alexandre
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151207/92a02c03/attachment-0001.html>

From aph at redhat.com  Tue Dec  8 04:49:23 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 09:49:23 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
Message-ID: <5666A7A3.2070505@redhat.com>

On 07/12/15 19:17, Vitaly Davidovich wrote:
>>
>> Correct me if I'm wrong, but basically what you are saying is that hotspot
>> does not perform advanced enough analysis to see that 'this' is actually
>> unnecessary after the call to unsafe.
> 
> 
> In which case? In DBB, `this` is still necessary after the Unsafe call
> since it needs to update position.  In theory, it could move position
> update prior to calling Bits.copyToArray() but it would have to prove that
> it's safe to do so.

That's not at all hard for HotSpot to do.

> Part of that safety check would require it to reason about memory
> effects, side effects, and failure cases (i.e. position update isn't
> reached if there's an exception,

What exception?  HotSpot knows everything about Bits.copyToArray()
because it is inlined.  It knows about all the arguments and
eliminates bounds checks.

> it would need to preserve that effect, also taking into account that
> it may not be able to speculatively write to memory and then undo
> those effects in case of exception).  So the answer is probably
> "yes" to your question above, in a theoretical sense only.

Not at all.

> I think the reasoning here is similar to the above.
> ByteBuffer.get() is invoked on a DBB instance, compiler sees a call
> to Unsafe.getXXX at some point.  The "natural" lifetime of the
> instance survives until the instance method returns. 

No, this is completely wrong.

> So if compiler now wanted to shorten this by observing that `this`
> is unreachable sooner than method exit, it has to prove a bunch of
> things like I mentioned above.

Now inline everything.

Please stop sepeculating about what an optimizer can and can't do.
Please instead concerntrate on the semantics of the language and think
about correctness.

Andrew.

From aph at redhat.com  Tue Dec  8 04:50:08 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 09:50:08 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<56659A96.7090706@redhat.com>
	<CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>
Message-ID: <5666A7D0.6030109@redhat.com>

On 07/12/15 15:20, Vitaly Davidovich wrote:
> If reachabilityFence use is going to proliferate, especially in perf
> sensitive places, Hotspot will need to make this method simply a
> liveness marker and not emit a call like the current
> prototype/version is doing.

Perhaps, but we've already discussed that, and it's not so hard.
Surely correctness comes first, then we optimize.  I expect we're
going to need a reachabilityFence in many (almost all?) methods of
classes with finalizers.

Andrew.

From aph at redhat.com  Tue Dec  8 06:06:12 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 11:06:12 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666A7A3.2070505@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
Message-ID: <5666B9A4.7060408@redhat.com>

I'm sorry, that reply was unnecessarily harsh.  However, I do
this that such speculation is dangerous.

Andrew.

From vitalyd at gmail.com  Tue Dec  8 06:56:13 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 06:56:13 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666A7D0.6030109@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<56659A96.7090706@redhat.com>
	<CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>
	<5666A7D0.6030109@redhat.com>
Message-ID: <CAHjP37HTSm845G5jAeUQCvLQ1hvCv_sGJWMFcSqMTx82EOPo4A@mail.gmail.com>

We did discuss it, and on that thread an Oracle engineer said there's no
plan to do that.  In addition, there's a JBS entry to optimize empty method
calls by removing prologue and epilogue, with reachabilityFence as the
motivator for that.  Correctness does come first, but these are
orthogonal/parallel concerns: someone has to update JDK code with this API
and someone else has to lower the call in the optimizer.  I don't think
this call can/should be liberally sprinkled in performance sensitive code
if it actually emits a call, this shouldn't happen from day 1.

sent from my phone
On Dec 8, 2015 4:50 AM, "Andrew Haley" <aph at redhat.com> wrote:

> On 07/12/15 15:20, Vitaly Davidovich wrote:
> > If reachabilityFence use is going to proliferate, especially in perf
> > sensitive places, Hotspot will need to make this method simply a
> > liveness marker and not emit a call like the current
> > prototype/version is doing.
>
> Perhaps, but we've already discussed that, and it's not so hard.
> Surely correctness comes first, then we optimize.  I expect we're
> going to need a reachabilityFence in many (almost all?) methods of
> classes with finalizers.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/23dd0153/attachment.html>

From vitalyd at gmail.com  Tue Dec  8 06:59:57 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 06:59:57 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666A7A3.2070505@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
Message-ID: <CAHjP37Fx1Wr1xLTiHCDTnQ6pvtMRKvv9SRWNE-pxJO0x1M7p=w@mail.gmail.com>

sent from my phone
On Dec 8, 2015 4:58 AM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 07/12/15 19:17, Vitaly Davidovich wrote:
> >>
> >> Correct me if I'm wrong, but basically what you are saying is that
hotspot
> >> does not perform advanced enough analysis to see that 'this' is
actually
> >> unnecessary after the call to unsafe.
> >
> >
> > In which case? In DBB, `this` is still necessary after the Unsafe call
> > since it needs to update position.  In theory, it could move position
> > update prior to calling Bits.copyToArray() but it would have to prove
that
> > it's safe to do so.
>
> That's not at all hard for HotSpot to do.
>
> > Part of that safety check would require it to reason about memory
> > effects, side effects, and failure cases (i.e. position update isn't
> > reached if there's an exception,
>
> What exception?  HotSpot knows everything about Bits.copyToArray()
> because it is inlined.  It knows about all the arguments and
> eliminates bounds checks.
>
> > it would need to preserve that effect, also taking into account that
> > it may not be able to speculatively write to memory and then undo
> > those effects in case of exception).  So the answer is probably
> > "yes" to your question above, in a theoretical sense only.
>
> Not at all.
>
> > I think the reasoning here is similar to the above.
> > ByteBuffer.get() is invoked on a DBB instance, compiler sees a call
> > to Unsafe.getXXX at some point.  The "natural" lifetime of the
> > instance survives until the instance method returns.
>
> No, this is completely wrong.
>
> > So if compiler now wanted to shorten this by observing that `this`
> > is unreachable sooner than method exit, it has to prove a bunch of
> > things like I mentioned above.
>
> Now inline everything.
>
> Please stop sepeculating about what an optimizer can and can't do.
> Please instead concerntrate on the semantics of the language and think
> about correctness.
>
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/1e3bfea3/attachment.html>

From vitalyd at gmail.com  Tue Dec  8 07:07:25 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 07:07:25 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666A7A3.2070505@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
Message-ID: <CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>

sent from my phone
On Dec 8, 2015 4:58 AM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 07/12/15 19:17, Vitaly Davidovich wrote:
> >>
> >> Correct me if I'm wrong, but basically what you are saying is that
hotspot
> >> does not perform advanced enough analysis to see that 'this' is
actually
> >> unnecessary after the call to unsafe.
> >
> >
> > In which case? In DBB, `this` is still necessary after the Unsafe call
> > since it needs to update position.  In theory, it could move position
> > update prior to calling Bits.copyToArray() but it would have to prove
that
> > it's safe to do so.
>
> That's not at all hard for HotSpot to do.
>
> > Part of that safety check would require it to reason about memory
> > effects, side effects, and failure cases (i.e. position update isn't
> > reached if there's an exception,
>
> What exception?  HotSpot knows everything about Bits.copyToArray()
> because it is inlined.  It knows about all the arguments and
> eliminates bounds checks.

This was a general statement about optimization.  By exception, I really
mean control flow.

>
> > it would need to preserve that effect, also taking into account that
> > it may not be able to speculatively write to memory and then undo
> > those effects in case of exception).  So the answer is probably
> > "yes" to your question above, in a theoretical sense only.
>
> Not at all.

Anything more substantive here?

>
> > I think the reasoning here is similar to the above.
> > ByteBuffer.get() is invoked on a DBB instance, compiler sees a call
> > to Unsafe.getXXX at some point.  The "natural" lifetime of the
> > instance survives until the instance method returns.
>
> No, this is completely wrong.

Same here

>
> > So if compiler now wanted to shorten this by observing that `this`
> > is unreachable sooner than method exit, it has to prove a bunch of
> > things like I mentioned above.
>
> Now inline everything.
>
> Please stop sepeculating about what an optimizer can and can't do.
> Please instead concerntrate on the semantics of the language and think
> about correctness.

It's speculation based on observing a real compiler and looking at its code
generation in various scenarios.  The bottom line is that it plays
conservative a lot of the time, and that is the sentiment I've picked up
from various conversations on the compiler list over the years.  Yes, it's
speculation and a Sufficiently Smart Compiler can do things differently.
But keep in mind if hotspot started scheduling operations more aggressively
around Unsafe usage a lot of code would break.

>
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/69fd08d7/attachment-0001.html>

From paul.sandoz at oracle.com  Tue Dec  8 08:40:34 2015
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Tue, 8 Dec 2015 14:40:34 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HTSm845G5jAeUQCvLQ1hvCv_sGJWMFcSqMTx82EOPo4A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<56659A96.7090706@redhat.com>
	<CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>
	<5666A7D0.6030109@redhat.com>
	<CAHjP37HTSm845G5jAeUQCvLQ1hvCv_sGJWMFcSqMTx82EOPo4A@mail.gmail.com>
Message-ID: <52F3E48A-7DF2-4650-A6B8-28BD892996ED@oracle.com>


> On 8 Dec 2015, at 12:56, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> 
> We did discuss it, and on that thread an Oracle engineer said there's no plan to do that.
> 

That was me :-) My response was a little more nuanced:

  http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2015-November/020006.html <http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2015-November/020006.html>

	AFAIK there are no plans to do such expansion.

(I may have been misunderstanding what you meant by ?expansion?.)

First i wanna get it into JDK 9 as currently optimized (via no inlining), and then iterate e.g. tackling https://bugs.openjdk.java.net/browse/JDK-8130398 <https://bugs.openjdk.java.net/browse/JDK-8130398> if that optimization route is appropriate, and updating various areas in the JDK to use it (some sooner that others perhaps, depending on performance requirements).

Paul.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/e11bd340/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/e11bd340/attachment.bin>

From vitalyd at gmail.com  Tue Dec  8 09:22:17 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 09:22:17 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <52F3E48A-7DF2-4650-A6B8-28BD892996ED@oracle.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<56659A96.7090706@redhat.com>
	<CAHjP37FQT9x3DQoY_ziEDK+083zZy5MCrJY00fie2BVDiNrnew@mail.gmail.com>
	<5666A7D0.6030109@redhat.com>
	<CAHjP37HTSm845G5jAeUQCvLQ1hvCv_sGJWMFcSqMTx82EOPo4A@mail.gmail.com>
	<52F3E48A-7DF2-4650-A6B8-28BD892996ED@oracle.com>
Message-ID: <CAHjP37Esc7B2ThGCot9rE7oQEpcRvoVMRCUw9JJ6sChsVDGj1A@mail.gmail.com>

>
> That was me :-) My response was a little more nuanced:


Ok Paul, I tried to keep this anonymous :)


> http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2015-November/020006.html
> AFAIK there are no plans to do such expansion.
> (I may have been misunderstanding what you meant by ?expansion?.)


Ok.

First i wanna get it into JDK 9 as currently optimized (via no inlining),
> and then iterate e.g. tackling
> https://bugs.openjdk.java.net/browse/JDK-8130398 if that optimization
> route is appropriate, and updating various areas in the JDK to use it (some
> sooner that others perhaps, depending on performance requirements).


That sounds good.  Removing prologue/epilogue for empty methods sounds like
a good idea generally, but at the risk of repeating myself, ideally there's
no call at all.  Andrew thinks it shouldn't be difficult, so I'd volunteer
him for it. :)



On Tue, Dec 8, 2015 at 8:40 AM, Paul Sandoz <paul.sandoz at oracle.com> wrote:

>
> On 8 Dec 2015, at 12:56, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> We did discuss it, and on that thread an Oracle engineer said there's no
> plan to do that.
>
>
> That was me :-) My response was a little more nuanced:
>
>
> http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2015-November/020006.html
>
> AFAIK there are no plans to do such expansion.
>
> (I may have been misunderstanding what you meant by ?expansion?.)
>
> First i wanna get it into JDK 9 as currently optimized (via no inlining),
> and then iterate e.g. tackling
> https://bugs.openjdk.java.net/browse/JDK-8130398 if that optimization
> route is appropriate, and updating various areas in the JDK to use it (some
> sooner that others perhaps, depending on performance requirements).
>
> Paul.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/476084b8/attachment.html>

From aph at redhat.com  Tue Dec  8 09:33:44 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 14:33:44 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
Message-ID: <5666EA48.2000102@redhat.com>

On 12/08/2015 12:07 PM, Vitaly Davidovich wrote:
>>> I think the reasoning here is similar to the above.
>>> ByteBuffer.get() is invoked on a DBB instance, compiler sees a call
>>> to Unsafe.getXXX at some point.  The "natural" lifetime of the
>>> instance survives until the instance method returns.
>>
>> No, this is completely wrong.

> Same here

The lifetime, natural or otherwise, of an instance does not survive
until an instance method returns because, a lot of the time, that
instance method is inlined.

> It's speculation based on observing a real compiler and looking at
> its code generation in various scenarios.  The bottom line is that
> it plays conservative a lot of the time, and that is the sentiment
> I've picked up from various conversations on the compiler list over
> the years.  Yes, it's speculation and a Sufficiently Smart Compiler
> can do things differently.

It's not just HotSpot, though: some VMs are even more aggressive, and
we have seen finalizers executed even before constructors have
completed.  And that is allowed by the specification.

> But keep in mind if hotspot started scheduling operations more
> aggressively around Unsafe usage a lot of code would break

It's already broken.

Andrew.

From vitalyd at gmail.com  Tue Dec  8 09:40:57 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 09:40:57 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666EA48.2000102@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
Message-ID: <CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>

>
> The lifetime, natural or otherwise, of an instance does not survive
> until an instance method returns because, a lot of the time, that
> instance method is inlined.


You're talking about optimization here (inlining); by "natural" I meant the
naive/no optimization case (e.g. interpreter, debugger attached
w/breakpoint in method, etc).

It's not just HotSpot, though: some VMs are even more aggressive, and
>

Which java VMs are these? Just curious.


> we have seen finalizers executed even before constructors have
> completed.  And that is allowed by the specification.


Ok, but that's beside the point, really.  Surely if compiler can optimize
and arrange for liveness to allow for it, then it's a good thing it does
that.  My point isn't that this cannot happen due to spec, but rather that
in places like DBB where `this` is used after the Unsafe call the  compiler
has to schedule things differently in order to reduce lifetime.  And my
point is that compilers generally tend to be cautious in doing things that
may break code.  This is the practical aspect we were referring to - it's
actual humans writing these optimizations, and they're sensitive to
breaking code, particularly in java.  Theoretically, yes, anything is
possible.

It's already broken.


Sure.  Now try to submit a patch to Hotspot that will break this case, even
if allowed by spec, and see how far you get :).


On Tue, Dec 8, 2015 at 9:33 AM, Andrew Haley <aph at redhat.com> wrote:

> On 12/08/2015 12:07 PM, Vitaly Davidovich wrote:
> >>> I think the reasoning here is similar to the above.
> >>> ByteBuffer.get() is invoked on a DBB instance, compiler sees a call
> >>> to Unsafe.getXXX at some point.  The "natural" lifetime of the
> >>> instance survives until the instance method returns.
> >>
> >> No, this is completely wrong.
>
> > Same here
>
> The lifetime, natural or otherwise, of an instance does not survive
> until an instance method returns because, a lot of the time, that
> instance method is inlined.
>
> > It's speculation based on observing a real compiler and looking at
> > its code generation in various scenarios.  The bottom line is that
> > it plays conservative a lot of the time, and that is the sentiment
> > I've picked up from various conversations on the compiler list over
> > the years.  Yes, it's speculation and a Sufficiently Smart Compiler
> > can do things differently.
>
> It's not just HotSpot, though: some VMs are even more aggressive, and
> we have seen finalizers executed even before constructors have
> completed.  And that is allowed by the specification.
>
> > But keep in mind if hotspot started scheduling operations more
> > aggressively around Unsafe usage a lot of code would break
>
> It's already broken.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/a5a357f9/attachment-0001.html>

From aph at redhat.com  Tue Dec  8 10:17:47 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 15:17:47 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
Message-ID: <5666F49B.9070906@redhat.com>

On 12/08/2015 02:40 PM, Vitaly Davidovich wrote:
>>
>> The lifetime, natural or otherwise, of an instance does not survive
>> until an instance method returns because, a lot of the time, that
>> instance method is inlined.
> 
> You're talking about optimization here (inlining); by "natural" I
> meant the naive/no optimization case (e.g. interpreter, debugger
> attached w/breakpoint in method, etc).

Okay.  Can you tell me the relevance of this, though?

> It's not just HotSpot, though: some VMs are even more aggressive, and
> 
> Which java VMs are these? Just curious.

IBM's J9.

>> we have seen finalizers executed even before constructors have
>> completed.  And that is allowed by the specification.
> 
> Ok, but that's beside the point, really.  Surely if compiler can
> optimize and arrange for liveness to allow for it, then it's a good
> thing it does that.  My point isn't that this cannot happen due to
> spec, but rather that in places like DBB where `this` is used after
> the Unsafe call the compiler has to schedule things differently in
> order to reduce lifetime. 

Or simply determine that nothing depends on position, so an update to
it doesn't have to be generated.

> And my point is that compilers generally tend to be cautious in
> doing things that may break code.  This is the practical aspect we
> were referring to - it's actual humans writing these optimizations,
> and they're sensitive to breaking code, particularly in java.
> Theoretically, yes, anything is possible. 

Not really: the JMM determines what is possible.  It's not just
"anything".

> It's already broken.  Sure.  Now try to submit a patch to Hotspot
> that will break this case, even if allowed by spec, and see how far
> you get :).

It might already have happened.  The problem with reasoning in such a
fragile way is that things get broken by accident.  The current Unsafe
support works by accident: as we have seen, copyMemory works because
position is updated after the call to Unsafe.  People who are
reasoning in terms of the compiler don't necessarily think of all the
incorrect things library authors might have done.

Andrew.

From david.lloyd at redhat.com  Tue Dec  8 10:22:49 2015
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Tue, 8 Dec 2015 09:22:49 -0600
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
Message-ID: <5666F5C9.1070605@redhat.com>

On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>     The lifetime, natural or otherwise, of an instance does not survive
>     until an instance method returns because, a lot of the time, that
>     instance method is inlined.
>
>
> You're talking about optimization here (inlining); by "natural" I meant
> the naive/no optimization case (e.g. interpreter, debugger attached
> w/breakpoint in method, etc).
>
>     It's not just HotSpot, though: some VMs are even more aggressive, and
>
> Which java VMs are these? Just curious.
>
>     we have seen finalizers executed even before constructors have
>     completed.  And that is allowed by the specification.
>
>
> Ok, but that's beside the point, really.  Surely if compiler can
> optimize and arrange for liveness to allow for it, then it's a good
> thing it does that.  My point isn't that this cannot happen due to spec,
> but rather that in places like DBB where `this` is used after the Unsafe
> call the  compiler has to schedule things differently in order to reduce
> lifetime.  And my point is that compilers generally tend to be cautious
> in doing things that may break code.  This is the practical aspect we
> were referring to - it's actual humans writing these optimizations, and
> they're sensitive to breaking code, particularly in java.
> Theoretically, yes, anything is possible.
>
>     It's already broken.
>
>
> Sure.  Now try to submit a patch to Hotspot that will break this case,
> even if allowed by spec, and see how far you get :).

If you're talking about simply observing the effects of an object being 
collected while method invocations on that object are still in flight, 
see this article:

http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms

We have run into this issue numerous times in various situations, which 
is why we're happy to see reachabilityFence() come into being.  So yes, 
it's already broken.
-- 
- DML

From vitalyd at gmail.com  Tue Dec  8 10:35:55 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 10:35:55 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666F49B.9070906@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
Message-ID: <CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>

>
> Okay.  Can you tell me the relevance of this, though?


Relevance is if code works correctly in interpreter then, practically
speaking, compiler tries to not break it.  Of course this isn't always the
case (e.g. compiler hoisting reads of a non-volatile field that should be
volatile), but is generally true.

Or simply determine that nothing depends on position, so an update to
> it doesn't have to be generated.


This is irrelevant.  There are, today, artifacts the optimizer leaves
behind even if it eliminates certain other operations to preserve behavior,
warranted by spec or simply being cautious about breaking code.

Not really: the JMM determines what is possible.  It's not just
> "anything".


Yes, "anything" was hyperbole.

It might already have happened.  The problem with reasoning in such a
> fragile way is that things get broken by accident.  The current Unsafe
> support works by accident: as we have seen, copyMemory works because
> position is updated after the call to Unsafe.  People who are
> reasoning in terms of the compiler don't necessarily think of all the
> incorrect things library authors might have done.


There are other operations in DBB that touch native memory that appear to
work without any position update (i.e. the various getters).  Again, I'm
not advocating reasoning like this for new code that someone may write.
The thread started with Alexandre asking a question for which he then added
a segfaulting example; we tried to figure out why his didn't work and DBB
works.  By definition, this is speculation unless you're expecting me to
provide a full trace through the compiler optimization pipeline.  At no
point did I advise/suggest that someone should reason like this for their
code, I was merely trying to use educated guesses as to why it works
keeping compiler optimizations in mind.

As to the theoretical vs practical aspect, I agree that there's nothing
holding this together spec/theory wise; afterall, I'm quite happy that
reachabilityFence is being added (don't particularly like that name, but
whatever).  But if you create a spec conforming JVM implementation today
that segfaults in DBB, congrats but nobody is going to use it.  Moreover,
once reachabilityFence is added and sprinkled in all the appropriate JDK
places, there may be a time when someone advertently or inadvertently makes
a compiler optimization that will break DBB-like clones in user code.  My
hunch, given the mindset of java and emphasis on not breaking code, even
code that's misbehaved and not conforming to spec, is that such
optimization will not go forward.  There are already cases where JVM treads
carefully to cater to java code out in the wild; the fact that final fields
are not treated as constants due to fear of reflection updates is a prime
example which actually could have tangible performance benefits if it
weren't so.  AFAIK, there's nothing in the spec that states it's legal to
update final fields.

We can agree on the spec all we want, but the reality/practical aspects are
more nuanced.




On Tue, Dec 8, 2015 at 10:17 AM, Andrew Haley <aph at redhat.com> wrote:

> On 12/08/2015 02:40 PM, Vitaly Davidovich wrote:
> >>
> >> The lifetime, natural or otherwise, of an instance does not survive
> >> until an instance method returns because, a lot of the time, that
> >> instance method is inlined.
> >
> > You're talking about optimization here (inlining); by "natural" I
> > meant the naive/no optimization case (e.g. interpreter, debugger
> > attached w/breakpoint in method, etc).
>
> Okay.  Can you tell me the relevance of this, though?
>
> > It's not just HotSpot, though: some VMs are even more aggressive, and
> >
> > Which java VMs are these? Just curious.
>
> IBM's J9.
>
> >> we have seen finalizers executed even before constructors have
> >> completed.  And that is allowed by the specification.
> >
> > Ok, but that's beside the point, really.  Surely if compiler can
> > optimize and arrange for liveness to allow for it, then it's a good
> > thing it does that.  My point isn't that this cannot happen due to
> > spec, but rather that in places like DBB where `this` is used after
> > the Unsafe call the compiler has to schedule things differently in
> > order to reduce lifetime.
>
> Or simply determine that nothing depends on position, so an update to
> it doesn't have to be generated.
>
> > And my point is that compilers generally tend to be cautious in
> > doing things that may break code.  This is the practical aspect we
> > were referring to - it's actual humans writing these optimizations,
> > and they're sensitive to breaking code, particularly in java.
> > Theoretically, yes, anything is possible.
>
> Not really: the JMM determines what is possible.  It's not just
> "anything".
>
> > It's already broken.  Sure.  Now try to submit a patch to Hotspot
> > that will break this case, even if allowed by spec, and see how far
> > you get :).
>
> It might already have happened.  The problem with reasoning in such a
> fragile way is that things get broken by accident.  The current Unsafe
> support works by accident: as we have seen, copyMemory works because
> position is updated after the call to Unsafe.  People who are
> reasoning in terms of the compiler don't necessarily think of all the
> incorrect things library authors might have done.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/6881ab69/attachment.html>

From vitalyd at gmail.com  Tue Dec  8 10:38:09 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 10:38:09 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666F5C9.1070605@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
Message-ID: <CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>

>
> If you're talking about simply observing the effects of an object being
> collected while method invocations on that object are still in flight, see
> this article:
> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
> We have run into this issue numerous times in various situations, which is
> why we're happy to see reachabilityFence() come into being.  So yes, it's
> already broken.


Nope, I'm talking about breaking existing DBB code as it stands today.
Alexandre already posted an example of where similar but subtly different
(with respect to DBB) code breaks, so I'm well aware it's a problem.

On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com>
wrote:

> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>
>>     The lifetime, natural or otherwise, of an instance does not survive
>>     until an instance method returns because, a lot of the time, that
>>     instance method is inlined.
>>
>>
>> You're talking about optimization here (inlining); by "natural" I meant
>> the naive/no optimization case (e.g. interpreter, debugger attached
>> w/breakpoint in method, etc).
>>
>>     It's not just HotSpot, though: some VMs are even more aggressive, and
>>
>> Which java VMs are these? Just curious.
>>
>>     we have seen finalizers executed even before constructors have
>>     completed.  And that is allowed by the specification.
>>
>>
>> Ok, but that's beside the point, really.  Surely if compiler can
>> optimize and arrange for liveness to allow for it, then it's a good
>> thing it does that.  My point isn't that this cannot happen due to spec,
>> but rather that in places like DBB where `this` is used after the Unsafe
>> call the  compiler has to schedule things differently in order to reduce
>> lifetime.  And my point is that compilers generally tend to be cautious
>> in doing things that may break code.  This is the practical aspect we
>> were referring to - it's actual humans writing these optimizations, and
>> they're sensitive to breaking code, particularly in java.
>> Theoretically, yes, anything is possible.
>>
>>     It's already broken.
>>
>>
>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>> even if allowed by spec, and see how far you get :).
>>
>
> If you're talking about simply observing the effects of an object being
> collected while method invocations on that object are still in flight, see
> this article:
>
> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>
> We have run into this issue numerous times in various situations, which is
> why we're happy to see reachabilityFence() come into being.  So yes, it's
> already broken.
> --
> - DML
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/9cf056d8/attachment-0001.html>

From aph at redhat.com  Tue Dec  8 11:21:20 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 16:21:20 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
Message-ID: <56670380.3080108@redhat.com>

On 12/08/2015 03:35 PM, Vitaly Davidovich wrote:
>>
>> Okay.  Can you tell me the relevance of this, though?
> 
> Relevance is if code works correctly in interpreter then, practically
> speaking, compiler tries to not break it.  Of course this isn't always the
> case (e.g. compiler hoisting reads of a non-volatile field that should be
> volatile), but is generally true.

I don't think it's generally true.

>> It might already have happened.  The problem with reasoning in such
>> a fragile way is that things get broken by accident.  The current
>> Unsafe support works by accident: as we have seen, copyMemory works
>> because position is updated after the call to Unsafe.  People who
>> are reasoning in terms of the compiler don't necessarily think of
>> all the incorrect things library authors might have done.
> 
> There are other operations in DBB that touch native memory that
> appear to work without any position update (i.e. the various
> getters).  Again, I'm not advocating reasoning like this for new
> code that someone may write.  The thread started with Alexandre
> asking a question for which he then added a segfaulting example; we
> tried to figure out why his didn't work and DBB works.

And in that case the answer is, I suspect, that the optimizer doesn't
know that the position field is unused by the finalizer.  If it did
know this, then you'd have early finalization.  As for the other
cases, it's not worth speculating without looking at code.

> By definition, this is speculation unless you're expecting me to
> provide a full trace through the compiler optimization pipeline.  At
> no point did I advise/suggest that someone should reason like this
> for their code, I was merely trying to use educated guesses as to
> why it works keeping compiler optimizations in mind.

Me too.  But surely why it works isn't really all that interesting:
what is much more interesting, and relevant to this list, is that it
may stop working, may already not work, or may not work in some VMs.

> As to the theoretical vs practical aspect, I agree that there's
> nothing holding this together spec/theory wise; afterall, I'm quite
> happy that reachabilityFence is being added (don't particularly like
> that name, but whatever).  But if you create a spec conforming JVM
> implementation today that segfaults in DBB, congrats but nobody is
> going to use it.

I don't see why: it'd require a patch to DBB, but people don't ship
JVMs without a copy of rt.jar (or somesuch) anyway.

> Moreover, once reachabilityFence is added and sprinkled in all the
> appropriate JDK places, there may be a time when someone advertently
> or inadvertently makes a compiler optimization that will break
> DBB-like clones in user code.  My hunch, given the mindset of java
> and emphasis on not breaking code, even code that's misbehaved and
> not conforming to spec, is that such optimization will not go
> forward.

We have very different hunches!

Andrew.

From vitalyd at gmail.com  Tue Dec  8 11:44:53 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 11:44:53 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56670380.3080108@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
Message-ID: <CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>

>
> I don't think it's generally true.


So your claim is that, generally speaking, if something works a certain
(observable) way in interpreter it's not guaranteed to work in same
(observable) way with compiled code, except quicker? I find that hard to
believe based on various compiler-dev threads I've read over the years, but
no point in debating this.

And in that case the answer is, I suspect, that the optimizer doesn't
> know that the position field is unused by the finalizer.  If it did
> know this, then you'd have early finalization.  As for the other
> cases, it's not worth speculating without looking at code.


The question is why do the various getters work in the face of early
finalization/reclaim given they don't touch internal state? I don't have a
good answer for this other than compiler is careful about optimizing around
Unsafe operations (it does know about unsafe memory accesses, that I know
for sure).

Me too.  But surely why it works isn't really all that interesting:
> what is much more interesting, and relevant to this list, is that it
> may stop working, may already not work, or may not work in some VMs.


Whether why it works today is interesting or not is subjective.  Whether
it's relevant to this list -- is this a theory only list? I don't think
so.  Theoretical discussions are good and form a basis for implementation,
but implementation details are also interesting (and have material
performance implications), at least to me.

I don't see why: it'd require a patch to DBB, but people don't ship
> JVMs without a copy of rt.jar (or somesuch) anyway.


See my comment about final field treatment as it stands today.  You can
patch JDK, but you'll likely break some user code that was "following" DBB
as a model.  Personally, I prefer aggressive optimizations and willing to
fix code if I did something wrong, but in this case there was no good way
to fix the code prior to writing it.  This is not a spec-wise
decision/situation, this is purely practical implications of breaking user
code.  This whole thing begs the rhetorical question then -- why was this
functionality released given it's rife with lifetime issues? That ship has
sailed now, and I'd hate to be the one explaining to users that some
optimizer change now segfaults their VM.

We have very different hunches!


Looks like it; let's circle back to this thread if/when an
optimization/code change breaks user code, which works today, of this
nature -- I'll be ready with the popcorn. :)


On Tue, Dec 8, 2015 at 11:21 AM, Andrew Haley <aph at redhat.com> wrote:

> On 12/08/2015 03:35 PM, Vitaly Davidovich wrote:
> >>
> >> Okay.  Can you tell me the relevance of this, though?
> >
> > Relevance is if code works correctly in interpreter then, practically
> > speaking, compiler tries to not break it.  Of course this isn't always
> the
> > case (e.g. compiler hoisting reads of a non-volatile field that should be
> > volatile), but is generally true.
>
> I don't think it's generally true.
>
> >> It might already have happened.  The problem with reasoning in such
> >> a fragile way is that things get broken by accident.  The current
> >> Unsafe support works by accident: as we have seen, copyMemory works
> >> because position is updated after the call to Unsafe.  People who
> >> are reasoning in terms of the compiler don't necessarily think of
> >> all the incorrect things library authors might have done.
> >
> > There are other operations in DBB that touch native memory that
> > appear to work without any position update (i.e. the various
> > getters).  Again, I'm not advocating reasoning like this for new
> > code that someone may write.  The thread started with Alexandre
> > asking a question for which he then added a segfaulting example; we
> > tried to figure out why his didn't work and DBB works.
>
> And in that case the answer is, I suspect, that the optimizer doesn't
> know that the position field is unused by the finalizer.  If it did
> know this, then you'd have early finalization.  As for the other
> cases, it's not worth speculating without looking at code.
>
> > By definition, this is speculation unless you're expecting me to
> > provide a full trace through the compiler optimization pipeline.  At
> > no point did I advise/suggest that someone should reason like this
> > for their code, I was merely trying to use educated guesses as to
> > why it works keeping compiler optimizations in mind.
>
> Me too.  But surely why it works isn't really all that interesting:
> what is much more interesting, and relevant to this list, is that it
> may stop working, may already not work, or may not work in some VMs.
>
> > As to the theoretical vs practical aspect, I agree that there's
> > nothing holding this together spec/theory wise; afterall, I'm quite
> > happy that reachabilityFence is being added (don't particularly like
> > that name, but whatever).  But if you create a spec conforming JVM
> > implementation today that segfaults in DBB, congrats but nobody is
> > going to use it.
>
> I don't see why: it'd require a patch to DBB, but people don't ship
> JVMs without a copy of rt.jar (or somesuch) anyway.
>
> > Moreover, once reachabilityFence is added and sprinkled in all the
> > appropriate JDK places, there may be a time when someone advertently
> > or inadvertently makes a compiler optimization that will break
> > DBB-like clones in user code.  My hunch, given the mindset of java
> > and emphasis on not breaking code, even code that's misbehaved and
> > not conforming to spec, is that such optimization will not go
> > forward.
>
> We have very different hunches!
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/5c90d071/attachment.html>

From vitalyd at gmail.com  Tue Dec  8 13:14:37 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 13:14:37 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <66914214-E716-48FD-90D4-B644A7A76373@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
Message-ID: <CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>

>
> My take is that current DBB doesn't work. It's just "harder" to hit its
> bugs because the racing-point safepoint is often (unintentionally but
> luckily) eliminated, and the race needed to hit the safepoint when it does
> remain in compiled code is dynamically rare.


Agreed that it's broken and doesn't work *by design*.

get(int i) {
>    long addr = ix(checkIndex(i));
>    // There is a safepoint here which may or may not be removed depending
> on
>    // unrelated compiler decisions.
>    // "this" may no longer be reachable here.
>    // If this is the last access to this buffer, and it goes out of scope
> "after" this get(),
>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
> fully
>    // execute and free the associated off-heap memory at addr before the
> next
>    // line below is executed...
>    return ((unsafe.getByte(addr)))); // <?? Boom!
> }


Yes.  I'm not convinced that compiler isn't treating Unsafe operations as
an optimization barrier, precluding live range of `this` being shortened.
Is there even a single reported/observed instance of DBB segfaulting or
reading free'd memory in this case? This class and methods are very
popular, and granted most of the time you don't instantiate a DBB that
immediately goes out of scope, I'd expect this to occur out in the wild and
ensuing bug reports.

public ByteBuffer put(int i, byte x) {
>    long addr = ix(checkIndex(i));
>    // There is a safepoint here which may or may not be removed depending
> on
>    // unrelated compiler decisions.
>    // "this" may no longer be reachable here, e.g. if method is inlined.
>    // If this is the last put to this buffer, and it goes out of scope
> "after" this put(),
>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
> fully
>    // execute and free the associated off-heap memory at addr before the
> next
>    // line below is executed...
>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>    return this; // This may not be used by inlining caller, and removed as
> dead code
> }


Likewise here, I'm not sure compiler reasons about Unsafe operations so
aggressively.

public ByteBuffer put(int i, byte x) {
>    try {
>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>        return this;
>    } finally {
>        Fences.reachabilityFence(this);
>    }
> }


Yes.  This also reminds me that default inlining size needs to be
reconsidered in light of changes like the above.  Putting try/finally
{reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
make some methods go over the default MaxInlineSize threshold.


On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:

> The thread started with Alexandre
> asking a question for which he then added a segfaulting example; we
>
> tried to figure out why his didn't work and DBB works.
>
>
> My take is that current DBB doesn't work. It's just "harder" to hit its
> bugs because the racing-point safepoint is often (unintentionally but
> luckily) eliminated, and the race needed to hit the safepoint when it does
> remain in compiled code is dynamically rare. To highlight by analysis,
> rather than with a reproducer, where current DBB is vulnerable, look at the
> simplest forms of get() and put(). Since both get() and put() will tend to
> [hopefully] get inlined, the safepoint positions I highlight below can
> easily remain real even after optimization. Many current cleaner-related
> (and other phantom/weak/soft ref queueing handlers that release resources)
> have similar bugs, and Fences.reachabilityFence can finally be used to fix
> them.
>
> get(int i) {
>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
> }
>
> public ByteBuffer put(int i, byte x) {
>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>    return this;
> }
>
> To highlight the bugs, let me split these up into steps:
>
> get(int i) {
>    long addr = ix(checkIndex(i));
>    // There is a safepoint here which may or may not be removed depending
> on
>    // unrelated compiler decisions.
>    // "this" may no longer be reachable here.
>    // If this is the last access to this buffer, and it goes out of scope
> "after" this get(),
>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
> fully
>    // execute and free the associated off-heap memory at addr before the
> next
>    // line below is executed...
>    return ((unsafe.getByte(addr)))); // <?? Boom!
> }
>
> public ByteBuffer put(int i, byte x) {
>    long addr = ix(checkIndex(i));
>    // There is a safepoint here which may or may not be removed depending
> on
>    // unrelated compiler decisions.
>    // "this" may no longer be reachable here, e.g. if method is inlined.
>    // If this is the last put to this buffer, and it goes out of scope
> "after" this put(),
>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
> fully
>    // execute and free the associated off-heap memory at addr before the
> next
>    // line below is executed...
>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>    return this; // This may not be used by inlining caller, and removed as
> dead code
> }
>
>
> With reachabilityFence, this bug can finally be fixed with e.g.:
>
> public ByteBuffer put(int i, byte x) {
>    try {
>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>        return this;
>    } finally {
>        Fences.reachabilityFence(this);
>    }
> }
>
> get(int i) {
>    try {
>        return ((unsafe.getByte(ix(checkIndex(i)))));
>    } finally {
>        Fences.reachabilityFence(this);
>    }
> }
>
> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> If you're talking about simply observing the effects of an object being
>> collected while method invocations on that object are still in flight, see
>> this article:
>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>> We have run into this issue numerous times in various situations, which
>> is why we're happy to see reachabilityFence() come into being.  So yes,
>> it's already broken.
>
>
> Nope, I'm talking about breaking existing DBB code as it stands today.
> Alexandre already posted an example of where similar but subtly different
> (with respect to DBB) code breaks, so I'm well aware it's a problem.
>
> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com>
> wrote:
>
>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>>
>>>     The lifetime, natural or otherwise, of an instance does not survive
>>>     until an instance method returns because, a lot of the time, that
>>>     instance method is inlined.
>>>
>>>
>>> You're talking about optimization here (inlining); by "natural" I meant
>>> the naive/no optimization case (e.g. interpreter, debugger attached
>>> w/breakpoint in method, etc).
>>>
>>>     It's not just HotSpot, though: some VMs are even more aggressive, and
>>>
>>> Which java VMs are these? Just curious.
>>>
>>>     we have seen finalizers executed even before constructors have
>>>     completed.  And that is allowed by the specification.
>>>
>>>
>>> Ok, but that's beside the point, really.  Surely if compiler can
>>> optimize and arrange for liveness to allow for it, then it's a good
>>> thing it does that.  My point isn't that this cannot happen due to spec,
>>> but rather that in places like DBB where `this` is used after the Unsafe
>>> call the  compiler has to schedule things differently in order to reduce
>>> lifetime.  And my point is that compilers generally tend to be cautious
>>> in doing things that may break code.  This is the practical aspect we
>>> were referring to - it's actual humans writing these optimizations, and
>>> they're sensitive to breaking code, particularly in java.
>>> Theoretically, yes, anything is possible.
>>>
>>>     It's already broken.
>>>
>>>
>>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>>> even if allowed by spec, and see how far you get :).
>>>
>>
>> If you're talking about simply observing the effects of an object being
>> collected while method invocations on that object are still in flight, see
>> this article:
>>
>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>
>> We have run into this issue numerous times in various situations, which
>> is why we're happy to see reachabilityFence() come into being.  So yes,
>> it's already broken.
>> --
>> - DML
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/6ae9d4ed/attachment.html>

From aph at redhat.com  Tue Dec  8 13:15:21 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 18:15:21 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
Message-ID: <56671E39.5040504@redhat.com>

On 12/08/2015 04:44 PM, Vitaly Davidovich wrote:

> So your claim is that, generally speaking, if something works a
> certain (observable) way in interpreter it's not guaranteed to work
> in same (observable) way with compiled code, except quicker? I find
> that hard to believe based on various compiler-dev threads I've read
> over the years, but no point in debating this.

Yes, that is my claim.  It's certainly true in the case of concurrent
code, which is the subject of this list.  It's certainly true in the
case of reachability, which is the subject we're discussing.

>> And in that case the answer is, I suspect, that the optimizer doesn't
>> know that the position field is unused by the finalizer.  If it did
>> know this, then you'd have early finalization.  As for the other
>> cases, it's not worth speculating without looking at code.
> 
> The question is why do the various getters work in the face of early
> finalization/reclaim given they don't touch internal state? I don't
> have a good answer for this other than compiler is careful about
> optimizing around Unsafe operations (it does know about unsafe
> memory accesses, that I know for sure).

Dunno.  It'd be interesting to try to break a getter and then look at
the code.

>> I don't see why: it'd require a patch to DBB, but people don't ship
>> JVMs without a copy of rt.jar (or somesuch) anyway.
> 
> See my comment about final field treatment as it stands today.  You
> can patch JDK, but you'll likely break some user code that was
> "following" DBB as a model.

Indeed.

> Personally, I prefer aggressive optimizations and willing to fix
> code if I did something wrong, but in this case there was no good
> way to fix the code prior to writing it.  This is not a spec-wise
> decision/situation, this is purely practical implications of
> breaking user code.  This whole thing begs the rhetorical question
> then -- why was this functionality released given it's rife with
> lifetime issues?

This warning about object lifetimes and finalizers is part of the
now-twenty-year-old Java Language Specification.  One would hope that
people have had time to get used to it and its implications.

> That ship has sailed now, and I'd hate to be the one explaining to
> users that some optimizer change now segfaults their VM.

It'll only happen with some user abusing Unsafe.  I know perfectly
well what would be said!

Andrew.

From vitalyd at gmail.com  Tue Dec  8 13:28:32 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 13:28:32 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56671E39.5040504@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
Message-ID: <CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>

>
> This warning about object lifetimes and finalizers is part of the
> now-twenty-year-old Java Language Specification.  One would hope that
> people have had time to get used to it and its implications.


We're going in circles now.  Let me just ask you this -- do you think
Oracle would ship a JDK version where code, following the model of DBB, now
breaks? The problem is that there was no way to achieve the desired
lifetime guarantees with today's and all prior JDK versions.  Why was DBB
released then if it's full of subtle gotchas? What are you going to say to
users whose code will break, and it will break subtly under particular
optimization/code shape scenarios? That they should've followed the 20+ yr
old JLS spec, and now that reachabilityFence is out, they should sweep all
their code and their 3rd party deps to ensure these subtle lifetimes issues
are fixed?

It'll only happen with some user abusing Unsafe.  I know perfectly
> well what would be said!


Didn't we just recently experience the hoopla surrounding Unsafe usage? And
that was "simply" about hiding Unsafe -- now you're going to crash user
code and expect what? Praise? Let's be realistic here and not be dogmatic
about what the spec says.  The spec would be fantastic if behavior was
consistent, predictable, and enforceable/controllable from user code on Day
1.

Again, there's precedent for existing unspec'd behavior either causing
implementations to ensure they don't break the behavior and/or causing the
spec to be updated to match behavior.

On Tue, Dec 8, 2015 at 1:15 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/08/2015 04:44 PM, Vitaly Davidovich wrote:
>
> > So your claim is that, generally speaking, if something works a
> > certain (observable) way in interpreter it's not guaranteed to work
> > in same (observable) way with compiled code, except quicker? I find
> > that hard to believe based on various compiler-dev threads I've read
> > over the years, but no point in debating this.
>
> Yes, that is my claim.  It's certainly true in the case of concurrent
> code, which is the subject of this list.  It's certainly true in the
> case of reachability, which is the subject we're discussing.
>
> >> And in that case the answer is, I suspect, that the optimizer doesn't
> >> know that the position field is unused by the finalizer.  If it did
> >> know this, then you'd have early finalization.  As for the other
> >> cases, it's not worth speculating without looking at code.
> >
> > The question is why do the various getters work in the face of early
> > finalization/reclaim given they don't touch internal state? I don't
> > have a good answer for this other than compiler is careful about
> > optimizing around Unsafe operations (it does know about unsafe
> > memory accesses, that I know for sure).
>
> Dunno.  It'd be interesting to try to break a getter and then look at
> the code.
>
> >> I don't see why: it'd require a patch to DBB, but people don't ship
> >> JVMs without a copy of rt.jar (or somesuch) anyway.
> >
> > See my comment about final field treatment as it stands today.  You
> > can patch JDK, but you'll likely break some user code that was
> > "following" DBB as a model.
>
> Indeed.
>
> > Personally, I prefer aggressive optimizations and willing to fix
> > code if I did something wrong, but in this case there was no good
> > way to fix the code prior to writing it.  This is not a spec-wise
> > decision/situation, this is purely practical implications of
> > breaking user code.  This whole thing begs the rhetorical question
> > then -- why was this functionality released given it's rife with
> > lifetime issues?
>
> This warning about object lifetimes and finalizers is part of the
> now-twenty-year-old Java Language Specification.  One would hope that
> people have had time to get used to it and its implications.
>
> > That ship has sailed now, and I'd hate to be the one explaining to
> > users that some optimizer change now segfaults their VM.
>
> It'll only happen with some user abusing Unsafe.  I know perfectly
> well what would be said!
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/802a2638/attachment.html>

From vitalyd at gmail.com  Tue Dec  8 13:48:58 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 13:48:58 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
Message-ID: <CAHjP37FYMGJCJDLqRpJdHQWLfrUCusA76nugbWZeq42vWDxo-g@mail.gmail.com>

>
> Yes, that is my claim.  It's certainly true in the case of concurrent
> code, which is the subject of this list.  It's certainly true in the
> case of reachability, which is the subject we're discussing.


I missed this part.  For concurrent code, how about the fact that volatile
writes in a constructor are effectively treated like final field writes,
even though current JMM does not mandate that? Last I heard, a future JMM
revision will make it such that existing behavior is actually spec'd simply
because lots of existing code relies on it and would break, subtly, if that
were to change.

On Tue, Dec 8, 2015 at 1:28 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

> This warning about object lifetimes and finalizers is part of the
>> now-twenty-year-old Java Language Specification.  One would hope that
>> people have had time to get used to it and its implications.
>
>
> We're going in circles now.  Let me just ask you this -- do you think
> Oracle would ship a JDK version where code, following the model of DBB, now
> breaks? The problem is that there was no way to achieve the desired
> lifetime guarantees with today's and all prior JDK versions.  Why was DBB
> released then if it's full of subtle gotchas? What are you going to say to
> users whose code will break, and it will break subtly under particular
> optimization/code shape scenarios? That they should've followed the 20+ yr
> old JLS spec, and now that reachabilityFence is out, they should sweep all
> their code and their 3rd party deps to ensure these subtle lifetimes issues
> are fixed?
>
> It'll only happen with some user abusing Unsafe.  I know perfectly
>> well what would be said!
>
>
> Didn't we just recently experience the hoopla surrounding Unsafe usage?
> And that was "simply" about hiding Unsafe -- now you're going to crash user
> code and expect what? Praise? Let's be realistic here and not be dogmatic
> about what the spec says.  The spec would be fantastic if behavior was
> consistent, predictable, and enforceable/controllable from user code on Day
> 1.
>
> Again, there's precedent for existing unspec'd behavior either causing
> implementations to ensure they don't break the behavior and/or causing the
> spec to be updated to match behavior.
>
> On Tue, Dec 8, 2015 at 1:15 PM, Andrew Haley <aph at redhat.com> wrote:
>
>> On 12/08/2015 04:44 PM, Vitaly Davidovich wrote:
>>
>> > So your claim is that, generally speaking, if something works a
>> > certain (observable) way in interpreter it's not guaranteed to work
>> > in same (observable) way with compiled code, except quicker? I find
>> > that hard to believe based on various compiler-dev threads I've read
>> > over the years, but no point in debating this.
>>
>> Yes, that is my claim.  It's certainly true in the case of concurrent
>> code, which is the subject of this list.  It's certainly true in the
>> case of reachability, which is the subject we're discussing.
>>
>> >> And in that case the answer is, I suspect, that the optimizer doesn't
>> >> know that the position field is unused by the finalizer.  If it did
>> >> know this, then you'd have early finalization.  As for the other
>> >> cases, it's not worth speculating without looking at code.
>> >
>> > The question is why do the various getters work in the face of early
>> > finalization/reclaim given they don't touch internal state? I don't
>> > have a good answer for this other than compiler is careful about
>> > optimizing around Unsafe operations (it does know about unsafe
>> > memory accesses, that I know for sure).
>>
>> Dunno.  It'd be interesting to try to break a getter and then look at
>> the code.
>>
>> >> I don't see why: it'd require a patch to DBB, but people don't ship
>> >> JVMs without a copy of rt.jar (or somesuch) anyway.
>> >
>> > See my comment about final field treatment as it stands today.  You
>> > can patch JDK, but you'll likely break some user code that was
>> > "following" DBB as a model.
>>
>> Indeed.
>>
>> > Personally, I prefer aggressive optimizations and willing to fix
>> > code if I did something wrong, but in this case there was no good
>> > way to fix the code prior to writing it.  This is not a spec-wise
>> > decision/situation, this is purely practical implications of
>> > breaking user code.  This whole thing begs the rhetorical question
>> > then -- why was this functionality released given it's rife with
>> > lifetime issues?
>>
>> This warning about object lifetimes and finalizers is part of the
>> now-twenty-year-old Java Language Specification.  One would hope that
>> people have had time to get used to it and its implications.
>>
>> > That ship has sailed now, and I'd hate to be the one explaining to
>> > users that some optimizer change now segfaults their VM.
>>
>> It'll only happen with some user abusing Unsafe.  I know perfectly
>> well what would be said!
>>
>> Andrew.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/77004fcd/attachment.html>

From aph at redhat.com  Tue Dec  8 13:53:58 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 18:53:58 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FYMGJCJDLqRpJdHQWLfrUCusA76nugbWZeq42vWDxo-g@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<CAHjP37FYMGJCJDLqRpJdHQWLfrUCusA76nugbWZeq42vWDxo-g@mail.gmail.com>
Message-ID: <56672746.7060103@redhat.com>

On 12/08/2015 06:48 PM, Vitaly Davidovich wrote:
>>
>> Yes, that is my claim.  It's certainly true in the case of concurrent
>> code, which is the subject of this list.  It's certainly true in the
>> case of reachability, which is the subject we're discussing.
> 
> I missed this part.  For concurrent code, how about the fact that volatile
> writes in a constructor are effectively treated like final field writes,
> even though current JMM does not mandate that? Last I heard, a future JMM
> revision will make it such that existing behavior is actually spec'd simply
> because lots of existing code relies on it and would break, subtly, if that
> were to change.

I'm trying to figure out exactly what point you're making.  In what
sense are volatile writes in a constructor effectively treated like
final field writes?  From the code I've looked at, volatile writes in
a constructor are treated exactly like any other kind of volatile
writes: they're sequentially consistent, and there's nothing stronger
than that.

Andrew.

From vitalyd at gmail.com  Tue Dec  8 14:00:28 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 14:00:28 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56672746.7060103@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<CAHjP37FYMGJCJDLqRpJdHQWLfrUCusA76nugbWZeq42vWDxo-g@mail.gmail.com>
	<56672746.7060103@redhat.com>
Message-ID: <CAHjP37E_35HxpDMDPxHo=uzvvBfniWJTYTQqAyzOqb-H7tvWTg@mail.gmail.com>

sent from my phone
On Dec 8, 2015 1:54 PM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 12/08/2015 06:48 PM, Vitaly Davidovich wrote:
> >>
> >> Yes, that is my claim.  It's certainly true in the case of concurrent
> >> code, which is the subject of this list.  It's certainly true in the
> >> case of reachability, which is the subject we're discussing.
> >
> > I missed this part.  For concurrent code, how about the fact that
volatile
> > writes in a constructor are effectively treated like final field writes,
> > even though current JMM does not mandate that? Last I heard, a future
JMM
> > revision will make it such that existing behavior is actually spec'd
simply
> > because lots of existing code relies on it and would break, subtly, if
that
> > were to change.
>
> I'm trying to figure out exactly what point you're making.

My point, which you're countering, is that JVM sometimes enforces stricter
semantics than the spec to satisfy behavior that existing code depends on
and doesn't just say "read the spec" to justify breaking changes.

> In what
> sense are volatile writes in a constructor effectively treated like
> final field writes?  From the code I've looked at, volatile writes in
> a constructor are treated exactly like any other kind of volatile
> writes: they're sequentially consistent, and there's nothing stronger
> than that.

Final field prevents subsequent assignment of the newly constructed object
from moving above the final field write inside the constructor; volatile
write doesn't carry this requirement by JMM spec but gets that treatment in
the implementation.

>
> Andrew.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/5b1ad168/attachment.html>

From aph at redhat.com  Tue Dec  8 14:03:42 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 8 Dec 2015 19:03:42 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
Message-ID: <5667298E.2080202@redhat.com>

On 12/08/2015 06:28 PM, Vitaly Davidovich wrote:
>>
>> This warning about object lifetimes and finalizers is part of the
>> now-twenty-year-old Java Language Specification.  One would hope that
>> people have had time to get used to it and its implications.
> 
> We're going in circles now.  Let me just ask you this -- do you
> think Oracle would ship a JDK version where code, following the
> model of DBB, now breaks?

Absolutely, yes.  We already know that very similar code breaks.

> The problem is that there was no way to achieve the desired lifetime
> guarantees with today's and all prior JDK versions. 

Sure there is: write a field (a counter, say) in your methods and read
it in the finalizer.  Make sure that you do something with the field
in the finalizer to ensure it's not eliminated: a volatile write will
do.  This is fully JLS-compliant; reachabilityFence() is just an
optimization.

> Why was DBB released then if it's full of subtle gotchas? What are
> you going to say to users whose code will break, and it will break
> subtly under particular optimization/code shape scenarios? That they
> should've followed the 20+ yr old JLS spec, and now that
> reachabilityFence is out, they should sweep all their code and their
> 3rd party deps to ensure these subtle lifetimes issues are fixed?

Yes, more or less.  It's happened in the past, and it'll continue
to happen.  To begin with people didn't much have to worry about
subtleties to do with finalization and lifetimes, and were bitten
by it, and fixed their code.

Andrew.

From vitalyd at gmail.com  Tue Dec  8 14:17:01 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 14:17:01 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5667298E.2080202@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
Message-ID: <CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>

>
> Absolutely, yes.  We already know that very similar code breaks.


"Very similar" is slightly different though.

Sure there is: write a field (a counter, say) in your methods and read
> it in the finalizer.  Make sure that you do something with the field
> in the finalizer to ensure it's not eliminated: a volatile write will
> do.  This is fully JLS-compliant; reachabilityFence() is just an
> optimization.


C'mon, really?? :) So now I'm going to write to dummy fields? And what are
you going to do with it in a finalizer? And of course, a Sufficiently Smart
Compiler could detect (theoretically, of course :)) that this is all just
dummy ops and remove them.

Yes, more or less.  It's happened in the past, and it'll continue
> to happen.  To begin with people didn't much have to worry about
> subtleties to do with finalization and lifetimes, and were bitten
> by it, and fixed their code.


In that case, please let me know if this ever happens, hopefully on a
public mailing list that I can follow along.

In my opinion, the current lack of optimization (accidental or not) should
be somehow encoded/made intentional.  Perhaps treat Unsafe::anything() as a
full compiler optimization fence, if it's not already.  At least don't
break existing code.  For Alexandre's SimpleBuffer version that broke and
breaks today, require them to use reachabilityFence.  This, or something
along these lines, is the pragmatic way to address this.


On Tue, Dec 8, 2015 at 2:03 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/08/2015 06:28 PM, Vitaly Davidovich wrote:
> >>
> >> This warning about object lifetimes and finalizers is part of the
> >> now-twenty-year-old Java Language Specification.  One would hope that
> >> people have had time to get used to it and its implications.
> >
> > We're going in circles now.  Let me just ask you this -- do you
> > think Oracle would ship a JDK version where code, following the
> > model of DBB, now breaks?
>
> Absolutely, yes.  We already know that very similar code breaks.
>
> > The problem is that there was no way to achieve the desired lifetime
> > guarantees with today's and all prior JDK versions.
>
> Sure there is: write a field (a counter, say) in your methods and read
> it in the finalizer.  Make sure that you do something with the field
> in the finalizer to ensure it's not eliminated: a volatile write will
> do.  This is fully JLS-compliant; reachabilityFence() is just an
> optimization.
>
> > Why was DBB released then if it's full of subtle gotchas? What are
> > you going to say to users whose code will break, and it will break
> > subtly under particular optimization/code shape scenarios? That they
> > should've followed the 20+ yr old JLS spec, and now that
> > reachabilityFence is out, they should sweep all their code and their
> > 3rd party deps to ensure these subtle lifetimes issues are fixed?
>
> Yes, more or less.  It's happened in the past, and it'll continue
> to happen.  To begin with people didn't much have to worry about
> subtleties to do with finalization and lifetimes, and were bitten
> by it, and fixed their code.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/323e65a2/attachment.html>

From jsampson at guidewire.com  Tue Dec  8 22:25:57 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 9 Dec 2015 03:25:57 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5666EA48.2000102@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
Message-ID: <DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>

Andrew Haley wrote:

> It's not just HotSpot, though: some VMs are even more aggressive,
> and we have seen finalizers executed even before constructors have
> completed. And that is allowed by the specification.

How so? I mean, I understand that an object may become unreachable
before the completion of its constructor due to inlining, but the
finalizer is not allowed to run at that point:

"The completion of an object's constructor happens-before the
execution of its finalize method (in the formal sense of
happens-before)."

https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6

Cheers,
Justin


From jsampson at guidewire.com  Tue Dec  8 22:40:19 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 9 Dec 2015 03:40:19 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
Message-ID: <DM2PR0501MB8758078EB00A5EBE90601B1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>

Vitaly Davidovich wrote:

> > public ByteBuffer put(int i, byte x) {
> >     try {
> >         unsafe.putByte(ix(checkIndex(i)), ((x)));
> >         return this;
> >     } finally {
> >         Fences.reachabilityFence(this);
> >     }
> > }
>
> Yes. This also reminds me that default inlining size needs to be
> reconsidered in light of changes like the above. Putting
> try/finally {reachabilityFence(this)} adds about 14 bytes of
> bytecode alone, which may make some methods go over the default
> MaxInlineSize threshold.

Is the try/finally necessary? How about instead:

public ByteBuffer put(int i, byte x) {
    unsafe.putByte(ix(checkIndex(i)), x);
    Fences.reachabilityFence(this);
    return this;
}

public int get(int i) {
    int result = unsafe.getByte(ix(checkIndex(i)));
    Fences.reachabilityFence(this);
    return result;
}

Cheers,
Justin


From vitalyd at gmail.com  Tue Dec  8 23:26:08 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 8 Dec 2015 23:26:08 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB8758078EB00A5EBE90601B1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<DM2PR0501MB8758078EB00A5EBE90601B1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <CAHjP37HwJtsO-3=Y8ummcnwhNBjaoFmSpzCmEjfbqsBQBxhMLA@mail.gmail.com>

I don't think it's needed for correctness in these examples, but I can see
people adopting try/finally forms as a way to "outline" the lifetime
extension and not mix it in with the core logic.  This also helps in
ensuring code refactoring does not inadvertently place code that needs
lifetime extension after reachabilityFence by mistake.

On Tue, Dec 8, 2015 at 10:40 PM, Justin Sampson <jsampson at guidewire.com>
wrote:

> Vitaly Davidovich wrote:
>
> > > public ByteBuffer put(int i, byte x) {
> > >     try {
> > >         unsafe.putByte(ix(checkIndex(i)), ((x)));
> > >         return this;
> > >     } finally {
> > >         Fences.reachabilityFence(this);
> > >     }
> > > }
> >
> > Yes. This also reminds me that default inlining size needs to be
> > reconsidered in light of changes like the above. Putting
> > try/finally {reachabilityFence(this)} adds about 14 bytes of
> > bytecode alone, which may make some methods go over the default
> > MaxInlineSize threshold.
>
> Is the try/finally necessary? How about instead:
>
> public ByteBuffer put(int i, byte x) {
>     unsafe.putByte(ix(checkIndex(i)), x);
>     Fences.reachabilityFence(this);
>     return this;
> }
>
> public int get(int i) {
>     int result = unsafe.getByte(ix(checkIndex(i)));
>     Fences.reachabilityFence(this);
>     return result;
> }
>
> Cheers,
> Justin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151208/c1ed77b6/attachment.html>

From peter.levart at gmail.com  Wed Dec  9 04:03:04 2015
From: peter.levart at gmail.com (Peter Levart)
Date: Wed, 9 Dec 2015 10:03:04 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <5667EE48.1020102@gmail.com>



On 12/09/2015 04:25 AM, Justin Sampson wrote:
> Andrew Haley wrote:
>
>> It's not just HotSpot, though: some VMs are even more aggressive,
>> and we have seen finalizers executed even before constructors have
>> completed. And that is allowed by the specification.
> How so? I mean, I understand that an object may become unreachable
> before the completion of its constructor due to inlining, but the
> finalizer is not allowed to run at that point:
>
> "The completion of an object's constructor happens-before the
> execution of its finalize method (in the formal sense of
> happens-before)."
>
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6
>
> Cheers,
> Justin

A little later down in "12.6.1. Implementing Finalization" JLS also writes:

"An object o is not finalizable until its constructor has invoked the 
constructor for Object on o and that invocation has completed 
successfully (that is, without throwing an exception)."

So we have two seemingly contradictive definitions using: object's 
constructor vs. Object's constructor

I think the definition that uses "object's constructor" is not precise. 
A general object may have many costructors which are invoked in chain. 
While java.lang.Object only has a single constructor. So I would trust 
the later definition. Besides, this is how it is implemented in Hotspot/JDK.

Regards, Peter

>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Wed Dec  9 04:21:26 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 9 Dec 2015 19:21:26 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5667EE48.1020102@gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
Message-ID: <07fb01d13262$fafccb70$f0f66250$@net.au>

JLS 12.6.1 establishes a minimum requirement for an object to be finalizable
- it ensures that the object has the minimalist form for a valid object: it
has been allocated and Object's constructor has succeeded. If something goes
wrong prior to that point then the object can not be finalized.

The happens-before requirement was deliberately set the way it is to show
that an object can not be finalized before its construction has completed
(whether normally or abnormally). So I would agree with Justin that it
should not be possible for an object to be finalized before construction has
completed - regardless of potential compiler optimizations etc.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Peter Levart
> Sent: Wednesday, December 9, 2015 7:03 PM
> To: Justin Sampson; Andrew Haley; Vitaly Davidovich
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
> 
> 
> 
> On 12/09/2015 04:25 AM, Justin Sampson wrote:
> > Andrew Haley wrote:
> >
> >> It's not just HotSpot, though: some VMs are even more aggressive,
> >> and we have seen finalizers executed even before constructors have
> >> completed. And that is allowed by the specification.
> > How so? I mean, I understand that an object may become unreachable
> > before the completion of its constructor due to inlining, but the
> > finalizer is not allowed to run at that point:
> >
> > "The completion of an object's constructor happens-before the
> > execution of its finalize method (in the formal sense of
> > happens-before)."
> >
> > https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-
> 12.6
> >
> > Cheers,
> > Justin
> 
> A little later down in "12.6.1. Implementing Finalization" JLS also
> writes:
> 
> "An object o is not finalizable until its constructor has invoked the
> constructor for Object on o and that invocation has completed
> successfully (that is, without throwing an exception)."
> 
> So we have two seemingly contradictive definitions using: object's
> constructor vs. Object's constructor
> 
> I think the definition that uses "object's constructor" is not precise.
> A general object may have many costructors which are invoked in chain.
> While java.lang.Object only has a single constructor. So I would trust
> the later definition. Besides, this is how it is implemented in
> Hotspot/JDK.
> 
> Regards, Peter
> 
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From adc at quartetfs.com  Wed Dec  9 04:30:10 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Wed, 9 Dec 2015 10:30:10 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
Message-ID: <CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>

Well the question that is underlying this thread is: does someone that uses
DirectByteBuffer needs to ensure their liveness beyond method calls?

It seems to be the case.

> My take is that current DBB doesn't work. It's just "harder" to hit its
>> bugs because the racing-point safepoint is often (unintentionally but
>> luckily) eliminated, and the race needed to hit the safepoint when it does
>> remain in compiled code is dynamically rare.
>
>
I tend to agree with Gil, and the example code that I have attached does
seem to show that the compiler does not have any specific optimization
fences when encountering Unsafe (or I would like to be explained what is
going on, and would appreciate pointers to where in the hotspot source code
those things are enforced). And this whole discussion shows that even if it
were the case, relying on it might break at some point.

So as a Java programmer, I will make sure that when using direct buffers
they stay reachable long enough.






> Agreed that it's broken and doesn't work *by design*.
>
> get(int i) {
>>    long addr = ix(checkIndex(i));
>>    // There is a safepoint here which may or may not be removed depending
>> on
>>    // unrelated compiler decisions.
>>    // "this" may no longer be reachable here.
>>    // If this is the last access to this buffer, and it goes out of scope
>> "after" this get(),
>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>> fully
>>    // execute and free the associated off-heap memory at addr before the
>> next
>>    // line below is executed...
>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> }
>
>
> Yes.  I'm not convinced that compiler isn't treating Unsafe operations as
> an optimization barrier, precluding live range of `this` being shortened.
> Is there even a single reported/observed instance of DBB segfaulting or
> reading free'd memory in this case? This class and methods are very
> popular, and granted most of the time you don't instantiate a DBB that
> immediately goes out of scope, I'd expect this to occur out in the wild and
> ensuing bug reports.
>
> public ByteBuffer put(int i, byte x) {
>>    long addr = ix(checkIndex(i));
>>    // There is a safepoint here which may or may not be removed depending
>> on
>>    // unrelated compiler decisions.
>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>    // If this is the last put to this buffer, and it goes out of scope
>> "after" this put(),
>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>> fully
>>    // execute and free the associated off-heap memory at addr before the
>> next
>>    // line below is executed...
>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>    return this; // This may not be used by inlining caller, and removed
>> as dead code
>> }
>
>
> Likewise here, I'm not sure compiler reasons about Unsafe operations so
> aggressively.
>
> public ByteBuffer put(int i, byte x) {
>>    try {
>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>        return this;
>>    } finally {
>>        Fences.reachabilityFence(this);
>>    }
>> }
>
>
> Yes.  This also reminds me that default inlining size needs to be
> reconsidered in light of changes like the above.  Putting try/finally
> {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
> make some methods go over the default MaxInlineSize threshold.
>
>
> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
>
>> The thread started with Alexandre
>> asking a question for which he then added a segfaulting example; we
>>
>> tried to figure out why his didn't work and DBB works.
>>
>>
>> My take is that current DBB doesn't work. It's just "harder" to hit its
>> bugs because the racing-point safepoint is often (unintentionally but
>> luckily) eliminated, and the race needed to hit the safepoint when it does
>> remain in compiled code is dynamically rare. To highlight by analysis,
>> rather than with a reproducer, where current DBB is vulnerable, look at the
>> simplest forms of get() and put(). Since both get() and put() will tend to
>> [hopefully] get inlined, the safepoint positions I highlight below can
>> easily remain real even after optimization. Many current cleaner-related
>> (and other phantom/weak/soft ref queueing handlers that release resources)
>> have similar bugs, and Fences.reachabilityFence can finally be used to fix
>> them.
>>
>> get(int i) {
>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>> }
>>
>> public ByteBuffer put(int i, byte x) {
>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>>    return this;
>> }
>>
>> To highlight the bugs, let me split these up into steps:
>>
>> get(int i) {
>>    long addr = ix(checkIndex(i));
>>    // There is a safepoint here which may or may not be removed depending
>> on
>>    // unrelated compiler decisions.
>>    // "this" may no longer be reachable here.
>>    // If this is the last access to this buffer, and it goes out of scope
>> "after" this get(),
>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>> fully
>>    // execute and free the associated off-heap memory at addr before the
>> next
>>    // line below is executed...
>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> }
>>
>> public ByteBuffer put(int i, byte x) {
>>    long addr = ix(checkIndex(i));
>>    // There is a safepoint here which may or may not be removed depending
>> on
>>    // unrelated compiler decisions.
>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>    // If this is the last put to this buffer, and it goes out of scope
>> "after" this put(),
>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>> fully
>>    // execute and free the associated off-heap memory at addr before the
>> next
>>    // line below is executed...
>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>    return this; // This may not be used by inlining caller, and removed
>> as dead code
>> }
>>
>>
>> With reachabilityFence, this bug can finally be fixed with e.g.:
>>
>> public ByteBuffer put(int i, byte x) {
>>    try {
>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>        return this;
>>    } finally {
>>        Fences.reachabilityFence(this);
>>    }
>> }
>>
>> get(int i) {
>>    try {
>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>>    } finally {
>>        Fences.reachabilityFence(this);
>>    }
>> }
>>
>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>> If you're talking about simply observing the effects of an object being
>>> collected while method invocations on that object are still in flight, see
>>> this article:
>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>> We have run into this issue numerous times in various situations, which
>>> is why we're happy to see reachabilityFence() come into being.  So yes,
>>> it's already broken.
>>
>>
>> Nope, I'm talking about breaking existing DBB code as it stands today.
>> Alexandre already posted an example of where similar but subtly different
>> (with respect to DBB) code breaks, so I'm well aware it's a problem.
>>
>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com>
>> wrote:
>>
>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>>>
>>>>     The lifetime, natural or otherwise, of an instance does not survive
>>>>     until an instance method returns because, a lot of the time, that
>>>>     instance method is inlined.
>>>>
>>>>
>>>> You're talking about optimization here (inlining); by "natural" I meant
>>>> the naive/no optimization case (e.g. interpreter, debugger attached
>>>> w/breakpoint in method, etc).
>>>>
>>>>     It's not just HotSpot, though: some VMs are even more aggressive,
>>>> and
>>>>
>>>> Which java VMs are these? Just curious.
>>>>
>>>>     we have seen finalizers executed even before constructors have
>>>>     completed.  And that is allowed by the specification.
>>>>
>>>>
>>>> Ok, but that's beside the point, really.  Surely if compiler can
>>>> optimize and arrange for liveness to allow for it, then it's a good
>>>> thing it does that.  My point isn't that this cannot happen due to spec,
>>>> but rather that in places like DBB where `this` is used after the Unsafe
>>>> call the  compiler has to schedule things differently in order to reduce
>>>> lifetime.  And my point is that compilers generally tend to be cautious
>>>> in doing things that may break code.  This is the practical aspect we
>>>> were referring to - it's actual humans writing these optimizations, and
>>>> they're sensitive to breaking code, particularly in java.
>>>> Theoretically, yes, anything is possible.
>>>>
>>>>     It's already broken.
>>>>
>>>>
>>>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>>>> even if allowed by spec, and see how far you get :).
>>>>
>>>
>>> If you're talking about simply observing the effects of an object being
>>> collected while method invocations on that object are still in flight, see
>>> this article:
>>>
>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>
>>> We have run into this issue numerous times in various situations, which
>>> is why we're happy to see reachabilityFence() come into being.  So yes,
>>> it's already broken.
>>> --
>>> - DML
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Alexandre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/cd2e47ca/attachment-0001.html>

From jaromir.hamala at gmail.com  Wed Dec  9 05:22:53 2015
From: jaromir.hamala at gmail.com (Jaromir Hamala)
Date: Wed, 9 Dec 2015 12:22:53 +0200
Subject: [concurrency-interest] A bug in JDK 8 ConcurrentMap::compute?
Message-ID: <CAMxXA6_ofNjGK4amP-Lh3afOa_PpzOYoJauO-7ntArQiP1XOtA@mail.gmail.com>

Hi,

I apologize if this is not the right group to discuss possible issues in
JDK8 j.u.c package. Please feel free to point me to a more appropriate
group.

I stumbled upon an interesting issue with default implementation of
`compute(K key, BiFunction<? super K, ? super V, ? extends V>
remappingFunction)` in JDK8 `ConcurrentMap`.
According to its contract the default method implementation assumes map
implementations do not support null values.

This is the begin of the default implementation:

default V compute(K key, BiFunction<? super K, ? super V, ? extends V>
remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue = get(key);
        for(;;) {
            V newValue = remappingFunction.apply(key, oldValue);
            if (newValue == null) {
                // delete mapping
                if (oldValue != null || containsKey(key)) {
                    // something to remove
                    if (remove(key, oldValue)) {
[...]


Let's say we have an empty map and 2 threads:
T1 is calling the `compute('foo', someFunction)`
T2 is concurrently calling calling `put('foo', 'bar');`

so the T1 will get `oldValue = null`, but `containsKey()` will return
`true` - because T2 already created the mapping `foo -> bar`. Hence T1 will
call `remove('foo', null)` !

Contract of `remove()` says: `throws NullPointerException if the specified
key or value is null, and this map does not permit null keys or values
optional.` -> the T1 will throw NPE.
Is it a bug in default method impl or do I understand it wrong?

Cheers,
Jaromir

-- 
?Perfection is achieved, not when there is nothing more to add, but when
there is nothing left to take away.?
Antoine de Saint Exup?ry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/3d1e0860/attachment.html>

From aph at redhat.com  Wed Dec  9 05:33:11 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 10:33:11 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
Message-ID: <56680367.4050801@redhat.com>

On 08/12/15 19:17, Vitaly Davidovich wrote:
>> [me:]
>> Absolutely, yes.  We already know that very similar code breaks.
> 
> "Very similar" is slightly different though.
> 
>> Sure there is: write a field (a counter, say) in your methods and read
>> it in the finalizer.  Make sure that you do something with the field
>> in the finalizer to ensure it's not eliminated: a volatile write will
>> do.  This is fully JLS-compliant; reachabilityFence() is just an
>> optimization.
> 
> C'mon, really?? :)

I wonder how many times I'm going to wrote "Absolutely, yes."

> So now I'm going to write to dummy fields? And what are you going to
> do with it in a finalizer?

Update a global volatile.

> And of course, a Sufficiently Smart Compiler could detect
> (theoretically, of course :)) that this is all just dummy ops and
> remove them.

No, it can't.  Because the JLS says so.  IMVHO it'd be much better to
stop trying to guess what a compiler might do and simply write in the
language instead.

> In my opinion, the current lack of optimization (accidental or not)
> should be somehow encoded/made intentional. 

I have in the past argued that methods of classes with finalizers
should automagically extend the lifetime of the "this" object.
However, I was on the losing side, and reachabilityFence() is the
compromise result.  That's okay, really: it solves the practical
problem.

> Perhaps treat Unsafe::anything() as a full compiler optimization
> fence, if it's not already.

That one really is a no-hoper.  The idea of NIO ByteBuffers is "as
fast as C" and full fences would be a pretty major regression.

Andrew.

From aph at redhat.com  Wed Dec  9 05:35:13 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 10:35:13 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <07fb01d13262$fafccb70$f0f66250$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com> <07fb01d13262$fafccb70$f0f66250$@net.au>
Message-ID: <566803E1.30809@redhat.com>

On 09/12/15 09:21, David Holmes wrote:

> The happens-before requirement was deliberately set the way it is to
> show that an object can not be finalized before its construction has
> completed (whether normally or abnormally). So I would agree with
> Justin that it should not be possible for an object to be finalized
> before construction has completed - regardless of potential compiler
> optimizations etc.

Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
but I don't think so.  Is there really a happens-before relationship
between a constructor of an object with no volatile or final fields
and its finalizer?

Andrew.

From davidcholmes at aapt.net.au  Wed Dec  9 06:11:06 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 9 Dec 2015 21:11:06 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566803E1.30809@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
Message-ID: <080801d13272$4d48eb20$e7dac160$@net.au>

Andrew Haley writes:
> On 09/12/15 09:21, David Holmes wrote:
> 
> > The happens-before requirement was deliberately set the way it is to
> > show that an object can not be finalized before its construction has
> > completed (whether normally or abnormally). So I would agree with
> > Justin that it should not be possible for an object to be finalized
> > before construction has completed - regardless of potential compiler
> > optimizations etc.
> 
> Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
> but I don't think so.  Is there really a happens-before relationship
> between a constructor of an object with no volatile or final fields
> and its finalizer?

My recollection - and I've been trying to find this in the JavaMemoryModel
archives - is that the happens-before between constructor and finalizer was
introduced because the normal "trick" of using synchronization was very
counter-intuitive in constructors given the object has not been published.

That said, A happens-before B simply establishes visibility/ordering rules
for the case when A occurs before B. It says nothing about B occurring
before A, or B and A overlapping. Other mechanisms have to force the
temporal order. So it may be I misspoke my support of Justin's position. :(

David
-----

 
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jaromir.hamala at gmail.com  Wed Dec  9 06:53:09 2015
From: jaromir.hamala at gmail.com (Jaromir Hamala)
Date: Wed, 9 Dec 2015 13:53:09 +0200
Subject: [concurrency-interest] A bug in JDK 8 ConcurrentMap::compute?
In-Reply-To: <CAMxXA6_ofNjGK4amP-Lh3afOa_PpzOYoJauO-7ntArQiP1XOtA@mail.gmail.com>
References: <CAMxXA6_ofNjGK4amP-Lh3afOa_PpzOYoJauO-7ntArQiP1XOtA@mail.gmail.com>
Message-ID: <CAMxXA69uqVAyPfFBMS=rP6o03Z3FVw-wdAngGxNhg9nTGfe4Vg@mail.gmail.com>

update: it has been confirmed to be a bug.

On Wed, Dec 9, 2015 at 12:22 PM, Jaromir Hamala <jaromir.hamala at gmail.com>
wrote:

> Hi,
>
> I apologize if this is not the right group to discuss possible issues in
> JDK8 j.u.c package. Please feel free to point me to a more appropriate
> group.
>
> I stumbled upon an interesting issue with default implementation of
> `compute(K key, BiFunction<? super K, ? super V, ? extends V>
> remappingFunction)` in JDK8 `ConcurrentMap`.
> According to its contract the default method implementation assumes map
> implementations do not support null values.
>
> This is the begin of the default implementation:
>
> default V compute(K key, BiFunction<? super K, ? super V, ? extends V>
> remappingFunction) {
>         Objects.requireNonNull(remappingFunction);
>         V oldValue = get(key);
>         for(;;) {
>             V newValue = remappingFunction.apply(key, oldValue);
>             if (newValue == null) {
>                 // delete mapping
>                 if (oldValue != null || containsKey(key)) {
>                     // something to remove
>                     if (remove(key, oldValue)) {
> [...]
>
>
> Let's say we have an empty map and 2 threads:
> T1 is calling the `compute('foo', someFunction)`
> T2 is concurrently calling calling `put('foo', 'bar');`
>
> so the T1 will get `oldValue = null`, but `containsKey()` will return
> `true` - because T2 already created the mapping `foo -> bar`. Hence T1 will
> call `remove('foo', null)` !
>
> Contract of `remove()` says: `throws NullPointerException if the specified
> key or value is null, and this map does not permit null keys or values
> optional.` -> the T1 will throw NPE.
> Is it a bug in default method impl or do I understand it wrong?
>
> Cheers,
> Jaromir
>
> --
> ?Perfection is achieved, not when there is nothing more to add, but when
> there is nothing left to take away.?
> Antoine de Saint Exup?ry
>



-- 
?Perfection is achieved, not when there is nothing more to add, but when
there is nothing left to take away.?
Antoine de Saint Exup?ry
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/56c8f8f7/attachment.html>

From dl at cs.oswego.edu  Wed Dec  9 07:46:38 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 9 Dec 2015 07:46:38 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56680367.4050801@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
Message-ID: <566822AE.3050204@cs.oswego.edu>

On 12/09/2015 05:33 AM, Andrew Haley wrote:

>> In my opinion, the current lack of optimization (accidental or not)
>> should be somehow encoded/made intentional.
>
> I have in the past argued that methods of classes with finalizers
> should automagically extend the lifetime of the "this" object.
> However, I was on the losing side, and reachabilityFence() is the
> compromise result.  That's okay, really: it solves the practical
> problem.
>

I don't think anyone "lost" these arguments, but further action
was postponed at least in the context of JMM-related updates.

Among the options is to introduce a @Finalized annotation
for a field of an object. Front-end compilers would
then insert reachabilityFence() after each use. Not necessarily
immediately after though. Optimal placement is non-trivial, which
is one reason this wasn't widely agreed on. It would be great
if some IDE's tried out this kind of support inside IDEs though.

See discussions on jmm-dev list mostly in August 2014.
   http://mail.openjdk.java.net/pipermail/jmm-dev/

(Also, someday, the JLS probably should be updated to explicitly
mention impact of reachabilityFence. The wording change
would basically be the same as the method spec, but a few other
clarifications done at the same time might be helpful.

-Doug



From vitalyd at gmail.com  Wed Dec  9 09:36:21 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 09:36:21 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56680367.4050801@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
Message-ID: <CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>

sent from my phone
On Dec 9, 2015 5:33 AM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 08/12/15 19:17, Vitaly Davidovich wrote:
> >> [me:]
> >> Absolutely, yes.  We already know that very similar code breaks.
> >
> > "Very similar" is slightly different though.
> >
> >> Sure there is: write a field (a counter, say) in your methods and read
> >> it in the finalizer.  Make sure that you do something with the field
> >> in the finalizer to ensure it's not eliminated: a volatile write will
> >> do.  This is fully JLS-compliant; reachabilityFence() is just an
> >> optimization.
> >
> > C'mon, really?? :)
>
> I wonder how many times I'm going to wrote "Absolutely, yes."

As many silly suggestions/workarounds as you propose :).

>
> > So now I'm going to write to dummy fields? And what are you going to
> > do with it in a finalizer?
>
> Update a global volatile.

And take perf hit? No thanks

>
> > And of course, a Sufficiently Smart Compiler could detect
> > (theoretically, of course :)) that this is all just dummy ops and
> > remove them.
>
> No, it can't.  Because the JLS says so.  IMVHO it'd be much better to
> stop trying to guess what a compiler might do and simply write in the
> language instead.

JLS prescribes observable behavior not exact steps.

>
> > In my opinion, the current lack of optimization (accidental or not)
> > should be somehow encoded/made intentional.
>
> I have in the past argued that methods of classes with finalizers
> should automagically extend the lifetime of the "this" object.
> However, I was on the losing side, and reachabilityFence() is the
> compromise result.  That's okay, really: it solves the practical
> problem.
>
> > Perhaps treat Unsafe::anything() as a full compiler optimization
> > fence, if it's not already.
>
> That one really is a no-hoper.  The idea of NIO ByteBuffers is "as
> fast as C" and full fences would be a pretty major regression.

Maybe you missed the "compiler" part.  I'm suggesting a compiler-only
fence.  And I like how you suggested updating a global volatile above but
here a full fence (which isn't what I proposed) is a no-hoper.

>
> Andrew.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/81a0c9d2/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 10:31:08 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 10:31:08 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
Message-ID: <CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>

Your example code differs from DBB in that you don't use `this` after call
to unsafe, as mentioned before, so the compiler fence (if any) is not
applicable.

Maybe you should bring this up on the hotspot compiler dev mailing list and
get a definitive answer on how this is modeled today.

sent from my phone
On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com> wrote:

> Well the question that is underlying this thread is: does someone that
> uses DirectByteBuffer needs to ensure their liveness beyond method calls?
>
> It seems to be the case.
>
>> My take is that current DBB doesn't work. It's just "harder" to hit its
>>> bugs because the racing-point safepoint is often (unintentionally but
>>> luckily) eliminated, and the race needed to hit the safepoint when it does
>>> remain in compiled code is dynamically rare.
>>
>>
> I tend to agree with Gil, and the example code that I have attached does
> seem to show that the compiler does not have any specific optimization
> fences when encountering Unsafe (or I would like to be explained what is
> going on, and would appreciate pointers to where in the hotspot source code
> those things are enforced). And this whole discussion shows that even if it
> were the case, relying on it might break at some point.
>
> So as a Java programmer, I will make sure that when using direct buffers
> they stay reachable long enough.
>
>
>
>
>
>
>> Agreed that it's broken and doesn't work *by design*.
>>
>> get(int i) {
>>>    long addr = ix(checkIndex(i));
>>>    // There is a safepoint here which may or may not be removed
>>> depending on
>>>    // unrelated compiler decisions.
>>>    // "this" may no longer be reachable here.
>>>    // If this is the last access to this buffer, and it goes out of
>>> scope "after" this get(),
>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>> fully
>>>    // execute and free the associated off-heap memory at addr before the
>>> next
>>>    // line below is executed...
>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>> }
>>
>>
>> Yes.  I'm not convinced that compiler isn't treating Unsafe operations as
>> an optimization barrier, precluding live range of `this` being shortened.
>> Is there even a single reported/observed instance of DBB segfaulting or
>> reading free'd memory in this case? This class and methods are very
>> popular, and granted most of the time you don't instantiate a DBB that
>> immediately goes out of scope, I'd expect this to occur out in the wild and
>> ensuing bug reports.
>>
>> public ByteBuffer put(int i, byte x) {
>>>    long addr = ix(checkIndex(i));
>>>    // There is a safepoint here which may or may not be removed
>>> depending on
>>>    // unrelated compiler decisions.
>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>>    // If this is the last put to this buffer, and it goes out of scope
>>> "after" this put(),
>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>> fully
>>>    // execute and free the associated off-heap memory at addr before the
>>> next
>>>    // line below is executed...
>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>    return this; // This may not be used by inlining caller, and removed
>>> as dead code
>>> }
>>
>>
>> Likewise here, I'm not sure compiler reasons about Unsafe operations so
>> aggressively.
>>
>> public ByteBuffer put(int i, byte x) {
>>>    try {
>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>        return this;
>>>    } finally {
>>>        Fences.reachabilityFence(this);
>>>    }
>>> }
>>
>>
>> Yes.  This also reminds me that default inlining size needs to be
>> reconsidered in light of changes like the above.  Putting try/finally
>> {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
>> make some methods go over the default MaxInlineSize threshold.
>>
>>
>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
>>
>>> The thread started with Alexandre
>>> asking a question for which he then added a segfaulting example; we
>>>
>>> tried to figure out why his didn't work and DBB works.
>>>
>>>
>>> My take is that current DBB doesn't work. It's just "harder" to hit its
>>> bugs because the racing-point safepoint is often (unintentionally but
>>> luckily) eliminated, and the race needed to hit the safepoint when it does
>>> remain in compiled code is dynamically rare. To highlight by analysis,
>>> rather than with a reproducer, where current DBB is vulnerable, look at the
>>> simplest forms of get() and put(). Since both get() and put() will tend to
>>> [hopefully] get inlined, the safepoint positions I highlight below can
>>> easily remain real even after optimization. Many current cleaner-related
>>> (and other phantom/weak/soft ref queueing handlers that release resources)
>>> have similar bugs, and Fences.reachabilityFence can finally be used to fix
>>> them.
>>>
>>> get(int i) {
>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>>> }
>>>
>>> public ByteBuffer put(int i, byte x) {
>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>>>    return this;
>>> }
>>>
>>> To highlight the bugs, let me split these up into steps:
>>>
>>> get(int i) {
>>>    long addr = ix(checkIndex(i));
>>>    // There is a safepoint here which may or may not be removed
>>> depending on
>>>    // unrelated compiler decisions.
>>>    // "this" may no longer be reachable here.
>>>    // If this is the last access to this buffer, and it goes out of
>>> scope "after" this get(),
>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>> fully
>>>    // execute and free the associated off-heap memory at addr before the
>>> next
>>>    // line below is executed...
>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>> }
>>>
>>> public ByteBuffer put(int i, byte x) {
>>>    long addr = ix(checkIndex(i));
>>>    // There is a safepoint here which may or may not be removed
>>> depending on
>>>    // unrelated compiler decisions.
>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>>    // If this is the last put to this buffer, and it goes out of scope
>>> "after" this put(),
>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>> fully
>>>    // execute and free the associated off-heap memory at addr before the
>>> next
>>>    // line below is executed...
>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>    return this; // This may not be used by inlining caller, and removed
>>> as dead code
>>> }
>>>
>>>
>>> With reachabilityFence, this bug can finally be fixed with e.g.:
>>>
>>> public ByteBuffer put(int i, byte x) {
>>>    try {
>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>        return this;
>>>    } finally {
>>>        Fences.reachabilityFence(this);
>>>    }
>>> }
>>>
>>> get(int i) {
>>>    try {
>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>>>    } finally {
>>>        Fences.reachabilityFence(this);
>>>    }
>>> }
>>>
>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>>
>>> If you're talking about simply observing the effects of an object being
>>>> collected while method invocations on that object are still in flight, see
>>>> this article:
>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>> We have run into this issue numerous times in various situations, which
>>>> is why we're happy to see reachabilityFence() come into being.  So yes,
>>>> it's already broken.
>>>
>>>
>>> Nope, I'm talking about breaking existing DBB code as it stands today.
>>> Alexandre already posted an example of where similar but subtly different
>>> (with respect to DBB) code breaks, so I'm well aware it's a problem.
>>>
>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com>
>>> wrote:
>>>
>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>>>>
>>>>>     The lifetime, natural or otherwise, of an instance does not survive
>>>>>     until an instance method returns because, a lot of the time, that
>>>>>     instance method is inlined.
>>>>>
>>>>>
>>>>> You're talking about optimization here (inlining); by "natural" I meant
>>>>> the naive/no optimization case (e.g. interpreter, debugger attached
>>>>> w/breakpoint in method, etc).
>>>>>
>>>>>     It's not just HotSpot, though: some VMs are even more aggressive,
>>>>> and
>>>>>
>>>>> Which java VMs are these? Just curious.
>>>>>
>>>>>     we have seen finalizers executed even before constructors have
>>>>>     completed.  And that is allowed by the specification.
>>>>>
>>>>>
>>>>> Ok, but that's beside the point, really.  Surely if compiler can
>>>>> optimize and arrange for liveness to allow for it, then it's a good
>>>>> thing it does that.  My point isn't that this cannot happen due to
>>>>> spec,
>>>>> but rather that in places like DBB where `this` is used after the
>>>>> Unsafe
>>>>> call the  compiler has to schedule things differently in order to
>>>>> reduce
>>>>> lifetime.  And my point is that compilers generally tend to be cautious
>>>>> in doing things that may break code.  This is the practical aspect we
>>>>> were referring to - it's actual humans writing these optimizations, and
>>>>> they're sensitive to breaking code, particularly in java.
>>>>> Theoretically, yes, anything is possible.
>>>>>
>>>>>     It's already broken.
>>>>>
>>>>>
>>>>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>>>>> even if allowed by spec, and see how far you get :).
>>>>>
>>>>
>>>> If you're talking about simply observing the effects of an object being
>>>> collected while method invocations on that object are still in flight, see
>>>> this article:
>>>>
>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>>
>>>> We have run into this issue numerous times in various situations, which
>>>> is why we're happy to see reachabilityFence() come into being.  So yes,
>>>> it's already broken.
>>>> --
>>>> - DML
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> Alexandre
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/ba3a3efa/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 10:35:48 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 10:35:48 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <080801d13272$4d48eb20$e7dac160$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
Message-ID: <CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>

sent from my phone
On Dec 9, 2015 6:11 AM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> Andrew Haley writes:
> > On 09/12/15 09:21, David Holmes wrote:
> >
> > > The happens-before requirement was deliberately set the way it is to
> > > show that an object can not be finalized before its construction has
> > > completed (whether normally or abnormally). So I would agree with
> > > Justin that it should not be possible for an object to be finalized
> > > before construction has completed - regardless of potential compiler
> > > optimizations etc.
> >
> > Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
> > but I don't think so.  Is there really a happens-before relationship
> > between a constructor of an object with no volatile or final fields
> > and its finalizer?
>
> My recollection - and I've been trying to find this in the JavaMemoryModel
> archives - is that the happens-before between constructor and finalizer
was
> introduced because the normal "trick" of using synchronization was very
> counter-intuitive in constructors given the object has not been published.
>
> That said, A happens-before B simply establishes visibility/ordering rules
> for the case when A occurs before B. It says nothing about B occurring
> before A, or B and A overlapping. Other mechanisms have to force the
> temporal order. So it may be I misspoke my support of Justin's position.
:(

I have a different interpretation, akin to your previous answer.  There's
very little point in stating that ctor happens-before finalization if
that's not even the case always (i.e. they overlap or occur in reverse
order) - how would that be meaningful?

>
> David
> -----
>
>
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/0da6b88a/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 11:16:58 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 11:16:58 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
Message-ID: <CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>

>
> an implicit implication that 'this' must remain reachable until after the
> last instruction in each of its instance methods


Why wouldn't this work, at least as a compromise? If there's unsafe.foo()
inside a method, extend `this` lifetime to beyond that unsafe call.  Or if
there's a use of `this` after unsafe.foo(), do not shorten the lifetime of
`this` to prior to unsafe.foo(), even if the operations are otherwise
schedulable like that.

On Wed, Dec 9, 2015 at 10:57 AM, Gil Tene <gil at azul.com> wrote:

> Just like in Justin's example, DBB has multiple methods that don't use
> 'this' after their call to unsafe. Most of the get() and put() variants
> behave like that in DBB, and they are all exposed to a cleaner running and
> freeing the buffer's backing store before the unsafe call is ever made.
>
> AFAICT there is nothing the compilers do to protect against this.
> Specifically, there is nothing being done to extend the reachability of
> 'this' to beyond the point where an unsafe call is made in an instance
> method. And doing anything about it for unsafe specifically would be
> "hard". The unsafe call has no relation to 'this' except that it is being
> called from within the instance method, and uses arguments that were at
> some point in the (recent) past derived from 'this'. Without a reachability
> fence, or an implicit implication that 'this' must remain reachable until
> after the last instruction in each of its instance methods, there is
> nothing you can do (IMO) to plug up this bug.
>
> Sent from Gil's iPhone
>
> On Dec 9, 2015, at 7:30 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> Your example code differs from DBB in that you don't use `this` after call
> to unsafe, as mentioned before, so the compiler fence (if any) is not
> applicable.
>
> Maybe you should bring this up on the hotspot compiler dev mailing list
> and get a definitive answer on how this is modeled today.
>
> sent from my phone
> On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
> wrote:
>
>> Well the question that is underlying this thread is: does someone that
>> uses DirectByteBuffer needs to ensure their liveness beyond method calls?
>>
>> It seems to be the case.
>>
>>> My take is that current DBB doesn't work. It's just "harder" to hit its
>>>> bugs because the racing-point safepoint is often (unintentionally but
>>>> luckily) eliminated, and the race needed to hit the safepoint when it does
>>>> remain in compiled code is dynamically rare.
>>>
>>>
>> I tend to agree with Gil, and the example code that I have attached does
>> seem to show that the compiler does not have any specific optimization
>> fences when encountering Unsafe (or I would like to be explained what is
>> going on, and would appreciate pointers to where in the hotspot source code
>> those things are enforced). And this whole discussion shows that even if it
>> were the case, relying on it might break at some point.
>>
>> So as a Java programmer, I will make sure that when using direct buffers
>> they stay reachable long enough.
>>
>>
>>
>>
>>
>>
>>> Agreed that it's broken and doesn't work *by design*.
>>>
>>> get(int i) {
>>>>    long addr = ix(checkIndex(i));
>>>>    // There is a safepoint here which may or may not be removed
>>>> depending on
>>>>    // unrelated compiler decisions.
>>>>    // "this" may no longer be reachable here.
>>>>    // If this is the last access to this buffer, and it goes out of
>>>> scope "after" this get(),
>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>>> fully
>>>>    // execute and free the associated off-heap memory at addr before
>>>> the next
>>>>    // line below is executed...
>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>>> }
>>>
>>>
>>> Yes.  I'm not convinced that compiler isn't treating Unsafe operations
>>> as an optimization barrier, precluding live range of `this` being
>>> shortened.  Is there even a single reported/observed instance of DBB
>>> segfaulting or reading free'd memory in this case? This class and methods
>>> are very popular, and granted most of the time you don't instantiate a DBB
>>> that immediately goes out of scope, I'd expect this to occur out in the
>>> wild and ensuing bug reports.
>>>
>>> public ByteBuffer put(int i, byte x) {
>>>>    long addr = ix(checkIndex(i));
>>>>    // There is a safepoint here which may or may not be removed
>>>> depending on
>>>>    // unrelated compiler decisions.
>>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>>>    // If this is the last put to this buffer, and it goes out of scope
>>>> "after" this put(),
>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>>> fully
>>>>    // execute and free the associated off-heap memory at addr before
>>>> the next
>>>>    // line below is executed...
>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>>    return this; // This may not be used by inlining caller, and removed
>>>> as dead code
>>>> }
>>>
>>>
>>> Likewise here, I'm not sure compiler reasons about Unsafe operations so
>>> aggressively.
>>>
>>> public ByteBuffer put(int i, byte x) {
>>>>    try {
>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>>        return this;
>>>>    } finally {
>>>>        Fences.reachabilityFence(this);
>>>>    }
>>>> }
>>>
>>>
>>> Yes.  This also reminds me that default inlining size needs to be
>>> reconsidered in light of changes like the above.  Putting try/finally
>>> {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
>>> make some methods go over the default MaxInlineSize threshold.
>>>
>>>
>>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
>>>
>>>> The thread started with Alexandre
>>>> asking a question for which he then added a segfaulting example; we
>>>>
>>>> tried to figure out why his didn't work and DBB works.
>>>>
>>>>
>>>> My take is that current DBB doesn't work. It's just "harder" to hit its
>>>> bugs because the racing-point safepoint is often (unintentionally but
>>>> luckily) eliminated, and the race needed to hit the safepoint when it does
>>>> remain in compiled code is dynamically rare. To highlight by analysis,
>>>> rather than with a reproducer, where current DBB is vulnerable, look at the
>>>> simplest forms of get() and put(). Since both get() and put() will tend to
>>>> [hopefully] get inlined, the safepoint positions I highlight below can
>>>> easily remain real even after optimization. Many current cleaner-related
>>>> (and other phantom/weak/soft ref queueing handlers that release resources)
>>>> have similar bugs, and Fences.reachabilityFence can finally be used to fix
>>>> them.
>>>>
>>>> get(int i) {
>>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>>>> }
>>>>
>>>> public ByteBuffer put(int i, byte x) {
>>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>>>>    return this;
>>>> }
>>>>
>>>> To highlight the bugs, let me split these up into steps:
>>>>
>>>> get(int i) {
>>>>    long addr = ix(checkIndex(i));
>>>>    // There is a safepoint here which may or may not be removed
>>>> depending on
>>>>    // unrelated compiler decisions.
>>>>    // "this" may no longer be reachable here.
>>>>    // If this is the last access to this buffer, and it goes out of
>>>> scope "after" this get(),
>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>>> fully
>>>>    // execute and free the associated off-heap memory at addr before
>>>> the next
>>>>    // line below is executed...
>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>>> }
>>>>
>>>> public ByteBuffer put(int i, byte x) {
>>>>    long addr = ix(checkIndex(i));
>>>>    // There is a safepoint here which may or may not be removed
>>>> depending on
>>>>    // unrelated compiler decisions.
>>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>>>>    // If this is the last put to this buffer, and it goes out of scope
>>>> "after" this put(),
>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can
>>>> fully
>>>>    // execute and free the associated off-heap memory at addr before
>>>> the next
>>>>    // line below is executed...
>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>>    return this; // This may not be used by inlining caller, and removed
>>>> as dead code
>>>> }
>>>>
>>>>
>>>> With reachabilityFence, this bug can finally be fixed with e.g.:
>>>>
>>>> public ByteBuffer put(int i, byte x) {
>>>>    try {
>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>>        return this;
>>>>    } finally {
>>>>        Fences.reachabilityFence(this);
>>>>    }
>>>> }
>>>>
>>>> get(int i) {
>>>>    try {
>>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>>>>    } finally {
>>>>        Fences.reachabilityFence(this);
>>>>    }
>>>> }
>>>>
>>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com>
>>>> wrote:
>>>>
>>>> If you're talking about simply observing the effects of an object being
>>>>> collected while method invocations on that object are still in flight, see
>>>>> this article:
>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>>> We have run into this issue numerous times in various situations,
>>>>> which is why we're happy to see reachabilityFence() come into being.  So
>>>>> yes, it's already broken.
>>>>
>>>>
>>>> Nope, I'm talking about breaking existing DBB code as it stands today.
>>>> Alexandre already posted an example of where similar but subtly different
>>>> (with respect to DBB) code breaks, so I'm well aware it's a problem.
>>>>
>>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com
>>>> > wrote:
>>>>
>>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>>>>>
>>>>>>     The lifetime, natural or otherwise, of an instance does not
>>>>>> survive
>>>>>>     until an instance method returns because, a lot of the time, that
>>>>>>     instance method is inlined.
>>>>>>
>>>>>>
>>>>>> You're talking about optimization here (inlining); by "natural" I
>>>>>> meant
>>>>>> the naive/no optimization case (e.g. interpreter, debugger attached
>>>>>> w/breakpoint in method, etc).
>>>>>>
>>>>>>     It's not just HotSpot, though: some VMs are even more aggressive,
>>>>>> and
>>>>>>
>>>>>> Which java VMs are these? Just curious.
>>>>>>
>>>>>>     we have seen finalizers executed even before constructors have
>>>>>>     completed.  And that is allowed by the specification.
>>>>>>
>>>>>>
>>>>>> Ok, but that's beside the point, really.  Surely if compiler can
>>>>>> optimize and arrange for liveness to allow for it, then it's a good
>>>>>> thing it does that.  My point isn't that this cannot happen due to
>>>>>> spec,
>>>>>> but rather that in places like DBB where `this` is used after the
>>>>>> Unsafe
>>>>>> call the  compiler has to schedule things differently in order to
>>>>>> reduce
>>>>>> lifetime.  And my point is that compilers generally tend to be
>>>>>> cautious
>>>>>> in doing things that may break code.  This is the practical aspect we
>>>>>> were referring to - it's actual humans writing these optimizations,
>>>>>> and
>>>>>> they're sensitive to breaking code, particularly in java.
>>>>>> Theoretically, yes, anything is possible.
>>>>>>
>>>>>>     It's already broken.
>>>>>>
>>>>>>
>>>>>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>>>>>> even if allowed by spec, and see how far you get :).
>>>>>>
>>>>>
>>>>> If you're talking about simply observing the effects of an object
>>>>> being collected while method invocations on that object are still in
>>>>> flight, see this article:
>>>>>
>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>>>
>>>>> We have run into this issue numerous times in various situations,
>>>>> which is why we're happy to see reachabilityFence() come into being.  So
>>>>> yes, it's already broken.
>>>>> --
>>>>> - DML
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>> --
>> Alexandre
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/73e8b59d/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 11:46:27 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 11:46:27 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
Message-ID: <CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>

sent from my phone
On Dec 9, 2015 11:34 AM, "Gil Tene" <gil at azul.com> wrote:
>
>
>
> Sent from Gil's iPhone
>
> On Dec 9, 2015, at 8:16 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
>>> an implicit implication that 'this' must remain reachable until after
the last instruction in each of its instance methods
>>
>>
>> Why wouldn't this work, at least as a compromise?
>
>
> Didn't say it wouldn't work. I said it >doesn't do it today.

Is this a fact that it doesn't do it?

>
>> If there's unsafe.foo() inside a method, extend `this` lifetime to
beyond that unsafe call.  Or if there's a use of `this` after unsafe.foo(),
do not shorten the lifetime of `this` to prior to unsafe.foo(), even if the
operations are otherwise schedulable like that.
>
>
> I wouldn't limit this to unsafe. I would just do it for all instance
method. Period. The bugs that have to do with loss of reachability to this
exist even without uses of unsafe. Unsafe use cases (like DBB) are just a
useful ways to demonstrate how bad things are (a SEGV catches people's
attention more than other semantic wrongness).
>

I'd have an issue with extending it blindly.  What if you have a long
running ordinary java method that doesn't use 'this' for majority of the
execution time?

You only have to do this when compiler is too smart and sees all accesses
because it fully inlined.  Non-inlined methods are black boxes and compiler
cannot reason across them (afterall, that's how current reachabilityFence
is implemented).

> To be specific: the same semantic premature loss of reachability issue
exists around any resource-release-on-loss-of-reachability logic in Java
today. Regardless of their choice of finalizers, cleaners, phantom refs, or
weak or soft refs. And regales of whether the resource involved is
"physical" (like memory) or logical (like a key or an id).  E.g. Files can
be prematurely closed, their fds recycled, and their last I/O operations
done to the wrong file or channel.  Logical window Ids can be prematurely
recycled and their last graphic operations done to the wrong window or to
bad memory. Etc. etc. etc.
>
> I'm not saying that each of these bugs actually exists right now (I
haven't specifically hunted them down to check), but I *am* saying that the
typical mechanisms each of them would use to do
resource-release-on-loss-of-reachability (whether in the JDK or in user
code) is inherently flawed under the current JLS and JVM specs, and that
much like DBB's innocently written bugs, I expect to find these in many
places that I look...
>
>>
>> On Wed, Dec 9, 2015 at 10:57 AM, Gil Tene <gil at azul.com> wrote:
>>>
>>> Just like in Justin's example, DBB has multiple methods that don't use
'this' after their call to unsafe. Most of the get() and put() variants
behave like that in DBB, and they are all exposed to a cleaner running and
freeing the buffer's backing store before the unsafe call is ever made.
>>>
>>> AFAICT there is nothing the compilers do to protect against this.
Specifically, there is nothing being done to extend the reachability of
'this' to beyond the point where an unsafe call is made in an instance
method. And doing anything about it for unsafe specifically would be
"hard". The unsafe call has no relation to 'this' except that it is being
called from within the instance method, and uses arguments that were at
some point in the (recent) past derived from 'this'. Without a reachability
fence, or an implicit implication that 'this' must remain reachable until
after the last instruction in each of its instance methods, there is
nothing you can do (IMO) to plug up this bug.
>>>
>>> Sent from Gil's iPhone
>>>
>>> On Dec 9, 2015, at 7:30 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>>
>>>> Your example code differs from DBB in that you don't use `this` after
call to unsafe, as mentioned before, so the compiler fence (if any) is not
applicable.
>>>>
>>>> Maybe you should bring this up on the hotspot compiler dev mailing
list and get a definitive answer on how this is modeled today.
>>>>
>>>> sent from my phone
>>>>
>>>> On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
wrote:
>>>>>
>>>>> Well the question that is underlying this thread is: does someone
that uses DirectByteBuffer needs to ensure their liveness beyond method
calls?
>>>>>
>>>>> It seems to be the case.
>>>>>>>
>>>>>>> My take is that current DBB doesn't work. It's just "harder" to hit
its bugs because the racing-point safepoint is often (unintentionally but
luckily) eliminated, and the race needed to hit the safepoint when it does
remain in compiled code is dynamically rare.
>>>>>
>>>>>
>>>>> I tend to agree with Gil, and the example code that I have attached
does seem to show that the compiler does not have any specific optimization
fences when encountering Unsafe (or I would like to be explained what is
going on, and would appreciate pointers to where in the hotspot source code
those things are enforced). And this whole discussion shows that even if it
were the case, relying on it might break at some point.
>>>>>
>>>>> So as a Java programmer, I will make sure that when using direct
buffers they stay reachable long enough.
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>>
>>>>>> Agreed that it's broken and doesn't work *by design*.
>>>>>>
>>>>>>> get(int i) {
>>>>>>>    long addr = ix(checkIndex(i));
>>>>>>>    // There is a safepoint here which may or may not be removed
depending on
>>>>>>>    // unrelated compiler decisions.
>>>>>>>    // "this" may no longer be reachable here.
>>>>>>>    // If this is the last access to this buffer, and it goes out of
scope "after" this get(),
>>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner
can fully
>>>>>>>    // execute and free the associated off-heap memory at addr
before the next
>>>>>>>    // line below is executed...
>>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>>>>>> }
>>>>>>
>>>>>>
>>>>>> Yes.  I'm not convinced that compiler isn't treating Unsafe
operations as an optimization barrier, precluding live range of `this`
being shortened.  Is there even a single reported/observed instance of DBB
segfaulting or reading free'd memory in this case? This class and methods
are very popular, and granted most of the time you don't instantiate a DBB
that immediately goes out of scope, I'd expect this to occur out in the
wild and ensuing bug reports.
>>>>>>
>>>>>>> public ByteBuffer put(int i, byte x) {
>>>>>>>    long addr = ix(checkIndex(i));
>>>>>>>    // There is a safepoint here which may or may not be removed
depending on
>>>>>>>    // unrelated compiler decisions.
>>>>>>>    // "this" may no longer be reachable here, e.g. if method is
inlined.
>>>>>>>    // If this is the last put to this buffer, and it goes out of
scope "after" this put(),
>>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner
can fully
>>>>>>>    // execute and free the associated off-heap memory at addr
before the next
>>>>>>>    // line below is executed...
>>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>>>>>    return this; // This may not be used by inlining caller, and
removed as dead code
>>>>>>> }
>>>>>>
>>>>>>
>>>>>> Likewise here, I'm not sure compiler reasons about Unsafe operations
so aggressively.
>>>>>>
>>>>>>> public ByteBuffer put(int i, byte x) {
>>>>>>>    try {
>>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>>>>>        return this;
>>>>>>>    } finally {
>>>>>>>        Fences.reachabilityFence(this);
>>>>>>>    }
>>>>>>> }
>>>>>>
>>>>>>
>>>>>> Yes.  This also reminds me that default inlining size needs to be
reconsidered in light of changes like the above.  Putting try/finally
{reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
make some methods go over the default MaxInlineSize threshold.
>>>>>>
>>>>>>
>>>>>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
>>>>>>>>
>>>>>>>> The thread started with Alexandre
>>>>>>>> asking a question for which he then added a segfaulting example; we
>>>>>>>>
>>>>>>>> tried to figure out why his didn't work and DBB works.
>>>>>>>
>>>>>>>
>>>>>>> My take is that current DBB doesn't work. It's just "harder" to hit
its bugs because the racing-point safepoint is often (unintentionally but
luckily) eliminated, and the race needed to hit the safepoint when it does
remain in compiled code is dynamically rare. To highlight by analysis,
rather than with a reproducer, where current DBB is vulnerable, look at the
simplest forms of get() and put(). Since both get() and put() will tend to
[hopefully] get inlined, the safepoint positions I highlight below can
easily remain real even after optimization. Many current cleaner-related
(and other phantom/weak/soft ref queueing handlers that release resources)
have similar bugs, and Fences.reachabilityFence can finally be used to fix
them.
>>>>>>>
>>>>>>> get(int i) {
>>>>>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>>>>>>> }
>>>>>>>
>>>>>>> public ByteBuffer put(int i, byte x) {
>>>>>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>>>>>>>    return this;
>>>>>>> }
>>>>>>>
>>>>>>> To highlight the bugs, let me split these up into steps:
>>>>>>>
>>>>>>> get(int i) {
>>>>>>>    long addr = ix(checkIndex(i));
>>>>>>>    // There is a safepoint here which may or may not be removed
depending on
>>>>>>>    // unrelated compiler decisions.
>>>>>>>    // "this" may no longer be reachable here.
>>>>>>>    // If this is the last access to this buffer, and it goes out of
scope "after" this get(),
>>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner
can fully
>>>>>>>    // execute and free the associated off-heap memory at addr
before the next
>>>>>>>    // line below is executed...
>>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>>>>>>> }
>>>>>>>
>>>>>>> public ByteBuffer put(int i, byte x) {
>>>>>>>    long addr = ix(checkIndex(i));
>>>>>>>    // There is a safepoint here which may or may not be removed
depending on
>>>>>>>    // unrelated compiler decisions.
>>>>>>>    // "this" may no longer be reachable here, e.g. if method is
inlined.
>>>>>>>    // If this is the last put to this buffer, and it goes out of
scope "after" this put(),
>>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner
can fully
>>>>>>>    // execute and free the associated off-heap memory at addr
before the next
>>>>>>>    // line below is executed...
>>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>>>>>>>    return this; // This may not be used by inlining caller, and
removed as dead code
>>>>>>> }
>>>>>>>
>>>>>>>
>>>>>>> With reachabilityFence, this bug can finally be fixed with e.g.:
>>>>>>>
>>>>>>> public ByteBuffer put(int i, byte x) {
>>>>>>>    try {
>>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>>>>>>>        return this;
>>>>>>>    } finally {
>>>>>>>        Fences.reachabilityFence(this);
>>>>>>>    }
>>>>>>> }
>>>>>>>
>>>>>>> get(int i) {
>>>>>>>    try {
>>>>>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>>>>>>>    } finally {
>>>>>>>        Fences.reachabilityFence(this);
>>>>>>>    }
>>>>>>> }
>>>>>>>
>>>>>>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com>
wrote:
>>>>>>>>
>>>>>>>>> If you're talking about simply observing the effects of an object
being collected while method invocations on that object are still in
flight, see this article:
>>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>>>>>>> We have run into this issue numerous times in various situations,
which is why we're happy to see reachabilityFence() come into being.  So
yes, it's already broken.
>>>>>>>>
>>>>>>>>
>>>>>>>> Nope, I'm talking about breaking existing DBB code as it stands
today.  Alexandre already posted an example of where similar but subtly
different (with respect to DBB) code breaks, so I'm well aware it's a
problem.
>>>>>>>>
>>>>>>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <
david.lloyd at redhat.com> wrote:
>>>>>>>>>
>>>>>>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>>>>>>>>>>
>>>>>>>>>>     The lifetime, natural or otherwise, of an instance does not
survive
>>>>>>>>>>     until an instance method returns because, a lot of the time,
that
>>>>>>>>>>     instance method is inlined.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> You're talking about optimization here (inlining); by "natural"
I meant
>>>>>>>>>> the naive/no optimization case (e.g. interpreter, debugger
attached
>>>>>>>>>> w/breakpoint in method, etc).
>>>>>>>>>>
>>>>>>>>>>     It's not just HotSpot, though: some VMs are even more
aggressive, and
>>>>>>>>>>
>>>>>>>>>> Which java VMs are these? Just curious.
>>>>>>>>>>
>>>>>>>>>>     we have seen finalizers executed even before constructors
have
>>>>>>>>>>     completed.  And that is allowed by the specification.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Ok, but that's beside the point, really.  Surely if compiler can
>>>>>>>>>> optimize and arrange for liveness to allow for it, then it's a
good
>>>>>>>>>> thing it does that.  My point isn't that this cannot happen due
to spec,
>>>>>>>>>> but rather that in places like DBB where `this` is used after
the Unsafe
>>>>>>>>>> call the  compiler has to schedule things differently in order
to reduce
>>>>>>>>>> lifetime.  And my point is that compilers generally tend to be
cautious
>>>>>>>>>> in doing things that may break code.  This is the practical
aspect we
>>>>>>>>>> were referring to - it's actual humans writing these
optimizations, and
>>>>>>>>>> they're sensitive to breaking code, particularly in java.
>>>>>>>>>> Theoretically, yes, anything is possible.
>>>>>>>>>>
>>>>>>>>>>     It's already broken.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> Sure.  Now try to submit a patch to Hotspot that will break this
case,
>>>>>>>>>> even if allowed by spec, and see how far you get :).
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> If you're talking about simply observing the effects of an object
being collected while method invocations on that object are still in
flight, see this article:
>>>>>>>>>
>>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>>>>>>>>>
>>>>>>>>> We have run into this issue numerous times in various situations,
which is why we're happy to see reachabilityFence() come into being.  So
yes, it's already broken.
>>>>>>>>> --
>>>>>>>>> - DML
>>>>>>>>>
>>>>>>>>> _______________________________________________
>>>>>>>>> Concurrency-interest mailing list
>>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>>
>>>>>>>>
>>>>>>>> _______________________________________________
>>>>>>>> Concurrency-interest mailing list
>>>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>>
>>>>>>>
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Alexandre
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/ad4c64ee/attachment-0001.html>

From aph at redhat.com  Wed Dec  9 12:18:16 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 17:18:16 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
Message-ID: <56686258.5010707@redhat.com>

On 12/09/2015 04:16 PM, Vitaly Davidovich wrote:
>>
>> an implicit implication that 'this' must remain reachable until after the
>> last instruction in each of its instance methods
> 
> Why wouldn't this work, at least as a compromise?

It would, but it would hurt performance because of increased register
pressure.

Andrew.


From gil at azul.com  Wed Dec  9 12:23:28 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 17:23:28 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56686258.5010707@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<56686258.5010707@redhat.com>
Message-ID: <55A7821F-06AE-43BC-8ACE-96B13A310D95@azul.com>


> On Dec 9, 2015, at 9:18 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/09/2015 04:16 PM, Vitaly Davidovich wrote:
>>> 
>>> an implicit implication that 'this' must remain reachable until after the
>>> last instruction in each of its instance methods
>> 
>> Why wouldn't this work, at least as a compromise?
> 
> It would, but it would hurt performance because of increased register
> pressure.

Actually, it would only add a stack slot. And a spill into it if needed.

> Andrew.
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/bf0a70cc/attachment.bin>

From vitalyd at gmail.com  Wed Dec  9 12:26:55 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 12:26:55 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
Message-ID: <CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>

>
> I'm not saying it's a fact. I'm just saying that ice never seen any
> indication of the compilers trying to do this (and it's certainly not
> required by any spec). And Jason's example seems to demonstrate at least
> one case where they actually don't do it.


This is why I suggested to ask the Hotspot compiler devs who may be able to
answer this (relatively) quickly and definitively, or at least as
definitive as we'll get at this point.  Jason's example? You mean
Alexandre's? The only case demonstrated in this thread that actually
segfaults is what Alexandre showed, but as mentioned a few times, it's
slightly different from DBB.

I'm not saying I don't believe we're hanging on by a thread here, but I'd
just like to hear confirmation of this from someone that works with that
code on a daily basis.  Perhaps I've had a bit too much speculation at this
point :).

And how would that hurt?
> If you were running interpreted, you would have that behavior anyway, so
> there is no valid semantic argument against it. E.g. the "but the GC won't
> collect 'this' for minutes in a long running loop when it could have"
> argument wouldn't fly here.


Performance conversations with interpreter in them are meaningless - I
don't care about interpreter here :).

And as for performance, keeping 'this' live to the end of the frame when it
> would otherwise have been untraceable would at worst eat up an additional
> stack slot in your frame that could have otherwise been recycled (it
> wouldn't actually eat up a register, because the register allocator
> would/should just spill it to the stack of the register was needed).


You're retaining memory that could otherwise be cleaned up much sooner.
It's an optimization that would be missed.  Whether it makes any
difference, I don't know, it would depend on circumstances.

The main downside has to do with teaching the compilers to actually do
> this. It's against their nature to keep otherwise dead oops in registers or
> sack locations, so they need to be told to do this somehow. But once
> reachabilityFence is implemented, the compilers have been taught how, and
> now it's just a question of where.


This assumes reachabilityFence is eventually optimized into a `marker` for
compiler only.  Right now, as we've discussed, it's an actual call with
prohibited inlining.

BTW, the implicit approach (for 'this' in all instance methods) is probably
> less performance-intrusive than manually adding referenceFence calls in
> e.g. DBB, because the implicit approach would not add any bytecodes to the
> affected methods, and would thereby avoid messing with currently working
> (but sometimes fragile) in lining heuristics... And since DBB get and put
> calls are often very performance sensitive, this could be a real issue...


Yes, agreed here.  But really, the current inlining heuristics are terrible
-- that's a big problem on its own.  reachabilityFence() may aggravate it,
which is why I raised that point earlier.


On Wed, Dec 9, 2015 at 12:14 PM, Gil Tene <gil at azul.com> wrote:

>
>
> Sent from Gil's iPhone
>
> On Dec 9, 2015, at 8:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> sent from my phone
> On Dec 9, 2015 11:34 AM, "Gil Tene" <gil at azul.com> wrote:
> >
> >
> >
> > Sent from Gil's iPhone
> >
> > On Dec 9, 2015, at 8:16 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> >
> >>> an implicit implication that 'this' must remain reachable until after
> the last instruction in each of its instance methods
> >>
> >>
> >> Why wouldn't this work, at least as a compromise?
> >
> >
> > Didn't say it wouldn't work. I said it >doesn't do it today.
>
> Is this a fact that it doesn't do it?
>
> I don't deal in facts, I just deal in suppositions ;-)
>
> I'm not saying it's a fact. I'm just saying that ice never seen any
> indication of the compilers trying to do this (and it's certainly not
> required by any spec). And Jason's example seems to demonstrate at least
> one case where they actually don't do it.
>
> >
> >> If there's unsafe.foo() inside a method, extend `this` lifetime to
> beyond that unsafe call.  Or if there's a use of `this` after unsafe.foo(),
> do not shorten the lifetime of `this` to prior to unsafe.foo(), even if the
> operations are otherwise schedulable like that.
> >
> >
> > I wouldn't limit this to unsafe. I would just do it for all instance
> method. Period. The bugs that have to do with loss of reachability to this
> exist even without uses of unsafe. Unsafe use cases (like DBB) are just a
> useful ways to demonstrate how bad things are (a SEGV catches people's
> attention more than other semantic wrongness).
> >
>
> I'd have an issue with extending it blindly.  What if you have a long
> running ordinary java method that doesn't use 'this' for majority of the
> execution time?
>
>
> And how would that hurt?
>
> If you were running interpreted, you would have that behavior anyway, so
> there is no valid semantic argument against it. E.g. the "but the GC won't
> collect 'this' for minutes in a long running loop when it could have"
> argument wouldn't fly here.
>
> And as for performance, keeping 'this' live to the end of the frame when
> it would otherwise have been untraceable would at worst eat up an
> additional stack slot in your frame that could have otherwise been recycled
> (it wouldn't actually eat up a register, because the register allocator
> would/should just spill it to the stack of the register was needed).
>
> The main downside has to do with teaching the compilers to actually do
> this. It's against their nature to keep otherwise dead oops in registers or
> sack locations, so they need to be told to do this somehow. But once
> reachabilityFence is implemented, the compilers have been taught how, and
> now it's just a question of where.
>
> BTW, the implicit approach (for 'this' in all instance methods) is
> probably less performance-intrusive than manually adding referenceFence
> calls in e.g. DBB, because the implicit approach would not add any
> bytecodes to the affected methods, and would thereby avoid messing with
> currently working (but sometimes fragile) in lining heuristics... And since
> DBB get and put calls are often very performance sensitive, this could be a
> real issue...
>
> You only have to do this when compiler is too smart and sees all accesses
> because it fully inlined.  Non-inlined methods are black boxes and compiler
> cannot reason across them (afterall, that's how current reachabilityFence
> is implemented).
>
> The bug technically exists in a non-inlined DBB.get(). Although you are
> right that it probably won't appear without inlining (the safepoint would
> be eliminated in the non-inlined method).
>
> But since keeping 'this' alive to the end of those non-inlined methods has
> no performance downside, there is no need to identify places where this
> shouldn't be applied...
>
> And within a longer compiled method that includes inlined methods, the
> 'this' of each inlined method doesn't need to stay reachable to the end of
> the long containing method. It only needs to stay alive until after the
> last instruction that originates from that specific inlined method (which
> is basically what a reachabilityFence in an explicit try...finally within
> that method would ensure).
>
> > To be specific: the same semantic premature loss of reachability issue
> exist around any resource-release-on-loss-of-reachability logic in Java
> today. Regardless of their choice of finalizers, cleaners, phantom refs, or
> weak or soft refs. And regales of whether the resource involved is
> "physical" (like memory) or logical (like a key or an id).  E.g. Files can
> be prematurely closed, their fds recycled, and their last I/O operations
> done to the wrong file or channel.  Logical window Ids can be prematurely
> recycled and their last graphic operations done to the wrong window or to
> bad memory. Etc. etc. etc.
>
> >
> > I'm not saying that each of these bugs actually exists right now (I
> haven't specifically hunted them down to check), but I *am* saying that the
> typical mechanisms each of them would use to do
> resource-release-on-loss-of-reachability (whether in the JDK or in user
> code) is inherently flawed under the current JLS and JVM specs, and that
> much like DBB's innocently written bugs, I expect to find these in many
> places that I look...
> >
> >>
> >> On Wed, Dec 9, 2015 at 10:57 AM, Gil Tene <gil at azul.com> wrote:
> >>>
> >>> Just like in Justin's example, DBB has multiple methods that don't use
> 'this' after their call to unsafe. Most of the get() and put() variants
> behave like that in DBB, and they are all exposed to a cleaner running and
> freeing the buffer's backing store before the unsafe call is ever made.
> >>>
> >>> AFAICT there is nothing the compilers do to protect against this.
> Specifically, there is nothing being done to extend the reachability of
> 'this' to beyond the point where an unsafe call is made in an instance
> method. And doing anything about it for unsafe specifically would be
> "hard". The unsafe call has no relation to 'this' except that it is being
> called from within the instance method, and uses arguments that were at
> some point in the (recent) past derived from 'this'. Without a reachability
> fence, or an implicit implication that 'this' must remain reachable until
> after the last instruction in each of its instance methods, there is
> nothing you can do (IMO) to plug up this bug.
> >>>
> >>> Sent from Gil's iPhone
> >>>
> >>> On Dec 9, 2015, at 7:30 AM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> >>>
> >>>> Your example code differs from DBB in that you don't use `this` after
> call to unsafe, as mentioned before, so the compiler fence (if any) is not
> applicable.
> >>>>
> >>>> Maybe you should bring this up on the hotspot compiler dev mailing
> list and get a definitive answer on how this is modeled today.
> >>>>
> >>>> sent from my phone
> >>>>
> >>>> On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
> wrote:
> >>>>>
> >>>>> Well the question that is underlying this thread is: does someone
> that uses DirectByteBuffer needs to ensure their liveness beyond method
> calls?
> >>>>>
> >>>>> It seems to be the case.
> >>>>>>>
> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to
> hit its bugs because the racing-point safepoint is often (unintentionally
> but luckily) eliminated, and the race needed to hit the safepoint when it
> does remain in compiled code is dynamically rare.
> >>>>>
> >>>>>
> >>>>> I tend to agree with Gil, and the example code that I have attached
> does seem to show that the compiler does not have any specific optimization
> fences when encountering Unsafe (or I would like to be explained what is
> going on, and would appreciate pointers to where in the hotspot source code
> those things are enforced). And this whole discussion shows that even if it
> were the case, relying on it might break at some point.
> >>>>>
> >>>>> So as a Java programmer, I will make sure that when using direct
> buffers they stay reachable long enough.
> >>>>>
> >>>>>
> >>>>>
> >>>>>
> >>>>>
> >>>>>>
> >>>>>> Agreed that it's broken and doesn't work *by design*.
> >>>>>>
> >>>>>>> get(int i) {
> >>>>>>>    long addr = ix(checkIndex(i));
> >>>>>>>    // There is a safepoint here which may or may not be removed
> depending on
> >>>>>>>    // unrelated compiler decisions.
> >>>>>>>    // "this" may no longer be reachable here.
> >>>>>>>    // If this is the last access to this buffer, and it goes out
> of scope "after" this get(),
> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
> cleaner can fully
> >>>>>>>    // execute and free the associated off-heap memory at addr
> before the next
> >>>>>>>    // line below is executed...
> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
> >>>>>>> }
> >>>>>>
> >>>>>>
> >>>>>> Yes.  I'm not convinced that compiler isn't treating Unsafe
> operations as an optimization barrier, precluding live range of `this`
> being shortened.  Is there even a single reported/observed instance of DBB
> segfaulting or reading free'd memory in this case? This class and methods
> are very popular, and granted most of the time you don't instantiate a DBB
> that immediately goes out of scope, I'd expect this to occur out in the
> wild and ensuing bug reports.
> >>>>>>
> >>>>>>> public ByteBuffer put(int i, byte x) {
> >>>>>>>    long addr = ix(checkIndex(i));
> >>>>>>>    // There is a safepoint here which may or may not be removed
> depending on
> >>>>>>>    // unrelated compiler decisions.
> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is
> inlined.
> >>>>>>>    // If this is the last put to this buffer, and it goes out of
> scope "after" this put(),
> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
> cleaner can fully
> >>>>>>>    // execute and free the associated off-heap memory at addr
> before the next
> >>>>>>>    // line below is executed...
> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
> >>>>>>>    return this; // This may not be used by inlining caller, and
> removed as dead code
> >>>>>>> }
> >>>>>>
> >>>>>>
> >>>>>> Likewise here, I'm not sure compiler reasons about Unsafe
> operations so aggressively.
> >>>>>>
> >>>>>>> public ByteBuffer put(int i, byte x) {
> >>>>>>>    try {
> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
> >>>>>>>        return this;
> >>>>>>>    } finally {
> >>>>>>>        Fences.reachabilityFence(this);
> >>>>>>>    }
> >>>>>>> }
> >>>>>>
> >>>>>>
> >>>>>> Yes.  This also reminds me that default inlining size needs to be
> reconsidered in light of changes like the above.  Putting try/finally
> {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
> make some methods go over the default MaxInlineSize threshold.
> >>>>>>
> >>>>>>
> >>>>>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
> >>>>>>>>
> >>>>>>>> The thread started with Alexandre
> >>>>>>>> asking a question for which he then added a segfaulting example;
> we
> >>>>>>>>
> >>>>>>>> tried to figure out why his didn't work and DBB works.
> >>>>>>>
> >>>>>>>
> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to
> hit its bugs because the racing-point safepoint is often (unintentionally
> but luckily) eliminated, and the race needed to hit the safepoint when it
> does remain in compiled code is dynamically rare. To highlight by analysis,
> rather than with a reproducer, where current DBB is vulnerable, look at the
> simplest forms of get() and put(). Since both get() and put() will tend to
> [hopefully] get inlined, the safepoint positions I highlight below can
> easily remain real even after optimization. Many current cleaner-related
> (and other phantom/weak/soft ref queueing handlers that release resources)
> have similar bugs, and Fences.reachabilityFence can finally be used to fix
> them.
> >>>>>>>
> >>>>>>> get(int i) {
> >>>>>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
> >>>>>>> }
> >>>>>>>
> >>>>>>> public ByteBuffer put(int i, byte x) {
> >>>>>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
> >>>>>>>    return this;
> >>>>>>> }
> >>>>>>>
> >>>>>>> To highlight the bugs, let me split these up into steps:
> >>>>>>>
> >>>>>>> get(int i) {
> >>>>>>>    long addr = ix(checkIndex(i));
> >>>>>>>    // There is a safepoint here which may or may not be removed
> depending on
> >>>>>>>    // unrelated compiler decisions.
> >>>>>>>    // "this" may no longer be reachable here.
> >>>>>>>    // If this is the last access to this buffer, and it goes out
> of scope "after" this get(),
> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
> cleaner can fully
> >>>>>>>    // execute and free the associated off-heap memory at addr
> before the next
> >>>>>>>    // line below is executed...
> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
> >>>>>>> }
> >>>>>>>
> >>>>>>> public ByteBuffer put(int i, byte x) {
> >>>>>>>    long addr = ix(checkIndex(i));
> >>>>>>>    // There is a safepoint here which may or may not be removed
> depending on
> >>>>>>>    // unrelated compiler decisions.
> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is
> inlined.
> >>>>>>>    // If this is the last put to this buffer, and it goes out of
> scope "after" this put(),
> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
> cleaner can fully
> >>>>>>>    // execute and free the associated off-heap memory at addr
> before the next
> >>>>>>>    // line below is executed...
> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
> >>>>>>>    return this; // This may not be used by inlining caller, and
> removed as dead code
> >>>>>>> }
> >>>>>>>
> >>>>>>>
> >>>>>>> With reachabilityFence, this bug can finally be fixed with e.g.:
> >>>>>>>
> >>>>>>> public ByteBuffer put(int i, byte x) {
> >>>>>>>    try {
> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
> >>>>>>>        return this;
> >>>>>>>    } finally {
> >>>>>>>        Fences.reachabilityFence(this);
> >>>>>>>    }
> >>>>>>> }
> >>>>>>>
> >>>>>>> get(int i) {
> >>>>>>>    try {
> >>>>>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
> >>>>>>>    } finally {
> >>>>>>>        Fences.reachabilityFence(this);
> >>>>>>>    }
> >>>>>>> }
> >>>>>>>
> >>>>>>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
> >>>>>>>>
> >>>>>>>>> If you're talking about simply observing the effects of an
> object being collected while method invocations on that object are still in
> flight, see this article:
> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
> >>>>>>>>> We have run into this issue numerous times in various
> situations, which is why we're happy to see reachabilityFence() come into
> being.  So yes, it's already broken.
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> Nope, I'm talking about breaking existing DBB code as it stands
> today.  Alexandre already posted an example of where similar but subtly
> different (with respect to DBB) code breaks, so I'm well aware it's a
> problem.
> >>>>>>>>
> >>>>>>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <
> david.lloyd at redhat.com> wrote:
> >>>>>>>>>
> >>>>>>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
> >>>>>>>>>>
> >>>>>>>>>>     The lifetime, natural or otherwise, of an instance does not
> survive
> >>>>>>>>>>     until an instance method returns because, a lot of the
> time, that
> >>>>>>>>>>     instance method is inlined.
> >>>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> You're talking about optimization here (inlining); by "natural"
> I meant
> >>>>>>>>>> the naive/no optimization case (e.g. interpreter, debugger
> attached
> >>>>>>>>>> w/breakpoint in method, etc).
> >>>>>>>>>>
> >>>>>>>>>>     It's not just HotSpot, though: some VMs are even more
> aggressive, and
> >>>>>>>>>>
> >>>>>>>>>> Which java VMs are these? Just curious.
> >>>>>>>>>>
> >>>>>>>>>>     we have seen finalizers executed even before constructors
> have
> >>>>>>>>>>     completed.  And that is allowed by the specification.
> >>>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> Ok, but that's beside the point, really.  Surely if compiler can
> >>>>>>>>>> optimize and arrange for liveness to allow for it, then it's a
> good
> >>>>>>>>>> thing it does that.  My point isn't that this cannot happen due
> to spec,
> >>>>>>>>>> but rather that in places like DBB where `this` is used after
> the Unsafe
> >>>>>>>>>> call the  compiler has to schedule things differently in order
> to reduce
> >>>>>>>>>> lifetime.  And my point is that compilers generally tend to be
> cautious
> >>>>>>>>>> in doing things that may break code.  This is the practical
> aspect we
> >>>>>>>>>> were referring to - it's actual humans writing these
> optimizations, and
> >>>>>>>>>> they're sensitive to breaking code, particularly in java.
> >>>>>>>>>> Theoretically, yes, anything is possible.
> >>>>>>>>>>
> >>>>>>>>>>     It's already broken.
> >>>>>>>>>>
> >>>>>>>>>>
> >>>>>>>>>> Sure.  Now try to submit a patch to Hotspot that will break
> this case,
> >>>>>>>>>> even if allowed by spec, and see how far you get :).
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>> If you're talking about simply observing the effects of an
> object being collected while method invocations on that object are still in
> flight, see this article:
> >>>>>>>>>
> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
> >>>>>>>>>
> >>>>>>>>> We have run into this issue numerous times in various
> situations, which is why we're happy to see reachabilityFence() come into
> being.  So yes, it's already broken.
> >>>>>>>>> --
> >>>>>>>>> - DML
> >>>>>>>>>
> >>>>>>>>> _______________________________________________
> >>>>>>>>> Concurrency-interest mailing list
> >>>>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>>
> >>>>>>>>
> >>>>>>>> _______________________________________________
> >>>>>>>> Concurrency-interest mailing list
> >>>>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>>
> >>>>>>>
> >>>>>>
> >>>>>>
> >>>>>> _______________________________________________
> >>>>>> Concurrency-interest mailing list
> >>>>>> Concurrency-interest at cs.oswego.edu
> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>>>>>
> >>>>>
> >>>>>
> >>>>>
> >>>>> --
> >>>>> Alexandre
> >>
> >>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/60141787/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 12:27:28 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 12:27:28 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56686258.5010707@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<56686258.5010707@redhat.com>
Message-ID: <CAHjP37F-rWduBeLRfsyveosoFt4SjpAaUy2bD1Yffh7WhYW3Hw@mail.gmail.com>

As Gil said, it should be spilled as there are no actual uses of it.

On Wed, Dec 9, 2015 at 12:18 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/09/2015 04:16 PM, Vitaly Davidovich wrote:
> >>
> >> an implicit implication that 'this' must remain reachable until after
> the
> >> last instruction in each of its instance methods
> >
> > Why wouldn't this work, at least as a compromise?
>
> It would, but it would hurt performance because of increased register
> pressure.
>
> Andrew.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/653fb3d5/attachment.html>

From adc at quartetfs.com  Wed Dec  9 12:39:40 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Wed, 9 Dec 2015 18:39:40 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
Message-ID: <CANrO4iZ8kJxvjNhiNs=1v6LH+q6syJTcomExnPd4Npn+06bdmA@mail.gmail.com>

> This is why I suggested to ask the Hotspot compiler devs who may be able
> to answer this (relatively) quickly and definitively, or at least as
> definitive as we'll get at this point.  Jason's example? You mean
> Alexandre's? The only case demonstrated in this thread that actually
> segfaults is what Alexandre showed, but as mentioned a few times, it's
> slightly different from DBB.
>
>
Well it's not that different from the get() method of a DBB.
If you like, you can replace the copy method of my previous example with
something like

public byte[] copy() {
final byte[] a = new byte[1];
final long addr = this.addr;
if (ctr++ >= 31_000l * 1000) {
// Counter is there to wait for JIT compilation
System.out.println("Must be compiled now, start doing some GCs " + ctr);
// Here we simulate a safepoint, and a GC at this safepoint
System.gc();
try {
// And here we wait for the reference handler to perform the cleaning to
simulate a fast cleaning.
Thread.sleep(1000);
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
}
a[0] = unsafe.getByte(addr);
return a;
}

This crashes as well.

Alexandre
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/9385b7fa/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 12:47:11 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 12:47:11 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4iZ8kJxvjNhiNs=1v6LH+q6syJTcomExnPd4Npn+06bdmA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
	<CANrO4iZ8kJxvjNhiNs=1v6LH+q6syJTcomExnPd4Npn+06bdmA@mail.gmail.com>
Message-ID: <CAHjP37FeQtBf=2mg_6KjR_R1Ktd_9r86R1nrZRCHqXtepy4w2A@mail.gmail.com>

This is no different than your previous examples in spirit.  Your explicit
triggering of GC is contorting the real thing we want to check.  You're
also using a loop with a long counter, which will automatically place
safepoint polls in that loop.  I'm trying to understand how DBB.get()
happens to work today, not how the above doesn't as it's obvious to me why
it doesn't. :)

On Wed, Dec 9, 2015 at 12:39 PM, Alexandre De Champeaux <adc at quartetfs.com>
wrote:

>
>
>> This is why I suggested to ask the Hotspot compiler devs who may be able
>> to answer this (relatively) quickly and definitively, or at least as
>> definitive as we'll get at this point.  Jason's example? You mean
>> Alexandre's? The only case demonstrated in this thread that actually
>> segfaults is what Alexandre showed, but as mentioned a few times, it's
>> slightly different from DBB.
>>
>>
> Well it's not that different from the get() method of a DBB.
> If you like, you can replace the copy method of my previous example with
> something like
>
> public byte[] copy() {
> final byte[] a = new byte[1];
> final long addr = this.addr;
> if (ctr++ >= 31_000l * 1000) {
> // Counter is there to wait for JIT compilation
> System.out.println("Must be compiled now, start doing some GCs " + ctr);
> // Here we simulate a safepoint, and a GC at this safepoint
> System.gc();
> try {
> // And here we wait for the reference handler to perform the cleaning to
> simulate a fast cleaning.
> Thread.sleep(1000);
> } catch (InterruptedException e) {
> Thread.currentThread().interrupt();
> }
> }
> a[0] = unsafe.getByte(addr);
> return a;
> }
>
> This crashes as well.
>
> Alexandre
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/34f70da2/attachment.html>

From gil at azul.com  Wed Dec  9 12:49:24 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 17:49:24 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
Message-ID: <F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>


> On Dec 9, 2015, at 9:26 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> 
> I'm not saying it's a fact. I'm just saying that ice never seen any indication of the compilers trying to do this (and it's certainly not required by any spec). And Jason's example seems to demonstrate at least one case where they actually don't do it.
> 
> This is why I suggested to ask the Hotspot compiler devs who may be able to answer this (relatively) quickly and definitively, or at least as definitive as we'll get at this point.  Jason's example? You mean Alexandre's? The only case demonstrated in this thread that actually segfaults is what Alexandre showed, but as mentioned a few times, it's slightly different from DBB.

Yes. s/Jason/Alexandre/g in my above reference to the example. Sorry for the mixup.

But that example is not different from DBB.get(). Both have a safepoint between the last use if 'this' and a call on unsafe on an address derived from 'this' in the past. Alexandre's simply forces reproduction by preventing the compiler from getting rid of the safepoint. And an inlined DBB.get() can have the same happen to it in various ways.

Alexandre's example is an existence proof that the current compilers to do extend the reachability of 'this' to the end of a method when an unsafe call is included in the method. And also that they do not extend the reachability of 'this' to beyond the unsafe call. If they did either one of those, the example would not trigger a SEGV.

> 
> I'm not saying I don't believe we're hanging on by a thread here, but I'd just like to hear confirmation of this from someone that works with that code on a daily basis.  Perhaps I've had a bit too much speculation at this point :).
> 
> And how would that hurt?
> If you were running interpreted, you would have that behavior anyway, so there is no valid semantic argument against it. E.g. the "but the GC won't collect 'this' for minutes in a long running loop when it could have" argument wouldn't fly here.
> 
> Performance conversations with interpreter in them are meaningless - I don't care about interpreter here :).

An expectation that parts of the heap would be collected "better" when compiled than when interpreted is a semantic discussion. I assume that you would not complain about an OOM exception being thrown based on this.

> 
> And as for performance, keeping 'this' live to the end of the frame when it would otherwise have been untraceable would at worst eat up an additional stack slot in your frame that could have otherwise been recycled (it wouldn't actually eat up a register, because the register allocator would/should just spill it to the stack of the register was needed).
> 
> You're retaining memory that could otherwise be cleaned up much sooner.  It's an optimization that would be missed.  Whether it makes any difference, I don't know, it would depend on circumstances.

If you are referring to the extremely-indirect benefit of more objects being released by a GC cycle if it happens to trigger in the middle of this method, you are probably technically right, in the sense that it is a non-zero. But since those effects are dwarfed (by 4+ orders of magnitude) compared to e.g. a choice of starting a CMS mark pass a few milliseconds earlier or later, I doubt that we can even discuss them as a "performance" effect.

> 
> The main downside has to do with teaching the compilers to actually do this. It's against their nature to keep otherwise dead oops in registers or sack locations, so they need to be told to do this somehow. But once reachabilityFence is implemented, the compilers have been taught how, and now it's just a question of where.
> 
> This assumes reachabilityFence is eventually optimized into a `marker` for compiler only.  Right now, as we've discussed, it's an actual call with prohibited inlining.

Since I expect reachabilityFence to be used to actually fix all those bugs in DBB, I also expect that it will not remain un-intrinsified in implementation.

I would not suggest implicit behavior unless it were implemented purely as a keep-this-oop-alive-in-this-frame-until-point-X intrinsic that has no other cost beyond the stack slot remaining occupied and a potential spill into that slot. But once that is implemented (and I expect that it will be), I think that the a change to implicitly extend the reachability 'this' to the end of all instance method (with no exception) will be the right way to go, even if it were not spec'ed that way in the JLS and JVM spec. It is certainly allowed behavior, and implementing it (even without the spec changes) would allow us to avoid fixing all those bugs one-by-one in the JDK, and tripping those bugs in user code.

> 
> BTW, the implicit approach (for 'this' in all instance methods) is probably less performance-intrusive than manually adding referenceFence calls in e.g. DBB, because the implicit approach would not add any bytecodes to the affected methods, and would thereby avoid messing with currently working (but sometimes fragile) in lining heuristics... And since DBB get and put calls are often very performance sensitive, this could be a real issue...
> 
> Yes, agreed here.  But really, the current inlining heuristics are terrible -- that's a big problem on its own.  reachabilityFence() may aggravate it, which is why I raised that point earlier.
> 
> 
> On Wed, Dec 9, 2015 at 12:14 PM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
> 
> 
> Sent from Gil's iPhone
> 
> On Dec 9, 2015, at 8:45 AM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
> 
>> 
>> sent from my phone
>> On Dec 9, 2015 11:34 AM, "Gil Tene" <gil at azul.com <mailto:gil at azul.com>> wrote:
>> >
>> >
>> >
>> > Sent from Gil's iPhone
>> >
>> > On Dec 9, 2015, at 8:16 AM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>> >
>> >>> an implicit implication that 'this' must remain reachable until after the last instruction in each of its instance methods
>> >>
>> >>
>> >> Why wouldn't this work, at least as a compromise?
>> >
>> >
>> > Didn't say it wouldn't work. I said it >doesn't do it today.
>> 
>> Is this a fact that it doesn't do it?
>> 
> 
> I don't deal in facts, I just deal in suppositions ;-)
> 
> I'm not saying it's a fact. I'm just saying that ice never seen any indication of the compilers trying to do this (and it's certainly not required by any spec). And Jason's example seems to demonstrate at least one case where they actually don't do it.
>> >
>> >> If there's unsafe.foo() inside a method, extend `this` lifetime to beyond that unsafe call.  Or if there's a use of `this` after unsafe.foo(), do not shorten the lifetime of `this` to prior to unsafe.foo(), even if the operations are otherwise schedulable like that.
>> >
>> >
>> > I wouldn't limit this to unsafe. I would just do it for all instance method. Period. The bugs that have to do with loss of reachability to this exist even without uses of unsafe. Unsafe use cases (like DBB) are just a useful ways to demonstrate how bad things are (a SEGV catches people's attention more than other semantic wrongness).
>> >
>> 
>> I'd have an issue with extending it blindly.  What if you have a long running ordinary java method that doesn't use 'this' for majority of the execution time?
>> 
> 
> And how would that hurt?
> 
> If you were running interpreted, you would have that behavior anyway, so there is no valid semantic argument against it. E.g. the "but the GC won't collect 'this' for minutes in a long running loop when it could have" argument wouldn't fly here.
> 
> And as for performance, keeping 'this' live to the end of the frame when it would otherwise have been untraceable would at worst eat up an additional stack slot in your frame that could have otherwise been recycled (it wouldn't actually eat up a register, because the register allocator would/should just spill it to the stack of the register was needed).
> 
> The main downside has to do with teaching the compilers to actually do this. It's against their nature to keep otherwise dead oops in registers or sack locations, so they need to be told to do this somehow. But once reachabilityFence is implemented, the compilers have been taught how, and now it's just a question of where.
> 
> BTW, the implicit approach (for 'this' in all instance methods) is probably less performance-intrusive than manually adding referenceFence calls in e.g. DBB, because the implicit approach would not add any bytecodes to the affected methods, and would thereby avoid messing with currently working (but sometimes fragile) in lining heuristics... And since DBB get and put calls are often very performance sensitive, this could be a real issue...
>> You only have to do this when compiler is too smart and sees all accesses because it fully inlined.  Non-inlined methods are black boxes and compiler cannot reason across them (afterall, that's how current reachabilityFence is implemented).
>> 
> 
> The bug technically exists in a non-inlined DBB.get(). Although you are right that it probably won't appear without inlining (the safepoint would be eliminated in the non-inlined method).
> 
> But since keeping 'this' alive to the end of those non-inlined methods has no performance downside, there is no need to identify places where this shouldn't be applied...
> 
> And within a longer compiled method that includes inlined methods, the 'this' of each inlined method doesn't need to stay reachable to the end of the long containing method. It only needs to stay alive until after the last instruction that originates from that specific inlined method (which is basically what a reachabilityFence in an explicit try...finally within that method would ensure).
>> > To be specific: the same semantic premature loss of reachability issue exist around any resource-release-on-loss-of-reachability logic in Java today. Regardless of their choice of finalizers, cleaners, phantom refs, or weak or soft refs. And regales of whether the resource involved is "physical" (like memory) or logical (like a key or an id).  E.g. Files can be prematurely closed, their fds recycled, and their last I/O operations done to the wrong file or channel.  Logical window Ids can be prematurely recycled and their last graphic operations done to the wrong window or to bad memory. Etc. etc. etc.
>> 
>> 
>> >
>> > I'm not saying that each of these bugs actually exists right now (I haven't specifically hunted them down to check), but I *am* saying that the typical mechanisms each of them would use to do resource-release-on-loss-of-reachability (whether in the JDK or in user code) is inherently flawed under the current JLS and JVM specs, and that much like DBB's innocently written bugs, I expect to find these in many places that I look...
>> >
>> >>
>> >> On Wed, Dec 9, 2015 at 10:57 AM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>> >>>
>> >>> Just like in Justin's example, DBB has multiple methods that don't use 'this' after their call to unsafe. Most of the get() and put() variants behave like that in DBB, and they are all exposed to a cleaner running and freeing the buffer's backing store before the unsafe call is ever made.
>> >>>
>> >>> AFAICT there is nothing the compilers do to protect against this. Specifically, there is nothing being done to extend the reachability of 'this' to beyond the point where an unsafe call is made in an instance method. And doing anything about it for unsafe specifically would be "hard". The unsafe call has no relation to 'this' except that it is being called from within the instance method, and uses arguments that were at some point in the (recent) past derived from 'this'. Without a reachability fence, or an implicit implication that 'this' must remain reachable until after the last instruction in each of its instance methods, there is nothing you can do (IMO) to plug up this bug.
>> >>>
>> >>> Sent from Gil's iPhone
>> >>>
>> >>> On Dec 9, 2015, at 7:30 AM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>> >>>
>> >>>> Your example code differs from DBB in that you don't use `this` after call to unsafe, as mentioned before, so the compiler fence (if any) is not applicable.
>> >>>>
>> >>>> Maybe you should bring this up on the hotspot compiler dev mailing list and get a definitive answer on how this is modeled today.
>> >>>>
>> >>>> sent from my phone
>> >>>>
>> >>>> On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com <mailto:adc at quartetfs.com>> wrote:
>> >>>>>
>> >>>>> Well the question that is underlying this thread is: does someone that uses DirectByteBuffer needs to ensure their liveness beyond method calls?
>> >>>>>
>> >>>>> It seems to be the case.
>> >>>>>>>
>> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to hit its bugs because the racing-point safepoint is often (unintentionally but luckily) eliminated, and the race needed to hit the safepoint when it does remain in compiled code is dynamically rare.
>> >>>>>
>> >>>>>
>> >>>>> I tend to agree with Gil, and the example code that I have attached does seem to show that the compiler does not have any specific optimization fences when encountering Unsafe (or I would like to be explained what is going on, and would appreciate pointers to where in the hotspot source code those things are enforced). And this whole discussion shows that even if it were the case, relying on it might break at some point.
>> >>>>>
>> >>>>> So as a Java programmer, I will make sure that when using direct buffers they stay reachable long enough.
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>>
>> >>>>>> Agreed that it's broken and doesn't work *by design*.
>> >>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here.
>> >>>>>>>    // If this is the last access to this buffer, and it goes out of scope "after" this get(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Yes.  I'm not convinced that compiler isn't treating Unsafe operations as an optimization barrier, precluding live range of `this` being shortened.  Is there even a single reported/observed instance of DBB segfaulting or reading free'd memory in this case? This class and methods are very popular, and granted most of the time you don't instantiate a DBB that immediately goes out of scope, I'd expect this to occur out in the wild and ensuing bug reports.
>> >>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>> >>>>>>>    // If this is the last put to this buffer, and it goes out of scope "after" this put(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>> >>>>>>>    return this; // This may not be used by inlining caller, and removed as dead code
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Likewise here, I'm not sure compiler reasons about Unsafe operations so aggressively.
>> >>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    try {
>> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>> >>>>>>>        return this;
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Yes.  This also reminds me that default inlining size needs to be reconsidered in light of changes like the above.  Putting try/finally {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may make some methods go over the default MaxInlineSize threshold.
>> >>>>>>
>> >>>>>>
>> >>>>>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>> >>>>>>>>
>> >>>>>>>> The thread started with Alexandre
>> >>>>>>>> asking a question for which he then added a segfaulting example; we
>> >>>>>>>>
>> >>>>>>>> tried to figure out why his didn't work and DBB works.
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to hit its bugs because the racing-point safepoint is often (unintentionally but luckily) eliminated, and the race needed to hit the safepoint when it does remain in compiled code is dynamically rare. To highlight by analysis, rather than with a reproducer, where current DBB is vulnerable, look at the simplest forms of get() and put(). Since both get() and put() will tend to [hopefully] get inlined, the safepoint positions I highlight below can easily remain real even after optimization. Many current cleaner-related (and other phantom/weak/soft ref queueing handlers that release resources) have similar bugs, and Fences.reachabilityFence can finally be used to fix them.
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>> >>>>>>>    return this;
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> To highlight the bugs, let me split these up into steps:
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here.
>> >>>>>>>    // If this is the last access to this buffer, and it goes out of scope "after" this get(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is inlined.
>> >>>>>>>    // If this is the last put to this buffer, and it goes out of scope "after" this put(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>> >>>>>>>    return this; // This may not be used by inlining caller, and removed as dead code
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> With reachabilityFence, this bug can finally be fixed with e.g.:
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    try {
>> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>> >>>>>>>        return this;
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    try {
>> >>>>>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>> >>>>>>>>
>> >>>>>>>>> If you're talking about simply observing the effects of an object being collected while method invocations on that object are still in flight, see this article:
>> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms <http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms>
>> >>>>>>>>> We have run into this issue numerous times in various situations, which is why we're happy to see reachabilityFence() come into being.  So yes, it's already broken.
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>> Nope, I'm talking about breaking existing DBB code as it stands today.  Alexandre already posted an example of where similar but subtly different (with respect to DBB) code breaks, so I'm well aware it's a problem.
>> >>>>>>>>
>> >>>>>>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <david.lloyd at redhat.com <mailto:david.lloyd at redhat.com>> wrote:
>> >>>>>>>>>
>> >>>>>>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>> >>>>>>>>>>
>> >>>>>>>>>>     The lifetime, natural or otherwise, of an instance does not survive
>> >>>>>>>>>>     until an instance method returns because, a lot of the time, that
>> >>>>>>>>>>     instance method is inlined.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> You're talking about optimization here (inlining); by "natural" I meant
>> >>>>>>>>>> the naive/no optimization case (e.g. interpreter, debugger attached
>> >>>>>>>>>> w/breakpoint in method, etc).
>> >>>>>>>>>>
>> >>>>>>>>>>     It's not just HotSpot, though: some VMs are even more aggressive, and
>> >>>>>>>>>>
>> >>>>>>>>>> Which java VMs are these? Just curious.
>> >>>>>>>>>>
>> >>>>>>>>>>     we have seen finalizers executed even before constructors have
>> >>>>>>>>>>     completed.  And that is allowed by the specification.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> Ok, but that's beside the point, really.  Surely if compiler can
>> >>>>>>>>>> optimize and arrange for liveness to allow for it, then it's a good
>> >>>>>>>>>> thing it does that.  My point isn't that this cannot happen due to spec,
>> >>>>>>>>>> but rather that in places like DBB where `this` is used after the Unsafe
>> >>>>>>>>>> call the  compiler has to schedule things differently in order to reduce
>> >>>>>>>>>> lifetime.  And my point is that compilers generally tend to be cautious
>> >>>>>>>>>> in doing things that may break code.  This is the practical aspect we
>> >>>>>>>>>> were referring to - it's actual humans writing these optimizations, and
>> >>>>>>>>>> they're sensitive to breaking code, particularly in java.
>> >>>>>>>>>> Theoretically, yes, anything is possible.
>> >>>>>>>>>>
>> >>>>>>>>>>     It's already broken.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> Sure.  Now try to submit a patch to Hotspot that will break this case,
>> >>>>>>>>>> even if allowed by spec, and see how far you get :).
>> >>>>>>>>>
>> >>>>>>>>>
>> >>>>>>>>> If you're talking about simply observing the effects of an object being collected while method invocations on that object are still in flight, see this article:
>> >>>>>>>>>
>> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms <http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms>
>> >>>>>>>>>
>> >>>>>>>>> We have run into this issue numerous times in various situations, which is why we're happy to see reachabilityFence() come into being.  So yes, it's already broken.
>> >>>>>>>>> --
>> >>>>>>>>> - DML
>> >>>>>>>>>
>> >>>>>>>>> _______________________________________________
>> >>>>>>>>> Concurrency-interest mailing list
>> >>>>>>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> >>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>> _______________________________________________
>> >>>>>>>> Concurrency-interest mailing list
>> >>>>>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> >>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> >>>>>>>
>> >>>>>>>
>> >>>>>>
>> >>>>>>
>> >>>>>> _______________________________________________
>> >>>>>> Concurrency-interest mailing list
>> >>>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> >>>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>> --
>> >>>>> Alexandre
>> >>
>> >>
>> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/5864f006/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/5864f006/attachment-0001.bin>

From gil at azul.com  Wed Dec  9 12:53:28 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 17:53:28 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
Message-ID: <2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>

[re-sending since it appears that my previous e-mails were not making it into the list earlier (my fault)].

> On Dec 9, 2015, at 5:11 AM, Doug Lea <dl at cs.oswego.edu> wrote:
> 
> On 12/09/2015 05:33 AM, Andrew Haley wrote:
> 
>>> In my opinion, the current lack of optimization (accidental or not)
>>> should be somehow encoded/made intentional.
>> 
>> I have in the past argued that methods of classes with finalizers
>> should automagically extend the lifetime of the "this" object.
>> However, I was on the losing side, and reachabilityFence() is the
>> compromise result.  That's okay, really: it solves the practical
>> problem.
> 
> I don't think anyone "lost" these arguments, but further action
> was postponed at least in the context of JMM-related updates.
> 
> Among the options is to introduce a @Finalized annotation
> for a field of an object. Front-end compilers would
> then insert reachabilityFence() after each use. Not necessarily
> immediately after though. Optimal placement is non-trivial, which
> is one reason this wasn't widely agreed on. It would be great
> if some IDE's tried out this kind of support inside IDEs though.

Since this issue is in no way contained to finalizers, and effects all phantom/weak/soft refs and cleaners, anything that only applies to classes with finalizers would not be sufficient. E.g. DBB would still need to be fixed.

I also don't think that an annotation on a field that implies a reachability fence (regardless office we name it) would suffice or help much. DBB is a great example of why I think this: the buffer management in DBB is an internal concern, and the current reachability bugs in its get() and put() implementations are internal implementation bugs. As such, it would clearly make no sense for a user of DBB to place an @Finalized (or equivalent) annotation on their instance fields that refers to a DBB. But inside of DBB, field annotation can't be used since there is no field to annotate, since it is 'this' that needs its reachability extended to the end of its instance methods.

My take on this would be to change the JLS and JVM spec to state that 'this' remains reachable until after the last instruction of every instance method. Period. This would basically equate to placing an implicit reachability fence at all exist points of every instance method (I.e. The equivalent of a try...finally). The "nice? thing about such an implicit reachability fence is that it does not really defeat any optimizations, as it only serves to extend the lifetime of an oop (so potentially pressing slightly harder on the register allocator). IMO this would auto-magically fix lots of current rarely occurring bugs (like those on DBB, but also in user code), and prevent many future ones.

For now I'm happy to see reachabilityFence, because I'm convinced that we have many resource cleanup race bugs in the JDK that are currently in fixable without it. But I think we should consider this implementing this implicit behavior (extending 'this' reachability to the end of all instance methods) even if the spec is not changed, because it would save us the manual work of fixing all the existing bugs by adding reachability fences. And would obviously provide better coverage than anything we could do manually.

> 
> See discussions on jmm-dev list mostly in August 2014.
> http://mail.openjdk.java.net/pipermail/jmm-dev/
> 
> (Also, someday, the JLS probably should be updated to explicitly
> mention impact of reachabilityFence. The wording change
> would basically be the same as the method spec, but a few other
> clarifications done at the same time might be helpful.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/a509b2b4/attachment.bin>

From vitalyd at gmail.com  Wed Dec  9 13:21:36 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 13:21:36 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
	<F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>
Message-ID: <CAHjP37FJNywnoPk0nMtBBCweHnjkrHQ6zBohXO5nKM3thaYDNw@mail.gmail.com>

>
> Alexandre's example is an existence proof that the current compilers to do
> extend the reachability of 'this' to the end of a method when an unsafe
> call is included in the method. And also that they do not extend the
> reachability of 'this' to beyond the unsafe call. If they did either one of
> those, the example would not trigger a SEGV.


Ok, I buy that.  I can't help but wonder how DBB authors decided it's ok to
release it to the public like this though.  Granted, I can't think of a
(realistic) scenario where allocating a DBB that's immediately garbage is
normal.

An expectation that parts of the heap would be collected "better" when
> compiled than when interpreted is a semantic discussion. I assume that you
> would not complain about an OOM exception being thrown based on this.


It's semantic to an extent; java would be unusable if there was no JIT.  I
wouldn't complain about an OOM, but I may complain if the performance
profile changes from today.  Once a daemon's hot paths are compiled,
throughput goes up which means more GC pressure per unit of time than
interpreter.  If all of a sudden the JIT was less aggressive across the
board, I suspect it may rub some scenarios the wrong way.


> If you are referring to the extremely-indirect benefit of more objects
> being released by a GC cycle if it happens to trigger in the middle of this
> method, you are probably technically right, in the sense that it is a
> non-zero. But since those effects are dwarfed (by 4+ orders of magnitude)
> compared to e.g. a choice of starting a CMS mark pass a few milliseconds
> earlier or later, I doubt that we can even discuss them as a "performance"
> effect.


I'd rather not conflate these things.  Otherwise, I can argue that micro
optimizing, e.g., DBB.get() is irrelevant because there are plenty of other
perf cliffs in the system.

Since I expect reachabilityFence to be used to actually fix all those bugs
> in DBB, I also expect that it will not remain un-intrinsified in
> implementation.


Let's hope so.

I would not suggest implicit behavior unless it were implemented purely as
> a keep-this-oop-alive-in-this-frame-until-point-X intrinsic that has no
> other cost beyond the stack slot remaining occupied and a potential spill
> into that slot. But once that is implemented (and I expect that it will
> be), I think that the a change to implicitly extend the reachability 'this'
> to the end of all instance method (with no exception) will be the right way
> to go, even if it were not spec'ed that way in the JLS and JVM spec. It is
> certainly allowed behavior, and implementing it (even without the spec
> changes) would allow us to avoid fixing all those bugs one-by-one in the
> JDK, and tripping those bugs in user code.


If the choice is between this vs crashes (or worse, reads of free'd but
still mapped memory that now has garbage/wrong data), then I agree.  I
guess another benefit would be that it would reduce need/use of
reachabilityFence, and thus having to reason about these things in fewer
places.

On Wed, Dec 9, 2015 at 12:49 PM, Gil Tene <gil at azul.com> wrote:

>
> On Dec 9, 2015, at 9:26 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> I'm not saying it's a fact. I'm just saying that ice never seen any
>> indication of the compilers trying to do this (and it's certainly not
>> required by any spec). And Jason's example seems to demonstrate at least
>> one case where they actually don't do it.
>
>
> This is why I suggested to ask the Hotspot compiler devs who may be able
> to answer this (relatively) quickly and definitively, or at least as
> definitive as we'll get at this point.  Jason's example? You mean
> Alexandre's? The only case demonstrated in this thread that actually
> segfaults is what Alexandre showed, but as mentioned a few times, it's
> slightly different from DBB.
>
>
> Yes. s/Jason/Alexandre/g in my above reference to the example. Sorry for
> the mixup.
>
> But that example is not different from DBB.get(). Both have a safepoint
> between the last use if 'this' and a call on unsafe on an address derived
> from 'this' in the past. Alexandre's simply forces reproduction by
> preventing the compiler from getting rid of the safepoint. And an inlined
> DBB.get() can have the same happen to it in various ways.
>
> Alexandre's example is an existence proof that the current compilers to do
> extend the reachability of 'this' to the end of a method when an unsafe
> call is included in the method. And also that they do not extend the
> reachability of 'this' to beyond the unsafe call. If they did either one of
> those, the example would not trigger a SEGV.
>
>
> I'm not saying I don't believe we're hanging on by a thread here, but I'd
> just like to hear confirmation of this from someone that works with that
> code on a daily basis.  Perhaps I've had a bit too much speculation at this
> point :).
>
> And how would that hurt?
>> If you were running interpreted, you would have that behavior anyway, so
>> there is no valid semantic argument against it. E.g. the "but the GC won't
>> collect 'this' for minutes in a long running loop when it could have"
>> argument wouldn't fly here.
>
>
> Performance conversations with interpreter in them are meaningless - I
> don't care about interpreter here :).
>
>
> An expectation that parts of the heap would be collected "better" when
> compiled than when interpreted is a semantic discussion. I assume that you
> would not complain about an OOM exception being thrown based on this.
>
>
> And as for performance, keeping 'this' live to the end of the frame when
>> it would otherwise have been untraceable would at worst eat up an
>> additional stack slot in your frame that could have otherwise been recycled
>> (it wouldn't actually eat up a register, because the register allocator
>> would/should just spill it to the stack of the register was needed).
>
>
> You're retaining memory that could otherwise be cleaned up much sooner.
> It's an optimization that would be missed.  Whether it makes any
> difference, I don't know, it would depend on circumstances.
>
>
> If you are referring to the extremely-indirect benefit of more objects
> being released by a GC cycle if it happens to trigger in the middle of this
> method, you are probably technically right, in the sense that it is a
> non-zero. But since those effects are dwarfed (by 4+ orders of magnitude)
> compared to e.g. a choice of starting a CMS mark pass a few milliseconds
> earlier or later, I doubt that we can even discuss them as a "performance"
> effect.
>
>
> The main downside has to do with teaching the compilers to actually do
>> this. It's against their nature to keep otherwise dead oops in registers or
>> sack locations, so they need to be told to do this somehow. But once
>> reachabilityFence is implemented, the compilers have been taught how, and
>> now it's just a question of where.
>
>
> This assumes reachabilityFence is eventually optimized into a `marker` for
> compiler only.  Right now, as we've discussed, it's an actual call with
> prohibited inlining.
>
>
> Since I expect reachabilityFence to be used to actually fix all those bugs
> in DBB, I also expect that it will not remain un-intrinsified in
> implementation.
>
> I would not suggest implicit behavior unless it were implemented purely as
> a keep-this-oop-alive-in-this-frame-until-point-X intrinsic that has no
> other cost beyond the stack slot remaining occupied and a potential spill
> into that slot. But once that is implemented (and I expect that it will
> be), I think that the a change to implicitly extend the reachability 'this'
> to the end of all instance method (with no exception) will be the right way
> to go, even if it were not spec'ed that way in the JLS and JVM spec. It is
> certainly allowed behavior, and implementing it (even without the spec
> changes) would allow us to avoid fixing all those bugs one-by-one in the
> JDK, and tripping those bugs in user code.
>
>
> BTW, the implicit approach (for 'this' in all instance methods) is
>> probably less performance-intrusive than manually adding referenceFence
>> calls in e.g. DBB, because the implicit approach would not add any
>> bytecodes to the affected methods, and would thereby avoid messing with
>> currently working (but sometimes fragile) in lining heuristics... And since
>> DBB get and put calls are often very performance sensitive, this could be a
>> real issue...
>
>
> Yes, agreed here.  But really, the current inlining heuristics are
> terrible -- that's a big problem on its own.  reachabilityFence() may
> aggravate it, which is why I raised that point earlier.
>
>
> On Wed, Dec 9, 2015 at 12:14 PM, Gil Tene <gil at azul.com> wrote:
>
>>
>>
>> Sent from Gil's iPhone
>>
>> On Dec 9, 2015, at 8:45 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>>
>>
>> sent from my phone
>> On Dec 9, 2015 11:34 AM, "Gil Tene" <gil at azul.com> wrote:
>> >
>> >
>> >
>> > Sent from Gil's iPhone
>> >
>> > On Dec 9, 2015, at 8:16 AM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> >
>> >>> an implicit implication that 'this' must remain reachable until after
>> the last instruction in each of its instance methods
>> >>
>> >>
>> >> Why wouldn't this work, at least as a compromise?
>> >
>> >
>> > Didn't say it wouldn't work. I said it >doesn't do it today.
>>
>> Is this a fact that it doesn't do it?
>>
>> I don't deal in facts, I just deal in suppositions ;-)
>>
>> I'm not saying it's a fact. I'm just saying that ice never seen any
>> indication of the compilers trying to do this (and it's certainly not
>> required by any spec). And Jason's example seems to demonstrate at least
>> one case where they actually don't do it.
>>
>> >
>> >> If there's unsafe.foo() inside a method, extend `this` lifetime to
>> beyond that unsafe call.  Or if there's a use of `this` after unsafe.foo(),
>> do not shorten the lifetime of `this` to prior to unsafe.foo(), even if the
>> operations are otherwise schedulable like that.
>> >
>> >
>> > I wouldn't limit this to unsafe. I would just do it for all instance
>> method. Period. The bugs that have to do with loss of reachability to this
>> exist even without uses of unsafe. Unsafe use cases (like DBB) are just a
>> useful ways to demonstrate how bad things are (a SEGV catches people's
>> attention more than other semantic wrongness).
>> >
>>
>> I'd have an issue with extending it blindly.  What if you have a long
>> running ordinary java method that doesn't use 'this' for majority of the
>> execution time?
>>
>>
>> And how would that hurt?
>>
>> If you were running interpreted, you would have that behavior anyway, so
>> there is no valid semantic argument against it. E.g. the "but the GC won't
>> collect 'this' for minutes in a long running loop when it could have"
>> argument wouldn't fly here.
>>
>> And as for performance, keeping 'this' live to the end of the frame when
>> it would otherwise have been untraceable would at worst eat up an
>> additional stack slot in your frame that could have otherwise been recycled
>> (it wouldn't actually eat up a register, because the register allocator
>> would/should just spill it to the stack of the register was needed).
>>
>> The main downside has to do with teaching the compilers to actually do
>> this. It's against their nature to keep otherwise dead oops in registers or
>> sack locations, so they need to be told to do this somehow. But once
>> reachabilityFence is implemented, the compilers have been taught how, and
>> now it's just a question of where.
>>
>> BTW, the implicit approach (for 'this' in all instance methods) is
>> probably less performance-intrusive than manually adding referenceFence
>> calls in e.g. DBB, because the implicit approach would not add any
>> bytecodes to the affected methods, and would thereby avoid messing with
>> currently working (but sometimes fragile) in lining heuristics... And since
>> DBB get and put calls are often very performance sensitive, this could be a
>> real issue...
>>
>> You only have to do this when compiler is too smart and sees all accesses
>> because it fully inlined.  Non-inlined methods are black boxes and compiler
>> cannot reason across them (afterall, that's how current reachabilityFence
>> is implemented).
>>
>> The bug technically exists in a non-inlined DBB.get(). Although you are
>> right that it probably won't appear without inlining (the safepoint would
>> be eliminated in the non-inlined method).
>>
>> But since keeping 'this' alive to the end of those non-inlined methods
>> has no performance downside, there is no need to identify places where this
>> shouldn't be applied...
>>
>> And within a longer compiled method that includes inlined methods, the
>> 'this' of each inlined method doesn't need to stay reachable to the end of
>> the long containing method. It only needs to stay alive until after the
>> last instruction that originates from that specific inlined method (which
>> is basically what a reachabilityFence in an explicit try...finally within
>> that method would ensure).
>>
>> > To be specific: the same semantic premature loss of reachability issue
>> exist around any resource-release-on-loss-of-reachability logic in Java
>> today. Regardless of their choice of finalizers, cleaners, phantom refs, or
>> weak or soft refs. And regales of whether the resource involved is
>> "physical" (like memory) or logical (like a key or an id).  E.g. Files can
>> be prematurely closed, their fds recycled, and their last I/O operations
>> done to the wrong file or channel.  Logical window Ids can be prematurely
>> recycled and their last graphic operations done to the wrong window or to
>> bad memory. Etc. etc. etc.
>>
>> >
>> > I'm not saying that each of these bugs actually exists right now (I
>> haven't specifically hunted them down to check), but I *am* saying that the
>> typical mechanisms each of them would use to do
>> resource-release-on-loss-of-reachability (whether in the JDK or in user
>> code) is inherently flawed under the current JLS and JVM specs, and that
>> much like DBB's innocently written bugs, I expect to find these in many
>> places that I look...
>> >
>> >>
>> >> On Wed, Dec 9, 2015 at 10:57 AM, Gil Tene <gil at azul.com> wrote:
>> >>>
>> >>> Just like in Justin's example, DBB has multiple methods that don't
>> use 'this' after their call to unsafe. Most of the get() and put() variants
>> behave like that in DBB, and they are all exposed to a cleaner running and
>> freeing the buffer's backing store before the unsafe call is ever made.
>> >>>
>> >>> AFAICT there is nothing the compilers do to protect against this.
>> Specifically, there is nothing being done to extend the reachability of
>> 'this' to beyond the point where an unsafe call is made in an instance
>> method. And doing anything about it for unsafe specifically would be
>> "hard". The unsafe call has no relation to 'this' except that it is being
>> called from within the instance method, and uses arguments that were at
>> some point in the (recent) past derived from 'this'. Without a reachability
>> fence, or an implicit implication that 'this' must remain reachable until
>> after the last instruction in each of its instance methods, there is
>> nothing you can do (IMO) to plug up this bug.
>> >>>
>> >>> Sent from Gil's iPhone
>> >>>
>> >>> On Dec 9, 2015, at 7:30 AM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> >>>
>> >>>> Your example code differs from DBB in that you don't use `this`
>> after call to unsafe, as mentioned before, so the compiler fence (if any)
>> is not applicable.
>> >>>>
>> >>>> Maybe you should bring this up on the hotspot compiler dev mailing
>> list and get a definitive answer on how this is modeled today.
>> >>>>
>> >>>> sent from my phone
>> >>>>
>> >>>> On Dec 9, 2015 4:30 AM, "Alexandre De Champeaux" <adc at quartetfs.com>
>> wrote:
>> >>>>>
>> >>>>> Well the question that is underlying this thread is: does someone
>> that uses DirectByteBuffer needs to ensure their liveness beyond method
>> calls?
>> >>>>>
>> >>>>> It seems to be the case.
>> >>>>>>>
>> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to
>> hit its bugs because the racing-point safepoint is often (unintentionally
>> but luckily) eliminated, and the race needed to hit the safepoint when it
>> does remain in compiled code is dynamically rare.
>> >>>>>
>> >>>>>
>> >>>>> I tend to agree with Gil, and the example code that I have attached
>> does seem to show that the compiler does not have any specific optimization
>> fences when encountering Unsafe (or I would like to be explained what is
>> going on, and would appreciate pointers to where in the hotspot source code
>> those things are enforced). And this whole discussion shows that even if it
>> were the case, relying on it might break at some point.
>> >>>>>
>> >>>>> So as a Java programmer, I will make sure that when using direct
>> buffers they stay reachable long enough.
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>>>
>> >>>>>> Agreed that it's broken and doesn't work *by design*.
>> >>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed
>> depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here.
>> >>>>>>>    // If this is the last access to this buffer, and it goes out
>> of scope "after" this get(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
>> cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr
>> before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Yes.  I'm not convinced that compiler isn't treating Unsafe
>> operations as an optimization barrier, precluding live range of `this`
>> being shortened.  Is there even a single reported/observed instance of DBB
>> segfaulting or reading free'd memory in this case? This class and methods
>> are very popular, and granted most of the time you don't instantiate a DBB
>> that immediately goes out of scope, I'd expect this to occur out in the
>> wild and ensuing bug reports.
>> >>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed
>> depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is
>> inlined.
>> >>>>>>>    // If this is the last put to this buffer, and it goes out of
>> scope "after" this put(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
>> cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr
>> before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>> >>>>>>>    return this; // This may not be used by inlining caller, and
>> removed as dead code
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Likewise here, I'm not sure compiler reasons about Unsafe
>> operations so aggressively.
>> >>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    try {
>> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>> >>>>>>>        return this;
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>
>> >>>>>>
>> >>>>>> Yes.  This also reminds me that default inlining size needs to be
>> reconsidered in light of changes like the above.  Putting try/finally
>> {reachabilityFence(this)} adds about 14 bytes of bytecode alone, which may
>> make some methods go over the default MaxInlineSize threshold.
>> >>>>>>
>> >>>>>>
>> >>>>>> On Tue, Dec 8, 2015 at 12:01 PM, Gil Tene <gil at azul.com> wrote:
>> >>>>>>>>
>> >>>>>>>> The thread started with Alexandre
>> >>>>>>>> asking a question for which he then added a segfaulting example;
>> we
>> >>>>>>>>
>> >>>>>>>> tried to figure out why his didn't work and DBB works.
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> My take is that current DBB doesn't work. It's just "harder" to
>> hit its bugs because the racing-point safepoint is often (unintentionally
>> but luckily) eliminated, and the race needed to hit the safepoint when it
>> does remain in compiled code is dynamically rare. To highlight by analysis,
>> rather than with a reproducer, where current DBB is vulnerable, look at the
>> simplest forms of get() and put(). Since both get() and put() will tend to
>> [hopefully] get inlined, the safepoint positions I highlight below can
>> easily remain real even after optimization. Many current cleaner-related
>> (and other phantom/weak/soft ref queueing handlers that release resources)
>> have similar bugs, and Fences.reachabilityFence can finally be used to fix
>> them.
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    return ((unsafe.getByte(ix(checkIndex(i))))); // <?? bug!
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    unsafe.putByte(ix(checkIndex(i)), ((x)));  // <?? bug!
>> >>>>>>>    return this;
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> To highlight the bugs, let me split these up into steps:
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed
>> depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here.
>> >>>>>>>    // If this is the last access to this buffer, and it goes out
>> of scope "after" this get(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
>> cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr
>> before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    return ((unsafe.getByte(addr)))); // <?? Boom!
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    long addr = ix(checkIndex(i));
>> >>>>>>>    // There is a safepoint here which may or may not be removed
>> depending on
>> >>>>>>>    // unrelated compiler decisions.
>> >>>>>>>    // "this" may no longer be reachable here, e.g. if method is
>> inlined.
>> >>>>>>>    // If this is the last put to this buffer, and it goes out of
>> scope "after" this put(),
>> >>>>>>>    // GC can trigger here, enqueue the phantom ref, and the
>> cleaner can fully
>> >>>>>>>    // execute and free the associated off-heap memory at addr
>> before the next
>> >>>>>>>    // line below is executed...
>> >>>>>>>    unsafe.putByte(ix(addr, ((x)));  // <? Boom!
>> >>>>>>>    return this; // This may not be used by inlining caller, and
>> removed as dead code
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>>
>> >>>>>>> With reachabilityFence, this bug can finally be fixed with e.g.:
>> >>>>>>>
>> >>>>>>> public ByteBuffer put(int i, byte x) {
>> >>>>>>>    try {
>> >>>>>>>        unsafe.putByte(ix(checkIndex(i)), ((x)));
>> >>>>>>>        return this;
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>> get(int i) {
>> >>>>>>>    try {
>> >>>>>>>        return ((unsafe.getByte(ix(checkIndex(i)))));
>> >>>>>>>    } finally {
>> >>>>>>>        Fences.reachabilityFence(this);
>> >>>>>>>    }
>> >>>>>>> }
>> >>>>>>>
>> >>>>>>>> On Dec 8, 2015, at 7:38 AM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>> >>>>>>>>
>> >>>>>>>>> If you're talking about simply observing the effects of an
>> object being collected while method invocations on that object are still in
>> flight, see this article:
>> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>> >>>>>>>>> We have run into this issue numerous times in various
>> situations, which is why we're happy to see reachabilityFence() come into
>> being.  So yes, it's already broken.
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>> Nope, I'm talking about breaking existing DBB code as it stands
>> today.  Alexandre already posted an example of where similar but subtly
>> different (with respect to DBB) code breaks, so I'm well aware it's a
>> problem.
>> >>>>>>>>
>> >>>>>>>> On Tue, Dec 8, 2015 at 10:22 AM, David M. Lloyd <
>> david.lloyd at redhat.com> wrote:
>> >>>>>>>>>
>> >>>>>>>>> On 12/08/2015 08:40 AM, Vitaly Davidovich wrote:
>> >>>>>>>>>>
>> >>>>>>>>>>     The lifetime, natural or otherwise, of an instance does
>> not survive
>> >>>>>>>>>>     until an instance method returns because, a lot of the
>> time, that
>> >>>>>>>>>>     instance method is inlined.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> You're talking about optimization here (inlining); by
>> "natural" I meant
>> >>>>>>>>>> the naive/no optimization case (e.g. interpreter, debugger
>> attached
>> >>>>>>>>>> w/breakpoint in method, etc).
>> >>>>>>>>>>
>> >>>>>>>>>>     It's not just HotSpot, though: some VMs are even more
>> aggressive, and
>> >>>>>>>>>>
>> >>>>>>>>>> Which java VMs are these? Just curious.
>> >>>>>>>>>>
>> >>>>>>>>>>     we have seen finalizers executed even before constructors
>> have
>> >>>>>>>>>>     completed.  And that is allowed by the specification.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> Ok, but that's beside the point, really.  Surely if compiler
>> can
>> >>>>>>>>>> optimize and arrange for liveness to allow for it, then it's a
>> good
>> >>>>>>>>>> thing it does that.  My point isn't that this cannot happen
>> due to spec,
>> >>>>>>>>>> but rather that in places like DBB where `this` is used after
>> the Unsafe
>> >>>>>>>>>> call the  compiler has to schedule things differently in order
>> to reduce
>> >>>>>>>>>> lifetime.  And my point is that compilers generally tend to be
>> cautious
>> >>>>>>>>>> in doing things that may break code.  This is the practical
>> aspect we
>> >>>>>>>>>> were referring to - it's actual humans writing these
>> optimizations, and
>> >>>>>>>>>> they're sensitive to breaking code, particularly in java.
>> >>>>>>>>>> Theoretically, yes, anything is possible.
>> >>>>>>>>>>
>> >>>>>>>>>>     It's already broken.
>> >>>>>>>>>>
>> >>>>>>>>>>
>> >>>>>>>>>> Sure.  Now try to submit a patch to Hotspot that will break
>> this case,
>> >>>>>>>>>> even if allowed by spec, and see how far you get :).
>> >>>>>>>>>
>> >>>>>>>>>
>> >>>>>>>>> If you're talking about simply observing the effects of an
>> object being collected while method invocations on that object are still in
>> flight, see this article:
>> >>>>>>>>>
>> >>>>>>>>> http://www.infoq.com/articles/Fatal-Flaw-Finalizers-Phantoms
>> >>>>>>>>>
>> >>>>>>>>> We have run into this issue numerous times in various
>> situations, which is why we're happy to see reachabilityFence() come into
>> being.  So yes, it's already broken.
>> >>>>>>>>> --
>> >>>>>>>>> - DML
>> >>>>>>>>>
>> >>>>>>>>> _______________________________________________
>> >>>>>>>>> Concurrency-interest mailing list
>> >>>>>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>>>
>> >>>>>>>>
>> >>>>>>>> _______________________________________________
>> >>>>>>>> Concurrency-interest mailing list
>> >>>>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>>
>> >>>>>>>
>> >>>>>>
>> >>>>>>
>> >>>>>> _______________________________________________
>> >>>>>> Concurrency-interest mailing list
>> >>>>>> Concurrency-interest at cs.oswego.edu
>> >>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>>>>>
>> >>>>>
>> >>>>>
>> >>>>>
>> >>>>> --
>> >>>>> Alexandre
>> >>
>> >>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/70e3964b/attachment-0001.html>

From aph at redhat.com  Wed Dec  9 13:26:16 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 18:26:16 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <55A7821F-06AE-43BC-8ACE-96B13A310D95@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<56686258.5010707@redhat.com>
	<55A7821F-06AE-43BC-8ACE-96B13A310D95@azul.com>
Message-ID: <56687248.5050104@redhat.com>

On 12/09/2015 05:23 PM, Gil Tene wrote:
> 
>> On Dec 9, 2015, at 9:18 AM, Andrew Haley <aph at redhat.com> wrote:
>>
>> On 12/09/2015 04:16 PM, Vitaly Davidovich wrote:
>>>>
>>>> an implicit implication that 'this' must remain reachable until after the
>>>> last instruction in each of its instance methods
>>>
>>> Why wouldn't this work, at least as a compromise?
>>
>> It would, but it would hurt performance because of increased register
>> pressure.
> 
> Actually, it would only add a stack slot. And a spill into it if needed.

Hesitant as I am to argue with you, I'm not so sure.  There'd
definitely have to be a USE in order to keep the oop alive, and C2
would surely try not to spill the oop.  The USE would be at the end of
every method.  Unless there's some sort of "sink" node in the ideal
graph which keeps an oop alive but does not refill from a stack slot,
and I don't think there is.

Andrew.

From aph at redhat.com  Wed Dec  9 13:40:03 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 18:40:03 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
Message-ID: <56687583.4060502@redhat.com>

On 12/09/2015 02:36 PM, Vitaly Davidovich wrote:
> sent from my phone
> On Dec 9, 2015 5:33 AM, "Andrew Haley" <aph at redhat.com> wrote:
>>
>> On 08/12/15 19:17, Vitaly Davidovich wrote:
>>>> [me:]

>>> So now I'm going to write to dummy fields? And what are you going to
>>> do with it in a finalizer?
>>
>> Update a global volatile.
> 
> And take perf hit? No thanks

I don't think it'd be measurable.  A global volatile write is pretty
cheap.  And I'm sure there are several such writes when queuing a
finalizer.

>>> And of course, a Sufficiently Smart Compiler could detect
>>> (theoretically, of course :)) that this is all just dummy ops and
>>> remove them.
>>
>> No, it can't.  Because the JLS says so.  IMVHO it'd be much better to
>> stop trying to guess what a compiler might do and simply write in the
>> language instead.
> 
> JLS prescribes observable behavior not exact steps.

Well, yes.  Indeed it does.

>>> In my opinion, the current lack of optimization (accidental or not)
>>> should be somehow encoded/made intentional.
>>
>> I have in the past argued that methods of classes with finalizers
>> should automagically extend the lifetime of the "this" object.
>> However, I was on the losing side, and reachabilityFence() is the
>> compromise result.  That's okay, really: it solves the practical
>> problem.
>>
>>> Perhaps treat Unsafe::anything() as a full compiler optimization
>>> fence, if it's not already.
>>
>> That one really is a no-hoper.  The idea of NIO ByteBuffers is "as
>> fast as C" and full fences would be a pretty major regression.
> 
> Maybe you missed the "compiler" part.

Not at all.

> I'm suggesting a compiler-only fence.  And I like how you suggested
> updating a global volatile above but here a full fence (which isn't
> what I proposed) is a no-hoper.

The global volatile gets hit once, when the object is finalized.  Not
at every access, which is what you'd have to do with a compiler
barrier.  Compiler barriers have a huge effect because they break many
loop optimizations.  That's a no-hoper.

Andrew.

From aph at redhat.com  Wed Dec  9 13:40:33 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 18:40:33 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
Message-ID: <566875A1.6000807@redhat.com>

On 12/09/2015 05:53 PM, Gil Tene wrote:

> My take on this would be to change the JLS and JVM spec to state
> that 'this' remains reachable until after the last instruction of
> every instance method. Period. This would basically equate to
> placing an implicit reachability fence at all exist points of every
> instance method (I.e. The equivalent of a try...finally). The "nice?
> thing about such an implicit reachability fence is that it does not
> really defeat any optimizations, as it only serves to extend the
> lifetime of an oop (so potentially pressing slightly harder on the
> register allocator). IMO this would auto-magically fix lots of
> current rarely occurring bugs (like those on DBB, but also in user
> code), and prevent many future ones.

Mmmm.  That's what I said!  One other advantage to doing this
automagically is that you won't get all these Java devs arguing about
whether the reachabilityFence really was needed.

Andrew.

From adc at quartetfs.com  Wed Dec  9 13:48:16 2015
From: adc at quartetfs.com (Alexandre De Champeaux)
Date: Wed, 9 Dec 2015 19:48:16 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FJNywnoPk0nMtBBCweHnjkrHQ6zBohXO5nKM3thaYDNw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
	<F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>
	<CAHjP37FJNywnoPk0nMtBBCweHnjkrHQ6zBohXO5nKM3thaYDNw@mail.gmail.com>
Message-ID: <CANrO4ianTLnFBtKxuhatwxg-A9oNK=pRG8WOh+mJ2sPusjrafw@mail.gmail.com>

> Ok, I buy that.  I can't help but wonder how DBB authors decided it's ok
> to release it to the public like this though.  Granted, I can't think of a
> (realistic) scenario where allocating a DBB that's immediately garbage is
> normal.
>

I don't see why only DBB that are immediately garbage would be affected.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/c1e3cad3/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 13:52:18 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 13:52:18 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56687583.4060502@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
Message-ID: <CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>

>
> I don't think it'd be measurable.  A global volatile write is pretty
> cheap.  And I'm sure there are several such writes when queuing a
> finalizer.


The global volatile gets hit once, when the object is finalized.  Not
> at every access, which is what you'd have to do with a compiler
> barrier.


Perhaps I misunderstood your global volatile suggestion -- when is it
written to exactly? What's the usage?

Compiler barriers have a huge effect because they break many
> loop optimizations.  That's a no-hoper.


That's true.  That's another reason to intrinsify reachabilityFence()
since, in its current form, it will be exactly like a compiler barrier.


On Wed, Dec 9, 2015 at 1:40 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/09/2015 02:36 PM, Vitaly Davidovich wrote:
> > sent from my phone
> > On Dec 9, 2015 5:33 AM, "Andrew Haley" <aph at redhat.com> wrote:
> >>
> >> On 08/12/15 19:17, Vitaly Davidovich wrote:
> >>>> [me:]
>
> >>> So now I'm going to write to dummy fields? And what are you going to
> >>> do with it in a finalizer?
> >>
> >> Update a global volatile.
> >
> > And take perf hit? No thanks
>
> I don't think it'd be measurable.  A global volatile write is pretty
> cheap.  And I'm sure there are several such writes when queuing a
> finalizer.
>
> >>> And of course, a Sufficiently Smart Compiler could detect
> >>> (theoretically, of course :)) that this is all just dummy ops and
> >>> remove them.
> >>
> >> No, it can't.  Because the JLS says so.  IMVHO it'd be much better to
> >> stop trying to guess what a compiler might do and simply write in the
> >> language instead.
> >
> > JLS prescribes observable behavior not exact steps.
>
> Well, yes.  Indeed it does.
>
> >>> In my opinion, the current lack of optimization (accidental or not)
> >>> should be somehow encoded/made intentional.
> >>
> >> I have in the past argued that methods of classes with finalizers
> >> should automagically extend the lifetime of the "this" object.
> >> However, I was on the losing side, and reachabilityFence() is the
> >> compromise result.  That's okay, really: it solves the practical
> >> problem.
> >>
> >>> Perhaps treat Unsafe::anything() as a full compiler optimization
> >>> fence, if it's not already.
> >>
> >> That one really is a no-hoper.  The idea of NIO ByteBuffers is "as
> >> fast as C" and full fences would be a pretty major regression.
> >
> > Maybe you missed the "compiler" part.
>
> Not at all.
>
> > I'm suggesting a compiler-only fence.  And I like how you suggested
> > updating a global volatile above but here a full fence (which isn't
> > what I proposed) is a no-hoper.
>
> The global volatile gets hit once, when the object is finalized.  Not
> at every access, which is what you'd have to do with a compiler
> barrier.  Compiler barriers have a huge effect because they break many
> loop optimizations.  That's a no-hoper.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/bc71f809/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 13:55:48 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 13:55:48 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4ianTLnFBtKxuhatwxg-A9oNK=pRG8WOh+mJ2sPusjrafw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
	<F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>
	<CAHjP37FJNywnoPk0nMtBBCweHnjkrHQ6zBohXO5nKM3thaYDNw@mail.gmail.com>
	<CANrO4ianTLnFBtKxuhatwxg-A9oNK=pRG8WOh+mJ2sPusjrafw@mail.gmail.com>
Message-ID: <CAHjP37Es9XUACNbgFsUr4=X6OXgOcMjj_3CVA8yTnp2H1ADZvA@mail.gmail.com>

Let me rephrase -- most DBB usage is such that the DBB is live until all
things using it are.

On Wed, Dec 9, 2015 at 1:48 PM, Alexandre De Champeaux <adc at quartetfs.com>
wrote:

>
>
>> Ok, I buy that.  I can't help but wonder how DBB authors decided it's ok
>> to release it to the public like this though.  Granted, I can't think of a
>> (realistic) scenario where allocating a DBB that's immediately garbage is
>> normal.
>>
>
> I don't see why only DBB that are immediately garbage would be affected.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/52fd2ba2/attachment-0001.html>

From aph at redhat.com  Wed Dec  9 14:03:02 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 19:03:02 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
Message-ID: <56687AE6.4050205@redhat.com>

On 12/09/2015 06:52 PM, Vitaly Davidovich wrote:
>>
>> I don't think it'd be measurable.  A global volatile write is pretty
>> cheap.  And I'm sure there are several such writes when queuing a
>> finalizer.
> 
> 
>> The global volatile gets hit once, when the object is finalized.  Not
>> at every access, which is what you'd have to do with a compiler
>> barrier.
> 
> Perhaps I misunderstood your global volatile suggestion -- when is it
> written to exactly? What's the usage?

In the finalizer.  The idea is that you keep a counter in the
object and then write it to a global when finalized.  I don't
think this can be done much more cheaply without changes to
the compiler, and it's certainly much cheaper than the current
implementation of reachabilityFence.

Andrew.


From gil at azul.com  Wed Dec  9 14:07:37 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 19:07:37 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CANrO4ianTLnFBtKxuhatwxg-A9oNK=pRG8WOh+mJ2sPusjrafw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<33DC7CD3-DFFA-47A2-AAD4-452978CB89A0@azul.com>
	<CAHjP37G9Cft1HjmUHQ2DKsT-RmZpbgXbG1CNJruDmQ9y-s4jrQ@mail.gmail.com>
	<1C0B9FE4-43DF-4756-9036-E30FAEBEDB9C@azul.com>
	<CAHjP37F+CT_vP-4td_hPVvaazgm0uoN0BLwxi3TcOmW=GFz51A@mail.gmail.com>
	<F146697F-318E-4EDD-AD9A-44D424DEC130@azul.com>
	<CAHjP37FJNywnoPk0nMtBBCweHnjkrHQ6zBohXO5nKM3thaYDNw@mail.gmail.com>
	<CANrO4ianTLnFBtKxuhatwxg-A9oNK=pRG8WOh+mJ2sPusjrafw@mail.gmail.com>
Message-ID: <88DC34B8-2CBD-4CD4-BCF4-30C37E22F1DD@azul.com>


> On Dec 9, 2015, at 10:48 AM, Alexandre De Champeaux <adc at quartetfs.com> wrote:
> 
> 
> Ok, I buy that.  I can't help but wonder how DBB authors decided it's ok to release it to the public like this though.  Granted, I can't think of a (realistic) scenario where allocating a DBB that's immediately garbage is normal.
> 
> I don't see why only DBB that are immediately garbage would be affected.

Like Alexandre, the current bug-tripping scenario that keeps me up at night is not the strange allocate-and-immediate-garbage case, but the last-use case. As in the behavior of the last get or put into a buffer that has been around for a while. These last accesses currently race with the cleaner's execution, and can result in reading from or writing to free'd (and potentially already allocated elsewhere) memory.

I believe that the reason this is "rare" dynamically is that most DBB uses we run into make fairly static use of DBBs, either managing their internal contents themselves (in various off heap memory patterns) or using them as a long lasting communications buffer (in various io and JNI setups). These use cases usually contain the race's exposure to the rare end-of-life events of the DBB, which often coincide with the program's end-of-life. Basically, the likelihood of completing a GC and running the cleaner within the race window, coupled with the actual access to the freed memory causing some actual problem (a SEGV or bad data being read that actually affects the program's behavior) in these situations is not 0, but is "fairly low".

But then there are the applications that make heavy dynamic use of DBBs, allocating and releasing them constantly. I'm dealing with one such app that is doing this with multiple TB of DBB managed memory, in tons of little chunks that come and go all the time, and some significant GC pressure as well, and it's those sort of apps that IMO are currently exposed to the inherent last-use race in DBB.

? Gil.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/89e18762/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/89e18762/attachment.bin>

From gil at azul.com  Wed Dec  9 14:15:00 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 19:15:00 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56687248.5050104@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<56686258.5010707@redhat.com>
	<55A7821F-06AE-43BC-8ACE-96B13A310D95@azul.com>
	<56687248.5050104@redhat.com>
Message-ID: <98210DC3-0CE2-4836-8531-98EFFFC7FC03@azul.com>


> On Dec 9, 2015, at 10:26 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/09/2015 05:23 PM, Gil Tene wrote:
>> 
>>> On Dec 9, 2015, at 9:18 AM, Andrew Haley <aph at redhat.com> wrote:
>>> 
>>> On 12/09/2015 04:16 PM, Vitaly Davidovich wrote:
>>>>> 
>>>>> an implicit implication that 'this' must remain reachable until after the
>>>>> last instruction in each of its instance methods
>>>> 
>>>> Why wouldn't this work, at least as a compromise?
>>> 
>>> It would, but it would hurt performance because of increased register
>>> pressure.
>> 
>> Actually, it would only add a stack slot. And a spill into it if needed.
> 
> Hesitant as I am to argue with you, I'm not so sure.  There'd
> definitely have to be a USE in order to keep the oop alive, and C2
> would surely try not to spill the oop.  The USE would be at the end of
> every method.  Unless there's some sort of "sink" node in the ideal
> graph which keeps an oop alive but does not refill from a stack slot,
> and I don't think there is.

Well, this all depends on how it's actually implemented.

Implementations can vary from an opaque non-inlineable method call that takes the 'this'
ref as an argument, to ones that just maintain a USE on the exit paths that doesn't get
optimized away (and as you note may mislead/drive the register allocator to want to keep the
thing in a register), to ones that somehow eliminate the actual use and the wish to hold
it in a register for that use, but prevent the recycling of the virtual register and/or associated
stack slot.

What is minimally required is that the oop remain around in the frame, and for it to be
described in the oopmaps. Which is why I see the minimal cost as that stack slot and the
potential spill into it.

> Andrew.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/88d7a2e9/attachment.bin>

From vitalyd at gmail.com  Wed Dec  9 14:20:07 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 14:20:07 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56687AE6.4050205@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
Message-ID: <CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>

I don't see how this extends the lifetime of the object unless, at minimum,
you increment the counter at each operation where you want to extend the
lifetime.  And at this point, you may as well just stick
reachabilityFence(this) inside the finalizer then.

On Wed, Dec 9, 2015 at 2:03 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/09/2015 06:52 PM, Vitaly Davidovich wrote:
> >>
> >> I don't think it'd be measurable.  A global volatile write is pretty
> >> cheap.  And I'm sure there are several such writes when queuing a
> >> finalizer.
> >
> >
> >> The global volatile gets hit once, when the object is finalized.  Not
> >> at every access, which is what you'd have to do with a compiler
> >> barrier.
> >
> > Perhaps I misunderstood your global volatile suggestion -- when is it
> > written to exactly? What's the usage?
>
> In the finalizer.  The idea is that you keep a counter in the
> object and then write it to a global when finalized.  I don't
> think this can be done much more cheaply without changes to
> the compiler, and it's certainly much cheaper than the current
> implementation of reachabilityFence.
>
> Andrew.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/6174f03a/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 14:21:58 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 14:21:58 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566875A1.6000807@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
Message-ID: <CAHjP37GOaZaaxq4ngrvLWjiNRUQUCr+shrP2F45iqgr0RQDMhg@mail.gmail.com>

It may still be needed when you need to extend the lifetime of an object
you hold but that would otherwise be early reclaimable.  But that's a much
more minimal use case, which is why I said the advantage is that rF() would
be used in much fewer places.

On Wed, Dec 9, 2015 at 1:40 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/09/2015 05:53 PM, Gil Tene wrote:
>
> > My take on this would be to change the JLS and JVM spec to state
> > that 'this' remains reachable until after the last instruction of
> > every instance method. Period. This would basically equate to
> > placing an implicit reachability fence at all exist points of every
> > instance method (I.e. The equivalent of a try...finally). The "nice?
> > thing about such an implicit reachability fence is that it does not
> > really defeat any optimizations, as it only serves to extend the
> > lifetime of an oop (so potentially pressing slightly harder on the
> > register allocator). IMO this would auto-magically fix lots of
> > current rarely occurring bugs (like those on DBB, but also in user
> > code), and prevent many future ones.
>
> Mmmm.  That's what I said!  One other advantage to doing this
> automagically is that you won't get all these Java devs arguing about
> whether the reachabilityFence really was needed.
>
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/616a50b3/attachment-0001.html>

From gil at azul.com  Wed Dec  9 14:30:25 2015
From: gil at azul.com (Gil Tene)
Date: Wed, 9 Dec 2015 19:30:25 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566875A1.6000807@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
Message-ID: <0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>


> On Dec 9, 2015, at 10:40 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/09/2015 05:53 PM, Gil Tene wrote:
> 
>> My take on this would be to change the JLS and JVM spec to state
>> that 'this' remains reachable until after the last instruction of
>> every instance method. Period. This would basically equate to
>> placing an implicit reachability fence at all exist points of every
>> instance method (I.e. The equivalent of a try...finally). The "nice?
>> thing about such an implicit reachability fence is that it does not
>> really defeat any optimizations, as it only serves to extend the
>> lifetime of an oop (so potentially pressing slightly harder on the
>> register allocator). IMO this would auto-magically fix lots of
>> current rarely occurring bugs (like those on DBB, but also in user
>> code), and prevent many future ones.
> 
> Mmmm.  That's what I said!

So we agree. At least for classes with finalizers in them. But since what you said was:

> ? I have in the past argued that methods of classes with finalizers
> should automagically extend the lifetime of the "this" object.

And what I am saying is that ALL instance methods should have
this quality (not just the ones in classes with finalizers). We may still
have a gap (or maybe that gap is gone now).

My point is that this reachability race has nothing (specific) to do with
finalizers or finalization, and applies just as much to things that cannot
be easily detectable from a class's qualities (like having a finalizer).
Therefore any solution that only addresses finalizers seems insufficient.

> One other advantage to doing this
> automagically is that you won't get all these Java devs arguing about
> whether the reachabilityFence really was needed.

+1000.

I'd much prefer a language and JVM spec change, and a conservative
implementation that already applies that change in the meantime. It will
make current code "just work", and save us from a l lot of "your code
is bad, you misunderstood the promises of liveness on 'this', so it's your
fault, and you should fix your code with reachabilityFence" discussions.

Note that the ability to explicitly call reachabilityFence is still needed
elsewhere. probably in the places it was originally envisioned for. So
I'm not advocating for replacing it with implicit behavior, I'm arguing
for implementing both.


> 
> Andrew.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/b9284f26/attachment.bin>

From aph at redhat.com  Wed Dec  9 14:45:56 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 19:45:56 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <98210DC3-0CE2-4836-8531-98EFFFC7FC03@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F5C9.1070605@redhat.com>
	<CAHjP37Hb-8=b4Y8BXG1aw8moSeYXAnRr5FYV9EYhAn+6YG2GFw@mail.gmail.com>
	<66914214-E716-48FD-90D4-B644A7A76373@azul.com>
	<CAHjP37Hq11zNABH_8zHAF_qt=CXVaHiZEv9cSO8Xh7C+im0GeQ@mail.gmail.com>
	<CANrO4iZ6FFQxFimYVM9k1SK2aWjeBa6j3_fBT1MNGACKwpuzvQ@mail.gmail.com>
	<CAHjP37HM+0+v0XdtS-iRdWm9FZg1kmfE9KW61jJx8cX91y5xpA@mail.gmail.com>
	<2A9FDE08-5A2D-46B9-BD7D-AA9BC114BA50@azul.com>
	<CAHjP37Fp101FDJ26Xn8AQ9t8boJj6it5kP5gHOT9Ajx8GZG0OA@mail.gmail.com>
	<56686258.5010707@redhat.com>
	<55A7821F-06AE-43BC-8ACE-96B13A310D95@azul.com>
	<56687248.5050104@redhat.com>
	<98210DC3-0CE2-4836-8531-98EFFFC7FC03@azul.com>
Message-ID: <566884F4.20504@redhat.com>

On 12/09/2015 07:15 PM, Gil Tene wrote:

> Implementations can vary from an opaque non-inlineable method call
> that takes the 'this' ref as an argument, to ones that just maintain
> a USE on the exit paths that doesn't get optimized away (and as you
> note may mislead/drive the register allocator to want to keep the
> thing in a register), to ones that somehow eliminate the actual use
> and the wish to hold it in a register for that use, but prevent the
> recycling of the virtual register and/or associated stack slot.

Ah, okay, I think you're envisaging a much more major change to the
compiler than I was.  I can certainly see a way to do what you suggest
but it's a fair bit of work.

Andrew.

From aph at redhat.com  Wed Dec  9 14:51:55 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 19:51:55 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
Message-ID: <5668865B.2080903@redhat.com>

On 12/09/2015 07:20 PM, Vitaly Davidovich wrote:
> I don't see how this extends the lifetime of the object unless, at minimum,
> you increment the counter at each operation where you want to extend the
> lifetime. 

Yes, you do increment the counter at each operation.  There has to be
a use of the counter in the finalizer to keep it alive.  Thinking
about it some more though, even this may not be enough in the presence
of some very aggressive optimizations because there is no
happens-before relationship between the methods and the finalizer.

> And at this point, you may as well just stick
> reachabilityFence(this) inside the finalizer then.

Ummm, I don't understand this.

Andrew.

From aph at redhat.com  Wed Dec  9 15:06:02 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 20:06:02 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5668865B.2080903@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
	<5668865B.2080903@redhat.com>
Message-ID: <566889AA.3020104@redhat.com>

On 12/09/2015 07:51 PM, Andrew Haley wrote:
> On 12/09/2015 07:20 PM, Vitaly Davidovich wrote:
>> I don't see how this extends the lifetime of the object unless, at minimum,
>> you increment the counter at each operation where you want to extend the
>> lifetime. 
> 
> Yes, you do increment the counter at each operation.  There has to be
> a use of the counter in the finalizer to keep it alive.  Thinking
> about it some more though, even this may not be enough in the presence
> of some very aggressive optimizations because there is no
> happens-before relationship between the methods and the finalizer.

And without a fence there's nothing to stop the counter update
moving past the Unsafe operation.  So no, this won't really
work without at least a compiler barrier.

Andrew.



From aph at redhat.com  Wed Dec  9 15:08:43 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 20:08:43 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
Message-ID: <56688A4B.5000906@redhat.com>

On 12/09/2015 07:30 PM, Gil Tene wrote:
> 
>> On Dec 9, 2015, at 10:40 AM, Andrew Haley <aph at redhat.com> wrote:
>>
>> On 12/09/2015 05:53 PM, Gil Tene wrote:
>>
>>> My take on this would be to change the JLS and JVM spec to state
>>> that 'this' remains reachable until after the last instruction of
>>> every instance method. Period. This would basically equate to
>>> placing an implicit reachability fence at all exist points of every
>>> instance method (I.e. The equivalent of a try...finally). The "nice?
>>> thing about such an implicit reachability fence is that it does not
>>> really defeat any optimizations, as it only serves to extend the
>>> lifetime of an oop (so potentially pressing slightly harder on the
>>> register allocator). IMO this would auto-magically fix lots of
>>> current rarely occurring bugs (like those on DBB, but also in user
>>> code), and prevent many future ones.
>>
>> Mmmm.  That's what I said!
> 
> So we agree. At least for classes with finalizers in them. But since what you said was:
> 
>> ? I have in the past argued that methods of classes with finalizers
>> should automagically extend the lifetime of the "this" object.
> 
> And what I am saying is that ALL instance methods should have
> this quality (not just the ones in classes with finalizers). We may still
> have a gap (or maybe that gap is gone now).

Ah, yes we do.

> My point is that this reachability race has nothing (specific) to do with
> finalizers or finalization, and applies just as much to things that cannot
> be easily detectable from a class's qualities (like having a finalizer).
> Therefore any solution that only addresses finalizers seems insufficient.

Possibly so, yes, given that there is nothing special about "this".
I take your point.

What would this do to objects which don't escape?  I presume that
there would be no need to extend their lifetimes, and the usual
"as if" rule would apply.

Andrew.


From vitalyd at gmail.com  Wed Dec  9 15:36:40 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 15:36:40 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5668865B.2080903@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
	<5668865B.2080903@redhat.com>
Message-ID: <CAHjP37Gx7zP0MG4SppM9auaXqzQcYvPfnwm6brOMq1cGaZKYGA@mail.gmail.com>

>
> Yes, you do increment the counter at each operation.  There has to be
> a use of the counter in the finalizer to keep it alive.


Right, that's what I thought would need to happen, but then you made it
sound like only finalizer actually does something.  So here you have a
possible performance degradation ...


> Thinking about it some more though, even this may not be enough in the
> presence
> of some very aggressive optimizations because there is no
> happens-before relationship between the methods and the finalizer.


Yup, and that's why I said I doubt this even works.

Ummm, I don't understand this.


Before your clarification that counter is updated at each use, I was just
saying that if counter is only used inside finalizer then you may as well
just put reachabilityFence(this) in there.  In other words, if you had some
reason to believe that simply using some field of the object inside the
finalizer was sufficient, then rF(this) is just as good.  This is, of
course, incorrect but that's what I meant.


On Wed, Dec 9, 2015 at 2:51 PM, Andrew Haley <aph at redhat.com> wrote:

> On 12/09/2015 07:20 PM, Vitaly Davidovich wrote:
> > I don't see how this extends the lifetime of the object unless, at
> minimum,
> > you increment the counter at each operation where you want to extend the
> > lifetime.
>
> Yes, you do increment the counter at each operation.  There has to be
> a use of the counter in the finalizer to keep it alive.  Thinking
> about it some more though, even this may not be enough in the presence
> of some very aggressive optimizations because there is no
> happens-before relationship between the methods and the finalizer.
>
> > And at this point, you may as well just stick
> > reachabilityFence(this) inside the finalizer then.
>
> Ummm, I don't understand this.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/a5cc68b5/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 15:48:15 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 15:48:15 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56688A4B.5000906@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
Message-ID: <CAHjP37GWAMCmYy7BsoiwDG-fq90G3xzfZfqN_20OrSN4akvAPg@mail.gmail.com>

sent from my phone
On Dec 9, 2015 3:36 PM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 12/09/2015 07:30 PM, Gil Tene wrote:
> >
> >> On Dec 9, 2015, at 10:40 AM, Andrew Haley <aph at redhat.com> wrote:
> >>
> >> On 12/09/2015 05:53 PM, Gil Tene wrote:
> >>
> >>> My take on this would be to change the JLS and JVM spec to state
> >>> that 'this' remains reachable until after the last instruction of
> >>> every instance method. Period. This would basically equate to
> >>> placing an implicit reachability fence at all exist points of every
> >>> instance method (I.e. The equivalent of a try...finally). The "nice?
> >>> thing about such an implicit reachability fence is that it does not
> >>> really defeat any optimizations, as it only serves to extend the
> >>> lifetime of an oop (so potentially pressing slightly harder on the
> >>> register allocator). IMO this would auto-magically fix lots of
> >>> current rarely occurring bugs (like those on DBB, but also in user
> >>> code), and prevent many future ones.
> >>
> >> Mmmm.  That's what I said!
> >
> > So we agree. At least for classes with finalizers in them. But since
what you said was:
> >
> >> ? I have in the past argued that methods of classes with finalizers
> >> should automagically extend the lifetime of the "this" object.
> >
> > And what I am saying is that ALL instance methods should have
> > this quality (not just the ones in classes with finalizers). We may
still
> > have a gap (or maybe that gap is gone now).
>
> Ah, yes we do.
>
> > My point is that this reachability race has nothing (specific) to do
with
> > finalizers or finalization, and applies just as much to things that
cannot
> > be easily detectable from a class's qualities (like having a finalizer).
> > Therefore any solution that only addresses finalizers seems
insufficient.
>
> Possibly so, yes, given that there is nothing special about "this".
> I take your point.
>
> What would this do to objects which don't escape?  I presume that
> there would be no need to extend their lifetimes, and the usual
> "as if" rule would apply.

Hopefully EA is not impacted by this - it certainly shouldn't be.  I can't
immediately see a problem that this would present for EA purposes.

>
> Andrew.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/383add43/attachment.html>

From mr.chrisvest at gmail.com  Wed Dec  9 15:50:09 2015
From: mr.chrisvest at gmail.com (Chris Vest)
Date: Wed, 9 Dec 2015 21:50:09 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56687AE6.4050205@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
Message-ID: <94227A23-CC6E-48E6-84EC-63AE144F5CF8@gmail.com>

Even non-volatile writes can be scalability bottle-necks due to cache sloshing, even if you writing the same value every time.

We have a Page concept in Neo4j that, like DBB, has a raw pointer in a long field. However, we have too many of these objects for them to override finalize() - the associated companion objects would take up too much heap space - so they instead all reference a single object that when finalised will release all the native memory. Therefor special rules for objects with finalisers won't work for us. We also pull the native pointers out of these page objects, when working with the memory, because this is used in some of our hottest code and every indirection counts. So making instance methods keep the instance alive would only work because those places incidentally also have field references to the page objects. 

Our code works because we need to guard the memory accesses with locks on the page objects, which keeps them alive. However, I wouldn't be surprised to hear about uses for fast explicit reachability fences.

Chris

> On 9. dec. 2015, at 20.03, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/09/2015 06:52 PM, Vitaly Davidovich wrote:
>>> 
>>> I don't think it'd be measurable.  A global volatile write is pretty
>>> cheap.  And I'm sure there are several such writes when queuing a
>>> finalizer.
>> 
>> 
>>> The global volatile gets hit once, when the object is finalized.  Not
>>> at every access, which is what you'd have to do with a compiler
>>> barrier.
>> 
>> Perhaps I misunderstood your global volatile suggestion -- when is it
>> written to exactly? What's the usage?
> 
> In the finalizer.  The idea is that you keep a counter in the
> object and then write it to a global when finalized.  I don't
> think this can be done much more cheaply without changes to
> the compiler, and it's certainly much cheaper than the current
> implementation of reachabilityFence.
> 
> Andrew.
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Wed Dec  9 15:51:49 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 06:51:49 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
Message-ID: <089f01d132c3$6d519650$47f4c2f0$@net.au>

By having construction happen-before finalization, it ensures that if finalization happens after construction is complete then it will see all of the constructed values, even though they happened in a different thread. This is normal happens-before with regard to two synchronization actions ? but a construction is not a synchronization action it was special-cased.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly Davidovich
Sent: Thursday, December 10, 2015 1:36 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

sent from my phone
On Dec 9, 2015 6:11 AM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> Andrew Haley writes:
> > On 09/12/15 09:21, David Holmes wrote:
> >
> > > The happens-before requirement was deliberately set the way it is to
> > > show that an object can not be finalized before its construction has
> > > completed (whether normally or abnormally). So I would agree with
> > > Justin that it should not be possible for an object to be finalized
> > > before construction has completed - regardless of potential compiler
> > > optimizations etc.
> >
> > Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
> > but I don't think so.  Is there really a happens-before relationship
> > between a constructor of an object with no volatile or final fields
> > and its finalizer?
>
> My recollection - and I've been trying to find this in the JavaMemoryModel
> archives - is that the happens-before between constructor and finalizer was
> introduced because the normal "trick" of using synchronization was very
> counter-intuitive in constructors given the object has not been published.
>
> That said, A happens-before B simply establishes visibility/ordering rules
> for the case when A occurs before B. It says nothing about B occurring
> before A, or B and A overlapping. Other mechanisms have to force the
> temporal order. So it may be I misspoke my support of Justin's position. :(

I have a different interpretation, akin to your previous answer.  There's very little point in stating that ctor happens-before finalization if that's not even the case always (i.e. they overlap or occur in reverse order) - how would that be meaningful?

>
> David
> -----
>
>
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/d1e4bb23/attachment.html>

From vitalyd at gmail.com  Wed Dec  9 15:52:44 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 15:52:44 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <94227A23-CC6E-48E6-84EC-63AE144F5CF8@gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<94227A23-CC6E-48E6-84EC-63AE144F5CF8@gmail.com>
Message-ID: <CAHjP37Ep5pA4zYoZ5hEuNHV7aRgwA5==m7b5ki9t+4qd+vPKGQ@mail.gmail.com>

sent from my phone
On Dec 9, 2015 3:50 PM, "Chris Vest" <mr.chrisvest at gmail.com> wrote:
>
> Even non-volatile writes can be scalability bottle-necks due to cache
sloshing, even if you writing the same value every time.

Yup, this is just "fancy" false sharing.

>
> We have a Page concept in Neo4j that, like DBB, has a raw pointer in a
long field. However, we have too many of these objects for them to override
finalize() - the associated companion objects would take up too much heap
space - so they instead all reference a single object that when finalised
will release all the native memory. Therefor special rules for objects with
finalisers won't work for us. We also pull the native pointers out of these
page objects, when working with the memory, because this is used in some of
our hottest code and every indirection counts. So making instance methods
keep the instance alive would only work because those places incidentally
also have field references to the page objects.
>
> Our code works because we need to guard the memory accesses with locks on
the page objects, which keeps them alive. However, I wouldn't be surprised
to hear about uses for fast explicit reachability fences.
>
> Chris
>
> > On 9. dec. 2015, at 20.03, Andrew Haley <aph at redhat.com> wrote:
> >
> > On 12/09/2015 06:52 PM, Vitaly Davidovich wrote:
> >>>
> >>> I don't think it'd be measurable.  A global volatile write is pretty
> >>> cheap.  And I'm sure there are several such writes when queuing a
> >>> finalizer.
> >>
> >>
> >>> The global volatile gets hit once, when the object is finalized.  Not
> >>> at every access, which is what you'd have to do with a compiler
> >>> barrier.
> >>
> >> Perhaps I misunderstood your global volatile suggestion -- when is it
> >> written to exactly? What's the usage?
> >
> > In the finalizer.  The idea is that you keep a counter in the
> > object and then write it to a global when finalized.  I don't
> > think this can be done much more cheaply without changes to
> > the compiler, and it's certainly much cheaper than the current
> > implementation of reachabilityFence.
> >
> > Andrew.
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/5b2f8ee1/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 15:59:45 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 15:59:45 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <089f01d132c3$6d519650$47f4c2f0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c2f0$@net.au>
Message-ID: <CAHjP37HVNZrpQ1r9T-9eGpQF7OhoyfiC7S3rDh-XDLE8c6C9Dw@mail.gmail.com>

Yes, I understand the meaning of happens-before.  My point, however, is
that specifying things this way but not actually mandating that finalizer()
runs after all load/store operations in the constructor have occurred is
meaningless (and "hostile" towards developers) - it would be impossible to
reason reliably about anything in the finalizer.

On Wed, Dec 9, 2015 at 3:51 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> By having construction happen-before finalization, it ensures that if
> finalization happens after construction is complete then it will see all of
> the constructed values, even though they happened in a different thread.
> This is normal happens-before with regard to two synchronization actions ?
> but a construction is not a synchronization action it was special-cased.
>
>
>
> David
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Vitaly
> Davidovich
> *Sent:* Thursday, December 10, 2015 1:36 AM
> *To:* dholmes at ieee.org
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
> sent from my phone
>
> On Dec 9, 2015 6:11 AM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
> >
> > Andrew Haley writes:
> > > On 09/12/15 09:21, David Holmes wrote:
> > >
> > > > The happens-before requirement was deliberately set the way it is to
> > > > show that an object can not be finalized before its construction has
> > > > completed (whether normally or abnormally). So I would agree with
> > > > Justin that it should not be possible for an object to be finalized
> > > > before construction has completed - regardless of potential compiler
> > > > optimizations etc.
> > >
> > > Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
> > > but I don't think so.  Is there really a happens-before relationship
> > > between a constructor of an object with no volatile or final fields
> > > and its finalizer?
> >
> > My recollection - and I've been trying to find this in the
> JavaMemoryModel
> > archives - is that the happens-before between constructor and finalizer
> was
> > introduced because the normal "trick" of using synchronization was very
> > counter-intuitive in constructors given the object has not been
> published.
> >
> > That said, A happens-before B simply establishes visibility/ordering
> rules
> > for the case when A occurs before B. It says nothing about B occurring
> > before A, or B and A overlapping. Other mechanisms have to force the
> > temporal order. So it may be I misspoke my support of Justin's position.
> :(
>
> I have a different interpretation, akin to your previous answer.  There's
> very little point in stating that ctor happens-before finalization if
> that's not even the case always (i.e. they overlap or occur in reverse
> order) - how would that be meaningful?
>
> >
> > David
> > -----
> >
> >
> > > Andrew.
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/7300f172/attachment.html>

From aph at redhat.com  Wed Dec  9 16:01:22 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 9 Dec 2015 21:01:22 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Gx7zP0MG4SppM9auaXqzQcYvPfnwm6brOMq1cGaZKYGA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
	<5668865B.2080903@redhat.com>
	<CAHjP37Gx7zP0MG4SppM9auaXqzQcYvPfnwm6brOMq1cGaZKYGA@mail.gmail.com>
Message-ID: <566896A2.50602@redhat.com>

On 12/09/2015 08:36 PM, Vitaly Davidovich wrote:
>>
>> Yes, you do increment the counter at each operation.  There has to be
>> a use of the counter in the finalizer to keep it alive.
> 
> Right, that's what I thought would need to happen, but then you made it
> sound like only finalizer actually does something.  So here you have a
> possible performance degradation ...

Yes.  To be clear: I do not believe that a correct solution to
this problem which has no performance degradation is possible.
All we can do is minimize it.  With some fairly substantial
compiler work we can get pretty close.

Andrew.


From jsampson at guidewire.com  Wed Dec  9 16:26:50 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 9 Dec 2015 21:26:50 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <089f01d132c3$6d519650$47f4c2f0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c2f0$@net.au>
Message-ID: <DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> By having construction happen-before finalization, it ensures that
> if finalization happens after construction is complete then it
> will see all of the constructed values, even though they happened
> in a different thread. This is normal happens-before with regard
> to two synchronization actions ? but a construction is not a
> synchronization action it was special-cased.

Program order implies happens-before order within each thread. If
the completion the constructor happens-before the execution of the
finalizer, then every write in the constructor is visible to every
read in the finalizer, and no writes in the finalizer are visible to
any reads in the constructor. Therefore if the finalizer closes a
resource, the constructor can't see that resource as closed. Any
additional synchronization actions in either the constructor or the
finalizer have to be consistent with that happens-before ordering,
because happens-before is transitive. Right?

Cheers,
Justin


From davidcholmes at aapt.net.au  Wed Dec  9 16:33:51 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 07:33:51 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HVNZrpQ1r9T-9eGpQF7OhoyfiC7S3rDh-XDLE8c6C9Dw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f01d132c3$6d519650$47f4c
	2f0$@net.au>
	<CAHjP37HVNZrpQ1r9T-9eGpQF7OhoyfiC7S3rDh-XDLE8c6C9Dw@mail.gmail.com>
Message-ID: <08c501d132c9$4c4d1370$e4e73a50$@net.au>

No different to any other pair of synchronization actions. The JMM doesn?t enforce any temporal orderings.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly Davidovich
Sent: Thursday, December 10, 2015 7:00 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

Yes, I understand the meaning of happens-before.  My point, however, is that specifying things this way but not actually mandating that finalizer() runs after all load/store operations in the constructor have occurred is meaningless (and "hostile" towards developers) - it would be impossible to reason reliably about anything in the finalizer.

 

On Wed, Dec 9, 2015 at 3:51 PM, David Holmes <davidcholmes at aapt.net.au> wrote:

By having construction happen-before finalization, it ensures that if finalization happens after construction is complete then it will see all of the constructed values, even though they happened in a different thread. This is normal happens-before with regard to two synchronization actions ? but a construction is not a synchronization action it was special-cased.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vitaly Davidovich
Sent: Thursday, December 10, 2015 1:36 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

sent from my phone


On Dec 9, 2015 6:11 AM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> Andrew Haley writes:
> > On 09/12/15 09:21, David Holmes wrote:
> >
> > > The happens-before requirement was deliberately set the way it is to
> > > show that an object can not be finalized before its construction has
> > > completed (whether normally or abnormally). So I would agree with
> > > Justin that it should not be possible for an object to be finalized
> > > before construction has completed - regardless of potential compiler
> > > optimizations etc.
> >
> > Hmmm, okay.  It might be that I misremembered or perhaps it was a bug,
> > but I don't think so.  Is there really a happens-before relationship
> > between a constructor of an object with no volatile or final fields
> > and its finalizer?
>
> My recollection - and I've been trying to find this in the JavaMemoryModel
> archives - is that the happens-before between constructor and finalizer was
> introduced because the normal "trick" of using synchronization was very
> counter-intuitive in constructors given the object has not been published.
>
> That said, A happens-before B simply establishes visibility/ordering rules
> for the case when A occurs before B. It says nothing about B occurring
> before A, or B and A overlapping. Other mechanisms have to force the
> temporal order. So it may be I misspoke my support of Justin's position. :(

I have a different interpretation, akin to your previous answer.  There's very little point in stating that ctor happens-before finalization if that's not even the case always (i.e. they overlap or occur in reverse order) - how would that be meaningful?

>
> David
> -----
>
>
> > Andrew.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/2f4ebaf2/attachment-0001.html>

From jsampson at guidewire.com  Wed Dec  9 17:06:42 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 9 Dec 2015 22:06:42 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08c401d132c9$1d4261c0$57c72540$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c	2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
Message-ID: <DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> You are still assuming/expecting that happens-before enforces
> temporal ordering - it doesn't.
>
> If two actions are temporally ordered: A occurs before B; and the
> spec says there is a happens-before edge between A and B, then you
> know what B can expect to see with respect to A's actions. Nothing
> more, nothing less.

I didn't say anything about temporal ordering, so I'm not sure what
you're saying can happen. Forget about synchronization actions and
just think about reads and writes. Since the completion of the
constructor happens-before the execution of the finalizer, all
reads and writes in the constructor happen-before all reads and
writes in the finalizer, because happens-before is transitive and
program order implies happens-before order. What kind of execution
are you imagining that might be problematic?

Cheers,
Justin


From davidcholmes at aapt.net.au  Wed Dec  9 17:55:41 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 08:55:41 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f01d132c3$6d519650$47f4c
	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <08d001d132d4$bb3b3450$31b19cf0$@net.au>

Justin Sampson writes:
> David Holmes wrote:
> 
> > You are still assuming/expecting that happens-before enforces
> > temporal ordering - it doesn't.
> >
> > If two actions are temporally ordered: A occurs before B; and the
> > spec says there is a happens-before edge between A and B, then you
> > know what B can expect to see with respect to A's actions. Nothing
> > more, nothing less.
> 
> I didn't say anything about temporal ordering, so I'm not sure what
> you're saying can happen. Forget about synchronization actions and
> just think about reads and writes. Since the completion of the
> constructor happens-before the execution of the finalizer, all
> reads and writes in the constructor happen-before all reads and
> writes in the finalizer, because happens-before is transitive and
> program order implies happens-before order. What kind of execution
> are you imagining that might be problematic?

I think we may just be at cross purposes. All I'm saying is that the
existence of a happens-before edge does not imply any kind of temporal
ordering. So just because it is specified that completion of the constructor
happens-before execution of the finalizer (so the finalizer thread will see
writes from the constructor) it doesn't imply that the finalizer is not
permitted to execute until the constructor has completed. If the finalizer
runs concurrently with the constructor then the constructor may well see the
actions of the finalize method.

David
-----

 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jsampson at guidewire.com  Wed Dec  9 18:05:41 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 9 Dec 2015 23:05:41 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08d001d132d4$bb3b3450$31b19cf0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c		2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
Message-ID: <DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> If the finalizer runs concurrently with the constructor then the
> constructor may well see the actions of the finalize method.

Nope. For any read r inside the constructor and any write w inside
the finalizer, we know that hb(r, w), because hb(r, completion of
constructor) and hb(completion of constructor, execution of finalizer)
implies hb(r, execution of finalizer). But if r sees the value
written by w, then the execution is not happens-before consistent and
therefore it is not a well-formed execution according to the JMM.

Cheers,
Justin



From davidcholmes at aapt.net.au  Wed Dec  9 19:04:10 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 10:04:10 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f01d132c3$6d519650$47f4c
	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <08d401d132de$4c29ee80$e47dcb80$@net.au>

Justin,

You are right about the intent here. I just found what seems to be a major
error in the JLS in regards to JSR-133.  Here is the text that was supposed
to be included in the JLS update by JSR-133:

"An object cannot be considered finalizable until all of its constructors
have finished. The constructor for class Object must be invoked and complete
normally in order for the object to be finalizable; other
constructors may terminate by throwing exceptions."

http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf

But that isn't what it says in JLS 12.6.1!

David
-----

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Justin Sampson
> Sent: Thursday, December 10, 2015 9:06 AM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
> 
> David Holmes wrote:
> 
> > If the finalizer runs concurrently with the constructor then the
> > constructor may well see the actions of the finalize method.
> 
> Nope. For any read r inside the constructor and any write w inside
> the finalizer, we know that hb(r, w), because hb(r, completion of
> constructor) and hb(completion of constructor, execution of finalizer)
> implies hb(r, execution of finalizer). But if r sees the value
> written by w, then the execution is not happens-before consistent and
> therefore it is not a well-formed execution according to the JMM.
> 
> Cheers,
> Justin
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jsampson at guidewire.com  Wed Dec  9 20:14:07 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 10 Dec 2015 01:14:07 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08d401d132de$4c29ee80$e47dcb80$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c			2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
Message-ID: <DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> You are right about the intent here. I just found what seems to be
> a major error in the JLS in regards to JSR-133. Here is the text
> that was supposed to be included in the JLS update by JSR-133:
>
> "An object cannot be considered finalizable until all of its
> constructors have finished. The constructor for class Object must
> be invoked and complete normally in order for the object to be
> finalizable; other constructors may terminate by throwing
> exceptions."
>
> http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
>
> But that isn't what it says in JLS 12.6.1!

As you pointed out earlier, that's just talking about whether an
exception during construction prevents finalization. That PDF and
the JLS both agree that an object can't be finalized at all if its
capital-O Object constructor didn't complete normally.

The happens-before relationship is stated very explicitly, not once
but _twice_ in the JLS. It is stated in 12.6, as I quoted earlier,
and stated again in 17.4.5 as the second bullet point in the very
definition of happens-before itself! It's stated even earlier than
the fact that synchronizes-with also implies happens-before:

  "If we have two actions x and y, we write hb(x, y) to indicate
  that x happens-before y.

  * If x and y are actions of the same thread and x comes before y
    in program order, then hb(x, y).

  * There is a happens-before edge from the end of a constructor of
    an object to the start of a finalizer (?12.6) for that object.

  * If an action x synchronizes-with a following action y, then we
    also have hb(x, y).

  * If hb(x, y) and hb(y, z), then hb(x, z)."

https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5

In summary, we agree that an object can _become finalizable_ before
completion of its constructor, if the Object constructor completed
normally and the object is otherwise no longer reachable. But the
definition of happens-before makes it very clear that whenever the
finalizer _does_ run, it will see all writes from the remainder of
the constructor and none of its writes will be visible within the
constructor.

Cheers,
Justin


From vitalyd at gmail.com  Wed Dec  9 20:36:38 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 20:36:38 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <CAHjP37GnHhF=iV7rCEHCxSw0wL59G+=kk8TOeat8x1sjAq6iig@mail.gmail.com>

sent from my phone
On Dec 9, 2015 8:23 PM, "Justin Sampson" <jsampson at guidewire.com> wrote:
>
> David Holmes wrote:
>
> > You are right about the intent here. I just found what seems to be
> > a major error in the JLS in regards to JSR-133. Here is the text
> > that was supposed to be included in the JLS update by JSR-133:
> >
> > "An object cannot be considered finalizable until all of its
> > constructors have finished. The constructor for class Object must
> > be invoked and complete normally in order for the object to be
> > finalizable; other constructors may terminate by throwing
> > exceptions."
> >
> > http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
> >
> > But that isn't what it says in JLS 12.6.1!
>
> As you pointed out earlier, that's just talking about whether an
> exception during construction prevents finalization. That PDF and
> the JLS both agree that an object can't be finalized at all if its
> capital-O Object constructor didn't complete normally.
>
> The happens-before relationship is stated very explicitly, not once
> but _twice_ in the JLS. It is stated in 12.6, as I quoted earlier,
> and stated again in 17.4.5 as the second bullet point in the very
> definition of happens-before itself! It's stated even earlier than
> the fact that synchronizes-with also implies happens-before:
>
>   "If we have two actions x and y, we write hb(x, y) to indicate
>   that x happens-before y.
>
>   * If x and y are actions of the same thread and x comes before y
>     in program order, then hb(x, y).
>
>   * There is a happens-before edge from the end of a constructor of
>     an object to the start of a finalizer (?12.6) for that object.
>
>   * If an action x synchronizes-with a following action y, then we
>     also have hb(x, y).
>
>   * If hb(x, y) and hb(y, z), then hb(x, z)."
>
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5
>
> In summary, we agree that an object can _become finalizable_ before
> completion of its constructor, if the Object constructor completed
> normally and the object is otherwise no longer reachable. But the
> definition of happens-before makes it very clear that whenever the
> finalizer _does_ run, it will see all writes from the remainder of
> the constructor and none of its writes will be visible within the
> constructor.

What about reads in ctor though? Writes in finalizer should not happen -
before reads in ctor either.

>
> Cheers,
> Justin
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/55b57174/attachment.html>

From davidcholmes at aapt.net.au  Wed Dec  9 20:42:15 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 11:42:15 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f01d132c3$6d519650$47f4c
	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <08e701d132eb$ffdecd30$ff9c6790$@net.au>

Justin Sampson writes:
> 
> David Holmes wrote:
> 
> > You are right about the intent here. I just found what seems to be
> > a major error in the JLS in regards to JSR-133. Here is the text
> > that was supposed to be included in the JLS update by JSR-133:
> >
> > "An object cannot be considered finalizable until all of its
> > constructors have finished. The constructor for class Object must
> > be invoked and complete normally in order for the object to be
> > finalizable; other constructors may terminate by throwing
> > exceptions."
> >
> > http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
> >
> > But that isn't what it says in JLS 12.6.1!
> 
> As you pointed out earlier, that's just talking about whether an
> exception during construction prevents finalization. That PDF and
> the JLS both agree that an object can't be finalized at all if its
> capital-O Object constructor didn't complete normally.

You can argue that HB implies the temporal constraint even if the temporal
constraint is not explicitly part of the JLS. But the intent was that the
temporal constraint was clearly stated in the JLS. The key point being: 

"until _all_ of its constructors have finished".

That is what provides the temporal ordering - that finalize() can't start
execution until after construction is complete (normally or abnormally [as
long as Object constructor completed normally]).

If you go and read the JMM discussions from 2003/2004 you will see that the
temporal constraint is what was put in place first and then happens-before
added later to ensure the finalizer thread was guaranteed to see the
constructed object.

I don't know if Doug/Hans/Bill/Jeremy can shed any light on why the JLS was
not updated as expected, but I'd really like to know if they intended to
remove the temporal constraint, or whether they also thought the HB was
sufficient. But expecting JVM implementers to infer the need for the
temporal constraint based on one HB definition seems completely unrealistic
to me.

Cheers,
David

> The happens-before relationship is stated very explicitly, not once
> but _twice_ in the JLS. It is stated in 12.6, as I quoted earlier,
> and stated again in 17.4.5 as the second bullet point in the very
> definition of happens-before itself! It's stated even earlier than
> the fact that synchronizes-with also implies happens-before:
> 
>   "If we have two actions x and y, we write hb(x, y) to indicate
>   that x happens-before y.
> 
>   * If x and y are actions of the same thread and x comes before y
>     in program order, then hb(x, y).
> 
>   * There is a happens-before edge from the end of a constructor of
>     an object to the start of a finalizer (?12.6) for that object.
> 
>   * If an action x synchronizes-with a following action y, then we
>     also have hb(x, y).
> 
>   * If hb(x, y) and hb(y, z), then hb(x, z)."
> 
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-
> 17.4.5
> 
> In summary, we agree that an object can _become finalizable_ before
> completion of its constructor, if the Object constructor completed
> normally and the object is otherwise no longer reachable. But the
> definition of happens-before makes it very clear that whenever the
> finalizer _does_ run, it will see all writes from the remainder of
> the constructor and none of its writes will be visible within the
> constructor.
> 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From davidcholmes at aapt.net.au  Wed Dec  9 20:44:34 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 11:44:34 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f01d132c3$6d519650$47f4c
	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <08e801d132ec$52d7cc80$f8876580$@net.au>

To be clear, I missed this later assertion:

> In summary, we agree that an object can _become finalizable_ before
> completion of its constructor, if the Object constructor completed
> normally and the object is otherwise no longer reachable.

No! The object should not be able to become finalizable until after all its
constructors have completed, and then it becomes unreachable.

David
-----


> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Justin Sampson
> Sent: Thursday, December 10, 2015 11:14 AM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
> 
> David Holmes wrote:
> 
> > You are right about the intent here. I just found what seems to be
> > a major error in the JLS in regards to JSR-133. Here is the text
> > that was supposed to be included in the JLS update by JSR-133:
> >
> > "An object cannot be considered finalizable until all of its
> > constructors have finished. The constructor for class Object must
> > be invoked and complete normally in order for the object to be
> > finalizable; other constructors may terminate by throwing
> > exceptions."
> >
> > http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
> >
> > But that isn't what it says in JLS 12.6.1!
> 
> As you pointed out earlier, that's just talking about whether an
> exception during construction prevents finalization. That PDF and
> the JLS both agree that an object can't be finalized at all if its
> capital-O Object constructor didn't complete normally.
> 
> The happens-before relationship is stated very explicitly, not once
> but _twice_ in the JLS. It is stated in 12.6, as I quoted earlier,
> and stated again in 17.4.5 as the second bullet point in the very
> definition of happens-before itself! It's stated even earlier than
> the fact that synchronizes-with also implies happens-before:
> 
>   "If we have two actions x and y, we write hb(x, y) to indicate
>   that x happens-before y.
> 
>   * If x and y are actions of the same thread and x comes before y
>     in program order, then hb(x, y).
> 
>   * There is a happens-before edge from the end of a constructor of
>     an object to the start of a finalizer (?12.6) for that object.
> 
>   * If an action x synchronizes-with a following action y, then we
>     also have hb(x, y).
> 
>   * If hb(x, y) and hb(y, z), then hb(x, z)."
> 
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-
> 17.4.5
> 
> In summary, we agree that an object can _become finalizable_ before
> completion of its constructor, if the Object constructor completed
> normally and the object is otherwise no longer reachable. But the
> definition of happens-before makes it very clear that whenever the
> finalizer _does_ run, it will see all writes from the remainder of
> the constructor and none of its writes will be visible within the
> constructor.
> 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From vitalyd at gmail.com  Wed Dec  9 21:05:53 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 21:05:53 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08e701d132eb$ffdecd30$ff9c6790$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
Message-ID: <CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>

sent from my phone
On Dec 9, 2015 8:53 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> Justin Sampson writes:
> >
> > David Holmes wrote:
> >
> > > You are right about the intent here. I just found what seems to be
> > > a major error in the JLS in regards to JSR-133. Here is the text
> > > that was supposed to be included in the JLS update by JSR-133:
> > >
> > > "An object cannot be considered finalizable until all of its
> > > constructors have finished. The constructor for class Object must
> > > be invoked and complete normally in order for the object to be
> > > finalizable; other constructors may terminate by throwing
> > > exceptions."
> > >
> > > http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
> > >
> > > But that isn't what it says in JLS 12.6.1!
> >
> > As you pointed out earlier, that's just talking about whether an
> > exception during construction prevents finalization. That PDF and
> > the JLS both agree that an object can't be finalized at all if its
> > capital-O Object constructor didn't complete normally.
>
> You can argue that HB implies the temporal constraint even if the temporal
> constraint is not explicitly part of the JLS. But the intent was that the
> temporal constraint was clearly stated in the JLS. The key point being:
>
> "until _all_ of its constructors have finished".
>
> That is what provides the temporal ordering - that finalize() can't start
> execution until after construction is complete (normally or abnormally [as
> long as Object constructor completed normally]).
>
> If you go and read the JMM discussions from 2003/2004 you will see that
the
> temporal constraint is what was put in place first and then happens-before
> added later to ensure the finalizer thread was guaranteed to see the
> constructed object.
>
> I don't know if Doug/Hans/Bill/Jeremy can shed any light on why the JLS
was
> not updated as expected, but I'd really like to know if they intended to
> remove the temporal constraint, or whether they also thought the HB was
> sufficient. But expecting JVM implementers to infer the need for the
> temporal constraint based on one HB definition seems completely
unrealistic
> to me.

The sane and intuitive thing is to say all reads/writes in ctor
happen-before all reads/writes in finalizer.  That just about enforces the
temporal aspect but is also the model that all developers would intuit.

>
> Cheers,
> David
>
> > The happens-before relationship is stated very explicitly, not once
> > but _twice_ in the JLS. It is stated in 12.6, as I quoted earlier,
> > and stated again in 17.4.5 as the second bullet point in the very
> > definition of happens-before itself! It's stated even earlier than
> > the fact that synchronizes-with also implies happens-before:
> >
> >   "If we have two actions x and y, we write hb(x, y) to indicate
> >   that x happens-before y.
> >
> >   * If x and y are actions of the same thread and x comes before y
> >     in program order, then hb(x, y).
> >
> >   * There is a happens-before edge from the end of a constructor of
> >     an object to the start of a finalizer (?12.6) for that object.
> >
> >   * If an action x synchronizes-with a following action y, then we
> >     also have hb(x, y).
> >
> >   * If hb(x, y) and hb(y, z), then hb(x, z)."
> >
> > https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-
> > 17.4.5
> >
> > In summary, we agree that an object can _become finalizable_ before
> > completion of its constructor, if the Object constructor completed
> > normally and the object is otherwise no longer reachable. But the
> > definition of happens-before makes it very clear that whenever the
> > finalizer _does_ run, it will see all writes from the remainder of
> > the constructor and none of its writes will be visible within the
> > constructor.
> >
> > Cheers,
> > Justin
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/274fa8f1/attachment-0001.html>

From vitalyd at gmail.com  Wed Dec  9 21:10:32 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 21:10:32 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566896A2.50602@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com>
	<CAHjP37FGdfFtLT-LVanS9mB9Mgr16PCPkFnEF6mbDTix_teUyg@mail.gmail.com>
	<56687583.4060502@redhat.com>
	<CAHjP37E6mJ15+fggyMRAYnKDm1m=1nr+2GEhrsUPbZwLgSDwLg@mail.gmail.com>
	<56687AE6.4050205@redhat.com>
	<CAHjP37Gw738W+CrpV_8nta+kk+fWUJqemeyKdWu5qV-WXhVZFA@mail.gmail.com>
	<5668865B.2080903@redhat.com>
	<CAHjP37Gx7zP0MG4SppM9auaXqzQcYvPfnwm6brOMq1cGaZKYGA@mail.gmail.com>
	<566896A2.50602@redhat.com>
Message-ID: <CAHjP37E4z8zc85x42aMrbpgn1-su_XtnDNTwubKzciaDXTXnVw@mail.gmail.com>

sent from my phone
On Dec 9, 2015 4:01 PM, "Andrew Haley" <aph at redhat.com> wrote:
>
> On 12/09/2015 08:36 PM, Vitaly Davidovich wrote:
> >>
> >> Yes, you do increment the counter at each operation.  There has to be
> >> a use of the counter in the finalizer to keep it alive.
> >
> > Right, that's what I thought would need to happen, but then you made it
> > sound like only finalizer actually does something.  So here you have a
> > possible performance degradation ...
>
> Yes.  To be clear: I do not believe that a correct solution to
> this problem which has no performance degradation is possible.
> All we can do is minimize it.  With some fairly substantial
> compiler work we can get pretty close.

Stack slot and spilling the oop (and never reloading it of course) under
register pressure ought to be close to, if not, zero cost.  Of course the
compiler will need to be taught about this, but I don't see any serious
fundamental/technical impediments.

>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/7e84722b/attachment.html>

From gil at azul.com  Wed Dec  9 21:15:49 2015
From: gil at azul.com (Gil Tene)
Date: Thu, 10 Dec 2015 02:15:49 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56688A4B.5000906@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
Message-ID: <56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>


> On Dec 9, 2015, at 12:08 PM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/09/2015 07:30 PM, Gil Tene wrote:
>> 
>>> On Dec 9, 2015, at 10:40 AM, Andrew Haley <aph at redhat.com> wrote:
>>> 
>>> On 12/09/2015 05:53 PM, Gil Tene wrote:
>>> 
>>>> My take on this would be to change the JLS and JVM spec to state
>>>> that 'this' remains reachable until after the last instruction of
>>>> every instance method. Period. This would basically equate to
>>>> placing an implicit reachability fence at all exist points of every
>>>> instance method (I.e. The equivalent of a try...finally). The "nice?
>>>> thing about such an implicit reachability fence is that it does not
>>>> really defeat any optimizations, as it only serves to extend the
>>>> lifetime of an oop (so potentially pressing slightly harder on the
>>>> register allocator). IMO this would auto-magically fix lots of
>>>> current rarely occurring bugs (like those on DBB, but also in user
>>>> code), and prevent many future ones.
>>> 
>>> Mmmm.  That's what I said!
>> 
>> So we agree. At least for classes with finalizers in them. But since what you said was:
>> 
>>> ? I have in the past argued that methods of classes with finalizers
>>> should automagically extend the lifetime of the "this" object.
>> 
>> And what I am saying is that ALL instance methods should have
>> this quality (not just the ones in classes with finalizers). We may still
>> have a gap (or maybe that gap is gone now).
> 
> Ah, yes we do.
> 
>> My point is that this reachability race has nothing (specific) to do with
>> finalizers or finalization, and applies just as much to things that cannot
>> be easily detectable from a class's qualities (like having a finalizer).
>> Therefore any solution that only addresses finalizers seems insufficient.
> 
> Possibly so, yes, given that there is nothing special about "this".
> I take your point.

I actually do think that 'this' is special. And that the specific mishandling of
'this' by the current spec and implementations is responsible for a ton
of lurking races like the ones in DBB.get() and put(). Wile I see a separate
need for things like explicit reachability fences in other cases (not 'this'
related), I think for 'this' the fundamental problem can be stated this way:

"It is fundamentally surprising behavior for an instance to become
unreachable while code in one of its instance methods is still executing."

This is the root of all these current could-access-a-freed-buffer in DBB. It
is also the root of many simple finalizer issues (though not all). And it is
probably a common root for many patterns that access memory at
an address stored in a long field of an instance. Any solution where you
were going to use reachabilityFence(this) (as opposed to some other
field or local variable) is an indication of this problem.

Stopping this surprising behavior from happening would reliably eliminate
any freeing races with things accessed via private instance fields (e.g.
unsafe accesses to addresses stored in private long fields, or i/o access
via fds stored in private long fields, or other id-based access). And since
most of those things tend to be idiomatically kept private, the coverage
we'd get is pretty good.

Stopping the surprising behavior can simply be achieved by adhering
(and promising) something this:

"[regardless of other reachability] An object instance is reachable if
any code in any of its instance methods is executing".

This basically translates to "'this' remains reachable until after the last instruction
of each instance method."

It also means that an explicit reachability fence on 'this' will never be
needed. Explicit reachability fences will only make sense on fields or
local variables, but never on 'this'. So for

> What would this do to objects which don't escape?  I presume that
> there would be no need to extend their lifetimes, and the usual
> "as if" rule would apply.

I don't think this has any effect on escape analysis. By definition, EA cannot
apply to 'this' by definition within an instance method, simply because an
instance method never allocates 'this'. Outside of the instance method there
is no effect on EA because 'this' is not required to remain reachable beyond the
last instruction in any of its instance methods (including when they are inlined).

> 
> Andrew.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/a77a03f7/attachment.bin>

From jsampson at guidewire.com  Wed Dec  9 21:24:56 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 10 Dec 2015 02:24:56 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
Message-ID: <DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>

Vitaly Davidovich wrote:

> The sane and intuitive thing is to say all reads/writes in ctor
> happen-before all reads/writes in finalizer. That just about
> enforces the temporal aspect but is also the model that all
> developers would intuit.

That's exactly what the JLS says! Twice! It's central to the very
definition of the happens-before ordering that the completion of a
constructor happens-before the execution of a finalizer on the same
object. That means _nothing but_ the fact that all reads and writes
in the constructor happen-before all reads and writes in the
finalizer. It doesn't say "_if_ the finalizer _doesn't_ execute
concurrently with the constructor..." -- that would be meaningless,
because the whole point of defining the happens-before ordering is
to define the semantics of "concurrently." If one program action
happens-before another, then they are by definition _not_ concurrent
actions. Therefore the JLS explicitly states that no finalizer may
ever be executed concurrently with any constructor for the same
object. If by "temporal ordering" David means the order of actual
instructions on a physical processor, that's an implementation
detail -- all the JLS has to say is that the physical operation of
the program must behave _as if_ all of the above is true. If a JVM
does _not_ behave as if all of the above is true, then it is not
implementing the JLS correctly.

Cheers,
Justin


From vitalyd at gmail.com  Wed Dec  9 21:32:33 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 21:32:33 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>

I've seen happens-before defined as writes happen before reads and say
nothing about reads before writes or reads before reads.  All I'm saying is
that full clarity is warranted so we don't need to have debates like this.

sent from my phone
On Dec 9, 2015 9:24 PM, "Justin Sampson" <jsampson at guidewire.com> wrote:
>
> Vitaly Davidovich wrote:
>
> > The sane and intuitive thing is to say all reads/writes in ctor
> > happen-before all reads/writes in finalizer. That just about
> > enforces the temporal aspect but is also the model that all
> > developers would intuit.
>
> That's exactly what the JLS says! Twice! It's central to the very
> definition of the happens-before ordering that the completion of a
> constructor happens-before the execution of a finalizer on the same
> object. That means _nothing but_ the fact that all reads and writes
> in the constructor happen-before all reads and writes in the
> finalizer. It doesn't say "_if_ the finalizer _doesn't_ execute
> concurrently with the constructor..." -- that would be meaningless,
> because the whole point of defining the happens-before ordering is
> to define the semantics of "concurrently." If one program action
> happens-before another, then they are by definition _not_ concurrent
> actions. Therefore the JLS explicitly states that no finalizer may
> ever be executed concurrently with any constructor for the same
> object. If by "temporal ordering" David means the order of actual
> instructions on a physical processor, that's an implementation
> detail -- all the JLS has to say is that the physical operation of
> the program must behave _as if_ all of the above is true. If a JVM
> does _not_ behave as if all of the above is true, then it is not
> implementing the JLS correctly.
>
> Cheers,
> Justin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/d0950ee2/attachment.html>

From jsampson at guidewire.com  Wed Dec  9 21:54:38 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 10 Dec 2015 02:54:38 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>
Message-ID: <DM2PR0501MB87595DDD8F38CB927D8AA0FD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>

Vitaly Davidovich wrote:

> I've seen happens-before defined as writes happen before reads and
> say nothing about reads before writes or reads before reads. All
> I'm saying is that full clarity is warranted so we don't need to
> have debates like this.

"A set of actions A is happens-before consistent if for all reads r
in A, where W(r) is the write action seen by r, it is not the case
that either hb(r, W(r)) or that there exists a write w in A such
that w.v = r.v and hb(W(r), w) and hb(w, r)."

https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5

The prohibition of reads seeing writes that occur later in the
happens-before ordering is the very first clause ("it is not the
case that either hb(r, W(r)) or ...") of the definition of
happens-before consistency.

Cheers,
Justin


From vitalyd at gmail.com  Wed Dec  9 21:54:44 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 21:54:44 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
Message-ID: <CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>

So where do we go from here? If `this` will be extended to method end, that
would have implications for where rF() is needed (or not).

Who makes the call on this, no pun intended?

sent from my phone
On Dec 9, 2015 9:49 PM, "Gil Tene" <gil at azul.com> wrote:

>
> > On Dec 9, 2015, at 12:08 PM, Andrew Haley <aph at redhat.com> wrote:
> >
> > On 12/09/2015 07:30 PM, Gil Tene wrote:
> >>
> >>> On Dec 9, 2015, at 10:40 AM, Andrew Haley <aph at redhat.com> wrote:
> >>>
> >>> On 12/09/2015 05:53 PM, Gil Tene wrote:
> >>>
> >>>> My take on this would be to change the JLS and JVM spec to state
> >>>> that 'this' remains reachable until after the last instruction of
> >>>> every instance method. Period. This would basically equate to
> >>>> placing an implicit reachability fence at all exist points of every
> >>>> instance method (I.e. The equivalent of a try...finally). The "nice?
> >>>> thing about such an implicit reachability fence is that it does not
> >>>> really defeat any optimizations, as it only serves to extend the
> >>>> lifetime of an oop (so potentially pressing slightly harder on the
> >>>> register allocator). IMO this would auto-magically fix lots of
> >>>> current rarely occurring bugs (like those on DBB, but also in user
> >>>> code), and prevent many future ones.
> >>>
> >>> Mmmm.  That's what I said!
> >>
> >> So we agree. At least for classes with finalizers in them. But since
> what you said was:
> >>
> >>> ? I have in the past argued that methods of classes with finalizers
> >>> should automagically extend the lifetime of the "this" object.
> >>
> >> And what I am saying is that ALL instance methods should have
> >> this quality (not just the ones in classes with finalizers). We may
> still
> >> have a gap (or maybe that gap is gone now).
> >
> > Ah, yes we do.
> >
> >> My point is that this reachability race has nothing (specific) to do
> with
> >> finalizers or finalization, and applies just as much to things that
> cannot
> >> be easily detectable from a class's qualities (like having a finalizer).
> >> Therefore any solution that only addresses finalizers seems
> insufficient.
> >
> > Possibly so, yes, given that there is nothing special about "this".
> > I take your point.
>
> I actually do think that 'this' is special. And that the specific
> mishandling of
> 'this' by the current spec and implementations is responsible for a ton
> of lurking races like the ones in DBB.get() and put(). Wile I see a
> separate
> need for things like explicit reachability fences in other cases (not
> 'this'
> related), I think for 'this' the fundamental problem can be stated this
> way:
>
> "It is fundamentally surprising behavior for an instance to become
> unreachable while code in one of its instance methods is still executing."
>
> This is the root of all these current could-access-a-freed-buffer in DBB.
> It
> is also the root of many simple finalizer issues (though not all). And it
> is
> probably a common root for many patterns that access memory at
> an address stored in a long field of an instance. Any solution where you
> were going to use reachabilityFence(this) (as opposed to some other
> field or local variable) is an indication of this problem.
>
> Stopping this surprising behavior from happening would reliably eliminate
> any freeing races with things accessed via private instance fields (e.g.
> unsafe accesses to addresses stored in private long fields, or i/o access
> via fds stored in private long fields, or other id-based access). And since
> most of those things tend to be idiomatically kept private, the coverage
> we'd get is pretty good.
>
> Stopping the surprising behavior can simply be achieved by adhering
> (and promising) something this:
>
> "[regardless of other reachability] An object instance is reachable if
> any code in any of its instance methods is executing".
>
> This basically translates to "'this' remains reachable until after the
> last instruction
> of each instance method."
>
> It also means that an explicit reachability fence on 'this' will never be
> needed. Explicit reachability fences will only make sense on fields or
> local variables, but never on 'this'. So for
>
> > What would this do to objects which don't escape?  I presume that
> > there would be no need to extend their lifetimes, and the usual
> > "as if" rule would apply.
>
> I don't think this has any effect on escape analysis. By definition, EA
> cannot
> apply to 'this' by definition within an instance method, simply because an
> instance method never allocates 'this'. Outside of the instance method
> there
> is no effect on EA because 'this' is not required to remain reachable
> beyond the
> last instruction in any of its instance methods (including when they are
> inlined).
>
> >
> > Andrew.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/a10c25aa/attachment.html>

From davidcholmes at aapt.net.au  Wed Dec  9 22:37:34 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 13:37:34 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<DM2PR0501MB875EC17FAAC851EA
	7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e701d132eb$ffdecd30$ff9c6790$@net.au>	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <091c01d132fc$1c6f2b10$554d8130$@net.au>

As far as I am concerned a key part of the JMM requirements surrounding
finalization has been omitted from the JLS. You may argue that HB is all
that is necessary to establish the requirement that finalize() can not
execute until after construction has completed, but that is far from clear
and I would not expect any JVM implementor to deduce that based purely on
HB. To me that is somewhat akin to inferring that monitors must enforce
mutual exclusion by only knowing about the HB edges defined for monitor
actions.

As I've stated the temporal constraint came first, and the adding of HB was
almost an afterthought to tidy up the model.

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Justin Sampson
> Sent: Thursday, December 10, 2015 12:25 PM
> To: Vitaly Davidovich; dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
> 
> Vitaly Davidovich wrote:
> 
> > The sane and intuitive thing is to say all reads/writes in ctor
> > happen-before all reads/writes in finalizer. That just about
> > enforces the temporal aspect but is also the model that all
> > developers would intuit.
> 
> That's exactly what the JLS says! Twice! It's central to the very
> definition of the happens-before ordering that the completion of a
> constructor happens-before the execution of a finalizer on the same
> object. That means _nothing but_ the fact that all reads and writes
> in the constructor happen-before all reads and writes in the
> finalizer. It doesn't say "_if_ the finalizer _doesn't_ execute
> concurrently with the constructor..." -- that would be meaningless,
> because the whole point of defining the happens-before ordering is
> to define the semantics of "concurrently." If one program action
> happens-before another, then they are by definition _not_ concurrent
> actions. Therefore the JLS explicitly states that no finalizer may
> ever be executed concurrently with any constructor for the same
> object. If by "temporal ordering" David means the order of actual
> instructions on a physical processor, that's an implementation
> detail -- all the JLS has to say is that the physical operation of
> the program must behave _as if_ all of the above is true. If a JVM
> does _not_ behave as if all of the above is true, then it is not
> implementing the JLS correctly.
> 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From vitalyd at gmail.com  Wed Dec  9 23:15:02 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 9 Dec 2015 23:15:02 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB87595DDD8F38CB927D8AA0FD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>
	<DM2PR0501MB87595DDD8F38CB927D8AA0FD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <CAHjP37Esyc60_nD-MUG9HSB=91MubZvaQ3xOH+dR-YOu59vx3Q@mail.gmail.com>

This is trying to relate reads and writes that synchronize with each other,
it says nothing about independent reads and independent writes.  I'd like
finalization to be spec'd as all independent reads and writes happen after
constructor's independent reads and writes.  This is perhaps another way to
state the temporal nature, but JMM-ism aside, I firmly believe that's
people's expectation.

sent from my phone
On Dec 9, 2015 9:54 PM, "Justin Sampson" <jsampson at guidewire.com> wrote:

> Vitaly Davidovich wrote:
>
> > I've seen happens-before defined as writes happen before reads and
> > say nothing about reads before writes or reads before reads. All
> > I'm saying is that full clarity is warranted so we don't need to
> > have debates like this.
>
> "A set of actions A is happens-before consistent if for all reads r
> in A, where W(r) is the write action seen by r, it is not the case
> that either hb(r, W(r)) or that there exists a write w in A such
> that w.v = r.v and hb(W(r), w) and hb(w, r)."
>
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5
>
> The prohibition of reads seeing writes that occur later in the
> happens-before ordering is the very first clause ("it is not the
> case that either hb(r, W(r)) or ...") of the definition of
> happens-before consistency.
>
> Cheers,
> Justin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151209/7ca80bfc/attachment.html>

From gil at azul.com  Wed Dec  9 23:20:12 2015
From: gil at azul.com (Gil Tene)
Date: Thu, 10 Dec 2015 04:20:12 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <091c01d132fc$1c6f2b10$554d8130$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<DM2P!
	R0501MB875EC17FAAC851EA
	7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>,
	<091c01d132fc$1c6f2b10$554d8130$@net.au>
Message-ID: <0DE292CA-BF14-4740-AF84-7D9C6A2A520B@azul.com>

As I note elsewhere, I think the missing requirement is for instances to remain reachable as long as any of their instance methods are executing. Since that includes constructors, it would completely eliminate the whole constructor/finalizer ordering discussion without making it a HB or ordering thing.

Fixing just the constructors, and just for finalizers wouldn't be of much use. Most things that have a constructor/finalizer race issue would also have races with other instance methods, and for many finalizer race issues you can find an equivalent/similar cleaner (or other phantom/weak/soft ref) issue.

Sent from Gil's iPhone

> On Dec 9, 2015, at 7:59 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> As far as I am concerned a key part of the JMM requirements surrounding
> finalization has been omitted from the JLS. You may argue that HB is all
> that is necessary to establish the requirement that finalize() can not
> execute until after construction has completed, but that is far from clear
> and I would not expect any JVM implementor to deduce that based purely on
> HB. To me that is somewhat akin to inferring that monitors must enforce
> mutual exclusion by only knowing about the HB edges defined for monitor
> actions.
> 
> As I've stated the temporal constraint came first, and the adding of HB was
> almost an afterthought to tidy up the model.
> 
> David
> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
>> interest-bounces at cs.oswego.edu] On Behalf Of Justin Sampson
>> Sent: Thursday, December 10, 2015 12:25 PM
>> To: Vitaly Davidovich; dholmes at ieee.org
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] DirectByteBuffers and
>> reachabilityFence
>> 
>> Vitaly Davidovich wrote:
>> 
>>> The sane and intuitive thing is to say all reads/writes in ctor
>>> happen-before all reads/writes in finalizer. That just about
>>> enforces the temporal aspect but is also the model that all
>>> developers would intuit.
>> 
>> That's exactly what the JLS says! Twice! It's central to the very
>> definition of the happens-before ordering that the completion of a
>> constructor happens-before the execution of a finalizer on the same
>> object. That means _nothing but_ the fact that all reads and writes
>> in the constructor happen-before all reads and writes in the
>> finalizer. It doesn't say "_if_ the finalizer _doesn't_ execute
>> concurrently with the constructor..." -- that would be meaningless,
>> because the whole point of defining the happens-before ordering is
>> to define the semantics of "concurrently." If one program action
>> happens-before another, then they are by definition _not_ concurrent
>> actions. Therefore the JLS explicitly states that no finalizer may
>> ever be executed concurrently with any constructor for the same
>> object. If by "temporal ordering" David means the order of actual
>> instructions on a physical processor, that's an implementation
>> detail -- all the JLS has to say is that the physical operation of
>> the program must behave _as if_ all of the above is true. If a JVM
>> does _not_ behave as if all of the above is true, then it is not
>> implementing the JLS correctly.
>> 
>> Cheers,
>> Justin
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jsampson at guidewire.com  Thu Dec 10 00:40:51 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 10 Dec 2015 05:40:51 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37Esyc60_nD-MUG9HSB=91MubZvaQ3xOH+dR-YOu59vx3Q@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>
	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>
	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>
	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>
	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>
	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e701d132eb$ffdecd30$ff9c6790$@net.au>
	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>
	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>
	<DM2PR0501MB87595DDD8F38CB927D8AA0FD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<CAHjP37Esyc60_nD-MUG9HSB=91MubZvaQ3xOH+dR-YOu59vx3Q@mail.gmail.com>
Message-ID: <DM2PR0501MB875E54556B70CC7B1DC8A45D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote: "To me that is somewhat akin to inferring that
monitors must enforce mutual exclusion by only knowing about the HB
edges defined for monitor actions."

And Vitaly Davidovich wrote: "This is trying to relate reads and
writes that synchronize with each other, it says nothing about
independent reads and independent writes."

Interesting. You both seem to be associating happens-before with
synchronization more strongly than is warranted by the JMM. The
happens-before order is more fundamental than the synchronization
order, right? Synchronization _implies_ happens-before, but not the
other way around. So _of course_ you can't infer mutual exclusion
from happens-before, because the implication is going in the other
direction.

Synchronization is _one_ of the things that determines
happens-before, but not the only thing. Happens-before doesn't imply
synchronization, but it _does_ imply visibility -- and the lack
thereof. Indeed, that is its only purpose! The only way that the
happens-before order relates to the definition of well-formed
executions is the notion of happens-before consistency, which
governs the visibility relationship between any reads and writes
that are connected by the happens-before order -- _not_ only reads
and writes that "synchronize with each other," but _all_ reads and
writes that are transitively connected by _any_ happens-before
edges, whether due to synchronization or due to other parts of the
specification -- including (once again) the very explicit inclusion
of a happens-before edge from the completion of a constructor to the
execution of a finalizer.

If the inclusion of such a rule right there in the bulleted list
that defines happens-before in 17.4.5 isn't enough for JVM
implementers to actually implement it, how can we possibly rely on
the specification for anything else?

Cheers,
Justin


From davidcholmes at aapt.net.au  Thu Dec 10 01:36:22 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 10 Dec 2015 16:36:22 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875E54556B70CC7B1DC8A45D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<CAHjP37FPep+E-tdAH3kymRmEGj1pJYEdZSAufbgYqn-wqFFb6w@mail.gmail.com>	<CANrO4ib03-n4K+Vw6zkATBJTz6_Y-J--dhd7d7J8E3jVLzAqcA@mail.gmail.com>	<CAHjP37FFaA6xceOnHR_iC1ZNASMoPemJEk8d_quidXUg9a1mkA@mail.gmail.com>	<CANrO4iZBsnsw6ruVRcEzupZG3e-KAP15=_89pEOFPwrV15Sauw@mail.gmail.com>	<CAHjP37Fwvvx12zPi5vkHtn4wTo+Oeam56EpAv2UinvGO5XVcKg@mail.gmail.com>	<CANrO4iYcyc5AOGJsLNDfFihHhvbj6q094KNcsU_-s8cTB9kKtg@mail.gmail.com>	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>	<5666A7A3.2070505@redhat.com>	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<DM2PR0501MB875EC17FAAC851EA
	7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e701d132eb$ffdecd30$ff9c6790$@net.au>	<CAHjP37FtOMCq8UdsH0-GC0J3xKLdGQCyfR1tXFh52SRPEXG1kw@mail.gmail.com>	<DM2PR0501MB875BA0DE525E7AD58243B8DD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<CAHjP37HvaJcsj83HfwNXQ4gyU7T5zur0f40R_MbLwceOLxpxkQ@mail.gmail.com>	<DM2PR0501MB87595DDD8F38CB927D8AA0FD1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<CAHjP37Esyc60_nD-MUG9HSB=91MubZvaQ3xOH+dR-YOu59vx3Q@mail.gmail.com>
	<DM2PR0501MB875E54556B70CC7B1DC8A45D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <092f01d13315$1679dcf0$436d96d0$@net.au>

Justin Sampson writes:
> 
> David Holmes wrote: "To me that is somewhat akin to inferring that
> monitors must enforce mutual exclusion by only knowing about the HB
> edges defined for monitor actions."
> 
> And Vitaly Davidovich wrote: "This is trying to relate reads and
> writes that synchronize with each other, it says nothing about
> independent reads and independent writes."
> 
> Interesting. You both seem to be associating happens-before with
> synchronization more strongly than is warranted by the JMM. The
> happens-before order is more fundamental than the synchronization
> order, right? Synchronization _implies_ happens-before, but not the
> other way around. So _of course_ you can't infer mutual exclusion
> from happens-before, because the implication is going in the other
> direction.

You've completely missed my point. So at this point I give up.

> Synchronization is _one_ of the things that determines
> happens-before, but not the only thing. Happens-before doesn't imply
> synchronization, but it _does_ imply visibility -- and the lack
> thereof. Indeed, that is its only purpose! The only way that the
> happens-before order relates to the definition of well-formed
> executions is the notion of happens-before consistency, which
> governs the visibility relationship between any reads and writes
> that are connected by the happens-before order -- _not_ only reads
> and writes that "synchronize with each other," but _all_ reads and
> writes that are transitively connected by _any_ happens-before
> edges, whether due to synchronization or due to other parts of the
> specification -- including (once again) the very explicit inclusion
> of a happens-before edge from the completion of a constructor to the
> execution of a finalizer.
> 
> If the inclusion of such a rule right there in the bulleted list
> that defines happens-before in 17.4.5 isn't enough for JVM
> implementers to actually implement it, how can we possibly rely on
> the specification for anything else?

I still maintain that the requirement that an object does not become
finalizable until after its constructors complete, would not jump out of
that rule. Especially when the spec clearly states the object can be
finalizable after Object's constructor completes! Why would anyone read
deeper into the HB rule to see if it contradicts the other statement. If you
think you would then good for you.

David
-----

 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aph at redhat.com  Thu Dec 10 04:28:22 2015
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Dec 2015 09:28:22 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
Message-ID: <566945B6.8010907@redhat.com>

On 10/12/15 02:15, Gil Tene wrote:
> 
> I actually do think that 'this' is special. And that the specific
> mishandling of 'this' by the current spec and implementations is
> responsible for a ton of lurking races like the ones in DBB.get()
> and put(). Wile I see a separate need for things like explicit
> reachability fences in other cases (not 'this' related), I think for
> 'this' the fundamental problem can be stated this way:
> 
> "It is fundamentally surprising behavior for an instance to become
> unreachable while code in one of its instance methods is still
> executing."

What, though, is your justification for such a statement?  Is it
simply to make the specification align with intuitive reasoning?  I'm
not saying that alignment with intuition is a bad thing, but as far as
I can see that's all it is.

> This is the root of all these current could-access-a-freed-buffer in
> DBB. It is also the root of many simple finalizer issues (though not
> all). And it is probably a common root for many patterns that access
> memory at an address stored in a long field of an instance. Any
> solution where you were going to use reachabilityFence(this) (as
> opposed to some other field or local variable) is an indication of
> this problem.

That's certainly true.

Andrew.

From aph at redhat.com  Thu Dec 10 04:38:29 2015
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Dec 2015 09:38:29 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
	<CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>
Message-ID: <56694815.4080104@redhat.com>

On 10/12/15 02:54, Vitaly Davidovich wrote:
> So where do we go from here? If `this` will be extended to method end, that
> would have implications for where rF() is needed (or not).
> 
> Who makes the call on this, no pun intended?

Ultimately, the JCP.  But I warn you now: we have had this exact
argument several times before, and it's always gone the same way.
reachabilityFence is the best hope we have.

Andrew.

From dl at cs.oswego.edu  Thu Dec 10 07:45:55 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 10 Dec 2015 07:45:55 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08d401d132de$4c29ee80$e47dcb80$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com> <07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com> <080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c 2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
Message-ID: <56697403.4080507@cs.oswego.edu>

On 12/09/2015 07:04 PM, David Holmes wrote:

> I just found what seems to be a major
> error in the JLS in regards to JSR-133.  Here is the text that was supposed
> to be included in the JLS update by JSR-133:
>
> "An object cannot be considered finalizable until all of its constructors
> have finished. The constructor for class Object must be invoked and complete
> normally in order for the object to be finalizable; other
> constructors may terminate by throwing exceptions."
>
> http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf
>
> But that isn't what it says in JLS 12.6.1!
>

> I don't know if Doug/Hans/Bill/Jeremy can shed any light on why the JLS was
> not updated as expected, but I'd really like to know if they intended to
> remove the temporal constraint, or whether they also thought the HB was
> sufficient.

Several "editorial improvements" were made (by Gilad Bracha and/or
others) when JSR133 text was incorporated into JLS. Plus some glitches
that might just be latex->framemaker conversion breakage. Some still
remain, and are on to-do list when JMM is substantively revised.

It could be the case that whoever did this incorporation made
the same inference as Justin about the intended cases already
being implicitly covered. Or it could just be an editorial slip.
In either case, it should be among follow-up JLS clarifications.

-Doug


From vitalyd at gmail.com  Thu Dec 10 07:51:46 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 10 Dec 2015 07:51:46 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56694815.4080104@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<CAHjP37Gy=j-9a5CMZL4JgX87QOzze5XcN_cVhK69_GtTHGwj1A@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
	<CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>
	<56694815.4080104@redhat.com>
Message-ID: <CAHjP37EfedZR1_71-MjOR5QqnybG9xmxqb=KHKOLGCn3tZOsJQ@mail.gmail.com>

I can see a few reasons against extending `this` lifetime at this stage of
java's life, but what were the objections last time(s) this came up?

sent from my phone
On Dec 10, 2015 4:38 AM, "Andrew Haley" <aph at redhat.com> wrote:

> On 10/12/15 02:54, Vitaly Davidovich wrote:
> > So where do we go from here? If `this` will be extended to method end,
> that
> > would have implications for where rF() is needed (or not).
> >
> > Who makes the call on this, no pun intended?
>
> Ultimately, the JCP.  But I warn you now: we have had this exact
> argument several times before, and it's always gone the same way.
> reachabilityFence is the best hope we have.
>
> Andrew.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/82d62095/attachment-0001.html>

From aph at redhat.com  Thu Dec 10 07:56:30 2015
From: aph at redhat.com (Andrew Haley)
Date: Thu, 10 Dec 2015 12:56:30 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37EfedZR1_71-MjOR5QqnybG9xmxqb=KHKOLGCn3tZOsJQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
	<CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>
	<56694815.4080104@redhat.com>
	<CAHjP37EfedZR1_71-MjOR5QqnybG9xmxqb=KHKOLGCn3tZOsJQ@mail.gmail.com>
Message-ID: <5669767E.40001@redhat.com>

On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> I can see a few reasons against extending `this` lifetime at this stage of
> java's life, but what were the objections last time(s) this came up?

Basically twofold.  Mostly efficiency, but also a reluctance to change
long-settled language semantics.  Making changes to something as
fundamental as this is always much tricker than people expect.  The
great advantage of reachabilityFence is that we can do it without a
lot of complex argument and politics.

Andrew.


From david.lloyd at redhat.com  Thu Dec 10 12:09:16 2015
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Thu, 10 Dec 2015 11:09:16 -0600
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08e801d132ec$52d7cc80$f8876580$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com> <07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com> <080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f! 01d132c3$6d519650$47f4c 2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>
Message-ID: <5669B1BC.7000406@redhat.com>

On 12/09/2015 07:44 PM, David Holmes wrote:
> To be clear, I missed this later assertion:
>
>> In summary, we agree that an object can _become finalizable_ before
>> completion of its constructor, if the Object constructor completed
>> normally and the object is otherwise no longer reachable.
>
> No! The object should not be able to become finalizable until after all its
> constructors have completed, and then it becomes unreachable.

Is this your view of the existing world, or what you are proposing be 
changed?  I'm losing track of what's what in this discussion. :-)

-- 
- DML

From jason_mehrens at hotmail.com  Thu Dec 10 13:26:40 2015
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu, 10 Dec 2015 18:26:40 +0000
Subject: [concurrency-interest] Enhance TimeoutException to include more
	details
Message-ID: <BN4PR13MB059403FE2D11E4D214316EEA83E90@BN4PR13MB0594.namprd13.prod.outlook.com>

Hello Concurrency-interest,

A lot of the synchronizers included in jsr166 that throw TimeoutException do not include the information that is useful to know when such an event occurs. I'm assuming that performance, keeping the code simple, and not crippling evolution of the code are the main drivers for the way it is today.

With those goals in mind, could TimeoutException be modified to include:
1. Information about the timeout value with a time unit mapped to getMessage().
2. A cause Throwable that contained the current stacktrace of the 'owner' thread (ASQ.getExclusiveOwnerThread().getStackTrace()).
3. Suppressed exceptions that contained all of the threads waiting to acquire (ASQ.getQueuedThreads())


For example, if take a FutureTask with 4 threads:
1. A thread calls FutureTask.run
2. Two threads call FutureTask.get.
3. One thread calls FutureTask.get(1, SECONDS) and logs the timeout.


To convert the stacktraces to a Throwable I abused the IllegalStateException for a proof of concept (no security manager).
The timeout could be described using the following (hopefully the formatting works).

=================================================================================
java.util.concurrent.TimeoutException: 1 SECONDS
?? ?at java.util.concurrent.FutureTask.get(FutureTask.java:205)
?? ?at TimeoutExampleOutput.testFutureTask(TimeoutExampleOutput.java:46)
?? ?at TimeoutExampleOutput.main(TimeoutExampleOutput.java:12)
?? ?Suppressed: java.lang.IllegalStateException: [14-WAITING-Thread[pool-1-thread-2,5,main]]
?? ??? ?at sun.misc.Unsafe.park(Native Method)
?? ??? ?at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
?? ??? ?at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
?? ??? ?at java.util.concurrent.FutureTask.get(FutureTask.java:191)
?? ??? ?at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
?? ??? ?at java.lang.Thread.run(Thread.java:745)
?? ?Suppressed: java.lang.IllegalStateException: [15-WAITING-Thread[pool-1-thread-3,5,main]]
?? ??? ?at sun.misc.Unsafe.park(Native Method)
?? ??? ?at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
?? ??? ?at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
?? ??? ?at java.util.concurrent.FutureTask.get(FutureTask.java:191)
?? ??? ?at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
?? ??? ?at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: [13-TIMED_WAITING-Thread[pool-1-thread-1,5,main]]
?? ?at java.lang.Thread.sleep(Native Method)
?? ?at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:19)
?? ?at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:16)
?? ?at java.util.concurrent.FutureTask.run(FutureTask.java:266)
?? ?at java.lang.Thread.run(Thread.java:745)
==================================================================================

The state of all 4 threads is described in this one failure.  You can see that this thread timed out was caused by the worker taking a nap and everyone else is being held up because of it.

I would assume there is a way to capture some of this state in TimeoutException and then delay the evaluation of that state until some TimeoutException method is called like getCause or getMessage and retain most of the performance goals.  Or perhaps adding a method to TimeoutException to opt into this information.

Any thoughts on this?

Regards,

Jason


From davidcholmes at aapt.net.au  Thu Dec 10 16:06:15 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 11 Dec 2015 07:06:15 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5669B1BC.7000406@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f!
	01d132c3$6d519650$47f4c
	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e801d132ec$52d7cc80$f8876580$@net.au>
	<5669B1BC.7000406@redhat.com>
Message-ID: <002101d1338e$9b828590$d28790b0$@net.au>

David M. Lloyd writes:
> 
> On 12/09/2015 07:44 PM, David Holmes wrote:
> > To be clear, I missed this later assertion:
> >
> >> In summary, we agree that an object can _become finalizable_ before
> >> completion of its constructor, if the Object constructor completed
> >> normally and the object is otherwise no longer reachable.
> >
> > No! The object should not be able to become finalizable until after
> all its
> > constructors have completed, and then it becomes unreachable.
> 
> Is this your view of the existing world, or what you are proposing be
> changed?  I'm losing track of what's what in this discussion. :-)

This is how the existing world should have been if the JLS update had not
been snafu'd. Justin would argue it should be the current state regardless
due to happens-before definition. Regardless the JVM does not currently
implement this.

David H.

 
> --
> - DML
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Thu Dec 10 16:19:03 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 11 Dec 2015 07:19:03 +1000
Subject: [concurrency-interest] Enhance TimeoutException to include
	more	details
In-Reply-To: <BN4PR13MB059403FE2D11E4D214316EEA83E90@BN4PR13MB0594.namprd13.prod.outlook.com>
References: <BN4PR13MB059403FE2D11E4D214316EEA83E90@BN4PR13MB0594.namprd13.prod.outlook.com>
Message-ID: <002501d13390$65a897f0$30f9c7d0$@net.au>

Hi Jason,

What you propose is a diagnostic capability which is way beyond what a
simple exception should be involved in. It simply isn't the role of
TimeoutException to try and expose all that.

How hard is it to gather that information when you detect the
TimeoutException? There are a couple of API's that could be used.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Jason Mehrens
> Sent: Friday, December 11, 2015 4:27 AM
> To: concurrency-interest
> Subject: [concurrency-interest] Enhance TimeoutException to include
> more details
> 
> Hello Concurrency-interest,
> 
> A lot of the synchronizers included in jsr166 that throw
> TimeoutException do not include the information that is useful to know
> when such an event occurs. I'm assuming that performance, keeping the
> code simple, and not crippling evolution of the code are the main
> drivers for the way it is today.
> 
> With those goals in mind, could TimeoutException be modified to
> include:
> 1. Information about the timeout value with a time unit mapped to
> getMessage().
> 2. A cause Throwable that contained the current stacktrace of the
> 'owner' thread (ASQ.getExclusiveOwnerThread().getStackTrace()).
> 3. Suppressed exceptions that contained all of the threads waiting to
> acquire (ASQ.getQueuedThreads())
> 
> 
> For example, if take a FutureTask with 4 threads:
> 1. A thread calls FutureTask.run
> 2. Two threads call FutureTask.get.
> 3. One thread calls FutureTask.get(1, SECONDS) and logs the timeout.
> 
> 
> To convert the stacktraces to a Throwable I abused the
> IllegalStateException for a proof of concept (no security manager).
> The timeout could be described using the following (hopefully the
> formatting works).
> 
> =======================================================================
> ==========
> java.util.concurrent.TimeoutException: 1 SECONDS
> ?? ?at java.util.concurrent.FutureTask.get(FutureTask.java:205)
> ?? ?at
> TimeoutExampleOutput.testFutureTask(TimeoutExampleOutput.java:46)
> ?? ?at TimeoutExampleOutput.main(TimeoutExampleOutput.java:12)
> ?? ?Suppressed: java.lang.IllegalStateException: [14-WAITING-
> Thread[pool-1-thread-2,5,main]]
> ?? ??? ?at sun.misc.Unsafe.park(Native Method)
> ?? ??? ?at
> java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
> ?? ??? ?at
> java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
> ?? ??? ?at java.util.concurrent.FutureTask.get(FutureTask.java:191)
> ?? ??? ?at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
> ?? ??? ?at java.lang.Thread.run(Thread.java:745)
> ?? ?Suppressed: java.lang.IllegalStateException: [15-WAITING-
> Thread[pool-1-thread-3,5,main]]
> ?? ??? ?at sun.misc.Unsafe.park(Native Method)
> ?? ??? ?at
> java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
> ?? ??? ?at
> java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
> ?? ??? ?at java.util.concurrent.FutureTask.get(FutureTask.java:191)
> ?? ??? ?at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
> ?? ??? ?at java.lang.Thread.run(Thread.java:745)
> Caused by: java.lang.IllegalStateException: [13-TIMED_WAITING-
> Thread[pool-1-thread-1,5,main]]
> ?? ?at java.lang.Thread.sleep(Native Method)
> ?? ?at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:19)
> ?? ?at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:16)
> ?? ?at java.util.concurrent.FutureTask.run(FutureTask.java:266)
> ?? ?at java.lang.Thread.run(Thread.java:745)
> =======================================================================
> ===========
> 
> The state of all 4 threads is described in this one failure.  You can
> see that this thread timed out was caused by the worker taking a nap
> and everyone else is being held up because of it.
> 
> I would assume there is a way to capture some of this state in
> TimeoutException and then delay the evaluation of that state until some
> TimeoutException method is called like getCause or getMessage and
> retain most of the performance goals.  Or perhaps adding a method to
> TimeoutException to opt into this information.
> 
> Any thoughts on this?
> 
> Regards,
> 
> Jason
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From vitalyd at gmail.com  Thu Dec 10 18:19:08 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 10 Dec 2015 18:19:08 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <002101d1338e$9b828590$d28790b0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>
	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
Message-ID: <CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim1DQG=51UQ@mail.gmail.com>

sent from my phone
On Dec 10, 2015 4:36 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> David M. Lloyd writes:
> >
> > On 12/09/2015 07:44 PM, David Holmes wrote:
> > > To be clear, I missed this later assertion:
> > >
> > >> In summary, we agree that an object can _become finalizable_ before
> > >> completion of its constructor, if the Object constructor completed
> > >> normally and the object is otherwise no longer reachable.
> > >
> > > No! The object should not be able to become finalizable until after
> > all its
> > > constructors have completed, and then it becomes unreachable.
> >
> > Is this your view of the existing world, or what you are proposing be
> > changed?  I'm losing track of what's what in this discussion. :-)
>
> This is how the existing world should have been if the JLS update had not
> been snafu'd. Justin would argue it should be the current state regardless
> due to happens-before definition. Regardless the JVM does not currently
> implement this.

To avoid further confusion, the JVM (I'm assuming you mean Hotspot) doesn't
implement what exactly?

>
> David H.
>
>
> > --
> > - DML
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/8b416832/attachment.html>

From davidcholmes at aapt.net.au  Thu Dec 10 18:37:42 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 11 Dec 2015 09:37:42 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim1DQG=51UQ@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e801d132ec$52d7cc80$f8876580$@net.au>	<5669B1BC.7000406@redhat.com>	<002101d1338e$9b828590$d28790b0$@net.au>
	<CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim
	1DQG=51UQ@mail.gmail.com>
Message-ID: <003f01d133a3$c3f78740$4be695c0$@net.au>

To be 100% clear: hotspot does not implement the requirement that an object is only eligible for finalization after its constructors have completed. Instead it makes them eligible for finalization at the successful end of Object.<init> (by default ? if RegisterFinalizersAtInit is false then it will register them at the end of allocation instead).

 

David

 

From: Vitaly Davidovich [mailto:vitalyd at gmail.com] 
Sent: Friday, December 11, 2015 9:19 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu; David M. Lloyd
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

sent from my phone
On Dec 10, 2015 4:36 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> David M. Lloyd writes:
> >
> > On 12/09/2015 07:44 PM, David Holmes wrote:
> > > To be clear, I missed this later assertion:
> > >
> > >> In summary, we agree that an object can _become finalizable_ before
> > >> completion of its constructor, if the Object constructor completed
> > >> normally and the object is otherwise no longer reachable.
> > >
> > > No! The object should not be able to become finalizable until after
> > all its
> > > constructors have completed, and then it becomes unreachable.
> >
> > Is this your view of the existing world, or what you are proposing be
> > changed?  I'm losing track of what's what in this discussion. :-)
>
> This is how the existing world should have been if the JLS update had not
> been snafu'd. Justin would argue it should be the current state regardless
> due to happens-before definition. Regardless the JVM does not currently
> implement this.

To avoid further confusion, the JVM (I'm assuming you mean Hotspot) doesn't implement what exactly?

>
> David H.
>
>
> > --
> > - DML
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/42cfc578/attachment-0001.html>

From vitalyd at gmail.com  Thu Dec 10 18:47:19 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 10 Dec 2015 18:47:19 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <003f01d133a3$c3f78740$4be695c0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>
	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
	<CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim1DQG=51UQ@mail.gmail.com>
	<003f01d133a3$c3f78740$4be695c0$@net.au>
Message-ID: <CAHjP37HWATWbjdwaywbE9sZ6cfXLfq4ru6-6qmkr+HcpNR+=JA@mail.gmail.com>

So frankly, I can no longer tell whether this is correct or not, and if
it's correct, only because a JLS update slipped through the cracks.  Did we
net out somewhere?

sent from my phone
On Dec 10, 2015 6:37 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> To be 100% clear: hotspot does not implement the requirement that an
> object is only eligible for finalization after its constructors have
> completed. Instead it makes them eligible for finalization at the
> successful end of Object.<init> (by default ? if RegisterFinalizersAtInit
> is false then it will register them at the end of allocation instead).
>
>
>
> David
>
>
>
> *From:* Vitaly Davidovich [mailto:vitalyd at gmail.com]
> *Sent:* Friday, December 11, 2015 9:19 AM
> *To:* dholmes at ieee.org
> *Cc:* concurrency-interest at cs.oswego.edu; David M. Lloyd
> *Subject:* Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
> sent from my phone
> On Dec 10, 2015 4:36 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
> >
> > David M. Lloyd writes:
> > >
> > > On 12/09/2015 07:44 PM, David Holmes wrote:
> > > > To be clear, I missed this later assertion:
> > > >
> > > >> In summary, we agree that an object can _become finalizable_ before
> > > >> completion of its constructor, if the Object constructor completed
> > > >> normally and the object is otherwise no longer reachable.
> > > >
> > > > No! The object should not be able to become finalizable until after
> > > all its
> > > > constructors have completed, and then it becomes unreachable.
> > >
> > > Is this your view of the existing world, or what you are proposing be
> > > changed?  I'm losing track of what's what in this discussion. :-)
> >
> > This is how the existing world should have been if the JLS update had not
> > been snafu'd. Justin would argue it should be the current state
> regardless
> > due to happens-before definition. Regardless the JVM does not currently
> > implement this.
>
> To avoid further confusion, the JVM (I'm assuming you mean Hotspot)
> doesn't implement what exactly?
>
> >
> > David H.
> >
> >
> > > --
> > > - DML
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151210/af4041b9/attachment.html>

From jsampson at guidewire.com  Thu Dec 10 18:48:29 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 10 Dec 2015 23:48:29 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <002101d1338e$9b828590$d28790b0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f!
	01d132c3$6d519650$47f4c	2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
Message-ID: <DM2PR0501MB8750FD51A57E1BD0BDF5BF8D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> > > No! The object should not be able to become finalizable until
> > > after all its constructors have completed, and then it becomes
> > > unreachable.
> >
> > Is this your view of the existing world, or what you are
> > proposing be changed? I'm losing track of what's what in this
> > discussion. :-)
>
> This is how the existing world should have been if the JLS update
> had not been snafu'd. Justin would argue it should be the current
> state regardless due to happens-before definition. Regardless the
> JVM does not currently implement this.

Jeremy Manson seemed to think it had been implemented this way,
based on the happens-before wording, back in 2010:

http://jeremymanson.blogspot.com/2010/01/garbage-collection-references.html

I'm having trouble finding any other concrete references to how it's
actually implemented, but I suppose it's not worth trying to nail it
down unless someone has a legitimate piece of code that's failing.

To summarize the thread again, there have been several questions:

1. Does the spec allow an object's memory to be freed in the middle
of one of its own instance methods?

Everyone seems to agree that the answer is Yes, but there is still
ongoing discussion of whether the spec could be changed, or whether
reachabilityFence() is the best we can hope for.

2. Does any JVM actually do #1?

Yes, Alexandre provided a working example with a segfault.

3. Does the spec allow a finalizer to be run concurrently with the
same object's own constructor?

I say No, David says Maybe, but everyone agrees that the intent was
to forbid it and it's probably worth clarifying in the spec.

4. Does any JVM actually do #3?

A few people say Yes, but we haven't looked at any running examples
in this particular discussion.

Cheers,
Justin


From davidcholmes at aapt.net.au  Thu Dec 10 18:55:32 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 11 Dec 2015 09:55:32 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37HWATWbjdwaywbE9sZ6cfXLfq4ru6-6qmkr+HcpNR+=JA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e801d132ec$52d7cc80$f8876580$@net.au>	<5669B1BC.7000406@redhat.com>	<002101d1338e$9b828590$d28790b0$@net.au>	<CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim
	1DQG=51UQ@mail.gmail.com>	<003f01d133a3$c3f78740$4be695c0$@net.au>
	<CAHjP37HWATWbjdwaywbE9sZ6cfXLfq4ru6-6qmkr+HcpNR+=JA@mail.gmail.com>
Message-ID: <004d01d133a6$4220f960$c662ec20$@net.au>

The current hotspot behaviour is consistent** with existing working in JLS 12.6.1 that an object can be finalized once Object?s constructor has successfully completed. 

 

The JSR-133 ?specification? made it clear that an object was only eligible for finalization once its constructors had completed. But that wording did not make it into the JLS update for reasons that will likely never be determined.

 

**if you don?t expect someone to use the HB definition to infer the stronger requirement

 

David

 

 

 

From: Vitaly Davidovich [mailto:vitalyd at gmail.com] 
Sent: Friday, December 11, 2015 9:47 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu; David M. Lloyd
Subject: RE: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

So frankly, I can no longer tell whether this is correct or not, and if it's correct, only because a JLS update slipped through the cracks.  Did we net out somewhere?

sent from my phone

On Dec 10, 2015 6:37 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:

To be 100% clear: hotspot does not implement the requirement that an object is only eligible for finalization after its constructors have completed. Instead it makes them eligible for finalization at the successful end of Object.<init> (by default ? if RegisterFinalizersAtInit is false then it will register them at the end of allocation instead).

 

David

 

From: Vitaly Davidovich [mailto:vitalyd at gmail.com] 
Sent: Friday, December 11, 2015 9:19 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu; David M. Lloyd
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

sent from my phone
On Dec 10, 2015 4:36 PM, "David Holmes" <davidcholmes at aapt.net.au> wrote:
>
> David M. Lloyd writes:
> >
> > On 12/09/2015 07:44 PM, David Holmes wrote:
> > > To be clear, I missed this later assertion:
> > >
> > >> In summary, we agree that an object can _become finalizable_ before
> > >> completion of its constructor, if the Object constructor completed
> > >> normally and the object is otherwise no longer reachable.
> > >
> > > No! The object should not be able to become finalizable until after
> > all its
> > > constructors have completed, and then it becomes unreachable.
> >
> > Is this your view of the existing world, or what you are proposing be
> > changed?  I'm losing track of what's what in this discussion. :-)
>
> This is how the existing world should have been if the JLS update had not
> been snafu'd. Justin would argue it should be the current state regardless
> due to happens-before definition. Regardless the JVM does not currently
> implement this.

To avoid further confusion, the JVM (I'm assuming you mean Hotspot) doesn't implement what exactly?

>
> David H.
>
>
> > --
> > - DML
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/0ee36ade/attachment-0001.html>

From davidcholmes at aapt.net.au  Thu Dec 10 19:08:27 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 11 Dec 2015 10:08:27 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB8750FD51A57E1BD0BDF5BF8D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>	<5666EA48.2000102@redhat.com>	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>	<089f!	01d132c3$6d519650$47f4c	2f0$@net.au>	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08c401d132c9$1d4261c0$57c72540$@net.au>	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d001d132d4$bb3b3450$31b19cf0$@net.au>	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>	<08d401d132de$4c29ee80$e47dcb80$@net.au>	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>	<08e801d132ec$52d7cc80$f8876580$@net.au>	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
	<DM2PR0501MB8750FD51A57E1BD0BDF5BF8D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <005801d133a8$0fc4e7e0$2f4eb7a0$@net.au>

Justin Sampson writes:
> 
> David Holmes wrote:
> 
> > > > No! The object should not be able to become finalizable until
> > > > after all its constructors have completed, and then it becomes
> > > > unreachable.
> > >
> > > Is this your view of the existing world, or what you are
> > > proposing be changed? I'm losing track of what's what in this
> > > discussion. :-)
> >
> > This is how the existing world should have been if the JLS update
> > had not been snafu'd. Justin would argue it should be the current
> > state regardless due to happens-before definition. Regardless the
> > JVM does not currently implement this.
> 
> Jeremy Manson seemed to think it had been implemented this way,
> based on the happens-before wording, back in 2010:
> 
> http://jeremymanson.blogspot.com/2010/01/garbage-collection-
> references.html

He certainly believed it was implemented this way - see the comments:

"@Sanjay - that is the right concept, although the VM has to do some magic
to prevent the finalizer from running before the constructor finishes."

But only Jeremy can answer whether that was based on the happens-before
wording or the explicit statement that got dropped from the JLS.

David
-----


 
> I'm having trouble finding any other concrete references to how it's
> actually implemented, but I suppose it's not worth trying to nail it
> down unless someone has a legitimate piece of code that's failing.
> 
> To summarize the thread again, there have been several questions:
> 
> 1. Does the spec allow an object's memory to be freed in the middle
> of one of its own instance methods?
> 
> Everyone seems to agree that the answer is Yes, but there is still
> ongoing discussion of whether the spec could be changed, or whether
> reachabilityFence() is the best we can hope for.
> 
> 2. Does any JVM actually do #1?
> 
> Yes, Alexandre provided a working example with a segfault.
> 
> 3. Does the spec allow a finalizer to be run concurrently with the
> same object's own constructor?
> 
> I say No, David says Maybe, but everyone agrees that the intent was
> to forbid it and it's probably worth clarifying in the spec.
> 
> 4. Does any JVM actually do #3?
> 
> A few people say Yes, but we haven't looked at any running examples
> in this particular discussion.
> 
> Cheers,
> Justin


From dl at cs.oswego.edu  Thu Dec 10 19:14:54 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 10 Dec 2015 19:14:54 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <5669767E.40001@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666F49B.9070906@redhat.com>
	<CAHjP37Fir1365NGAzBi7njw639CGaPSrs4OmPab3-2h=_a_Q7Q@mail.gmail.com>
	<56670380.3080108@redhat.com>
	<CAHjP37Fy6dFVQ_XqJ4+-RkEasAeGsdm3bX2TUmwuqxpXK1GH4A@mail.gmail.com>
	<56671E39.5040504@redhat.com>
	<CAHjP37H-BKgqyEEwQgS5kXw3ccJLKovkrXik_KZ2V-zCy=dWDw@mail.gmail.com>
	<5667298E.2080202@redhat.com>
	<CAHjP37HVSy-HPbgX1=a=x_JokDoMTo=HzA6=yUKTjXoM2cA95w@mail.gmail.com>
	<56680367.4050801@redhat.com> <566822AE.3050204@cs.oswego.edu>
	<07CAE6BB-621C-47F1-9B68-E16CCC0EF191@azul.com>
	<2D9EF4BB-59B0-4867-A792-F0B5CA4AB2A2@azul.com>
	<566875A1.6000807@redhat.com>
	<0B5FB78A-890C-48D6-9294-14DD9B2404C7@azul.com>
	<56688A4B.5000906@redhat.com>
	<56F4530E-3C60-4D4E-A6B8-7671245A93CA@azul.com>
	<CAHjP37GoUaVMv+zx3RbMSMWX5-BOTudVKOcX7SkXZ6CGNRJ1Cw@mail.gmail.com>
	<56694815.4080104@redhat.com>
	<CAHjP37EfedZR1_71-MjOR5QqnybG9xmxqb=KHKOLGCn3tZOsJQ@mail.gmail.com>
	<5669767E.40001@redhat.com>
Message-ID: <566A157E.5060707@cs.oswego.edu>

On 12/10/2015 07:56 AM, Andrew Haley wrote:
> On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
>> I can see a few reasons against extending `this` lifetime at this stage of
>> java's life, but what were the objections last time(s) this came up?
>
> Basically twofold.  Mostly efficiency, but also a reluctance to change
> long-settled language semantics.  Making changes to something as
> fundamental as this is always much tricker than people expect.  The
> great advantage of reachabilityFence is that we can do it without a
> lot of complex argument and politics.
>

Like Andrew and others who have seen periodic protracted
discussions of this issue over the past decade or so, I'm not
too optimistic.

But this is also one reason for considering a @Finalized annotation
for fields (not classes!), that would give essentially this
guarantee only in those cases it was requested. Compilers would
translate methods/blocks accessing @Finalized field r
(as in .. use(r); ...)  to  the equivalent of:
   try { ... use(r); ... } finally { reachabilityFence(); }

In the mean time, users can at least arrange this manually though.
There is no reason to believe that the performance impact would
be any different in manual vs automated forms, as long as some of
us are willing to help hotspot minimize it.

-Doug



From jsampson at guidewire.com  Thu Dec 10 19:15:00 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Fri, 11 Dec 2015 00:15:00 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <003f01d133a3$c3f78740$4be695c0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
	<CAHjP37HdvmDvMk-3JfPQfarUb5_=6exWH4zNs9Bim	1DQG=51UQ@mail.gmail.com>
	<003f01d133a3$c3f78740$4be695c0$@net.au>
Message-ID: <DM2PR0501MB8754CCA087094D2CCB00492D1EA0@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> To be 100% clear: hotspot does not implement the requirement that
> an object is only eligible for finalization after its constructors
> have completed. Instead it makes them eligible for finalization at
> the successful end of Object.<init>

Sorry, that's not 100% clear. The spec doesn't use the phrase
"eligible for finalization." Certainly the object must at least be
unreachable before it is eligible for finalization, right? So there
must be more to the implementation of "eligibility" than that
particular call in the compiler.

Cheers,
Justin

P.S. Jeremy explicitly mentioned the happens-before reasoning in the
body of the blog post that I linked to.


From jini at zeus.net.au  Thu Dec 10 21:47:17 2015
From: jini at zeus.net.au (Peter)
Date: Fri, 11 Dec 2015 12:47:17 +1000 (AEST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
Message-ID: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>

Would another workaround be to use a phantom reference ?for the DBB?

The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.

The phantom reference queue functionality could be implemented in static methods and fields. ?Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.

Just curious.

Regards,

Peter.

Sent from my Samsung device.
??Include original message
---- Original message ----
From: Doug Lea <dl at cs.oswego.edu>
Sent: 11/12/2015 10:14:54 am
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

On?12/10/2015?07:56?AM,?Andrew?Haley?wrote: 
>?On?12/10/2015?12:51?PM,?Vitaly?Davidovich?wrote: 
>>?I?can?see?a?few?reasons?against?extending?`this`?lifetime?at?this?stage?of 
>>?java's?life,?but?what?were?the?objections?last?time(s)?this?came?up? 
> 
>?Basically?twofold.??Mostly?efficiency,?but?also?a?reluctance?to?change 
>?long-settled?language?semantics.??Making?changes?to?something?as 
>?fundamental?as?this?is?always?much?tricker?than?people?expect.??The 
>?great?advantage?of?reachabilityFence?is?that?we?can?do?it?without?a 
>?lot?of?complex?argument?and?politics. 
> 

Like?Andrew?and?others?who?have?seen?periodic?protracted 
discussions?of?this?issue?over?the?past?decade?or?so,?I'm?not 
too?optimistic. 

But?this?is?also?one?reason?for?considering?a?@Finalized?annotation 
for?fields?(not?classes!),?that?would?give?essentially?this 
guarantee?only?in?those?cases?it?was?requested.?Compilers?would 
translate?methods/blocks?accessing?@Finalized?field?r 
(as?in?..?use(r);?...)??to??the?equivalent?of: 
???try?{?...?use(r);?...?}?finally?{?reachabilityFence();?} 

In?the?mean?time,?users?can?at?least?arrange?this?manually?though. 
There?is?no?reason?to?believe?that?the?performance?impact?would 
be?any?different?in?manual?vs?automated?forms,?as?long?as?some?of 
us?are?willing?to?help?hotspot?minimize?it. 

-Doug 


_______________________________________________ 
Concurrency-interest?mailing?list 
Concurrency-interest at cs.oswego.edu 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/4c0cde89/attachment.html>

From gil at azul.com  Thu Dec 10 23:30:39 2015
From: gil at azul.com (Gil Tene)
Date: Fri, 11 Dec 2015 04:30:39 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
Message-ID: <43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>


> On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
> 
> Would another workaround be to use a phantom reference  for the DBB?

That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.

There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...

> 
> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
> 
> The phantom reference queue functionality could be implemented in static methods and fields.  Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
> 
> Just curious.
> 
> Regards,
> 
> Peter.
> 
> Sent from my Samsung device.
> ---- Original message ----
> From: Doug Lea <dl at cs.oswego.edu>
> Sent: 11/12/2015 10:14:54 am
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> >> I can see a few reasons against extending `this` lifetime at this stage of
> >> java's life, but what were the objections last time(s) this came up?
> >
> > Basically twofold.  Mostly efficiency, but also a reluctance to change
> > long-settled language semantics.  Making changes to something as
> > fundamental as this is always much tricker than people expect.  The
> > great advantage of reachabilityFence is that we can do it without a
> > lot of complex argument and politics.
> >
> 
> Like Andrew and others who have seen periodic protracted
> discussions of this issue over the past decade or so, I'm not
> too optimistic.
> 
> But this is also one reason for considering a @Finalized annotation
> for fields (not classes!), that would give essentially this
> guarantee only in those cases it was requested. Compilers would
> translate methods/blocks accessing @Finalized field r
> (as in .. use(r); ...)  to  the equivalent of:
>    try { ... use(r); ... } finally { reachabilityFence(); }
> 
> In the mean time, users can at least arrange this manually though.
> There is no reason to believe that the performance impact would
> be any different in manual vs automated forms, as long as some of
> us are willing to help hotspot minimize it.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/ba7f26b9/attachment-0001.bin>

From jini at zeus.net.au  Fri Dec 11 03:48:26 2015
From: jini at zeus.net.au (Peter)
Date: Fri, 11 Dec 2015 18:48:26 +1000 (AEST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
Message-ID: <93504ddb883f26c29a324d2497bdc188@org.tizen.email>

Will this also be the case if the DBB is created and reference managed from c jni code? ?

Thanks,

Peter.

Sent from my Samsung device.
??Include original message
---- Original message ----
From: Gil Tene <gil at azul.com>
Sent: 11/12/2015 02:30:39 pm
To: Peter <jini at zeus.net.au>
Cc: Doug Lea <dl at cs.oswego.edu>; concurrency-interest at cs.oswego.edu <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence


>?On?Dec?10,?2015,?at?6:47?PM,?Peter?<jini at zeus.net.au>?wrote: 
>? 
>?Would?another?workaround?be?to?use?a?phantom?reference??for?the?DBB? 

That's?exactly?what?sun.misc.Cleaner?already?does,?and?DBB?already?uses?a?cleaner.?Cleaners?and?phantom?references?(or?weak,?or?soft,?or?finalizers)?do?not?get?rid?of?the?race.?A?DBB?'this'?can?become?unreachable?between?computing?an?address?and?accessing?it,?GC?picks?up?on?that?and?enqueues?the?phantom?reference?(the?Cleaner?object),?and?the?Cleaner?object?explicitly?frees?the?buffer?memory?that?was?held?by?the?DBB?instance.?Even?though?the?DBB?memory?isn't?reclaimed?until?the?next?GC,?that?doesn't?matter,?since?the?buffer?has?been?freed?[and?potentially?recycled?elsewhere]?before?the?unsafe?call?to?perform?the?last?read?or?write?operation?into?it?is?made. 

There?is?currently?(prior?to?reachabilityFence)?no?way?I?know?of?in?Java?to?close?this?race?in?DBB?short?of?following?each?unsafe?access?(e.g.?in?each?put?or?get)?with?some?carefully?crafted?(and?also?expensive?and/or?optimization-hurting)?volatile?accesses.?E.g.?you?can?add?an?operation?that?stores?'this'?to?an?extra?volatile?field?initialized?to?point?refer?to?'this'.?E.g.?I?think?something?like:?...?unsafe(?);?this.dummy.dummy?=?this;???might?be?sufficient?to?ensure?that?'this'?is?reachable?until?after?the?unsafe?call?if?dummy?is?volatile.?But?it?will?make?buffer?operations?dead?slow... 

>? 
>?The?memory?isn't?reclaimed?by?gc?until?the?phantom?reference?is?cleared?or?becomes?reachable. 
>? 
>?The?phantom?reference?queue?functionality?could?be?implemented?in?static?methods?and?fields.??Classes?aren't?gc'd?until?all?classes?in?a?ClassLoader?and?the?ClassLoader?itself?becomes?reachable. 
>? 
>?Just?curious. 
>? 
>?Regards, 
>? 
>?Peter. 
>? 
>?Sent?from?my?Samsung?device. 
>?----?Original?message?---- 
>?From:?Doug?Lea?<dl at cs.oswego.edu> 
>?Sent:?11/12/2015?10:14:54?am 
>?To:?concurrency-interest at cs.oswego.edu 
>?Subject:?Re:?[concurrency-interest]?DirectByteBuffers?and?reachabilityFence 
>? 
>?On?12/10/2015?07:56?AM,?Andrew?Haley?wrote: 
>?>?On?12/10/2015?12:51?PM,?Vitaly?Davidovich?wrote: 
>?>>?I?can?see?a?few?reasons?against?extending?`this`?lifetime?at?this?stage?of 
>?>>?java's?life,?but?what?were?the?objections?last?time(s)?this?came?up? 
>?> 
>?>?Basically?twofold.??Mostly?efficiency,?but?also?a?reluctance?to?change 
>?>?long-settled?language?semantics.??Making?changes?to?something?as 
>?>?fundamental?as?this?is?always?much?tricker?than?people?expect.??The 
>?>?great?advantage?of?reachabilityFence?is?that?we?can?do?it?without?a 
>?>?lot?of?complex?argument?and?politics. 
>?> 
>? 
>?Like?Andrew?and?others?who?have?seen?periodic?protracted 
>?discussions?of?this?issue?over?the?past?decade?or?so,?I'm?not 
>?too?optimistic. 
>? 
>?But?this?is?also?one?reason?for?considering?a?@Finalized?annotation 
>?for?fields?(not?classes!),?that?would?give?essentially?this 
>?guarantee?only?in?those?cases?it?was?requested.?Compilers?would 
>?translate?methods/blocks?accessing?@Finalized?field?r 
>?(as?in?..?use(r);?...)??to??the?equivalent?of: 
>????try?{?...?use(r);?...?}?finally?{?reachabilityFence();?} 
>? 
>?In?the?mean?time,?users?can?at?least?arrange?this?manually?though. 
>?There?is?no?reason?to?believe?that?the?performance?impact?would 
>?be?any?different?in?manual?vs?automated?forms,?as?long?as?some?of 
>?us?are?willing?to?help?hotspot?minimize?it 
>? 
>?-Doug 
>? 
>? 
>?_______________________________________________ 
>?Concurrency-interest?mailing?list 
>?Concurrency-interest at cs.oswego.edu 
>?http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
>? 
>?_______________________________________________ 
>?Concurrency-interest?mailing?list 
>?Concurrency-interest at cs.oswego.edu 
>?http://cs.oswego.edu/mailman/listinfo/concurrency-interest 


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/24207cd5/attachment.html>

From jason_mehrens at hotmail.com  Fri Dec 11 10:09:11 2015
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Fri, 11 Dec 2015 15:09:11 +0000
Subject: [concurrency-interest] Enhance TimeoutException to include
	more	details
In-Reply-To: <002501d13390$65a897f0$30f9c7d0$@net.au>
References: <BN4PR13MB059403FE2D11E4D214316EEA83E90@BN4PR13MB0594.namprd13.prod.outlook.com>,
	<002501d13390$65a897f0$30f9c7d0$@net.au>
Message-ID: <BN4PR13MB05945D85CB3D63FD0ED27B6C83E90@BN4PR13MB0594.namprd13.prod.outlook.com>

Yes the role of TimeoutException is what I'm asking so you have answered my question.  The interesting part is that receiver of a timeout exception is usually a victim which means the information contained in the timeout exception is almost useless.  You have to admit that we set the bar pretty low when we don't even give back the value of the timeout.  I suppose that could lead to users coding parsers for that information.

Using the example of FutureTask there are no (nor should there be) accessors to get the id or the actual runner of the FutureTask.  So gathering all the information for a JVM is not too hard.  Gathering the exact information for this specific synchronizer very difficult.  Because of where TimeoutException is constructed it would have safe access to all the context required including the assailant thread.  Even if TimeoutException had a methods that returned getExclusiveOwnerThread().getId() and ids of the getQueuedThreads would at add some utility without adding diagnostics directly.

Jason




________________________________________
From: David Holmes <davidcholmes at aapt.net.au>
Sent: Thursday, December 10, 2015 3:19 PM
To: 'Jason Mehrens'; 'concurrency-interest'
Subject: RE: [concurrency-interest] Enhance TimeoutException to include more    details

Hi Jason,

What you propose is a diagnostic capability which is way beyond what a
simple exception should be involved in. It simply isn't the role of
TimeoutException to try and expose all that.

How hard is it to gather that information when you detect the
TimeoutException? There are a couple of API's that could be used.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Jason Mehrens
> Sent: Friday, December 11, 2015 4:27 AM
> To: concurrency-interest
> Subject: [concurrency-interest] Enhance TimeoutException to include
> more details
>
> Hello Concurrency-interest,
>
> A lot of the synchronizers included in jsr166 that throw
> TimeoutException do not include the information that is useful to know
> when such an event occurs. I'm assuming that performance, keeping the
> code simple, and not crippling evolution of the code are the main
> drivers for the way it is today.
>
> With those goals in mind, could TimeoutException be modified to
> include:
> 1. Information about the timeout value with a time unit mapped to
> getMessage().
> 2. A cause Throwable that contained the current stacktrace of the
> 'owner' thread (ASQ.getExclusiveOwnerThread().getStackTrace()).
> 3. Suppressed exceptions that contained all of the threads waiting to
> acquire (ASQ.getQueuedThreads())
>
>
> For example, if take a FutureTask with 4 threads:
> 1. A thread calls FutureTask.run
> 2. Two threads call FutureTask.get.
> 3. One thread calls FutureTask.get(1, SECONDS) and logs the timeout.
>
>
> To convert the stacktraces to a Throwable I abused the
> IllegalStateException for a proof of concept (no security manager).
> The timeout could be described using the following (hopefully the
> formatting works).
>
> =======================================================================
> ==========
> java.util.concurrent.TimeoutException: 1 SECONDS
>     at java.util.concurrent.FutureTask.get(FutureTask.java:205)
>     at
> TimeoutExampleOutput.testFutureTask(TimeoutExampleOutput.java:46)
>     at TimeoutExampleOutput.main(TimeoutExampleOutput.java:12)
>     Suppressed: java.lang.IllegalStateException: [14-WAITING-
> Thread[pool-1-thread-2,5,main]]
>         at sun.misc.Unsafe.park(Native Method)
>         at
> java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
>         at
> java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
>         at java.util.concurrent.FutureTask.get(FutureTask.java:191)
>         at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
>         at java.lang.Thread.run(Thread.java:745)
>     Suppressed: java.lang.IllegalStateException: [15-WAITING-
> Thread[pool-1-thread-3,5,main]]
>         at sun.misc.Unsafe.park(Native Method)
>         at
> java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
>         at
> java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
>         at java.util.concurrent.FutureTask.get(FutureTask.java:191)
>         at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
>         at java.lang.Thread.run(Thread.java:745)
> Caused by: java.lang.IllegalStateException: [13-TIMED_WAITING-
> Thread[pool-1-thread-1,5,main]]
>     at java.lang.Thread.sleep(Native Method)
>     at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:19)
>     at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:16)
>     at java.util.concurrent.FutureTask.run(FutureTask.java:266)
>     at java.lang.Thread.run(Thread.java:745)
> =======================================================================
> ===========
>
> The state of all 4 threads is described in this one failure.  You can
> see that this thread timed out was caused by the worker taking a nap
> and everyone else is being held up because of it.
>
> I would assume there is a way to capture some of this state in
> TimeoutException and then delay the evaluation of that state until some
> TimeoutException method is called like getCause or getMessage and
> retain most of the performance goals.  Or perhaps adding a method to
> TimeoutException to opt into this information.
>
> Any thoughts on this?
>
> Regards,
>
> Jason
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From timo.kinnunen at gmail.com  Fri Dec 11 15:56:19 2015
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Fri, 11 Dec 2015 21:56:19 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
Message-ID: <566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>

Hi, 

I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe. 

First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)

Convinced already? Good ?? 

First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual. 

Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:

A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context. 

Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.

So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken. 

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
 
So, what do you think? Sound reasoning or not?



-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10



From: Gil Tene
Sent: Friday, December 11, 2015 06:01
To: Peter
Cc: Doug Lea;concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence



> On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
> 
> Would another workaround be to use a phantom reference  for the DBB?

That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.

There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...

> 
> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
> 
> The phantom reference queue functionality could be implemented in static methods and fields.  Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
> 
> Just curious.
> 
> Regards,
> 
> Peter.
> 
> Sent from my Samsung device.
> ---- Original message ----
> From: Doug Lea <dl at cs.oswego.edu>
> Sent: 11/12/2015 10:14:54 am
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> >> I can see a few reasons against extending `this` lifetime at this stage of
> >> java's life, but what were the objections last time(s) this came up?
> >
> > Basically twofold.  Mostly efficiency, but also a reluctance to change
> > long-settled language semantics.  Making changes to something as
> > fundamental as this is always much tricker than people expect.  The
> > great advantage of reachabilityFence is that we can do it without a
> > lot of complex argument and politics.
> >
> 
> Like Andrew and others who have seen periodic protracted
> discussions of this issue over the past decade or so, I'm not
> too optimistic.
> 
> But this is also one reason for considering a @Finalized annotation
> for fields (not classes!), that would give essentially this
> guarantee only in those cases it was requested. Compilers would
> translate methods/blocks accessing @Finalized field r
> (as in .. use(r); ...)  to  the equivalent of:
>    try { ... use(r); ... } finally { reachabilityFence(); }
> 
> In the mean time, users can at least arrange this manually though.
> There is no reason to believe that the performance impact would
> be any different in manual vs automated forms, as long as some of
> us are willing to help hotspot minimize it.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/cc93ecf1/attachment.html>

From thurston at nomagicsoftware.com  Fri Dec 11 15:58:42 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Fri, 11 Dec 2015 13:58:42 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <08d001d132d4$bb3b3450$31b19cf0$@net.au>
References: <DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<089f01d132c3$6d519650$47f4c2f0$@net.au>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
Message-ID: <1449867522870-13066.post@n7.nabble.com>


It seems to me this is analogous to the "thread liveness/death" actions.

If thread A starts thread B, then all actions (thread A program order)
happen before, and therefore are visible to, thread B's running.

There is no *legal* execution possible where thread B doesn't 'see' any
prior (A po < ThreadB.start()) writes by thread A.

All of this can be stated without reference to an absolute temporal order,
although IMO, thinking about temporal order doesn't hurt anything.

And the converse is true for thread death
(Thread.join()/Thread.isAlive(false))



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13066.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vitalyd at gmail.com  Fri Dec 11 16:51:17 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 11 Dec 2015 16:51:17 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
Message-ID: <CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>

>
> So why is the DBB.get() method safe and not a potentially asynchronous
> destructor? Simply because as the last thing it does is a ?return this;?
> there is no place inside it where a reachabilityFence(this) could be placed
> such that the receiver would not be used afterwards! This doesn?t by itself
> mean that every call to it is done in a safe manner but it does mean that a
> reachability fence can?t fix the implementation of DBB.get() because
> DBB.get() isn?t broken.


It's been shown a few times already in this thread why DBB.get() is
actually broken, but happens to be lucky (presumably).

I think this is still safe, though, as everything until here has been
> limited to a single thread, therefore correctly synchronized, therefore
> data-race free and therefore sequentially consistent. If a single-threaded
> program could observe a crash here then it would mean the GC had observed
> the return of a method call before the method call returned, which would
> mean the thread?s execution wasn?t sequentially consistent, which is a
> contradiction. Therefore such a reordering is not a legal reordering.
>

There's no contradiction, really.  The GC does not "observe return of a
method", the GC observes oopmaps the compiler gives it; these oopmaps
describe which oops are live at the point of GC (safepoint).  If compiler
determines that `this` is not live anymore, GC will pick up on that.  The
problem is simply that JIT thinks it's dealing with plain "long" values,
but in reality that's a native pointer.  This is just an impedance mismatch
between managed and native memory playing together.



On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com>
wrote:

> Hi,
>
>
>
> I think I?ve figured out why the implementation of
> DirectByteBuffer.get(byte[], int, int) is safe.
>
>
>
> First, please convince yourself that reachabilityFence(this) is
> semantically equivalent or at least as-if compatible with a
> reachabilityPotentiallyEnds(this) call, with the method
> reachabilityPotentiallyEnds() being where all the finalization magic is
> implemented. (This is just for illustration and not the main point.)
>
>
>
> Convinced already? Good ??
>
>
>
> First, consider a constructor. The execution of a constructor starts in a
> static context, where pretty much nothing except evaluating arguments and
> calling another constructor of the same class or some superclass
> constructor is allowed. After that call completes normally, the context
> becomes that of the newly constructed instance, all restrictions of the
> static context are lifted and the rest of the constructor proceeds to
> execute as usual.
>
>
>
> Now consider an instance method where the receiver is not used beyond a
> certain point, its bytecode with slot 0 not read after that point, and the
> native code version which therefore can overwrite and reuse the register
> housing the this-pointer as needed. Such a method could be refactored into
> methods A and B, where method A executes before B and where the receiver is
> used in A but not in B, so that method B can be static. For such a method
> an implicit reachabilityPotentiallyEnds(this) call could be considered to
> exist between the parts A and B. If the receiver does become unreachable in
> such a method then the result of such an execution would be a dual or the
> inverse to a constructor call. Let?s call such methods potentially
> asynchronous destructors:
>
>
>
> A Potentially Asynchronous Destructor is an instance method where it?s
> possible to place a reachabilityFence(this) marker in such a way that the
> receiver is not referenced after execution reaches the marker and the rest
> of the execution happens in an effectively static context.
>
>
>
> Given this definition, any method where an explicit
> reachabilityFence(this) needs to be inserted so that the boundary between A
> and B moves to some later position to guarantee its safety is a potentially
> asynchronous destructor.
>
>
>
> So why is the DBB.get() method safe and not a potentially asynchronous
> destructor? Simply because as the last thing it does is a ?return this;?
> there is no place inside it where a reachabilityFence(this) could be placed
> such that the receiver would not be used afterwards! This doesn?t by itself
> mean that every call to it is done in a safe manner but it does mean that a
> reachability fence can?t fix the implementation of DBB.get() because
> DBB.get() isn?t broken.
>
>
>
> I think this is still safe, though, as everything until here has been
> limited to a single thread, therefore correctly synchronized, therefore
> data-race free and therefore sequentially consistent. If a single-threaded
> program could observe a crash here then it would mean the GC had observed
> the return of a method call before the method call returned, which would
> mean the thread?s execution wasn?t sequentially consistent, which is a
> contradiction. Therefore such a reordering is not a legal reordering.
>
> So, what do you think? Sound reasoning or not?
>
>
>
>
> --
> Have a nice day,
> Timo
>
> Sent from Mail for Windows 10
>
>
>
>
>
>
> *From: *Gil Tene
> *Sent: *Friday, December 11, 2015 06:01
> *To: *Peter
> *Cc: *Doug Lea;concurrency-interest at cs.oswego.edu
>
> *Subject: *Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
>
>
>
>
> > On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
>
> >
>
> > Would another workaround be to use a phantom reference  for the DBB?
>
>
>
> That's exactly what sun.misc.Cleaner already does, and DBB already uses a
> cleaner. Cleaners and phantom references (or weak, or soft, or finalizers)
> do not get rid of the race. A DBB 'this' can become unreachable between
> computing an address and accessing it, GC picks up on that and enqueues the
> phantom reference (the Cleaner object), and the Cleaner object explicitly
> frees the buffer memory that was held by the DBB instance. Even though the
> DBB memory isn't reclaimed until the next GC, that doesn't matter, since
> the buffer has been freed [and potentially recycled elsewhere] before the
> unsafe call to perform the last read or write operation into it is made.
>
>
>
> There is currently (prior to reachabilityFence) no way I know of in Java
> to close this race in DBB short of following each unsafe access (e.g. in
> each put or get) with some carefully crafted (and also expensive and/or
> optimization-hurting) volatile accesses. E.g. you can add an operation that
> stores 'this' to an extra volatile field initialized to point refer to
> 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy =
> this; ? might be sufficient to ensure that 'this' is reachable until after
> the unsafe call if dummy is volatile. But it will make buffer operations
> dead slow...
>
>
>
> >
>
> > The memory isn't reclaimed by gc until the phantom reference is cleared
> or becomes reachable.
>
> >
>
> > The phantom reference queue functionality could be implemented in static
> methods and fields.  Classes aren't gc'd until all classes in a ClassLoader
> and the ClassLoader itself becomes reachable.
>
> >
>
> > Just curious.
>
> >
>
> > Regards,
>
> >
>
> > Peter.
>
> >
>
> > Sent from my Samsung device.
>
> > ---- Original message ----
>
> > From: Doug Lea <dl at cs.oswego.edu>
>
> > Sent: 11/12/2015 10:14:54 am
>
> > To: concurrency-interest at cs.oswego.edu
>
> > Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
> >
>
> > On 12/10/2015 07:56 AM, Andrew Haley wrote:
>
> > > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
>
> > >> I can see a few reasons against extending `this` lifetime at this
> stage of
>
> > >> java's life, but what were the objections last time(s) this came up?
>
> > >
>
> > > Basically twofold.  Mostly efficiency, but also a reluctance to change
>
> > > long-settled language semantics.  Making changes to something as
>
> > > fundamental as this is always much tricker than people expect.  The
>
> > > great advantage of reachabilityFence is that we can do it without a
>
> > > lot of complex argument and politics.
>
> > >
>
> >
>
> > Like Andrew and others who have seen periodic protracted
>
> > discussions of this issue over the past decade or so, I'm not
>
> > too optimistic.
>
> >
>
> > But this is also one reason for considering a @Finalized annotation
>
> > for fields (not classes!), that would give essentially this
>
> > guarantee only in those cases it was requested. Compilers would
>
> > translate methods/blocks accessing @Finalized field r
>
> > (as in .. use(r); ...)  to  the equivalent of:
>
> >    try { ... use(r); ... } finally { reachabilityFence(); }
>
> >
>
> > In the mean time, users can at least arrange this manually though.
>
> > There is no reason to believe that the performance impact would
>
> > be any different in manual vs automated forms, as long as some of
>
> > us are willing to help hotspot minimize it.
>
> >
>
> > -Doug
>
> >
>
> >
>
> > _______________________________________________
>
> > Concurrency-interest mailing list
>
> > Concurrency-interest at cs.oswego.edu
>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> >
>
> > _______________________________________________
>
> > Concurrency-interest mailing list
>
> > Concurrency-interest at cs.oswego.edu
>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151211/b2b362b4/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Dec 11 17:29:43 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 12 Dec 2015 08:29:43 +1000
Subject: [concurrency-interest] Enhance TimeoutException to
	include	more	details
In-Reply-To: <BN4PR13MB05945D85CB3D63FD0ED27B6C83E90@BN4PR13MB0594.namprd13.prod.outlook.com>
References: <BN4PR13MB059403FE2D11E4D214316EEA83E90@BN4PR13MB0594.namprd13.prod.outlook.com>,
	<002501d13390$65a897f0$30f9c7d0$@net.au>
	<BN4PR13MB05945D85CB3D63FD0ED27B6C83E90@BN4PR13MB0594.namprd13.prod.outlook.com>
Message-ID: <00b301d13463$6f508690$4df193b0$@net.au>

Jason Mehrens writes:
> 
> Yes the role of TimeoutException is what I'm asking so you have
> answered my question.  The interesting part is that receiver of a
> timeout exception is usually a victim which means the information
> contained in the timeout exception is almost useless.  You have to
> admit that we set the bar pretty low when we don't even give back the
> value of the timeout.  I suppose that could lead to users coding
> parsers for that information.

I would expect the TimeoutException to be caught at the same level where the
timeout was set - certainly I would expect the value of the timeout used to
be available in most cases. If the exception is propagated to a level that
was unaware of the blocking operation then that seems a flaw in the error
propagation aspect of the API design. The actual value of the timeout is
also somewhat meaningless if you are not in code that understands it is
there and can do something to modify it. Also in many cases the actual
time-left-to-wait that is passed into a blocking operation is not the
maximum-time-to-wait that came in from the caller, so reporting it is again
somewhat meaningless in general.

 
> Using the example of FutureTask there are no (nor should there be)
> accessors to get the id or the actual runner of the FutureTask.  So
> gathering all the information for a JVM is not too hard.  Gathering the
> exact information for this specific synchronizer very difficult.
> Because of where TimeoutException is constructed it would have safe
> access to all the context required including the assailant thread.
> Even if TimeoutException had a methods that returned
> getExclusiveOwnerThread().getId() and ids of the getQueuedThreads would
> at add some utility without adding diagnostics directly.

I hear what you are saying but a TimeoutException is not a privileged member
of a synchronizer for which access to synchronizer innards can be provided

Exploring better diagnostic options for synchronizers is certainly something
to be considered.

Cheers,
David
 
> Jason
> 
> 
> 
> 
> ________________________________________
> From: David Holmes <davidcholmes at aapt.net.au>
> Sent: Thursday, December 10, 2015 3:19 PM
> To: 'Jason Mehrens'; 'concurrency-interest'
> Subject: RE: [concurrency-interest] Enhance TimeoutException to include
> more    details
> 
> Hi Jason,
> 
> What you propose is a diagnostic capability which is way beyond what a
> simple exception should be involved in. It simply isn't the role of
> TimeoutException to try and expose all that.
> 
> How hard is it to gather that information when you detect the
> TimeoutException? There are a couple of API's that could be used.
> 
> Cheers,
> David
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Jason Mehrens
> > Sent: Friday, December 11, 2015 4:27 AM
> > To: concurrency-interest
> > Subject: [concurrency-interest] Enhance TimeoutException to include
> > more details
> >
> > Hello Concurrency-interest,
> >
> > A lot of the synchronizers included in jsr166 that throw
> > TimeoutException do not include the information that is useful to
> know
> > when such an event occurs. I'm assuming that performance, keeping the
> > code simple, and not crippling evolution of the code are the main
> > drivers for the way it is today.
> >
> > With those goals in mind, could TimeoutException be modified to
> > include:
> > 1. Information about the timeout value with a time unit mapped to
> > getMessage().
> > 2. A cause Throwable that contained the current stacktrace of the
> > 'owner' thread (ASQ.getExclusiveOwnerThread().getStackTrace()).
> > 3. Suppressed exceptions that contained all of the threads waiting to
> > acquire (ASQ.getQueuedThreads())
> >
> >
> > For example, if take a FutureTask with 4 threads:
> > 1. A thread calls FutureTask.run
> > 2. Two threads call FutureTask.get.
> > 3. One thread calls FutureTask.get(1, SECONDS) and logs the timeout.
> >
> >
> > To convert the stacktraces to a Throwable I abused the
> > IllegalStateException for a proof of concept (no security manager).
> > The timeout could be described using the following (hopefully the
> > formatting works).
> >
> >
> =======================================================================
> > ==========
> > java.util.concurrent.TimeoutException: 1 SECONDS
> >     at java.util.concurrent.FutureTask.get(FutureTask.java:205)
> >     at
> > TimeoutExampleOutput.testFutureTask(TimeoutExampleOutput.java:46)
> >     at TimeoutExampleOutput.main(TimeoutExampleOutput.java:12)
> >     Suppressed: java.lang.IllegalStateException: [14-WAITING-
> > Thread[pool-1-thread-2,5,main]]
> >         at sun.misc.Unsafe.park(Native Method)
> >         at
> > java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
> >         at
> > java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
> >         at java.util.concurrent.FutureTask.get(FutureTask.java:191)
> >         at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
> >         at java.lang.Thread.run(Thread.java:745)
> >     Suppressed: java.lang.IllegalStateException: [15-WAITING-
> > Thread[pool-1-thread-3,5,main]]
> >         at sun.misc.Unsafe.park(Native Method)
> >         at
> > java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
> >         at
> > java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
> >         at java.util.concurrent.FutureTask.get(FutureTask.java:191)
> >         at TimeoutExampleOutput$2.run(TimeoutExampleOutput.java:37)
> >         at java.lang.Thread.run(Thread.java:745)
> > Caused by: java.lang.IllegalStateException: [13-TIMED_WAITING-
> > Thread[pool-1-thread-1,5,main]]
> >     at java.lang.Thread.sleep(Native Method)
> >     at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:19)
> >     at TimeoutExampleOutput$1.call(TimeoutExampleOutput.java:16)
> >     at java.util.concurrent.FutureTask.run(FutureTask.java:266)
> >     at java.lang.Thread.run(Thread.java:745)
> >
> =======================================================================
> > ===========
> >
> > The state of all 4 threads is described in this one failure.  You can
> > see that this thread timed out was caused by the worker taking a nap
> > and everyone else is being held up because of it.
> >
> > I would assume there is a way to capture some of this state in
> > TimeoutException and then delay the evaluation of that state until
> some
> > TimeoutException method is called like getCause or getMessage and
> > retain most of the performance goals.  Or perhaps adding a method to
> > TimeoutException to opt into this information.
> >
> > Any thoughts on this?
> >
> > Regards,
> >
> > Jason
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From timo.kinnunen at gmail.com  Sat Dec 12 03:38:35 2015
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Sat, 12 Dec 2015 09:38:35 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
Message-ID: <566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>

There?s many ways DBB.get() could be written and many ways a compiler could transform it when inlining it inside a calling method. The implementation that I looked at returns the receiver as the method call completes. My position is that within such a method, the range where the receiver is reachable is already as large as it can ever be and inserting a reachabilityFence can?t and won?t make it any larger. If it didn?t return the receiver the situation would be completely different. I can easily observe the receiver getting garbage collected in under a second while an instance method is executing when that method returns a null value that no-one reads. If it returns the receiver ? still with no-one to read it -- then I can?t make it get finalized before it returns. Not even if I make it extremely unlikely to actually return the receiver and not a null, like this:
 
	return ThreadLocalRandom.current().nextInt(100) == 101 ? this : null;

As for the theory side of the issue, my position there is that asking what sort of data races thread t1 could observe in the presence of some garbage collection thread GC1 is fruitless, because garbage collection isn?t a synchronization action, the JMM doesn?t recognize that these threads synchronize with each other and in any case if thread T1 won?t attempt to synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4 doesn?t even apply.

I think what ultimately decides the case at least for those instance methods that return their receiver is this part in 12.6.1: ?Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.? For our purposes reading the receiver to pass it to the caller could be construed as a read of all of the receiver?s fields .






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10



From: Vitaly Davidovich
Sent: Friday, December 11, 2015 22:51
To: Timo Kinnunen
Cc: Gil Tene;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence


So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.

It's been shown a few times already in this thread why DBB.get() is actually broken, but happens to be lucky (presumably).?

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.

There's no contradiction, really.? The GC does not "observe return of a method", the GC observes oopmaps the compiler gives it; these oopmaps describe which oops are live at the point of GC (safepoint).? If compiler determines that `this` is not live anymore, GC will pick up on that.? The problem is simply that JIT thinks it's dealing with plain "long" values, but in reality that's a native pointer.? This is just an impedance mismatch between managed and native memory playing together.
?

On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com> wrote:
Hi, 
?
I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe. 
?
First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)
?
Convinced already? Good ?? 
?
First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual. 
?
Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:
?
A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context. 
?
Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.
?
So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken. 
?
I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
So, what do you think? Sound reasoning or not?



-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10
?
?

From: Gil Tene
Sent: Friday, December 11, 2015 06:01
To: Peter
Cc: Doug Lea;concurrency-interest at cs.oswego.edu

Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
?
?
?
> On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
> 
> Would another workaround be to use a phantom reference? for the DBB?
?
That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.
?
There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...
?
> 
> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
> 
> The phantom reference queue functionality could be implemented in static methods and fields.? Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
> 
> Just curious.
> 
> Regards,
> 
> Peter.
> 
> Sent from my Samsung device.
> ---- Original message ----
> From: Doug Lea <dl at cs.oswego.edu>
> Sent: 11/12/2015 10:14:54 am
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> >> I can see a few reasons against extending `this` lifetime at this stage of
> >> java's life, but what were the objections last time(s) this came up?
> >
> > Basically twofold.? Mostly efficiency, but also a reluctance to change
> > long-settled language semantics.? Making changes to something as
> > fundamental as this is always much tricker than people expect.? The
> > great advantage of reachabilityFence is that we can do it without a
> > lot of complex argument and politics.
> >
> 
> Like Andrew and others who have seen periodic protracted
> discussions of this issue over the past decade or so, I'm not
> too optimistic.
> 
> But this is also one reason for considering a @Finalized annotation
> for fields (not classes!), that would give essentially this
> guarantee only in those cases it was requested. Compilers would
> translate methods/blocks accessing @Finalized field r
> (as in .. use(r); ...)? to? the equivalent of:
>??? try { ... use(r); ... } finally { reachabilityFence(); }
> 
> In the mean time, users can at least arrange this manually though.
> There is no reason to believe that the performance impact would
> be any different in manual vs automated forms, as long as some of
> us are willing to help hotspot minimize it.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
?
?
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151212/dab103b9/attachment-0001.html>

From martinrb at google.com  Sat Dec 12 14:08:43 2015
From: martinrb at google.com (Martin Buchholz)
Date: Sat, 12 Dec 2015 11:08:43 -0800
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56697403.4080507@cs.oswego.edu>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<CAHjP37Go5CSAHHsKnNJC2_NCUBWUipX80n6PhvMkujrCx2e_JQ@mail.gmail.com>
	<5666A7A3.2070505@redhat.com>
	<CAHjP37F5zfPH8zPYKT7AGt2E-332PdL9iHCzcfy548pq6ftxqw@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<56697403.4080507@cs.oswego.edu>
Message-ID: <CA+kOe08MnOx_YLijKXThzsiHdFmn3sWbLa-EXddVibCzZ6DuVw@mail.gmail.com>

On Thu, Dec 10, 2015 at 4:45 AM, Doug Lea <dl at cs.oswego.edu> wrote:

>> I don't know if Doug/Hans/Bill/Jeremy can shed any light on why the JLS
>> was
>> not updated as expected, but I'd really like to know if they intended to
>> remove the temporal constraint, or whether they also thought the HB was
>> sufficient.
>
>
> Several "editorial improvements" were made (by Gilad Bracha and/or
> others) when JSR133 text was incorporated into JLS. Plus some glitches
> that might just be latex->framemaker conversion breakage. Some still
> remain, and are on to-do list when JMM is substantively revised.

IIRC Gilad intended to incorporate JSR133 into the JLS without
substantive changes.  I'm pretty sure the current state of 12.6.1 is
unintentional.  It may simply be a mistaken focus on only updating
Chapter 17.

Why not just fix it now?  Don't wait for the Great Memory Model Rewrite.

From jsampson at guidewire.com  Sat Dec 12 20:46:06 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Sun, 13 Dec 2015 01:46:06 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
Message-ID: <DM2PR0501MB875039248E6295E7417F764D1EC0@DM2PR0501MB875.namprd05.prod.outlook.com>

Timo Kinnunen wrote:

> There's many ways DBB.get() could be written and many ways a
> compiler could transform it when inlining it inside a calling
> method. The implementation that I looked at returns the receiver
> as the method call completes.

Well, that's the thing: If the method is inlined in a context where
the returned value is ignored, then the compiler is free to get rid
of the return statement iself. If there's no return statement, then
the object can indeed become unreachable at some earlier point in
the method.

> As for the theory side of the issue, my position there is that
> asking what sort of data races thread t1 could observe in the
> presence of some garbage collection thread GC1 is fruitless,
> because garbage collection isn't a synchronization action, the JMM
> doesn't recognize that these threads synchronize with each other
> and in any case if thread T1 won't attempt to synchronize with the
> possibly-non-existent GC1 then the whole of JLS 17.4 doesn't even
> apply.

For the most part, garbage collection isn't part of the memory model
because it's supposed to be invisible. And as long as you're not
trying to manage native memory yourself, it mostly IS invisible. But
DirectByteBuffer DOES manage native memory itself, which leads to
some surprising interactions with garbage collection.

There is some discussion of how garbage collection interacts with
the memory model in section 12.6.2. That section introduces yet
another ordering concept, "comes-before," which is only barely
related to happens-before. It seems primarily intended to ensure
that an object is only considered unreachable if no thread could
possibly observe a reference to it. DBB's management of its own
native memory undermines that logic, leading to a potential
segfault.

https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.2

Cheers,
Justin


From gil at azul.com  Sat Dec 12 21:10:58 2015
From: gil at azul.com (Gil Tene)
Date: Sun, 13 Dec 2015 02:10:58 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>,
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
Message-ID: <ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>



Sent from Gil's iPhone

On Dec 12, 2015, at 12:38 AM, Timo Kinnunen <timo.kinnunen at gmail.com<mailto:timo.kinnunen at gmail.com>> wrote:

There?s many ways DBB.get() could be written and many ways a compiler could transform it when inlining it inside a calling method. The implementation that I looked at returns the receiver as the method call completes. My position is that within such a method, the range where the receiver is reachable is already as large as it can ever be and inserting a reachabilityFence can?t and won?t make it any larger. If it didn?t return the receiver the situation would be completely different.

If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.

put() provides the same fun adventures in accessing potentially-freed memory, and probably a more readable example of the race.

I can easily observe the receiver getting garbage collected in under a second while an instance method is executing when that method returns a null value that no-one reads. If it returns the receiver ? still with no-one to read it -- then I can?t make it get finalized before it returns. Not even if I make it extremely unlikely to actually return the receiver and not a null, like this:
                return ThreadLocalRandom.current().nextInt(100) == 101 ? this : null;

Inlining eliminates the return.


As for the theory side of the issue, my position there is that asking what sort of data races thread t1 could observe in the presence of some garbage collection thread GC1 is fruitless, because garbage collection isn?t a synchronization action, the JMM doesn?t recognize that these threads synchronize with each other and in any case if thread T1 won?t attempt to synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4 doesn?t even apply.

There are no data races between Java threads and GC threads. But there certainly are data races between Java thread t1 and another Java thread t2 that is executing code in response to a phantom/weak/soft red being enqueued (as a result of GC activity on a reference that has become unreachable), or a Java thread t3 that is executing a finalizer (finalizers are executed in Java threads, not in collector threads).

I think what ultimately decides the case at least for those instance methods that return their receiver is this part in 12.6.1: ?Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.? For our purposes reading the receiver to pass it to the caller could be construed as a read of all of the receiver?s fields .

First, The finalization parts of the spec are irrelevant to DBB, since it doesn't do finalization. The races involved effect phantom/weak/soft refs just as much as they  do finalization.

But even when looking at finalizers (the Cleaner work DBB does could be similarly done with a finalizer), there are no post-finalization field reads or writes involved in the DBB races for get() and put(): A local method variable value (a long representing an off heap address) is determined by reading ('pre-fnalzation') a field of 'this'; Then 'this' becomes unreachable. Then a cleaner executes because a phantom ref to the now unreachable 'this' got enqueued; Then the native memory gets freed; (then lots of interesting things, like that memory being allocated for some other purpose, can occur); Then ('post finalization') the unsafe access to that native memory occurs using the method local variable.









--
Have a nice day,
Timo

Sent from Mail for Windows 10





From: Vitaly Davidovich
Sent: Friday, December 11, 2015 22:51
To: Timo Kinnunen
Cc: Gil Tene;Peter;Doug Lea;concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence


So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.

It's been shown a few times already in this thread why DBB.get() is actually broken, but happens to be lucky (presumably).

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.

There's no contradiction, really.  The GC does not "observe return of a method", the GC observes oopmaps the compiler gives it; these oopmaps describe which oops are live at the point of GC (safepoint).  If compiler determines that `this` is not live anymore, GC will pick up on that.  The problem is simply that JIT thinks it's dealing with plain "long" values, but in reality that's a native pointer.  This is just an impedance mismatch between managed and native memory playing together.


On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com<mailto:timo.kinnunen at gmail.com>> wrote:
Hi,

I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe.

First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)

Convinced already? Good ??

First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual.

Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:

A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context.

Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.

So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
So, what do you think? Sound reasoning or not?



--
Have a nice day,
Timo

Sent from Mail for Windows 10





From: Gil Tene
Sent: Friday, December 11, 2015 06:01
To: Peter
Cc: Doug Lea;concurrency-interest at cs.oswego.edu<mailto:Lea%3Bconcurrency-interest at cs.oswego.edu>

Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence



> On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au<mailto:jini at zeus.net.au>> wrote:
>
> Would another workaround be to use a phantom reference  for the DBB?

That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.

There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...

>
> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
>
> The phantom reference queue functionality could be implemented in static methods and fields.  Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
>
> Just curious.
>
> Regards,
>
> Peter.
>
> Sent from my Samsung device.
> ---- Original message ----
> From: Doug Lea <dl at cs.oswego.edu<mailto:dl at cs.oswego.edu>>
> Sent: 11/12/2015 10:14:54 am
> To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
>
> On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> >> I can see a few reasons against extending `this` lifetime at this stage of
> >> java's life, but what were the objections last time(s) this came up?
> >
> > Basically twofold.  Mostly efficiency, but also a reluctance to change
> > long-settled language semantics.  Making changes to something as
> > fundamental as this is always much tricker than people expect.  The
> > great advantage of reachabilityFence is that we can do it without a
> > lot of complex argument and politics.
> >
>
> Like Andrew and others who have seen periodic protracted
> discussions of this issue over the past decade or so, I'm not
> too optimistic.
>
> But this is also one reason for considering a @Finalized annotation
> for fields (not classes!), that would give essentially this
> guarantee only in those cases it was requested. Compilers would
> translate methods/blocks accessing @Finalized field r
> (as in .. use(r); ...)  to  the equivalent of:
>    try { ... use(r); ... } finally { reachabilityFence(); }
>
> In the mean time, users can at least arrange this manually though.
> There is no reason to believe that the performance impact would
> be any different in manual vs automated forms, as long as some of
> us are willing to help hotspot minimize it.
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest




_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151213/73b38bb9/attachment-0001.html>

From gil at azul.com  Sat Dec 12 21:20:45 2015
From: gil at azul.com (Gil Tene)
Date: Sun, 13 Dec 2015 02:20:45 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <DM2PR0501MB875039248E6295E7417F764D1EC0@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>,
	<DM2PR0501MB875039248E6295E7417F764D1EC0@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <3E407733-C1C3-411D-B1BE-3CBC0760C2A7@azul.com>

A small note: This is a resource management  vs. reachability race. It is not really a memory model issue IMO, at least not in a conventional way. The fact that the resource being managed here (in DBB) happens to be native memory does the make this memory related. It would be no different and no less problematic if the opaque id stored in the private field on DBB instance didn't refer to a native memory address, and instead represented a file descriptor number, or a window frame id, or a TCP port number, or a slot position in some custom managed arrays of widgets. It is a resource that is being accessed after resource-release actions have been executed on it, and that's all there is to it.

Sent from Gil's iPhone

> On Dec 12, 2015, at 5:53 PM, Justin Sampson <jsampson at guidewire.com> wrote:
> 
> Timo Kinnunen wrote:
> 
>> There's many ways DBB.get() could be written and many ways a
>> compiler could transform it when inlining it inside a calling
>> method. The implementation that I looked at returns the receiver
>> as the method call completes.
> 
> Well, that's the thing: If the method is inlined in a context where
> the returned value is ignored, then the compiler is free to get rid
> of the return statement iself. If there's no return statement, then
> the object can indeed become unreachable at some earlier point in
> the method.
> 
>> As for the theory side of the issue, my position there is that
>> asking what sort of data races thread t1 could observe in the
>> presence of some garbage collection thread GC1 is fruitless,
>> because garbage collection isn't a synchronization action, the JMM
>> doesn't recognize that these threads synchronize with each other
>> and in any case if thread T1 won't attempt to synchronize with the
>> possibly-non-existent GC1 then the whole of JLS 17.4 doesn't even
>> apply.
> 
> For the most part, garbage collection isn't part of the memory model
> because it's supposed to be invisible. And as long as you're not
> trying to manage native memory yourself, it mostly IS invisible. But
> DirectByteBuffer DOES manage native memory itself, which leads to
> some surprising interactions with garbage collection.
> 
> There is some discussion of how garbage collection interacts with
> the memory model in section 12.6.2. That section introduces yet
> another ordering concept, "comes-before," which is only barely
> related to happens-before. It seems primarily intended to ensure
> that an object is only considered unreachable if no thread could
> possibly observe a reference to it. DBB's management of its own
> native memory undermines that logic, leading to a potential
> segfault.
> 
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.2
> 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From timo.kinnunen at gmail.com  Mon Dec 14 07:27:43 2015
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Mon, 14 Dec 2015 13:27:43 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>,
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
Message-ID: <566eb5c6.42661c0a.791a4.6594@mx.google.com>

Re: ?If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.?

This is the case when I do such refactorings in source code using an IDE. It doesn?t seem like the compiler allows the transforms it does at runtime to affect the reachability of the objects involved, however. The biggest difference is that whether the return value is read or not isn?t what decides if the instance gets collected before the method has returned.

These are factors that I see that do play a part in the decision:
1) Is the receiver not being used baked into the bytecode or can it be affected by evaluating something at runtime. 
2) Is the instance method a leaf method or has it called another instance method on the receiver.

My earlier theory doesn?t predict the second point and I wonder if the compiler is being overly conservative or if there?s something more to it.

This is the caller:

	public void work() throws InterruptedException {
		int which = this.whichRun;
		report(this.letsDoThisThing(), which);
		report(DETAIL, which);
		reachabilityEnds(which);
	}

And this is the instance method that I?m observing:

	private BrokenFinalizeExample letsDoThisThing() throws InterruptedException {
		report("Work started", this.whichRun);
		collect(this.whichRun);
		Thread.sleep(WAIT_MILLIS);
		if(CONDITIONALLY_COMPILED) return EFFECTIVELY_STATIC ? null : this;
		return new Boolean(EFFECTIVELY_STATIC) ? null : this;
	}


It?s only when CONDITIONALLY_COMPILED and EFFECTIVELY_STATIC are both true (and compile-time constants) and not if the caller uses the return value that the receiver gets collected before the sleep. This suggests that whether DBB.get() is safe or not can be determined without examining its callers, which is how it should be. 

Observed with  ?-Xcomp -XX:+TieredCompilation? settings.

And the positive trace:

          2.243455 ms: Run 1
        382.288398 ms: Work started 1
        386.992615 ms: GC 1
        440.442752 ms: Finalize 1
       2433.652559 ms: null 1
       2433.809728 ms: Unconditional 'instance method' ends 1
       2433.887848 ms: GC 1
       2445.546556 ms: Reachability definitely ends 1
       2445.671485 ms: GC 1
       2457.054916 ms: Run 2
       2461.741153 ms: Work started 2
       2462.251409 ms: GC 2
       2473.351502 ms: Finalize 2
       4473.494721 ms: null 2
       4473.611900 ms: Unconditional 'instance method' ends 2
       4473.644760 ms: GC 2
       4480.421312 ms: Reachability definitely ends 2
       4480.504082 ms: GC 2


-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10



From: Gil Tene
Sent: Sunday, December 13, 2015 03:11
To: Timo Kinnunen
Cc: Vitaly Davidovich;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence




Sent from Gil's iPhone

On Dec 12, 2015, at 12:38 AM, Timo Kinnunen <timo.kinnunen at gmail.com> wrote:
There?s many ways DBB.get() could be written and many ways a compiler could transform it when inlining it inside a calling method. The implementation that I looked at returns the receiver as the method call completes. My position is that within such a method, the range where the receiver is reachable is already as large as it can ever be and inserting a reachabilityFence can?t and won?t make it any larger. If it didn?t return the receiver the situation would be completely different.

If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.

put() provides the same fun adventures in accessing potentially-freed memory, and probably a more readable example of the race.


I can easily observe the receiver getting garbage collected in under a second while an instance method is executing when that method returns a null value that no-one reads. If it returns the receiver ? still with no-one to read it -- then I can?t make it get finalized before it returns. Not even if I make it extremely unlikely to actually return the receiver and not a null, like this:
??????????????? return ThreadLocalRandom.current().nextInt(100) == 101 ? this : null;

Inlining eliminates the return. 


?
As for the theory side of the issue, my position there is that asking what sort of data races thread t1 could observe in the presence of some garbage collection thread GC1 is fruitless, because garbage collection isn?t a synchronization action, the JMM doesn?t recognize that these threads synchronize with each other and in any case if thread T1 won?t attempt to synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4 doesn?t even apply.

There are no data races between Java threads and GC threads. But there certainly are data races between Java thread t1 and another Java thread t2 that is executing code in response to a phantom/weak/soft red being enqueued (as a result of GC activity on a reference that has become unreachable), or a Java thread t3 that is executing a finalizer (finalizers are executed in Java threads, not in collector threads).

I think what ultimately decides the case at least for those instance methods that return their receiver is this part in 12.6.1: ?Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.? For our purposes reading the receiver to pass it to the caller could be construed as a read of all of the receiver?s fields .

First, The finalization parts of the spec are irrelevant to DBB, since it doesn't do finalization. The races involved effect phantom/weak/soft refs just as much as they ?do finalization.

But even when looking at finalizers (the Cleaner work DBB does could be similarly done with a finalizer), there are no post-finalization field reads or writes involved in the DBB races for get() and put(): A local method variable value (a long representing an off heap address) is determined by reading ('pre-fnalzation') a field of 'this'; Then 'this' becomes unreachable. Then a cleaner executes because a phantom ref to the now unreachable 'this' got enqueued; Then the native memory gets freed; (then lots of interesting things, like that memory being allocated for some other purpose, can occur); Then ('post finalization') the unsafe access to that native memory occurs using the method local variable.




?





-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10
?
?

From: Vitaly Davidovich
Sent: Friday, December 11, 2015 22:51
To: Timo Kinnunen
Cc: Gil Tene;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
?
?
So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.
?
It's been shown a few times already in this thread why DBB.get() is actually broken, but happens to be lucky (presumably).?
?
I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
?
There's no contradiction, really.? The GC does not "observe return of a method", the GC observes oopmaps the compiler gives it; these oopmaps describe which oops are live at the point of GC (safepoint).? If compiler determines that `this` is not live anymore, GC will pick up on that.? The problem is simply that JIT thinks it's dealing with plain "long" values, but in reality that's a native pointer.? This is just an impedance mismatch between managed and native memory playing together.
?
?
On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com> wrote:
Hi, 
?
I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe. 
?
First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)
?
Convinced already? Good ?? 
?
First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual. 
?
Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:
?
A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context. 
?
Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.
?
So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken. 
?
I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
So, what do you think? Sound reasoning or not?



-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10
?
?

From: Gil Tene
Sent: Friday, December 11, 2015 06:01
To: Peter
Cc: Doug Lea;concurrency-interest at cs.oswego.edu

Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
?
?
?
> On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
> 
> Would another workaround be to use a phantom reference? for the DBB?
?
That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.
?
There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...
?
> 
> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
> 
> The phantom reference queue functionality could be implemented in static methods and fields.? Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
> 
> Just curious.
> 
> Regards,
> 
> Peter.
> 
> Sent from my Samsung device.
> ---- Original message ----
> From: Doug Lea <dl at cs.oswego.edu>
> Sent: 11/12/2015 10:14:54 am
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> >> I can see a few reasons against extending `this` lifetime at this stage of
> >> java's life, but what were the objections last time(s) this came up?
> >
> > Basically twofold.? Mostly efficiency, but also a reluctance to change
> > long-settled language semantics.? Making changes to something as
> > fundamental as this is always much tricker than people expect.? The
> > great advantage of reachabilityFence is that we can do it without a
> > lot of complex argument and politics.
> >
> 
> Like Andrew and others who have seen periodic protracted
> discussions of this issue over the past decade or so, I'm not
> too optimistic.
> 
> But this is also one reason for considering a @Finalized annotation
> for fields (not classes!), that would give essentially this
> guarantee only in those cases it was requested. Compilers would
> translate methods/blocks accessing @Finalized field r
> (as in .. use(r); ...)? to? the equivalent of:
>??? try { ... use(r); ... } finally { reachabilityFence(); }
> 
> In the mean time, users can at least arrange this manually though.
> There is no reason to believe that the performance impact would
> be any different in manual vs automated forms, as long as some of
> us are willing to help hotspot minimize it.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
?
?
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
?
?
?


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151214/fab4b3d5/attachment-0001.html>

From gil at azul.com  Mon Dec 14 12:47:44 2015
From: gil at azul.com (Gil Tene)
Date: Mon, 14 Dec 2015 17:47:44 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566eb5c6.42661c0a.791a4.6594@mx.google.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
Message-ID: <79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>


> On Dec 14, 2015, at 4:27 AM, Timo Kinnunen <timo.kinnunen at gmail.com> wrote:
> 
> Re: ?If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.?
> 
> This is the case when I do such refactorings in source code using an IDE. It doesn?t seem like the compiler allows the transforms it does at runtime to affect the reachability of the objects involved, however. The biggest difference is that whether the return value is read or not isn?t what decides if the instance gets collected before the method has returned.

Lack of success in making the object reachability race happen doesn't equate to the race not being there? The compiler will absolutely shorten the reachability (from a frame) of anything that is no longer used in the frame and is does not escape it. It does so by no longer describing it in the oopmaps. If that object is not otherwise reachable, it is susceptible to having loss-of-reachability actions (such as queueing references or running finalizers) occur on it in the middle of the frame's execution. It's not something you can detect directly by reading the generated code (you'd have to examine the oopmaps). And it's not something that you can to disprove with a test.

> 
> These are factors that I see that do play a part in the decision:
> 1)      Is the receiver not being used baked into the bytecode or can it be affected by evaluating something at runtime.
> 2)      Is the instance method a leaf method or has it called another instance method on the receiver.

It is helpful to imagine "infinite inlining" when thinking about these things, and look at the code as one big flat frame. Then see how far in that frame a reference is still used (including being passed to later calls). Bytecodes and method boundaries don't really mean anything for this reachability issue.

> 
> My earlier theory doesn?t predict the second point and I wonder if the compiler is being overly conservative or if there?s something more to it.
> 
> This is the caller:
> 
>                 public void work() throws InterruptedException {
>                                 int which = this.whichRun;
>                                 report(this.letsDoThisThing(), which);
>                                 report(DETAIL, which);
>                                 reachabilityEnds(which);
>                 }
> 
> And this is the instance method that I?m observing:
> 
>                 private BrokenFinalizeExample letsDoThisThing() throws InterruptedException {
>                                 report("Work started", this.whichRun);
>                                 collect(this.whichRun);
>                                 Thread.sleep(WAIT_MILLIS);
>                                 if(CONDITIONALLY_COMPILED) return EFFECTIVELY_STATIC ? null : this;
>                                 return new Boolean(EFFECTIVELY_STATIC) ? null : this;
>                 }
> 
> It?s only when CONDITIONALLY_COMPILED and EFFECTIVELY_STATIC are both true (and compile-time constants) and not if the caller uses the return value that the receiver gets collected before the sleep.

When your compile time constants are not set, this example can't shorten the reachability of this in letsDoThisThing(), or in work() even when it inlines it, because 'this' can make it to the subsequent call to report().

Try the same without passing the return value to report(), and see if you can trigger things in the sleep...

> This suggests that whether DBB.get() is safe or not can be determined without examining its callers, which is how it should be.

This is not something you can deduce from this test code, since the caller in the test code consumes the return value from the caller and uses it in report().

Determining that DBB.get() "isn't safe" doesn't require examining the callers. It can be shown to be "not-safe by the mere possibility of an inlining caller hat doesn't make actual (required to occur after the call) use of the return value, making 'this' potentially become unreachable before the internally tracked ID (the off heap buffer address in this case) is used to access a resource. That possibility both exists and is probably a common case.

> 
> 
> Observed with  ?-Xcomp -XX:+TieredCompilation? settings.
> 
> And the positive trace:
> 
>           2.243455 ms: Run 1
>         382.288398 ms: Work started 1
>         386.992615 ms: GC 1
>         440.442752 ms: Finalize 1
>        2433.652559 ms: null 1
>        2433.809728 ms: Unconditional 'instance method' ends 1
>        2433.887848 ms: GC 1
>        2445.546556 ms: Reachability definitely ends 1
>        2445.671485 ms: GC 1
>        2457.054916 ms: Run 2
>        2461.741153 ms: Work started 2
>        2462.251409 ms: GC 2
>        2473.351502 ms: Finalize 2
>        4473.494721 ms: null 2
>        4473.611900 ms: Unconditional 'instance method' ends 2
>        4473.644760 ms: GC 2
>        4480.421312 ms: Reachability definitely ends 2
>        4480.504082 ms: GC 2
> 
> 
> --
> Have a nice day,
> Timo
> 
> Sent from Mail for Windows 10
> 
> 
> 
> From: Gil Tene
> Sent: Sunday, December 13, 2015 03:11
> To: Timo Kinnunen
> Cc: Vitaly Davidovich;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> 
> 
> 
> Sent from Gil's iPhone
> 
> On Dec 12, 2015, at 12:38 AM, Timo Kinnunen <timo.kinnunen at gmail.com <mailto:timo.kinnunen at gmail.com>> wrote:
> 
> There?s many ways DBB.get() could be written and many ways a compiler could transform it when inlining it inside a calling method. The implementation that I looked at returns the receiver as the method call completes. My position is that within such a method, the range where the receiver is reachable is already as large as it can ever be and inserting a reachabilityFence can?t and won?t make it any larger. If it didn?t return the receiver the situation would be completely different.
> 
> If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.
> 
> put() provides the same fun adventures in accessing potentially-freed memory, and probably a more readable example of the race.
> 
> 
> I can easily observe the receiver getting garbage collected in under a second while an instance method is executing when that method returns a null value that no-one reads. If it returns the receiver ? still with no-one to read it -- then I can?t make it get finalized before it returns. Not even if I make it extremely unlikely to actually return the receiver and not a null, like this:
>                 return ThreadLocalRandom.current().nextInt(100) == 101 ? this : null;
> 
> Inlining eliminates the return.
> 
> 
> 
> As for the theory side of the issue, my position there is that asking what sort of data races thread t1 could observe in the presence of some garbage collection thread GC1 is fruitless, because garbage collection isn?t a synchronization action, the JMM doesn?t recognize that these threads synchronize with each other and in any case if thread T1 won?t attempt to synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4 doesn?t even apply.
> 
> There are no data races between Java threads and GC threads. But there certainly are data races between Java thread t1 and another Java thread t2 that is executing code in response to a phantom/weak/soft red being enqueued (as a result of GC activity on a reference that has become unreachable), or a Java thread t3 that is executing a finalizer (finalizers are executed in Java threads, not in collector threads).
> 
> I think what ultimately decides the case at least for those instance methods that return their receiver is this part in 12.6.1: ?Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.? For our purposes reading the receiver to pass it to the caller could be construed as a read of all of the receiver?s fields .
> 
> First, The finalization parts of the spec are irrelevant to DBB, since it doesn't do finalization. The races involved effect phantom/weak/soft refs just as much as they  do finalization.
> 
> But even when looking at finalizers (the Cleaner work DBB does could be similarly done with a finalizer), there are no post-finalization field reads or writes involved in the DBB races for get() and put(): A local method variable value (a long representing an off heap address) is determined by reading ('pre-fnalzation') a field of 'this'; Then 'this' becomes unreachable. Then a cleaner executes because a phantom ref to the now unreachable 'this' got enqueued; Then the native memory gets freed; (then lots of interesting things, like that memory being allocated for some other purpose, can occur); Then ('post finalization') the unsafe access to that native memory occurs using the method local variable.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> --
> Have a nice day,
> Timo
> 
> Sent from Mail for Windows 10
> 
> 
> 
> From: Vitaly Davidovich
> Sent: Friday, December 11, 2015 22:51
> To: Timo Kinnunen
> Cc: Gil Tene;Peter;Doug Lea;concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> 
> So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.
> 
> It's been shown a few times already in this thread why DBB.get() is actually broken, but happens to be lucky (presumably).
> 
> I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
> 
> There's no contradiction, really.  The GC does not "observe return of a method", the GC observes oopmaps the compiler gives it; these oopmaps describe which oops are live at the point of GC (safepoint).  If compiler determines that `this` is not live anymore, GC will pick up on that.  The problem is simply that JIT thinks it's dealing with plain "long" values, but in reality that's a native pointer.  This is just an impedance mismatch between managed and native memory playing together.
> 
> 
> On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com <mailto:timo.kinnunen at gmail.com>> wrote:
> Hi,
> 
> I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe.
> 
> First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)
> 
> Convinced already? Good ??
> 
> First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual.
> 
> Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:
> 
> A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context.
> 
> Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.
> 
> So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.
> 
> I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.
> So, what do you think? Sound reasoning or not?
> 
> 
> 
> --
> Have a nice day,
> Timo
> 
> Sent from Mail for Windows 10
> 
> 
> 
> From: Gil Tene
> Sent: Friday, December 11, 2015 06:01
> To: Peter
> Cc: Doug Lea;concurrency-interest at cs.oswego.edu <mailto:Lea%3Bconcurrency-interest at cs.oswego.edu>
> 
> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> 
> 
> 
> > On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au <mailto:jini at zeus.net.au>> wrote:
> >
> > Would another workaround be to use a phantom reference  for the DBB?
> 
> That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.
> 
> There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...
> 
> >
> > The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.
> >
> > The phantom reference queue functionality could be implemented in static methods and fields.  Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.
> >
> > Just curious.
> >
> > Regards,
> >
> > Peter.
> >
> > Sent from my Samsung device.
> > ---- Original message ----
> > From: Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
> > Sent: 11/12/2015 10:14:54 am
> > To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
> > Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence
> >
> > On 12/10/2015 07:56 AM, Andrew Haley wrote:
> > > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
> > >> I can see a few reasons against extending `this` lifetime at this stage of
> > >> java's life, but what were the objections last time(s) this came up?
> > >
> > > Basically twofold.  Mostly efficiency, but also a reluctance to change
> > > long-settled language semantics.  Making changes to something as
> > > fundamental as this is always much tricker than people expect.  The
> > > great advantage of reachabilityFence is that we can do it without a
> > > lot of complex argument and politics.
> > >
> >
> > Like Andrew and others who have seen periodic protracted
> > discussions of this issue over the past decade or so, I'm not
> > too optimistic.
> >
> > But this is also one reason for considering a @Finalized annotation
> > for fields (not classes!), that would give essentially this
> > guarantee only in those cases it was requested. Compilers would
> > translate methods/blocks accessing @Finalized field r
> > (as in .. use(r); ...)  to  the equivalent of:
> >    try { ... use(r); ... } finally { reachabilityFence(); }
> >
> > In the mean time, users can at least arrange this manually though.
> > There is no reason to believe that the performance impact would
> > be any different in manual vs automated forms, as long as some of
> > us are willing to help hotspot minimize it.
> >
> > -Doug
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151214/3428caf9/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151214/3428caf9/attachment-0001.bin>

From davidcholmes at aapt.net.au  Mon Dec 14 22:51:35 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 15 Dec 2015 13:51:35 +1000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
Message-ID: <00d401d136eb$e5303010$af909030$@net.au>

Here?s another nasty little reachability/finalize example:

 

https://bugs.openjdk.java.net/browse/JDK-8145304

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gil Tene
Sent: Tuesday, December 15, 2015 3:48 AM
To: Timo Kinnunen
Cc: Doug Lea; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

 

On Dec 14, 2015, at 4:27 AM, Timo Kinnunen <timo.kinnunen at gmail.com> wrote:

 

Re: ?If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.?

 

This is the case when I do such refactorings in source code using an IDE. It doesn?t seem like the compiler allows the transforms it does at runtime to affect the reachability of the objects involved, however. The biggest difference is that whether the return value is read or not isn?t what decides if the instance gets collected before the method has returned.

 

Lack of success in making the object reachability race happen doesn't equate to the race not being there? The compiler will absolutely shorten the reachability (from a frame) of anything that is no longer used in the frame and is does not escape it. It does so by no longer describing it in the oopmaps. If that object is not otherwise reachable, it is susceptible to having loss-of-reachability actions (such as queueing references or running finalizers) occur on it in the middle of the frame's execution. It's not something you can detect directly by reading the generated code (you'd have to examine the oopmaps). And it's not something that you can to disprove with a test.





 

These are factors that I see that do play a part in the decision:

1)      Is the receiver not being used baked into the bytecode or can it be affected by evaluating something at runtime. 

2)      Is the instance method a leaf method or has it called another instance method on the receiver.

 

It is helpful to imagine "infinite inlining" when thinking about these things, and look at the code as one big flat frame. Then see how far in that frame a reference is still used (including being passed to later calls). Bytecodes and method boundaries don't really mean anything for this reachability issue.

 

 

My earlier theory doesn?t predict the second point and I wonder if the compiler is being overly conservative or if there?s something more to it.

 

This is the caller:

 

                public void work() throws InterruptedException {

                                int which = this.whichRun;

                                report(this.letsDoThisThing(), which);

                                report(DETAIL, which);

                                reachabilityEnds(which);

                }

 

And this is the instance method that I?m observing:

 

                private BrokenFinalizeExample letsDoThisThing() throws InterruptedException {

                                report("Work started", this.whichRun);

                                collect(this.whichRun);

                                Thread.sleep(WAIT_MILLIS);

                                if(CONDITIONALLY_COMPILED) return EFFECTIVELY_STATIC ? null : this;

                                return new Boolean(EFFECTIVELY_STATIC) ? null : this;

                }


It?s only when CONDITIONALLY_COMPILED and EFFECTIVELY_STATIC are both true (and compile-time constants) and not if the caller uses the return value that the receiver gets collected before the sleep. 

 

When your compile time constants are not set, this example can't shorten the reachability of this in letsDoThisThing(), or in work() even when it inlines it, because 'this' can make it to the subsequent call to report().

 

Try the same without passing the return value to report(), and see if you can trigger things in the sleep...





This suggests that whether DBB.get() is safe or not can be determined without examining its callers, which is how it should be.

 

This is not something you can deduce from this test code, since the caller in the test code consumes the return value from the caller and uses it in report().

 

Determining that DBB.get() "isn't safe" doesn't require examining the callers. It can be shown to be "not-safe by the mere possibility of an inlining caller hat doesn't make actual (required to occur after the call) use of the return value, making 'this' potentially become unreachable before the internally tracked ID (the off heap buffer address in this case) is used to access a resource. That possibility both exists and is probably a common case.





 

 

Observed with  ?-Xcomp -XX:+TieredCompilation? settings.

 

And the positive trace:

 

          2.243455 ms: Run 1

        382.288398 ms: Work started 1

        386.992615 ms: GC 1

        440.442752 ms: Finalize 1

       2433.652559 ms: null 1

       2433.809728 ms: Unconditional 'instance method' ends 1

       2433.887848 ms: GC 1

       2445.546556 ms: Reachability definitely ends 1

       2445.671485 ms: GC 1

       2457.054916 ms: Run 2

       2461.741153 ms: Work started 2

       2462.251409 ms: GC 2

       2473.351502 ms: Finalize 2

       4473.494721 ms: null 2

       4473.611900 ms: Unconditional 'instance method' ends 2

       4473.644760 ms: GC 2

       4480.421312 ms: Reachability definitely ends 2

       4480.504082 ms: GC 2



-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

 

 


From: Gil Tene
Sent: Sunday, December 13, 2015 03:11
To: Timo Kinnunen
Cc: Vitaly Davidovich;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

 



Sent from Gil's iPhone


On Dec 12, 2015, at 12:38 AM, Timo Kinnunen < <mailto:timo.kinnunen at gmail.com> timo.kinnunen at gmail.com> wrote:

There?s many ways DBB.get() could be written and many ways a compiler could transform it when inlining it inside a calling method. The implementation that I looked at returns the receiver as the method call completes. My position is that within such a method, the range where the receiver is reachable is already as large as it can ever be and inserting a reachabilityFence can?t and won?t make it any larger. If it didn?t return the receiver the situation would be completely different.

 

If the caller doesn't use the return value (which is a common case for calling get()), and the caller inlined get(), then that return statement doesn't exist as far as the JIT is concerned; it is dead code that can (and does) get legitimately be removed without breaking any rules. Then 'this' goes out of scope before the unsafe access, and boom.

 

put() provides the same fun adventures in accessing potentially-freed memory, and probably a more readable example of the race.






I can easily observe the receiver getting garbage collected in under a second while an instance method is executing when that method returns a null value that no-one reads. If it returns the receiver ? still with no-one to read it -- then I can?t make it get finalized before it returns. Not even if I make it extremely unlikely to actually return the receiver and not a null, like this:

                return ThreadLocalRandom.current().nextInt(100) == 101 ? this : null;

 

Inlining eliminates the return. 






 

As for the theory side of the issue, my position there is that asking what sort of data races thread t1 could observe in the presence of some garbage collection thread GC1 is fruitless, because garbage collection isn?t a synchronization action, the JMM doesn?t recognize that these threads synchronize with each other and in any case if thread T1 won?t attempt to synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4 doesn?t even apply.

 

There are no data races between Java threads and GC threads. But there certainly are data races between Java thread t1 and another Java thread t2 that is executing code in response to a phantom/weak/soft red being enqueued (as a result of GC activity on a reference that has become unreachable), or a Java thread t3 that is executing a finalizer (finalizers are executed in Java threads, not in collector threads).

 

I think what ultimately decides the case at least for those instance methods that return their receiver is this part in 12.6.1: ?Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.? For our purposes reading the receiver to pass it to the caller could be construed as a read of all of the receiver?s fields .

 

First, The finalization parts of the spec are irrelevant to DBB, since it doesn't do finalization. The races involved effect phantom/weak/soft refs just as much as they  do finalization.

 

But even when looking at finalizers (the Cleaner work DBB does could be similarly done with a finalizer), there are no post-finalization field reads or writes involved in the DBB races for get() and put(): A local method variable value (a long representing an off heap address) is determined by reading ('pre-fnalzation') a field of 'this'; Then 'this' becomes unreachable. Then a cleaner executes because a phantom ref to the now unreachable 'this' got enqueued; Then the native memory gets freed; (then lots of interesting things, like that memory being allocated for some other purpose, can occur); Then ('post finalization') the unsafe access to that native memory occurs using the method local variable.

 

 






 






-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

 

 


From: Vitaly Davidovich
Sent: Friday, December 11, 2015 22:51
To: Timo Kinnunen
Cc: Gil Tene;Peter;Doug Lea; <mailto:concurrency-interest at cs.oswego.edu> concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

 

So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken.

 

It's been shown a few times already in this thread why DBB.get() is actually broken, but happens to be lucky (presumably). 

 

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.

 

There's no contradiction, really.  The GC does not "observe return of a method", the GC observes oopmaps the compiler gives it; these oopmaps describe which oops are live at the point of GC (safepoint).  If compiler determines that `this` is not live anymore, GC will pick up on that.  The problem is simply that JIT thinks it's dealing with plain "long" values, but in reality that's a native pointer.  This is just an impedance mismatch between managed and native memory playing together.

 

 

On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen < <mailto:timo.kinnunen at gmail.com> timo.kinnunen at gmail.com> wrote:

Hi, 

 

I think I?ve figured out why the implementation of DirectByteBuffer.get(byte[], int, int) is safe. 

 

First, please convince yourself that reachabilityFence(this) is semantically equivalent or at least as-if compatible with a reachabilityPotentiallyEnds(this) call, with the method reachabilityPotentiallyEnds() being where all the finalization magic is implemented. (This is just for illustration and not the main point.)

 

Convinced already? Good ??

 

First, consider a constructor. The execution of a constructor starts in a static context, where pretty much nothing except evaluating arguments and calling another constructor of the same class or some superclass constructor is allowed. After that call completes normally, the context becomes that of the newly constructed instance, all restrictions of the static context are lifted and the rest of the constructor proceeds to execute as usual. 

 

Now consider an instance method where the receiver is not used beyond a certain point, its bytecode with slot 0 not read after that point, and the native code version which therefore can overwrite and reuse the register housing the this-pointer as needed. Such a method could be refactored into methods A and B, where method A executes before B and where the receiver is used in A but not in B, so that method B can be static. For such a method an implicit reachabilityPotentiallyEnds(this) call could be considered to exist between the parts A and B. If the receiver does become unreachable in such a method then the result of such an execution would be a dual or the inverse to a constructor call. Let?s call such methods potentially asynchronous destructors:

 

A Potentially Asynchronous Destructor is an instance method where it?s possible to place a reachabilityFence(this) marker in such a way that the receiver is not referenced after execution reaches the marker and the rest of the execution happens in an effectively static context. 

 

Given this definition, any method where an explicit reachabilityFence(this) needs to be inserted so that the boundary between A and B moves to some later position to guarantee its safety is a potentially asynchronous destructor.

 

So why is the DBB.get() method safe and not a potentially asynchronous destructor? Simply because as the last thing it does is a ?return this;? there is no place inside it where a reachabilityFence(this) could be placed such that the receiver would not be used afterwards! This doesn?t by itself mean that every call to it is done in a safe manner but it does mean that a reachability fence can?t fix the implementation of DBB.get() because DBB.get() isn?t broken. 

 

I think this is still safe, though, as everything until here has been limited to a single thread, therefore correctly synchronized, therefore data-race free and therefore sequentially consistent. If a single-threaded program could observe a crash here then it would mean the GC had observed the return of a method call before the method call returned, which would mean the thread?s execution wasn?t sequentially consistent, which is a contradiction. Therefore such a reordering is not a legal reordering.

So, what do you think? Sound reasoning or not?




-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10

 

 


From: Gil Tene
Sent: Friday, December 11, 2015 06:01
To: Peter
Cc: Doug  <mailto:Lea%3Bconcurrency-interest at cs.oswego.edu> Lea;concurrency-interest at cs.oswego.edu


Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

 

 

 

> On Dec 10, 2015, at 6:47 PM, Peter < <mailto:jini at zeus.net.au> jini at zeus.net.au> wrote:

> 

> Would another workaround be to use a phantom reference  for the DBB?

 

That's exactly what sun.misc.Cleaner already does, and DBB already uses a cleaner. Cleaners and phantom references (or weak, or soft, or finalizers) do not get rid of the race. A DBB 'this' can become unreachable between computing an address and accessing it, GC picks up on that and enqueues the phantom reference (the Cleaner object), and the Cleaner object explicitly frees the buffer memory that was held by the DBB instance. Even though the DBB memory isn't reclaimed until the next GC, that doesn't matter, since the buffer has been freed [and potentially recycled elsewhere] before the unsafe call to perform the last read or write operation into it is made.

 

There is currently (prior to reachabilityFence) no way I know of in Java to close this race in DBB short of following each unsafe access (e.g. in each put or get) with some carefully crafted (and also expensive and/or optimization-hurting) volatile accesses. E.g. you can add an operation that stores 'this' to an extra volatile field initialized to point refer to 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy = this; ? might be sufficient to ensure that 'this' is reachable until after the unsafe call if dummy is volatile. But it will make buffer operations dead slow...

 

> 

> The memory isn't reclaimed by gc until the phantom reference is cleared or becomes reachable.

> 

> The phantom reference queue functionality could be implemented in static methods and fields.  Classes aren't gc'd until all classes in a ClassLoader and the ClassLoader itself becomes reachable.

> 

> Just curious.

> 

> Regards,

> 

> Peter.

> 

> Sent from my Samsung device.

> ---- Original message ----

> From: Doug Lea < <mailto:dl at cs.oswego.edu> dl at cs.oswego.edu>

> Sent: 11/12/2015 10:14:54 am

> To:  <mailto:concurrency-interest at cs.oswego.edu> concurrency-interest at cs.oswego.edu

> Subject: Re: [concurrency-interest] DirectByteBuffers and reachabilityFence

> 

> On 12/10/2015 07:56 AM, Andrew Haley wrote:

> > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:

> >> I can see a few reasons against extending `this` lifetime at this stage of

> >> java's life, but what were the objections last time(s) this came up?

> >

> > Basically twofold.  Mostly efficiency, but also a reluctance to change

> > long-settled language semantics.  Making changes to something as

> > fundamental as this is always much tricker than people expect.  The

> > great advantage of reachabilityFence is that we can do it without a

> > lot of complex argument and politics.

> >

> 

> Like Andrew and others who have seen periodic protracted

> discussions of this issue over the past decade or so, I'm not

> too optimistic.

> 

> But this is also one reason for considering a @Finalized annotation

> for fields (not classes!), that would give essentially this

> guarantee only in those cases it was requested. Compilers would

> translate methods/blocks accessing @Finalized field r

> (as in .. use(r); ...)  to  the equivalent of:

>    try { ... use(r); ... } finally { reachabilityFence(); }

> 

> In the mean time, users can at least arrange this manually though.

> There is no reason to believe that the performance impact would

> be any different in manual vs automated forms, as long as some of

> us are willing to help hotspot minimize it.

> 

> -Doug

> 

> 

> _______________________________________________

> Concurrency-interest mailing list

>  <mailto:Concurrency-interest at cs.oswego.edu> Concurrency-interest at cs.oswego.edu

>  <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

> 

> _______________________________________________

> Concurrency-interest mailing list

>  <mailto:Concurrency-interest at cs.oswego.edu> Concurrency-interest at cs.oswego.edu

>  <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

 

 


_______________________________________________
Concurrency-interest mailing list
 <mailto:Concurrency-interest at cs.oswego.edu> Concurrency-interest at cs.oswego.edu
 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/8d1d0599/attachment-0001.html>

From thurston at nomagicsoftware.com  Mon Dec 14 23:47:51 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Mon, 14 Dec 2015 21:47:51 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <00d401d136eb$e5303010$af909030$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
Message-ID: <1450154871137-13077.post@n7.nabble.com>

Yeah, it seems likely that the number of places this crops up is just a
function of time.

Is there a legitimate, empirical performance reason that  the JLS couldn't
be changed to require that reachability extend throughout the lifetime of an
instance method?

Maybe method inlining doesn't even account for whether the method inlined is
instance or not?



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13077.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From viktor.klang at gmail.com  Tue Dec 15 03:36:51 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 15 Dec 2015 09:36:51 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <00d401d136eb$e5303010$af909030$@net.au>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
Message-ID: <CANPzfU8gtQWN+K1XTriZc4d6bSU-_RE4q4=CvPGtsQh2gTWnfg@mail.gmail.com>

wow, nasty indeed!

-- 
Cheers,
?
On 15 Dec 2015 05:01, "David Holmes" <davidcholmes at aapt.net.au> wrote:

> Here?s another nasty little reachability/finalize example:
>
>
>
> https://bugs.openjdk.java.net/browse/JDK-8145304
>
>
>
> David
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Gil Tene
> *Sent:* Tuesday, December 15, 2015 3:48 AM
> *To:* Timo Kinnunen
> *Cc:* Doug Lea; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
>
>
> On Dec 14, 2015, at 4:27 AM, Timo Kinnunen <timo.kinnunen at gmail.com>
> wrote:
>
>
>
> Re: ?If the caller doesn't use the return value (which is a common case
> for calling get()), and the caller inlined get(), then that return
> statement doesn't exist as far as the JIT is concerned; it is dead code
> that can (and does) get legitimately be removed without breaking any rules.
> Then 'this' goes out of scope before the unsafe access, and boom.?
>
>
>
> This is the case when I do such refactorings in source code using an IDE.
> It doesn?t seem like the compiler allows the transforms it does at runtime
> to affect the reachability of the objects involved, however. The biggest
> difference is that whether the return value is read or not isn?t what
> decides if the instance gets collected before the method has returned.
>
>
>
> Lack of success in making the object reachability race happen doesn't
> equate to the race not being there? The compiler will absolutely shorten
> the reachability (from a frame) of anything that is no longer used in the
> frame and is does not escape it. It does so by no longer describing it in
> the oopmaps. If that object is not otherwise reachable, it is susceptible
> to having loss-of-reachability actions (such as queueing references or
> running finalizers) occur on it in the middle of the frame's execution.
> It's not something you can detect directly by reading the generated code
> (you'd have to examine the oopmaps). And it's not something that you can to
> disprove with a test.
>
>
>
>
>
> These are factors that I see that do play a part in the decision:
>
> 1)      Is the receiver not being used baked into the bytecode or can it
> be affected by evaluating something at runtime.
>
> 2)      Is the instance method a leaf method or has it called another
> instance method on the receiver.
>
>
>
> It is helpful to imagine "infinite inlining" when thinking about these
> things, and look at the code as one big flat frame. Then see how far in
> that frame a reference is still used (including being passed to later
> calls). Bytecodes and method boundaries don't really mean anything for this
> reachability issue.
>
>
>
>
>
> My earlier theory doesn?t predict the second point and I wonder if the
> compiler is being overly conservative or if there?s something more to it.
>
>
>
> This is the caller:
>
>
>
>                 public void work() throws InterruptedException {
>
>                                 int which = this.whichRun;
>
>                                 report(this.letsDoThisThing(), which);
>
>                                 report(DETAIL, which);
>
>                                 reachabilityEnds(which);
>
>                 }
>
>
>
> And this is the instance method that I?m observing:
>
>
>
>                 private BrokenFinalizeExample letsDoThisThing() throws
> InterruptedException {
>
>                                 report("Work started", this.whichRun);
>
>                                 collect(this.whichRun);
>
>                                 Thread.sleep(WAIT_MILLIS);
>
>                                 if(CONDITIONALLY_COMPILED) return
> EFFECTIVELY_STATIC ? null : this;
>
>                                 return new Boolean(EFFECTIVELY_STATIC) ?
> null : this;
>
>                 }
>
>
> It?s only when CONDITIONALLY_COMPILED and EFFECTIVELY_STATIC are both true
> (and compile-time constants) and not if the caller uses the return value
> that the receiver gets collected before the sleep.
>
>
>
> When your compile time constants are not set, this example can't shorten
> the reachability of this in letsDoThisThing(), or in work() even when it
> inlines it, because 'this' can make it to the subsequent call to report().
>
>
>
> Try the same without passing the return value to report(), and see if you
> can trigger things in the sleep...
>
>
>
> This suggests that whether DBB.get() is safe or not can be determined
> without examining its callers, which is how it should be.
>
>
>
> This is not something you can deduce from this test code, since the caller
> in the test code consumes the return value from the caller and uses it in
> report().
>
>
>
> Determining that DBB.get() "isn't safe" doesn't require examining the
> callers. It can be shown to be "not-safe by the mere possibility of an
> inlining caller hat doesn't make actual (required to occur after the call)
> use of the return value, making 'this' potentially become unreachable
> before the internally tracked ID (the off heap buffer address in this case)
> is used to access a resource. That possibility both exists and is probably
> a common case.
>
>
>
>
>
>
>
> Observed with  ?-Xcomp -XX:+TieredCompilation? settings.
>
>
>
> And the positive trace:
>
>
>
>           2.243455 ms: Run 1
>
>         382.288398 ms: Work started 1
>
>         386.992615 ms: GC 1
>
>         440.442752 ms: Finalize 1
>
>        2433.652559 ms: null 1
>
>        2433.809728 ms: Unconditional 'instance method' ends 1
>
>        2433.887848 ms: GC 1
>
>        2445.546556 ms: Reachability definitely ends 1
>
>        2445.671485 ms: GC 1
>
>        2457.054916 ms: Run 2
>
>        2461.741153 ms: Work started 2
>
>        2462.251409 ms: GC 2
>
>        2473.351502 ms: Finalize 2
>
>        4473.494721 ms: null 2
>
>        4473.611900 ms: Unconditional 'instance method' ends 2
>
>        4473.644760 ms: GC 2
>
>        4480.421312 ms: Reachability definitely ends 2
>
>        4480.504082 ms: GC 2
>
>
>
> --
> Have a nice day,
> Timo
>
> Sent from Mail for Windows 10
>
>
>
>
>
>
> *From: *Gil Tene
> *Sent: *Sunday, December 13, 2015 03:11
> *To: *Timo Kinnunen
> *Cc: *Vitaly Davidovich;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
> *Subject: *Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
>
>
>
>
> Sent from Gil's iPhone
>
>
> On Dec 12, 2015, at 12:38 AM, Timo Kinnunen <timo.kinnunen at gmail.com>
> wrote:
>
> There?s many ways DBB.get() could be written and many ways a compiler
> could transform it when inlining it inside a calling method. The
> implementation that I looked at returns the receiver as the method call
> completes. My position is that within such a method, the range where the
> receiver is reachable is already as large as it can ever be and inserting a
> reachabilityFence can?t and won?t make it any larger. If it didn?t return
> the receiver the situation would be completely different.
>
>
>
> If the caller doesn't use the return value (which is a common case for
> calling get()), and the caller inlined get(), then that return statement
> doesn't exist as far as the JIT is concerned; it is dead code that can (and
> does) get legitimately be removed without breaking any rules. Then 'this'
> goes out of scope before the unsafe access, and boom.
>
>
>
> put() provides the same fun adventures in accessing potentially-freed
> memory, and probably a more readable example of the race.
>
>
>
>
> I can easily observe the receiver getting garbage collected in under a
> second while an instance method is executing when that method returns a
> null value that no-one reads. If it returns the receiver ? still with
> no-one to read it -- then I can?t make it get finalized before it returns.
> Not even if I make it extremely unlikely to actually return the receiver
> and not a null, like this:
>
>                 return ThreadLocalRandom.current().nextInt(100) == 101 ?
> this : null;
>
>
>
> Inlining eliminates the return.
>
>
>
>
>
>
> As for the theory side of the issue, my position there is that asking what
> sort of data races thread t1 could observe in the presence of some garbage
> collection thread GC1 is fruitless, because garbage collection isn?t a
> synchronization action, the JMM doesn?t recognize that these threads
> synchronize with each other and in any case if thread T1 won?t attempt to
> synchronize with the possibly-non-existent GC1 then the whole of JLS 17.4
> doesn?t even apply.
>
>
>
> There are no data races between Java threads and GC threads. But there
> certainly are data races between Java thread t1 and another Java thread t2
> that is executing code in response to a phantom/weak/soft red being
> enqueued (as a result of GC activity on a reference that has become
> unreachable), or a Java thread t3 that is executing a finalizer (finalizers
> are executed in Java threads, not in collector threads).
>
>
>
> I think what ultimately decides the case at least for those instance
> methods that return their receiver is this part in 12.6.1: ?Furthermore,
> none of the pre-finalization reads of fields of that object may see writes
> that occur after finalization of that object is initiated.? For our
> purposes reading the receiver to pass it to the caller could be construed
> as a read of all of the receiver?s fields .
>
>
>
> First, The finalization parts of the spec are irrelevant to DBB, since it
> doesn't do finalization. The races involved effect phantom/weak/soft refs
> just as much as they  do finalization.
>
>
>
> But even when looking at finalizers (the Cleaner work DBB does could be
> similarly done with a finalizer), there are no post-finalization field
> reads or writes involved in the DBB races for get() and put(): A local
> method variable value (a long representing an off heap address) is
> determined by reading ('pre-fnalzation') a field of 'this'; Then 'this'
> becomes unreachable. Then a cleaner executes because a phantom ref to the
> now unreachable 'this' got enqueued; Then the native memory gets freed;
> (then lots of interesting things, like that memory being allocated for some
> other purpose, can occur); Then ('post finalization') the unsafe access to
> that native memory occurs using the method local variable.
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> --
> Have a nice day,
> Timo
>
> Sent from Mail for Windows 10
>
>
>
>
>
>
> *From: *Vitaly Davidovich
> *Sent: *Friday, December 11, 2015 22:51
> *To: *Timo Kinnunen
> *Cc: *Gil Tene;Peter;Doug Lea;concurrency-interest at cs.oswego.edu
> *Subject: *Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
>
>
> So why is the DBB.get() method safe and not a potentially asynchronous
> destructor? Simply because as the last thing it does is a ?return this;?
> there is no place inside it where a reachabilityFence(this) could be placed
> such that the receiver would not be used afterwards! This doesn?t by itself
> mean that every call to it is done in a safe manner but it does mean that a
> reachability fence can?t fix the implementation of DBB.get() because
> DBB.get() isn?t broken.
>
>
>
> It's been shown a few times already in this thread why DBB.get() is
> actually broken, but happens to be lucky (presumably).
>
>
>
> I think this is still safe, though, as everything until here has been
> limited to a single thread, therefore correctly synchronized, therefore
> data-race free and therefore sequentially consistent. If a single-threaded
> program could observe a crash here then it would mean the GC had observed
> the return of a method call before the method call returned, which would
> mean the thread?s execution wasn?t sequentially consistent, which is a
> contradiction. Therefore such a reordering is not a legal reordering.
>
>
>
> There's no contradiction, really.  The GC does not "observe return of a
> method", the GC observes oopmaps the compiler gives it; these oopmaps
> describe which oops are live at the point of GC (safepoint).  If compiler
> determines that `this` is not live anymore, GC will pick up on that.  The
> problem is simply that JIT thinks it's dealing with plain "long" values,
> but in reality that's a native pointer.  This is just an impedance mismatch
> between managed and native memory playing together.
>
>
>
>
>
> On Fri, Dec 11, 2015 at 3:56 PM, Timo Kinnunen <timo.kinnunen at gmail.com>
> wrote:
>
> Hi,
>
>
>
> I think I?ve figured out why the implementation of
> DirectByteBuffer.get(byte[], int, int) is safe.
>
>
>
> First, please convince yourself that reachabilityFence(this) is
> semantically equivalent or at least as-if compatible with a
> reachabilityPotentiallyEnds(this) call, with the method
> reachabilityPotentiallyEnds() being where all the finalization magic is
> implemented. (This is just for illustration and not the main point.)
>
>
>
> Convinced already? Good ??
>
>
>
> First, consider a constructor. The execution of a constructor starts in a
> static context, where pretty much nothing except evaluating arguments and
> calling another constructor of the same class or some superclass
> constructor is allowed. After that call completes normally, the context
> becomes that of the newly constructed instance, all restrictions of the
> static context are lifted and the rest of the constructor proceeds to
> execute as usual.
>
>
>
> Now consider an instance method where the receiver is not used beyond a
> certain point, its bytecode with slot 0 not read after that point, and the
> native code version which therefore can overwrite and reuse the register
> housing the this-pointer as needed. Such a method could be refactored into
> methods A and B, where method A executes before B and where the receiver is
> used in A but not in B, so that method B can be static. For such a method
> an implicit reachabilityPotentiallyEnds(this) call could be considered to
> exist between the parts A and B. If the receiver does become unreachable in
> such a method then the result of such an execution would be a dual or the
> inverse to a constructor call. Let?s call such methods potentially
> asynchronous destructors:
>
>
>
> A Potentially Asynchronous Destructor is an instance method where it?s
> possible to place a reachabilityFence(this) marker in such a way that the
> receiver is not referenced after execution reaches the marker and the rest
> of the execution happens in an effectively static context.
>
>
>
> Given this definition, any method where an explicit
> reachabilityFence(this) needs to be inserted so that the boundary between A
> and B moves to some later position to guarantee its safety is a potentially
> asynchronous destructor.
>
>
>
> So why is the DBB.get() method safe and not a potentially asynchronous
> destructor? Simply because as the last thing it does is a ?return this;?
> there is no place inside it where a reachabilityFence(this) could be placed
> such that the receiver would not be used afterwards! This doesn?t by itself
> mean that every call to it is done in a safe manner but it does mean that a
> reachability fence can?t fix the implementation of DBB.get() because
> DBB.get() isn?t broken.
>
>
>
> I think this is still safe, though, as everything until here has been
> limited to a single thread, therefore correctly synchronized, therefore
> data-race free and therefore sequentially consistent. If a single-threaded
> program could observe a crash here then it would mean the GC had observed
> the return of a method call before the method call returned, which would
> mean the thread?s execution wasn?t sequentially consistent, which is a
> contradiction. Therefore such a reordering is not a legal reordering.
>
> So, what do you think? Sound reasoning or not?
>
>
>
>
> --
> Have a nice day,
> Timo
>
> Sent from Mail for Windows 10
>
>
>
>
>
>
> *From: *Gil Tene
> *Sent: *Friday, December 11, 2015 06:01
> *To: *Peter
> *Cc: *Doug Lea;concurrency-interest at cs.oswego.edu
>
>
> *Subject: *Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
>
>
>
>
>
>
> > On Dec 10, 2015, at 6:47 PM, Peter <jini at zeus.net.au> wrote:
>
> >
>
> > Would another workaround be to use a phantom reference  for the DBB?
>
>
>
> That's exactly what sun.misc.Cleaner already does, and DBB already uses a
> cleaner. Cleaners and phantom references (or weak, or soft, or finalizers)
> do not get rid of the race. A DBB 'this' can become unreachable between
> computing an address and accessing it, GC picks up on that and enqueues the
> phantom reference (the Cleaner object), and the Cleaner object explicitly
> frees the buffer memory that was held by the DBB instance. Even though the
> DBB memory isn't reclaimed until the next GC, that doesn't matter, since
> the buffer has been freed [and potentially recycled elsewhere] before the
> unsafe call to perform the last read or write operation into it is made.
>
>
>
> There is currently (prior to reachabilityFence) no way I know of in Java
> to close this race in DBB short of following each unsafe access (e.g. in
> each put or get) with some carefully crafted (and also expensive and/or
> optimization-hurting) volatile accesses. E.g. you can add an operation that
> stores 'this' to an extra volatile field initialized to point refer to
> 'this'. E.g. I think something like: ... unsafe(?); this.dummy.dummy =
> this; ? might be sufficient to ensure that 'this' is reachable until after
> the unsafe call if dummy is volatile. But it will make buffer operations
> dead slow...
>
>
>
> >
>
> > The memory isn't reclaimed by gc until the phantom reference is cleared
> or becomes reachable.
>
> >
>
> > The phantom reference queue functionality could be implemented in static
> methods and fields.  Classes aren't gc'd until all classes in a ClassLoader
> and the ClassLoader itself becomes reachable.
>
> >
>
> > Just curious.
>
> >
>
> > Regards,
>
> >
>
> > Peter.
>
> >
>
> > Sent from my Samsung device.
>
> > ---- Original message ----
>
> > From: Doug Lea <dl at cs.oswego.edu>
>
> > Sent: 11/12/2015 10:14:54 am
>
> > To: concurrency-interest at cs.oswego.edu
>
> > Subject: Re: [concurrency-interest] DirectByteBuffers and
> reachabilityFence
>
> >
>
> > On 12/10/2015 07:56 AM, Andrew Haley wrote:
>
> > > On 12/10/2015 12:51 PM, Vitaly Davidovich wrote:
>
> > >> I can see a few reasons against extending `this` lifetime at this
> stage of
>
> > >> java's life, but what were the objections last time(s) this came up?
>
> > >
>
> > > Basically twofold.  Mostly efficiency, but also a reluctance to change
>
> > > long-settled language semantics.  Making changes to something as
>
> > > fundamental as this is always much tricker than people expect.  The
>
> > > great advantage of reachabilityFence is that we can do it without a
>
> > > lot of complex argument and politics.
>
> > >
>
> >
>
> > Like Andrew and others who have seen periodic protracted
>
> > discussions of this issue over the past decade or so, I'm not
>
> > too optimistic.
>
> >
>
> > But this is also one reason for considering a @Finalized annotation
>
> > for fields (not classes!), that would give essentially this
>
> > guarantee only in those cases it was requested. Compilers would
>
> > translate methods/blocks accessing @Finalized field r
>
> > (as in .. use(r); ...)  to  the equivalent of:
>
> >    try { ... use(r); ... } finally { reachabilityFence(); }
>
> >
>
> > In the mean time, users can at least arrange this manually though.
>
> > There is no reason to believe that the performance impact would
>
> > be any different in manual vs automated forms, as long as some of
>
> > us are willing to help hotspot minimize it.
>
> >
>
> > -Doug
>
> >
>
> >
>
> > _______________________________________________
>
> > Concurrency-interest mailing list
>
> > Concurrency-interest at cs.oswego.edu
>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> >
>
> > _______________________________________________
>
> > Concurrency-interest mailing list
>
> > Concurrency-interest at cs.oswego.edu
>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/9c7b501f/attachment-0001.html>

From aph at redhat.com  Tue Dec 15 05:17:38 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 15 Dec 2015 10:17:38 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <1450154871137-13077.post@n7.nabble.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com>
Message-ID: <566FE8C2.8020402@redhat.com>

On 15/12/15 04:47, thurstonn wrote:
> Is there a legitimate, empirical performance reason that  the JLS couldn't
> be changed to require that reachability extend throughout the lifetime of an
> instance method?

That question was asked and answered on this list a couple of
days ago.

Andrew.


From vitalyd at gmail.com  Tue Dec 15 07:37:51 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 15 Dec 2015 07:37:51 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <566FE8C2.8020402@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com>
	<566FE8C2.8020402@redhat.com>
Message-ID: <CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>

To be fair, no empirical evidence has been presented; there is speculation
of scenarios it may hurt but nothing concrete.

I also think the bigger obstacle to changing this behavior is getting all
the different JVM implementations modified and not really the performance
impact.

On Tuesday, December 15, 2015, Andrew Haley <aph at redhat.com> wrote:

> On 15/12/15 04:47, thurstonn wrote:
> > Is there a legitimate, empirical performance reason that  the JLS
> couldn't
> > be changed to require that reachability extend throughout the lifetime
> of an
> > instance method?
>
> That question was asked and answered on this list a couple of
> days ago.
>
> Andrew.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <javascript:;>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/435c8dc8/attachment.html>

From thurston at nomagicsoftware.com  Tue Dec 15 07:58:56 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 15 Dec 2015 05:58:56 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <00d401d136eb$e5303010$af909030$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
Message-ID: <1450184336309-13081.post@n7.nabble.com>

David Holmes-6 wrote
> Here?s another nasty little reachability/finalize example:
> 
>  
> 
> https://bugs.openjdk.java.net/browse/JDK-8145304
> 
>  
> 
> David

I think this is an actual bug, i.e. it's a violation of the spec.  
If you look at TPE's code and the test case, #reject is being executed
*after* #finalize has done it's dirty, and #reject() references an instance
variable (#handler) - surely that's not allowed; I mean accessing an
instance variable counts toward reachability, surely
 





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13081.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From aph at redhat.com  Tue Dec 15 08:54:08 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 15 Dec 2015 13:54:08 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com> <566FE8C2.8020402@redhat.com>
	<CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>
Message-ID: <56701B80.3010002@redhat.com>

On 12/15/2015 12:37 PM, Vitaly Davidovich wrote:
> To be fair, no empirical evidence has been presented; there is speculation
> of scenarios it may hurt but nothing concrete.

Exactly.  That was the answer!

> I also think the bigger obstacle to changing this behavior is getting all
> the different JVM implementations modified and not really the performance
> impact.

Yes, it's political as well.  reachabilityFence() is a great start.

Andrew.



From vitalyd at gmail.com  Tue Dec 15 09:50:12 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 15 Dec 2015 09:50:12 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <1450184336309-13081.post@n7.nabble.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450184336309-13081.post@n7.nabble.com>
Message-ID: <CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>

I wonder if this example is hiding some optimization problem.  Although
it's clear that the TPE does not escape, I'm having a hard time seeing how
the JIT was able to prove that it could shorten the lifetime of the TPE
through the swath of code in TPE::execute with all of its atomic ops to
boot.

On Tue, Dec 15, 2015 at 7:58 AM, thurstonn <thurston at nomagicsoftware.com>
wrote:

> David Holmes-6 wrote
> > Here?s another nasty little reachability/finalize example:
> >
> >
> >
> > https://bugs.openjdk.java.net/browse/JDK-8145304
> >
> >
> >
> > David
>
> I think this is an actual bug, i.e. it's a violation of the spec.
> If you look at TPE's code and the test case, #reject is being executed
> *after* #finalize has done it's dirty, and #reject() references an instance
> variable (#handler) - surely that's not allowed; I mean accessing an
> instance variable counts toward reachability, surely
>
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13081.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/112c6ec7/attachment.html>

From martinrb at google.com  Tue Dec 15 12:43:48 2015
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 15 Dec 2015 09:43:48 -0800
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450184336309-13081.post@n7.nabble.com>
	<CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>
Message-ID: <CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>

On Tue, Dec 15, 2015 at 6:50 AM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> I wonder if this example is hiding some optimization problem.  Although it's
> clear that the TPE does not escape, I'm having a hard time seeing how the
> JIT was able to prove that it could shorten the lifetime of the TPE through
> the swath of code in TPE::execute with all of its atomic ops to boot.

I just added this comment to
https://bugs.openjdk.java.net/browse/JDK-8145304

Part of the problem is that there are two finalize methods in play here.
The implementation does

    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,

so the outer executor may get finalized while methods on the inner are
still executing.

Not sure of the motivation for the finalization strategy here.

From jsampson at guidewire.com  Tue Dec 15 15:19:44 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Tue, 15 Dec 2015 20:19:44 +0000
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <00d401d136eb$e5303010$af909030$@net.au>
References: <aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
Message-ID: <DM2PR0501MB8750A7761ACF4D1283CCAA4D1EE0@DM2PR0501MB875.namprd05.prod.outlook.com>

David Holmes wrote:

> Here's another nasty little reachability/finalize example:
>
> https://bugs.openjdk.java.net/browse/JDK-8145304

Interesting! The use case is a bit odd -- I mean, why bother with an
executor when it's not going to be used for anything but a single
task? -- but as a general design issue, is this an example of the
kind of thing that should never have been using finalization in the
first place? I.e., we all know that finalization is problematic, but
it seems like it's occasionally useful for managing native resources
if done carefully. This is just a thread pool. If the programmer
never explicitly shuts down the thread pool, shouldn't it just be
left running? It's their own fault, after all, for not using the API
properly, and the result of not shutting down during finalization is
merely a performance issue, not a correctness issue.

Cheers,
Justin


From paul.sandoz at oracle.com  Tue Dec 15 16:05:21 2015
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Tue, 15 Dec 2015 22:05:21 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56701B80.3010002@redhat.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com>
	<566FE8C2.8020402@redhat.com>
	<CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>
	<56701B80.3010002@redhat.com>
Message-ID: <1A64124C-8449-41B2-A862-40B2CAEDA602@oracle.com>


> On 15 Dec 2015, at 14:54, Andrew Haley <aph at redhat.com> wrote:
> 
> On 12/15/2015 12:37 PM, Vitaly Davidovich wrote:
>> To be fair, no empirical evidence has been presented; there is speculation
>> of scenarios it may hurt but nothing concrete.
> 
> Exactly.  That was the answer!
> 
>> I also think the bigger obstacle to changing this behavior is getting all
>> the different JVM implementations modified and not really the performance
>> impact.
> 
> Yes, it's political as well.  reachabilityFence() is a great start.
> 

The current API and implementation (with known limitations) is now in hs-comp:

  http://hg.openjdk.java.net/jdk9/hs-comp/jdk/rev/827ce3d74163 <http://hg.openjdk.java.net/jdk9/hs-comp/jdk/rev/827ce3d74163>

It will eventually wind it?s way into a JDK EA build but i don?t know exactly when.

Paul.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/7c71cee0/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151215/7c71cee0/attachment.bin>

From thurston at nomagicsoftware.com  Tue Dec 15 15:31:28 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 15 Dec 2015 13:31:28 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>
References: <566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450184336309-13081.post@n7.nabble.com>
	<CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>
	<CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>
Message-ID: <1450211488127-13087.post@n7.nabble.com>

Ahh, yes.  You're right.
The outer ES becomes unreachable while the delegate's #submit is executing.
And the outer ES finalize (indirectly) ->
   delegate.shutdown()

hence the race and the rejected submission



Martin Buchholz-3 wrote
> I just added this comment to
> https://bugs.openjdk.java.net/browse/JDK-8145304
> 
> Part of the problem is that there are two finalize methods in play here.
> The implementation does
> 
>     public static ExecutorService newSingleThreadExecutor() {
>         return new FinalizableDelegatedExecutorService
>             (new ThreadPoolExecutor(1, 1,
> 
> so the outer executor may get finalized while methods on the inner are
> still executing.
> 
> Not sure of the motivation for the finalization strategy here.
> _______________________________________________
> Concurrency-interest mailing list

> Concurrency-interest at .oswego

> http://cs.oswego.edu/mailman/listinfo/concurrency-interest





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13087.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From dl at cs.oswego.edu  Tue Dec 15 16:24:35 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 15 Dec 2015 16:24:35 -0500
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<aba6589c6b0d87a9e3589b16cbaec13c@org.tizen.email>
	<43583B9F-CF63-4B2F-B6FE-DB545529C7D7@azul.com>
	<566b3876.ad3ec20a.d19ea.6a3e@mx.google.com>
	<CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450184336309-13081.post@n7.nabble.com>
	<CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>
	<CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>
Message-ID: <56708513.5040607@cs.oswego.edu>

On 12/15/2015 12:43 PM, Martin Buchholz wrote:
> Part of the problem is that there are two finalize methods in play here.
> The implementation does
>
>      public static ExecutorService newSingleThreadExecutor() {
>          return new FinalizableDelegatedExecutorService
>              (new ThreadPoolExecutor(1, 1,
>
> so the outer executor may get finalized while methods on the inner are
> still executing.
>
> Not sure of the motivation for the finalization strategy here.

See http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6399443
and concurrency-interest discussion in March 2006 with subject
   Finalization changes to DelegatedExecutorService
http://cs.oswego.edu/pipermail/concurrency-interest/2006-March/thread.html

Without this, some users were leaking Executors/Threads.
This is arguably not our (j.u.c) problem.
But after some resistance, we decided to add the finalizer.
With it, users may encounter surprisingly early shutdown without
reachabilityFence.

-Doug






From thurston at nomagicsoftware.com  Tue Dec 15 16:06:26 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 15 Dec 2015 14:06:26 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <56708513.5040607@cs.oswego.edu>
References: <CAHjP37FZ8YSKP-4aUDkOthPnbJDR5hcqQHJejPWyw9XjTQaz3g@mail.gmail.com>
	<566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450184336309-13081.post@n7.nabble.com>
	<CAHjP37G9GwTW0_hQeNKGJGWCe7Av5Skz455+36g8mimGXZRcKA@mail.gmail.com>
	<CA+kOe0_Kh9AdQPoEit0_neo+wCRoebqr_vrRjG_Btkk-jf4woA@mail.gmail.com>
	<56708513.5040607@cs.oswego.edu>
Message-ID: <1450213586067-13089.post@n7.nabble.com>

So will DelegatedExecutorService be refactored to include reachabilityFence()
calls where appropriate?
e.g.

public Future<?> submit(Runnable task) {
            return e.submit(task);
        }

becomes

public Future<?> submit(Runnable task) 
{
            Future<?> result = e.submit(task);
            reachabilityFence(this);
            return result;
}

that would ameliorate (although not eliminate) the issue


Doug Lea wrote
> On 12/15/2015 12:43 PM, Martin Buchholz wrote:
>> Part of the problem is that there are two finalize methods in play here.
>> The implementation does
>>
>>      public static ExecutorService newSingleThreadExecutor() {
>>          return new FinalizableDelegatedExecutorService
>>              (new ThreadPoolExecutor(1, 1,
>>
>> so the outer executor may get finalized while methods on the inner are
>> still executing.
>>
>> Not sure of the motivation for the finalization strategy here.
> 
> See http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6399443
> and concurrency-interest discussion in March 2006 with subject
>    Finalization changes to DelegatedExecutorService
> http://cs.oswego.edu/pipermail/concurrency-interest/2006-March/thread.html
> 
> Without this, some users were leaking Executors/Threads.
> This is arguably not our (j.u.c) problem.
> But after some resistance, we decided to add the finalizer.
> With it, users may encounter surprisingly early shutdown without
> reachabilityFence.
> 
> -Doug
> 
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list

> Concurrency-interest at .oswego

> http://cs.oswego.edu/mailman/listinfo/concurrency-interest





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13089.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From dl at cs.oswego.edu  Wed Dec 16 20:00:19 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 16 Dec 2015 20:00:19 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
Message-ID: <56720923.80502@cs.oswego.edu>


Ever since Chris Purcell helpfully pointed out last summer that we
should not drop nested exceptions in whenComplete, we've stalled
incorporating changes. There are some good arguments for each of
two options, that affects only a single line of code.
(We've ruled out some other options.)

Even though this is a corner case issue with low impact, we'd like
to choose the best option we can. So please help us out by
responding to this SurveyMonkey survey before Saturday
morning (19 December).

   https://www.surveymonkey.com/r/3D2L9DR

Thanks!

-Doug

From boehm at acm.org  Wed Dec 16 20:57:16 2015
From: boehm at acm.org (Hans Boehm)
Date: Wed, 16 Dec 2015 17:57:16 -0800
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <002101d1338e$9b828590$d28790b0$@net.au>
References: <CANrO4iZCQLoY4eREWgUa9oAZ8VtatnYKLU9Q5U9G01c_DuVn3Q@mail.gmail.com>
	<5666EA48.2000102@redhat.com>
	<DM2PR0501MB875CD49227D8AE6D0BCA79CD1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<5667EE48.1020102@gmail.com>
	<07fb01d13262$fafccb70$f0f66250$@net.au>
	<566803E1.30809@redhat.com>
	<080801d13272$4d48eb20$e7dac160$@net.au>
	<CAHjP37GraLP_ccsNxV0aufYf0Ou-=T90Vvc-K1JV_gHAPtjKHQ@mail.gmail.com>
	<DM2PR0501MB875EC17FAAC851EA7307F33D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08c401d132c9$1d4261c0$57c72540$@net.au>
	<DM2PR0501MB875FE9682BFB41874C9FEB1D1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d001d132d4$bb3b3450$31b19cf0$@net.au>
	<DM2PR0501MB875244218E2E85C8191583ED1E80@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08d401d132de$4c29ee80$e47dcb80$@net.au>
	<DM2PR0501MB8758ADBE688CA98AD74C100D1E90@DM2PR0501MB875.namprd05.prod.outlook.com>
	<08e801d132ec$52d7cc80$f8876580$@net.au>
	<5669B1BC.7000406@redhat.com>
	<002101d1338e$9b828590$d28790b0$@net.au>
Message-ID: <CAPUmR1a48Qz1b1iPBzkgZPjwv+B-suczmcCm8FWDguRh2G=JMw@mail.gmail.com>

My vague recollection is also that there should have been a statement
preventing finalization before constructor completion.  I'm actually no
longer sure how much it matters.  I think 12.6.2 ensure that the finalizer
must see all non-finalizer writes to the object.  Thus I think it must see
an object that looks more or less initialized.  In the new world, basically
every method, probably including the constructor, that uses a field cleaned
up by a finalizer should use an explicit reachabilityFence.

I suspect that in the long run we essentially just want to say that the
last reachabilityFence happens before the finalizer, and lose the rest of
12.6.2.  Almost no finalizer works without reachabilityFence anyway.

Note that "this" is really not special here.  A great (bad?) example is
Android's BigInteger implementation that wraps a native bignum
implementation.  The finalizer deallocates the native object.  If you look
at something like the add() method, "this" and the method argument are
entirely symmetric.  Either would be subject to premature finalization of
we didn't work around the issue in the compiler.

On Thu, Dec 10, 2015 at 1:06 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> David M. Lloyd writes:
> >
> > On 12/09/2015 07:44 PM, David Holmes wrote:
> > > To be clear, I missed this later assertion:
> > >
> > >> In summary, we agree that an object can _become finalizable_ before
> > >> completion of its constructor, if the Object constructor completed
> > >> normally and the object is otherwise no longer reachable.
> > >
> > > No! The object should not be able to become finalizable until after
> > all its
> > > constructors have completed, and then it becomes unreachable.
> >
> > Is this your view of the existing world, or what you are proposing be
> > changed?  I'm losing track of what's what in this discussion. :-)
>
> This is how the existing world should have been if the JLS update had not
> been snafu'd. Justin would argue it should be the current state regardless
> due to happens-before definition. Regardless the JVM does not currently
> implement this.
>
> David H.
>
>
> > --
> > - DML
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151216/d4895734/attachment.html>

From thurston at nomagicsoftware.com  Thu Dec 17 09:54:20 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Thu, 17 Dec 2015 07:54:20 -0700 (MST)
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <1A64124C-8449-41B2-A862-40B2CAEDA602@oracle.com>
References: <566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com>
	<566FE8C2.8020402@redhat.com>
	<CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>
	<56701B80.3010002@redhat.com>
	<1A64124C-8449-41B2-A862-40B2CAEDA602@oracle.com>
Message-ID: <1450364060762-13092.post@n7.nabble.com>

If possible, it would be convenient if #reachabilityFence were defined as
varargs:

public static void reachabilityFence(Object...  refs)

as there are many cases (e.g. Hans Boehm provides one in this thread) where
one would want to extend reachability to a set of objects to the same point. 
I wouldn't think that any ordering guarantee need to be preserved in the
case where multiple args were passed

I don't know the effect that might have upon the compiler



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13092.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From aleksey.shipilev at oracle.com  Thu Dec 17 16:36:57 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 18 Dec 2015 00:36:57 +0300
Subject: [concurrency-interest] Explicitly initializing volatile fields with
	default values
Message-ID: <56732AF9.7030109@oracle.com>

Hi there, concurrency dwellers,

I'm trying to find a counter-example/constraints against removing the
field initializers for volatile fields, when those initializers are
storing the default value. We know this improves performance, e.g.
  https://bugs.openjdk.java.net/browse/JDK-8035284

There is a gut feeling that removing these initializations is safe. But,
I have heard rumors of traces of counter-examples in OpenJDK bugtracker,
but found nothing substantial, which gives me doubts. Maybe there are
constraints I am overlooking?

First, let me show that you cannot (always) do this mechanically for all
(even non-volatile!) usages. JLS 8.3.2.3 "Restrictions on the use of
Fields during Initialization" allows this:

public class InitializerOverwrite {
  {
    x1 = 42;
    x2 = 42;
  }

  int x1;
  int x2 = 0;

  public static void main(String... args) {
    InitializerOverwrite io = new InitializerOverwrite();
    System.out.println(io.x1); // 42
    System.out.println(io.x2); // 0
  }
}

...so you definitely need to inspect if there is some stray store that
needs to be stamped out with the field initializer. What's worse,
instance/field initializer can invoke an arbitrary method that might
confuse any analysis, but still perform an instance field store. So, we
can reliably do this optimization for simple cases only.

But let's consider a simpler case for concurrency implications:

 class C {
   volatile int v = 0; // can we drop " = 0"?

   public C() {
     // nothing here
   }
 }

Is there a plausible case that shows the semantical difference with
field initializer storing a default value, and without one, that does
*not* also affect single-threaded usages (i.e. it does not follow from
the instance initialization sequence itself)?

Naive attempts to construct the examples seem to boil down to two cases.

*** Case A. Over-reaching "memory effects" for instance fields:

 class A {
   int f;
   volatile int v = 0;

   public A() {
     f = 42;
   }
 }

 A global;

 ----

 Thread 1:
   global = new A();

 Thread 2:
   A a = global;
   if (a != null && a.v == 0) {
     print(a.f); // ?
   }

There are no guarantees here whatsoever, because field initializations
are performed *before* any constructor body starts, as per JLS 12.5.
Therefore, the "releasing" volatile store to $v is executed before any
store to $f, which deconstructs any happens-before.

This seems to expand to non-instance fields, and other variables written
after firing the field initializer.

Note, that perhaps moving the initialization ($v = 0) into the
constructor after ($f = 42), or, similarly, making ($f = 42) the field
initializer, would lay out the code in the correct shape, and this gets
us to case B.


*** Case B. Transitive "memory effects" over explicit stores:

 class B {
   int f = 42;
   volatile int v = 0;
 }

 B global;

 ----

 Thread 1:
   global = new B();

 Thread 2:
   B b = global;
   if (b != null && b.v == 0) {
     print(b.f); // ?
   }

These three executions seem plausible:

 1) Happens-before read of write(f, 42):

  (default) write(v,0)
  (default) write(f,0)
         |
         | hb/sw
         v
     write(f,42) --hb/po--> write(v,0)
                                |
                                | hb/sw
                                v
                             read(v):0 --hb/po--> read(f):42;

 2) Read of default write(f, 0) -- these synchronize-with the first
action in the thread:

                       (default) write(v,0)
                       (default) write(f,0)
                                |
                                | hb/sw
                                v
                             read(v):0 --hb/po--> read(f):0

 (One might wonder if that means you can see the default value for an
explicitly initialized volatile field, once you read the instance itself
-- you can! -- we have seen this with AtomicIntegers before)

 3) Racy read of unordered write(f, 42):

     (default) write(v,0)
     (default) write(f,0)          write(f, 42)
                  |                     .
                  | hb/sw               . (unordered)
                  v                     .
               read(v):0 --hb/po--> read(f):42


In other words, if we drop execution (1) by omitting the explicit
initializing store, we would still be able to observe both "0" and "42".

This seems to expand to non-instance fields, and other variables written
before firing the field initializer.

*** Putting all together

Now, putting these things together:

 * Case A tells that no variable written *after* the volatile instance
field initializer is protected (duh).

 * Case B tells that no variable written *before* the volatile instance
field initializer writing the default value is protected by
happens-before. This is because the explicit initializing store with the
default value is indistinguishable from the default value store.

 * Since Case A and Case B cover all possible variables (with the
exception of the volatile field itself), this seems to imply that
explicit field initializers that store default values have no effect on
memory ordering.

Is it a correct way to think about it?

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/06a62a5b/attachment.bin>

From vitalyd at gmail.com  Thu Dec 17 19:06:10 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 17 Dec 2015 19:06:10 -0500
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <56732AF9.7030109@oracle.com>
References: <56732AF9.7030109@oracle.com>
Message-ID: <CAHjP37ESZDeqGnv+t+=53fTh_8MTBq4FjSuM6yUgon7YJBS0rg@mail.gmail.com>

On Thursday, December 17, 2015, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> Hi there, concurrency dwellers,
>
> I'm trying to find a counter-example/constraints against removing the
> field initializers for volatile fields, when those initializers are
> storing the default value. We know this improves performance, e.g.
>   https://bugs.openjdk.java.net/browse/JDK-8035284
>
> There is a gut feeling that removing these initializations is safe. But,
> I have heard rumors of traces of counter-examples in OpenJDK bugtracker,
> but found nothing substantial, which gives me doubts. Maybe there are
> constraints I am overlooking?
>
> First, let me show that you cannot (always) do this mechanically for all
> (even non-volatile!) usages. JLS 8.3.2.3 "Restrictions on the use of
> Fields during Initialization" allows this:
>
> public class InitializerOverwrite {
>   {
>     x1 = 42;
>     x2 = 42;
>   }
>
>   int x1;
>   int x2 = 0;
>
>   public static void main(String... args) {
>     InitializerOverwrite io = new InitializerOverwrite();
>     System.out.println(io.x1); // 42
>     System.out.println(io.x2); // 0
>   }
> }
>
> ...so you definitely need to inspect if there is some stray store that
> needs to be stamped out with the field initializer. What's worse,
> instance/field initializer can invoke an arbitrary method that might
> confuse any analysis, but still perform an instance field store. So, we
> can reliably do this optimization for simple cases only.
>
> But let's consider a simpler case for concurrency implications:
>
>  class C {
>    volatile int v = 0; // can we drop " = 0"?
>
>    public C() {
>      // nothing here
>    }
>  }
>
> Is there a plausible case that shows the semantical difference with
> field initializer storing a default value, and without one, that does
> *not* also affect single-threaded usages (i.e. it does not follow from
> the instance initialization sequence itself)?
>
> Naive attempts to construct the examples seem to boil down to two cases.
>
> *** Case A. Over-reaching "memory effects" for instance fields:
>
>  class A {
>    int f;
>    volatile int v = 0;
>
>    public A() {
>      f = 42;
>    }
>  }
>
>  A global;
>
>  ----
>
>  Thread 1:
>    global = new A();
>
>  Thread 2:
>    A a = global;
>    if (a != null && a.v == 0) {
>      print(a.f); // ?
>    }
>
> There are no guarantees here whatsoever, because field initializations
> are performed *before* any constructor body starts, as per JLS 12.5.
> Therefore, the "releasing" volatile store to $v is executed before any
> store to $f, which deconstructs any happens-before.
>
> This seems to expand to non-instance fields, and other variables written
> after firing the field initializer.
>
> Note, that perhaps moving the initialization ($v = 0) into the
> constructor after ($f = 42), or, similarly, making ($f = 42) the field
> initializer, would lay out the code in the correct shape, and this gets
> us to case B.
>
>
> *** Case B. Transitive "memory effects" over explicit stores:
>
>  class B {
>    int f = 42;
>    volatile int v = 0;
>  }
>
>  B global;
>
>  ----
>
>  Thread 1:
>    global = new B();
>
>  Thread 2:
>    B b = global;
>    if (b != null && b.v == 0) {
>      print(b.f); // ?
>    }
>
> These three executions seem plausible:
>
>  1) Happens-before read of write(f, 42):
>
>   (default) write(v,0)
>   (default) write(f,0)
>          |
>          | hb/sw
>          v
>      write(f,42) --hb/po--> write(v,0)
>                                 |
>                                 | hb/sw
>                                 v
>                              read(v):0 --hb/po--> read(f):42;
>
>  2) Read of default write(f, 0) -- these synchronize-with the first
> action in the thread:
>
>                        (default) write(v,0)
>                        (default) write(f,0)
>                                 |
>                                 | hb/sw
>                                 v
>                              read(v):0 --hb/po--> read(f):0
>
>  (One might wonder if that means you can see the default value for an
> explicitly initialized volatile field, once you read the instance itself
> -- you can! -- we have seen this with AtomicIntegers before)


Aren't instance fields initialized in textual order according to JLS? It's
not clear to me how this would be allowed.  In particular, if volatile
writes in ctor are supposed to have same ordering constraints as final
field writes (that's supposedly going to be stated in next JMM revision),
how was it possible to see AtomicInteger field with default value?



>
>  3) Racy read of unordered write(f, 42):
>
>      (default) write(v,0)
>      (default) write(f,0)          write(f, 42)
>                   |                     .
>                   | hb/sw               . (unordered)
>                   v                     .
>                read(v):0 --hb/po--> read(f):42
>
>
> In other words, if we drop execution (1) by omitting the explicit
> initializing store, we would still be able to observe both "0" and "42".
>
> This seems to expand to non-instance fields, and other variables written
> before firing the field initializer.
>
> *** Putting all together
>
> Now, putting these things together:
>
>  * Case A tells that no variable written *after* the volatile instance
> field initializer is protected (duh).
>
>  * Case B tells that no variable written *before* the volatile instance
> field initializer writing the default value is protected by
> happens-before. This is because the explicit initializing store with the
> default value is indistinguishable from the default value store.
>
>  * Since Case A and Case B cover all possible variables (with the
> exception of the volatile field itself), this seems to imply that
> explicit field initializers that store default values have no effect on
> memory ordering.
>
> Is it a correct way to think about it?
>
> Thanks,
> -Aleksey
>
>

-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151217/b40aa6fd/attachment.html>

From aleksey.shipilev at oracle.com  Thu Dec 17 19:24:52 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 18 Dec 2015 03:24:52 +0300
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <CAHjP37ESZDeqGnv+t+=53fTh_8MTBq4FjSuM6yUgon7YJBS0rg@mail.gmail.com>
References: <56732AF9.7030109@oracle.com>
	<CAHjP37ESZDeqGnv+t+=53fTh_8MTBq4FjSuM6yUgon7YJBS0rg@mail.gmail.com>
Message-ID: <56735254.9010200@oracle.com>

On 12/18/2015 03:06 AM, Vitaly Davidovich wrote:
> On Thursday, December 17, 2015, Aleksey Shipilev
>      2) Read of default write(f, 0) -- these synchronize-with the first
>     action in the thread:
> 
>                            (default) write(v,0)
>                            (default) write(f,0)
>                                     |
>                                     | hb/sw
>                                     v
>                                  read(v):0 --hb/po--> read(f):0
> 
>      (One might wonder if that means you can see the default value for an
>     explicitly initialized volatile field, once you read the instance itself
>     -- you can! -- we have seen this with AtomicIntegers before)
> 
> Aren't instance fields initialized in textual order according to JLS?

Instance field initializers and instance initializers are run in the
lexical order, but this is irrelevant for:

> It's not clear to me how this would be allowed.  In particular, if
> volatile writes in ctor are supposed to have same ordering constraints
> as final field writes (that's supposedly going to be stated in next JMM
> revision), how was it possible to see AtomicInteger field with default
> value?

Volatile writes in constructors *are not* having the same ordering
constraints as final field writes. Some implementations might choose to
provide final-like behavior today, but it is not required by spec.

That remark was not supposed to re-fuel the discussion on volatile
writes in constructors themselves -- we seem to agree that's a problem,
we know that should be addressed in JMM update. Interested readers are
welcome to re-read the entire thread from the last time:

http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011954.html

But here, let's try to discuss the original "problem" with volatile
field initializers storing the default values with the current formal spec.

Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/6efd14f3/attachment-0001.bin>

From dl at cs.oswego.edu  Thu Dec 17 19:53:24 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 17 Dec 2015 19:53:24 -0500
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <56732AF9.7030109@oracle.com>
References: <56732AF9.7030109@oracle.com>
Message-ID: <56735904.2070902@cs.oswego.edu>

On 12/17/2015 04:36 PM, Aleksey Shipilev wrote:

>   * Since Case A and Case B cover all possible variables (with the
> exception of the volatile field itself), this seems to imply that
> explicit field initializers that store default values have no effect on
> memory ordering.
>
> Is it a correct way to think about it?
>

Yes. Without a machine-checkable JLS and JMM formalization, it's hard to prove
this definitively. But your account is a more careful version of reasoning
we've done before to conclude that there is never any reason to explicitly
initialize fields to 0/0.0/false/null. (There might be traces of these
discussions in the original JSR133 mail archives.)

Some people like to explicitly initialize to 0/0.0/false/null for clarity.
Arguably javac should not penalize this by generating unnecessary code.

-Doug



From jsampson at guidewire.com  Thu Dec 17 21:11:24 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Fri, 18 Dec 2015 02:11:24 +0000
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <56735904.2070902@cs.oswego.edu>
References: <56732AF9.7030109@oracle.com> <56735904.2070902@cs.oswego.edu>
Message-ID: <DM2PR0501MB87504F77145A18D4CE0E87AD1E10@DM2PR0501MB875.namprd05.prod.outlook.com>

Doug Lea wrote:

> Yes. Without a machine-checkable JLS and JMM formalization, it's
> hard to prove this definitively. But your account is a more
> careful version of reasoning we've done before to conclude that
> there is never any reason to explicitly initialize fields to
> 0/0.0/false/null. (There might be traces of these discussions in
> the original JSR133 mail archives.)

This seems like a specific instance of the more general question of
whether _any_ volatile write has visible memory ordering effects if
it doesn't actually change the value stored in memory. I remember a
discussion touching on that question back in January regarding the
semantics of a failed or no-op compareAndSet. Since the value is not
changed, there is no way for another thread to notice that anything
has happened, and therefore no other thread can _depend_ on any such
memory ordering effects for correctness -- at least in practical
terms, even if some specific executions happen to be ruled out.

That thread was "Varieties of CAS semantics" here:

http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/thread.html#13613

Cheers,
Justin


From thurston at nomagicsoftware.com  Thu Dec 17 20:30:07 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Thu, 17 Dec 2015 18:30:07 -0700 (MST)
Subject: [concurrency-interest] Explicitly initializing volatile fields
	with default values
In-Reply-To: <56732AF9.7030109@oracle.com>
References: <56732AF9.7030109@oracle.com>
Message-ID: <1450402207525-13097.post@n7.nabble.com>

What about


class B
{
    int f = 42;
    boolean initialized = true;
    volatile int v = 0;


}

B global;

Thread 1:
   global = new B();

 Thread 2:
   B b = global;
   if (b != null && b.initialized && b.v == 0) {
     print(b.f); // ?
   } 

I still think that the JMM allows either 0 or 42.

"There is a gut feeling that removing these initializations is *safe*"

But partly it comes down to your definition of "safe", i.e.

1.  Safe ==> spec-compliant
or
2.  Safe ==> no JVM presently in use will behave differently in the face of
initialization-to-default-value elision






--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Explicitly-initializing-volatile-fields-with-default-values-tp13093p13097.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From mr.chrisvest at gmail.com  Fri Dec 18 04:44:06 2015
From: mr.chrisvest at gmail.com (Chris Vest)
Date: Fri, 18 Dec 2015 10:44:06 +0100
Subject: [concurrency-interest] DirectByteBuffers and reachabilityFence
In-Reply-To: <1450364060762-13092.post@n7.nabble.com>
References: <566bdd0e.576d1c0a.a4b3e.4b93@mx.google.com>
	<ADEBD2F2-69B9-4D31-AE16-3F24C273F40D@azul.com>
	<566eb5c6.42661c0a.791a4.6594@mx.google.com>
	<79A94C94-E0B8-4D18-8D51-3885FEDEE693@azul.com>
	<00d401d136eb$e5303010$af909030$@net.au>
	<1450154871137-13077.post@n7.nabble.com>
	<566FE8C2.8020402@redhat.com>
	<CAHjP37ELSkpgUjYr=tjAvTaw3oTqGtHe9fdqm8nitDL9h_Xfiw@mail.gmail.com>
	<56701B80.3010002@redhat.com>
	<1A64124C-8449-41B2-A862-40B2CAEDA602@oracle.com>
	<1450364060762-13092.post@n7.nabble.com>
Message-ID: <BB4FA013-044C-4A7A-8C2E-4ECD30D61BE6@gmail.com>

Only if we never have to pay the cost of allocating the arguments array.

Cheers,
Chris

> On 17 Dec 2015, at 15:54, thurstonn <thurston at nomagicsoftware.com> wrote:
> 
> If possible, it would be convenient if #reachabilityFence were defined as
> varargs:
> 
> public static void reachabilityFence(Object...  refs)
> 
> as there are many cases (e.g. Hans Boehm provides one in this thread) where
> one would want to extend reachability to a set of objects to the same point. 
> I wouldn't think that any ordering guarantee need to be preserved in the
> case where multiple args were passed
> 
> I don't know the effect that might have upon the compiler
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/DirectByteBuffers-and-reachabilityFence-tp12935p13092.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/568a2067/attachment.html>

From aleksey.shipilev at oracle.com  Fri Dec 18 06:56:49 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 18 Dec 2015 14:56:49 +0300
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <1450402207525-13097.post@n7.nabble.com>
References: <56732AF9.7030109@oracle.com>
	<1450402207525-13097.post@n7.nabble.com>
Message-ID: <5673F481.50206@oracle.com>

On 12/18/2015 04:30 AM, thurstonn wrote:
> class B
> {
>     int f = 42;
>     boolean initialized = true;
>     volatile int v = 0;
> 
> 
> }
> 
> B global;
> 
> Thread 1:
>    global = new B();
> 
>  Thread 2:
>    B b = global;
>    if (b != null && b.initialized && b.v == 0) {
>      print(b.f); // ?
>    } 
> 
> I still think that the JMM allows either 0 or 42.

Yes, it does. I don't see how this case differs from the original case
without the "initialized" field. Moreover, since the $initialized read
is done before "acquiring" $v read, there is no effect whatsoever ;)


> "There is a gut feeling that removing these initializations is *safe*"
> 
> But partly it comes down to your definition of "safe", i.e.
> 
> 1.  Safe ==> spec-compliant
> or
> 2.  Safe ==> no JVM presently in use will behave differently in the face of
> initialization-to-default-value elision

I tried to frame a more formal question in the original note:

"Is there a plausible case that shows the semantical difference with
field initializer storing a default value, and without one, that does
*not* also affect single-threaded usages (i.e. it does not follow from
the instance initialization sequence itself)?"

The answer to which is, apparently, "no".

Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/10aac8b2/attachment.bin>

From aleksey.shipilev at oracle.com  Fri Dec 18 06:59:24 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Fri, 18 Dec 2015 14:59:24 +0300
Subject: [concurrency-interest] Explicitly initializing volatile fields
 with default values
In-Reply-To: <DM2PR0501MB87504F77145A18D4CE0E87AD1E10@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <56732AF9.7030109@oracle.com> <56735904.2070902@cs.oswego.edu>
	<DM2PR0501MB87504F77145A18D4CE0E87AD1E10@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <5673F51C.8030806@oracle.com>

On 12/18/2015 05:11 AM, Justin Sampson wrote:
> Doug Lea wrote:
> 
>> Yes. Without a machine-checkable JLS and JMM formalization, it's
>> hard to prove this definitively. But your account is a more
>> careful version of reasoning we've done before to conclude that
>> there is never any reason to explicitly initialize fields to
>> 0/0.0/false/null. (There might be traces of these discussions in
>> the original JSR133 mail archives.)

Excellent, then we will go forward with pruning stray volatile stores
with default values from JDK:
 https://bugs.openjdk.java.net/browse/JDK-6736490
 https://bugs.openjdk.java.net/browse/JDK-8145680


> This seems like a specific instance of the more general question of
> whether _any_ volatile write has visible memory ordering effects if
> it doesn't actually change the value stored in memory. I remember a
> discussion touching on that question back in January regarding the
> semantics of a failed or no-op compareAndSet. Since the value is not
> changed, there is no way for another thread to notice that anything
> has happened, and therefore no other thread can _depend_ on any such
> memory ordering effects for correctness -- at least in practical
> terms, even if some specific executions happen to be ruled out.

Indeed, this default values case seems to be a special subcase of that
general observation.


> That thread was "Varieties of CAS semantics" here:
> 
> http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/thread.html#13613

Thanks! Good read.

Cheers,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/e2d832cc/attachment.bin>

From tim at peierls.net  Fri Dec 18 10:57:02 2015
From: tim at peierls.net (Tim Peierls)
Date: Fri, 18 Dec 2015 10:57:02 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <56720923.80502@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu>
Message-ID: <CA+F8eeQP0=Ljq2PgbXkqmtc6dsYOOhHC8n5Nhqo06ptwCK-pDw@mail.gmail.com>

I'm confused: whenComplete takes a BiConsumer, not a BiFunction, so it
can't return a value. I can't get the survey question code to compile.

On Wed, Dec 16, 2015 at 8:00 PM, Doug Lea <dl at cs.oswego.edu> wrote:

>
> Ever since Chris Purcell helpfully pointed out last summer that we
> should not drop nested exceptions in whenComplete, we've stalled
> incorporating changes. There are some good arguments for each of
> two options, that affects only a single line of code.
> (We've ruled out some other options.)
>
> Even though this is a corner case issue with low impact, we'd like
> to choose the best option we can. So please help us out by
> responding to this SurveyMonkey survey before Saturday
> morning (19 December).
>
>   https://www.surveymonkey.com/r/3D2L9DR
>
> Thanks!
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151218/25319a89/attachment-0001.html>

From dl at cs.oswego.edu  Fri Dec 18 11:14:38 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 18 Dec 2015 11:14:38 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CA+F8eeQP0=Ljq2PgbXkqmtc6dsYOOhHC8n5Nhqo06ptwCK-pDw@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu>
	<CA+F8eeQP0=Ljq2PgbXkqmtc6dsYOOhHC8n5Nhqo06ptwCK-pDw@mail.gmail.com>
Message-ID: <567430EE.5000608@cs.oswego.edu>

On 12/18/2015 10:57 AM, Tim Peierls wrote:
> I'm confused: whenComplete takes a BiConsumer, not a BiFunction, so it can't
> return a value. I can't get the survey question code to compile.

Sorry. The "return" with values should just say "return". They
don't get executed in the case in question.
Non-compilability is an accidental feature of the survey.

-Doug

>
> On Wed, Dec 16, 2015 at 8:00 PM, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:
>
>
>     Ever since Chris Purcell helpfully pointed out last summer that we
>     should not drop nested exceptions in whenComplete, we've stalled
>     incorporating changes. There are some good arguments for each of
>     two options, that affects only a single line of code.
>     (We've ruled out some other options.)
>
>     Even though this is a corner case issue with low impact, we'd like
>     to choose the best option we can. So please help us out by
>     responding to this SurveyMonkey survey before Saturday
>     morning (19 December).
>
>     https://www.surveymonkey.com/r/3D2L9DR
>
>     Thanks!
>
>     -Doug
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From thurston at nomagicsoftware.com  Fri Dec 18 13:26:47 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Fri, 18 Dec 2015 11:26:47 -0700 (MST)
Subject: [concurrency-interest] Explicitly initializing volatile fields
	with default values
In-Reply-To: <5673F481.50206@oracle.com>
References: <56732AF9.7030109@oracle.com>
	<1450402207525-13097.post@n7.nabble.com>
	<5673F481.50206@oracle.com>
Message-ID: <1450463207038-13104.post@n7.nabble.com>

Aleksey Shipilev-2 wrote
> On 12/18/2015 04:30 AM, thurstonn wrote:
>> class B
>> {
>>     int f = 42;
>>     boolean initialized = true;
>>     volatile int v = 0;
>> 
>> 
>> }
>> 
>> B global;
>> 
>> Thread 1:
>>    global = new B();
>> 
>>  Thread 2:
>>    B b = global;
>>    if (b != null && b.initialized && b.v == 0) {
>>      print(b.f); // ?
>>    } 
>> 
>> I still think that the JMM allows either 0 or 42.
> 
> Yes, it does. I don't see how this case differs from the original case
> without the "initialized" field. Moreover, since the $initialized read
> is done before "acquiring" $v read, there is no effect whatsoever ;)

The order of the $initialized read wrt to the $v read is irrelevant to the
point I was making, i.e. if the code was:

if (b != null && b.v == 0 && b.initialized) 
{
      print(b.f); // ?
}
the point would be the same.
Why?  because we're in agreement that no synchronizes-with edge can be
deduced from the program, so in terms of the JMM (which is what I meant by
spec-compliance), 
<r(initialized), T2, true> tells you nothing about 
<r(f), T2, ?>


But in reference to definition of "safe" (#2 below) compare:

1.  Elide the initializing write of $v
  vs.
2.  There is some store fence emitted between the initializing write to
$initialized = true and $v=0

I was merely positing on some platform(s),
in case 1 ==>
<r(initialized), T2, true> tells you nothing about 
<r(f), T2, ?>

but in case 2 ==>
<r(initialized), T2, true> always results in:
<r(f), T2, 42>

again, not as dictated by the JMM, but by a particular platform's
implementation/behavior of the JMM; producing a stronger memory model than
required.

If such a platform exists, then eliding the initializing $v = 0, hence
eliding the store fence (#1 above), changes the possible results of program
executions (which would be "unsafe" in the sense of #2 below)








> "There is a gut feeling that removing these initializations is *safe*"
> 
> But partly it comes down to your definition of "safe", i.e.
> 
> 1.  Safe ==> spec-compliant
> or
> 2.  Safe ==> no JVM presently in use will behave differently in the face
> of
> initialization-to-default-value elision

I tried to frame a more formal question in the original note:

"Is there a plausible case that shows the semantical difference with
field initializer storing a default value, and without one, that does
*not* also affect single-threaded usages (i.e. it does not follow from
the instance initialization sequence itself)?"

The answer to which is, apparently, "no".

Thanks,
-Aleksey



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at .oswego
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


signature.asc (836 bytes)
&lt;http://jsr166-concurrency.10961.n7.nabble.com/attachment/13100/0/signature.asc&gt;





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Explicitly-initializing-volatile-fields-with-default-values-tp13093p13104.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From dl at cs.oswego.edu  Sat Dec 19 08:08:07 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 19 Dec 2015 08:08:07 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <56720923.80502@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu>
Message-ID: <567556B7.6080407@cs.oswego.edu>


Thanks to the 71 people who answered the survey. The majority (52)
voted for the second option. To recap, here's the (fixed) question:

   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
      if (true)
         throw new FirstException();
      else
         return "A"; });

   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
      if (exception != null) {
         if (true)
            throw new SecondException();
          else
            return;
      }
      else
         return; });

(where "true" stands in for some error condition).

What should the completed value of f2 be?

19: The FirstException, with the SecondException as suppressed exception
52: The SecondException, with the FirstException as suppressed exception

The vote was closer among the 29 people who filled out the optional
rationale, but still favoring the second.

One consideration differentiating votes is whether SecondException was
viewed as intentional versus the result of a programming error or
cleanup artifact. Regardless of vote outcome, throwing an exception in an
exception handler (in CompletableFutures or elsewhere) is likely to
surprise some users.

The most detailed rationale, by Tim Peierls, was
long enough that he had to place it elsewhere:
   https://gist.github.com/Tembrel/68d5670bf37824d55078

Others are below.

...

to me, it's as if the lambda is wrapped in a try-catch, with the `if (exception 
!= null)` block as the catch. As this doesn't rethrow the FirstException, f2 
should contain the thrown SecondException.

...

the most recent exception should be first, with prior ones nested

...

whenComplete shouldn't allow overwriting a normal result with a different normal 
result despite what the example code implies. Nor should it allow replacing an 
exceptional result with a different exceptional result, but going with the 
second option would be same as specifying just that, with an added wrinkle that 
the replacement exception is modified to suppress the original if it doesn't do 
that already.

...

the first exception was "handled" by the whenComplete, but not successfully

...

By using whenComplete, the user is declaring an expectation that FirstException 
may occur and are saying "I'll handle it." They haven't declared they will 
handle SecondException, so that one seems more likely (than the first) to be a 
programming error, and more important to call out.

...

per "then the returned stage exceptionally completes with this exception unless 
this stage also completed exceptionally." unless is the key word indicating f1 
exception has primacy.

...

This matches the current behavior (aside from the additional suppressed 
exception, of course). It also matches try-with-resources, the other main case 
for suppressed exceptions. (It consequently doesn't match try-finally, but we 
can match only one of the two, and try-with-resources, besides being the one 
that uses suppressed exceptions, is newer and (debatably) a replacement for most 
existing try-finally blocks.) But I admit that the try-with-resources and 
try-finally analogies aren't perfect for whenComplete(): whenComplete() has 
access to the result, but the try-with-resources close() implementation and the 
try-finally's finally do not. If whenComplete() is intended to handle other use 
cases, then those use cases may have different requirements.

...

As long as application code has the opportunity to be aware of the first 
exception and take action, it's not suppressed. Suppressing the second exception 
would mean no application code has the opportunity to even be aware of it.

...

since I specifically handle FirstException and decide to throw SecondException 
that would be the one that I expect at the end

...

f2 was supposed to handle exception from f1, but failed, so we throw 
SecondException. To not lose data, we suppress FirstException

...

First exception is likely to be the cause of a whole issue.

...

1. The contract of F2 is throw SecondException, not FirstException. 2. The 
implementor is knowingly suppressing FirstException, similar supplying the 
caused by exception when wrapping a thrown exception.

...

It should be treated the same way, when FirstException occurred in a try-block 
and SecondException occurred in finally block. I think the try-exception is the 
one which is thrown and the finally-exception is added to it as suppressed.

...

It is the least change to the current semantics; it matches the behaviour of 
try-with-resources; it lets you write a stage that releases resources without 
worrying about the exceptional path of the main code.

...
It should be isomorphic to throwing an exception in a catch block.

...

The second exception is further down the line and one can think of it as the 
transformation of the first exception, i.e., closest failure first (similar to 
how printStackTrace prints the closest method first, not the Thread's starting 
method). The third option would be to introduce some CompositeException that 
will get both exceptions suppressed, in timely order. Besides, a fluent 
java.util.concurrent.Flow library does this when lambdas crash on the onError path.

...

SecondException is the one that is last thrown.

...

For f2, SecondException is the primary exception (at the top of the ladder), and 
everything else must trail behind in the context of historicity

...

I can see reasons for both options, but in the end, I think that the caller of 
oncomplete passes in a lambda which may have a known and well defined set of 
throws, thus they are entitled to expect that f2 will only have values that can 
be thrown by the lambda

...

For consistency as an async version of a try-catch-finally block. Here "then" == 
try; "exceptionally" == catch; "when"/"handle" == finally.

...

[Option 1] mirrors try-with-resources and (arguably) is how try-finally should 
have been specified when both the try and finally blocks throw.

...

At first glance, I was viewing exception2 as the suppressed one, but then I 
wondered what happens in a chain of exceptional completions. Do suppressed 
exceptions chain? That is, what happens in a chain of exceptional completions? 
Is there a way to draw an analogy to a nesting of ARM statements? On second or 
third thought, I don't see the need for suppressed exceptions here, and worry a 
little bit about creating one automatically. I say there is not a real 
suppressed exception in this case because the first exception is "explicit" in 
the completion arguments. However, there is a chance that the earlier exception 
won't be handled by the completion code, and will be lost. And so, as a nicety 
(B) the first exception could be added as a suppressed exception of exception2.

...

Order of execution makes me feel like an exception from f1 should be the root, 
and f2 be the suppressed exception.

...

The implementor of f2 is explicitly handling the exception from f1 and throwing 
a new one. That one is the one that matters to the client of f2, at least from 
f2's perspective.

...

No time travelling to change history!

...

When ever an in-flight exception gets replaced it should become a suppressed 
exception of the new exception.

...

try-with-resources will add exceptions from close() as suppressed exceptions.







From joe.bowbeer at gmail.com  Sat Dec 19 08:40:27 2015
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 19 Dec 2015 05:40:27 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <567556B7.6080407@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu>
	<567556B7.6080407@cs.oswego.edu>
Message-ID: <CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>

I'm still holding out for option C: none of the above.  (Also I want access
to the voter database!)

The concerns that I didn't express very well in my survey response are:

1. That exception1 is not "suppressed" because it has already been
delivered to user code.

I think the comparison with ARM try-with-resources breaks down because in
try-with-resources the exception *is* suppressed by the framework, and
would otherwise go unreported.

2. The completion handler receiving exception1 may not want it to reach the
next stage, even via getSuppressedExceptions.

--Joe

On Sat, Dec 19, 2015 at 5:08 AM, Doug Lea <dl at cs.oswego.edu> wrote:

>
> Thanks to the 71 people who answered the survey. The majority (52)
> voted for the second option. To recap, here's the (fixed) question:
>
>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>      if (true)
>         throw new FirstException();
>      else
>         return "A"; });
>
>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
>      if (exception != null) {
>         if (true)
>            throw new SecondException();
>          else
>            return;
>      }
>      else
>         return; });
>
> (where "true" stands in for some error condition).
>
> What should the completed value of f2 be?
>
> 19: The FirstException, with the SecondException as suppressed exception
> 52: The SecondException, with the FirstException as suppressed exception
>
> The vote was closer among the 29 people who filled out the optional
> rationale, but still favoring the second.
>
> One consideration differentiating votes is whether SecondException was
> viewed as intentional versus the result of a programming error or
> cleanup artifact. Regardless of vote outcome, throwing an exception in an
> exception handler (in CompletableFutures or elsewhere) is likely to
> surprise some users.
>
> The most detailed rationale, by Tim Peierls, was
> long enough that he had to place it elsewhere:
>   https://gist.github.com/Tembrel/68d5670bf37824d55078
>
> Others are below.
>
> ...
>
> to me, it's as if the lambda is wrapped in a try-catch, with the `if
> (exception != null)` block as the catch. As this doesn't rethrow the
> FirstException, f2 should contain the thrown SecondException.
>
> ...
>
> the most recent exception should be first, with prior ones nested
>
> ...
>
> whenComplete shouldn't allow overwriting a normal result with a different
> normal result despite what the example code implies. Nor should it allow
> replacing an exceptional result with a different exceptional result, but
> going with the second option would be same as specifying just that, with an
> added wrinkle that the replacement exception is modified to suppress the
> original if it doesn't do that already.
>
> ...
>
> the first exception was "handled" by the whenComplete, but not successfully
>
> ...
>
> By using whenComplete, the user is declaring an expectation that
> FirstException may occur and are saying "I'll handle it." They haven't
> declared they will handle SecondException, so that one seems more likely
> (than the first) to be a programming error, and more important to call out.
>
> ...
>
> per "then the returned stage exceptionally completes with this exception
> unless this stage also completed exceptionally." unless is the key word
> indicating f1 exception has primacy.
>
> ...
>
> This matches the current behavior (aside from the additional suppressed
> exception, of course). It also matches try-with-resources, the other main
> case for suppressed exceptions. (It consequently doesn't match try-finally,
> but we can match only one of the two, and try-with-resources, besides being
> the one that uses suppressed exceptions, is newer and (debatably) a
> replacement for most existing try-finally blocks.) But I admit that the
> try-with-resources and try-finally analogies aren't perfect for
> whenComplete(): whenComplete() has access to the result, but the
> try-with-resources close() implementation and the try-finally's finally do
> not. If whenComplete() is intended to handle other use cases, then those
> use cases may have different requirements.
>
> ...
>
> As long as application code has the opportunity to be aware of the first
> exception and take action, it's not suppressed. Suppressing the second
> exception would mean no application code has the opportunity to even be
> aware of it.
>
> ...
>
> since I specifically handle FirstException and decide to throw
> SecondException that would be the one that I expect at the end
>
> ...
>
> f2 was supposed to handle exception from f1, but failed, so we throw
> SecondException. To not lose data, we suppress FirstException
>
> ...
>
> First exception is likely to be the cause of a whole issue.
>
> ...
>
> 1. The contract of F2 is throw SecondException, not FirstException. 2. The
> implementor is knowingly suppressing FirstException, similar supplying the
> caused by exception when wrapping a thrown exception.
>
> ...
>
> It should be treated the same way, when FirstException occurred in a
> try-block and SecondException occurred in finally block. I think the
> try-exception is the one which is thrown and the finally-exception is added
> to it as suppressed.
>
> ...
>
> It is the least change to the current semantics; it matches the behaviour
> of try-with-resources; it lets you write a stage that releases resources
> without worrying about the exceptional path of the main code.
>
> ...
> It should be isomorphic to throwing an exception in a catch block.
>
> ...
>
> The second exception is further down the line and one can think of it as
> the transformation of the first exception, i.e., closest failure first
> (similar to how printStackTrace prints the closest method first, not the
> Thread's starting method). The third option would be to introduce some
> CompositeException that will get both exceptions suppressed, in timely
> order. Besides, a fluent java.util.concurrent.Flow library does this when
> lambdas crash on the onError path.
>
> ...
>
> SecondException is the one that is last thrown.
>
> ...
>
> For f2, SecondException is the primary exception (at the top of the
> ladder), and everything else must trail behind in the context of historicity
>
> ...
>
> I can see reasons for both options, but in the end, I think that the
> caller of oncomplete passes in a lambda which may have a known and well
> defined set of throws, thus they are entitled to expect that f2 will only
> have values that can be thrown by the lambda
>
> ...
>
> For consistency as an async version of a try-catch-finally block. Here
> "then" == try; "exceptionally" == catch; "when"/"handle" == finally.
>
> ...
>
> [Option 1] mirrors try-with-resources and (arguably) is how try-finally
> should have been specified when both the try and finally blocks throw.
>
> ...
>
> At first glance, I was viewing exception2 as the suppressed one, but then
> I wondered what happens in a chain of exceptional completions. Do
> suppressed exceptions chain? That is, what happens in a chain of
> exceptional completions? Is there a way to draw an analogy to a nesting of
> ARM statements? On second or third thought, I don't see the need for
> suppressed exceptions here, and worry a little bit about creating one
> automatically. I say there is not a real suppressed exception in this case
> because the first exception is "explicit" in the completion arguments.
> However, there is a chance that the earlier exception won't be handled by
> the completion code, and will be lost. And so, as a nicety (B) the first
> exception could be added as a suppressed exception of exception2.
>
> ...
>
> Order of execution makes me feel like an exception from f1 should be the
> root, and f2 be the suppressed exception.
>
> ...
>
> The implementor of f2 is explicitly handling the exception from f1 and
> throwing a new one. That one is the one that matters to the client of f2,
> at least from f2's perspective.
>
> ...
>
> No time travelling to change history!
>
> ...
>
> When ever an in-flight exception gets replaced it should become a
> suppressed exception of the new exception.
>
> ...
>
> try-with-resources will add exceptions from close() as suppressed
> exceptions.
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/b8352379/attachment-0001.html>

From dl at cs.oswego.edu  Sat Dec 19 09:15:18 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 19 Dec 2015 09:15:18 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
Message-ID: <56756676.3040608@cs.oswego.edu>

On 12/19/2015 08:40 AM, Joe Bowbeer wrote:
> I'm still holding out for option C: none of the above.  (Also I want access
> to the voter database!)

I set it up as anonymous.

> 2. The completion handler receiving exception1 may not want it to reach the
> next stage, even via getSuppressedExceptions.
>

In which case, why not use CF.handle to perform arbitrary outcome translation?

> 1. That exception1 is not "suppressed" because it has already been delivered
> to user code.

This always holds for a suppressed exception -- some code catches it
but then does addSuppressed. The term "suppressed" is not perfect here:
   "e1 with suppressed e2"
is treated in nearly the same way as
   "e2 with cause e1",
but with roles swapped.

Martin suggested (on core-libs-dev) an alternative that might reduce
confusion. Or might not. Thoughts welcome.

On 12/18/2015 02:08 PM, Martin Buchholz wrote:
> Instead of calling addSuppressed on the source exception, call
> addSuppressed on the wrapping CompletionException.  This has the
> upside that the integrity of both original exceptions is maintained,
> but the downside that the suppressed exception is likely to be
> discarded since the CompletionException is "just a wrapper".  In fact,
> get() will do that.  But we can modify reportGet to transfer any
> suppressed exceptions from the CompletionException to the
> ExecutionException, somewhat mitigating this problem, at the cost of a
> small tax on all users of get() who encounter abnormal completion.  As
> to which exception gets to be the cause and which the suppressed, I
> still think it makes sense for the action exception to be the cause
> and the source exception to be suppressed, by analogy with "finally".



From chris.purcell.39 at gmail.com  Sat Dec 19 11:16:04 2015
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Sat, 19 Dec 2015 16:16:04 +0000
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <56756676.3040608@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
Message-ID: <CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>

The second option surprised me, as we now have a fourth approach to
suppressed exceptions in Java: try/finally (throw away A),
try-with-resources (suppress B), j8 whenComplete (throw away B) and j9+
whenComplete (suppress A). Isn't this unnecessarily complicated? Why not
behave like a finally block, and let the user add A as a suppressed
exception if they want it?

WhenComplete seems like the only way to reliably close resources in async
code, so I expected it to work like try-with-resources. That seems to be
the point of contention for others too. Perhaps there should be another
method for this use-case instead? One which takes a simple runnable and
suppresses any exception it throws.

Thanks!
Chris

On Sat, 19 Dec 2015 14:38 Doug Lea <dl at cs.oswego.edu> wrote:

> On 12/19/2015 08:40 AM, Joe Bowbeer wrote:
> > I'm still holding out for option C: none of the above.  (Also I want
> access
> > to the voter database!)
>
> I set it up as anonymous.
>
> > 2. The completion handler receiving exception1 may not want it to reach
> the
> > next stage, even via getSuppressedExceptions.
> >
>
> In which case, why not use CF.handle to perform arbitrary outcome
> translation?
>
> > 1. That exception1 is not "suppressed" because it has already been
> delivered
> > to user code.
>
> This always holds for a suppressed exception -- some code catches it
> but then does addSuppressed. The term "suppressed" is not perfect here:
>    "e1 with suppressed e2"
> is treated in nearly the same way as
>    "e2 with cause e1",
> but with roles swapped.
>
> Martin suggested (on core-libs-dev) an alternative that might reduce
> confusion. Or might not. Thoughts welcome.
>
> On 12/18/2015 02:08 PM, Martin Buchholz wrote:
> > Instead of calling addSuppressed on the source exception, call
> > addSuppressed on the wrapping CompletionException.  This has the
> > upside that the integrity of both original exceptions is maintained,
> > but the downside that the suppressed exception is likely to be
> > discarded since the CompletionException is "just a wrapper".  In fact,
> > get() will do that.  But we can modify reportGet to transfer any
> > suppressed exceptions from the CompletionException to the
> > ExecutionException, somewhat mitigating this problem, at the cost of a
> > small tax on all users of get() who encounter abnormal completion.  As
> > to which exception gets to be the cause and which the suppressed, I
> > still think it makes sense for the action exception to be the cause
> > and the source exception to be suppressed, by analogy with "finally".
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/1ff42cc6/attachment.html>

From tim at peierls.net  Sat Dec 19 11:40:47 2015
From: tim at peierls.net (Tim Peierls)
Date: Sat, 19 Dec 2015 11:40:47 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
Message-ID: <CA+F8eeTRLMZJ4ojbbA33B7eY=7ciwk=tuGAFGSf44fJFUvRwOQ@mail.gmail.com>

On Sat, Dec 19, 2015 at 11:16 AM, Chris Purcell <chris.purcell.39 at gmail.com>
wrote:

> The second option surprised me, as we now have a fourth approach to
> suppressed exceptions in Java: try/finally (throw away A),
> try-with-resources (suppress B), j8 whenComplete (throw away B) and j9+
> whenComplete (suppress A). Isn't this unnecessarily complicated?
>
Like Joe, I would have voted against suppression if that had been given as
a survey option.


> Why not behave like a finally block, and let the user add A as a
> suppressed exception if they want it?
>
Is this opt-in behavior not achievable with a wrapper? (Assuming
survey-option-2-without-suppression semantics.)

    public static <T> BiConsumer<T, Throwable> suppressEarlierException(
            BiConsumer<? super T, ? super Throwable> action) {

        return (r1, ex1) -> {
            try {
                action.accept(r1, ex1);
            } catch (Throwable ex2) {
                ex2.addSuppressed(ex1);
                throw ex2;
            }
        };
    }


> WhenComplete seems like the only way to reliably close resources in async
> code, so I expected it to work like try-with-resources. That seems to be
> the point of contention for others too. Perhaps there should be another
> method for this use-case instead? One which takes a simple runnable and
> suppresses any exception it throws.
>
I don't see why CF.handle(BiFunction) isn't already sufficient for
providing any behavior you want here.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/ba80c87d/attachment.html>

From timo.kinnunen at gmail.com  Sat Dec 19 11:40:44 2015
From: timo.kinnunen at gmail.com (Timo Kinnunen)
Date: Sat, 19 Dec 2015 17:40:44 +0100
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <567556B7.6080407@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
Message-ID: <5675888f.cdb81c0a.9debb.2996@mx.google.com>

Hi, 

Interesting and unexpected results, and thanks especially to everyone who provided a rationale.

I?d like to point out that the question posed in the survey isn?t the only one that needs to be considered when deciding the whenComplete method contract. A BiConsumer that rethrows the same FirstException, or throws a SecondException which has the FirstException as its cause, or throws a SecondException which suppresses the FirstException are also possibilities that must be taken into account.

That said, what I take away from the results is that there?s too much overlap between the whenComplete(BiConsumer) method and the handle(BiFunction) method. As several responses which mentioned handling indicates, it?s not clear where the responsibilities of handle end and whenComplete?s begin. The uncorrected code in the survey itself confused the two methods with each other, too! So my recommendations would then be:

- Specify the whenComplete methods in terms of the handle method.
- Rewrite the implementations of the whenComplete method to forward the call to the handle methods.
- And then deprecate whenComplete.

With this it becomes readily apparent which method to use when you want to react to the exceptional result as well and it?s clear what happens if your BiFunction throws an exception, regardless of if it was thrown intentionally or due to a bug.








-- 
Have a nice day, 
Timo

Sent from Mail for Windows 10


From: Doug Lea
Sent: Saturday, December 19, 2015 14:17
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] CompletableFuture.whenComplete survey


Thanks to the 71 people who answered the survey. The majority (52)
voted for the second option. To recap, here's the (fixed) question:

   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
      if (true)
         throw new FirstException();
      else
         return "A"; });

   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
      if (exception != null) {
         if (true)
            throw new SecondException();
          else
            return;
      }
      else
         return; });

(where "true" stands in for some error condition).

What should the completed value of f2 be?

19: The FirstException, with the SecondException as suppressed exception
52: The SecondException, with the FirstException as suppressed exception

The vote was closer among the 29 people who filled out the optional
rationale, but still favoring the second.

One consideration differentiating votes is whether SecondException was
viewed as intentional versus the result of a programming error or
cleanup artifact. Regardless of vote outcome, throwing an exception in an
exception handler (in CompletableFutures or elsewhere) is likely to
surprise some users.

The most detailed rationale, by Tim Peierls, was
long enough that he had to place it elsewhere:
   https://gist.github.com/Tembrel/68d5670bf37824d55078

Others are below.

...

to me, it's as if the lambda is wrapped in a try-catch, with the `if (exception 
!= null)` block as the catch. As this doesn't rethrow the FirstException, f2 
should contain the thrown SecondException.

...

the most recent exception should be first, with prior ones nested

...

whenComplete shouldn't allow overwriting a normal result with a different normal 
result despite what the example code implies. Nor should it allow replacing an 
exceptional result with a different exceptional result, but going with the 
second option would be same as specifying just that, with an added wrinkle that 
the replacement exception is modified to suppress the original if it doesn't do 
that already.

...

the first exception was "handled" by the whenComplete, but not successfully

...

By using whenComplete, the user is declaring an expectation that FirstException 
may occur and are saying "I'll handle it." They haven't declared they will 
handle SecondException, so that one seems more likely (than the first) to be a 
programming error, and more important to call out.

...

per "then the returned stage exceptionally completes with this exception unless 
this stage also completed exceptionally." unless is the key word indicating f1 
exception has primacy.

...

This matches the current behavior (aside from the additional suppressed 
exception, of course). It also matches try-with-resources, the other main case 
for suppressed exceptions. (It consequently doesn't match try-finally, but we 
can match only one of the two, and try-with-resources, besides being the one 
that uses suppressed exceptions, is newer and (debatably) a replacement for most 
existing try-finally blocks.) But I admit that the try-with-resources and 
try-finally analogies aren't perfect for whenComplete(): whenComplete() has 
access to the result, but the try-with-resources close() implementation and the 
try-finally's finally do not. If whenComplete() is intended to handle other use 
cases, then those use cases may have different requirements.

...

As long as application code has the opportunity to be aware of the first 
exception and take action, it's not suppressed. Suppressing the second exception 
would mean no application code has the opportunity to even be aware of it.

...

since I specifically handle FirstException and decide to throw SecondException 
that would be the one that I expect at the end

...

f2 was supposed to handle exception from f1, but failed, so we throw 
SecondException. To not lose data, we suppress FirstException

...

First exception is likely to be the cause of a whole issue.

...

1. The contract of F2 is throw SecondException, not FirstException. 2. The 
implementor is knowingly suppressing FirstException, similar supplying the 
caused by exception when wrapping a thrown exception.

...

It should be treated the same way, when FirstException occurred in a try-block 
and SecondException occurred in finally block. I think the try-exception is the 
one which is thrown and the finally-exception is added to it as suppressed.

...

It is the least change to the current semantics; it matches the behaviour of 
try-with-resources; it lets you write a stage that releases resources without 
worrying about the exceptional path of the main code.

...
It should be isomorphic to throwing an exception in a catch block.

...

The second exception is further down the line and one can think of it as the 
transformation of the first exception, i.e., closest failure first (similar to 
how printStackTrace prints the closest method first, not the Thread's starting 
method). The third option would be to introduce some CompositeException that 
will get both exceptions suppressed, in timely order. Besides, a fluent 
java.util.concurrent.Flow library does this when lambdas crash on the onError path.

...

SecondException is the one that is last thrown.

...

For f2, SecondException is the primary exception (at the top of the ladder), and 
everything else must trail behind in the context of historicity

...

I can see reasons for both options, but in the end, I think that the caller of 
oncomplete passes in a lambda which may have a known and well defined set of 
throws, thus they are entitled to expect that f2 will only have values that can 
be thrown by the lambda

...

For consistency as an async version of a try-catch-finally block. Here "then" == 
try; "exceptionally" == catch; "when"/"handle" == finally.

...

[Option 1] mirrors try-with-resources and (arguably) is how try-finally should 
have been specified when both the try and finally blocks throw.

...

At first glance, I was viewing exception2 as the suppressed one, but then I 
wondered what happens in a chain of exceptional completions. Do suppressed 
exceptions chain? That is, what happens in a chain of exceptional completions? 
Is there a way to draw an analogy to a nesting of ARM statements? On second or 
third thought, I don't see the need for suppressed exceptions here, and worry a 
little bit about creating one automatically. I say there is not a real 
suppressed exception in this case because the first exception is "explicit" in 
the completion arguments. However, there is a chance that the earlier exception 
won't be handled by the completion code, and will be lost. And so, as a nicety 
(B) the first exception could be added as a suppressed exception of exception2.

...

Order of execution makes me feel like an exception from f1 should be the root, 
and f2 be the suppressed exception.

...

The implementor of f2 is explicitly handling the exception from f1 and throwing 
a new one. That one is the one that matters to the client of f2, at least from 
f2's perspective.

...

No time travelling to change history!

...

When ever an in-flight exception gets replaced it should become a suppressed 
exception of the new exception.

...

try-with-resources will add exceptions from close() as suppressed exceptions.






_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/585c6cba/attachment-0001.html>

From chris.purcell.39 at gmail.com  Sat Dec 19 12:16:56 2015
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Sat, 19 Dec 2015 17:16:56 +0000
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CA+F8eeTRLMZJ4ojbbA33B7eY=7ciwk=tuGAFGSf44fJFUvRwOQ@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<CA+F8eeTRLMZJ4ojbbA33B7eY=7ciwk=tuGAFGSf44fJFUvRwOQ@mail.gmail.com>
Message-ID: <CAJUoZVYEquBnXmp65aBmQ0aOEUKdY73yECiv44089+Q3FSC+YA@mail.gmail.com>

On Sat, 19 Dec 2015 16:40 Tim Peierls <tim at peierls.net> wrote:

> On Sat, Dec 19, 2015 at 11:16 AM, Chris Purcell <
> chris.purcell.39 at gmail.com> wrote:
>
>> Why not behave like a finally block, and let the user add A as a
>> suppressed exception if they want it?
>>
> Is this opt-in behavior not achievable with a wrapper? (Assuming
> survey-option-2-without-suppression semantics.)
>

Yep, that's exactly what I meant, thanks for the impl!


> WhenComplete seems like the only way to reliably close resources in async
>> code, so I expected it to work like try-with-resources. That seems to be
>> the point of contention for others too. Perhaps there should be another
>> method for this use-case instead? One which takes a simple runnable and
>> suppresses any exception it throws.
>>
> I don't see why CF.handle(BiFunction) isn't already sufficient for
> providing any behavior you want here.
>

In fact, the non-suppressing-option-2 whenComplete would be sufficient to
implement it. However, it's a lot of boilerplate for a common use-case, and
easy to get viciously wrong, as modifying the result of a previous stage
(even an exception) is a bug: you need to carefully clone the exception
with serialisation. I would expect there to be a default implementation
that does the obvious (painful) delegation. (And I would expect a lot of
effort to go into optimising the CompletableFuture version to avoid the
clone if it isn't needed.)

Cheers,
Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/7f9fa5bd/attachment.html>

From dl at cs.oswego.edu  Sat Dec 19 12:54:15 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 19 Dec 2015 12:54:15 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
Message-ID: <567599C7.9010906@cs.oswego.edu>

On 12/19/2015 11:16 AM, Chris Purcell wrote:
> The second option surprised me, as we now have a fourth approach to suppressed
> exceptions in Java: try/finally (throw away A), try-with-resources (suppress B),
> j8 whenComplete (throw away B) and j9+ whenComplete (suppress A).

Actually, at the moment, our jsr166 version suppresses B.
Nothing has changed in our codebase since the a.addSuppressed(b)
fix. We were about this to commit to OpenJDK when further questions emerged,
leading to survey. My plans were to check for any new ideas or
over-my-dead-body reactions stemming from survey before changing.

Also, to recap related core-libs-dev discussions: The initial suggestion
to serialize or clone A doesn't work well with some user Throwable
classes. So reflection-based pseudo-cloning should be treated as
a desperation move, avoided when there are other options.
It was also pointed out that with a.addSuppressed(b), the call
might occur while exception a is being processed in another thread.
Which might be surprising, but is thread-safe and not in itself
a compelling reason not to do it.

>
> WhenComplete seems like the only way to reliably close resources in async code,

This was among initial motivations (see list archives mainly in December 2012).

But as it turns out from survey, a lot of people expect or want it to
behave more like handle(). Which is a different issue than the one
you first raised.

-Doug


From martinrb at google.com  Sat Dec 19 12:58:32 2015
From: martinrb at google.com (Martin Buchholz)
Date: Sat, 19 Dec 2015 09:58:32 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <56756676.3040608@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
Message-ID: <CA+kOe08YnUdpBCJkNi6sbyUfoXTBnmZY-O5z-yONRvVkwEaZ4A@mail.gmail.com>

On Sat, Dec 19, 2015 at 6:15 AM, Doug Lea <dl at cs.oswego.edu> wrote:
> On 12/19/2015 08:40 AM, Joe Bowbeer wrote:

>> 1. That exception1 is not "suppressed" because it has already been
>> delivered
>> to user code.
>
>
> This always holds for a suppressed exception -- some code catches it
> but then does addSuppressed.

Unsurprisingly, I agree with Joe here.  For try-with-resources it is
hard for real user code to directly handle the failure from an
AutoCloseable

try (FileOutputStream s = ...)

The only way I can think of doing that is by creating another
AutoCloseable that wrapped the FileOutputStream, which is cumbersome.
(I guess users would just fall back to sugar-free try/catch/finally)

BUT with whenComplete, the user code has the exception handed to them
directly as an argument - no machinery required.

From chris.purcell.39 at gmail.com  Sat Dec 19 14:41:19 2015
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Sat, 19 Dec 2015 19:41:19 +0000
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <567599C7.9010906@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
Message-ID: <CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>

> But as it turns out from survey, a lot of people expect or want it to
> behave more like handle(). Which is a different issue than the one
> you first raised.


Behaving like handle() makes sense, but wasn't strictly speaking one of the
survey options. Will you (a) open a new survey, (b) throw
B-with-A-suppressed (survey option 2), or (c) throw B (like handle)? I'd
vote for C.

Thanks!
Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/61c00b61/attachment.html>

From ppozerov at gmail.com  Sat Dec 19 15:48:03 2015
From: ppozerov at gmail.com (Vladimir Ozerov)
Date: Sat, 19 Dec 2015 23:48:03 +0300
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
	<CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
Message-ID: <CAJJmzpX8KCJwr9YDncfDggR8WfTR7V1QTKpcbmO26Ddz3BNwVg@mail.gmail.com>

2015-12-19 22:41 GMT+03:00 Chris Purcell <chris.purcell.39 at gmail.com>:
>
> Behaving like handle() makes sense, but wasn't strictly speaking one of
> the survey options. Will you (a) open a new survey, (b) throw
> B-with-A-suppressed (survey option 2), or (c) throw B (like handle)? I'd
> vote for C.
>

+ 1 for just throwing B without A suppressed.

When I receive normal result X and then transform it to Y inside my *new*
completion stage, it doesn't mean that I "suppressed" X. Likewise, throwing
an exception from a new completion stage should not mean that I suppressed
previous exception. Instead, most likely it means that user *processed*
previous exception and transformed it into some other form.

try-with-resources is not very good analogy here, because it has a single
control flow. If the first exception is thrown from try-block and then the
control flow is disturbed by the second exception from close() method, we
end up with two pending unrelated exceptions. Both of them must be
propagated further somehow and this is where suppression comes into play.
To the contrast, "whenComplete" and "invoke" create new control flow. And
as there is no ambiguity, it is not clear why A should be suppressed. Looks
like we can simply forget about it.

Vladimir.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151219/ad93df65/attachment.html>

From dl at cs.oswego.edu  Sun Dec 20 09:25:16 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 20 Dec 2015 09:25:16 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey, pass 2
In-Reply-To: <CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
	<CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
Message-ID: <5676BA4C.1060703@cs.oswego.edu>

On 12/19/2015 02:41 PM, Chris Purcell wrote:
> Will you (a) open a new survey,

At this point, I think our only choice is to iterate until
we stop encountering new alternatives that we can't rule out
on other grounds. It's clear that there is no perfect policy,
but we'd still like to minimize long-term discontent.

So, please answer the new survey, before Tuesday (22 December) morning.

   https://www.surveymonkey.com/r/S3CS3LJ

It simplifies question, and includes all viable options that I know of,
with very brief explanations.

Also pasted below, but don't reply to this mail with votes.

Q1. Given

   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
      if (true)
         throw new FirstException();
      else
         return "A";
    });

   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
     if (true)
        throw new SecondException();
    });

Where "if (true)" shows the paths of interest in this question. These might 
arise from explicit error checks, programming errors, resource failures, and/or 
translated rethrows.

What should be the completed value of f2?

A. The FirstException. In other words, preserve the source outcome (only) if 
exceptional, ignoring the SecondException.

B. The FirstException, with the SecondException as its suppressed exception.  In 
other words, preserve but modify the source exception to record the SecondException.

C. The SecondException. In other words, replace the source outcome (whether it 
is exceptional or not).

D. The SecondException, with the FirstException as its suppressed exception.  In 
other words, replace the source outcome, but if exceptional, record it as a 
suppressedException of the SecondException.

E. A new CompletionException, with the FirstException as its cause and the 
SecondException as its suppressed exception. In other words, indicate that 
throwing an exception in whenComplete is a different form of error.

Q2. 2. Even if you don't prefer them, which of the above choices are acceptable?

[same options]




From dl at cs.oswego.edu  Mon Dec 21 08:06:10 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 21 Dec 2015 08:06:10 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <5675888f.cdb81c0a.9debb.2996@mx.google.com>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<5675888f.cdb81c0a.9debb.2996@mx.google.com>
Message-ID: <5677F942.6010606@cs.oswego.edu>

On 12/19/2015 11:40 AM, Timo Kinnunen wrote:
> there?s too much overlap between the whenComplete(BiConsumer) method and the
> handle(BiFunction) method.

Just as a reminder, the initial intent was that handle() translates
source outcomes, but whenComplete() preserves them.

This leaves open the policy about what to do if the action in
whenComplete itself throws an exception, so cannot preserve the
outcome without losing information. Which is the issue at hand:
in jdk8, a new exception encountered in whenComplete is dropped
if the outcome is already exceptional.

As I've said, regardless of survey results, we should improve
documentation to more strongly advise users to use handle()
instead of whenComplete() when intentionally translating outcomes.
It seems that most users know this already. As far as we know,
no user has ever complained about jdk8 behavior. The issue was
noticed while Chris was exploring an alternative implementation of
CompletionStage, suggesting that we could do better.

-Doug






From joe.bowbeer at gmail.com  Mon Dec 21 09:01:15 2015
From: joe.bowbeer at gmail.com (joe.bowbeer at gmail.com)
Date: Mon, 21 Dec 2015 06:01:15 -0800 (PST)
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <5677F942.6010606@cs.oswego.edu>
References: <5677F942.6010606@cs.oswego.edu>
Message-ID: <1450706475353.da4693c6@Nodemailer>

Given this discussion, I had assumed that the jdk8 documentation left the door open regarding what happened if the whenComplete action itself threw an exception, but the CompletionStage#whenComplete javadoc clearly specifies what happens:





"If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally."





I agree that better documentation about the intended use is needed. I've learned more from this discussion than from the CompletionStage and CompletableFuture javadoc.

On Mon, Dec 21, 2015 at 5:15 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 12/19/2015 11:40 AM, Timo Kinnunen wrote:
>> there?s too much overlap between the whenComplete(BiConsumer) method and the
>> handle(BiFunction) method.
> Just as a reminder, the initial intent was that handle() translates
> source outcomes, but whenComplete() preserves them.
> This leaves open the policy about what to do if the action in
> whenComplete itself throws an exception, so cannot preserve the
> outcome without losing information. Which is the issue at hand:
> in jdk8, a new exception encountered in whenComplete is dropped
> if the outcome is already exceptional.
> As I've said, regardless of survey results, we should improve
> documentation to more strongly advise users to use handle()
> instead of whenComplete() when intentionally translating outcomes.
> It seems that most users know this already. As far as we know,
> no user has ever complained about jdk8 behavior. The issue was
> noticed while Chris was exploring an alternative implementation of
> CompletionStage, suggesting that we could do better.
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/13998203/attachment.html>

From dl at cs.oswego.edu  Mon Dec 21 09:22:27 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 21 Dec 2015 09:22:27 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <1450706475353.da4693c6@Nodemailer>
References: <5677F942.6010606@cs.oswego.edu>
	<1450706475353.da4693c6@Nodemailer>
Message-ID: <56780B23.1020904@cs.oswego.edu>

On 12/21/2015 09:01 AM, joe.bowbeer at gmail.com wrote:
> Given this discussion, I had assumed that the jdk8 documentation left the door
> open regarding what happened if the whenComplete action itself threw an
> exception,

Given the controversy, the survey includes all known options,
including those that would require an interface-level spec change.
Only the first two options are clearly compatible with current spec.

> I agree that better documentation about the intended use is needed.

Suggestions are always welcome! People out there do complain
a lot about the terse javadocs. We initially decided against
tutorial-style documentation, thinking that the topic was too
big to fit into javadocs. But a few additional explanations
and examples would still help.

A few tutorials have arisen elsewhere, including in some java8 books and:

http://www.jesperdj.com/2015/09/26/the-future-is-completable-in-java-8/
http://www.infoq.com/articles/Functional-Style-Callbacks-Using-CompletableFuture
http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html

and probably more.

-Doug



From peter.levart at gmail.com  Mon Dec 21 10:44:39 2015
From: peter.levart at gmail.com (Peter Levart)
Date: Mon, 21 Dec 2015 16:44:39 +0100
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <5677F942.6010606@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<5675888f.cdb81c0a.9debb.2996@mx.google.com>
	<5677F942.6010606@cs.oswego.edu>
Message-ID: <56781E67.4030806@gmail.com>



On 12/21/2015 02:06 PM, Doug Lea wrote:
> On 12/19/2015 11:40 AM, Timo Kinnunen wrote:
>> there?s too much overlap between the whenComplete(BiConsumer) method 
>> and the
>> handle(BiFunction) method.
>
> Just as a reminder, the initial intent was that handle() translates
> source outcomes, but whenComplete() preserves them.
>
> This leaves open the policy about what to do if the action in
> whenComplete itself throws an exception, so cannot preserve the
> outcome without losing information. Which is the issue at hand:
> in jdk8, a new exception encountered in whenComplete is dropped
> if the outcome is already exceptional.
>
> As I've said, regardless of survey results, we should improve
> documentation to more strongly advise users to use handle()
> instead of whenComplete() when intentionally translating outcomes.
> It seems that most users know this already. As far as we know,
> no user has ever complained about jdk8 behavior. The issue was
> noticed while Chris was exploring an alternative implementation of
> CompletionStage, suggesting that we could do better.
>
> -Doug

It should also be noted that the behavior of the suggested fix to 
improve the situation (the point B in the 2nd survey, which says: "The 
FirstException, with the SecondException as its suppressed exception. In 
other words, preserve but modify the source exception to record the 
SecondException"), while potentially modifying the suppressed exceptions 
list of exceptional outcome of the 1st stage (f1) after it's completion, 
is not that bad because:

- the Throwable.addSuppressed() is a thread-safe operation
- Throwable.getSuppressed() returns a snapshot of exceptions accumulated 
so-far

...which means that a potential consumer of the exceptional outcome of 
the 1st stage (f1) will see all the suppressed exceptions that were 
attached to the FirstException before it was thrown in the 1st stage. 
Hypothetical logic processing those suppressed exceptions will not miss 
any of them. It might or might not see the additional SecondException 
attached, and we hope it will not be confused by that.

Spoiler alert: "personal opinion follows". If you intend to vote 
uninfluenced, do so before reading further...











I think that code that handles the exceptional outcome will usually be 
only interested in the type of the main exception, it might also be 
interested in it's cause, but I'm yet to see code that tries to 
reconstruct a meaning from suppressed exception(s). They are usually 
just a diagnostic tool. It would also be sad to loose the property of 
whenComplete() which now guarantees that the exceptional outcome of the 
previous stage is preserved regardless of what whenComplete() action 
does as it might be an action that is not written by the same programmer 
that has written a call to whenComplete().

I've written a thin wrapper for CompletableFuture that presents a 
type-safe API for checked exception handling. It relies on whenComplete 
not changing the type of exceptional outcome. I'm not using this API for 
anything important, but just want to note that any change that makes it 
possible for whenComplete() to change the type of exceptional outcome 
might brake some code that currently relies on assumption that it can't 
be changed.

Regards, Peter

>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Mon Dec 21 13:12:46 2015
From: joe.bowbeer at gmail.com (joe.bowbeer at gmail.com)
Date: Mon, 21 Dec 2015 10:12:46 -0800 (PST)
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <56780B23.1020904@cs.oswego.edu>
References: <56780B23.1020904@cs.oswego.edu>
Message-ID: <1450721565978.79ad8344@Nodemailer>

In the second survey email, the only options clearly *compatible* with the CompletionStage spec are the third and fourth options, C and D, which throw the second exception. Correct?

On Mon, Dec 21, 2015 at 6:25 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 12/21/2015 09:01 AM, joe.bowbeer at gmail.com wrote:
>> Given this discussion, I had assumed that the jdk8 documentation left the door
>> open regarding what happened if the whenComplete action itself threw an
>> exception,
> Given the controversy, the survey includes all known options,
> including those that would require an interface-level spec change.
> Only the first two options are clearly compatible with current spec.
>> I agree that better documentation about the intended use is needed.
> Suggestions are always welcome! People out there do complain
> a lot about the terse javadocs. We initially decided against
> tutorial-style documentation, thinking that the topic was too
> big to fit into javadocs. But a few additional explanations
> and examples would still help.
> A few tutorials have arisen elsewhere, including in some java8 books and:
> http://www.jesperdj.com/2015/09/26/the-future-is-completable-in-java-8/
> http://www.infoq.com/articles/Functional-Style-Callbacks-Using-CompletableFuture
> http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html
> and probably more.
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/4a116999/attachment.html>

From dl at cs.oswego.edu  Mon Dec 21 13:49:12 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 21 Dec 2015 13:49:12 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <1450721565978.79ad8344@Nodemailer>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
Message-ID: <567849A8.6090204@cs.oswego.edu>

On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
> In the second survey email, the only options clearly *compatible* with the
> CompletionStage spec are ...

No. Here's jdk8 spec:

"If the supplied action itself encounters an exception, then the returned stage 
exceptionally completes with this exception unless this stage also completed 
exceptionally."

Which describes options A and B. Option B also adds as suppressed
the whenComplete exception, which is not required but not disallowed
by current spec.

Options C would comply only if the "unless" clause were dropped.

Options D and E would require more changes.

where, as a reminder...

   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
      if (true)
         throw new FirstException();
      else
         return "A";
    });

   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
     if (true)
        throw new SecondException();
    });

A. The FirstException. In other words, preserve the source outcome (only) if 
exceptional, ignoring the SecondException.

B. The FirstException, with the SecondException as its suppressed exception.  In 
other words, preserve but modify the source exception to record the SecondException.

C. The SecondException. In other words, replace the source outcome (whether it 
is exceptional or not).

D. The SecondException, with the FirstException as its suppressed exception.  In 
other words, replace the source outcome, but if exceptional, record it as a 
suppressedException of the SecondException.

E. A new CompletionException, with the FirstException as its cause and the 
SecondException as its suppressed exception. In other words, indicate that 
throwing an exception in whenComplete is a different form of error.




From joe.bowbeer at gmail.com  Mon Dec 21 14:28:57 2015
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 21 Dec 2015 11:28:57 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <567849A8.6090204@cs.oswego.edu>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
Message-ID: <CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>

Thanks for clarifying!

I had to read the spec several more times before I could parse that
meaning, but now that I see it, it is also hard to mistake :-)

The spec talks about "this stage" and the "returned stage" and I was
confused by all the "this".

In the spec wording, below, "this stage" is stage1 throwing exception1 and
the "returned stage" is stage2 throwing exception2. The last phrase
contains a "this exception" referring to exception2 and also a "this stage"
referring to stage1, which is especially confusing.

Annotated:

"If the supplied action [action2] itself encounters an exception
[exception2], then the returned stage [stage2] exceptionally completes with
this exception [exception2] unless this stage [stage1] also completed
exceptionally [exception1]."

I had been interpreting the final "this stage" to mean the next stage...

Given my new understanding of the spec, throwing exception1 with suppressed
exception2 (a la try-with-resources) makes a lot of sense.

To be clear, is the current jdk8 behavior *not* compliant with spec?


On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>
>> In the second survey email, the only options clearly *compatible* with the
>> CompletionStage spec are ...
>>
>
> No. Here's jdk8 spec:
>
> "If the supplied action itself encounters an exception, then the returned
> stage exceptionally completes with this exception unless this stage also
> completed exceptionally."
>
> Which describes options A and B. Option B also adds as suppressed
> the whenComplete exception, which is not required but not disallowed
> by current spec.
>
> Options C would comply only if the "unless" clause were dropped.
>
> Options D and E would require more changes.
>
> where, as a reminder...
>
>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>      if (true)
>         throw new FirstException();
>      else
>         return "A";
>    });
>
>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
>     if (true)
>        throw new SecondException();
>    });
>
> A. The FirstException. In other words, preserve the source outcome (only)
> if exceptional, ignoring the SecondException.
>
> B. The FirstException, with the SecondException as its suppressed
> exception.  In other words, preserve but modify the source exception to
> record the SecondException.
>
> C. The SecondException. In other words, replace the source outcome
> (whether it is exceptional or not).
>
> D. The SecondException, with the FirstException as its suppressed
> exception.  In other words, replace the source outcome, but if exceptional,
> record it as a suppressedException of the SecondException.
>
> E. A new CompletionException, with the FirstException as its cause and the
> SecondException as its suppressed exception. In other words, indicate that
> throwing an exception in whenComplete is a different form of error.
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/b833a884/attachment.html>

From chris.purcell.39 at gmail.com  Mon Dec 21 15:36:07 2015
From: chris.purcell.39 at gmail.com (Chris Purcell)
Date: Mon, 21 Dec 2015 20:36:07 +0000
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
Message-ID: <CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>

Perhaps a simple change from "this stage/the returned stage" to "the input
stage/the output stage" would be helpful?

Chris

On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Thanks for clarifying!
>
> I had to read the spec several more times before I could parse that
> meaning, but now that I see it, it is also hard to mistake :-)
>
> The spec talks about "this stage" and the "returned stage" and I was
> confused by all the "this".
>
> In the spec wording, below, "this stage" is stage1 throwing exception1 and
> the "returned stage" is stage2 throwing exception2. The last phrase
> contains a "this exception" referring to exception2 and also a "this stage"
> referring to stage1, which is especially confusing.
>
> Annotated:
>
> "If the supplied action [action2] itself encounters an exception
> [exception2], then the returned stage [stage2] exceptionally completes with
> this exception [exception2] unless this stage [stage1] also completed
> exceptionally [exception1]."
>
> I had been interpreting the final "this stage" to mean the next stage...
>
> Given my new understanding of the spec, throwing exception1 with
> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>
> To be clear, is the current jdk8 behavior *not* compliant with spec?
>
>
> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>
>>> In the second survey email, the only options clearly *compatible* with
>>> the
>>> CompletionStage spec are ...
>>>
>>
>> No. Here's jdk8 spec:
>>
>> "If the supplied action itself encounters an exception, then the returned
>> stage exceptionally completes with this exception unless this stage also
>> completed exceptionally."
>>
>> Which describes options A and B. Option B also adds as suppressed
>> the whenComplete exception, which is not required but not disallowed
>> by current spec.
>>
>> Options C would comply only if the "unless" clause were dropped.
>>
>> Options D and E would require more changes.
>>
>> where, as a reminder...
>>
>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>      if (true)
>>         throw new FirstException();
>>      else
>>         return "A";
>>    });
>>
>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
>>     if (true)
>>        throw new SecondException();
>>    });
>>
>> A. The FirstException. In other words, preserve the source outcome (only)
>> if exceptional, ignoring the SecondException.
>>
>> B. The FirstException, with the SecondException as its suppressed
>> exception.  In other words, preserve but modify the source exception to
>> record the SecondException.
>>
>> C. The SecondException. In other words, replace the source outcome
>> (whether it is exceptional or not).
>>
>> D. The SecondException, with the FirstException as its suppressed
>> exception.  In other words, replace the source outcome, but if exceptional,
>> record it as a suppressedException of the SecondException.
>>
>> E. A new CompletionException, with the FirstException as its cause and
>> the SecondException as its suppressed exception. In other words, indicate
>> that throwing an exception in whenComplete is a different form of error.
>>
>>
>>
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/f671db89/attachment-0001.html>

From joe.bowbeer at gmail.com  Mon Dec 21 16:05:50 2015
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 21 Dec 2015 13:05:50 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
	<CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
Message-ID: <CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>

Some disambiguation of "this" is needed, especially when it is referring to
different stages or their things.

Using input/output would help, except that it is normal in javadoc to refer
to the object whose method is being invoked as "this [thing]". In the case
of CompletionStage#whenComplete, "this stage" is this CompletionStage
object.

Here is my stab at a clearer sentence:

"If the supplied action itself encounters an exception, then the returned
stage exceptionally completes with the supplied action's exception unless
this stage [had|already] completed exceptionally, in which case the first
exception is retained.


On Mon, Dec 21, 2015 at 12:36 PM, Chris Purcell <chris.purcell.39 at gmail.com>
wrote:

> Perhaps a simple change from "this stage/the returned stage" to "the input
> stage/the output stage" would be helpful?
>
> Chris
>
> On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
>> Thanks for clarifying!
>>
>> I had to read the spec several more times before I could parse that
>> meaning, but now that I see it, it is also hard to mistake :-)
>>
>> The spec talks about "this stage" and the "returned stage" and I was
>> confused by all the "this".
>>
>> In the spec wording, below, "this stage" is stage1 throwing exception1
>> and the "returned stage" is stage2 throwing exception2. The last phrase
>> contains a "this exception" referring to exception2 and also a "this stage"
>> referring to stage1, which is especially confusing.
>>
>> Annotated:
>>
>> "If the supplied action [action2] itself encounters an exception
>> [exception2], then the returned stage [stage2] exceptionally completes with
>> this exception [exception2] unless this stage [stage1] also completed
>> exceptionally [exception1]."
>>
>> I had been interpreting the final "this stage" to mean the next stage...
>>
>> Given my new understanding of the spec, throwing exception1 with
>> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>>
>> To be clear, is the current jdk8 behavior *not* compliant with spec?
>>
>>
>> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>>
>>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>>
>>>> In the second survey email, the only options clearly *compatible* with
>>>> the
>>>> CompletionStage spec are ...
>>>>
>>>
>>> No. Here's jdk8 spec:
>>>
>>> "If the supplied action itself encounters an exception, then the
>>> returned stage exceptionally completes with this exception unless this
>>> stage also completed exceptionally."
>>>
>>> Which describes options A and B. Option B also adds as suppressed
>>> the whenComplete exception, which is not required but not disallowed
>>> by current spec.
>>>
>>> Options C would comply only if the "unless" clause were dropped.
>>>
>>> Options D and E would require more changes.
>>>
>>> where, as a reminder...
>>>
>>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>>      if (true)
>>>         throw new FirstException();
>>>      else
>>>         return "A";
>>>    });
>>>
>>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
>>>     if (true)
>>>        throw new SecondException();
>>>    });
>>>
>>> A. The FirstException. In other words, preserve the source outcome
>>> (only) if exceptional, ignoring the SecondException.
>>>
>>> B. The FirstException, with the SecondException as its suppressed
>>> exception.  In other words, preserve but modify the source exception to
>>> record the SecondException.
>>>
>>> C. The SecondException. In other words, replace the source outcome
>>> (whether it is exceptional or not).
>>>
>>> D. The SecondException, with the FirstException as its suppressed
>>> exception.  In other words, replace the source outcome, but if exceptional,
>>> record it as a suppressedException of the SecondException.
>>>
>>> E. A new CompletionException, with the FirstException as its cause and
>>> the SecondException as its suppressed exception. In other words, indicate
>>> that throwing an exception in whenComplete is a different form of error.
>>>
>>>
>>>
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/782380b6/attachment.html>

From joe.bowbeer at gmail.com  Mon Dec 21 16:18:12 2015
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 21 Dec 2015 13:18:12 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
	<CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
	<CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
Message-ID: <CAHzJPEpwsarXYzQ7xFBoabo+sOzQmL1EBGLOBA1rcrcRPmGmXQ@mail.gmail.com>

Given that the doc leads with the statement that whenComplete "returns a
new CompletionStage with the same result or exception as this stage", I
think the following is sufficiently clear:

If this stage completed normally but the supplied action itself encounters
an exception, then the returned stage exceptionally completes with the
supplied action's exception.

On Mon, Dec 21, 2015 at 1:05 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Some disambiguation of "this" is needed, especially when it is referring
> to different stages or their things.
>
> Using input/output would help, except that it is normal in javadoc to
> refer to the object whose method is being invoked as "this [thing]". In the
> case of CompletionStage#whenComplete, "this stage" is this CompletionStage
> object.
>
> Here is my stab at a clearer sentence:
>
> "If the supplied action itself encounters an exception, then the returned
> stage exceptionally completes with the supplied action's exception unless
> this stage [had|already] completed exceptionally, in which case the first
> exception is retained.
>
>
> On Mon, Dec 21, 2015 at 12:36 PM, Chris Purcell <
> chris.purcell.39 at gmail.com> wrote:
>
>> Perhaps a simple change from "this stage/the returned stage" to "the
>> input stage/the output stage" would be helpful?
>>
>> Chris
>>
>> On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>>
>>> Thanks for clarifying!
>>>
>>> I had to read the spec several more times before I could parse that
>>> meaning, but now that I see it, it is also hard to mistake :-)
>>>
>>> The spec talks about "this stage" and the "returned stage" and I was
>>> confused by all the "this".
>>>
>>> In the spec wording, below, "this stage" is stage1 throwing exception1
>>> and the "returned stage" is stage2 throwing exception2. The last phrase
>>> contains a "this exception" referring to exception2 and also a "this stage"
>>> referring to stage1, which is especially confusing.
>>>
>>> Annotated:
>>>
>>> "If the supplied action [action2] itself encounters an exception
>>> [exception2], then the returned stage [stage2] exceptionally completes with
>>> this exception [exception2] unless this stage [stage1] also completed
>>> exceptionally [exception1]."
>>>
>>> I had been interpreting the final "this stage" to mean the next stage...
>>>
>>> Given my new understanding of the spec, throwing exception1 with
>>> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>>>
>>> To be clear, is the current jdk8 behavior *not* compliant with spec?
>>>
>>>
>>> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>>>
>>>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>>>
>>>>> In the second survey email, the only options clearly *compatible* with
>>>>> the
>>>>> CompletionStage spec are ...
>>>>>
>>>>
>>>> No. Here's jdk8 spec:
>>>>
>>>> "If the supplied action itself encounters an exception, then the
>>>> returned stage exceptionally completes with this exception unless this
>>>> stage also completed exceptionally."
>>>>
>>>> Which describes options A and B. Option B also adds as suppressed
>>>> the whenComplete exception, which is not required but not disallowed
>>>> by current spec.
>>>>
>>>> Options C would comply only if the "unless" clause were dropped.
>>>>
>>>> Options D and E would require more changes.
>>>>
>>>> where, as a reminder...
>>>>
>>>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>>>      if (true)
>>>>         throw new FirstException();
>>>>      else
>>>>         return "A";
>>>>    });
>>>>
>>>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) ->
>>>> {
>>>>     if (true)
>>>>        throw new SecondException();
>>>>    });
>>>>
>>>> A. The FirstException. In other words, preserve the source outcome
>>>> (only) if exceptional, ignoring the SecondException.
>>>>
>>>> B. The FirstException, with the SecondException as its suppressed
>>>> exception.  In other words, preserve but modify the source exception to
>>>> record the SecondException.
>>>>
>>>> C. The SecondException. In other words, replace the source outcome
>>>> (whether it is exceptional or not).
>>>>
>>>> D. The SecondException, with the FirstException as its suppressed
>>>> exception.  In other words, replace the source outcome, but if exceptional,
>>>> record it as a suppressedException of the SecondException.
>>>>
>>>> E. A new CompletionException, with the FirstException as its cause and
>>>> the SecondException as its suppressed exception. In other words, indicate
>>>> that throwing an exception in whenComplete is a different form of error.
>>>>
>>>>
>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/02d770c1/attachment.html>

From tim at peierls.net  Mon Dec 21 16:23:25 2015
From: tim at peierls.net (Tim Peierls)
Date: Mon, 21 Dec 2015 16:23:25 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
	<CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
	<CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
Message-ID: <CA+F8eeSiYbmVdN2hhkx6YC=ewS0CwdFS7vkKMi-RyQq5u+NCyQ@mail.gmail.com>

Joe's re-wording is good, but I think could be improved by replacing "the
first exception" (which still feels a bit ambiguous: do we mean first
lexically in the sentence or first in execution order?) with "the exception
from the already-completed stage".

On Mon, Dec 21, 2015 at 4:05 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Some disambiguation of "this" is needed, especially when it is referring
> to different stages or their things.
>
> Using input/output would help, except that it is normal in javadoc to
> refer to the object whose method is being invoked as "this [thing]". In the
> case of CompletionStage#whenComplete, "this stage" is this CompletionStage
> object.
>
> Here is my stab at a clearer sentence:
>
> "If the supplied action itself encounters an exception, then the returned
> stage exceptionally completes with the supplied action's exception unless
> this stage [had|already] completed exceptionally, in which case the first
> exception is retained.
>
>
> On Mon, Dec 21, 2015 at 12:36 PM, Chris Purcell <
> chris.purcell.39 at gmail.com> wrote:
>
>> Perhaps a simple change from "this stage/the returned stage" to "the
>> input stage/the output stage" would be helpful?
>>
>> Chris
>>
>> On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>>
>>> Thanks for clarifying!
>>>
>>> I had to read the spec several more times before I could parse that
>>> meaning, but now that I see it, it is also hard to mistake :-)
>>>
>>> The spec talks about "this stage" and the "returned stage" and I was
>>> confused by all the "this".
>>>
>>> In the spec wording, below, "this stage" is stage1 throwing exception1
>>> and the "returned stage" is stage2 throwing exception2. The last phrase
>>> contains a "this exception" referring to exception2 and also a "this stage"
>>> referring to stage1, which is especially confusing.
>>>
>>> Annotated:
>>>
>>> "If the supplied action [action2] itself encounters an exception
>>> [exception2], then the returned stage [stage2] exceptionally completes with
>>> this exception [exception2] unless this stage [stage1] also completed
>>> exceptionally [exception1]."
>>>
>>> I had been interpreting the final "this stage" to mean the next stage...
>>>
>>> Given my new understanding of the spec, throwing exception1 with
>>> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>>>
>>> To be clear, is the current jdk8 behavior *not* compliant with spec?
>>>
>>>
>>> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>>>
>>>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>>>
>>>>> In the second survey email, the only options clearly *compatible* with
>>>>> the
>>>>> CompletionStage spec are ...
>>>>>
>>>>
>>>> No. Here's jdk8 spec:
>>>>
>>>> "If the supplied action itself encounters an exception, then the
>>>> returned stage exceptionally completes with this exception unless this
>>>> stage also completed exceptionally."
>>>>
>>>> Which describes options A and B. Option B also adds as suppressed
>>>> the whenComplete exception, which is not required but not disallowed
>>>> by current spec.
>>>>
>>>> Options C would comply only if the "unless" clause were dropped.
>>>>
>>>> Options D and E would require more changes.
>>>>
>>>> where, as a reminder...
>>>>
>>>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>>>      if (true)
>>>>         throw new FirstException();
>>>>      else
>>>>         return "A";
>>>>    });
>>>>
>>>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) ->
>>>> {
>>>>     if (true)
>>>>        throw new SecondException();
>>>>    });
>>>>
>>>> A. The FirstException. In other words, preserve the source outcome
>>>> (only) if exceptional, ignoring the SecondException.
>>>>
>>>> B. The FirstException, with the SecondException as its suppressed
>>>> exception.  In other words, preserve but modify the source exception to
>>>> record the SecondException.
>>>>
>>>> C. The SecondException. In other words, replace the source outcome
>>>> (whether it is exceptional or not).
>>>>
>>>> D. The SecondException, with the FirstException as its suppressed
>>>> exception.  In other words, replace the source outcome, but if exceptional,
>>>> record it as a suppressedException of the SecondException.
>>>>
>>>> E. A new CompletionException, with the FirstException as its cause and
>>>> the SecondException as its suppressed exception. In other words, indicate
>>>> that throwing an exception in whenComplete is a different form of error.
>>>>
>>>>
>>>>
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/f20d3449/attachment-0001.html>

From joe.bowbeer at gmail.com  Mon Dec 21 16:49:11 2015
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 21 Dec 2015 13:49:11 -0800
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPEpwsarXYzQ7xFBoabo+sOzQmL1EBGLOBA1rcrcRPmGmXQ@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
	<CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
	<CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
	<CAHzJPEpwsarXYzQ7xFBoabo+sOzQmL1EBGLOBA1rcrcRPmGmXQ@mail.gmail.com>
Message-ID: <CAHzJPEpQdK+XQp0U==BtS09koBOTMv08yK=6c2pTXUsX3U6rzw@mail.gmail.com>

Continuing my prose, an additional sentence can be added specifically for
the case we are voting on, replacing the final sentence with these two:

"If this stage completed normally but the supplied action itself encounters
an exception, then the returned stage exceptionally completes with the
supplied action's exception. If this stage completed exceptionally and the
supplied action encounters an exception, then the returned stage
exceptionally completes with [...]"

On Mon, Dec 21, 2015 at 1:18 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Given that the doc leads with the statement that whenComplete "returns a
> new CompletionStage with the same result or exception as this stage", I
> think the following is sufficiently clear:
>
> If this stage completed normally but the supplied action itself encounters
> an exception, then the returned stage exceptionally completes with the
> supplied action's exception.
>
> On Mon, Dec 21, 2015 at 1:05 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
> wrote:
>
>> Some disambiguation of "this" is needed, especially when it is referring
>> to different stages or their things.
>>
>> Using input/output would help, except that it is normal in javadoc to
>> refer to the object whose method is being invoked as "this [thing]". In the
>> case of CompletionStage#whenComplete, "this stage" is this CompletionStage
>> object.
>>
>> Here is my stab at a clearer sentence:
>>
>> "If the supplied action itself encounters an exception, then the returned
>> stage exceptionally completes with the supplied action's exception unless
>> this stage [had|already] completed exceptionally, in which case the first
>> exception is retained.
>>
>>
>> On Mon, Dec 21, 2015 at 12:36 PM, Chris Purcell <
>> chris.purcell.39 at gmail.com> wrote:
>>
>>> Perhaps a simple change from "this stage/the returned stage" to "the
>>> input stage/the output stage" would be helpful?
>>>
>>> Chris
>>>
>>> On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>>>
>>>> Thanks for clarifying!
>>>>
>>>> I had to read the spec several more times before I could parse that
>>>> meaning, but now that I see it, it is also hard to mistake :-)
>>>>
>>>> The spec talks about "this stage" and the "returned stage" and I was
>>>> confused by all the "this".
>>>>
>>>> In the spec wording, below, "this stage" is stage1 throwing exception1
>>>> and the "returned stage" is stage2 throwing exception2. The last phrase
>>>> contains a "this exception" referring to exception2 and also a "this stage"
>>>> referring to stage1, which is especially confusing.
>>>>
>>>> Annotated:
>>>>
>>>> "If the supplied action [action2] itself encounters an exception
>>>> [exception2], then the returned stage [stage2] exceptionally completes with
>>>> this exception [exception2] unless this stage [stage1] also completed
>>>> exceptionally [exception1]."
>>>>
>>>> I had been interpreting the final "this stage" to mean the next stage...
>>>>
>>>> Given my new understanding of the spec, throwing exception1 with
>>>> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>>>>
>>>> To be clear, is the current jdk8 behavior *not* compliant with spec?
>>>>
>>>>
>>>> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>>>>
>>>>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>>>>
>>>>>> In the second survey email, the only options clearly *compatible*
>>>>>> with the
>>>>>> CompletionStage spec are ...
>>>>>>
>>>>>
>>>>> No. Here's jdk8 spec:
>>>>>
>>>>> "If the supplied action itself encounters an exception, then the
>>>>> returned stage exceptionally completes with this exception unless this
>>>>> stage also completed exceptionally."
>>>>>
>>>>> Which describes options A and B. Option B also adds as suppressed
>>>>> the whenComplete exception, which is not required but not disallowed
>>>>> by current spec.
>>>>>
>>>>> Options C would comply only if the "unless" clause were dropped.
>>>>>
>>>>> Options D and E would require more changes.
>>>>>
>>>>> where, as a reminder...
>>>>>
>>>>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>>>>      if (true)
>>>>>         throw new FirstException();
>>>>>      else
>>>>>         return "A";
>>>>>    });
>>>>>
>>>>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception)
>>>>> -> {
>>>>>     if (true)
>>>>>        throw new SecondException();
>>>>>    });
>>>>>
>>>>> A. The FirstException. In other words, preserve the source outcome
>>>>> (only) if exceptional, ignoring the SecondException.
>>>>>
>>>>> B. The FirstException, with the SecondException as its suppressed
>>>>> exception.  In other words, preserve but modify the source exception to
>>>>> record the SecondException.
>>>>>
>>>>> C. The SecondException. In other words, replace the source outcome
>>>>> (whether it is exceptional or not).
>>>>>
>>>>> D. The SecondException, with the FirstException as its suppressed
>>>>> exception.  In other words, replace the source outcome, but if exceptional,
>>>>> record it as a suppressedException of the SecondException.
>>>>>
>>>>> E. A new CompletionException, with the FirstException as its cause and
>>>>> the SecondException as its suppressed exception. In other words, indicate
>>>>> that throwing an exception in whenComplete is a different form of error.
>>>>>
>>>>>
>>>>>
>>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/d5bceffa/attachment.html>

From tim at peierls.net  Mon Dec 21 16:55:38 2015
From: tim at peierls.net (Tim Peierls)
Date: Mon, 21 Dec 2015 16:55:38 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey
In-Reply-To: <CAHzJPEpQdK+XQp0U==BtS09koBOTMv08yK=6c2pTXUsX3U6rzw@mail.gmail.com>
References: <56780B23.1020904@cs.oswego.edu>
	<1450721565978.79ad8344@Nodemailer>
	<567849A8.6090204@cs.oswego.edu>
	<CAHzJPEoV7JQcObR-kpndt5076f1n2BVYL0O87uFfZh+d0KVAmg@mail.gmail.com>
	<CAJUoZVbV4+dw8J_ujG=_MjzTG8Zw28cEP3XzOY3bVEoGN3jrgg@mail.gmail.com>
	<CAHzJPErZTq_dSb1JZ09NNu+RY-sY+PT7Wu7q44DqtcNCkstn=g@mail.gmail.com>
	<CAHzJPEpwsarXYzQ7xFBoabo+sOzQmL1EBGLOBA1rcrcRPmGmXQ@mail.gmail.com>
	<CAHzJPEpQdK+XQp0U==BtS09koBOTMv08yK=6c2pTXUsX3U6rzw@mail.gmail.com>
Message-ID: <CA+F8eeTw3VpMzm8RBnDHojw87yJdsM-UPGyYnwzsdcEt9Qk=KQ@mail.gmail.com>

Even better. Enumerating the possibilities using that parallel sentence
structure makes it clearer what's going on. (Regardless of how [...] gets
filled in.)

On Mon, Dec 21, 2015 at 4:49 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Continuing my prose, an additional sentence can be added specifically for
> the case we are voting on, replacing the final sentence with these two:
>
> "If this stage completed normally but the supplied action itself
> encounters an exception, then the returned stage exceptionally completes
> with the supplied action's exception. If this stage completed exceptionally
> and the supplied action encounters an exception, then the returned stage
> exceptionally completes with [...]"
>
> On Mon, Dec 21, 2015 at 1:18 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
> wrote:
>
>> Given that the doc leads with the statement that whenComplete "returns a
>> new CompletionStage with the same result or exception as this stage", I
>> think the following is sufficiently clear:
>>
>> If this stage completed normally but the supplied action itself
>> encounters an exception, then the returned stage exceptionally completes
>> with the supplied action's exception.
>>
>> On Mon, Dec 21, 2015 at 1:05 PM, Joe Bowbeer <joe.bowbeer at gmail.com>
>> wrote:
>>
>>> Some disambiguation of "this" is needed, especially when it is referring
>>> to different stages or their things.
>>>
>>> Using input/output would help, except that it is normal in javadoc to
>>> refer to the object whose method is being invoked as "this [thing]". In the
>>> case of CompletionStage#whenComplete, "this stage" is this CompletionStage
>>> object.
>>>
>>> Here is my stab at a clearer sentence:
>>>
>>> "If the supplied action itself encounters an exception, then the
>>> returned stage exceptionally completes with the supplied action's exception
>>> unless this stage [had|already] completed exceptionally, in which case the
>>> first exception is retained.
>>>
>>>
>>> On Mon, Dec 21, 2015 at 12:36 PM, Chris Purcell <
>>> chris.purcell.39 at gmail.com> wrote:
>>>
>>>> Perhaps a simple change from "this stage/the returned stage" to "the
>>>> input stage/the output stage" would be helpful?
>>>>
>>>> Chris
>>>>
>>>> On Mon, 21 Dec 2015 at 19:37 Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>>>>
>>>>> Thanks for clarifying!
>>>>>
>>>>> I had to read the spec several more times before I could parse that
>>>>> meaning, but now that I see it, it is also hard to mistake :-)
>>>>>
>>>>> The spec talks about "this stage" and the "returned stage" and I was
>>>>> confused by all the "this".
>>>>>
>>>>> In the spec wording, below, "this stage" is stage1 throwing exception1
>>>>> and the "returned stage" is stage2 throwing exception2. The last phrase
>>>>> contains a "this exception" referring to exception2 and also a "this stage"
>>>>> referring to stage1, which is especially confusing.
>>>>>
>>>>> Annotated:
>>>>>
>>>>> "If the supplied action [action2] itself encounters an exception
>>>>> [exception2], then the returned stage [stage2] exceptionally completes with
>>>>> this exception [exception2] unless this stage [stage1] also completed
>>>>> exceptionally [exception1]."
>>>>>
>>>>> I had been interpreting the final "this stage" to mean the next
>>>>> stage...
>>>>>
>>>>> Given my new understanding of the spec, throwing exception1 with
>>>>> suppressed exception2 (a la try-with-resources) makes a lot of sense.
>>>>>
>>>>> To be clear, is the current jdk8 behavior *not* compliant with spec?
>>>>>
>>>>>
>>>>> On Mon, Dec 21, 2015 at 10:49 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>>>>>
>>>>>> On 12/21/2015 01:12 PM, joe.bowbeer at gmail.com wrote:
>>>>>>
>>>>>>> In the second survey email, the only options clearly *compatible*
>>>>>>> with the
>>>>>>> CompletionStage spec are ...
>>>>>>>
>>>>>>
>>>>>> No. Here's jdk8 spec:
>>>>>>
>>>>>> "If the supplied action itself encounters an exception, then the
>>>>>> returned stage exceptionally completes with this exception unless this
>>>>>> stage also completed exceptionally."
>>>>>>
>>>>>> Which describes options A and B. Option B also adds as suppressed
>>>>>> the whenComplete exception, which is not required but not disallowed
>>>>>> by current spec.
>>>>>>
>>>>>> Options C would comply only if the "unless" clause were dropped.
>>>>>>
>>>>>> Options D and E would require more changes.
>>>>>>
>>>>>> where, as a reminder...
>>>>>>
>>>>>>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>>>>>>      if (true)
>>>>>>         throw new FirstException();
>>>>>>      else
>>>>>>         return "A";
>>>>>>    });
>>>>>>
>>>>>>   CompletableFuture<String> f2 = f1.whenComplete((result, exception)
>>>>>> -> {
>>>>>>     if (true)
>>>>>>        throw new SecondException();
>>>>>>    });
>>>>>>
>>>>>> A. The FirstException. In other words, preserve the source outcome
>>>>>> (only) if exceptional, ignoring the SecondException.
>>>>>>
>>>>>> B. The FirstException, with the SecondException as its suppressed
>>>>>> exception.  In other words, preserve but modify the source exception to
>>>>>> record the SecondException.
>>>>>>
>>>>>> C. The SecondException. In other words, replace the source outcome
>>>>>> (whether it is exceptional or not).
>>>>>>
>>>>>> D. The SecondException, with the FirstException as its suppressed
>>>>>> exception.  In other words, replace the source outcome, but if exceptional,
>>>>>> record it as a suppressedException of the SecondException.
>>>>>>
>>>>>> E. A new CompletionException, with the FirstException as its cause
>>>>>> and the SecondException as its suppressed exception. In other words,
>>>>>> indicate that throwing an exception in whenComplete is a different form of
>>>>>> error.
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151221/3fe3ad2a/attachment-0001.html>

From dl at cs.oswego.edu  Wed Dec 23 07:17:04 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 23 Dec 2015 07:17:04 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey,
 pass 2
In-Reply-To: <5676BA4C.1060703@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
	<CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
	<5676BA4C.1060703@cs.oswego.edu>
Message-ID: <567A90C0.2@cs.oswego.edu>


Here's another attempt to resolve this issue based on the surveys and
accompanying discussions.

As the javadocs already note, method whenComplete is intended to
preserve outcomes. We should further emphasize this by adding:

      * <p> Unlike method {@link #handle}, this method is not designed
      * to translate completion outcomes, so the supplied action should
      * not throw an exception.

An exception thrown in a whenComplete action violates the intent to
preserve outcomes, so almost any policy (possibly even stating that
the effects are undefined) might be defensible. However, the one we
chose (A) allowed an exception to be swallowed, impairing diagnosis of
usage problems.  Each of the other surveyed options avoids this
problem, and each them has advantages (and votes).  The only one that
does not require behavioral modification of the CompletionStage spec
(rather than just the CompletableFuture implementation) is option B
(to add the action exception as a suppressed exception of the incoming
exception).  So this choice does not require change in any other
implementations of the interface.  Option B also got the most
"acceptable" votes (in question 2) of survey 2. Here are results
from the 29 voters. (Questions are repasted below.)

Option  Preferred Acceptable
A       1         5
B       4         18
C       8         12
D       9         17
E       4         15

(A few people skipped question 1. Also, some did not include
question 1 choice in 2. The above table is adjusted to include them.)

Options C and D got more first-choice votes, indicating that they
probably would have been better choices in the original spec. But the
pattern of votes suggests that no choice is widely agreed on as enough
better to risk an interface spec change.

Given all this, I propose we continue with option B (the current
in-progress jdk9 update) in the CompletableFuture implementation. Plus
improve the above CompletionStage spec clarification to better describe
outcomes, as suggested by Joe and others. Here's whenComplete. the
whnCompleteAsync versions are almost identical.

      * <p> Unlike method {@link #handle}, this method is not designed
      * to translate completion outcomes, so the supplied action should
      * not throw an exception. However, if it does, the following
      * rules apply: If this stage completed normally but the supplied
      * action throws an exception, then the returned stage completes
      * exceptionally with the supplied action's exception. Or, if this
      * stage completed exceptionally and the supplied action throws an
      * exception, then the returned stage completes exceptionally with
      * this stage's exception.
      *

Any objections?

-Doug

... survey 2

Q1. Given

   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
      if (true)
         throw new FirstException();
      else
         return "A";
    });

   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
     if (true)
        throw new SecondException();
    });

Where "if (true)" shows the paths of interest in this question. These might 
arise from explicit error checks, programming errors, resource failures, and/or 
translated rethrows.

What should be the completed value of f2?

A. The FirstException. In other words, preserve the source outcome (only) if 
exceptional, ignoring the SecondException.

B. The FirstException, with the SecondException as its suppressed exception.  In 
other words, preserve but modify the source exception to record the SecondException.

C. The SecondException. In other words, replace the source outcome (whether it 
is exceptional or not).

D. The SecondException, with the FirstException as its suppressed exception.  In 
other words, replace the source outcome, but if exceptional, record it as a 
suppressedException of the SecondException.

E. A new CompletionException, with the FirstException as its cause and the 
SecondException as its suppressed exception. In other words, indicate that 
throwing an exception in whenComplete is a different form of error.

Q2. Even if you don't prefer them, which of the above choices are acceptable?






From tim at peierls.net  Wed Dec 23 09:50:09 2015
From: tim at peierls.net (Tim Peierls)
Date: Wed, 23 Dec 2015 09:50:09 -0500
Subject: [concurrency-interest] CompletableFuture.whenComplete survey,
 pass 2
In-Reply-To: <567A90C0.2@cs.oswego.edu>
References: <56720923.80502@cs.oswego.edu> <567556B7.6080407@cs.oswego.edu>
	<CAHzJPErkLU_n8aRJY63eLu_7XW+HdUfBX_H4h7dptdkuub1sdQ@mail.gmail.com>
	<56756676.3040608@cs.oswego.edu>
	<CAJUoZVY3u=Jw=vRFdTkLckoc5jLh7KRZwyo7DKVhAigdagxjsQ@mail.gmail.com>
	<567599C7.9010906@cs.oswego.edu>
	<CAJUoZVamtYv65Vwha67BNQRKpbFfA6+HeJ-6dW5+8JzBRfns0w@mail.gmail.com>
	<5676BA4C.1060703@cs.oswego.edu> <567A90C0.2@cs.oswego.edu>
Message-ID: <CA+F8eeS-p4yRgcxcskC2nsRqDykrBw-PHWGMP9tvQtW2uuinwg@mail.gmail.com>

On Wed, Dec 23, 2015 at 7:17 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> Here's another attempt to resolve this issue based on the surveys and
> accompanying discussions.
>
> As the javadocs already note, method whenComplete is intended to
> preserve outcomes. We should further emphasize this by adding:
>
>      * <p> Unlike method {@link #handle}, this method is not designed
>      * to translate completion outcomes, so the supplied action should
>      * not throw an exception.
>

The javadocs weren't at all clear about this intention. The parallels
between the handle and whenComplete javadocs made it very easy for me to
see whenComplete as the void-returning version of handle (although I was
struck by the oddness of the name choices). The first real doubt in my mind
was introduced by Chris Purcell's comment about resource cleanup.

But given the proposed clarification of intent, and (importantly) given the
argument below about avoiding behavioral modification of the CF spec, I now
agree that option B (E1 with suppressed E2) is the best choice.

--tim


An exception thrown in a whenComplete action violates the intent to
> preserve outcomes, so almost any policy (possibly even stating that
> the effects are undefined) might be defensible. However, the one we
> chose (A) allowed an exception to be swallowed, impairing diagnosis of
> usage problems.  Each of the other surveyed options avoids this
> problem, and each them has advantages (and votes).  The only one that
> does not require behavioral modification of the CompletionStage spec
> (rather than just the CompletableFuture implementation) is option B
> (to add the action exception as a suppressed exception of the incoming
> exception).  So this choice does not require change in any other
> implementations of the interface.  Option B also got the most
> "acceptable" votes (in question 2) of survey 2. Here are results
> from the 29 voters. (Questions are repasted below.)
>
> Option  Preferred Acceptable
> A       1         5
> B       4         18
> C       8         12
> D       9         17
> E       4         15
>
> (A few people skipped question 1. Also, some did not include
> question 1 choice in 2. The above table is adjusted to include them.)
>
> Options C and D got more first-choice votes, indicating that they
> probably would have been better choices in the original spec. But the
> pattern of votes suggests that no choice is widely agreed on as enough
> better to risk an interface spec change.
>
> Given all this, I propose we continue with option B (the current
> in-progress jdk9 update) in the CompletableFuture implementation. Plus
> improve the above CompletionStage spec clarification to better describe
> outcomes, as suggested by Joe and others. Here's whenComplete. the
> whnCompleteAsync versions are almost identical.
>
>      * <p> Unlike method {@link #handle}, this method is not designed
>      * to translate completion outcomes, so the supplied action should
>      * not throw an exception. However, if it does, the following
>      * rules apply: If this stage completed normally but the supplied
>      * action throws an exception, then the returned stage completes
>      * exceptionally with the supplied action's exception. Or, if this
>      * stage completed exceptionally and the supplied action throws an
>      * exception, then the returned stage completes exceptionally with
>      * this stage's exception.
>      *
>
> Any objections?
>
> -Doug
>
> ... survey 2
>
> Q1. Given
>
>   CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
>      if (true)
>         throw new FirstException();
>      else
>         return "A";
>    });
>
>   CompletableFuture<String> f2 = f1.whenComplete((result, exception) -> {
>     if (true)
>        throw new SecondException();
>    });
>
> Where "if (true)" shows the paths of interest in this question. These
> might arise from explicit error checks, programming errors, resource
> failures, and/or translated rethrows.
>
> What should be the completed value of f2?
>
> A. The FirstException. In other words, preserve the source outcome (only)
> if exceptional, ignoring the SecondException.
>
> B. The FirstException, with the SecondException as its suppressed
> exception.  In other words, preserve but modify the source exception to
> record the SecondException.
>
> C. The SecondException. In other words, replace the source outcome
> (whether it is exceptional or not).
>
> D. The SecondException, with the FirstException as its suppressed
> exception.  In other words, replace the source outcome, but if exceptional,
> record it as a suppressedException of the SecondException.
>
> E. A new CompletionException, with the FirstException as its cause and the
> SecondException as its suppressed exception. In other words, indicate that
> throwing an exception in whenComplete is a different form of error.
>
> Q2. Even if you don't prefer them, which of the above choices are
> acceptable?
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151223/fe199a79/attachment.html>

From openjdk at duigou.org  Wed Dec 30 15:18:49 2015
From: openjdk at duigou.org (Mike Duigou)
Date: Wed, 30 Dec 2015 12:18:49 -0800
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet review followup
Message-ID: <473d851e7986e6e7569c4780568121f8@sonic.net>

Dr Heinz M. Kabutz <heinz at javaspecialists.eu> wrote:
> At the moment you can construct a CopyOnWriteArrayNavigableSet for a 
> type that does not have a natural ordering and without specifying a 
> comparator.  I think that makes our lives a lot harder in the 
> implementation.  Better would be to force the user to pass in a correct 
> Comparator for that type.  That way we know that we always have one and 
> we don't need to check for null
anymore.  ... It is easy enough to pass in Comparator.naturalOrder() and 
that also checks that E is in fact Comparable.

This seems like a very reasonable idea. I have always disliked the use 
of null as a sentinel value.

I have also added the static create() factory methods suggested by Chris 
Povirk though I did not make the constructors private as this would be 
too unusual for a JDK class.

> Dr Heinz M. Kabutz <heinz at javaspecialists.eu> wrote:

> 1. In the JavaDoc comment, probably use &lt;Handler> instead of 
> <Handler>

The entire block is wrapped with {@code } so this would result in &lt; 
being rendered rather than <

> 2. I would probably delegate to the Integer.compare(int, int) method in 
>  your Handler otherwise we might get overflows resulting in incorrect 
> comparisons.

Good catch. Done.

> 3. Inside class X in the JavaDocs, use the diamond operator

Done.

> 4. Unless there is a compelling reason, I would make both comparator 
> and
al fields private.

The package private access is done so that accessor methods are not 
needed for BoundedNavigableSet. This is typical within the 
j.u.concurrent classes.

> 5. I would make the internal constructor also private:

It is package private so that it can be called from tests.

6. Where you use the wrapped COWArrayList for locking, instead of
synchronized(super.al.lock)

You may be looking at an old implementation of COWArrayList. In the 
latest JDK9 repo the type of locking has been changed to a standard Java 
monitor.

> 7. I dislike turning off unchecked warnings.

Agreed. I tried your suggestion and found that warnings were still 
generated for the comparator assignment so I opted to leave things as 
they are/were.

> 8. Since we have type erasure in generics, it would probably be also a  
> bit more accurate to use Object[] instead of E[].  See the other 
> classes in java.util.* for comparison.  I understand why you did it - 
> to get Arrays.binarySort() to work.  However, it is a bit messy that 
> one could construct a CopyOnWriteArrayNavigableSet with a generic type 
> that is not Comparable and without a Comparator and where we would get 
> an ClassCastException the moment we use it.

Agreed that the use of Object[] or E[] is inconsistent across 
java.util.* Generally the policy has been to use whichever is 
convenient.

> 9. The fromLoc and toLoc methods both have the same code for finding 
> the
comparator

Removed by eliminating null for natural order.

> 10. I am concerned by the number of methods that are being called 
> whilst holding locks.  Whilst I don't have any concrete example, I am 
> concerned that this could lead to deadlocks.

We only lock on one private object from our own instance so I don't 
believe there's any risk of deadlock.


Thank you for the feedback and to those who provided earlier feedback 
and off-list feedback.

Once I have done some tidying and retesting I will publish an updated 
version of the source.

Mike

From openjdk at duigou.org  Wed Dec 30 17:53:39 2015
From: openjdk at duigou.org (Mike Duigou)
Date: Wed, 30 Dec 2015 14:53:39 -0800
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for Java 9
Message-ID: <dd65a0250377f19bdc744723f939311f@sonic.net>

Hello All;

Enclosed is a new draft of the CopyOnWriteArrayNavigableSet 
implementation I have been working on for Java 9. This version 
incorporates review feedback from November and should be very nearly 
complete and ready for submission. It is not to late to provide feedback 
though, so if you have any comments or suggestions feel free to send 
them to this list.

I am planning to post a standalone version of this class on github and 
probably will publish it as a maven package for use with Java 7 and Java 
8. This version will have he same class name and API but will be in a 
different package.

Cheers,

Mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151230/93a4fb0c/attachment-0001.html>

From heinz at javaspecialists.eu  Wed Dec 30 18:44:54 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Wed, 30 Dec 2015 23:44:54 +0000
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet review
	followup
In-Reply-To: <473d851e7986e6e7569c4780568121f8@sonic.net>
References: <473d851e7986e6e7569c4780568121f8@sonic.net>
Message-ID: <56846C76.70700@javaspecialists.eu>


> 6. Where you use the wrapped COWArrayList for locking, instead of
> synchronized(super.al.lock)
>
> You may be looking at an old implementation of COWArrayList. In the 
> latest JDK9 repo the type of locking has been changed to a standard 
> Java monitor.
Indeed I was - thank you for that correction.
>> 10. I am concerned by the number of methods that are being called 
>> whilst holding locks.  Whilst I don't have any concrete example, I am 
>> concerned that this could lead to deadlocks.
>
> We only lock on one private object from our own instance so I don't 
> believe there's any risk of deadlock.
Right, in the version I was looking at you had two - the ReentrantLock 
and the synchronized.  I will still need to check this more carefully, 
considering how long Vector contained a deadlock even with what seemed 
like a single lock :-)

From jini at zeus.net.au  Wed Dec 30 20:27:18 2015
From: jini at zeus.net.au (Peter)
Date: Thu, 31 Dec 2015 11:27:18 +1000 (AEST)
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet review
	followup
Message-ID: <7fe12acb1bc7497c68c4335361dbd727@org.tizen.email>

An option might be a single threaded executor, ?so all writes are uncontended and written by the same thread, then make all access volatile.


Sent from my Samsung device.
?
??Include original message
---- Original message ----
From: Dr Heinz M. Kabutz <heinz at javaspecialists.eu>
Sent: 31/12/2015 09:44:54 am
To: Mike Duigou <openjdk at duigou.org>
Cc: Concurrency Interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] CopyOnWriteArrayNavigableSet review followup


>?6.?Where?you?use?the?wrapped?COWArrayList?for?locking,?instead?of 
>?synchronized(super.al.lock) 
> 
>?You?may?be?looking?at?an?old?implementation?of?COWArrayList.?In?the? 
>?latest?JDK9?repo?the?type?of?locking?has?been?changed?to?a?standard? 
>?Java?monitor. 
Indeed?I?was?-?thank?you?for?that?correction. 
>>?10.?I?am?concerned?by?the?number?of?methods?that?are?being?called? 
>>?whilst?holding?locks.??Whilst?I?don't?have?any?concrete?example,?I?am? 
>>?concerned?that?this?could?lead?to?deadlocks. 
> 
>?We?only?lock?on?one?private?object?from?our?own?instance?so?I?don't? 
>?believe?there's?any?risk?of?deadlock. 
Right,?in?the?version?I?was?looking?at?you?had?two?-?the?ReentrantLock? 
and?the?synchronized.??I?will?still?need?to?check?this?more?carefully,? 
considering?how?long?Vector?contained?a?deadlock?even?with?what?seemed? 
like?a?single?lock?:-) 
_______________________________________________ 
Concurrency-interest?mailing?list 
Concurrency-interest at cs.oswego.edu 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151231/068d0177/attachment.html>

From heinz at javaspecialists.eu  Thu Dec 31 05:09:02 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 31 Dec 2015 10:09:02 +0000
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for
 Java 9
In-Reply-To: <dd65a0250377f19bdc744723f939311f@sonic.net>
References: <dd65a0250377f19bdc744723f939311f@sonic.net>
Message-ID: <5684FEBE.9090404@javaspecialists.eu>

In your constructor that takes an Iterable, I would probably have the 
last case first add the elements to an ArrayList and then add those to 
with your clever addAll() bulk method:

        } else {
            this.comparator = (Comparator<? super E>) 
Comparator.naturalOrder();
            this.al = new CopyOnWriteArrayList<>();
            if (c instanceof Collection) {
                CopyOnWriteArrayNavigableSet.addAll(this, ((Collection) c));
            } else {
*                ArrayList<E> elements = new ArrayList<>();
                for(E e : c) {
                    elements.add(e);
                }
                CopyOnWriteArrayNavigableSet.addAll(this, elements);*
            }
        }

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz



Mike Duigou wrote:
> Hello All;
>
> Enclosed is a new draft of the CopyOnWriteArrayNavigableSet 
> implementation I have been working on for Java 9. This version 
> incorporates review feedback from November and should be very nearly 
> complete and ready for submission. It is not to late to provide 
> feedback though, so if you have any comments or suggestions feel free 
> to send them to this list.
>
> I am planning to post a standalone version of this class on github and 
> probably will publish it as a maven package for use with Java 7 and 
> Java 8. This version will have he same class name and API but will be 
> in a different package.
>
> Cheers,
>
> Mike
>
> ------------------------------------------------------------------------
>
> /* * Written by Doug Lea & Mike Duigou with assistance from members of 
> JCP JSR-166 * Expert Group and released to the public domain, as 
> explained at * http://creativecommons.org/publicdomain/zero/1.0/ */ 
> package java.util.concurrent; import java.lang.reflect.Array; import 
> java.util.Collection; import java.util.AbstractSet; import 
> java.util.Arrays; import java.util.Collections; import 
> java.util.Comparator; import java.util.Iterator; import 
> java.util.List; import java.util.NavigableSet; import 
> java.util.NoSuchElementException; import java.util.Objects; import 
> java.util.SortedSet; import java.util.Spliterator; import 
> java.util.Spliterators; import java.util.function.Predicate; import 
> java.util.function.Consumer; /** * A {@link java.util.NavigableSet} 
> that uses an internal {@link CopyOnWriteArrayList} * for all of its 
> operations. Thus, it shares the same basic properties: *
>
>     * * It is best suited for applications in which set sizes
>       generally * stay small, read-only operations * vastly outnumber
>       mutative operations, and you need * to prevent interference
>       among threads during traversal. *
>     * It is thread-safe. *
>     * Mutative operations ({@code add}, {@code set}, {@code remove},
>       etc.) * are expensive since they usually entail copying the
>       entire underlying * array. *
>     * Iterators do not support the mutative {@code remove} operation. *
>     * Traversal via iterators is fast and cannot encounter *
>       interference from other threads. Iterators rely on * unchanging
>       snapshots of the array at the time the iterators were *
>       constructed. *
>
> * *
>
> *Sample Usage.* The following code sketch uses a * copy-on-write 
> navigable set to maintain a set of ordered Handler objects that * 
> perform some action upon state updates until one of the handlers 
> returns * true indicating that the update has been handled. * *
>
>  {@code
>  * class Handler implements Comparable {
>  *   // returns true if update has been handled
>  *   boolean handle();
>  *
>  *   // ordered from highest to lowest
>  *   public int compareTo(Handler other) { return Integer.compare(priority, other.priority); }
>  * }
>  *
>  * class X {
>  *   // Will use "Natural Order" of Comparables
>  *   private final CopyOnWriteArrayNavigableSet handlers
>  *     = new CopyOnWriteArrayNavigableSet<>();
>  *   public void addHandler(Handler h) { handlers.add(h); }
>  *
>  *   private long internalState;
>  *   private synchronized void changeState() { internalState = ...; }
>  *
>  *   public void update() {
>  *     changeState();
>  *     for (Handler handler : handlers)
>  *       if(handler.handle()) break;
>  *   }
>  * }}
> * *
>
> This class is a member of the * * Java Collections Framework 
> <%7B at docRoot%7D/../technotes/guides/collections/index.html>. * * @see 
> CopyOnWriteArrayList * @since 9 * @author Doug Lea * @author Mike 
> Duigou * @param the type of elements held in this collection */ public 
> class CopyOnWriteArrayNavigableSet extends AbstractSet implements 
> java.io.Serializable, NavigableSet { private static final long 
> serialVersionUID = -3680134489612968105L; /** * Comparator for 
> elements. */ final Comparator comparator; /** * Embedded 
> CopyOnWriteArrayList used to hold the storage of this set. */ final 
> CopyOnWriteArrayList al; /** * Creates a set using the provided 
> comparator with the initial elements * of the provided COWAL. * * 
> @param comparator * @param al */ 
> CopyOnWriteArrayNavigableSet(Comparator comparator, 
> CopyOnWriteArrayList al) { this.comparator = 
> Objects.requireNonNull(comparator, "comparator"); this.al = al; } /** 
> * Creates an empty set which can be used for mutually * {@link 
> java.lang.Comparable Comparable} objects. */ 
> @SuppressWarnings("unchecked") public CopyOnWriteArrayNavigableSet() { 
> this((Comparator) Comparator.naturalOrder()); } /** * Creates an empty 
> set with the specified comparator. * * @param comparator Used for 
> ordering elements. For * {@link java.lang.Comparable Comparable} 
> objects use * {@link Comparator#naturalOrder()} */ public 
> CopyOnWriteArrayNavigableSet(Comparator comparator) { this(comparator, 
> new CopyOnWriteArrayList<>()); } /** * Creates a set containing all of 
> the elements of the specified * Iterable. If c is a {@link SortedSet 
> sorted set} then the same * Comparator is used. * * @param c the 
> elements to initially contain * @throws NullPointerException if the 
> specified collection is null */ @SuppressWarnings("unchecked") public 
> CopyOnWriteArrayNavigableSet(Iterable c) { if (c.getClass() == 
> CopyOnWriteArrayNavigableSet.class) { this.comparator = 
> ((CopyOnWriteArrayNavigableSet) c).comparator; this.al = new 
> CopyOnWriteArrayList<>(); 
> this.al.setArray(((CopyOnWriteArrayNavigableSet) c).al.getArray()); } 
> else if (c instanceof SortedSet) { Comparator compare = ((SortedSet) 
> c).comparator(); this.comparator = compare == null ? (Comparator) 
> Comparator.naturalOrder() : compare; this.al = new 
> CopyOnWriteArrayList<>(((SortedSet) c)); } else { this.comparator = 
> (Comparator) Comparator.naturalOrder(); this.al = new 
> CopyOnWriteArrayList<>(); if (c instanceof Collection) { 
> CopyOnWriteArrayNavigableSet.addAll(this, ((Collection) c)); } else { 
> for(E e : c) { add(this, e); } } } } /** * Creates a new empty 
> CopyOnWriteArrayNavigableSet using natural order * ordering. * @param 
> Type of elements * @return new CopyOnWriteArrayNavigableSet */ public 
> static > CopyOnWriteArrayNavigableSet create() { return new 
> CopyOnWriteArrayNavigableSet<>(); } /** * Creates a new 
> CopyOnWriteArrayNavigableSet of the provided elements using * natural 
> order ordering. * @param Type of elements * @param contents initial 
> elements for the set. * @return new CopyOnWriteArrayNavigableSet */ 
> public static > CopyOnWriteArrayNavigableSet create(Iterable contents) 
> { return new CopyOnWriteArrayNavigableSet<>(contents); } /** * Creates 
> a new empty CopyOnWriteArrayNavigableSet using provided * comparator 
> for ordering. * @param Type of elements * @param comparator The 
> comparator to use for ordering. * @return new 
> CopyOnWriteArrayNavigableSet */ public static 
> CopyOnWriteArrayNavigableSet create(Comparator comparator) { return 
> new CopyOnWriteArrayNavigableSet<>(comparator); } @Override 
> @SuppressWarnings("unchecked") public boolean contains(Object o) { 
> return Arrays.binarySearch((E[]) al.getArray(), (E) o, comparator) >= 
> 0; } @Override public boolean remove(Object o) { synchronized(al.lock) 
> { @SuppressWarnings("unchecked") E[] array = (E[]) al.getArray(); 
> @SuppressWarnings("unchecked") int loc = Arrays.binarySearch(array, 
> (E) o, comparator); if(loc >= 0) { al.remove(loc); return true; } 
> return false; } } @Override public boolean add(E e) { return add(this, 
> e); } private static boolean add(CopyOnWriteArrayNavigableSet cowans, 
> E e) { Objects.requireNonNull(e, "e"); synchronized(cowans.al.lock) { 
> @SuppressWarnings("unchecked") E[] array = (E[]) cowans.al.getArray(); 
> int loc = Arrays.binarySearch(array, e, cowans.comparator); if(loc < 
> 0) { cowans.al.add(-1 - loc, e); return true; } return false; } } 
> @Override @SuppressWarnings("unchecked") public boolean 
> containsAll(Collection c) { @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); for(Object each : c) { 
> if(Arrays.binarySearch(array, (E) each, comparator) < 0) { return 
> false; } } return true; } @Override public boolean addAll(Collection 
> c) { return CopyOnWriteArrayNavigableSet.addAll(this, c); } 
> @SuppressWarnings("unchecked") private static boolean 
> addAll(CopyOnWriteArrayNavigableSet cowans, Collection c) { Object[] 
> cs = c.toArray(); if (cs.length == 0) return false; if(cs.length == 1) 
> { return cowans.add((E) cs[0]); } synchronized (cowans.al.lock) { E[] 
> array = (E[]) cowans.al.getArray(); int len = array.length; int added 
> = 0; // uniquify and compact elements in cs for (int i = 0; i < 
> cs.length; ++i) { Object e = Objects.requireNonNull(cs[i]); if 
> (Arrays.binarySearch(array, (E) e, cowans.comparator) < 0) { int at = 
> Arrays.binarySearch((E[]) cs, 0, added, (E) e, cowans.comparator); 
> if(at < 0) { // insertion sort it into low portion of cs. at = -at - 
> 1; //System.out.println( Arrays.asList(cs) + " len:" + cs.length + " 
> e:" + e + " at:" + at + " added:" + added); System.arraycopy(cs, at, 
> cs, at + 1, added++ - at); cs[at] = e; } } } if (added > 0) { Object[] 
> newElements = (Object[]) 
> Array.newInstance(array.getClass().getComponentType(), len + added); 
> --len; --added; for(int i = newElements.length - 1; i >= 0; i--) { // 
> merge into resulting array. Both array and cs are sorted. 
> newElements[i] = len >= 0 && (added < 0 || 
> cowans.comparator.compare(array[len], (E) cs[added]) > 0) ? 
> array[len--] : cs[added--]; } cowans.al.setArray(newElements); return 
> true; } return false; } } @Override public Iterator iterator() { 
> return al.iterator(); } @Override public int size() { return 
> al.size(); } @Override public boolean removeIf(Predicate filter) { 
> return al.removeIf(filter); } @Override public void forEach(Consumer 
> action) { al.forEach(action); } @Override public boolean 
> retainAll(Collection c) { return al.retainAll(c); } @Override public 
> boolean removeAll(Collection c) { return al.removeAll(c); } @Override 
> public Object[] toArray() { return al.toArray(); } @Override public 
> T[] toArray(T[] a) { return al.toArray(a); } @Override public void 
> clear() { al.clear(); } /** * Returns a {@link Spliterator} over the 
> elements in this set in the order * in which these elements were 
> added. * *
>
> The {@code Spliterator} reports {@link Spliterator#ORDERED}, * {@link 
> Spliterator#NONNULL}, {@link Spliterator#IMMUTABLE}, * {@link 
> Spliterator#DISTINCT}, and {@link Spliterator#SIZED}. * *
>
> The spliterator provides a snapshot of the state of the set * when the 
> spliterator was constructed. No synchronization is needed while * 
> operating on the spliterator. * * @return a {@code Spliterator} over 
> the elements in this set */ @Override public Spliterator spliterator() 
> { return Spliterators.spliterator (al.getArray(), Spliterator.ORDERED 
> | Spliterator.NONNULL | Spliterator.IMMUTABLE | Spliterator.DISTINCT); 
> } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | // +---+---+---+---+ // 
> lower(0) = null // lower(2) = null // lower(3) = 2 // lower(8) = 6 // 
> lower(9) = 8 @Override @SuppressWarnings("unchecked") public E lower(E 
> e) { E[] array = (E[]) al.getArray(); int loc = 
> Arrays.binarySearch(array, e, comparator); return loc > 0 ? array[loc 
> - 1] : loc < -1 // zero or minus one means nothing strictly lower. ? 
> array[-2 - loc] : null; } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | // 
> +---+---+---+---+ // floor(0) = null // floor(2) = 2 // floor(3) = 2 
> // floor(8) = 8 // floor(9) = 8 @Override 
> @SuppressWarnings("unchecked") public E floor(E e) { E[] array = (E[]) 
> al.getArray(); int loc = Arrays.binarySearch(array, e, comparator); 
> return loc >= 0 ? array[loc] : loc < -1 // minus one means nothing 
> matching or lower. ? array[-2 - loc] : null; } // +---+---+---+---+ // 
> | 2 | 4 | 6 | 8 | // +---+---+---+---+ // ceiling(0) = 2 // ceiling(2) 
> = 2 // ceiling(3) = 4 // ceiling(8) = 8 // ceiling(9) = null @Override 
> @SuppressWarnings("unchecked") public E ceiling(E e) { E[] array = 
> (E[]) al.getArray(); int loc = Arrays.binarySearch(array, e, 
> comparator); return loc >= 0 ? array[loc] : -loc < array.length ? 
> array[-1 - loc] : null; } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | // 
> +---+---+---+---+ // higher(0) = 2 // higher(2) = 4 // higher(3) = 4 
> // higher(8) = null // higher(9) = null @Override 
> @SuppressWarnings("unchecked") public E higher(E e) { E[] array = 
> (E[]) al.getArray(); int loc = Arrays.binarySearch(array, e, 
> comparator); return loc >= 0 ? (loc < array.length - 1 ) ? array[loc + 
> 1] : null : -loc < array.length ? array[-1 - loc] : null; } @Override 
> public E pollFirst() { if(al.isEmpty()) return null; 
> synchronized(al.lock) { if(al.isEmpty()) return null; E result = 
> al.remove(0); return result; } } @Override public E pollLast() { 
> if(al.isEmpty()) return null; synchronized(al.lock) { if(al.isEmpty()) 
> return null; E result = al.remove(al.size() - 1); return result; } } 
> @Override public NavigableSet descendingSet() { return new 
> BoundedNavigableSet<>(comparator, al, false, null, false, false, null, 
> false, true); } @Override @SuppressWarnings("unchecked") public 
> Iterator descendingIterator() { final Object[] array = al.getArray(); 
> return array.length == 0 ? Collections.emptyIterator() : new 
> Iterator() { int index = array.length - 1; @Override public boolean 
> hasNext() { return index >= 0; } @Override public E next() { if 
> (hasNext()) { return (E) array[index--]; } else { throw new 
> NoSuchElementException(); } } }; } @Override public NavigableSet 
> subSet(E fromElement, boolean fromInclusive, E toElement, boolean 
> toInclusive) { return new BoundedNavigableSet<>(comparator, al, true, 
> fromElement, fromInclusive, true, toElement, toInclusive, false); } 
> @Override public NavigableSet headSet(E toElement, boolean inclusive) 
> { return new BoundedNavigableSet<>(comparator, al, false, null, false, 
> true, toElement, inclusive, false); } @Override public NavigableSet 
> tailSet(E fromElement, boolean inclusive) { return new 
> BoundedNavigableSet<>(comparator, al, true, fromElement, inclusive, 
> false, null, false, false); } @Override public SortedSet subSet(E 
> fromElement, E toElement) { return subSet(fromElement, true, 
> toElement, false); } @Override public SortedSet headSet(E toElement) { 
> return headSet(toElement, false); } @Override public SortedSet 
> tailSet(E fromElement) { return tailSet(fromElement, true); } 
> @Override public Comparator comparator() { return comparator; } 
> @Override public E first() { if(al.isEmpty()) throw new 
> NoSuchElementException(); @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); if(array.length == 0) throw new 
> NoSuchElementException(); return array[0]; } @Override public E last() 
> { if(al.isEmpty()) throw new NoSuchElementException(); 
> @SuppressWarnings("unchecked") E[] array = (E[]) al.getArray(); 
> if(array.length == 0) throw new NoSuchElementException(); return 
> array[array.length - 1]; } private static class BoundedNavigableSet 
> extends CopyOnWriteArrayNavigableSet { private static final long 
> serialVersionUID = 3830104881368453055L; /** * If true then iteration 
> is done in descending order. */ final boolean descending; /** * If 
> true then a lower bound relative to the super set. */ final boolean 
> lowerBounded; /** * If true then we have an upper bound relative to 
> the super set. */ final boolean upperBounded; /** * If true then the 
> lower bound is included in the set. */ final boolean lowerInclusive; 
> /** * If true then the upper bound is included in the set. */ final 
> boolean upperInclusive; /** * The value of the lower bound. */ final E 
> lowerBound; /** * The value of the upper bound. */ final E upperBound; 
> @SuppressWarnings("unchecked") public BoundedNavigableSet( Comparator 
> comparator, CopyOnWriteArrayList al, boolean lowerBounded, E 
> fromElement, boolean lowerInclusive, boolean upperBounded, E 
> toElement, boolean upperInclusive, boolean descending) { 
> super(comparator, al); this.descending = descending; if (lowerBounded 
> && upperBounded) { int fromCompared = 
> Integer.signum(comparator.compare(fromElement,toElement)); int 
> toCompared = 
> Integer.signum(comparator.compare(toElement,fromElement)); 
> if(fromCompared != -toCompared) { throw new 
> IllegalArgumentException("inconsistent comparator"); } if 
> (!descending) { if (fromCompared > 0) { throw new 
> IllegalArgumentException("upper < lower"); } } else { if (fromCompared 
> < 0) { throw new IllegalArgumentException("upper < lower"); } } } 
> this.lowerBounded = lowerBounded; this.lowerBound = fromElement; 
> this.lowerInclusive = lowerInclusive; this.upperBounded = 
> upperBounded; this.upperBound = toElement; this.upperInclusive = 
> upperInclusive; } @Override public boolean add(E e) { return 
> super.add(inBounds(e)); } @Override @SuppressWarnings("unchecked") 
> public boolean contains(Object o) { return checkInBounds((E) o) && 
> super.contains(o); } @Override @SuppressWarnings("unchecked") public 
> Comparator comparator() { return (Comparator) (descending ? 
> comparator.reversed() : comparator); } @Override public NavigableSet 
> descendingSet() { return new BoundedNavigableSet<>( comparator, al, 
> upperBounded, upperBound, upperInclusive, lowerBounded, lowerBound, 
> lowerInclusive, !descending); } @Override public NavigableSet subSet(E 
> fromElement, boolean fromInclusive, E toElement, boolean toInclusive) 
> { return new BoundedNavigableSet<>( comparator, al, true, 
> inBounds(fromElement), fromInclusive, true, inBounds(toElement), 
> toInclusive, descending); } @Override public NavigableSet headSet(E 
> toElement, boolean inclusive) { return new BoundedNavigableSet<>( 
> comparator, al, lowerBounded, lowerBound, lowerInclusive, true, 
> inBounds(toElement), inclusive, descending); } @Override public 
> NavigableSet tailSet(E fromElement, boolean inclusive) { return new 
> BoundedNavigableSet<>( comparator, al, true, inBounds(fromElement), 
> inclusive, upperBounded, upperBound, upperInclusive, descending); } 
> @Override public SortedSet subSet(E fromElement, E toElement) { return 
> subSet(fromElement, true, toElement, false); } @Override public 
> SortedSet headSet(E toElement) { return headSet(toElement, false); } 
> @Override public SortedSet tailSet(E fromElement) { return 
> tailSet(fromElement, true); } private E inBounds(E element) { if 
> (lowerBounded) { if (lowerInclusive) { if 
> (comparator.compare(lowerBound,element) > 0) { throw new 
> IllegalArgumentException("out of bounds: " + element + " < " + 
> lowerBound); } } else { if (comparator.compare(lowerBound, element) >= 
> 0) { throw new IllegalArgumentException("out of bounds: " + element + 
> " <= " + lowerBound); } } } if (upperBounded) { if (upperInclusive) { 
> if (comparator.compare(upperBound, element) < 0) { throw new 
> IllegalArgumentException("out of bounds: " + element + " > " + 
> upperBound); } } else { if (comparator.compare(upperBound, element) <= 
> 0) { throw new IllegalArgumentException("out of bounds: " + element + 
> " >= " + upperBound); } } } return element; } private boolean 
> checkInBounds(E element) { if (lowerBounded) { if (lowerInclusive) { 
> if (comparator.compare(lowerBound,element) > 0) { return false; } } 
> else { if (comparator.compare(lowerBound, element) >= 0) { return 
> false; } } } if (upperBounded) { if (upperInclusive) { if 
> (comparator.compare(upperBound, element) < 0) { return false; } } else 
> { if (comparator.compare(upperBound, element) <= 0) { return false; } 
> } } return true; } @Override public Iterator descendingIterator() { 
> return makeIterator(!descending); } @Override public void 
> forEach(Consumer action) { Objects.requireNonNull(action, "action"); 
> @SuppressWarnings("unchecked") E[] array = (E[]) al.getArray(); int 
> start = fromLoc(array); int end = toLoc(array); for(int 
> each=start;each filter) { Objects.requireNonNull(filter, "filter"); 
> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); int start = fromLoc(array); int end = 
> toLoc(array); return al.subList(start, end).removeIf(filter); } } 
> @Override public boolean retainAll(Collection c) { 
> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); int start = fromLoc(array); int end = 
> toLoc(array); return al.subList(start, end).retainAll(c); } } 
> @Override public boolean removeAll(Collection c) { 
> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); int start = fromLoc(array); int end = 
> toLoc(array); return al.subList(start, end).removeAll(c); } } 
> @Override public boolean addAll(Collection c) { for (E e : c) 
> inBounds(e); return CopyOnWriteArrayNavigableSet.addAll(this, c); } 
> @Override @SuppressWarnings("unchecked") public boolean 
> containsAll(Collection c) { E[] array = (E[]) al.getArray(); int start 
> = fromLoc(array); int end = toLoc(array); for (Object each : c) { if 
> (Arrays.binarySearch(array, start, end, (E) each, comparator) < 0) { 
> return false; } } return true; } @Override 
> @SuppressWarnings("unchecked") public boolean remove(Object o) { 
> return checkInBounds((E) o) && super.remove(o); } @Override public 
> void clear() { synchronized(al.lock) { @SuppressWarnings("unchecked") 
> E[] array = (E[]) al.getArray(); int start = fromLoc(array); int end = 
> toLoc(array); al.removeRange(start, end); } } 
> @SuppressWarnings("unchecked") private int fromLoc(E[] array) { int 
> start; if(lowerBounded) { start = Arrays.binarySearch(array, 
> lowerBound, comparator == null ? descending ? (Comparator) 
> Comparator.reverseOrder() : null : descending ? comparator.reversed() 
> : comparator); start = start >= 0 ? lowerInclusive ? start : start + 1 
> : -1 - start; } else { start = 0; } return start; } 
> @SuppressWarnings("unchecked") private int toLoc(E[] array) { int end; 
> if(upperBounded) { end = Arrays.binarySearch(array, upperBound, 
> descending ? comparator.reversed() : comparator); end = end >= 0 ? 
> upperInclusive ? end + 1 : end : -1 - end; } else { end = 
> array.length; } return end; } @Override public T[] toArray(T[] a) { 
> return makeArray(a, descending); } @SuppressWarnings("unchecked") 
> public T[] makeArray(T[] a, boolean inDescending) { E[] array = (E[]) 
> al.getArray(); int start = fromLoc(array); int end = toLoc(array); int 
> len = end - start; if (a.length < len) { a = (T[]) 
> Array.newInstance(a.getClass().getComponentType(), len); } 
> System.arraycopy(array, start, a, 0, len); if(len < a.length) a[len] = 
> null; if(inDescending) Collections.reverse(Arrays.asList(a).subList(0, 
> len)); return a; } @Override public Object[] toArray() { return 
> makeArray(new Object[0], descending); } @Override public Iterator 
> iterator() { return makeIterator(descending); } 
> @SuppressWarnings("unchecked") private Iterator makeIterator(boolean 
> inDescending) { List asList; if(inDescending) { asList = 
> Arrays.asList((E[]) makeArray(new Object[0], inDescending)); } else { 
> E[] array = (E[]) al.getArray(); int start = fromLoc(array); int end = 
> toLoc(array); asList = Arrays.asList(array).subList(start, end); } 
> return Collections.unmodifiableList(asList).iterator(); } @Override 
> public int size() { @SuppressWarnings("unchecked") E[] array = (E[]) 
> al.getArray(); return toLoc(array) - fromLoc(array); } @Override 
> @SuppressWarnings("unchecked") public E lower(E e) { E result = 
> descending ? super.higher(e) : super.lower(e); return result != null 
> && checkInBounds(result) ? result : null; } @Override 
> @SuppressWarnings("unchecked") public E floor(E e) { E result = 
> descending ? super.ceiling(e) : super.floor(e); return result != null 
> && checkInBounds(result) ? result : null; } @Override 
> @SuppressWarnings("unchecked") public E ceiling(E e) { E result = 
> descending ? super.floor(e) : super.ceiling(e); return result != null 
> && checkInBounds(result) ? result : null; } @Override 
> @SuppressWarnings("unchecked") public E higher(E e) { E result = 
> descending ? super.lower(e) : super.higher(e); return result != null 
> && checkInBounds(result) ? result : null; } @Override public E 
> pollFirst() { return descending ? doPollLast() : doPollFirst(); } 
> private E doPollFirst() { if(lowerBounded) synchronized(al.lock) { E 
> remove = lowerInclusive ? floor(lowerBound) : higher(lowerBound); 
> if(null != remove) { super.remove(remove); } return remove; } else 
> return super.pollFirst(); } @Override public E pollLast() { return 
> descending ? doPollFirst() : doPollLast(); } private E doPollLast() { 
> if(upperBounded) synchronized(al.lock) { E remove = upperInclusive ? 
> floor(upperBound) : lower(upperBound); if(null != remove) { 
> super.remove(remove); } return remove; } else return super.pollLast(); 
> } @Override public E first() { return descending ? doLast() : 
> doFirst(); } private E doFirst() { E result = lowerInclusive ? 
> ceiling(lowerBound) : higher(lowerBound); if(null == result) { throw 
> new NoSuchElementException(); } return result; } @Override public E 
> last() { return descending ? doFirst() : doLast(); } private E 
> doLast() { E result = upperInclusive ? floor(upperBound) : 
> lower(upperBound); if(null == result) { throw new 
> NoSuchElementException(); } return result; } @Override public 
> Spliterator spliterator() { @SuppressWarnings("unchecked") E[] array = 
> (E[]) al.getArray(); return Spliterators.spliterator( array, 
> fromLoc(array), toLoc(array), Spliterator.ORDERED | 
> Spliterator.NONNULL | Spliterator.IMMUTABLE | Spliterator.DISTINCT); } 
> } }
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151231/a1cd2248/attachment-0001.html>

From heinz at javaspecialists.eu  Thu Dec 31 05:16:12 2015
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Thu, 31 Dec 2015 10:16:12 +0000
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for
 Java 9
In-Reply-To: <5684FEBE.9090404@javaspecialists.eu>
References: <dd65a0250377f19bdc744723f939311f@sonic.net>
	<5684FEBE.9090404@javaspecialists.eu>
Message-ID: <5685006C.5080506@javaspecialists.eu>

May I ask why you made *CopyOnWriteArrayNavigableSet.addAll() *static, 
considering that you are always passing in "*this*" as a parameter?

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz



Dr Heinz M. Kabutz wrote:
> In your constructor that takes an Iterable, I would probably have the 
> last case first add the elements to an ArrayList and then add those to 
> with your clever addAll() bulk method:
>
>         } else {
>             this.comparator = (Comparator<? super E>) 
> Comparator.naturalOrder();
>             this.al = new CopyOnWriteArrayList<>();
>             if (c instanceof Collection) {
>                 CopyOnWriteArrayNavigableSet.addAll(this, 
> ((Collection) c));
>             } else {
> *                ArrayList<E> elements = new ArrayList<>();
>                 for(E e : c) {
>                     elements.add(e);
>                 }
>                 CopyOnWriteArrayNavigableSet.addAll(this, elements);*
>             }
>         }
>
> Regards
>
> Heinz
> -- 
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion since 2005
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>   
>
>
> Mike Duigou wrote:
>> Hello All;
>>
>> Enclosed is a new draft of the CopyOnWriteArrayNavigableSet 
>> implementation I have been working on for Java 9. This version 
>> incorporates review feedback from November and should be very nearly 
>> complete and ready for submission. It is not to late to provide 
>> feedback though, so if you have any comments or suggestions feel free 
>> to send them to this list.
>>
>> I am planning to post a standalone version of this class on github 
>> and probably will publish it as a maven package for use with Java 7 
>> and Java 8. This version will have he same class name and API but 
>> will be in a different package.
>>
>> Cheers,
>>
>> Mike
>>
>> ------------------------------------------------------------------------
>>
>> /* * Written by Doug Lea & Mike Duigou with assistance from members 
>> of JCP JSR-166 * Expert Group and released to the public domain, as 
>> explained at * http://creativecommons.org/publicdomain/zero/1.0/ */ 
>> package java.util.concurrent; import java.lang.reflect.Array; import 
>> java.util.Collection; import java.util.AbstractSet; import 
>> java.util.Arrays; import java.util.Collections; import 
>> java.util.Comparator; import java.util.Iterator; import 
>> java.util.List; import java.util.NavigableSet; import 
>> java.util.NoSuchElementException; import java.util.Objects; import 
>> java.util.SortedSet; import java.util.Spliterator; import 
>> java.util.Spliterators; import java.util.function.Predicate; import 
>> java.util.function.Consumer; /** * A {@link java.util.NavigableSet} 
>> that uses an internal {@link CopyOnWriteArrayList} * for all of its 
>> operations. Thus, it shares the same basic properties: *
>>
>>     * * It is best suited for applications in which set sizes
>>       generally * stay small, read-only operations * vastly outnumber
>>       mutative operations, and you need * to prevent interference
>>       among threads during traversal. *
>>     * It is thread-safe. *
>>     * Mutative operations ({@code add}, {@code set}, {@code remove},
>>       etc.) * are expensive since they usually entail copying the
>>       entire underlying * array. *
>>     * Iterators do not support the mutative {@code remove} operation. *
>>     * Traversal via iterators is fast and cannot encounter *
>>       interference from other threads. Iterators rely on * unchanging
>>       snapshots of the array at the time the iterators were *
>>       constructed. *
>>
>> * *
>>
>> *Sample Usage.* The following code sketch uses a * copy-on-write 
>> navigable set to maintain a set of ordered Handler objects that * 
>> perform some action upon state updates until one of the handlers 
>> returns * true indicating that the update has been handled. * *
>>
>>  {@code
>>  * class Handler implements Comparable {
>>  *   // returns true if update has been handled
>>  *   boolean handle();
>>  *
>>  *   // ordered from highest to lowest
>>  *   public int compareTo(Handler other) { return Integer.compare(priority, other.priority); }
>>  * }
>>  *
>>  * class X {
>>  *   // Will use "Natural Order" of Comparables
>>  *   private final CopyOnWriteArrayNavigableSet handlers
>>  *     = new CopyOnWriteArrayNavigableSet<>();
>>  *   public void addHandler(Handler h) { handlers.add(h); }
>>  *
>>  *   private long internalState;
>>  *   private synchronized void changeState() { internalState = ...; }
>>  *
>>  *   public void update() {
>>  *     changeState();
>>  *     for (Handler handler : handlers)
>>  *       if(handler.handle()) break;
>>  *   }
>>  * }}
>> * *
>>
>> This class is a member of the * * Java Collections Framework 
>> <%7B at docRoot%7D/../technotes/guides/collections/index.html>. * * @see 
>> CopyOnWriteArrayList * @since 9 * @author Doug Lea * @author Mike 
>> Duigou * @param the type of elements held in this collection */ 
>> public class CopyOnWriteArrayNavigableSet extends AbstractSet 
>> implements java.io.Serializable, NavigableSet { private static final 
>> long serialVersionUID = -3680134489612968105L; /** * Comparator for 
>> elements. */ final Comparator comparator; /** * Embedded 
>> CopyOnWriteArrayList used to hold the storage of this set. */ final 
>> CopyOnWriteArrayList al; /** * Creates a set using the provided 
>> comparator with the initial elements * of the provided COWAL. * * 
>> @param comparator * @param al */ 
>> CopyOnWriteArrayNavigableSet(Comparator comparator, 
>> CopyOnWriteArrayList al) { this.comparator = 
>> Objects.requireNonNull(comparator, "comparator"); this.al = al; } /** 
>> * Creates an empty set which can be used for mutually * {@link 
>> java.lang.Comparable Comparable} objects. */ 
>> @SuppressWarnings("unchecked") public CopyOnWriteArrayNavigableSet() 
>> { this((Comparator) Comparator.naturalOrder()); } /** * Creates an 
>> empty set with the specified comparator. * * @param comparator Used 
>> for ordering elements. For * {@link java.lang.Comparable Comparable} 
>> objects use * {@link Comparator#naturalOrder()} */ public 
>> CopyOnWriteArrayNavigableSet(Comparator comparator) { 
>> this(comparator, new CopyOnWriteArrayList<>()); } /** * Creates a set 
>> containing all of the elements of the specified * Iterable. If c is a 
>> {@link SortedSet sorted set} then the same * Comparator is used. * * 
>> @param c the elements to initially contain * @throws 
>> NullPointerException if the specified collection is null */ 
>> @SuppressWarnings("unchecked") public 
>> CopyOnWriteArrayNavigableSet(Iterable c) { if (c.getClass() == 
>> CopyOnWriteArrayNavigableSet.class) { this.comparator = 
>> ((CopyOnWriteArrayNavigableSet) c).comparator; this.al = new 
>> CopyOnWriteArrayList<>(); 
>> this.al.setArray(((CopyOnWriteArrayNavigableSet) c).al.getArray()); } 
>> else if (c instanceof SortedSet) { Comparator compare = ((SortedSet) 
>> c).comparator(); this.comparator = compare == null ? (Comparator) 
>> Comparator.naturalOrder() : compare; this.al = new 
>> CopyOnWriteArrayList<>(((SortedSet) c)); } else { this.comparator = 
>> (Comparator) Comparator.naturalOrder(); this.al = new 
>> CopyOnWriteArrayList<>(); if (c instanceof Collection) { 
>> CopyOnWriteArrayNavigableSet.addAll(this, ((Collection) c)); } else { 
>> for(E e : c) { add(this, e); } } } } /** * Creates a new empty 
>> CopyOnWriteArrayNavigableSet using natural order * ordering. * @param 
>> Type of elements * @return new CopyOnWriteArrayNavigableSet */ public 
>> static > CopyOnWriteArrayNavigableSet create() { return new 
>> CopyOnWriteArrayNavigableSet<>(); } /** * Creates a new 
>> CopyOnWriteArrayNavigableSet of the provided elements using * natural 
>> order ordering. * @param Type of elements * @param contents initial 
>> elements for the set. * @return new CopyOnWriteArrayNavigableSet */ 
>> public static > CopyOnWriteArrayNavigableSet create(Iterable 
>> contents) { return new CopyOnWriteArrayNavigableSet<>(contents); } 
>> /** * Creates a new empty CopyOnWriteArrayNavigableSet using provided 
>> * comparator for ordering. * @param Type of elements * @param 
>> comparator The comparator to use for ordering. * @return new 
>> CopyOnWriteArrayNavigableSet */ public static 
>> CopyOnWriteArrayNavigableSet create(Comparator comparator) { return 
>> new CopyOnWriteArrayNavigableSet<>(comparator); } @Override 
>> @SuppressWarnings("unchecked") public boolean contains(Object o) { 
>> return Arrays.binarySearch((E[]) al.getArray(), (E) o, comparator) >= 
>> 0; } @Override public boolean remove(Object o) { 
>> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
>> (E[]) al.getArray(); @SuppressWarnings("unchecked") int loc = 
>> Arrays.binarySearch(array, (E) o, comparator); if(loc >= 0) { 
>> al.remove(loc); return true; } return false; } } @Override public 
>> boolean add(E e) { return add(this, e); } private static boolean 
>> add(CopyOnWriteArrayNavigableSet cowans, E e) { 
>> Objects.requireNonNull(e, "e"); synchronized(cowans.al.lock) { 
>> @SuppressWarnings("unchecked") E[] array = (E[]) 
>> cowans.al.getArray(); int loc = Arrays.binarySearch(array, e, 
>> cowans.comparator); if(loc < 0) { cowans.al.add(-1 - loc, e); return 
>> true; } return false; } } @Override @SuppressWarnings("unchecked") 
>> public boolean containsAll(Collection c) { 
>> @SuppressWarnings("unchecked") E[] array = (E[]) al.getArray(); 
>> for(Object each : c) { if(Arrays.binarySearch(array, (E) each, 
>> comparator) < 0) { return false; } } return true; } @Override public 
>> boolean addAll(Collection c) { return 
>> CopyOnWriteArrayNavigableSet.addAll(this, c); } 
>> @SuppressWarnings("unchecked") private static boolean 
>> addAll(CopyOnWriteArrayNavigableSet cowans, Collection c) { Object[] 
>> cs = c.toArray(); if (cs.length == 0) return false; if(cs.length == 
>> 1) { return cowans.add((E) cs[0]); } synchronized (cowans.al.lock) { 
>> E[] array = (E[]) cowans.al.getArray(); int len = array.length; int 
>> added = 0; // uniquify and compact elements in cs for (int i = 0; i < 
>> cs.length; ++i) { Object e = Objects.requireNonNull(cs[i]); if 
>> (Arrays.binarySearch(array, (E) e, cowans.comparator) < 0) { int at = 
>> Arrays.binarySearch((E[]) cs, 0, added, (E) e, cowans.comparator); 
>> if(at < 0) { // insertion sort it into low portion of cs. at = -at - 
>> 1; //System.out.println( Arrays.asList(cs) + " len:" + cs.length + " 
>> e:" + e + " at:" + at + " added:" + added); System.arraycopy(cs, at, 
>> cs, at + 1, added++ - at); cs[at] = e; } } } if (added > 0) { 
>> Object[] newElements = (Object[]) 
>> Array.newInstance(array.getClass().getComponentType(), len + added); 
>> --len; --added; for(int i = newElements.length - 1; i >= 0; i--) { // 
>> merge into resulting array. Both array and cs are sorted. 
>> newElements[i] = len >= 0 && (added < 0 || 
>> cowans.comparator.compare(array[len], (E) cs[added]) > 0) ? 
>> array[len--] : cs[added--]; } cowans.al.setArray(newElements); return 
>> true; } return false; } } @Override public Iterator iterator() { 
>> return al.iterator(); } @Override public int size() { return 
>> al.size(); } @Override public boolean removeIf(Predicate filter) { 
>> return al.removeIf(filter); } @Override public void forEach(Consumer 
>> action) { al.forEach(action); } @Override public boolean 
>> retainAll(Collection c) { return al.retainAll(c); } @Override public 
>> boolean removeAll(Collection c) { return al.removeAll(c); } @Override 
>> public Object[] toArray() { return al.toArray(); } @Override public 
>> T[] toArray(T[] a) { return al.toArray(a); } @Override public void 
>> clear() { al.clear(); } /** * Returns a {@link Spliterator} over the 
>> elements in this set in the order * in which these elements were 
>> added. * *
>>
>> The {@code Spliterator} reports {@link Spliterator#ORDERED}, * {@link 
>> Spliterator#NONNULL}, {@link Spliterator#IMMUTABLE}, * {@link 
>> Spliterator#DISTINCT}, and {@link Spliterator#SIZED}. * *
>>
>> The spliterator provides a snapshot of the state of the set * when 
>> the spliterator was constructed. No synchronization is needed while * 
>> operating on the spliterator. * * @return a {@code Spliterator} over 
>> the elements in this set */ @Override public Spliterator 
>> spliterator() { return Spliterators.spliterator (al.getArray(), 
>> Spliterator.ORDERED | Spliterator.NONNULL | Spliterator.IMMUTABLE | 
>> Spliterator.DISTINCT); } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | // 
>> +---+---+---+---+ // lower(0) = null // lower(2) = null // lower(3) = 
>> 2 // lower(8) = 6 // lower(9) = 8 @Override 
>> @SuppressWarnings("unchecked") public E lower(E e) { E[] array = 
>> (E[]) al.getArray(); int loc = Arrays.binarySearch(array, e, 
>> comparator); return loc > 0 ? array[loc - 1] : loc < -1 // zero or 
>> minus one means nothing strictly lower. ? array[-2 - loc] : null; } 
>> // +---+---+---+---+ // | 2 | 4 | 6 | 8 | // +---+---+---+---+ // 
>> floor(0) = null // floor(2) = 2 // floor(3) = 2 // floor(8) = 8 // 
>> floor(9) = 8 @Override @SuppressWarnings("unchecked") public E 
>> floor(E e) { E[] array = (E[]) al.getArray(); int loc = 
>> Arrays.binarySearch(array, e, comparator); return loc >= 0 ? 
>> array[loc] : loc < -1 // minus one means nothing matching or lower. ? 
>> array[-2 - loc] : null; } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | 
>> // +---+---+---+---+ // ceiling(0) = 2 // ceiling(2) = 2 // 
>> ceiling(3) = 4 // ceiling(8) = 8 // ceiling(9) = null @Override 
>> @SuppressWarnings("unchecked") public E ceiling(E e) { E[] array = 
>> (E[]) al.getArray(); int loc = Arrays.binarySearch(array, e, 
>> comparator); return loc >= 0 ? array[loc] : -loc < array.length ? 
>> array[-1 - loc] : null; } // +---+---+---+---+ // | 2 | 4 | 6 | 8 | 
>> // +---+---+---+---+ // higher(0) = 2 // higher(2) = 4 // higher(3) = 
>> 4 // higher(8) = null // higher(9) = null @Override 
>> @SuppressWarnings("unchecked") public E higher(E e) { E[] array = 
>> (E[]) al.getArray(); int loc = Arrays.binarySearch(array, e, 
>> comparator); return loc >= 0 ? (loc < array.length - 1 ) ? array[loc 
>> + 1] : null : -loc < array.length ? array[-1 - loc] : null; } 
>> @Override public E pollFirst() { if(al.isEmpty()) return null; 
>> synchronized(al.lock) { if(al.isEmpty()) return null; E result = 
>> al.remove(0); return result; } } @Override public E pollLast() { 
>> if(al.isEmpty()) return null; synchronized(al.lock) { 
>> if(al.isEmpty()) return null; E result = al.remove(al.size() - 1); 
>> return result; } } @Override public NavigableSet descendingSet() { 
>> return new BoundedNavigableSet<>(comparator, al, false, null, false, 
>> false, null, false, true); } @Override @SuppressWarnings("unchecked") 
>> public Iterator descendingIterator() { final Object[] array = 
>> al.getArray(); return array.length == 0 ? Collections.emptyIterator() 
>> : new Iterator() { int index = array.length - 1; @Override public 
>> boolean hasNext() { return index >= 0; } @Override public E next() { 
>> if (hasNext()) { return (E) array[index--]; } else { throw new 
>> NoSuchElementException(); } } }; } @Override public NavigableSet 
>> subSet(E fromElement, boolean fromInclusive, E toElement, boolean 
>> toInclusive) { return new BoundedNavigableSet<>(comparator, al, true, 
>> fromElement, fromInclusive, true, toElement, toInclusive, false); } 
>> @Override public NavigableSet headSet(E toElement, boolean inclusive) 
>> { return new BoundedNavigableSet<>(comparator, al, false, null, 
>> false, true, toElement, inclusive, false); } @Override public 
>> NavigableSet tailSet(E fromElement, boolean inclusive) { return new 
>> BoundedNavigableSet<>(comparator, al, true, fromElement, inclusive, 
>> false, null, false, false); } @Override public SortedSet subSet(E 
>> fromElement, E toElement) { return subSet(fromElement, true, 
>> toElement, false); } @Override public SortedSet headSet(E toElement) 
>> { return headSet(toElement, false); } @Override public SortedSet 
>> tailSet(E fromElement) { return tailSet(fromElement, true); } 
>> @Override public Comparator comparator() { return comparator; } 
>> @Override public E first() { if(al.isEmpty()) throw new 
>> NoSuchElementException(); @SuppressWarnings("unchecked") E[] array = 
>> (E[]) al.getArray(); if(array.length == 0) throw new 
>> NoSuchElementException(); return array[0]; } @Override public E 
>> last() { if(al.isEmpty()) throw new NoSuchElementException(); 
>> @SuppressWarnings("unchecked") E[] array = (E[]) al.getArray(); 
>> if(array.length == 0) throw new NoSuchElementException(); return 
>> array[array.length - 1]; } private static class BoundedNavigableSet 
>> extends CopyOnWriteArrayNavigableSet { private static final long 
>> serialVersionUID = 3830104881368453055L; /** * If true then iteration 
>> is done in descending order. */ final boolean descending; /** * If 
>> true then a lower bound relative to the super set. */ final boolean 
>> lowerBounded; /** * If true then we have an upper bound relative to 
>> the super set. */ final boolean upperBounded; /** * If true then the 
>> lower bound is included in the set. */ final boolean lowerInclusive; 
>> /** * If true then the upper bound is included in the set. */ final 
>> boolean upperInclusive; /** * The value of the lower bound. */ final 
>> E lowerBound; /** * The value of the upper bound. */ final E 
>> upperBound; @SuppressWarnings("unchecked") public 
>> BoundedNavigableSet( Comparator comparator, CopyOnWriteArrayList al, 
>> boolean lowerBounded, E fromElement, boolean lowerInclusive, boolean 
>> upperBounded, E toElement, boolean upperInclusive, boolean 
>> descending) { super(comparator, al); this.descending = descending; if 
>> (lowerBounded && upperBounded) { int fromCompared = 
>> Integer.signum(comparator.compare(fromElement,toElement)); int 
>> toCompared = 
>> Integer.signum(comparator.compare(toElement,fromElement)); 
>> if(fromCompared != -toCompared) { throw new 
>> IllegalArgumentException("inconsistent comparator"); } if 
>> (!descending) { if (fromCompared > 0) { throw new 
>> IllegalArgumentException("upper < lower"); } } else { if 
>> (fromCompared < 0) { throw new IllegalArgumentException("upper < 
>> lower"); } } } this.lowerBounded = lowerBounded; this.lowerBound = 
>> fromElement; this.lowerInclusive = lowerInclusive; this.upperBounded 
>> = upperBounded; this.upperBound = toElement; this.upperInclusive = 
>> upperInclusive; } @Override public boolean add(E e) { return 
>> super.add(inBounds(e)); } @Override @SuppressWarnings("unchecked") 
>> public boolean contains(Object o) { return checkInBounds((E) o) && 
>> super.contains(o); } @Override @SuppressWarnings("unchecked") public 
>> Comparator comparator() { return (Comparator) (descending ? 
>> comparator.reversed() : comparator); } @Override public NavigableSet 
>> descendingSet() { return new BoundedNavigableSet<>( comparator, al, 
>> upperBounded, upperBound, upperInclusive, lowerBounded, lowerBound, 
>> lowerInclusive, !descending); } @Override public NavigableSet 
>> subSet(E fromElement, boolean fromInclusive, E toElement, boolean 
>> toInclusive) { return new BoundedNavigableSet<>( comparator, al, 
>> true, inBounds(fromElement), fromInclusive, true, 
>> inBounds(toElement), toInclusive, descending); } @Override public 
>> NavigableSet headSet(E toElement, boolean inclusive) { return new 
>> BoundedNavigableSet<>( comparator, al, lowerBounded, lowerBound, 
>> lowerInclusive, true, inBounds(toElement), inclusive, descending); } 
>> @Override public NavigableSet tailSet(E fromElement, boolean 
>> inclusive) { return new BoundedNavigableSet<>( comparator, al, true, 
>> inBounds(fromElement), inclusive, upperBounded, upperBound, 
>> upperInclusive, descending); } @Override public SortedSet subSet(E 
>> fromElement, E toElement) { return subSet(fromElement, true, 
>> toElement, false); } @Override public SortedSet headSet(E toElement) 
>> { return headSet(toElement, false); } @Override public SortedSet 
>> tailSet(E fromElement) { return tailSet(fromElement, true); } private 
>> E inBounds(E element) { if (lowerBounded) { if (lowerInclusive) { if 
>> (comparator.compare(lowerBound,element) > 0) { throw new 
>> IllegalArgumentException("out of bounds: " + element + " < " + 
>> lowerBound); } } else { if (comparator.compare(lowerBound, element) 
>> >= 0) { throw new IllegalArgumentException("out of bounds: " + 
>> element + " <= " + lowerBound); } } } if (upperBounded) { if 
>> (upperInclusive) { if (comparator.compare(upperBound, element) < 0) { 
>> throw new IllegalArgumentException("out of bounds: " + element + " > 
>> " + upperBound); } } else { if (comparator.compare(upperBound, 
>> element) <= 0) { throw new IllegalArgumentException("out of bounds: " 
>> + element + " >= " + upperBound); } } } return element; } private 
>> boolean checkInBounds(E element) { if (lowerBounded) { if 
>> (lowerInclusive) { if (comparator.compare(lowerBound,element) > 0) { 
>> return false; } } else { if (comparator.compare(lowerBound, element) 
>> >= 0) { return false; } } } if (upperBounded) { if (upperInclusive) { 
>> if (comparator.compare(upperBound, element) < 0) { return false; } } 
>> else { if (comparator.compare(upperBound, element) <= 0) { return 
>> false; } } } return true; } @Override public Iterator 
>> descendingIterator() { return makeIterator(!descending); } @Override 
>> public void forEach(Consumer action) { Objects.requireNonNull(action, 
>> "action"); @SuppressWarnings("unchecked") E[] array = (E[]) 
>> al.getArray(); int start = fromLoc(array); int end = toLoc(array); 
>> for(int each=start;each filter) { Objects.requireNonNull(filter, 
>> "filter"); synchronized(al.lock) { @SuppressWarnings("unchecked") E[] 
>> array = (E[]) al.getArray(); int start = fromLoc(array); int end = 
>> toLoc(array); return al.subList(start, end).removeIf(filter); } } 
>> @Override public boolean retainAll(Collection c) { 
>> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
>> (E[]) al.getArray(); int start = fromLoc(array); int end = 
>> toLoc(array); return al.subList(start, end).retainAll(c); } } 
>> @Override public boolean removeAll(Collection c) { 
>> synchronized(al.lock) { @SuppressWarnings("unchecked") E[] array = 
>> (E[]) al.getArray(); int start = fromLoc(array); int end = 
>> toLoc(array); return al.subList(start, end).removeAll(c); } } 
>> @Override public boolean addAll(Collection c) { for (E e : c) 
>> inBounds(e); return CopyOnWriteArrayNavigableSet.addAll(this, c); } 
>> @Override @SuppressWarnings("unchecked") public boolean 
>> containsAll(Collection c) { E[] array = (E[]) al.getArray(); int 
>> start = fromLoc(array); int end = toLoc(array); for (Object each : c) 
>> { if (Arrays.binarySearch(array, start, end, (E) each, comparator) < 
>> 0) { return false; } } return true; } @Override 
>> @SuppressWarnings("unchecked") public boolean remove(Object o) { 
>> return checkInBounds((E) o) && super.remove(o); } @Override public 
>> void clear() { synchronized(al.lock) { @SuppressWarnings("unchecked") 
>> E[] array = (E[]) al.getArray(); int start = fromLoc(array); int end 
>> = toLoc(array); al.removeRange(start, end); } } 
>> @SuppressWarnings("unchecked") private int fromLoc(E[] array) { int 
>> start; if(lowerBounded) { start = Arrays.binarySearch(array, 
>> lowerBound, comparator == null ? descending ? (Comparator) 
>> Comparator.reverseOrder() : null : descending ? comparator.reversed() 
>> : comparator); start = start >= 0 ? lowerInclusive ? start : start + 
>> 1 : -1 - start; } else { start = 0; } return start; } 
>> @SuppressWarnings("unchecked") private int toLoc(E[] array) { int 
>> end; if(upperBounded) { end = Arrays.binarySearch(array, upperBound, 
>> descending ? comparator.reversed() : comparator); end = end >= 0 ? 
>> upperInclusive ? end + 1 : end : -1 - end; } else { end = 
>> array.length; } return end; } @Override public T[] toArray(T[] a) { 
>> return makeArray(a, descending); } @SuppressWarnings("unchecked") 
>> public T[] makeArray(T[] a, boolean inDescending) { E[] array = (E[]) 
>> al.getArray(); int start = fromLoc(array); int end = toLoc(array); 
>> int len = end - start; if (a.length < len) { a = (T[]) 
>> Array.newInstance(a.getClass().getComponentType(), len); } 
>> System.arraycopy(array, start, a, 0, len); if(len < a.length) a[len] 
>> = null; if(inDescending) 
>> Collections.reverse(Arrays.asList(a).subList(0, len)); return a; } 
>> @Override public Object[] toArray() { return makeArray(new Object[0], 
>> descending); } @Override public Iterator iterator() { return 
>> makeIterator(descending); } @SuppressWarnings("unchecked") private 
>> Iterator makeIterator(boolean inDescending) { List asList; 
>> if(inDescending) { asList = Arrays.asList((E[]) makeArray(new 
>> Object[0], inDescending)); } else { E[] array = (E[]) al.getArray(); 
>> int start = fromLoc(array); int end = toLoc(array); asList = 
>> Arrays.asList(array).subList(start, end); } return 
>> Collections.unmodifiableList(asList).iterator(); } @Override public 
>> int size() { @SuppressWarnings("unchecked") E[] array = (E[]) 
>> al.getArray(); return toLoc(array) - fromLoc(array); } @Override 
>> @SuppressWarnings("unchecked") public E lower(E e) { E result = 
>> descending ? super.higher(e) : super.lower(e); return result != null 
>> && checkInBounds(result) ? result : null; } @Override 
>> @SuppressWarnings("unchecked") public E floor(E e) { E result = 
>> descending ? super.ceiling(e) : super.floor(e); return result != null 
>> && checkInBounds(result) ? result : null; } @Override 
>> @SuppressWarnings("unchecked") public E ceiling(E e) { E result = 
>> descending ? super.floor(e) : super.ceiling(e); return result != null 
>> && checkInBounds(result) ? result : null; } @Override 
>> @SuppressWarnings("unchecked") public E higher(E e) { E result = 
>> descending ? super.lower(e) : super.higher(e); return result != null 
>> && checkInBounds(result) ? result : null; } @Override public E 
>> pollFirst() { return descending ? doPollLast() : doPollFirst(); } 
>> private E doPollFirst() { if(lowerBounded) synchronized(al.lock) { E 
>> remove = lowerInclusive ? floor(lowerBound) : higher(lowerBound); 
>> if(null != remove) { super.remove(remove); } return remove; } else 
>> return super.pollFirst(); } @Override public E pollLast() { return 
>> descending ? doPollFirst() : doPollLast(); } private E doPollLast() { 
>> if(upperBounded) synchronized(al.lock) { E remove = upperInclusive ? 
>> floor(upperBound) : lower(upperBound); if(null != remove) { 
>> super.remove(remove); } return remove; } else return 
>> super.pollLast(); } @Override public E first() { return descending ? 
>> doLast() : doFirst(); } private E doFirst() { E result = 
>> lowerInclusive ? ceiling(lowerBound) : higher(lowerBound); if(null == 
>> result) { throw new NoSuchElementException(); } return result; } 
>> @Override public E last() { return descending ? doFirst() : doLast(); 
>> } private E doLast() { E result = upperInclusive ? floor(upperBound) 
>> : lower(upperBound); if(null == result) { throw new 
>> NoSuchElementException(); } return result; } @Override public 
>> Spliterator spliterator() { @SuppressWarnings("unchecked") E[] array 
>> = (E[]) al.getArray(); return Spliterators.spliterator( array, 
>> fromLoc(array), toLoc(array), Spliterator.ORDERED | 
>> Spliterator.NONNULL | Spliterator.IMMUTABLE | Spliterator.DISTINCT); 
>> } } }
>>
>> ------------------------------------------------------------------------
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151231/48944f3d/attachment-0001.html>

From jason_mehrens at hotmail.com  Thu Dec 31 10:13:13 2015
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu, 31 Dec 2015 15:13:13 +0000
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for
 Java 9
In-Reply-To: <dd65a0250377f19bdc744723f939311f@sonic.net>
References: <dd65a0250377f19bdc744723f939311f@sonic.net>
Message-ID: <BN4PR13MB0594179B4D6040C19AA9BE1683FE0@BN4PR13MB0594.namprd13.prod.outlook.com>

Mike,

It appears that this code recreates bug https://bugs.openjdk.java.net/browse/JDK-5045147. When the collection is empty you have to perform a reflexive compare on the given element to screen null and other types that are rejected by the comparator.

Jason

________________________________________
From: concurrency-interest-bounces at cs.oswego.edu <concurrency-interest-bounces at cs.oswego.edu> on behalf of Mike Duigou <openjdk at duigou.org>
Sent: Wednesday, December 30, 2015 4:53 PM
To: Concurrency Interest
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for Java 9

Hello All;

Enclosed is a new draft of the CopyOnWriteArrayNavigableSet
implementation I have been working on for Java 9. This version
incorporates review feedback from November and should be very nearly
complete and ready for submission. It is not to late to provide feedback
though, so if you have any comments or suggestions feel free to send
them to this list.

I am planning to post a standalone version of this class on github and
probably will publish it as a maven package for use with Java 7 and Java
8. This version will have he same class name and API but will be in a
different package.

Cheers,

Mike


From openjdk at duigou.org  Thu Dec 31 15:21:45 2015
From: openjdk at duigou.org (Mike Duigou)
Date: Thu, 31 Dec 2015 12:21:45 -0800
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for
	Java 9
In-Reply-To: <mailman.1.1451581201.9252.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1451581201.9252.concurrency-interest@cs.oswego.edu>
Message-ID: <0fbc4b77077b03d67d88a1f5a2d1fabc@sonic.net>

Jason Mehrens <jason_mehrens at hotmail.com> wrote:
> Mike,
> 
> It appears that this code recreates bug
> https://bugs.openjdk.java.net/browse/JDK-5045147. When the collection
> is empty you have to perform a reflexive compare on the given element
> to screen null and other types that are rejected by the comparator.
> 
> Jason

5045147 is one of my favourite bugs!

Null elements aren't allowed by this implementation, but you are 
certainly correct about incompatible elements being incorrectly accepted 
into an empty Set. When I added the requireNonNull() I foolishly removed 
the forced comparison for empty set. Thank you for noticing.

The internal add() method becomes :

private static <E> boolean add(CopyOnWriteArrayNavigableSet<E> cowans, E 
e) {
     Objects.requireNonNull(e, "e");
     synchronized(cowans.al.lock) {
         @SuppressWarnings("unchecked")
         E[] array = (E[]) cowans.al.getArray();
         int loc = (array.length != 0)
                 ? Arrays.binarySearch(array, e, cowans.comparator)
                 : cowans.comparator().compare(e, e) == 0 ? -1 : 
Integer.MIN_VALUE;
         if(loc < 0) {
             // MIN_VALUE is an impossible index we use as a sentinel for 
bad comparator.
             if (loc == Integer.MIN_VALUE)
                 throw new IllegalArgumentException(
                 "Comparison method violates its general contract!");
             cowans.al.add(-1 - loc, e);
             return true;
         }
         return false;
     }
}

with a similar change in the addAll() method. I opted to use the same 
exception message as thrown by TimSort because that will hopefully 
generate search results pointing unfortunate developers in the direction 
of a solution.

Thanks!

Mike

From jason_mehrens at hotmail.com  Thu Dec 31 17:26:25 2015
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu, 31 Dec 2015 22:26:25 +0000
Subject: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet
 for	Java 9
In-Reply-To: <0fbc4b77077b03d67d88a1f5a2d1fabc@sonic.net>
References: <mailman.1.1451581201.9252.concurrency-interest@cs.oswego.edu>,
	<0fbc4b77077b03d67d88a1f5a2d1fabc@sonic.net>
Message-ID: <BN4PR13MB05944A99301620DCBEC701C683FE0@BN4PR13MB0594.namprd13.prod.outlook.com>

Agreed.  In the BoundedNavigableSet constructor the "inconsistent comparator" message could be replaced with the same TimSort message.  I always wished that TimSort message included the comparator class and the types of both arguments.  However, I agree with your approach of just using the exact message.

Jason

________________________________________
From: concurrency-interest-bounces at cs.oswego.edu <concurrency-interest-bounces at cs.oswego.edu> on behalf of Mike Duigou <openjdk at duigou.org>
Sent: Thursday, December 31, 2015 2:21 PM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] RFR: CopyOnWriteArrayNavigableSet for       Java 9

Jason Mehrens <jason_mehrens at hotmail.com> wrote:
> Mike,
>
> It appears that this code recreates bug
> https://bugs.openjdk.java.net/browse/JDK-5045147. When the collection
> is empty you have to perform a reflexive compare on the given element
> to screen null and other types that are rejected by the comparator.
>
> Jason

5045147 is one of my favourite bugs!

Null elements aren't allowed by this implementation, but you are
certainly correct about incompatible elements being incorrectly accepted
into an empty Set. When I added the requireNonNull() I foolishly removed
the forced comparison for empty set. Thank you for noticing.

The internal add() method becomes :

private static <E> boolean add(CopyOnWriteArrayNavigableSet<E> cowans, E
e) {
     Objects.requireNonNull(e, "e");
     synchronized(cowans.al.lock) {
         @SuppressWarnings("unchecked")
         E[] array = (E[]) cowans.al.getArray();
         int loc = (array.length != 0)
                 ? Arrays.binarySearch(array, e, cowans.comparator)
                 : cowans.comparator().compare(e, e) == 0 ? -1 :
Integer.MIN_VALUE;
         if(loc < 0) {
             // MIN_VALUE is an impossible index we use as a sentinel for
bad comparator.
             if (loc == Integer.MIN_VALUE)
                 throw new IllegalArgumentException(
                 "Comparison method violates its general contract!");
             cowans.al.add(-1 - loc, e);
             return true;
         }
         return false;
     }
}

with a similar change in the addAll() method. I opted to use the same
exception message as thrown by TimSort because that will hopefully
generate search results pointing unfortunate developers in the direction
of a solution.

Thanks!

Mike
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


