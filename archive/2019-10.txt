From viktor.klang at gmail.com  Fri Oct 25 06:11:11 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 25 Oct 2019 10:11:11 +0000
Subject: [concurrency-interest] Low-latency pause in JDK
Message-ID: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>

Hey,

Is there any jdk-builtin Java8+ method which tries to be clever about
low-nanos/micros parking?

I'm currently considering LockSupport.parkNanos but want to avoid having
the Thread parked when parking + wake-up latency is more likely to be much
greater than the requested time.

I.e. some combination of onSpinWait + some non-cache-polluting computation
+ yielding + actual parking. I'd like to avoid having to custom-roll it,
hence the question for prior art ;)

-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191025/4586a15e/attachment.html>

From nigro.fra at gmail.com  Fri Oct 25 06:26:52 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Fri, 25 Oct 2019 19:26:52 +0900
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
Message-ID: <CAKxGtTXK7eBh6DyzpHNhe8A39BDGCyUDBJ1CEt6zgc4yVZXd9A@mail.gmail.com>

I haven't seen anything yet if not on some initial implementations of the
fork join pool, lately removed. If you need something that is more aware of
the OS behaviour eg timeslack_ns probably is something you need to
implement by yourself afaik :( (see
https://github.com/JCTools/JCTools/pull/248#pullrequestreview-248613337)

Il ven 25 ott 2019, 19:14 Viktor Klang via Concurrency-interest <
concurrency-interest at cs.oswego.edu> ha scritto:

> Hey,
>
> Is there any jdk-builtin Java8+ method which tries to be clever about
> low-nanos/micros parking?
>
> I'm currently considering LockSupport.parkNanos but want to avoid having
> the Thread parked when parking + wake-up latency is more likely to be much
> greater than the requested time.
>
> I.e. some combination of onSpinWait + some non-cache-polluting computation
> + yielding + actual parking. I'd like to avoid having to custom-roll it,
> hence the question for prior art ;)
>
> --
> Cheers,
> √
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191025/753b3925/attachment.html>

From nigro.fra at gmail.com  Fri Oct 25 06:28:17 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Fri, 25 Oct 2019 19:28:17 +0900
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CAKxGtTXK7eBh6DyzpHNhe8A39BDGCyUDBJ1CEt6zgc4yVZXd9A@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <CAKxGtTXK7eBh6DyzpHNhe8A39BDGCyUDBJ1CEt6zgc4yVZXd9A@mail.gmail.com>
Message-ID: <CAKxGtTWYjMJog_B4akUSaZO7v-4P_mkF+8ARyW+24qDHSUfFTA@mail.gmail.com>

To not mention that you need to consider counted loops/safepoint polls in
the equation

Il ven 25 ott 2019, 19:26 Francesco Nigro <nigro.fra at gmail.com> ha scritto:

> I haven't seen anything yet if not on some initial implementations of the
> fork join pool, lately removed. If you need something that is more aware of
> the OS behaviour eg timeslack_ns probably is something you need to
> implement by yourself afaik :( (see
> https://github.com/JCTools/JCTools/pull/248#pullrequestreview-248613337)
>
> Il ven 25 ott 2019, 19:14 Viktor Klang via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> ha scritto:
>
>> Hey,
>>
>> Is there any jdk-builtin Java8+ method which tries to be clever about
>> low-nanos/micros parking?
>>
>> I'm currently considering LockSupport.parkNanos but want to avoid having
>> the Thread parked when parking + wake-up latency is more likely to be much
>> greater than the requested time.
>>
>> I.e. some combination of onSpinWait + some non-cache-polluting
>> computation + yielding + actual parking. I'd like to avoid having to
>> custom-roll it, hence the question for prior art ;)
>>
>> --
>> Cheers,
>> √
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191025/5173111c/attachment.html>

From viktor.klang at gmail.com  Fri Oct 25 07:30:32 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 25 Oct 2019 11:30:32 +0000
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CAKxGtTWYjMJog_B4akUSaZO7v-4P_mkF+8ARyW+24qDHSUfFTA@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <CAKxGtTXK7eBh6DyzpHNhe8A39BDGCyUDBJ1CEt6zgc4yVZXd9A@mail.gmail.com>
 <CAKxGtTWYjMJog_B4akUSaZO7v-4P_mkF+8ARyW+24qDHSUfFTA@mail.gmail.com>
Message-ID: <CANPzfU9meqAN3a3C_g2VWipfAxmAftgT8uyvLirE1=Uq0tLCWQ@mail.gmail.com>

Sounds like a good reason for a JDK-official method for it…

On Fri, Oct 25, 2019 at 10:28 AM Francesco Nigro <nigro.fra at gmail.com>
wrote:

> To not mention that you need to consider counted loops/safepoint polls in
> the equation
>
> Il ven 25 ott 2019, 19:26 Francesco Nigro <nigro.fra at gmail.com> ha
> scritto:
>
>> I haven't seen anything yet if not on some initial implementations of the
>> fork join pool, lately removed. If you need something that is more aware of
>> the OS behaviour eg timeslack_ns probably is something you need to
>> implement by yourself afaik :( (see
>> https://github.com/JCTools/JCTools/pull/248#pullrequestreview-248613337)
>>
>> Il ven 25 ott 2019, 19:14 Viktor Klang via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> ha scritto:
>>
>>> Hey,
>>>
>>> Is there any jdk-builtin Java8+ method which tries to be clever about
>>> low-nanos/micros parking?
>>>
>>> I'm currently considering LockSupport.parkNanos but want to avoid having
>>> the Thread parked when parking + wake-up latency is more likely to be much
>>> greater than the requested time.
>>>
>>> I.e. some combination of onSpinWait + some non-cache-polluting
>>> computation + yielding + actual parking. I'd like to avoid having to
>>> custom-roll it, hence the question for prior art ;)
>>>
>>> --
>>> Cheers,
>>> √
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>

-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191025/00bd324d/attachment.html>

From nigro.fra at gmail.com  Fri Oct 25 07:31:33 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Fri, 25 Oct 2019 20:31:33 +0900
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CANPzfU9meqAN3a3C_g2VWipfAxmAftgT8uyvLirE1=Uq0tLCWQ@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <CAKxGtTXK7eBh6DyzpHNhe8A39BDGCyUDBJ1CEt6zgc4yVZXd9A@mail.gmail.com>
 <CAKxGtTWYjMJog_B4akUSaZO7v-4P_mkF+8ARyW+24qDHSUfFTA@mail.gmail.com>
 <CANPzfU9meqAN3a3C_g2VWipfAxmAftgT8uyvLirE1=Uq0tLCWQ@mail.gmail.com>
Message-ID: <CAKxGtTU2eoVQ5N=Fcs8VbkO-Pz1mdo3smsA6PC5JOWFAht7zVg@mail.gmail.com>

+100 totally agree!

Il ven 25 ott 2019, 20:30 Viktor Klang <viktor.klang at gmail.com> ha scritto:

> Sounds like a good reason for a JDK-official method for it…
>
> On Fri, Oct 25, 2019 at 10:28 AM Francesco Nigro <nigro.fra at gmail.com>
> wrote:
>
>> To not mention that you need to consider counted loops/safepoint polls in
>> the equation
>>
>> Il ven 25 ott 2019, 19:26 Francesco Nigro <nigro.fra at gmail.com> ha
>> scritto:
>>
>>> I haven't seen anything yet if not on some initial implementations of
>>> the fork join pool, lately removed. If you need something that is more
>>> aware of the OS behaviour eg timeslack_ns probably is something you need to
>>> implement by yourself afaik :( (see
>>> https://github.com/JCTools/JCTools/pull/248#pullrequestreview-248613337)
>>>
>>> Il ven 25 ott 2019, 19:14 Viktor Klang via Concurrency-interest <
>>> concurrency-interest at cs.oswego.edu> ha scritto:
>>>
>>>> Hey,
>>>>
>>>> Is there any jdk-builtin Java8+ method which tries to be clever about
>>>> low-nanos/micros parking?
>>>>
>>>> I'm currently considering LockSupport.parkNanos but want to avoid
>>>> having the Thread parked when parking + wake-up latency is more likely to
>>>> be much greater than the requested time.
>>>>
>>>> I.e. some combination of onSpinWait + some non-cache-polluting
>>>> computation + yielding + actual parking. I'd like to avoid having to
>>>> custom-roll it, hence the question for prior art ;)
>>>>
>>>> --
>>>> Cheers,
>>>> √
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>
> --
> Cheers,
> √
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191025/44098c03/attachment-0001.html>

From aph at redhat.com  Sat Oct 26 05:21:16 2019
From: aph at redhat.com (Andrew Haley)
Date: Sat, 26 Oct 2019 10:21:16 +0100
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
Message-ID: <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>

On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
> 
> Is there any jdk-builtin Java8+ method which tries to be clever
> about low-nanos/micros parking?
> 
> I'm currently considering LockSupport.parkNanos but want to avoid
> having the Thread parked when parking + wake-up latency is more
> likely to be much greater than the requested time.
> 
> I.e. some combination of onSpinWait + some non-cache-polluting
> computation + yielding + actual parking. I'd like to avoid having to
> custom-roll it, hence the question for prior art ;)

As I understand it, the common wisdom is to wait for about half the
round-trip time for a system call and then park. It doesn't sound
terribly hard to write something to do that.

Please forgive me for digressing, but:

Arm has a mechanism to do this, WFE. When a core fails to obtain a
lock it executes a WFE instruction which waits on the cache line
containing the lock. When that cache line is written to by the core
releasing the lock it awakens the waiting core.

I'd like to find some way to expose this in a high-level language but
it's not at all easy to do.

I believe that Intel has MWAIT which is similar, but it's a privileged
instruction so no use to us.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From nigro.fra at gmail.com  Sat Oct 26 06:07:26 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Sat, 26 Oct 2019 12:07:26 +0200
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
Message-ID: <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>

I was hoping that for parking times <  granularity offered by the OS would
make sense a mm_pause (possibility not broken) spin loop while using rdts
to measure the elapsed time (+ lfence, if needed, but maybe with the pause
isn't necessary). And no safepoint polls in the spin wait loop.
I know that on oversubscribed systems (more active threads then core) isn't
a great solution but would be nice to have some way to perform a low
latency sleep.
Implementing by myself saving the safepoint poll to be injected in an
uncounted loop is not that trivial...

Il sab 26 ott 2019, 11:23 Andrew Haley via Concurrency-interest <
concurrency-interest at cs.oswego.edu> ha scritto:

> On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
> >
> > Is there any jdk-builtin Java8+ method which tries to be clever
> > about low-nanos/micros parking?
> >
> > I'm currently considering LockSupport.parkNanos but want to avoid
> > having the Thread parked when parking + wake-up latency is more
> > likely to be much greater than the requested time.
> >
> > I.e. some combination of onSpinWait + some non-cache-polluting
> > computation + yielding + actual parking. I'd like to avoid having to
> > custom-roll it, hence the question for prior art ;)
>
> As I understand it, the common wisdom is to wait for about half the
> round-trip time for a system call and then park. It doesn't sound
> terribly hard to write something to do that.
>
> Please forgive me for digressing, but:
>
> Arm has a mechanism to do this, WFE. When a core fails to obtain a
> lock it executes a WFE instruction which waits on the cache line
> containing the lock. When that cache line is written to by the core
> releasing the lock it awakens the waiting core.
>
> I'd like to find some way to expose this in a high-level language but
> it's not at all easy to do.
>
> I believe that Intel has MWAIT which is similar, but it's a privileged
> instruction so no use to us.
>
> --
> Andrew Haley  (he/him)
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> https://keybase.io/andrewhaley
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191026/42ecb4c2/attachment.html>

From nigro.fra at gmail.com  Sat Oct 26 06:23:30 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Sat, 26 Oct 2019 12:23:30 +0200
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
Message-ID: <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>

I mean RDTSC, missed the final C :P

Il sab 26 ott 2019, 12:07 Francesco Nigro <nigro.fra at gmail.com> ha scritto:

> I was hoping that for parking times <  granularity offered by the OS would
> make sense a mm_pause (possibility not broken) spin loop while using rdts
> to measure the elapsed time (+ lfence, if needed, but maybe with the pause
> isn't necessary). And no safepoint polls in the spin wait loop.
> I know that on oversubscribed systems (more active threads then core)
> isn't a great solution but would be nice to have some way to perform a low
> latency sleep.
> Implementing by myself saving the safepoint poll to be injected in an
> uncounted loop is not that trivial...
>
> Il sab 26 ott 2019, 11:23 Andrew Haley via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> ha scritto:
>
>> On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
>> >
>> > Is there any jdk-builtin Java8+ method which tries to be clever
>> > about low-nanos/micros parking?
>> >
>> > I'm currently considering LockSupport.parkNanos but want to avoid
>> > having the Thread parked when parking + wake-up latency is more
>> > likely to be much greater than the requested time.
>> >
>> > I.e. some combination of onSpinWait + some non-cache-polluting
>> > computation + yielding + actual parking. I'd like to avoid having to
>> > custom-roll it, hence the question for prior art ;)
>>
>> As I understand it, the common wisdom is to wait for about half the
>> round-trip time for a system call and then park. It doesn't sound
>> terribly hard to write something to do that.
>>
>> Please forgive me for digressing, but:
>>
>> Arm has a mechanism to do this, WFE. When a core fails to obtain a
>> lock it executes a WFE instruction which waits on the cache line
>> containing the lock. When that cache line is written to by the core
>> releasing the lock it awakens the waiting core.
>>
>> I'd like to find some way to expose this in a high-level language but
>> it's not at all easy to do.
>>
>> I believe that Intel has MWAIT which is similar, but it's a privileged
>> instruction so no use to us.
>>
>> --
>> Andrew Haley  (he/him)
>> Java Platform Lead Engineer
>> Red Hat UK Ltd. <https://www.redhat.com>
>> https://keybase.io/andrewhaley
>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191026/daf6246b/attachment.html>

From viktor.klang at gmail.com  Sat Oct 26 07:37:37 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sat, 26 Oct 2019 11:37:37 +0000
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
 <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>
Message-ID: <CANPzfU-kQ-V=ZdLbhqFqqEdV=MhvAxhpR2K0sg=G09EGK1p-kg@mail.gmail.com>

Given that the strategy will depend on the runtime environment, a JDK
"intrinsic" would make most sense to me—hence wanting something in the JDK
:)

On Sat, Oct 26, 2019 at 10:23 AM Francesco Nigro <nigro.fra at gmail.com>
wrote:

> I mean RDTSC, missed the final C :P
>
> Il sab 26 ott 2019, 12:07 Francesco Nigro <nigro.fra at gmail.com> ha
> scritto:
>
>> I was hoping that for parking times <  granularity offered by the OS
>> would make sense a mm_pause (possibility not broken) spin loop while using
>> rdts to measure the elapsed time (+ lfence, if needed, but maybe with the
>> pause isn't necessary). And no safepoint polls in the spin wait loop.
>> I know that on oversubscribed systems (more active threads then core)
>> isn't a great solution but would be nice to have some way to perform a low
>> latency sleep.
>> Implementing by myself saving the safepoint poll to be injected in an
>> uncounted loop is not that trivial...
>>
>> Il sab 26 ott 2019, 11:23 Andrew Haley via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> ha scritto:
>>
>>> On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
>>> >
>>> > Is there any jdk-builtin Java8+ method which tries to be clever
>>> > about low-nanos/micros parking?
>>> >
>>> > I'm currently considering LockSupport.parkNanos but want to avoid
>>> > having the Thread parked when parking + wake-up latency is more
>>> > likely to be much greater than the requested time.
>>> >
>>> > I.e. some combination of onSpinWait + some non-cache-polluting
>>> > computation + yielding + actual parking. I'd like to avoid having to
>>> > custom-roll it, hence the question for prior art ;)
>>>
>>> As I understand it, the common wisdom is to wait for about half the
>>> round-trip time for a system call and then park. It doesn't sound
>>> terribly hard to write something to do that.
>>>
>>> Please forgive me for digressing, but:
>>>
>>> Arm has a mechanism to do this, WFE. When a core fails to obtain a
>>> lock it executes a WFE instruction which waits on the cache line
>>> containing the lock. When that cache line is written to by the core
>>> releasing the lock it awakens the waiting core.
>>>
>>> I'd like to find some way to expose this in a high-level language but
>>> it's not at all easy to do.
>>>
>>> I believe that Intel has MWAIT which is similar, but it's a privileged
>>> instruction so no use to us.
>>>
>>> --
>>> Andrew Haley  (he/him)
>>> Java Platform Lead Engineer
>>> Red Hat UK Ltd. <https://www.redhat.com>
>>> https://keybase.io/andrewhaley
>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>

-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191026/01325bec/attachment-0001.html>

From nathanila at gmail.com  Sat Oct 26 09:52:46 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Sat, 26 Oct 2019 07:52:46 -0600
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
Message-ID: <d9356fcd-780a-3a32-abf3-8cdfcc646e3d@gmail.com>

x86 MWAIT is not available but we could simulate this with XACQUIRE and 
PAUSE.  The thread uses XACQUIRE on the cache line and then executes 
PAUSE.  PAUSE takes 100s of cycles.  Hopefully, XACQUIRE will wake up 
the thread from PAUSE.

The downside of pausing the threads execution of instructions is that 
the thread cannot respond to stop the world events.  This will increase 
the time it takes to stop the world.  If we are talking about 1000s of 
cycles, this might not make much of a difference.  On the other hand, 
with GC pause times lower than 1 ms, 1000s of cycles might be a 
significant portion of time.

On x86, it takes about 3,000 cycles to enter and return from a 
System.yield() call on Windows (on a mid-range laptop processor from 8 
years ago).  Any low-latency pause loop has to take into account that if 
it waits 3,000 cycles, then it would have been better to enter the 
kernel in the first place.  Blocking in the kernel will reduce power 
consumption as well as allow other threads to do useful work.  Thus, 
each call site needs to keep statistics on how long the thread waits.  
If the call site is waiting too long too often, then the threads should 
immediately block in the kernel instead of spinning.  This is not easy 
to get right.

Perhaps, a better solution is to provide low-level mechanisms in the JDK 
and let people experiment with how long to spin or wait.

-Nathan

On 10/26/2019 3:21 AM, Andrew Haley via Concurrency-interest wrote:
> On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
>> Is there any jdk-builtin Java8+ method which tries to be clever
>> about low-nanos/micros parking?
>>
>> I'm currently considering LockSupport.parkNanos but want to avoid
>> having the Thread parked when parking + wake-up latency is more
>> likely to be much greater than the requested time.
>>
>> I.e. some combination of onSpinWait + some non-cache-polluting
>> computation + yielding + actual parking. I'd like to avoid having to
>> custom-roll it, hence the question for prior art ;)
> As I understand it, the common wisdom is to wait for about half the
> round-trip time for a system call and then park. It doesn't sound
> terribly hard to write something to do that.
>
> Please forgive me for digressing, but:
>
> Arm has a mechanism to do this, WFE. When a core fails to obtain a
> lock it executes a WFE instruction which waits on the cache line
> containing the lock. When that cache line is written to by the core
> releasing the lock it awakens the waiting core.
>
> I'd like to find some way to expose this in a high-level language but
> it's not at all easy to do.
>
> I believe that Intel has MWAIT which is similar, but it's a privileged
> instruction so no use to us.
>

From dl at cs.oswego.edu  Sat Oct 26 14:07:05 2019
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 26 Oct 2019 14:07:05 -0400
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CANPzfU-kQ-V=ZdLbhqFqqEdV=MhvAxhpR2K0sg=G09EGK1p-kg@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
 <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>
 <CANPzfU-kQ-V=ZdLbhqFqqEdV=MhvAxhpR2K0sg=G09EGK1p-kg@mail.gmail.com>
Message-ID: <3b477d9d-4ad8-d0c9-0d94-228ede031852@cs.oswego.edu>

On 10/26/19 7:37 AM, Viktor Klang via Concurrency-interest wrote:
> Given that the strategy will depend on the runtime environment, a JDK
> "intrinsic" would make most sense to me—hence wanting something in the
> JDK :)

Considering that a general solution would provide the best course of
action whenever entities (for example you, or some thread) momentarily
cannot get something they momentarily want (a lock, a new JDK method),
this is a hard request to fulfill! The best we've been able to do is
make internal choices (in locks, queues, etc) that are OK with respect
to more concrete contexts. In addition to issues that other people have
mentioned, solutions also interact with choice of garbage collector.

I agree that it might be would be nice to expose some of the lower-level
features available on some platforms that might sometimes provide better
performance, but these also tend to be hard to encapsulate in APIs in
ways that do more good than harm. (For example, I have later removed
nearly every occurrence of Thread.yield() in any code I've written after
finding something better or more general.)

And as always (especially in real life), whenever you encounter a
problem involving blocking, the main question to ask is whether there is
something you can do other than block -- helping, choosing alternate
actions, speculating, etc.

-Doug


> 
> On Sat, Oct 26, 2019 at 10:23 AM Francesco Nigro <nigro.fra at gmail.com
> <mailto:nigro.fra at gmail.com>> wrote:
> 
>     I mean RDTSC, missed the final C :P
> 
>     Il sab 26 ott 2019, 12:07 Francesco Nigro <nigro.fra at gmail.com
>     <mailto:nigro.fra at gmail.com>> ha scritto:
> 
>         I was hoping that for parking times <  granularity offered by
>         the OS would make sense a mm_pause (possibility not broken) spin
>         loop while using rdts to measure the elapsed time (+ lfence, if
>         needed, but maybe with the pause isn't necessary). And no
>         safepoint polls in the spin wait loop. 
>         I know that on oversubscribed systems (more active threads then
>         core) isn't a great solution but would be nice to have some way
>         to perform a low latency sleep.
>         Implementing by myself saving the safepoint poll to be injected
>         in an uncounted loop is not that trivial...
> 
>         Il sab 26 ott 2019, 11:23 Andrew Haley via Concurrency-interest
>         <concurrency-interest at cs.oswego.edu
>         <mailto:concurrency-interest at cs.oswego.edu>> ha scritto:
> 
>             On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest
>             wrote:
>             >
>             > Is there any jdk-builtin Java8+ method which tries to be
>             clever
>             > about low-nanos/micros parking?
>             >
>             > I'm currently considering LockSupport.parkNanos but want
>             to avoid
>             > having the Thread parked when parking + wake-up latency is
>             more
>             > likely to be much greater than the requested time.
>             >
>             > I.e. some combination of onSpinWait + some non-cache-polluting
>             > computation + yielding + actual parking. I'd like to avoid
>             having to
>             > custom-roll it, hence the question for prior art ;)
> 
>             As I understand it, the common wisdom is to wait for about
>             half the
>             round-trip time for a system call and then park. It doesn't
>             sound
>             terribly hard to write something to do that.
> 
>             Please forgive me for digressing, but:
> 
>             Arm has a mechanism to do this, WFE. When a core fails to
>             obtain a
>             lock it executes a WFE instruction which waits on the cache line
>             containing the lock. When that cache line is written to by
>             the core
>             releasing the lock it awakens the waiting core.
> 
>             I'd like to find some way to expose this in a high-level
>             language but
>             it's not at all easy to do.
> 
>             I believe that Intel has MWAIT which is similar, but it's a
>             privileged
>             instruction so no use to us.
> 
>             -- 
>             Andrew Haley  (he/him)
>             Java Platform Lead Engineer
>             Red Hat UK Ltd. <https://www.redhat.com>
>             https://keybase.io/andrewhaley
>             EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> 
>             _______________________________________________
>             Concurrency-interest mailing list
>             Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> -- 
> Cheers,
> √
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 



From nigro.fra at gmail.com  Sat Oct 26 14:42:30 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Sat, 26 Oct 2019 20:42:30 +0200
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <3b477d9d-4ad8-d0c9-0d94-228ede031852@cs.oswego.edu>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
 <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>
 <CANPzfU-kQ-V=ZdLbhqFqqEdV=MhvAxhpR2K0sg=G09EGK1p-kg@mail.gmail.com>
 <3b477d9d-4ad8-d0c9-0d94-228ede031852@cs.oswego.edu>
Message-ID: <CAKxGtTUnSdkkahPsfcuFA3PKZaGZY-MQMteD=uXywOZvHc9vVg@mail.gmail.com>

> For example, I have later removed
nearly every occurrence of Thread.yield() in any code I've written after
finding something better or more general

OT: Just curious, where? :)

Il sab 26 ott 2019, 20:08 Doug Lea via Concurrency-interest <
concurrency-interest at cs.oswego.edu> ha scritto:

> On 10/26/19 7:37 AM, Viktor Klang via Concurrency-interest wrote:
> > Given that the strategy will depend on the runtime environment, a JDK
> > "intrinsic" would make most sense to me—hence wanting something in the
> > JDK :)
>
> Considering that a general solution would provide the best course of
> action whenever entities (for example you, or some thread) momentarily
> cannot get something they momentarily want (a lock, a new JDK method),
> this is a hard request to fulfill! The best we've been able to do is
> make internal choices (in locks, queues, etc) that are OK with respect
> to more concrete contexts. In addition to issues that other people have
> mentioned, solutions also interact with choice of garbage collector.
>
> I agree that it might be would be nice to expose some of the lower-level
> features available on some platforms that might sometimes provide better
> performance, but these also tend to be hard to encapsulate in APIs in
> ways that do more good than harm. (For example, I have later removed
> nearly every occurrence of Thread.yield() in any code I've written after
> finding something better or more general.)
>
> And as always (especially in real life), whenever you encounter a
> problem involving blocking, the main question to ask is whether there is
> something you can do other than block -- helping, choosing alternate
> actions, speculating, etc.
>
> -Doug
>
>
> >
> > On Sat, Oct 26, 2019 at 10:23 AM Francesco Nigro <nigro.fra at gmail.com
> > <mailto:nigro.fra at gmail.com>> wrote:
> >
> >     I mean RDTSC, missed the final C :P
> >
> >     Il sab 26 ott 2019, 12:07 Francesco Nigro <nigro.fra at gmail.com
> >     <mailto:nigro.fra at gmail.com>> ha scritto:
> >
> >         I was hoping that for parking times <  granularity offered by
> >         the OS would make sense a mm_pause (possibility not broken) spin
> >         loop while using rdts to measure the elapsed time (+ lfence, if
> >         needed, but maybe with the pause isn't necessary). And no
> >         safepoint polls in the spin wait loop.
> >         I know that on oversubscribed systems (more active threads then
> >         core) isn't a great solution but would be nice to have some way
> >         to perform a low latency sleep.
> >         Implementing by myself saving the safepoint poll to be injected
> >         in an uncounted loop is not that trivial...
> >
> >         Il sab 26 ott 2019, 11:23 Andrew Haley via Concurrency-interest
> >         <concurrency-interest at cs.oswego.edu
> >         <mailto:concurrency-interest at cs.oswego.edu>> ha scritto:
> >
> >             On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest
> >             wrote:
> >             >
> >             > Is there any jdk-builtin Java8+ method which tries to be
> >             clever
> >             > about low-nanos/micros parking?
> >             >
> >             > I'm currently considering LockSupport.parkNanos but want
> >             to avoid
> >             > having the Thread parked when parking + wake-up latency is
> >             more
> >             > likely to be much greater than the requested time.
> >             >
> >             > I.e. some combination of onSpinWait + some
> non-cache-polluting
> >             > computation + yielding + actual parking. I'd like to avoid
> >             having to
> >             > custom-roll it, hence the question for prior art ;)
> >
> >             As I understand it, the common wisdom is to wait for about
> >             half the
> >             round-trip time for a system call and then park. It doesn't
> >             sound
> >             terribly hard to write something to do that.
> >
> >             Please forgive me for digressing, but:
> >
> >             Arm has a mechanism to do this, WFE. When a core fails to
> >             obtain a
> >             lock it executes a WFE instruction which waits on the cache
> line
> >             containing the lock. When that cache line is written to by
> >             the core
> >             releasing the lock it awakens the waiting core.
> >
> >             I'd like to find some way to expose this in a high-level
> >             language but
> >             it's not at all easy to do.
> >
> >             I believe that Intel has MWAIT which is similar, but it's a
> >             privileged
> >             instruction so no use to us.
> >
> >             --
> >             Andrew Haley  (he/him)
> >             Java Platform Lead Engineer
> >             Red Hat UK Ltd. <https://www.redhat.com>
> >             https://keybase.io/andrewhaley
> >             EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> >
> >             _______________________________________________
> >             Concurrency-interest mailing list
> >             Concurrency-interest at cs.oswego.edu
> >             <mailto:Concurrency-interest at cs.oswego.edu>
> >             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > --
> > Cheers,
> > √
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191026/035272cf/attachment.html>

From dl at cs.oswego.edu  Sat Oct 26 15:37:24 2019
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 26 Oct 2019 15:37:24 -0400
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <CAKxGtTUnSdkkahPsfcuFA3PKZaGZY-MQMteD=uXywOZvHc9vVg@mail.gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <CAKxGtTUagEO-cYqhsTJarbdfqk=m_F6qURZnEkw8QrLWdP_KWA@mail.gmail.com>
 <CAKxGtTVjmLgYCTK6ozqHmV-cj8zUgdHbS83=JcGt+DvJtfwybQ@mail.gmail.com>
 <CANPzfU-kQ-V=ZdLbhqFqqEdV=MhvAxhpR2K0sg=G09EGK1p-kg@mail.gmail.com>
 <3b477d9d-4ad8-d0c9-0d94-228ede031852@cs.oswego.edu>
 <CAKxGtTUnSdkkahPsfcuFA3PKZaGZY-MQMteD=uXywOZvHc9vVg@mail.gmail.com>
Message-ID: <9235d994-0dac-ecea-eb54-cc8339df925e@cs.oswego.edu>

On 10/26/19 2:42 PM, Francesco Nigro via Concurrency-interest wrote:
>> For example, I have later removed
> nearly every occurrence of Thread.yield() in any code I've written after
> finding something better or more general
> 
> OT: Just curious, where? :)

Notice for example that as of the rewrites last summer, there are none
in all of java.util.concurrent.locks.*

Much further off-topic, I was reminded of this when seeing "Ants Are
Practically Immune to Traffic Jams" courtesy of Hacker News a few days
ago (https://news.ycombinator.com/item?id=21352345)
https://www.sciencealert.com/ant-roads-are-practically-immune-to-traffic-jams-even-when-it-gets-crowded


Perhaps we can devise some pheromone-based synchronization primitives...

-Doug


From aaron.grunthal at infinite-source.de  Sat Oct 26 17:56:06 2019
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Sat, 26 Oct 2019 23:56:06 +0200
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
Message-ID: <b10648ba-b3f7-56fb-2aa7-c39906557d13@infinite-source.de>

On 26/10/2019 11:21, Andrew Haley via Concurrency-interest wrote:
> On 10/25/19 11:11 AM, Viktor Klang via Concurrency-interest wrote:
>>
>> Is there any jdk-builtin Java8+ method which tries to be clever
>> about low-nanos/micros parking?
>>
>> I'm currently considering LockSupport.parkNanos but want to avoid
>> having the Thread parked when parking + wake-up latency is more
>> likely to be much greater than the requested time.
>>
>> I.e. some combination of onSpinWait + some non-cache-polluting
>> computation + yielding + actual parking. I'd like to avoid having to
>> custom-roll it, hence the question for prior art ;)
> 
> As I understand it, the common wisdom is to wait for about half the
> round-trip time for a system call and then park. It doesn't sound
> terribly hard to write something to do that.
> 
> Please forgive me for digressing, but:
> 
> Arm has a mechanism to do this, WFE. When a core fails to obtain a
> lock it executes a WFE instruction which waits on the cache line
> containing the lock. When that cache line is written to by the core
> releasing the lock it awakens the waiting core.
> 
> I'd like to find some way to expose this in a high-level language but
> it's not at all easy to do.
> 
> I believe that Intel has MWAIT which is similar, but it's a privileged
> instruction so no use to us.
> 

Intel is introducing UMWAIT with Tremont

https://www.felixcloutier.com/x86/umwait

From leventov.ru at gmail.com  Wed Oct 30 03:23:06 2019
From: leventov.ru at gmail.com (Roman Leventov)
Date: Wed, 30 Oct 2019 10:23:06 +0300
Subject: [concurrency-interest] ManagedBlocker.block() documentation
Message-ID: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>

Currently, ManagedBlocker's documentation doesn't clarify whether the
execution framework could call block() more than once or not. The
specification for the return value of block() method:

> true if no additional blocking is necessary (i.e., if isReleasable would
return true)

Implies that isReleasable result should change if block() returns true.

It means that to code one-off blocking ops with ManagedBlocker, strictly
against the spec, one must make block() idempotent:

class MyBlocker implements ManagedBlocker {
  boolean done = false;
  boolean block() {
    if (done) return true;
    doMyOneOffBlockingOp();
    done = true;
    return true;
  }
  boolean isReleasable() { return done; }
}

Which is 1) boilerplate 2) non-trivial conclusion, implicit in the doc (so
few people would probably do this; e. g. there is an SO answer from a very
reputable folk that ditch this complexity and call it an "official
solution": https://stackoverflow.com/a/46073118/648955)

So, perhaps, it would make sense to extend the documentation
of ManagedBlocker with reservations about one-off blocking operations, e.
g. like this:

@return true if no additional blocking is necessary (i.e., if isReleasable
would return true, or if block() is a one-off operation)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191030/702ba732/attachment.html>

From viktor.klang at gmail.com  Wed Oct 30 03:58:11 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 30 Oct 2019 07:58:11 +0000
Subject: [concurrency-interest] ManagedBlocker.block() documentation
In-Reply-To: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
References: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
Message-ID: <CANPzfU-xOPchkVJ652C6gbWMpZOfLHjqftCNr51kDd=78iC5+Q@mail.gmail.com>

I typically do this:

class MyBlocker implements ManagedBlocker {
  boolean done;
  boolean block() {
    if (!isReleasable()) {
      doMyOneOffBlockingOp();
      done = true;
    }
    return isReleasable();
  }
  boolean isReleasable() { return done; }
}

In Scala I added a `blocking` construct which takes a thunk so the users
can write:

val result = blocking { doMyOneOffBlockingOp() }

On Wed, Oct 30, 2019 at 7:26 AM Roman Leventov via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Currently, ManagedBlocker's documentation doesn't clarify whether the
> execution framework could call block() more than once or not. The
> specification for the return value of block() method:
>
> > true if no additional blocking is necessary (i.e., if isReleasable would
> return true)
>
> Implies that isReleasable result should change if block() returns true.
>
> It means that to code one-off blocking ops with ManagedBlocker, strictly
> against the spec, one must make block() idempotent:
>
> class MyBlocker implements ManagedBlocker {
>   boolean done = false;
>   boolean block() {
>     if (done) return true;
>     doMyOneOffBlockingOp();
>     done = true;
>     return true;
>   }
>   boolean isReleasable() { return done; }
> }
>
> Which is 1) boilerplate 2) non-trivial conclusion, implicit in the doc (so
> few people would probably do this; e. g. there is an SO answer from a very
> reputable folk that ditch this complexity and call it an "official
> solution": https://stackoverflow.com/a/46073118/648955)
>
> So, perhaps, it would make sense to extend the documentation
> of ManagedBlocker with reservations about one-off blocking operations, e.
> g. like this:
>
> @return true if no additional blocking is necessary (i.e., if isReleasable
> would return true, or if block() is a one-off operation)
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191030/52214478/attachment.html>

From aph at redhat.com  Wed Oct 30 05:24:05 2019
From: aph at redhat.com (Andrew Haley)
Date: Wed, 30 Oct 2019 09:24:05 +0000
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <b10648ba-b3f7-56fb-2aa7-c39906557d13@infinite-source.de>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <b10648ba-b3f7-56fb-2aa7-c39906557d13@infinite-source.de>
Message-ID: <f9810019-3759-9566-91fd-9ec262f29174@redhat.com>

On 10/26/19 10:56 PM, Aaron Grunthal via Concurrency-interest wrote:
> On 26/10/2019 11:21, Andrew Haley via Concurrency-interest wrote:
>>
>> I'd like to find some way to expose [WFE] in a high-level language but
>> it's not at all easy to do.
>>
>> I believe that Intel has MWAIT which is similar, but it's a privileged
>> instruction so no use to us.
> 
> Intel is introducing UMWAIT with Tremont

Excellent! Competition is good. And perhaps once we have hardware we can find
a nice way to handle this.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From henri.tremblay at gmail.com  Wed Oct 30 05:46:58 2019
From: henri.tremblay at gmail.com (Henri Tremblay)
Date: Wed, 30 Oct 2019 05:46:58 -0400
Subject: [concurrency-interest] ManagedBlocker.block() documentation
In-Reply-To: <CANPzfU-xOPchkVJ652C6gbWMpZOfLHjqftCNr51kDd=78iC5+Q@mail.gmail.com>
References: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
 <CANPzfU-xOPchkVJ652C6gbWMpZOfLHjqftCNr51kDd=78iC5+Q@mail.gmail.com>
Message-ID: <CADZL2=tJFPTMNJAGBt9WDdTSMJhmkk6uB=6PVpzgrD_MqD9S3Q@mail.gmail.com>

Maybe is should actually be put in code. Something like

public interface ManagedBlocker {

    // Note: Runnable is not a good choice, the method show allow to
throw an InterruptedException
    static ManagedBlocker blocker(Runnable blockingOperation) {
        return new ManagedBlocker() { // Probably better to have a
real class, not an anonymous one
            private volatile boolean done; // Is volatile needed?

            public boolean block() throws InterruptedException {
                if (!isReleasable()) {
                    blockingOperation.run();
                    done = true;
                }
                return isReleasable();
            }

            public boolean isReleasable() {
                return done;
            }
        };
    }
    boolean block() throws InterruptedException;
    boolean isReleasable();
}


On Wed, 30 Oct 2019 at 04:00, Viktor Klang via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> I typically do this:
>
> class MyBlocker implements ManagedBlocker {
>   boolean done;
>   boolean block() {
>     if (!isReleasable()) {
>       doMyOneOffBlockingOp();
>       done = true;
>     }
>     return isReleasable();
>   }
>   boolean isReleasable() { return done; }
> }
>
> In Scala I added a `blocking` construct which takes a thunk so the users
> can write:
>
> val result = blocking { doMyOneOffBlockingOp() }
>
> On Wed, Oct 30, 2019 at 7:26 AM Roman Leventov via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Currently, ManagedBlocker's documentation doesn't clarify whether the
>> execution framework could call block() more than once or not. The
>> specification for the return value of block() method:
>>
>> > true if no additional blocking is necessary (i.e., if isReleasable
>> would return true)
>>
>> Implies that isReleasable result should change if block() returns true.
>>
>> It means that to code one-off blocking ops with ManagedBlocker, strictly
>> against the spec, one must make block() idempotent:
>>
>> class MyBlocker implements ManagedBlocker {
>>   boolean done = false;
>>   boolean block() {
>>     if (done) return true;
>>     doMyOneOffBlockingOp();
>>     done = true;
>>     return true;
>>   }
>>   boolean isReleasable() { return done; }
>> }
>>
>> Which is 1) boilerplate 2) non-trivial conclusion, implicit in the doc
>> (so few people would probably do this; e. g. there is an SO answer from a
>> very reputable folk that ditch this complexity and call it an "official
>> solution": https://stackoverflow.com/a/46073118/648955)
>>
>> So, perhaps, it would make sense to extend the documentation
>> of ManagedBlocker with reservations about one-off blocking operations, e.
>> g. like this:
>>
>> @return true if no additional blocking is necessary (i.e., if
>> isReleasable would return true, or if block() is a one-off operation)
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> --
> Cheers,
> √
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191030/db34909c/attachment-0001.html>

From aph at redhat.com  Wed Oct 30 06:04:21 2019
From: aph at redhat.com (Andrew Haley)
Date: Wed, 30 Oct 2019 10:04:21 +0000
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <d9356fcd-780a-3a32-abf3-8cdfcc646e3d@gmail.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <d9356fcd-780a-3a32-abf3-8cdfcc646e3d@gmail.com>
Message-ID: <add710ca-ef4d-94e7-fe86-57767a3493e2@redhat.com>

On 10/26/19 2:52 PM, Nathan and Ila Reynolds via Concurrency-interest wrote:

> The downside of pausing the threads execution of instructions is
> that the thread cannot respond to stop the world events.  This will
> increase the time it takes to stop the world.

Good point.

I don't think that's necessarily true, though. When a stop-the-world
event is needed a common technique is to read-protect a page. At the
hardware level this is [usually?] done by sending an inter-processor
interrupt broadcast to invalidate the TLBs of all processors. This
will kick every processor out of MWAIT/WFE.

On Arm any event which clears the "global monitor" (i.e. the state
machine used by load locked / store conditional) will kick the
processor out of WFE, and both TLB invalidate and exception return
clear the global monitor. I very much suspect Intel will do the same,
but that's not guaranteed.

Also, the longest MWAIT pause time I've ever measured on AArch64
systems is orders of magnitude less than our time to safepoint in
HotSpot. There's no guarantee of that either.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From dl at cs.oswego.edu  Wed Oct 30 09:49:22 2019
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 30 Oct 2019 09:49:22 -0400
Subject: [concurrency-interest] ManagedBlocker.block() documentation
In-Reply-To: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
References: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
Message-ID: <1661c7b5-9ab2-6220-c17d-68eb9c435029@cs.oswego.edu>

On 10/30/19 3:23 AM, Roman Leventov via Concurrency-interest wrote:
> Currently, ManagedBlocker's documentation doesn't clarify whether the
> execution framework could call block() more than once or not. The
> specification for the return value of block() method:

This seems implicit in the interface-level description, but we'll add a
clarification:

     * Method {@code block} is not invoked after a prior invocation of
     * {@code isReleasable} or {@code block} return {@code true}.
     *

-Doug


From tim at peierls.net  Wed Oct 30 09:58:45 2019
From: tim at peierls.net (Tim Peierls)
Date: Wed, 30 Oct 2019 09:58:45 -0400
Subject: [concurrency-interest] ManagedBlocker.block() documentation
In-Reply-To: <1661c7b5-9ab2-6220-c17d-68eb9c435029@cs.oswego.edu>
References: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
 <1661c7b5-9ab2-6220-c17d-68eb9c435029@cs.oswego.edu>
Message-ID: <CA+F8eeSON_86vUVeP9+df1pv0MCvgKzxkDT9v3mr4dwCpiWTfg@mail.gmail.com>

"return" -> "returns" ?

On Wed, Oct 30, 2019, 9:50 AM Doug Lea via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> On 10/30/19 3:23 AM, Roman Leventov via Concurrency-interest wrote:
> > Currently, ManagedBlocker's documentation doesn't clarify whether the
> > execution framework could call block() more than once or not. The
> > specification for the return value of block() method:
>
> This seems implicit in the interface-level description, but we'll add a
> clarification:
>
>      * Method {@code block} is not invoked after a prior invocation of
>      * {@code isReleasable} or {@code block} return {@code true}.
>      *
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191030/9e5c7b49/attachment.html>

From dl at cs.oswego.edu  Wed Oct 30 10:23:15 2019
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 30 Oct 2019 10:23:15 -0400
Subject: [concurrency-interest] ManagedBlocker.block() documentation
In-Reply-To: <CA+F8eeSON_86vUVeP9+df1pv0MCvgKzxkDT9v3mr4dwCpiWTfg@mail.gmail.com>
References: <CAAMLo=Y_RT-Z=534GuvatMEi7_ZFXzvq=AiV-vsPHGAnWcVGEA@mail.gmail.com>
 <1661c7b5-9ab2-6220-c17d-68eb9c435029@cs.oswego.edu>
 <CA+F8eeSON_86vUVeP9+df1pv0MCvgKzxkDT9v3mr4dwCpiWTfg@mail.gmail.com>
Message-ID: <2e300f77-af78-6a55-5f46-da7efd49455e@cs.oswego.edu>

On 10/30/19 9:58 AM, Tim Peierls via Concurrency-interest wrote:
> "return" -> "returns" ?

Right; thanks. Plus we can further simplify as:

     * Neither method is invoked after a prior invocation
     * of {@code isReleasable} or {@code block} returns {@code true}.

> 
> On Wed, Oct 30, 2019, 9:50 AM Doug Lea via Concurrency-interest
> <concurrency-interest at cs.oswego.edu
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> 
>     On 10/30/19 3:23 AM, Roman Leventov via Concurrency-interest wrote:
>     > Currently, ManagedBlocker's documentation doesn't clarify whether the
>     > execution framework could call block() more than once or not. The
>     > specification for the return value of block() method:
> 
>     This seems implicit in the interface-level description, but we'll add a
>     clarification:
> 
>          * Method {@code block} is not invoked after a prior invocation of
>          * {@code isReleasable} or {@code block} return {@code true}.
>          *
> 
>     -Doug
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 



From nathanila at gmail.com  Wed Oct 30 11:03:07 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Wed, 30 Oct 2019 09:03:07 -0600
Subject: [concurrency-interest] Low-latency pause in JDK
In-Reply-To: <add710ca-ef4d-94e7-fe86-57767a3493e2@redhat.com>
References: <CANPzfU9Msa3LkmPEUgr3QPULZkXqxFvcAgeYucA9L9-o=kM7xQ@mail.gmail.com>
 <ab814e78-0ecf-c576-ba61-1761730ece13@redhat.com>
 <d9356fcd-780a-3a32-abf3-8cdfcc646e3d@gmail.com>
 <add710ca-ef4d-94e7-fe86-57767a3493e2@redhat.com>
Message-ID: <857c56a8-6597-93ea-2845-3948d4da8049@gmail.com>

For blocking file I/O, the native method will check the stop-the-world 
flag after returning from the OS API call.  GC can then assume these 
threads are effectively stopped.

If the "pause" instruction does not wake up the thread immediately due 
to a stop-the-world event, we could add similar logic as what is in file 
I/O.  However, this will make pause performance suffer.

-Nathan

On 10/30/2019 4:04 AM, Andrew Haley wrote:
> On 10/26/19 2:52 PM, Nathan and Ila Reynolds via Concurrency-interest wrote:
>
>> The downside of pausing the threads execution of instructions is
>> that the thread cannot respond to stop the world events.  This will
>> increase the time it takes to stop the world.
> Good point.
>
> I don't think that's necessarily true, though. When a stop-the-world
> event is needed a common technique is to read-protect a page. At the
> hardware level this is [usually?] done by sending an inter-processor
> interrupt broadcast to invalidate the TLBs of all processors. This
> will kick every processor out of MWAIT/WFE.
>
> On Arm any event which clears the "global monitor" (i.e. the state
> machine used by load locked / store conditional) will kick the
> processor out of WFE, and both TLB invalidate and exception return
> clear the global monitor. I very much suspect Intel will do the same,
> but that's not guaranteed.
>
> Also, the longest MWAIT pause time I've ever measured on AArch64
> systems is orders of magnitude less than our time to safepoint in
> HotSpot. There's no guarantee of that either.
>

