From P.H.Welch at kent.ac.uk  Thu Sep  1 18:03:48 2005
From: P.H.Welch at kent.ac.uk (P.H.Welch)
Date: Thu Sep  1 18:04:02 2005
Subject: [concurrency-interest] Re: CSP, the pi-calculus and CPA-2005
Message-ID: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>


Thanks to Miles Sabin and Peter Soper for their replies.

Miles wrote:
> I think you'll find that many of the people on this list have an 
> interest in process algebras in one way or another. But I'm not quite 
> so surprised that they don't get discussed here ... the process algebra 
> approach to concurrency is very different from the threads, locks and 
> shared state approach that's hard-wired into Java and reflected in JSR 
> 166.

No, there's a misunderstanding here about what process algebra offers.

Regarding threads, locks and shared state there is plenty on offer -
like formal characterisations that allow formal reasoning and automated
model-checking.  In turn, this leads to precise design of the various
high-level locking mechanisms you want, correct implementation, correct
low-level code generation ... all the way down to correct and fast hardware
support ... all the way up to correct applications.

CSP/pi mechanisms are extremely primitive, have a rich mathematics and
can be formed into patterns that capture any synchronisation mechanism
you fancy - some will be more useful than others, of course!  For instance,
CSP "events" are the basis for channel communications (all sorts), barriers
(multiway synchronisation) and pretty much anything.

Shared state?  Easy!  Let x be a variable visible to many threads.  Then:

  Var (x, value) = load.x!value -> Var (x, value)
                   []
                   store.x?newValue -> Var (x, newValue)

is a process allowing its use by any number of threads (= other processes).
In the above, "Var" is a generic variable process, "x" is an integer specific
to a particular variable (e.g. it may be its address) and "value" is some
initial value for that variable.  The channel names "load" and "store" reflect
the point of view of processes using the variables.

Any process knowing "x" can now use the variable.  For instance, an assignment:

  x = y

is modelled as the CSP process:

  load.y?tmp -> store.x!tmp -> SKIP

which looks interestingly like a compilation to machine code, though to a machine
that is formally specified, :).

Of course, there is absolutely no protection against arbitrary interleaving of
loads and stores on the same variable by multiple processes - the point being
that such problems fall naturally into the scope of CSP.  Fixing them, through
higher level constraints ("healthiness conditions") can now begin.

Another example: variables with various "atomic" update operators ...

  AtomicVar (x, value) =
    load.x!value -> AtomicVar (x, value)
    []
    store.x?newValue -> AtomicVar (x, newValue)
    []
    getAndSet.x?newValue -> getAndSetReply.x!value -> AtomicVar (x, newValue)
    []
    compareAndSet.x?expect?update ->
      (compareAndSetReply.x!true -> AtomicVar (x, newValue) <| expect = value |>
       compareAndSetReply.x!false -> AtomicVar (x, value)
      )

etc.  Again, the point is that it's easy to express this stuff formally and
that we should do so.  Apart from anything else, it makes their implementation
and applications using them amenable to automated model checking ... which can
save months/years of debugging.  CSP has the commercial FDR ("Failures-
Divergences-Refinement") model checker of Formal Systems (Europe) Ltd:

  http://www.fsel.com/software.html

It's commercial - you have to pay (I have no relationship with Formal Systems!),
though it's cheap for university research.  But it's really useful.

A while back, we had to build a formal (CSP) model of the standard Java monitor
mechanisms (synchronized/wait/notify/notifyAll).  The trickiest part was making
as sure as possible that we had captured all the informally expressed semantics
from the original "specifications" - an impossible thing to prove, of course.
Anyway, the CSP modelling is quite short - slides 20-36 of:

  http://www.cs.kent.ac.uk/projects/ofa/jcsp/csp-java-model.ppt

The reason we had to do this was to correct the JCSP implementation of CSP
external choice, [] - the JCSP "Alternative", where a process waits passively
for any one of a number of events to occur and reacts accordingly.  We released
JCSP back in 1997 but a bug in its "Alternative" didn't show up till 1999, when
it caused a bit of a panic!  Took a whole week to "fix".  Concerned, we built
the CSP model of Java monitors and could then apply FDR to check that our Java
implementation of choice was equivalent to a direct CSP choice.  Applying the
check to our original implementation threw up the counter-example trace that
yielded the deadlock our users had encountered.  The check took about just
a few (< 5) seconds.  Really should have done that way back!  Anyone interested
can look at the rest of the slides above or read the paper:

  http://www.wotug.org/paperdb/send_file.php?id=44

which also contains the formal model of Java monitors.  This paper is from 2000.
Are there other formal specifications of this?  If not, why ... ?

BTW, JCSP is outlined in the final chapter of Doug Lea's book and is available
from:

  http://www.cs.kent.ac.uk/projects/ofa/jcsp/

Although the page doesn't say so, L-GPL open source is available - just ask!
Must update the website, :(.  The release hasn't been updated for a while ...
but it will be.  There's a distributed JCSP Network Edition from Quickstone:

  http://www.quickstone.com/xcsp/jcspnetworkedition/

that is also going public - when I can get around to integrating it cleanly
with the core release.

For those who have not seen JCSP, this is a library of standard Java packages
giving access to the CSP/occam concurrency model, with a dash of pi-calculus
mobility (mobile channels, barriers and terminated-but-rerunnable-processes)
thrown in.  It integrates seamlessly with standard Java thread-and-locks
concurrency - you choose whatever mix suits your application, though you must
take care to conform to the occam parallel healthiness conditions (that the
Java compiler does not police!).

Again, I'm trying to refute Miles' assertion that:

>                                             ... the process algebra 
> approach to concurrency is very different from the threads, locks and 
> shared state approach that's hard-wired into Java and reflected in JSR 
> 166.

:).

Miles added:
> FWIW, JSR 121, the Java Isolation API, has a CSP/pi-ish feel to it: 
> communication is based on message passing rather than shared state, 
> communication channels can be passed across communication channels for 
> scope extrusion. Pete Soper's collected various things you might find 
> interesting here,
> 
>   http://www.bitser.net/isolate-interest/

and Peter Soper wrote:
>                                          ... and it reminded me of the 
> potential of intersecting CSP and pi with JSR121 isolates. I finally 
> located a copy of slides that include Miles Sabin's pi-related ones (see 
> slide 31) that he presented to a UK university some time ago:
> 
>   http://www.bitser.net/isolate-interest/slides20040623.pdf

Thanks for this!  With Isolates, I guess you were forced into a CSP/pi-like
channel mechanism, :).

Just a few notes on the above slides ("The Java Isolation API").  Slide 23:

  o CSP style programming
     o Always use Isolates instead of Threads
     o Practically suitable only for course-grained designs

The last sub-point is an artifact of the first sub-point.  The first point
is the whole point of Isolates - to give security from one "process" being
messed around by another (either through interference or failure).  This is
absolutely fair and necessary in the context of Java.  But if you can police
the necessary care yourself, JCSP (for example) allows CSP style programming
in Java with as fine-grained design as Threads allow.

occam-pi guarantees against erroneous (unsynchronised) process interference
through language design and rules enforced by the compiler - so no run-time
checks are needed, :).  Security against failure of another process is only
partial.  For the kind of applications for which Isolates are designed,
we would have to do a lot more work.

In a wider context, CSP/pi style programming can be extremely fine-grained.
We are working on a project attempting low-level modelling of nanite assemblies
(artificial blood platelets and blood clotting).  This uses all the dynamic
mobility mechanisms built into occam-pi (an extension of the classical occam
language supporting mobile channels, barriers, processes and much more).
We are aiming at models involving (initially) tens of millions of dynamically
constructed, mobile, location-aware, and self-assembling processes - each
process being pretty tiny!

occam-pi carries overheads of only 8 bytes per process, with around 50 ns
process construction time (using Brinch Hansen's parallel memory allocation
algorithm) and 50 ns channel communication overhead (using all the transputer
tricks) on modern Pentiums 4s ... assuming cache hits, that is, :).
URLs for the curious:

  http://www.cs.kent.ac.uk/projects/ofa/kroc/      (occam-pi home and download)
  http://frmb.org/occ21-extensions.html            (summary of pi-extensions)
  http://rmox.net/prelude/                         (research OS)

Other points: I really liked the pi-calc slides (31 and following).  Yes,
there is a nice, happy and useful relationship.  The Link mechanism is
a little different to both CSP and pi - being bound to both Isolates (one
at each end).  In CSP/pi (and in JCSP/occam-pi), channels are independent
entities usable by any process that lays its hands on them.  When you create
them, you just create them - processes can use them if they can see them and
can take it in turns, which is a bit more flexible.  Language (algebra) rules
prevent confusion.

Many apologies for going on too long.  Summary:

  (1) Formal specification of concurrency synchronisation mechanisms (including
      memory models) should be undertaken for all sorts of very practical
      reasons.  We should have moved away from natural language specs long ago.
  
  (2) Formal specification in CSP is usually pretty easy, if you have a
      reasonably tight informal specification ... and finds you out if you
      haven't.  CSP also allows access to the FDR2 model checker.  [Note:
      we have draft CSP specifications for pi-calc mobile channels and,
      soon, for (occam-pi) mobile processes.]
   
  (3) Both the CSP and pi-calculus process algebras address message passing
      via channels between non-shared-memory processes ... but they do much
      much more than that.  :)

Peter Welch.
From hans.boehm at hp.com  Thu Sep  1 19:11:15 2005
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu Sep  1 19:13:45 2005
Subject: [concurrency-interest] Re: CSP, the pi-calculus and CPA-2005
Message-ID: <65953E8166311641A685BDF71D8658262B7164@cacexc12.americas.cpqcorp.net>

> A while back, we had to build a formal (CSP) model of the standard
Java monitor mechanisms
> (synchronized/wait/notify/notifyAll).  The trickiest part was making
as sure as possible
> that we had captured all the informally expressed semantics from the
original "specifications"
> - an impossible thing to prove, of course. Anyway, the CSP modelling
is quite short - slides 20-36 of:

>  http://www.cs.kent.ac.uk/projects/ofa/jcsp/csp-java-model.ppt

As far as I can tell, your CSP model of Java monitors ignores the memory
model
issues (JSR 133), as does most theoretical work that I've seen.  That
doesn't make it
useless by any means, but you have to be careful to remember what you're
modeling,
and what you're not.

If I understand correctly, a number of very common Java concurrency bugs
seem
to just quietly disappear in the CSP translation, e.g. double-checked
locking.
(This doesn't argue that we should all be writing the CSP version.  The
Java
memory model is there for a reason, namely to get reasonable
performance.)

Hans

From miles at milessabin.com  Fri Sep  2 04:16:59 2005
From: miles at milessabin.com (Miles Sabin)
Date: Fri Sep  2 04:17:16 2005
Subject: [concurrency-interest] Re: CSP, the pi-calculus and CPA-2005
In-Reply-To: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>
References: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>
Message-ID: <200509020917.00248.miles@milessabin.com>

P.H.Welch wrote,
> Thanks to Miles Sabin and Peter Soper for their replies.
>
> Miles wrote:
> > I think you'll find that many of the people on this list have an
> > interest in process algebras in one way or another. But I'm not
> > quite so surprised that they don't get discussed here ... the
> > process algebra approach to concurrency is very different from the
> > threads, locks and shared state approach that's hard-wired into
> > Java and reflected in JSR 166.
>
> No, there's a misunderstanding here about what process algebra
> offers.
>
> Regarding threads, locks and shared state there is plenty on offer -
> like formal characterisations that allow formal reasoning and
> automated model-checking.  In turn, this leads to precise design of
> the various high-level locking mechanisms you want, correct
> implementation, correct low-level code generation ... all the way
> down to correct and fast hardware support ... all the way up to
> correct applications.

No argument here ... if you look at the Java Memory Model documents 
produced by JSR 133 you'll find exactly that. But this only takes us 
from the machine level to a level somewhat below that addressed by JSR 
166.

> CSP/pi mechanisms are extremely primitive, have a rich mathematics
> and can be formed into patterns that capture any synchronisation
> mechanism you fancy - some will be more useful than others, of
> course!  For instance, CSP "events" are the basis for channel
> communications (all sorts), barriers (multiway synchronisation) and
> pretty much anything.
<snip/>
> Again, the point is that it's easy to express this stuff formally and
> that we should do so.  Apart from anything else, it makes their
> implementation and applications using them amenable to automated model
> checking ... which can save months/years of debugging.

Understood. But this isn't much practical help to the people who are the 
intended consumers of java.util.concurrent. From there up to the 
application level things get much more complicated, hence much harder 
to specify formally, particularly when you lack first-class language 
support for your formalism or programming model of choice.

One of the most common problems here is that typical applications have 
to deal not just with the intrinsic sources of concurrency supported by 
a particular programming language, but also with concurrency due to 
network interaction. This isn't particularly well integrated in Java 
(you can't, for example, _directly_ wait on both a monitor and I/O), or 
in any other mainstream programming language that I'm aware of (Erlang 
comes close, but I'm not sure it could really be characterized as 
mainstream).

Systematic handling of failure and cancellation are probably the next 
two most common problems, and whilst they're non-negotiable for 
production quality systems, they're rarely handled smoothly by 
specification languages.

Speaking anecdotally, I've found the concurrent hierarchical state 
machines model extremely helpful when designing network applications. 
But the translation from a formal specification to running Java code is 
an extremely delicate process, one which is most certainly not 
correctness-proof-preserving. 

In summary: I actually agree with almost all you say, I just don't think 
that Java (but not just Java) provides an environment which supports 
the direct application of these techniques other than as informal 
guidelines.

> Miles added:
> > FWIW, JSR 121, the Java Isolation API, has a CSP/pi-ish feel to it:
> > communication is based on message passing rather than shared state,
> > communication channels can be passed across communication channels
> > for scope extrusion. Pete Soper's collected various things you
> > might find interesting here,

> Thanks for this!  With Isolates, I guess you were forced into a
> CSP/pi-like channel mechanism, :).
<snip/>

Indeed.

> Yes, there is a nice, happy and useful relationship.  The Link
> mechanism is a little different to both CSP and pi - being bound to
> both Isolates (one at each end).  In CSP/pi (and in JCSP/occam-pi),
> channels are independent entities usable by any process that lays its
> hands on them.  When you create them, you just create them -
> processes can use them if they can see them and can take it in turns,
> which is a bit more flexible.  Language (algebra) rules prevent
> confusion.

Yes, we were aware of this at the time. There are a variety of 
implementation reasons which make unbound Links problematic. I hope a 
revision of JSR 121 will support them one day, but for now I'd just 
like to see a release of what we've done so far.

If you have any comments on the isolation API we'd be delighted to hear 
them ... the best place would probably be the isolate-interest list ... 
subscription details here,

  http://www.bitser.net/isolate-interest/

Cheers,


Miles
From normelton at gmail.com  Fri Sep  2 11:36:50 2005
From: normelton at gmail.com (Norman Elton)
Date: Fri Sep  2 11:36:58 2005
Subject: [concurrency-interest] Removing jobs from ThreadPoolExecutor
Message-ID: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>

I'm using a ThreadPoolExecutor to handle incoming jobs. Jobs are  
either "low priority" or "high priority". I have a separate thread  
that monitors the queue to ensure that it does not get out of control.

I'd like for the monitoring thread to remove all low priority jobs if  
the queue gets above a certain size. Currently, I plan to loop  
through the queue, retrieved from ThreadPoolExecutor.getQueue(), and  
call ThreadPoolExecutor.remove() on all low priority jobs.

Is this the best way to accomplish this? Will there be any  
concurrency issues here? It appears that if I remove a job that has  
already been executed, the method will simply return false.

Thanks for any ideas,

Norman
From forax at univ-mlv.fr  Fri Sep  2 12:28:28 2005
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri Sep  2 12:28:31 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit from Sorted{Map, Set}
In-Reply-To: <200509020917.00248.miles@milessabin.com>
References: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>
	<200509020917.00248.miles@milessabin.com>
Message-ID: <43187DAC.3010201@univ-mlv.fr>

The problem :
   I have a user defined implementation of a Set
   (FastTraversalSet) and this implementation
   already provides some traversal methods that
   i could use to retrofit the class
   in order to implement NavigableSet interface.
   But i think i can't do this without risking to break
   the semantic of my program.

   Because NavigableSet inherits from SortedSet
   (an interface that already exists in the JDK),
   if i retrofit my class some code in my program
   could have a different behavior :

   void doSomething(Set<String> set) {
     if (set instanceof SortedSet)
       // before retrofitting:
       //   it's a tree set, or a wrapper on a tree set
       //   like unmodifiableSet(...)
       // after retrofitting:
       //   oups FastTraversalSet match
     else
       // it's my implementation
   }

   The fact that NavigableSet inherits from SortedSet
   prevents me to retrofit FastTraversalSet.

   Please, Navigable{Set,Map} must not inherits
   from Sorted{Set,Map}.

R?mi Forax


From brian at quiotix.com  Fri Sep  2 12:46:32 2005
From: brian at quiotix.com (Brian Goetz)
Date: Fri Sep  2 12:46:43 2005
Subject: [concurrency-interest] Removing jobs from ThreadPoolExecutor
In-Reply-To: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>
References: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>
Message-ID: <431881E8.6010101@quiotix.com>

Let me see if I understand what you're doing:

- You have one executor
- It shares both high and low priority tasks
- You want to reap low-priority tasks if the queue hits some bound so 
that you can make room for more high priority tasks

Are you using a PriorityBlockingQueue for the tasks?  Is it bounded?

You might be able to do this with a custom BlockingQueue that derives 
most of its functionality from PriorityBlockingQueue, but whose offer() 
method kicks out old elements when the queue seems "too full".  (To do 
this, you'd have to iterate the queue; the PriorityBlockingDeque class 
from JSR166x would make this easier, because you could just delete the 
last element(s) to make some room.)  Then you wouldn't need a separate 
thread, because you'd intercept the offer() and only shed tasks when a 
new high priority task shows up and there are already too many tasks on 
the queue.

Norman Elton wrote:
> I'm using a ThreadPoolExecutor to handle incoming jobs. Jobs are  either 
> "low priority" or "high priority". I have a separate thread  that 
> monitors the queue to ensure that it does not get out of control.
> 
> I'd like for the monitoring thread to remove all low priority jobs if  
> the queue gets above a certain size. Currently, I plan to loop  through 
> the queue, retrieved from ThreadPoolExecutor.getQueue(), and  call 
> ThreadPoolExecutor.remove() on all low priority jobs.
> 
> Is this the best way to accomplish this? Will there be any  concurrency 
> issues here? It appears that if I remove a job that has  already been 
> executed, the method will simply return false.
> 
> Thanks for any ideas,
> 
> Norman
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From dl at cs.oswego.edu  Fri Sep  2 13:03:46 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri Sep  2 13:03:46 2005
Subject: [concurrency-interest] Navigable{Map, Set} must not inherit from
	Sorted{Map, Set}
In-Reply-To: <43187DAC.3010201@univ-mlv.fr>
References: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>	<200509020917.00248.miles@milessabin.com>
	<43187DAC.3010201@univ-mlv.fr>
Message-ID: <431885F2.5060606@cs.oswego.edu>

R?mi Forax wrote:
> 
>    void doSomething(Set<String> set) {
>      if (set instanceof SortedSet)
>        // before retrofitting:
>        //   it's a tree set, or a wrapper on a tree set
>        //   like unmodifiableSet(...)
>        // after retrofitting:
>        //   oups FastTraversalSet match
>      else
>        // it's my implementation
>    }
> 
>    The fact that NavigableSet inherits from SortedSet
>    prevents me to retrofit FastTraversalSet.
> 
>    Please, Navigable{Set,Map} must not inherits
>    from Sorted{Set,Map}.
> 

According to this, it seems that you do not want any interface to
ever inherit from Sorted{Set,Map}. So even if we changed Navigable
to not inherit Sorted, someone else will someday cause you the
same problem. Whenever you use instanceof in this way, you are
committing yourself to change your code in the future. (You never know
exactly when or why though -- if you did, you probably wouldn't have
used instanceof.)

Sorry to make your life more complicated, but we won't be changing this.

-Doug








From dawidk at mathcs.emory.edu  Fri Sep  2 13:12:23 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Sep  2 13:12:38 2005
Subject: [concurrency-interest] Removing jobs from ThreadPoolExecutor
In-Reply-To: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>
References: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>
Message-ID: <431887F7.8000105@mathcs.emory.edu>

Norman Elton wrote:

> I'm using a ThreadPoolExecutor to handle incoming jobs. Jobs are  
> either "low priority" or "high priority". I have a separate thread  
> that monitors the queue to ensure that it does not get out of control.
>
> I'd like for the monitoring thread to remove all low priority jobs if  
> the queue gets above a certain size. Currently, I plan to loop  
> through the queue, retrieved from ThreadPoolExecutor.getQueue(), and  
> call ThreadPoolExecutor.remove() on all low priority jobs.
>
> Is this the best way to accomplish this? Will there be any  
> concurrency issues here? It appears that if I remove a job that has  
> already been executed, the method will simply return false.
>
Agreeing with Brian that using custom queue implementation is probably 
the best solution, I am thinking, if you only have two priorities, maybe 
you can get away with implementation of your queue that internally holds 
two queues for high and low priority tasks? You then need to implement 
the await/signal logic; internal queues may in fact be non-blocking. The 
advantage of this is that you can quickly remove items from low-priority 
queue on put, without iterating.

I don't quite see the solution based on PriorityQueue without using 
iterators: Assuming that high-priority tasks should be run before 
low-priority tasks, they must go at the top of the heap, and stuff can 
only be removed from priority queue in log time and in proper order from 
the top of the heap, not from the bottom.

If you need more than two priority levels, yet another possibility is to 
use sorted list for the queue implementation, which makes it possible to 
remove stuff from the end. I guess the only way to implement sorted list 
in Java is to use SortedMap, with keys being (priority, uniqueID) pairs, 
sorted in that order. (By priority first, FIFO next).

Regards,
Dawid

From normelton at gmail.com  Fri Sep  2 13:23:21 2005
From: normelton at gmail.com (Norman Elton)
Date: Fri Sep  2 13:23:30 2005
Subject: [concurrency-interest] Removing jobs from ThreadPoolExecutor
In-Reply-To: <431887F7.8000105@mathcs.emory.edu>
References: <C7E249D2-7BBA-46A8-8AE9-488EE997A7F9@gmail.com>
	<431887F7.8000105@mathcs.emory.edu>
Message-ID: <8941EF8D-E13B-4AFE-8156-1A6B8119DCDC@gmail.com>

Thanks Brian & David for the responses...

 >> - You have one executor
 >> - It shares both high and low priority tasks
 >> - You want to reap low-priority tasks if the queue hits some  
bound so that you can make room for more high priority tasks

Correct.

I am using a regular BlockingQueue (the default with a  
ThreadPoolExecutor). Although tasks are of two priorities, high  
priority jobs are not executed before low priority jobs. The  
"priority" (and perhaps I could have chosen a better term) only takes  
affect when the queue becomes too long.

I'll work on some of your suggestions and see how things go. Thanks  
again,

Norman


On Sep 2, 2005, at 1:12 PM, Dawid Kurzyniec wrote:

> Norman Elton wrote:
>
>
>> I'm using a ThreadPoolExecutor to handle incoming jobs. Jobs are   
>> either "low priority" or "high priority". I have a separate  
>> thread  that monitors the queue to ensure that it does not get out  
>> of control.
>>
>> I'd like for the monitoring thread to remove all low priority jobs  
>> if  the queue gets above a certain size. Currently, I plan to  
>> loop  through the queue, retrieved from ThreadPoolExecutor.getQueue 
>> (), and  call ThreadPoolExecutor.remove() on all low priority jobs.
>>
>> Is this the best way to accomplish this? Will there be any   
>> concurrency issues here? It appears that if I remove a job that  
>> has  already been executed, the method will simply return false.
>>
>>
> Agreeing with Brian that using custom queue implementation is  
> probably the best solution, I am thinking, if you only have two  
> priorities, maybe you can get away with implementation of your  
> queue that internally holds two queues for high and low priority  
> tasks? You then need to implement the await/signal logic; internal  
> queues may in fact be non-blocking. The advantage of this is that  
> you can quickly remove items from low-priority queue on put,  
> without iterating.
>
> I don't quite see the solution based on PriorityQueue without using  
> iterators: Assuming that high-priority tasks should be run before  
> low-priority tasks, they must go at the top of the heap, and stuff  
> can only be removed from priority queue in log time and in proper  
> order from the top of the heap, not from the bottom.
>
> If you need more than two priority levels, yet another possibility  
> is to use sorted list for the queue implementation, which makes it  
> possible to remove stuff from the end. I guess the only way to  
> implement sorted list in Java is to use SortedMap, with keys being  
> (priority, uniqueID) pairs, sorted in that order. (By priority  
> first, FIFO next).
>
> Regards,
> Dawid
>
>

From forax at univ-mlv.fr  Fri Sep  2 14:11:25 2005
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri Sep  2 14:11:28 2005
Subject: [concurrency-interest] Navigable{Map, Set} must not inherit from
	Sorted{Map, Set}
In-Reply-To: <431885F2.5060606@cs.oswego.edu>
References: <E1EAx9w-0003CU-4D@myrtle.ukc.ac.uk>	<200509020917.00248.miles@milessabin.com>
	<43187DAC.3010201@univ-mlv.fr> <431885F2.5060606@cs.oswego.edu>
Message-ID: <431895CD.4010007@univ-mlv.fr>

Doug Lea a ?crit :
 > R?mi Forax wrote:
 >
 >>
 >>    void doSomething(Set<String> set) {
 >>      if (set instanceof SortedSet)
 >>        // before retrofitting:
 >>        //   it's a tree set, or a wrapper on a tree set
 >>        //   like unmodifiableSet(...)
 >>        // after retrofitting:
 >>        //   oups FastTraversalSet match
 >>      else
 >>        // it's my implementation
 >>    }
 >>
 >>    The fact that NavigableSet inherits from SortedSet
 >>    prevents me to retrofit FastTraversalSet.
 >>
 >>    Please, Navigable{Set,Map} must not inherits
 >>    from Sorted{Set,Map}.
 >>
 >
 > According to this, it seems that you do not want any interface to
 > ever inherit from Sorted{Set,Map}.

No, anyone can write an interface that inherit from Sorted{Set,Map}
because i'm free to not use its library.
That not the case of the JDK.
If i want the next Java, i get the new JDK API bundle with it.

 > So even if we changed Navigable
 > to not inherit Sorted, someone else will someday cause you the
 > same problem.

I can choose to not use the library that do this.
I can't do the same with the JDK.

 > Whenever you use instanceof in this way, you are
 > committing yourself to change your code in the future. (You never know
 > exactly when or why though -- if you did, you probably wouldn't have
 > used instanceof.)

Yes your right its a "bad design", but i think i have no
way in Java to avoid such code.
Take by example java.util.Collections and count how many instanceof
you can find. I'm not the only one to use such design :)

 >
 > Sorry to make your life more complicated, but we won't be changing this.

i think it could make not only my life more complicated.

 >
 > -Doug
 >
 >

R?mi


From jean.morissette666 at videotron.ca  Fri Sep  2 16:19:11 2005
From: jean.morissette666 at videotron.ca (Jean Morissette)
Date: Fri Sep  2 16:46:13 2005
Subject: [concurrency-interest] Multi-Reader One-Writer Queue
Message-ID: <4318B3BF.1050605@videotron.ca>

Hi,
    I'm developing an application where a single writer thread must send 
messages to many reader thread.  The particularity is that a message 
must be read by all readers before being discarded.  Also, low memory 
consomption is an important requirement.  To achieve that, I'm thinking 
to create an array-based custom queue where each reader is in fact a 
queue proxy that keep its "dequeue pointer"  in the array.  Only the 
last reader of an element will remove it from the array.  However, I'm 
wondering how to determine efficiently who is the last reader during 
dequeue operation?

Is this the best way to accomplish this?  Any advices would be appreciated.
Thanks,
-Jean


From brian at quiotix.com  Fri Sep  2 18:04:03 2005
From: brian at quiotix.com (Brian Goetz)
Date: Fri Sep  2 18:04:02 2005
Subject: [concurrency-interest] Multi-Reader One-Writer Queue
In-Reply-To: <4318B3BF.1050605@videotron.ca>
References: <4318B3BF.1050605@videotron.ca>
Message-ID: <4318CC53.8000201@quiotix.com>

 > However, I'm
 > wondering how to determine efficiently who is the last reader during
 > dequeue operation?

I think that's a task for the garbage collector.

> To achieve that, I'm thinking to create an array-based custom queue
 > where each reader is in fact a queue proxy that keep its "dequeue
 > pointer" in the array.

This will only work if you can ensure that the producer cannot outrun 
the slowest consumer.  If you can't, then you have to make the 
multi-insert operation block.

To do this, you could have a semaphore which represents the put credit, 
and no master queue, but N array-based queues:

   Semaphore sem = new Semaphore(bound);

The put operation operates on all queues:

   void put(T t) throws IE {
     sem.acquire();
     Node n = new Node(t, nQueues);
     for (Queue q : queues)
       q.put(n);
   }

The get() operation operates on one queue, and the last of the get() 
operations for a given node releases the semaphore permit:

   T get() {
     Node n = q.take();
     int count = n.count.decrementAndGet();
     if (count == 0)
       sem.release();
   }

   class Node<T> {
     final T item;
     final AtomicInteger count;

     public Node(T item, int count) {
       this.item = item;
       this.count = new AtomicInteger(count);
     }
   }

From gregg at cytetech.com  Sat Sep  3 00:37:27 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Sat Sep  3 00:37:36 2005
Subject: [concurrency-interest] Multi-Reader One-Writer Queue
In-Reply-To: <4318CC53.8000201@quiotix.com>
References: <4318B3BF.1050605@videotron.ca> <4318CC53.8000201@quiotix.com>
Message-ID: <43192887.7070004@cytetech.com>



Brian Goetz wrote:
>  > However, I'm
>  > wondering how to determine efficiently who is the last reader during
>  > dequeue operation?
> 
> I think that's a task for the garbage collector.
> 
>> To achieve that, I'm thinking to create an array-based custom queue
> 
>  > where each reader is in fact a queue proxy that keep its "dequeue
>  > pointer" in the array.
> 
> This will only work if you can ensure that the producer cannot outrun 
> the slowest consumer.  If you can't, then you have to make the 
> multi-insert operation block.
> 
> To do this, you could have a semaphore which represents the put credit, 
> and no master queue, but N array-based queues:

The other choice is to make the receivers be listeners in a list that the producer cycles through.  If the listeners 
need to manage some queuing, they could use queues in their listener objects.  But, in the end, you have to be very 
careful about unbounded production opportunities.  It can seem attractive to let them run asynchronously, but this can 
be a big trap to fall into.

Asynchronous processing is good for unrelated activities, or when you are using multi-threading to hide latency.  But, 
you have to be careful to still keep data producers and consumers in sync either by using bounded queues, or counting 
semaphores or something that will keep the outstanding operations at some reasonable level.

Gregg Wonderly
From holger at wizards.de  Sat Sep  3 11:09:20 2005
From: holger at wizards.de (Holger Hoffstaette)
Date: Sat Sep  3 11:12:40 2005
Subject: [concurrency-interest] Waitable* classes for backport or 1.5?
Message-ID: <pan.2005.09.03.15.09.19.567250@wizards.de>


Hi,

has anybody forward-ported the Waitable{Boolean/Byte..} classes from the
original edu.oswego package to either backport or 1.5 proper? I could need
them for forward-backporting a project :) since are quite handy. Porting
them as subclasses of AtomicBoolean etc. should not be too difficult but I
wanted to ping here first - no need to duplicate efforts..

Thanks,
Holger


From dawidk at mathcs.emory.edu  Sat Sep  3 11:20:39 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sat Sep  3 11:21:01 2005
Subject: [concurrency-interest] Waitable* classes for backport or 1.5?
In-Reply-To: <pan.2005.09.03.15.09.19.567250@wizards.de>
References: <pan.2005.09.03.15.09.19.567250@wizards.de>
Message-ID: <4319BF47.9090305@mathcs.emory.edu>

Holger Hoffstaette wrote:

>Hi,
>
>has anybody forward-ported the Waitable{Boolean/Byte..} classes from the
>original edu.oswego package to either backport or 1.5 proper? I could need
>them for forward-backporting a project :) since are quite handy. Porting
>them as subclasses of AtomicBoolean etc. should not be too difficult but I
>wanted to ping here first - no need to duplicate efforts..
>
>
>  
>
Not me :)
Regards,
Dawid Kurzyniec

From dholmes at dltech.com.au  Sun Sep  4 09:09:36 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Sun Sep  4 09:09:48 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit fromSorted{Map, Set}
In-Reply-To: <431885F2.5060606@cs.oswego.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEIGGCAA.dholmes@dltech.com.au>

> R?mi Forax wrote:
> >
> >    void doSomething(Set<String> set) {
> >      if (set instanceof SortedSet)
> >        // before retrofitting:
> >        //   it's a tree set, or a wrapper on a tree set
> >        //   like unmodifiableSet(...)
> >        // after retrofitting:
> >        //   oups FastTraversalSet match
> >      else
> >        // it's my implementation
> >    }

Is there some reason you can't invert the test and check for your
implementation first? That way you don't care what interfaces it implements.

David Holmes

From forax at univ-mlv.fr  Mon Sep  5 05:32:03 2005
From: forax at univ-mlv.fr (Remi Forax)
Date: Mon Sep  5 05:32:24 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit fromSorted{Map, Set}
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEIGGCAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCAEIGGCAA.dholmes@dltech.com.au>
Message-ID: <431C1093.8050301@univ-mlv.fr>

David Holmes wrote:

>>R?mi Forax wrote:
>>    
>>
>>>   void doSomething(Set<String> set) {
>>>     if (set instanceof SortedSet)
>>>       // before retrofitting:
>>>       //   it's a tree set, or a wrapper on a tree set
>>>       //   like unmodifiableSet(...)
>>>       // after retrofitting:
>>>       //   oups FastTraversalSet match
>>>     else
>>>       // it's my implementation
>>>   }
>>>      
>>>
>
>Is there some reason you can't invert the test and check for your
>implementation first? That way you don't care what interfaces it implements.
>
>David Holmes
>  
>
I can invert the test but this code was written two years ago and not by me.
It works so i prefer not to touch it if it's possible.
I  have to maintain the program and extends some specific parts.
It seems not a good idea to have to rewrite a code because i want to 
retrofit a class.

The fact that NavigableSet inherits from SortedSet prevents me to 
retrofit my class
without changing some other parts of the program.

R?mi Forax

From tim at peierls.net  Mon Sep  5 10:47:14 2005
From: tim at peierls.net (Tim Peierls)
Date: Mon Sep  5 10:47:31 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit fromSorted{Map, Set}
In-Reply-To: <431C1093.8050301@univ-mlv.fr>
References: <NFBBKALFDCPFIDBNKAPCAEIGGCAA.dholmes@dltech.com.au>
	<431C1093.8050301@univ-mlv.fr>
Message-ID: <431C5A72.5050009@peierls.net>

Remi Forax wrote:
> I can invert the test but this code was written two years ago and not by me.
> It works so i prefer not to touch it if it's possible.
> I have to maintain the program and extends some specific parts.
> It seems not a good idea to have to rewrite a code because i want to 
> retrofit a class.
> 
> The fact that NavigableSet inherits from SortedSet prevents me to 
> retrofit my class without changing some other parts of the program.

I'm encountering similar difficulties. I wrote some classes back before Collections came out that 
have been working perfectly for years. I'd like to retrofit them to implement Collection 
interfaces, but the interface hierarchy used by Collections is incompatible with algorithms I am 
using. I could go back and modify my code, but it depends on some intricate instanceof tests that 
I'm afraid are too delicate to mess with (and I'm not sure at this point exactly how they work), 
so instead I'd like to ask if it would be possible to change the Collections interface hierarchy 
so that Map implements Set.

I've done some initial work to verify that this could be accomplished in a way that would not 
cause any problems for existing code. If anyone is interested I can describe the technique.

--tim


From p.veentjer at anchormen.nl  Mon Sep  5 14:35:41 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Mon Sep  5 14:36:06 2005
Subject: [concurrency-interest] overview new features -> tim.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA26@gerard.anchormen.nl>

Sorry for this late reply tim. 

>>  ... But there are some
>> parts where the concurrency library could be improved. One of those things
>> would be better control on timeout behaviour of the executorservices. That
>> is why I have created the BlockingExecutor that gives the control.
>> 
>> public interface BlockingExecutor {
>>  void put(Runnable command) throws InterruptedException;
>>  boolean offer(Runnable command, long timeout, TimeUnit unit) throws InterruptedException;
>> }
>Do you have a small example that illustrates the use of BlockingExecutor to do 
>something that is difficult or impossible to achieve conveniently with the 
>standard task execution framework?

I`m currently working on a channels project, and I need the control on timeout behaviour of 

the tasks in the BlockingExecutor. I don`t have the control to do a put/offer and send

timeout parameters with the current Executors (there is only a single execute method

with no arguments) and that is what I need.


>> And why where the Takeable/Puttable/Channel interfaces/implementations
>> removed? I had to create my own libary based on those interfaces and I
>> think the original code should have made it into java 5. JMS is too
>> heavy... and the removed code was perfect.
>
>The method names haven't changed, only the class name.
>
> Channel -> BlockingQueue
>  Takeable -> the take and poll methods of BlockingQueue
>  Puttable -> the put and offer methods of BlockingQueue
>
>There are no separate interfaces to describe the puttable side of a 
>BlockingQueue from its takeable side, but you can provide simple wrappers to 
>achieve the same effect.

I don`t think that is a very good solution because the exchange of messages is combined 

with storage of messages. 

You can see my channels project here:

http://members.home.nl/peter-veentjer01/index.htm

I want to have total control and don`t want to drag along a lot of garbage.

And sorry for this messy reply. My Email client (outlook) doesn`t make a good 

reply and is terrible for layout.

 


From normelton at gmail.com  Mon Sep  5 15:10:59 2005
From: normelton at gmail.com (Norman Elton)
Date: Mon Sep  5 15:11:14 2005
Subject: [concurrency-interest] NullPointerException after removing all
	tasks from a ThreadPoolExecutor
Message-ID: <D83B1407-2538-460C-B4BD-B8ACA69ABD89@gmail.com>

I've setup a simple test scenario that is producing a  
NullPointerException. My code is...

----------------
ThreadPoolExecutor tpe = new ThreadPoolExecutor(1, 1, 5,  
TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new  
JobThreadFactory());

tThread t1 = new tThread(1);
tThread t2 = new tThread(2);
tThread t3 = new tThread(3);

tpe.execute(t1);
tpe.execute(t2);

tpe.remove(t2);

tpe.execute(t3);
----------------

The "tThread" class merely waits five seconds and produces a simple  
message to System.out. No magic there. The code runs the first thread  
(t1) as expected, then starts spewing out exceptions of the form...

Exception in thread "EX-1737" java.lang.NullPointerException
         at java.util.concurrent.LinkedBlockingQueue.extract(Unknown  
Source)
         at java.util.concurrent.LinkedBlockingQueue.take(Unknown  
Source)
         at java.util.concurrent.ThreadPoolExecutor.getTask(Unknown  
Source)
         at java.util.concurrent.ThreadPoolExecutor$Worker.run 
(Unknown Source)
         at java.lang.Thread.run(Unknown Source)

It does not appear to like it when I remove all the tasks from the  
queue. If I leave one task on the queue, it remains happy.

Any ideas? I looked through the JSR166 bugs, and did not find  
anything that looked promising.

Thanks for your help,

Norman

From wnelto at wm.edu  Mon Sep  5 15:09:51 2005
From: wnelto at wm.edu (Norman Elton)
Date: Mon Sep  5 15:17:44 2005
Subject: [concurrency-interest] NullPointerException after removing all
	tasks from ThreadPoolExecutor
Message-ID: <D5045419-066B-4306-BAB7-F4C620A370BF@wm.edu>

I've setup a simple test scenario that is producing a  
NullPointerException. My code is...

----------------
ThreadPoolExecutor tpe = new ThreadPoolExecutor(1, 1, 5,  
TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new  
JobThreadFactory());

tThread t1 = new tThread(1);
tThread t2 = new tThread(2);
tThread t3 = new tThread(3);

tpe.execute(t1);
tpe.execute(t2);

tpe.remove(t2);

tpe.execute(t3);
----------------

The "tThread" class merely waits five seconds and produces a simple  
message to System.out. No magic there. The code runs the first thread  
(t1) as expected, then starts spewing out exceptions of the form...

Exception in thread "EX-1737" java.lang.NullPointerException
         at java.util.concurrent.LinkedBlockingQueue.extract(Unknown  
Source)
         at java.util.concurrent.LinkedBlockingQueue.take(Unknown  
Source)
         at java.util.concurrent.ThreadPoolExecutor.getTask(Unknown  
Source)
         at java.util.concurrent.ThreadPoolExecutor$Worker.run 
(Unknown Source)
         at java.lang.Thread.run(Unknown Source)

It does not appear to like it when I remove all the tasks from the  
queue. If I leave one task on the queue, it remains happy.

Any ideas? I looked through the JSR166 bugs, and did not find  
anything that looked promising.

Thanks for your help,

Norman
From dl at cs.oswego.edu  Mon Sep  5 15:27:55 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Sep  5 15:28:02 2005
Subject: [concurrency-interest] NullPointerException after removing all
	tasks from ThreadPoolExecutor
In-Reply-To: <D5045419-066B-4306-BAB7-F4C620A370BF@wm.edu>
References: <D5045419-066B-4306-BAB7-F4C620A370BF@wm.edu>
Message-ID: <431C9C3B.7060201@cs.oswego.edu>


> Any ideas? I looked through the JSR166 bugs, and did not find  
> anything that looked promising.
> 

I'm pretty sure this is:
   http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6215625

Sorry that it takes so long to get these into Sun Tiger update releases.

In the mean time, you can grab source from our CVS, compile, and
place in your -Xbootclasspath.

-Doug

From p.veentjer at anchormen.nl  Mon Sep  5 15:29:49 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Mon Sep  5 15:30:13 2005
Subject: [concurrency-interest] NullPointerException after removing
	alltasks from a ThreadPoolExecutor
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA29@gerard.anchormen.nl>

You shouldn't use Threads but use runnable`s. The ThreadPoolExecutor has is own pool of thread (hence the name).
 
I don't know the cause of the NullPointerException.
 

From normelton at gmail.com  Mon Sep  5 15:39:17 2005
From: normelton at gmail.com (Norman Elton)
Date: Mon Sep  5 15:39:31 2005
Subject: [concurrency-interest] NullPointerException after removing
	alltasks from a ThreadPoolExecutor
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07CA29@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07CA29@gerard.anchormen.nl>
Message-ID: <4A902793-D2B9-4BC4-901C-F698B0C036B6@gmail.com>

Thanks for the follow-up. The "tThread" naming was actually a  
misnomer. In the implementation, it's a Runnable, not a thread.

As far as the NullPointerException, Doug Lea just responded offline  
(perhaps there's a list post coming soon) pointing to...

http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6215625

Thanks all,

Norman



On Sep 5, 2005, at 3:29 PM, Peter Veentjer - Anchor Men wrote:

> You shouldn't use Threads but use runnable`s. The  
> ThreadPoolExecutor has is own pool of thread (hence the name).
>
> I don't know the cause of the NullPointerException.
>
>

From normelton at gmail.com  Mon Sep  5 17:00:05 2005
From: normelton at gmail.com (Norman Elton)
Date: Mon Sep  5 17:00:17 2005
Subject: [concurrency-interest] Compiling from CVS
Message-ID: <3DAD3673-0F1A-4E69-93AF-84860EF81449@gmail.com>

I apologize that this may be more of an Ant question, but I'm using  
the supplied build.xml, and can't get it to compile correctly. A  
simple "ant compile" generates...

     [javac] /usr/local/netauth2/jsr166/jsr166/src/main/java/util/ 
AbstractMap.java:52: error: '{' expected.
     [javac]    public abstract class AbstractMap<K,V> implements  
Map<K,V> {
     [javac]                                     ^
     [javac] /usr/local/netauth2/jsr166/jsr166/src/main/java/util/ 
AbstractMap.java:52: internal compiler error: Segmentation fault

This would seem to indicate that it's running a 1.4 compiler. If I  
specify a "java.home" attribute, I get...

file:/usr/local/netauth2/jsr166/jsr166/build.xml:111: Error running  
javac compiler

If I compile by hand, I get errors complaining that it cannot find  
Arrays.copyOf() for various classes.

Any ideas?

Thanks,

Norman
From holger at wizards.de  Mon Sep  5 17:15:08 2005
From: holger at wizards.de (Holger Hoffstaette)
Date: Mon Sep  5 17:20:02 2005
Subject: [concurrency-interest] Re: Waitable* classes for backport or 1.5?
References: <pan.2005.09.03.15.09.19.567250@wizards.de>
Message-ID: <pan.2005.09.05.21.15.07.399375@wizards.de>

On Sat, 03 Sep 2005 17:09:20 +0200, Holger Hoffstaette wrote:

> has anybody forward-ported the Waitable{Boolean/Byte..} classes from the
> original edu.oswego package to either backport or 1.5 proper? I could need

Well just for the record - I first wrote a junit test case against
edu.oswego.WaitableBoolean, wrote the backport implementation (which needs
to be in a different inheritance hierarchy because some Atomic* methods
are final, grr!) by wrapping an AtomicBoolean, and after successfully
switching the test over it works just fine in the old codebase.
No rocket science..if someone needs the code drop me a line.

Holger


From dholmes at dltech.com.au  Mon Sep  5 18:11:11 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Mon Sep  5 18:11:21 2005
Subject: [concurrency-interest] Compiling from CVS
In-Reply-To: <3DAD3673-0F1A-4E69-93AF-84860EF81449@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEJKGCAA.dholmes@dltech.com.au>

Norman,

> This would seem to indicate that it's running a 1.4 compiler.

Yes.

> If I specify a "java.home" attribute, I get...
>
> file:/usr/local/netauth2/jsr166/jsr166/build.xml:111: Error running
> javac compiler

Can't help there. Have you tried just setting the PATH to point to javac 5
when running ant?

> If I compile by hand, I get errors complaining that it cannot find
> Arrays.copyOf() for various classes.

Those methods are new in Mustang. It seems Arrays.java has just been added
to the cvs with these new methods. However I don't think you want to be
compiling the Mustang version of things. Does it not suffice to download the
jsr166 jar file and place it in your bootclasspath?

David Holmes

From dholmes at dltech.com.au  Mon Sep  5 18:19:38 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Mon Sep  5 18:19:46 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit fromSorted{Map, Set}
In-Reply-To: <431C1093.8050301@univ-mlv.fr>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEJLGCAA.dholmes@dltech.com.au>

Remi,
> It works so i prefer not to touch it if it's possible.

But it won't work in Java 6 so you are going to have to do something
regardless and inverting the test is a simple fix.

> It seems not a good idea to have to rewrite a code because i want to
> retrofit a class.

If the retrofit is perfectly compatible with what you have then there would
be no need to rewrite things. But you are trying to retrofit something that
is incompatible with what you have. The simple solution is "don't do that".

The choice was made that a NavigableSet isA SortedSet. You have a situation
where you'd like the functionality of NavigableSet but your implementation
is not a SortedSet and doesn't want to be. Something has to give.

Cheers,
David Holmes

From dl at cs.oswego.edu  Mon Sep  5 18:31:24 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Sep  5 18:31:31 2005
Subject: [concurrency-interest] Compiling from CVS
In-Reply-To: <3DAD3673-0F1A-4E69-93AF-84860EF81449@gmail.com>
References: <3DAD3673-0F1A-4E69-93AF-84860EF81449@gmail.com>
Message-ID: <431CC73C.8080909@cs.oswego.edu>

Norman Elton wrote:
> I apologize that this may be more of an Ant question, but I'm using  
> the supplied build.xml, and can't get it to compile correctly. A  

Our full build scripts are always forward-looking to the next release.
For a pointwise fix, the easiest thing to do is to get only that
file, place in a directory whatever/java/util/concurrent, compile
it, make a jar from the root of it, and add to -Xbootclasspath.
This is harder to automate, but it avoids the sorts of major-release
incompatibilities you can otherwise encounter.

-Doug

From dholmes at dltech.com.au  Mon Sep  5 18:32:53 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Mon Sep  5 18:33:00 2005
Subject: [concurrency-interest] Navigable{Map,
	Set} must not inherit fromSorted{Map, Set}
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEJLGCAA.dholmes@dltech.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEJNGCAA.dholmes@dltech.com.au>

I wrote:
> But it won't work in Java 6 so you are going to have to do something
> regardless and inverting the test is a simple fix.

Sorry I lost the context a little. If you retrofit your code to implement
NavigableSet then the other code will break - otherwise the other code will
still work in Java 6.

The choice really comes down to how bad you want to implement NavigableSet.

For what it is worth that instanceof test should be written the other way
regardless - always look for the most specific type first, which in this
case is your implementation class.

David Holmes

From dl at cs.oswego.edu  Mon Sep  5 19:48:47 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Sep  5 19:48:54 2005
Subject: [concurrency-interest] overview new features -> tim.
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07CA26@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07CA26@gerard.anchormen.nl>
Message-ID: <431CD95F.5030105@cs.oswego.edu>

Peter Veentjer - Anchor Men wrote:
> 
> I don`t think that is a very good solution because the exchange of messages is combined 
> 
> with storage of messages. 
> 

That was my original rational for dl.uti.concurrent versions. But the
rest of the world (including, now, me) disagrees. Support for standard
Collection methods was probably the most frequently requested feature.
Integration into Collections makes these classes more widely usable. And
(sorry to say) the only people inconvenienced by it can cope
with this a lot more easily than if it were the other way around.

-Doug
From p.veentjer at anchormen.nl  Tue Sep  6 02:04:07 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep  6 02:04:27 2005
Subject: [concurrency-interest] overview new features -> tim.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2A@gerard.anchormen.nl>

I like to have a small interface so making implementations is easy
and are easy to reason about. If I need buffering (queuing) I could
chain (decorate) channels, the same goes for other functionality like regulating 
(closing/opening channels) or monitoring. There is no reason this
functionality should be declared in the root interface. 
 
example of chaining:
OutputChannel c = someChannel;//every channel implement in/outputchannel
c = new MonitoringOutputChannel(c);
c = new LoggingOutputChannel(c);
Channel newChannel = new ComposedChannel(c,someChannel);
 
In this example a new channel (with logging and monitoring) is created 
based on someChannel. This works great and a wide root interface
isn`t required.

________________________________

From: Doug Lea [mailto:dl@cs.oswego.edu]
Sent: Tue 9/6/2005 1:48
To: Peter Veentjer - Anchor Men
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] overview new features -> tim.



Peter Veentjer - Anchor Men wrote:
>
> I don`t think that is a very good solution because the exchange of messages is combined
>
> with storage of messages.
>

That was my original rational for dl.uti.concurrent versions. But the
rest of the world (including, now, me) disagrees. Support for standard
Collection methods was probably the most frequently requested feature.
Integration into Collections makes these classes more widely usable. And
(sorry to say) the only people inconvenienced by it can cope
with this a lot more easily than if it were the other way around.

-Doug




From tim at peierls.net  Tue Sep  6 02:11:40 2005
From: tim at peierls.net (Tim Peierls)
Date: Tue Sep  6 02:11:56 2005
Subject: [concurrency-interest] overview new features -> tim.
In-Reply-To: <431CD95F.5030105@cs.oswego.edu>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07CA26@gerard.anchormen.nl>
	<431CD95F.5030105@cs.oswego.edu>
Message-ID: <431D331C.7040209@peierls.net>

> Peter Veentjer - Anchor Men wrote:
>> I don`t think that is a very good solution because the exchange of 
>> messages is combined with storage of messages.
> 
Doug Lea wrote:
> That was my original rationale for dl.uti.concurrent versions. But the
> rest of the world (including, now, me) disagrees. Support for standard
> Collection methods was probably the most frequently requested feature.
> Integration into Collections makes these classes more widely usable. And
> (sorry to say) the only people inconvenienced by it can cope
> with this a lot more easily than if it were the other way around.

And if you're having trouble coping, just do this:

   public interface Puttable<E> {
       boolean offer(E o);
       boolean offer(E o, long timeout, TimeUnit unit) throws InterruptedException;
       void put(E o) throws InterruptedException;
   }

   public interface Takeable<E> {
       E poll();
       E pool(long timeout, TimeUnit unit) throws InterruptedException;
       E take() throws InterruptedException;
   }

   public class PTAdapters {
       public static <E> Puttable<E> asPuttable(BlockingQueue<E> q) {
           return new Puttable<E>() {
               public boolean offer(E o) { return q.offer(o); }
               public boolean offer(E o, long timeout, TimeUnit unit)
                   throws InterruptedException { return q.offer(o, timeout, unit); }
               public void put(E o) throws InterruptedException { q.put(o); }
           };
       }
       public static <E> Takeable<E> asTakeable(BlockingQueue<E> q) {
           return new Takeable<E>() {
               public E poll() { return q.poll(); }
               public E poll(long timeout, TimeUnit unit)
                   throws InterruptedException { return q.poll(timeout, unit); }
               public E take() throws InterruptedException { return q.take(); }
           };
       }
       private PTAdapters() {} // uninstantiable
   }

   // sample use
   class Producer {
       Producer(Puttable<Long> p) {...}
       ...
   }
   class Consumer {
       Consumer(Takeable<Long> t) {...}
       ...
   }
   BlockingQueue<Long> queue = new ArrayBlockingQueue<Long>(10);
   Executor exec = newFixedThreadPool(2);
   exec.execute(new Producer(asPuttable(queue)));
   exec.execute(new Consumer(asTakeable(queue)));
   exec.shutdown();

There, now you have them back. :-)

--tim

From p.veentjer at anchormen.nl  Tue Sep  6 02:20:56 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep  6 02:23:15 2005
Subject: [concurrency-interest] overview new features -> tim.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2B@gerard.anchormen.nl>

I'm going to work, have a nice cup of coffee and then I'll 
have a good look at it (looks nice).

________________________________

From: Tim Peierls [mailto:tim@peierls.net]
Sent: Tue 9/6/2005 8:11
To: Peter Veentjer - Anchor Men
Cc: Doug Lea; concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] overview new features -> tim.



> Peter Veentjer - Anchor Men wrote:
>> I don`t think that is a very good solution because the exchange of
>> messages is combined with storage of messages.
>
Doug Lea wrote:
> That was my original rationale for dl.uti.concurrent versions. But the
> rest of the world (including, now, me) disagrees. Support for standard
> Collection methods was probably the most frequently requested feature.
> Integration into Collections makes these classes more widely usable. And
> (sorry to say) the only people inconvenienced by it can cope
> with this a lot more easily than if it were the other way around.

And if you're having trouble coping, just do this:

   public interface Puttable<E> {
       boolean offer(E o);
       boolean offer(E o, long timeout, TimeUnit unit) throws InterruptedException;
       void put(E o) throws InterruptedException;
   }

   public interface Takeable<E> {
       E poll();
       E pool(long timeout, TimeUnit unit) throws InterruptedException;
       E take() throws InterruptedException;
   }

   public class PTAdapters {
       public static <E> Puttable<E> asPuttable(BlockingQueue<E> q) {
           return new Puttable<E>() {
               public boolean offer(E o) { return q.offer(o); }
               public boolean offer(E o, long timeout, TimeUnit unit)
                   throws InterruptedException { return q.offer(o, timeout, unit); }
               public void put(E o) throws InterruptedException { q.put(o); }
           };
       }
       public static <E> Takeable<E> asTakeable(BlockingQueue<E> q) {
           return new Takeable<E>() {
               public E poll() { return q.poll(); }
               public E poll(long timeout, TimeUnit unit)
                   throws InterruptedException { return q.poll(timeout, unit); }
               public E take() throws InterruptedException { return q.take(); }
           };
       }
       private PTAdapters() {} // uninstantiable
   }

   // sample use
   class Producer {
       Producer(Puttable<Long> p) {...}
       ...
   }
   class Consumer {
       Consumer(Takeable<Long> t) {...}
       ...
   }
   BlockingQueue<Long> queue = new ArrayBlockingQueue<Long>(10);
   Executor exec = newFixedThreadPool(2);
   exec.execute(new Producer(asPuttable(queue)));
   exec.execute(new Consumer(asTakeable(queue)));
   exec.shutdown();

There, now you have them back. :-)

--tim





From p.veentjer at anchormen.nl  Tue Sep  6 03:26:25 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep  6 03:26:44 2005
Subject: [concurrency-interest] overview new features -> tim.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA071220@gerard.anchormen.nl>

Hi Tim,

Your solution looks a lot like mine. I have create the
Input/OutputChannel
Instead of the Puttable/Takable. Although I find puttable and takable
Easier to understand (you can put things in a output channel, and
retrieve
Things from a input channen, feels Strange at first) but they are well
known 
names. So I didn`t want to create new names.

The PTAdapters are nice. I have created something similar:
The BufferedChannel.

Example:
Channel c = new BufferedChannel(new BlockingQueue());
InputChannel in = c;
OutputChannel out = c;

And the threading part... If have been strugling with it in the
Beginning, but I have found the following solutions:

1---------------------------------------
I can make channels active:
OutputChannel c = new DoSomeHeavyCalculatingOutputChannel(..);
ActiveOutputChannel a = new ActiveOutputChannel(c,someExecutorService);

If a message is put/offered on a, a new runnable is put on the 
someExecutorService and the thread that put it there isn`t
Used for putting the message on c, but a thread from the
'someExecutorService' is used.

2---------------------------------------
But also have created something new recently: the Repeater. 
Example:

Channel fetchChannel = new StdBufferedChannel();
Channel protocolChan = new StdBufferedChannel();
Channel parseDataChan = new StdBufferedChannel();

RepeaterService fetchRepeater = new StdRepeaterService(40);//40 threads
fetchRepeater.start();
BetterFetcher fetcher = new
BetterFetcher(fetchChannel,protocolChan,fetchRepeater);
fetcher.start();

RepeaterService analyseRepeater = new StdRepeaterService();
analyseRepeater.start();
Analyzer analyzer = new
Analyzer(protocolChan,parseDataChan,analyseRepeater);
analyzer.start();

RepeaterService downManRepeater = new StdRepeaterService();
downManRepeater.start();
DownloadManager downMan = new
DownloadManager(parseDataChan,fetchChannel,downManRepeater);
downMan.start();

In this example there are 3 channels:
fetchChannel (you can put requests in here for pages to download)
protocolChan (the fetcher puts the downloaded pages in here)
parseDataChan (the analyzer put the analyzed pages (with outlinks) in
here))

The Repeaters can be compared to a threadpool, but they keep
Executing the same task over and over again. In this example
The repeaters keep sucking on channels to recieve messages
And process them.

This is the code of the BetterFetcher:

public class BetterFetcher {

	private InputChannel _channel;
	private Repeater _repeater;
	private Channel _protocolOutputChannel;

	public BetterFetcher(InputChannel channel, Channel
protocolOutputChannel, Repeater repeater) {
		if (channel ==
null||protocolOutputChannel==null||repeater == null) throw new
NullPointerException();
		_channel = channel;
		_repeater = repeater;
		_protocolOutputChannel = protocolOutputChannel;
	}

	public void start() throws InterruptedException {
		_repeater.repeat(new RunnableImpl());
	}

	private class RunnableImpl implements Runnable{

		private void runInterrupteble()throws
InterruptedException{
			FetchListEntry fle =
(FetchListEntry)_channel.take();
			String url = fle.getPage().getURL().toString();
			System.out.println("fetching url: "+url);
			Protocol protocol = null;
			try {
				try{
					protocol =
ProtocolFactory.getProtocol(url);
				}catch(RuntimeException ex){
					ex.printStackTrace();
					throw ex;
				}

				ProtocolOutput output =
protocol.getProtocolOutput(fle);
				System.out.println("page succesfully
retrieved");
				_protocolOutputChannel.put(new
X(fle,output));
			} catch (ProtocolNotFound protocolNotFound) {
				System.out.println("no protocol found");
				protocolNotFound.printStackTrace();
			}
		}

		public void run() {
			try {
				runInterrupteble();
			} catch (InterruptedException e) {
				e.printStackTrace();  //To change body
of catch statement use File | Settings | File Templates.
			}
		}
	}
}


At the moment I`m experimenting with the repeaters in a prototype, 
But the ActiveChannels have been used in a couple of projects and 
I`m totally in love with this channeled approach. 




From p.veentjer at anchormen.nl  Tue Sep  6 03:37:24 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep  6 03:37:44 2005
Subject: [concurrency-interest] overview new features -> tim.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA071222@gerard.anchormen.nl>


You have been asking about a usecase for the BlockingExecutor.
The someExecutorService from my threading example is A BlockingExecutor.

OutputChannel c = new DoSomeHeavyCalculatingOutputChannel(..);
BlockingExecutor blockingExecutor = new BlockingExecutor(10);//10
threads.
ActiveOutputChannel activeChannel= new
ActiveOutputChannel(c,blockingExecutor);

The someExecutor is a BlockingExecutor. That is where I need The control

for timeouts for. If a msg is offered on activeChannel, The message is 
offered with the same arguments to the blockingexecutor.

Example of put:
activeChannel.Put(msg) gives a blockingExecutor.put(new
PutterRunnable(msg));

Example of offer:
activeChannel.offer(msg,timeout,unit) gives a blockingExecutor.offer(new
PutterRunnable(msg),timeout,unit);

From p.veentjer at anchormen.nl  Tue Sep  6 13:10:37 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep  6 13:11:21 2005
Subject: [concurrency-interest] unit testing concurrency code.
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2E@gerard.anchormen.nl>

How do you (unit) tests concurrency code? I'm experienced
with JUnit, but I haven't found a good extension for junit.

From brian at quiotix.com  Tue Sep  6 14:42:35 2005
From: brian at quiotix.com (Brian Goetz)
Date: Tue Sep  6 14:42:45 2005
Subject: [concurrency-interest] unit testing concurrency code.
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2E@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2E@gerard.anchormen.nl>
Message-ID: <431DE31B.1020907@quiotix.com>

Like the old joke about how porcupines mate -- very carefully.

Testing concurrent code is an extension of testing regular code.  First, 
you must have good tests for functionality, and be able to test as many 
of your classes invariants as possible.  The trick is then trying to 
generate as many random interleavings of operations as you can, without 
the test framework introducing timing artifacts that will prevent 
certain interleavings from being tested.

Our book, Java Concurrency in Practice, due out by the end of the year, 
will cover some of this.

Peter Veentjer - Anchor Men wrote:
> How do you (unit) tests concurrency code? I'm experienced
> with JUnit, but I haven't found a good extension for junit.
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From p.veentjer at anchormen.nl  Wed Sep  7 02:24:37 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Wed Sep  7 02:25:34 2005
Subject: [concurrency-interest] Why never daemon threads with default
	threadfactory?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA30@gerard.anchormen.nl>

Why are the threads created with the default thread
factory never deamon threads? even though their threadgroup 
could have the daemon property set to true.
 
 
 
 

From p.veentjer at anchormen.nl  Wed Sep  7 02:31:06 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Wed Sep  7 02:31:33 2005
Subject: [concurrency-interest] ScheduledExecutor execute takes longer than
	the next job.. what is going to happen?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07CA31@gerard.anchormen.nl>

What happens if the ScheduledExecutor executes a heavy job,
only has a single thread, and the next job needs to be scheduled?
 
If the execution of a job takes 1 minute.. and every 30 seconds
a job should be executed.. are the jobs that have to wait dropped? 
Stored? Can this be controlled (maybe with timeouts)? 
 
I have looked through the documentation, but I didn't find an
answer to this question.

From dholmes at dltech.com.au  Wed Sep  7 02:39:36 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Wed Sep  7 02:39:49 2005
Subject: [concurrency-interest] Why never daemon threads with
	defaultthreadfactory?
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07CA30@gerard.anchormen.nl>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELMGCAA.dholmes@dltech.com.au>

Peter,

> Why are the threads created with the default thread
> factory never deamon threads? even though their threadgroup
> could have the daemon property set to true.

First, daemon threads and daemon threadgroups are completely unrelated.
Daemon threads won't keep the VM alive while they are executing. Daemon
thread groups are automatically destroyed when they become empty.

The default thread factory doesn't create daemon threads because the common
case is that you want any tasks submitted to an executor to actually get
executed. Daemon threads wouldn't support this unless you always used an
application thread to wait until the executor had finished.

If you truly want daemon threads it is easy to change the thread factory.

Note that daemon threads are deceptive creatures. Only the most trivial of
tasks can be arbitrarily terminated in the middle of processing - as would
happen if the JVM terminated.

Cheers,
David Holmes

From p.veentjer at anchormen.nl  Wed Sep  7 03:00:22 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Wed Sep  7 03:00:41 2005
Subject: [concurrency-interest] Why never daemon threads with
	defaultthreadfactory?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA071225@gerard.anchormen.nl>



>>The default thread factory doesn't create daemon threads because the 
>>common case is that you want any tasks submitted to an executor to 
>>actually get executed. Daemon threads wouldn't support this unless you

>>always used an application thread to wait until the executor had 
>>finished.
Aha ok. 

>>If you truly want daemon threads it is easy to change the thread 
>>factory.
I already did and that was why I was wondering why the daemon property 
with the default threadfactory Was set to false even though the daemon 
property of the Threadgroup is true.

>>Note that daemon threads are deceptive creatures. 
>>Only the most trivial of tasks can be arbitrarily terminated in the 
>>middle of processing - as would happen if the JVM terminated.
I know (it happend to me once). But I`m creating a new threadfactory 
where I have more control and was wondering why things are done in the 
default threadfactory.

Met vriendelijke groet,

Peter Veentjer
Anchor Men Interactive Solutions - duidelijk in zakelijke
internetoplossingen

Praediniussingel 41
9711 AE Groningen

T: 050-3115222
F: 050-5891696
E: p.veentjer@anchormen.nl
I : www.anchormen.nl

From dholmes at dltech.com.au  Wed Sep  7 03:06:52 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Wed Sep  7 03:07:01 2005
Subject: [concurrency-interest] Why never daemon threads
	withdefaultthreadfactory?
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA071225@gerard.anchormen.nl>
Message-ID: <NFBBKALFDCPFIDBNKAPCIELOGCAA.dholmes@dltech.com.au>

Peter,

> I already did and that was why I was wondering
> why the daemon property with the default threadfactory
> Was set to false even though the daemon property of the
> Threadgroup is true.

I don't know what you are talking about here. The default ThreadFactory
doesn't create or modify the ThreadGroup that will be used. If the group is
a daemon group then it has nothing to do with the thread factory.

And as I said: being a daemon Threadgroup has absolutely NO connection with
daemon threads.

Cheers,
David Holmes

From dholmes at dltech.com.au  Wed Sep  7 03:12:24 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Wed Sep  7 03:12:33 2005
Subject: [concurrency-interest] ScheduledExecutor execute takes longer
	thanthe next job.. what is going to happen?
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07CA31@gerard.anchormen.nl>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELOGCAA.dholmes@dltech.com.au>

Peter,

> What happens if the ScheduledExecutor executes a heavy job,
> only has a single thread, and the next job needs to be scheduled?
>
> If the execution of a job takes 1 minute.. and every 30 seconds
> a job should be executed.. are the jobs that have to wait dropped?
> Stored? Can this be controlled (maybe with timeouts)?

As per the documentation: "Delayed tasks execute no sooner than they are
enabled, but without any real-time guarantees about when, after they are
enabled, they will commence."

If there are no threads available to process it then it will wait until a
thread is available. (The tasks are put into a work queue and only come
out - excluding cancellation - if a worker thread asks for a task, and the
task is eligible to execute.)


scheduleWithFixedDelay states:

"Creates and executes a periodic action that becomes enabled first after the
given initial delay, and subsequently with the given delay between the
termination of one execution and the commencement of the next."

So the next occurrence of the task won't execute until "delay" timeunits
after the previous invocation completed.

scheduleAtFixedRate is less clear on how it behaves. I believe the basic
model for periodic tasks is that at the end of each execution the task looks
to see if its period has elapsed since its last "start" time and if so it is
eligible to run again. This means that you'll never have multiple executions
of the one task happening concurrently even if multiple periods have passed.
But I don't know if it will execute again immediately or have to wait its
turn if others tasks could also execute.

Cheers,
David Holmes

From p.veentjer at anchormen.nl  Wed Sep  7 03:12:50 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Wed Sep  7 03:13:10 2005
Subject: [concurrency-interest] Why never daemon threads
	withdefaultthreadfactory?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA071226@gerard.anchormen.nl>


>> I already did and that was why I was wondering
>> why the daemon property with the default threadfactory
>> Was set to false even though the daemon property of the
>> Threadgroup is true.
>
>I don't know what you are talking about here. The default ThreadFactory
>doesn't create or modify the ThreadGroup that will be used. If the
group is
>a daemon group then it has nothing to do with the thread factory.
>
>And as I said: being a daemon Threadgroup has absolutely NO connection
with
>daemon threads.
Aha ok.. I thought there was some relation: if a threadgroup is a daemon
and a thread created ( and linked to that threadgroup) would also be a
daemon.
But clearly that isn`t the case. 

From jason_mehrens at hotmail.com  Wed Sep  7 09:36:48 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Wed Sep  7 09:36:59 2005
Subject: [concurrency-interest] CopyOnWriteArrayList clone bug?
Message-ID: <BAY105-F541EE811E4F40D4773A7783A60@phx.gbl>

In revision: 1.51 of the CopyOnWriteArrayList, the resetLock() method is not 
invoked on the newly created clone.  Won't this result in one lock being 
shared over multiple instances?

Jason Mehrens


From normelton at gmail.com  Wed Sep  7 09:56:18 2005
From: normelton at gmail.com (Norman Elton)
Date: Wed Sep  7 09:56:33 2005
Subject: [concurrency-interest] Compiling from CVS
In-Reply-To: <431CC73C.8080909@cs.oswego.edu>
References: <3DAD3673-0F1A-4E69-93AF-84860EF81449@gmail.com>
	<431CC73C.8080909@cs.oswego.edu>
Message-ID: <2F4A13FD-97CB-4FBE-A1DC-CCB7F96B3C55@gmail.com>

That is indeed a MUCH nicer solution than to run an entire beta code  
release. I grabbed LinkedBlockingQueue.java, compiled and JARed it.  
Works like a charm. Look forward to it being in the official Sun  
release.

Thanks again,

Norman

On Sep 5, 2005, at 6:31 PM, Doug Lea wrote:

> Norman Elton wrote:
>
>> I apologize that this may be more of an Ant question, but I'm  
>> using  the supplied build.xml, and can't get it to compile  
>> correctly. A
>>
>
> Our full build scripts are always forward-looking to the next release.
> For a pointwise fix, the easiest thing to do is to get only that
> file, place in a directory whatever/java/util/concurrent, compile
> it, make a jar from the root of it, and add to -Xbootclasspath.
> This is harder to automate, but it avoids the sorts of major-release
> incompatibilities you can otherwise encounter.
>
> -Doug
>
>

From dl at cs.oswego.edu  Wed Sep  7 09:57:11 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Sep  7 09:57:23 2005
Subject: [concurrency-interest] Concurrency at OOPSLA
Message-ID: <431EF1B7.6000009@cs.oswego.edu>


The early registration deadline for OOPSLA is approaching (September 9).
See http://oopsla.acm.org/ . It will be in San Diego October 16-20.

I think this is the first event that all of the JSR166 expert group
members are planning to attend. (We've never all been at the
same place at the same time.)

If you are planning to come, you might be interested in:

1. Tutorials given by subsets of the JSR166 EG.
    Introduction to Concurrent Programming in Java 5.0
      http://www.oopsla.org/2005/ShowEvent.do?id=114
    Effective Concurrent Programming with Java 5.0
     http://www.oopsla.org/2005/ShowEvent.do?id=137

2. The Synchronization and concurrency in object-oriented languages
(SCOOL) workshop. This was originally planned as a small interactive
restricted-attendance workshop. But there's been a lot of interest, so
it is now scheduled in a larger room, and others may attend
just by letting us know in advance. For details, see:
   http://research.microsoft.com/%7Etharris/scool/

3. The Java Technologies for Real-Time and Embedded Systems (JTRES)
workshop. This IS a smaller workshop, but you might ask permission
to attend. See
   http://www.cs.purdue.edu/homes/jv/JTRES05/

There may also be some related BoFs and the like (Josh Bloch hopes to
organize one), and the conference proper has several sessions of likely
interest.

Note that some of these overlap. OOPSLA has a busy schedule,
and it's impossible to avoid conflicts.

-Doug

From dl at cs.oswego.edu  Wed Sep  7 10:16:56 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Sep  7 10:17:09 2005
Subject: [concurrency-interest] CopyOnWriteArrayList clone bug?
In-Reply-To: <BAY105-F541EE811E4F40D4773A7783A60@phx.gbl>
References: <BAY105-F541EE811E4F40D4773A7783A60@phx.gbl>
Message-ID: <431EF658.6030004@cs.oswego.edu>

Jason Mehrens wrote:
> In revision: 1.51 of the CopyOnWriteArrayList, the resetLock() method is not 
> invoked on the newly created clone.  Won't this result in one lock being 
> shared over multiple instances?
> 

Yes. Thanks VERY much! Hopefully we'll get this change in for Mustang.
It's not quite a bug, but it is not the way anyone wants it to work.

(Note: The Tiger version of this class does not have this problem.
For Mustang, we needed to change to use explicit locks but did not
adjust clone accordingly.)

-Doug

From dl at cs.oswego.edu  Wed Sep  7 11:13:13 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Sep  7 11:13:26 2005
Subject: [concurrency-interest] ScheduledExecutor execute takes longer
	thanthe next job.. what is going to happen?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOELOGCAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCOELOGCAA.dholmes@dltech.com.au>
Message-ID: <431F0389.4080301@cs.oswego.edu>

David Holmes wrote:
> 
> 
> scheduleAtFixedRate is less clear on how it behaves. I believe the basic
> model for periodic tasks is that at the end of each execution the task looks
> to see if its period has elapsed since its last "start" time and if so it is
> eligible to run again. This means that you'll never have multiple executions
> of the one task happening concurrently even if multiple periods have passed.
> But I don't know if it will execute again immediately or have to wait its
> turn if others tasks could also execute.

Right. There are no promises about how long after it is re-enabled that
it will start. (We can't make any since it depends in part on numbers
of threads and tasks.)

-Doug
From jbloch at gmail.com  Wed Sep  7 12:59:40 2005
From: jbloch at gmail.com (Joshua Bloch)
Date: Wed Sep  7 12:59:47 2005
Subject: [concurrency-interest] CopyOnWriteArrayList clone bug?
In-Reply-To: <431EF658.6030004@cs.oswego.edu>
References: <BAY105-F541EE811E4F40D4773A7783A60@phx.gbl>
	<431EF658.6030004@cs.oswego.edu>
Message-ID: <b097ac5105090709595d931bf4@mail.gmail.com>

Doug,

Interesting, because this is a general "bug pattern."  If you move
from intrinsic lock to an explicit lock and you have a clone method,
you have to fix it.

        Josh

On 9/7/05, Doug Lea <dl@cs.oswego.edu> wrote:
> Jason Mehrens wrote:
> > In revision: 1.51 of the CopyOnWriteArrayList, the resetLock() method is not
> > invoked on the newly created clone.  Won't this result in one lock being
> > shared over multiple instances?
> >
> 
> Yes. Thanks VERY much! Hopefully we'll get this change in for Mustang.
> It's not quite a bug, but it is not the way anyone wants it to work.
> 
> (Note: The Tiger version of this class does not have this problem.
> For Mustang, we needed to change to use explicit locks but did not
> adjust clone accordingly.)
> 
> -Doug
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From jason_mehrens at hotmail.com  Wed Sep  7 23:20:44 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Wed Sep  7 23:20:59 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
Message-ID: <BAY105-F50049CFFD4180646A2EDE83990@phx.gbl>

Is the absence of "tail to head" iterator (Iterator<E> descendingIterator()) 
an intensional design decision?  I would think since the Deque has two ends 
a user would be able to iterate from either end.   The most apparent case 
for the "tail to head" iterator is the asLifoQueue class as it currently 
iterates from "head to tail".
An RFE was filed against the Stack 
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4475301 for this issue.  
Then again, that bug got zero votes so it must not be too important or maybe 
that could be attributed to the number of Stack users.  Just kidding.

Jason Mehrens


From jbloch at gmail.com  Thu Sep  8 02:01:27 2005
From: jbloch at gmail.com (Joshua Bloch)
Date: Thu Sep  8 02:01:32 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
In-Reply-To: <BAY105-F50049CFFD4180646A2EDE83990@phx.gbl>
References: <BAY105-F50049CFFD4180646A2EDE83990@phx.gbl>
Message-ID: <b097ac51050907230126e55732@mail.gmail.com>

Jason,

This was not an intentional design decision on my part  (I designed
this interface jointly with Doug).  Historically, Java collections
haven't had descending iterators.  List has the bidirectional
ListIterator, which is a bit too complex for my tastes (even if I did
design it).  SortedSet was missing this functionality till it was
augmented by NavigableSet.  I think it might well be reasonable to add
a descendingIterator method to Deque.  I wish you had come up with the
idea six months ago.  It would be a nightmare to try to sell this idea
to Sun now, especially because it affects all the subinterfaces and
implementations of Deque:(  On the other hand, interfaces are forever.
 If we don't do add the method now, we can't ever do it.  Let's see
what Doug thinks.

      Regards,

      Josh

On 9/7/05, Jason Mehrens <jason_mehrens@hotmail.com> wrote:
> Is the absence of "tail to head" iterator (Iterator<E> descendingIterator())
> an intensional design decision?  I would think since the Deque has two ends
> a user would be able to iterate from either end.   The most apparent case
> for the "tail to head" iterator is the asLifoQueue class as it currently
> iterates from "head to tail".
> An RFE was filed against the Stack
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4475301 for this issue.
> Then again, that bug got zero votes so it must not be too important or maybe
> that could be attributed to the number of Stack users.  Just kidding.
> 
> Jason Mehrens
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Thu Sep  8 06:29:49 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu Sep  8 06:30:09 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
In-Reply-To: <b097ac51050907230126e55732@mail.gmail.com>
References: <BAY105-F50049CFFD4180646A2EDE83990@phx.gbl>
	<b097ac51050907230126e55732@mail.gmail.com>
Message-ID: <4320129D.1030408@cs.oswego.edu>

Joshua Bloch wrote:
> Jason,
> 
> This was not an intentional design decision on my part  (I designed
> this interface jointly with Doug).  Historically, Java collections
> haven't had descending iterators.  List has the bidirectional
> ListIterator, which is a bit too complex for my tastes (even if I did
> design it).  SortedSet was missing this functionality till it was
> augmented by NavigableSet.  I think it might well be reasonable to add
> a descendingIterator method to Deque.  I wish you had come up with the
> idea six months ago.  It would be a nightmare to try to sell this idea
> to Sun now, especially because it affects all the subinterfaces and
> implementations of Deque:(  On the other hand, interfaces are forever.
>  If we don't do add the method now, we can't ever do it.  Let's see
> what Doug thinks.
> 

I think:
   1. Josh and Jason are right -- we ought to support descendingIterator
   2. The timing is very inconvenient but I'll see what we can do.
   3. Thanks to all the people on this list for trying things out,
      reading our code, spotting problems, and telling us about
      them. It improves java.util.concurrent for the rest of the
      world. But if you want to be even more helpful, tell about
      things sooner rather than later :-)

-Doug

From jason_mehrens at hotmail.com  Thu Sep  8 10:38:47 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu Sep  8 10:39:02 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
Message-ID: <BAY105-F30274B5992072F2419317983990@phx.gbl>

Josh,

Would getting votes for BUG 4475301 help sell the idea to sun or a new RFE?  
It looks like 82 votes are needed to get into the top 25 RFEs.  I would 
think a few the concurrency interest members would have sun accounts for the 
bug database so they could vote.

If the AsLifoQueue was modified to return the "tail-to-head" iterator, 
should the toArray methods return the elements in "tail-to-head" order?  Is 
descendingIterator the correct name as in implies the elements are ordered 
(by a Comparator)?

Jason "public Iterator<E> rotareti()" Mehrens

>From: Joshua Bloch <jbloch@gmail.com>
>Reply-To: josh@bloch.us
>To: Jason Mehrens <jason_mehrens@hotmail.com>
>CC: concurrency-interest@altair.cs.oswego.edu
>Subject: Re: [concurrency-interest] Deque missing tail to head iterator.
>Date: Wed, 7 Sep 2005 23:01:27 -0700
>
>Jason,
>
>This was not an intentional design decision on my part  (I designed
>this interface jointly with Doug).  Historically, Java collections
>haven't had descending iterators.  List has the bidirectional
>ListIterator, which is a bit too complex for my tastes (even if I did
>design it).  SortedSet was missing this functionality till it was
>augmented by NavigableSet.  I think it might well be reasonable to add
>a descendingIterator method to Deque.  I wish you had come up with the
>idea six months ago.  It would be a nightmare to try to sell this idea
>to Sun now, especially because it affects all the subinterfaces and
>implementations of Deque:(  On the other hand, interfaces are forever.
>  If we don't do add the method now, we can't ever do it.  Let's see
>what Doug thinks.
>
>       Regards,
>
>       Josh
>
>On 9/7/05, Jason Mehrens <jason_mehrens@hotmail.com> wrote:
> > Is the absence of "tail to head" iterator (Iterator<E> 
>descendingIterator())
> > an intensional design decision?  I would think since the Deque has two 
>ends
> > a user would be able to iterate from either end.   The most apparent 
>case
> > for the "tail to head" iterator is the asLifoQueue class as it currently
> > iterates from "head to tail".
> > An RFE was filed against the Stack
> > http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4475301 for this 
>issue.
> > Then again, that bug got zero votes so it must not be too important or 
>maybe
> > that could be attributed to the number of Stack users.  Just kidding.
> >
> > Jason Mehrens
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >


From jason_mehrens at hotmail.com  Thu Sep  8 14:48:58 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu Sep  8 14:50:13 2005
Subject: [concurrency-interest] Timed Peek for BlockingDeque
Message-ID: <BAY105-F232D86D9CED0938DC7D8F283990@phx.gbl>

Are timed peeks a worth while addition to the BlockingDeque?  There was a 
old RFE
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5099778 filed against the 
BlockingQueue about this issue. I would think it could be morphed into:

public E peekFirst (long timeout, TimeUnit unit) throws 
InterruptedException;
public E peekLast (long timeout, TimeUnit unit) throws InterruptedException;

I'm not sure if timed peeks pull their weight but, I figure it would be 
worth while to raise the issue.

Jason Mehrens


From tim at peierls.net  Thu Sep  8 15:22:30 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Sep  8 15:23:11 2005
Subject: [concurrency-interest] Timed Peek for BlockingDeque
In-Reply-To: <BAY105-F232D86D9CED0938DC7D8F283990@phx.gbl>
References: <BAY105-F232D86D9CED0938DC7D8F283990@phx.gbl>
Message-ID: <43208F76.2050403@peierls.net>

Jason Mehrens wrote:
> I'm not sure if timed peeks pull their weight but, I figure it would be 
> worth while to raise the issue.

If it can't be incorporated for Mustang, but there is still interest in it, it might be nice to
provide (unofficially) a TimedPeekAdapter that turns a BQ into a BQWithTimedPeek (better name).

--tim

From jbloch at gmail.com  Thu Sep  8 17:49:26 2005
From: jbloch at gmail.com (Joshua Bloch)
Date: Thu Sep  8 17:49:33 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
In-Reply-To: <BAY105-F30274B5992072F2419317983990@phx.gbl>
References: <BAY105-F30274B5992072F2419317983990@phx.gbl>
Message-ID: <b097ac51050908144949e6e42d@mail.gmail.com>

Jason,

On 9/8/05, Jason Mehrens <jason_mehrens@hotmail.com> wrote:
> Josh,
> 
> Would getting votes for BUG 4475301 help sell the idea to sun or a new RFE?
> It looks like 82 votes are needed to get into the top 25 RFEs.  I would
> think a few the concurrency interest members would have sun accounts for the
> bug database so they could vote.

It could, but I wouldn't mount a vote drive just yet.  Doug and I can
talk to our contacts at Sun and see where we stand.
> 
> If the AsLifoQueue was modified to return the "tail-to-head" iterator,
> should the toArray methods return the elements in "tail-to-head" order? 

Not sure I get this.  In fact, I'm a bit confused: the Bug parade says
there's a Collections.asLifoQueue(Queue) method, but the latest
Mustang snapshot shows no such method.  If there were such a method,
I'd imagine that it would do everything backward (iteration and
toArray).  The latest Mustang snapshot doesn't so a Deque interface
either, so I have no idea what's up.

>  Is descendingIterator the correct name as in implies the elements are ordered
> (by a Comparator)?

This is a good question.  On the one hand, it's the same name used by
Navigable set, which reduces the possibility that people will get it
wrong.  On the other hand it does sort of imply ordering based on
value.  Other possibilities include backwardIterator, reverseIterator,
and lastToFirstIterator.  I prefer lastToFirst to tailToHead, as the
other Deque method names contain "first" and "last" rather than "head"
and "tail."

       Regards,

       Josh

From jason_mehrens at hotmail.com  Thu Sep  8 20:09:38 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Thu Sep  8 20:11:11 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
Message-ID: <BAY105-F3886D684A5A316F60A72BA83980@phx.gbl>

Josh,

>Not sure I get this.  In fact, I'm a bit confused: the Bug parade says
>there's a Collections.asLifoQueue(Queue) method, but the latest
>Mustang snapshot shows no such method.  If there were such a method,
>I'd imagine that it would do everything backward (iteration and
>toArray).  The latest Mustang snapshot doesn't so a Deque interface
>either, so I have no idea what's up.

I can see why you are confused, because my original question:

>>If the AsLifoQueue was modified to return the "tail-to-head" iterator,
>>should the toArray methods return the elements in "tail-to-head" order?

was based on a misunderstanding of the AsLifoQueue code from the CVS source 
on this site.  The AsLifoQueue implementation on this site is correct and 
works as expected (backward iteration and toArray).

Thanks for answering my questions,

Jason Mehrens


From jbloch at gmail.com  Thu Sep  8 20:40:21 2005
From: jbloch at gmail.com (Joshua Bloch)
Date: Thu Sep  8 20:40:25 2005
Subject: [concurrency-interest] Deque missing tail to head iterator.
In-Reply-To: <BAY105-F3886D684A5A316F60A72BA83980@phx.gbl>
References: <BAY105-F3886D684A5A316F60A72BA83980@phx.gbl>
Message-ID: <b097ac5105090817401caede05@mail.gmail.com>

Jason,

Happy to help.  And I do hope we succeed in amending Deque as your suggested.

                      Josh

On 9/8/05, Jason Mehrens <jason_mehrens@hotmail.com> wrote:
> Josh,
> 
> >Not sure I get this.  In fact, I'm a bit confused: the Bug parade says
> >there's a Collections.asLifoQueue(Queue) method, but the latest
> >Mustang snapshot shows no such method.  If there were such a method,
> >I'd imagine that it would do everything backward (iteration and
> >toArray).  The latest Mustang snapshot doesn't so a Deque interface
> >either, so I have no idea what's up.
> 
> I can see why you are confused, because my original question:
> 
> >>If the AsLifoQueue was modified to return the "tail-to-head" iterator,
> >>should the toArray methods return the elements in "tail-to-head" order?
> 
> was based on a misunderstanding of the AsLifoQueue code from the CVS source
> on this site.  The AsLifoQueue implementation on this site is correct and
> works as expected (backward iteration and toArray).
> 
> Thanks for answering my questions,
> 
> Jason Mehrens
> 
> 
>

From mattocks at mac.com  Fri Sep  9 00:15:33 2005
From: mattocks at mac.com (Craig Mattocks)
Date: Fri Sep  9 00:15:58 2005
Subject: [concurrency-interest] Re: unit testing concurrency code.
Message-ID: <6f6f015a82f293460fb6ca822e0a3146@mac.com>

On Tue, 06 Sep 2005 14:42:35 Brian Goetz <brian@quiotix.com> wrote:

 > Our book, Java Concurrency in Practice, due out by the end of the  
year,
 > will cover some of this.

Great - I've been searching for a book like this!  Seems you can  
already pre-order it from Amazon:

http://www.amazon.com/exec/obidos/tg/detail/-/0321349601/ 
qid=1126238399/sr=8-1/ref=pd_bbs_1/002-8907356-9580856? 
v=glance&s=books&n=507846

Please post an announcement when it actually ships.

Does it contain the famous "baboons crossing a bridge" (platooning)  
problem?  :-)

Craig

From bharath at pramati.com  Wed Sep 14 05:40:01 2005
From: bharath at pramati.com (Bharath Ganesh)
Date: Wed Sep 14 07:09:49 2005
Subject: [concurrency-interest] Why String is immutable?
Message-ID: <002301c5b910$472c7b80$7301a8c0@bharathg>

Hi

Could anyone tell me why String is immutable?


=====
cheerio 
bharath
I Blog at http://jroller.com/page/bharath 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050914/fd8b030c/attachment.htm
From dholmes at dltech.com.au  Wed Sep 14 07:39:35 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Wed Sep 14 07:39:46 2005
Subject: [concurrency-interest] Why String is immutable?
In-Reply-To: <002301c5b910$472c7b80$7301a8c0@bharathg>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEDDGDAA.dholmes@dltech.com.au>

Primarily for security purposes. It assures that given, for example, a
security check that you can access a file of a given name, that the string
is not concurrently modified to represent a different file between the
security check and the actual opening of the file.

It also makes it easy to share strings without having to worry about someone
accidentally or maliciously changing the string - such as constant values.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Bharath
Ganesh
  Sent: Wednesday, 14 September 2005 7:40 PM
  To: concurrency-interest@altair.cs.oswego.edu
  Subject: [concurrency-interest] Why String is immutable?


  Hi

  Could anyone tell me why String is immutable?


  =====
  cheerio
  bharath
  I Blog at http://jroller.com/page/bharath
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050914/5cceb2d3/attachment.htm
From gregg at cytetech.com  Wed Sep 14 08:43:00 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed Sep 14 08:43:21 2005
Subject: [concurrency-interest] Why String is immutable?
In-Reply-To: <002301c5b910$472c7b80$7301a8c0@bharathg>
References: <002301c5b910$472c7b80$7301a8c0@bharathg>
Message-ID: <43281AD4.7050000@cytetech.com>



Bharath Ganesh wrote:
> Hi
>  
> Could anyone tell me why String is immutable?

There are several reasons, but the one that generally has the largest impact is, so that a single instance of any string 
value can be used for all references.  Look at String.intern(), which is used to maintain a "weak hash map" of all 
string values. This greatly reduces the total space for String values in many applications.  It would be interesting,
to have the ability to turn that off, and then see the difference in heap use for an XML based application for instance.

Gregg Wonderly
From dl at cs.oswego.edu  Wed Sep 14 10:11:10 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Sep 14 10:12:02 2005
Subject: [concurrency-interest] Mustang build 51 (and 53)
Message-ID: <43282F7E.1020109@cs.oswego.edu>


For those of you who have been waiting for fully integrated versions
of post-Tiger changes/additions/fixes, the newest Sun build (51) of
Mustang available at https://mustang.dev.java.net/ contains most
of them (in particular all those listed in violet under "jsr166 bugs
fixed in mustang" at 
http://gee.cs.oswego.edu/dl/concurrency-interest/jsr166/bugs.html)

A few more will appear in two weeks in b53. (And it is still possible
that descendingIterator will make it into Deque before release.)

Please try things out and tell us as soon as you can if you don't like
anything or run into any problems.

(Mustang is project name for what will be called JSE6. Note that
as of this version, everyone is now supposed drop the "2" from
J2SE/J2EE/J2ME => JSE/JEE/JME. Silly marketers...)

-Doug

From osvaldo at visionnaire.com.br  Wed Sep 14 10:37:33 2005
From: osvaldo at visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Wed Sep 14 10:35:31 2005
Subject: [concurrency-interest] Why String is immutable?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEDDGDAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEDDGDAA.dholmes@dltech.com.au>
Message-ID: <432835AD.5090707@visionnaire.com.br>

David Holmes wrote:
> Primarily for security purposes. It assures that given, for example, a 
> security check that you can access a file of a given name, that the 
> string is not concurrently modified to represent a different file 
> between the security check and the actual opening of the file.
>  
> It also makes it easy to share strings without having to worry about 
> someone accidentally or maliciously changing the string - such as 
> constant values.

Besides these reasons plus memory savings (as pointed by Gregg), I
think that one major reason was avoiding synchronization.  Monitors
were much more expensive in the first releases of Java, strings are
used pervasively in any app, and Java was designed to make concurrent
programming easy (almost all APIs thread-safe); therefore, without
immutability, java.lang.String would have to be synchronized and this
would have a big performance impact (even with modern, high-perf JVMs).


A+
Osvaldo

> Cheers,
> David Holmes
> 
>     -----Original Message-----
>     *From:* concurrency-interest-bounces@cs.oswego.edu
>     [mailto:concurrency-interest-bounces@cs.oswego.edu]*On Behalf Of
>     *Bharath Ganesh
>     *Sent:* Wednesday, 14 September 2005 7:40 PM
>     *To:* concurrency-interest@altair.cs.oswego.edu
>     *Subject:* [concurrency-interest] Why String is immutable?
> 
>     Hi
>      
>     Could anyone tell me why String is immutable?
> 
> 
>     =====
>     cheerio
>     bharath
>     I Blog at http://jroller.com/page/bharath 
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Inform?tica S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223

From gnu_andrew at member.fsf.org  Wed Sep 14 16:47:12 2005
From: gnu_andrew at member.fsf.org (Andrew John Hughes)
Date: Wed Sep 14 18:35:32 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
Message-ID: <1126730832.28949.75.camel@localhost.localdomain>

Hi all,

Some of you may be aware of the GNU Classpath project
(http://www.gnu.org/software/classpath), which aims to produce a Free
cleanroom implementation of the core class libraries.  Given the recent
addition of the concurrency classes to the 1.5 API, this is obviously
something we need to include at some point to produce a complete
implementation.

The availability of these classes within the public domain is thus
beneficial to us, as it should hopefully allow their inclusion without
the need to produce our own versions of this code.  Instead, we should
hopefully be able to include the public domain code in later releases.

In reviewing previous posts, there seems to have been some confusion
over the licensing of these files, and, as a result, we were hopeful
that you may be able to clarify the license of the files within both the
JSR166 package and the backport to 1.4.  As is currently understood, it
appears that most files are public domain save the following:

* java.util.concurrent.CopyOnWriteArrayList, which is under a Sun
license.
* Various java.util classes (e.g. AbstractMap, Collections, TreeMap),
which, at a guess, are taken from earlier Sun releases, and which we
already have implementations of.

We would be grateful if you could clarify this with us, so as to avoid
any later confusion.

Thanks in advance for any help you can give, and again for making these
classes available to us,
-- 
Andrew :-)

Please avoid sending me Microsoft Office (e.g. Word, PowerPoint)
attachments.
See http://www.fsf.org/philosophy/no-word-attachments.html

"Value your freedom, or you will lose it, teaches history.
`Don't bother us with politics' respond those who don't want to learn."
-- Richard Stallman

Escape the Java Trap with GNU Classpath!
http://www.gnu.org/philosophy/java-trap.html
public class gcj extends Freedom implements Java { ... }
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : /pipermail/attachments/20050914/a92ff8dd/attachment.bin
From dl at cs.oswego.edu  Wed Sep 14 18:49:13 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed Sep 14 18:50:09 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
In-Reply-To: <1126730832.28949.75.camel@localhost.localdomain>
References: <1126730832.28949.75.camel@localhost.localdomain>
Message-ID: <4328A8E9.3010905@cs.oswego.edu>

Andrew John Hughes wrote:
> 
> 
> We would be grateful if you could clarify this with us, so as to avoid
> any later confusion.
> 


There's a simple, universally valid rule you can use for JSR166 files
as they appear in CVS:
For any file of interest, do "head -5 <filename>".
It will either clearly say that it is released to the public domain or
it won't. Nearly all are.

But especially during release integration, our CVS contains not only
files originated by us, but also other files that are modified by us.
We do this to make sure that everything goes into a release exactly
right, which is more important to us than maintaining license purity.

This rule is better than an enumeration, since the actual files
might change over time.

(BTW, our diffs to files not originated by us are also
released to the public domain, but they might not be
very useful.)

-Doug




From dawidk at mathcs.emory.edu  Thu Sep 15 02:40:35 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Thu Sep 15 02:40:57 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
In-Reply-To: <1126730832.28949.75.camel@localhost.localdomain>
References: <1126730832.28949.75.camel@localhost.localdomain>
Message-ID: <43291763.9080009@mathcs.emory.edu>

Andrew John Hughes wrote:

>(...)
>We would be grateful if you could clarify this with us, so as to avoid
>any later confusion.
>
>  
>
As far as the backport is considered, there are two versions currently 
available:

* public domain version. All files are public domain, except portions of 
CopyOnWriteArrayList, which is adapted from SUN code and is subject to 
terms described in file "LEGAL" in the distribution (basically, the file 
can be freely redistributed; the only SUN restrictions are: it is 
prohibited to use SUN trademarks to endorse derived products, and to use 
the software in nuclear facilities). If these terms prove to be 
incompatible with GPL, I guess the ClassPath folks will need to write a 
clean-room implementation of COWArrayList.

* default version. In addition to the above, it contains 4 collection 
classes from java.util that are subject to SUN license. They include new 
functionality of collection classes that was introduced in Java 5.0 and 
later (e.g. TreeMap implementing NavigableMap etc.)

Regards,
Dawid Kurzyniec

From TEREKHOV at de.ibm.com  Thu Sep 15 09:59:36 2005
From: TEREKHOV at de.ibm.com (Alexander Terekhov)
Date: Thu Sep 15 10:00:11 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
In-Reply-To: <43291763.9080009@mathcs.emory.edu>
Message-ID: <OF229159B9.687C95B5-ONC125707D.004C45D8-C125707D.004CB3B2@de.ibm.com>


> incompatible with GPL

Somewhere in the cyberspace (Shlomi Fish on Monday April 01).

----
A recent press conference of the Free Software Foundation confirmed
the rumors that the GNU General Public License was found to be
incompatible with itself. This newly discovered fact may actually
cause a lot of disorder in the free software world in which most
programs and libraries are licensed under this license.

Richard Stallman, chairman of the FSF, called upon developers to
immediately exempt GPL-licensed software from the GPL, as far as
linking them with GPL programs is concerned. "We have already made
sure all GNU software and every other software that is licensed to
the Free Software Foundation would be ad-hoc compatible with itself.
However we need other developers to do the same for their software",
Stallman said.

Eben Moglen, the FSF's attorney outlined the subsequent steps that
his organization will take to overcome this crisis. The first step
would be releasing a Modified General Public License (or MGPL for
short) that will be compatible with the GPL and with itself as well
as with all other licenses that the GPL is already compatible with.
It will be labeled the GPL version 2.1, thus allowing developers to
convert their software to it. He noted that care would be taken to
make sure the upcoming GPL version 3.0 will be compatible with
itself, as well as the MGPL.

For the time being, though, there is an explosion of commentary,
confusion and otherwise bad temper about the newly formed situation.
Eric S. Raymond, the famous Open Source Guru notes: "This is one of
the greatest blows to the Open Source world, I have yet encountered.
I have already exempted all of my own software from the GPL in this
regard, but there is a lot of other software out there, and many of
its authors are not very communicative.

Bill Gates, Microsoft's co-founder, on the other hand, seems to
find the situation very amusing: "I said times and again, that
viral licenses such as the GPL are a bad idea, and many open-source
advocates disagreed. Now they see that even making sure one's
license is compatible with itself, is hard to do when you open that
can of worms."

The integrity of many software projects whose license is the GPL and
yet contain works licensed by several developers is in jeopardy. The
Linux kernel is a prominent example of such a case. In a post to its
mailing list, Linus Torvalds commented that, in their case, it was
not an issue. "My interpretation of the GPL is already quite unusual,
so I'll simply rule that I also interpret the GPL as compatible with
itself."
----

Sorry, I just could not resist.

regards,
alexander.

From yechielf at gigaspaces.com  Mon Sep 19 06:13:50 2005
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Mon Sep 19 05:07:05 2005
Subject: [concurrency-interest] a question about concurrent safe access
Message-ID: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>

Hi all
say I have a pointer ( reference) to an object ( A). This reference is
changed to point at object B. I have threads that concurrently are using
that reference to get the object it points at. I dont want to synchronize
the usage of the reference. Is it safe to do so, i.e. if I dont use a lock
and I dont declare the reference volatile will I always get object A or B or
do I have a risk of getting "dirty" inconsistent pointer , i.e. is assigning
a pointer always atomic  ? 

Regrds, 
Yechiel   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050919/d8f766ae/attachment.htm
From p.veentjer at anchormen.nl  Mon Sep 19 05:30:37 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Mon Sep 19 05:31:14 2005
Subject: [concurrency-interest] a question about concurrent safe access
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA071236@gerard.anchormen.nl>

As far as I know a object reference is always set atomic. So you can`t
get a non existing references unlike the double or long for example (you
can get non existing numbers because only a part of the number is
updated). 

________________________________

Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Yechiel
Feffer
Verzonden: maandag 19 september 2005 12:14
Aan: concurrency-interest@altair.cs.oswego.edu
Onderwerp: [concurrency-interest] a question about concurrent safe
access



Hi all 
say I have a pointer ( reference) to an object ( A). This reference is
changed to point at object B. I have threads that concurrently are using
that reference to get the object it points at. I dont want to
synchronize the usage of the reference. Is it safe to do so, i.e. if I
dont use a lock and I dont declare the reference volatile will I always
get object A or B or do I have a risk of getting "dirty" inconsistent
pointer , i.e. is assigning a pointer always atomic  ? 

Regrds, 
Yechiel   

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050919/9f6ef193/attachment.htm
From hanson.char at gmail.com  Mon Sep 19 06:30:43 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Mon Sep 19 06:30:59 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA071236@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA071236@gerard.anchormen.nl>
Message-ID: <ca53c8f805091903305aba650c@mail.gmail.com>

My understanding is you will always get either A or B, except, in theory, 
there is no guarantee that the assigned reference to B will ever be visible 
to other threads other than the one doing the assignment.

Hanson

On 9/19/05, Peter Veentjer - Anchor Men <p.veentjer@anchormen.nl> wrote:
> 
> As far as I know a object reference is always set atomic. So you can`t get 
> a non existing references unlike the double or long for example (you can get 
> non existing numbers because only a part of the number is updated). 
> 
>  ------------------------------
> *Van:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu] *Namens *Yechiel Feffer
> *Verzonden:* maandag 19 september 2005 12:14
> *Aan:* concurrency-interest@altair.cs.oswego.edu
> *Onderwerp:* [concurrency-interest] a question about concurrent safe 
> access
> 
>  Hi all 
> say I have a pointer ( reference) to an object ( A). This reference is 
> changed to point at object B. I have threads that concurrently are using 
> that reference to get the object it points at. I dont want to synchronize 
> the usage of the reference. Is it safe to do so, i.e. if I dont use a lock 
> and I dont declare the reference volatile will I always get object A or B or 
> do I have a risk of getting "dirty" inconsistent pointer , i.e. is 
> assigning a pointer always atomic ? 
> 
> Regrds, 
> Yechiel 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050919/e5a75629/attachment.htm
From michele.mazzucco at ncl.ac.uk  Mon Sep 19 06:57:42 2005
From: michele.mazzucco at ncl.ac.uk (Michele Mazzucco)
Date: Mon Sep 19 06:57:58 2005
Subject: [concurrency-interest] how to lock a ConcurrentHashMap entry
Message-ID: <432E99A6.1010604@ncl.ac.uk>

Hi all,
is it possible to lock a single value (or a single entry <K, V>) of a 
ConcurrentHashMap object?
If yes, how can I lock it?
From michele.mazzucco at ncl.ac.uk  Mon Sep 19 06:49:44 2005
From: michele.mazzucco at ncl.ac.uk (Michele Mazzucco)
Date: Mon Sep 19 07:02:58 2005
Subject: [concurrency-interest] locking an entry in a ConcurrentHashMap
	object
Message-ID: <432E97C8.50100@ncl.ac.uk>

Hi all,
is it possible to lock a single value (or a single entry <K, V>) of a 
ConcurrentHashMap object?
If yes, how can I lock it?
From dl at cs.oswego.edu  Mon Sep 19 07:13:31 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Sep 19 07:15:01 2005
Subject: [concurrency-interest] how to lock a ConcurrentHashMap entry
In-Reply-To: <432E99A6.1010604@ncl.ac.uk>
References: <432E99A6.1010604@ncl.ac.uk>
Message-ID: <432E9D5B.1020200@cs.oswego.edu>

Michele Mazzucco wrote:
> Hi all,
> is it possible to lock a single value (or a single entry <K, V>) of a 
> ConcurrentHashMap object?

No. Among other reasons, there is not necessarily a single
lock associated with each entry, and get() operations normally
run without accessing any lock at all.

These are among the tradeoffs of ConcurrentHashMap vs Hashtable.
ConcurrentHashMap gives much more scalable performance at the
price of not providing any way for users to perform external
synchronization.

-Doug



From dl at cs.oswego.edu  Mon Sep 19 07:19:20 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon Sep 19 07:20:50 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
Message-ID: <432E9EB8.2050902@cs.oswego.edu>

Yechiel Feffer wrote:
> Hi all
> say I have a pointer ( reference) to an object ( A). This reference is 
> changed to point at object B. I have threads that concurrently are using 
> that reference to get the object it points at. I dont want to 
> synchronize the usage of the reference. Is it safe to do so, i.e. if I 
> dont use a lock and I dont declare the reference volatile will I always 
> get object A or B or do I have a risk of getting "dirty" inconsistent 
> pointer , i.e. is assigning a pointer always atomic  ?
> 

Pleae declare the field volaitle.

One of the goals of the JSR133 JMM revision was to make answers to
questions like this nearly automatic: If you have a field that is not
consistently protected by some kind of synchronization, then it should
either be declared volatile or final. (Final doesn't apply here.)

If you don't declare it volatile, then you have to be prepared for
suprising things to happen, like begin able to read the reference
but not seeing the current values of the fields of the referred-to
object. The gruesome details are in chapter 17 of the revised JLS
(http://java.sun.com/docs/books/jls/index.html).

-Doug


From stefan.skoglund at it-huset.se  Mon Sep 19 07:36:36 2005
From: stefan.skoglund at it-huset.se (Stefan Skoglund)
Date: Mon Sep 19 07:37:05 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
Message-ID: <432EA2C4.40400@it-huset.se>

Theoretically, I guess you could get a dirty reference if you used a 
volatile reference. Consider the two treads X and Y. And consider 
volatile reference R pointing to A, seen by both threads. If X creates 
object B and lets R point to B, then Y would see reference R point to 
where B should reside. But since no memory synchronization is guarantied 
to have occurred. except the volatile reference. it would be possible 
that Y sees a dirty reference.

However as I understand, the current implementation of volatile reads 
and writes, does perform full blown memory synchronization between two 
threads, exchanging information through a volatile reference. So the 
dirty reference would never appear. I'm not sure one should rely the 
fullblown memory synchronization though.

I guess one of the experts could verify this.

yours
/Stefan


Yechiel Feffer wrote:

> Hi all
> say I have a pointer ( reference) to an object ( A). This reference is 
> changed to point at object B. I have threads that concurrently are 
> using that reference to get the object it points at. I dont want to 
> synchronize the usage of the reference. Is it safe to do so, i.e. if I 
> dont use a lock and I dont declare the reference volatile will I 
> always get object A or B or do I have a risk of getting "dirty" 
> inconsistent pointer , i.e. is assigning a pointer always atomic  ?
>
> Regrds,
> Yechiel  
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  
>


From michele.mazzucco at ncl.ac.uk  Mon Sep 19 08:54:58 2005
From: michele.mazzucco at ncl.ac.uk (Michele Mazzucco)
Date: Mon Sep 19 08:55:11 2005
Subject: [concurrency-interest] binary semaphore
Message-ID: <432EB522.9040501@ncl.ac.uk>

Java APIs say "A semaphore initialized to one, and which is used such 
that it only has at most one permit available, can serve as a mutual 
exclusion lock" (binary semaphore)
(http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Semaphore.html)

How can I implement a binary semaphore in a bounded buffer environment, 
say of capacity of one element (the binary semaphore has the property  - 
unlike many Lock implementations - that the "lock" can be released by a 
thread other than the owner), without using synchronized methods and 
wait() and notify()/notifyAll() calls?
From bnewport at us.ibm.com  Mon Sep 19 09:38:09 2005
From: bnewport at us.ibm.com (Billy Newport)
Date: Mon Sep 19 09:38:40 2005
Subject: [concurrency-interest] Billy Newport/Rochester/IBM is out of the
	office.
Message-ID: <OFD752B13D.B34F2A9C-ON86257081.004AE78E-86257081.004AE78F@us.ibm.com>

I will be out of the office starting  09/19/2005 and will not return until
09/20/2005.

I have no or very limited access to email. Please try my cell but I'll have
infrequent access to that also.

From brian at quiotix.com  Mon Sep 19 10:35:10 2005
From: brian at quiotix.com (Brian Goetz)
Date: Mon Sep 19 10:35:26 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE4AF@OFFICESRV>
Message-ID: <432ECC9E.5070006@quiotix.com>

> say I have a pointer ( reference) to an object ( A). This reference is 
> changed to point at object B. I have threads that concurrently are using 
> that reference to get the object it points at. I dont want to 
> synchronize the usage of the reference. Is it safe to do so, i.e. if I 
> dont use a lock and I dont declare the reference volatile will I always 
> get object A or B or do I have a risk of getting "dirty" inconsistent 
> pointer , i.e. is assigning a pointer always atomic  ?

The assignment of the _value_ of the pointer is atomic.  However, that 
does not mean this idiom is safe, because this does not promise anything 
about the object _pointed to_.  It is possible to see inconsistent 
values for the fields of the pointed-to object unless it is immutable.

Just writing a shared pointer is a form of "unsafe publication".

Example:

class Sum {
   // Invariant: a+b = sum
   public int a, b, sum;

   Sum(int a, int b) {
     this.a = a;
     this.b = b;
     this.sum = a+b;
   }
}

public static Sum sum;

Thread A:  sum= new Sum (3,4);

Thread B:  Sum mySum = sum;

At the end of this, Thread B could see sum have any of the following 
values for (a,b,sum):

   (0,0,0) *
   (0,0,7)
   (0,4,0)
   (3,0,0)
   (3,4,0)
   (3,0,7)
   (0,4,7)
   (3,4,7) *

The ones labeled with * are the only ones which are "consistent".

From jmanson at cs.purdue.edu  Mon Sep 19 11:13:27 2005
From: jmanson at cs.purdue.edu (Jeremy Manson)
Date: Mon Sep 19 11:13:43 2005
Subject: [concurrency-interest] binary semaphore
In-Reply-To: <432EB522.9040501@ncl.ac.uk>
References: <432EB522.9040501@ncl.ac.uk>
Message-ID: <432ED597.7080307@cs.purdue.edu>

Michele Mazzucco wrote:

> 
> How can I implement a binary semaphore in a bounded buffer environment, 
> say of capacity of one element (the binary semaphore has the property  - 
> unlike many Lock implementations - that the "lock" can be released by a 
> thread other than the owner), without using synchronized methods and 
> wait() and notify()/notifyAll() calls?


A Semaphore can basically keeps a count on how many items are in the 
bounded buffer.  You initialize the Semaphore with a number of permits 
equal to the bound.  Then, every time you call an add method, you 
acquire a permit, which blocks until a permit is available.  Once all of 
the permits are acquired, you have hit the bound on your buffer, and any 
further adds will block.  Similarly, every time you do a remove, you 
release a permit.

It looks more-or-less like this:

Semaphore s;

public MyBuffer() {
   s = new Semaphore(1); // or whatever your bound is
}

public void add(Object o) {
   s.acquire();
   // add object to collection
}

public Object remove(Object o) {
   // remove object from collection
   s.release();
}

Note that to do this correctly, access to the collection object still 
needs to be synchronized.  That can be hidden, though, if you use a 
synchronized wrapper class.

					Jeremy
From dholmes at dltech.com.au  Mon Sep 19 19:31:09 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Mon Sep 19 19:31:32 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <432EA2C4.40400@it-huset.se>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEJKGDAA.dholmes@dltech.com.au>

Stefan,

As of Java 5 the new Java Memory Model gives very precise semantics to
volatile and you are indeed guaranteed certain behaviour - it is not an
artefact of an implementation.

The JMM guarantees that a write of a volatile variable happens-before a read
of that variable that sees the written value. This means that if Thread-X
does:

  Global.R = new B();

and Thread-Y reads Gobal.R and finds the reference to the B object, then it
is guaranteed to see everything that occurred in Thread-X prior to the
assignment to Global.R ie all the construction actions.

David Holmes


> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of
> Stefan Skoglund
> Sent: Monday, 19 September 2005 9:37 PM
> To: Yechiel Feffer
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] a question about concurrent
> safe access
>
>
> Theoretically, I guess you could get a dirty reference if you used a
> volatile reference. Consider the two treads X and Y. And consider
> volatile reference R pointing to A, seen by both threads. If X creates
> object B and lets R point to B, then Y would see reference R point to
> where B should reside. But since no memory synchronization is guarantied
> to have occurred. except the volatile reference. it would be possible
> that Y sees a dirty reference.
>
> However as I understand, the current implementation of volatile reads
> and writes, does perform full blown memory synchronization between two
> threads, exchanging information through a volatile reference. So the
> dirty reference would never appear. I'm not sure one should rely the
> fullblown memory synchronization though.
>
> I guess one of the experts could verify this.
>
> yours
> /Stefan
>
>
> Yechiel Feffer wrote:
>
> > Hi all
> > say I have a pointer ( reference) to an object ( A). This reference is
> > changed to point at object B. I have threads that concurrently are
> > using that reference to get the object it points at. I dont want to
> > synchronize the usage of the reference. Is it safe to do so, i.e. if I
> > dont use a lock and I dont declare the reference volatile will I
> > always get object A or B or do I have a risk of getting "dirty"
> > inconsistent pointer , i.e. is assigning a pointer always atomic  ?
> >
> > Regrds,
> > Yechiel
> >
> >------------------------------------------------------------------------
> >
> >_______________________________________________
> >Concurrency-interest mailing list
> >Concurrency-interest@altair.cs.oswego.edu
> >http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From p.veentjer at anchormen.nl  Tue Sep 20 03:19:56 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Tue Sep 20 03:20:22 2005
Subject: [concurrency-interest] a question about concurrent safe access
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07123A@gerard.anchormen.nl>

 
But what can happen if a field is used in a multithreaded environment
and it isn`t synchronized or volatile. Could you get some serious
vm-errors (or totally unacceptable behaviour of the program)? Or just an
old reference?

-----Oorspronkelijk bericht-----
Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens David Holmes
Verzonden: dinsdag 20 september 2005 1:31
Aan: Stefan Skoglund
CC: concurrency-interest@altair.cs.oswego.edu
Onderwerp: RE: [concurrency-interest] a question about concurrent safe
access

Stefan,

As of Java 5 the new Java Memory Model gives very precise semantics to
volatile and you are indeed guaranteed certain behaviour - it is not an
artefact of an implementation.

The JMM guarantees that a write of a volatile variable happens-before a
read of that variable that sees the written value. This means that if
Thread-X
does:

  Global.R = new B();

and Thread-Y reads Gobal.R and finds the reference to the B object, then
it is guaranteed to see everything that occurred in Thread-X prior to
the assignment to Global.R ie all the construction actions.

David Holmes


> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Stefan

> Skoglund
> Sent: Monday, 19 September 2005 9:37 PM
> To: Yechiel Feffer
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] a question about concurrent safe 
> access
>
>
> Theoretically, I guess you could get a dirty reference if you used a 
> volatile reference. Consider the two treads X and Y. And consider 
> volatile reference R pointing to A, seen by both threads. If X creates

> object B and lets R point to B, then Y would see reference R point to 
> where B should reside. But since no memory synchronization is 
> guarantied to have occurred. except the volatile reference. it would 
> be possible that Y sees a dirty reference.
>
> However as I understand, the current implementation of volatile reads 
> and writes, does perform full blown memory synchronization between two

> threads, exchanging information through a volatile reference. So the 
> dirty reference would never appear. I'm not sure one should rely the 
> fullblown memory synchronization though.
>
> I guess one of the experts could verify this.
>
> yours
> /Stefan
>
>
> Yechiel Feffer wrote:
>
> > Hi all
> > say I have a pointer ( reference) to an object ( A). This reference 
> > is changed to point at object B. I have threads that concurrently 
> > are using that reference to get the object it points at. I dont want

> > to synchronize the usage of the reference. Is it safe to do so, i.e.

> > if I dont use a lock and I dont declare the reference volatile will 
> > I always get object A or B or do I have a risk of getting "dirty"
> > inconsistent pointer , i.e. is assigning a pointer always atomic  ?
> >
> > Regrds,
> > Yechiel
> >
> >---------------------------------------------------------------------
> >---
> >
> >_______________________________________________
> >Concurrency-interest mailing list
> >Concurrency-interest@altair.cs.oswego.edu
> >http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Tue Sep 20 04:06:25 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue Sep 20 04:06:41 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07123A@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07123A@gerard.anchormen.nl>
Message-ID: <31f2a7bd050920010610731f00@mail.gmail.com>

On 9/20/05, Peter Veentjer - Anchor Men <p.veentjer@anchormen.nl> wrote:
> 
> But what can happen if a field is used in a multithreaded environment
> and it isn`t synchronized or volatile. Could you get some serious
> vm-errors (or totally unacceptable behaviour of the program)? Or just an
> old reference?
> 

The answer is C: Just an old reference

Your thread must see a live reference (or null) written by some thread
-- but it might not see the most recent value written.

From richard.beton at roke.co.uk  Tue Sep 20 05:16:30 2005
From: richard.beton at roke.co.uk (Rick Beton)
Date: Tue Sep 20 05:17:15 2005
Subject: [concurrency-interest] unit testing concurrency code.
In-Reply-To: <431DE31B.1020907@quiotix.com>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07CA2E@gerard.anchormen.nl>
	<431DE31B.1020907@quiotix.com>
Message-ID: <432FD36E.1040402@roke.co.uk>

Brian Goetz wrote:

 > Testing concurrent code is an extension of testing regular code.  
 > First, you must have good tests for functionality, and be able to test
 > as many of your classes invariants as possible.  The trick is then
 > trying to generate as many random interleavings of operations as you
 > can, without the test framework introducing timing artifacts that will
 > prevent certain interleavings from being tested.


Surely this overlooks something: there are four kinds of dynamic failure
(deadlock, livelock, starvation and race) that you cannot prove are
absent simply by testing alone.  You can prove they are *present* if
your testing finds them, but you can't prove they are *absent*.

This is quite important if you are writing concurrency classes for other
people to use.  You cannot write tests with enough coverage to handle
every end-user's use cases.  Simply covering a certain subset of dynamic
behaviour and then passing such classes as "tested" may be a bit too
optimistic and misleading.

I'd like to draw your attention to Peter Welch's posting ("CSP, the
pi-calculus and CPA-2005") and the work he and others have done using
CSP as the basis for establishing thread reliability (establishing the
absence of deadlock, livelock, starvation and race).  My own experience
is limited to being a JCSP user, rather than having much theoretical
skill.  There are some straightforward design rules that guarantee
deadlock freedom for example.  This makes JCSP a simple strategy to
apply to practical usage.

Regards,
Rick









-- 

Visit our website at www.roke.co.uk

Roke Manor Research Ltd, Roke Manor, Romsey, Hampshire SO51 0ZN, UK.

The information contained in this e-mail and any attachments is proprietary to
Roke Manor Research Ltd and must not be passed to any third party without
permission. This communication is for information only and shall not create or
change any contractual relationship.

From brian at quiotix.com  Tue Sep 20 10:48:16 2005
From: brian at quiotix.com (Brian Goetz)
Date: Tue Sep 20 10:48:34 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <31f2a7bd050920010610731f00@mail.gmail.com>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07123A@gerard.anchormen.nl>
	<31f2a7bd050920010610731f00@mail.gmail.com>
Message-ID: <43302130.7060809@quiotix.com>

>>But what can happen if a field is used in a multithreaded environment
>>and it isn`t synchronized or volatile. Could you get some serious
>>vm-errors (or totally unacceptable behaviour of the program)? Or just an
>>old reference?
> 
> The answer is C: Just an old reference

More precisely:

You can get an old or new reference to the object being referenced.  But 
in the event you see the new reference, the state _of that referenced 
object_ may still be garbage unless that object it itself immutable or 
thread-safe.

From larryr at saturn.sdsu.edu  Tue Sep 20 12:29:14 2005
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Tue Sep 20 12:29:35 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <43302130.7060809@quiotix.com>
Message-ID: <20050920162914.9137.qmail@home19.riedel.org>


> > But what can happen if a field is used in a multithreaded
> > environment and it isn`t synchronized or volatile. Could
> > you get some serious vm-errors (or totally unacceptable
> > behaviour of the program)? Or just an old reference?
>
> [...]
>
> You can get an old or new reference to the object being
> referenced.  But in the event you see the new reference, the
> state _of that referenced object_ may still be garbage unless
> that object it itself immutable or thread-safe.

A different kind of garbage from when an object which is not
thread-safe may in general violate its "invariants" when used
concurrently by multiple threads?


Larry

From gnu_andrew at member.fsf.org  Tue Sep 20 13:49:33 2005
From: gnu_andrew at member.fsf.org (Andrew John Hughes)
Date: Tue Sep 20 13:50:11 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
In-Reply-To: <4328A8E9.3010905@cs.oswego.edu>
References: <1126730832.28949.75.camel@localhost.localdomain>
	<4328A8E9.3010905@cs.oswego.edu>
Message-ID: <1127238573.504.6.camel@localhost.localdomain>

On Wed, 2005-09-14 at 18:49 -0400, Doug Lea wrote:
> Andrew John Hughes wrote:
> > 
> > 
> > We would be grateful if you could clarify this with us, so as to avoid
> > any later confusion.
> > 
> 
> 
> There's a simple, universally valid rule you can use for JSR166 files
> as they appear in CVS:
> For any file of interest, do "head -5 <filename>".
> It will either clearly say that it is released to the public domain or
> it won't. Nearly all are.
> 
> But especially during release integration, our CVS contains not only
> files originated by us, but also other files that are modified by us.
> We do this to make sure that everything goes into a release exactly
> right, which is more important to us than maintaining license purity.
> 
> This rule is better than an enumeration, since the actual files
> might change over time.
> 
> (BTW, our diffs to files not originated by us are also
> released to the public domain, but they might not be
> very useful.)
> 
> -Doug
> 
> 
> 
> 
> 

Thanks for your help.  With regard to including the code in GNU
Classpath, we'd like to use java.util.concurrent code provided by you as
an upstream provider.  Ideally, this would thus be based on some kind of
stable release point, rather than a random CVS snapshot.  Is such a
thing available, specifically a version which forms the basis of the 1.5
release (i.e. without the unstable 1.6 additions which are now appearing
in the repository).  Is such a thing available, or would it be possible
to make this available for use as an upstream provider for Classpath?

Also, I note that the code, as-is, use some internal Sun classes
(notably in the atomic classes).  Is there some documentation available
which specifies what these external methods are expected to provide?

Thanks,
-- 
Andrew :)

Please avoid sending me Microsoft Office (e.g. Word, PowerPoint)
attachments.
See http://www.fsf.org/philosophy/no-word-attachments.html

"Value your freedom, or you will lose it, teaches history.
`Don't bother us with politics' respond those who don't want to learn."
-- Richard Stallman

Escape the Java Trap with GNU Classpath!
http://www.gnu.org/philosophy/java-trap.html
public class gcj extends Freedom implements Java { ... }

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : /pipermail/attachments/20050920/c1ec1ff3/attachment.bin
From dl at cs.oswego.edu  Tue Sep 20 15:55:54 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue Sep 20 15:57:31 2005
Subject: [concurrency-interest] JSR166+backport: Licensing Issues
In-Reply-To: <1127238573.504.6.camel@localhost.localdomain>
References: <1126730832.28949.75.camel@localhost.localdomain>	
	<4328A8E9.3010905@cs.oswego.edu>
	<1127238573.504.6.camel@localhost.localdomain>
Message-ID: <4330694A.5020105@cs.oswego.edu>

Andrew John Hughes wrote:
>  
> Thanks for your help.  With regard to including the code in GNU
> Classpath, we'd like to use java.util.concurrent code provided by you as
> an upstream provider.  Ideally, this would thus be based on some kind of
> stable release point, rather than a random CVS snapshot. 

There are CVS tags (like "JSR166_PFD") at release points.
But you are better off getting more recent versions, that
contain fixes. (There were three "serious" bugs in
initial Tiger release, but you might as well get others.)
And in fact, we are very near stable Mustang/JSE6 freeze,
so in a month or so, there will be very few changes for
a while, and then none at all for a longer while.

> 
> Also, I note that the code, as-is, use some internal Sun classes
> (notably in the atomic classes).  Is there some documentation available
> which specifies what these external methods are expected to provide?
> 

The only internal class used is "sun.misc.Unsafe". This (poorly
named) class should be familiar to all JVM implementors, since it
contains "intrinsics" underlying various JSRs that require
bytecode-like VM support in the era where people don't dare add byte
codes. Someday this class should undergo JCP standardization, but
different JVM providers seem to want to retain some flexibility about
it, so it probably still premature to standardize. I believe that
JikesRVM for example contains overlapping methods but in a differently 
named class. For simplicity, I believe that all the commercial JVMs
contain supersets of the Sun version. Implementation of this class
requires tight coupling with a JVM -- intrinsics are things
the look like methods, but act like bytecodes.

-Doug
From dholmes at dltech.com.au  Tue Sep 20 18:58:24 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Tue Sep 20 18:58:46 2005
Subject: [concurrency-interest] a question about concurrent safe access
In-Reply-To: <20050920162914.9137.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEKNGDAA.dholmes@dltech.com.au>

> A different kind of garbage from when an object which is not
> thread-safe may in general violate its "invariants" when used
> concurrently by multiple threads?

The same kind of "garbage". You will never see a value that was never
written to a field (with the exception of long and doubles).

David Holmes

From chris.burnley at gmail.com  Thu Sep 22 06:09:26 2005
From: chris.burnley at gmail.com (Chris Burnley)
Date: Thu Sep 22 06:09:43 2005
Subject: [concurrency-interest] Critique my class ?
Message-ID: <76205f0b050922030942d2347c@mail.gmail.com>

I have a use case where I've got several client threads that write to a
FileChannel but I must guarantee that the file gets synced for each client.
A file sync could take up to 40ms depending on the size of the file. To get
around this I want to buffer up the clients so I only have to do the sync
once every, say 50ms, thus drastically improving the throughput at the cost
of a little latency.

Question : is there something already available that would help me do this
sort of thing ? I thought maybe a cyclicbarrier but somehow it didn't fit (
I'm not concerned with the number of clients waiting but rather the time
elapsed since last sync)

Otherwise, can anybody see anything wrong with the following implementation
? (I've called it Switch for want of a better term).


class Switch {

private Lock lock = new ReentrantLock();

private Condition condition = lock.newCondition();

private boolean waiters;
private Exception failure;

/**
* Lock, but only if there are waiters.
* @return if the lock was acquired.
*/
public boolean lockIfWaiters() {
lock.lock();
failure = null;
if (!waiters) {
lock.unlock();
return false;
}
return true;
}

/**
* Unlock the switch and notify all those that have been waiting.
*/
public void unlockAndSignalAll() {
waiters = false;
condition.signalAll();
lock.unlock();
}

/**
* Indicate to waiters that the operation has failed.
*
*/
public void signalFailure(Exception cause){
this.failure = cause;
unlockAndSignalAll();
}

/**
* Used by waiters on the switch.
* @throws InterruptedException
*/
public void await() throws InterruptedException, WaitFailureException{
lock.lock();
try {
waiters = true;
condition.await();
if(failure != null)
throw new WaitFailureException(failure);
} finally {
lock.unlock();
}
}
}

The clients call this method after they've written to the channel:


protected void force() throws SyncFailedException {
try {
swtch.await();
} catch (InterruptedException e) {
throw new SyncFailedException(e.toString());
} catch (WaitFailureException e) {
throw new SyncFailedException(e.toString());
}
}



and I have a scheduled task that does the actual file sync:

class FileSyncer implements Runnable {

public void run() {
while (swtch.lockIfWaiters()) {
try {
fileChannel.force(false);
swtch.unlockAndSignalAll();
} catch (Exception e){
// error logging omitted
swtch.signalFalure(e);
}
}
}
}

regards,

Chris Burnley
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/5c2d2773/attachment.htm
From p.veentjer at anchormen.nl  Thu Sep 22 07:16:52 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Thu Sep 22 07:17:31 2005
Subject: [concurrency-interest] Critique my class ?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07123C@gerard.anchormen.nl>

 
Would it not be an idea the store all the requests for every thread in
the queue and periodically flush that queue? Now clients don`t have to
block untill they can write information to the channel.You can use a
bounded BlockingQueue to prevent that there are to many requests and you
can use a ScheduledExecutor to schedule a runnable for the flusing task.


 
________________________________

Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Chris Burnley
Verzonden: donderdag 22 september 2005 12:09
Aan: concurrency-interest@altair.cs.oswego.edu
Onderwerp: [concurrency-interest] Critique my class ?


I have a use case where I've got several client threads that write to a
FileChannel but I must guarantee that the file gets synced for each
client. A file sync could take up to 40ms depending on the size of the
file. To get around this I want to buffer up the clients so I only have
to do the sync once every, say 50ms, thus drastically improving the
throughput at the cost of a little latency.

Question : is there something already available that would help me do
this sort of thing ? I thought maybe a cyclicbarrier but somehow it
didn't fit ( I'm not concerned with the number of clients waiting but
rather the time elapsed since last sync)

Otherwise, can anybody see anything wrong with the following
implementation ? (I've called it Switch for want of a better term). 


class Switch {

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    private boolean waiters;
    private Exception failure;
    
    /**
     * Lock, but only if there are waiters.
     * @return if the lock was acquired.
     */
    public boolean lockIfWaiters() {
        lock.lock();
        failure = null;
        if (!waiters) {
            lock.unlock();
            return false;
        }
        return true;
    }

    /**
     * Unlock the switch and notify all those that have been waiting.
     */
    public void unlockAndSignalAll() {
        waiters = false;
        condition.signalAll();
        lock.unlock();
    }
    
    /**
     * Indicate to waiters that the operation has failed.
     *
     */
    public void signalFailure(Exception cause){
        this.failure = cause;
        unlockAndSignalAll();
    }

    /**
     * Used by waiters on the switch. 
     * @throws InterruptedException
     */
    public void await() throws InterruptedException,
WaitFailureException{
        lock.lock();
        try {
            waiters = true;
            condition.await();
            if(failure != null)
                throw new WaitFailureException(failure);
        } finally {
            lock.unlock();
        }
    }
}

The clients call this method after they've written to the channel:


    protected void force() throws SyncFailedException {
        try {
            swtch.await();
        } catch (InterruptedException e) {
            throw new SyncFailedException(e.toString());
        } catch (WaitFailureException e) {
            throw new SyncFailedException(e.toString());        
        }
    }



and I have a scheduled task that does the actual file sync:

    class FileSyncer implements Runnable {

        public void run() {
            while (swtch.lockIfWaiters()) {
                try {
                    fileChannel.force(false);
                    swtch.unlockAndSignalAll();
                } catch (Exception e){
                    // error logging omitted
                    swtch.signalFalure(e);
                }
            }
        }
    }

regards, 

Chris Burnley

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/dfcb9666/attachment.htm
From p.veentjer at anchormen.nl  Thu Sep 22 07:28:33 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Thu Sep 22 07:28:58 2005
Subject: [concurrency-interest] Critique my class ?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07123D@gerard.anchormen.nl>

And you could use a Future of you realy need to wait for the result of
the execution. 

________________________________

Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Peter
Veentjer - Anchor Men
Verzonden: donderdag 22 september 2005 13:17
Aan: Chris Burnley; concurrency-interest@altair.cs.oswego.edu
Onderwerp: RE: [concurrency-interest] Critique my class ?


 
Would it not be an idea the store all the requests for every thread in
the queue and periodically flush that queue? Now clients don`t have to
block untill they can write information to the channel.You can use a
bounded BlockingQueue to prevent that there are to many requests and you
can use a ScheduledExecutor to schedule a runnable for the flusing task.


 
________________________________

Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Chris Burnley
Verzonden: donderdag 22 september 2005 12:09
Aan: concurrency-interest@altair.cs.oswego.edu
Onderwerp: [concurrency-interest] Critique my class ?


I have a use case where I've got several client threads that write to a
FileChannel but I must guarantee that the file gets synced for each
client. A file sync could take up to 40ms depending on the size of the
file. To get around this I want to buffer up the clients so I only have
to do the sync once every, say 50ms, thus drastically improving the
throughput at the cost of a little latency.

Question : is there something already available that would help me do
this sort of thing ? I thought maybe a cyclicbarrier but somehow it
didn't fit ( I'm not concerned with the number of clients waiting but
rather the time elapsed since last sync)

Otherwise, can anybody see anything wrong with the following
implementation ? (I've called it Switch for want of a better term). 


class Switch {

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    private boolean waiters;
    private Exception failure;
    
    /**
     * Lock, but only if there are waiters.
     * @return if the lock was acquired.
     */
    public boolean lockIfWaiters() {
        lock.lock();
        failure = null;
        if (!waiters) {
            lock.unlock();
            return false;
        }
        return true;
    }

    /**
     * Unlock the switch and notify all those that have been waiting.
     */
    public void unlockAndSignalAll() {
        waiters = false;
        condition.signalAll();
        lock.unlock();
    }
    
    /**
     * Indicate to waiters that the operation has failed.
     *
     */
    public void signalFailure(Exception cause){
        this.failure = cause;
        unlockAndSignalAll();
    }

    /**
     * Used by waiters on the switch. 
     * @throws InterruptedException
     */
    public void await() throws InterruptedException,
WaitFailureException{
        lock.lock();
        try {
            waiters = true;
            condition.await();
            if(failure != null)
                throw new WaitFailureException(failure);
        } finally {
            lock.unlock();
        }
    }
}

The clients call this method after they've written to the channel:


    protected void force() throws SyncFailedException {
        try {
            swtch.await();
        } catch (InterruptedException e) {
            throw new SyncFailedException(e.toString());
        } catch (WaitFailureException e) {
            throw new SyncFailedException(e.toString());        
        }
    }



and I have a scheduled task that does the actual file sync:

    class FileSyncer implements Runnable {

        public void run() {
            while (swtch.lockIfWaiters()) {
                try {
                    fileChannel.force(false);
                    swtch.unlockAndSignalAll();
                } catch (Exception e){
                    // error logging omitted
                    swtch.signalFalure(e);
                }
            }
        }
    }

regards, 

Chris Burnley

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/1957bb8f/attachment-0001.htm
From chris.burnley at gmail.com  Thu Sep 22 08:11:54 2005
From: chris.burnley at gmail.com (Chris Burnley)
Date: Thu Sep 22 08:12:10 2005
Subject: [concurrency-interest] Critique my class ?
In-Reply-To: <24CFCE44DCB015489FB96D38BDF4FCAA07123D@gerard.anchormen.nl>
References: <24CFCE44DCB015489FB96D38BDF4FCAA07123D@gerard.anchormen.nl>
Message-ID: <76205f0b05092205116c6a23df@mail.gmail.com>

The whole point is that it is a XA database so each request must be
gauranteed that the sync has occurred and therfore will block. however, new
waiters that began waiting after the sync was started must not be notified
with the group of requests that began waiting before the sync was started.

On 9/22/05, Peter Veentjer - Anchor Men <p.veentjer@anchormen.nl> wrote:
>
> And you could use a Future of you realy need to wait for the result of the
> execution.
>
>  ------------------------------
> *Van:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu] *Namens *Peter Veentjer -
> Anchor Men
> *Verzonden:* donderdag 22 september 2005 13:17
> *Aan:* Chris Burnley; concurrency-interest@altair.cs.oswego.edu
> *Onderwerp:* RE: [concurrency-interest] Critique my class ?
>
>   Would it not be an idea the store all the requests for every thread in
> the queue and periodically flush that queue? Now clients don`t have to block
> untill they can write information to the channel.You can use a bounded
> BlockingQueue to prevent that there are to many requests and you can use a
> ScheduledExecutor to schedule a runnable for the flusing task.
>
>  ------------------------------
> *Van:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu] *Namens *Chris Burnley
> *Verzonden:* donderdag 22 september 2005 12:09
> *Aan:* concurrency-interest@altair.cs.oswego.edu
> *Onderwerp:* [concurrency-interest] Critique my class ?
>
> I have a use case where I've got several client threads that write to a
> FileChannel but I must guarantee that the file gets synced for each client.
> A file sync could take up to 40ms depending on the size of the file. To get
> around this I want to buffer up the clients so I only have to do the sync
> once every, say 50ms, thus drastically improving the throughput at the cost
> of a little latency.
>
> Question : is there something already available that would help me do this
> sort of thing ? I thought maybe a cyclicbarrier but somehow it didn't fit (
> I'm not concerned with the number of clients waiting but rather the time
> elapsed since last sync)
>
> Otherwise, can anybody see anything wrong with the following
> implementation ? (I've called it Switch for want of a better term).
>
>
> class Switch {
>
> private Lock lock = new ReentrantLock();
>
> private Condition condition = lock.newCondition();
>
> private boolean waiters;
> private Exception failure;
>
> /**
> * Lock, but only if there are waiters.
> * @return if the lock was acquired.
> */
> public boolean lockIfWaiters() {
> lock.lock();
> failure = null;
> if (!waiters) {
> lock.unlock();
> return false;
> }
> return true;
> }
>
> /**
> * Unlock the switch and notify all those that have been waiting.
> */
> public void unlockAndSignalAll() {
> waiters = false;
> condition.signalAll();
> lock.unlock();
> }
>
> /**
> * Indicate to waiters that the operation has failed.
> *
> */
> public void signalFailure(Exception cause){
> this.failure = cause;
> unlockAndSignalAll();
> }
>
> /**
> * Used by waiters on the switch.
> * @throws InterruptedException
> */
> public void await() throws InterruptedException, WaitFailureException{
> lock.lock();
> try {
> waiters = true;
> condition.await();
> if(failure != null)
> throw new WaitFailureException(failure);
> } finally {
> lock.unlock();
> }
> }
> }
>
> The clients call this method after they've written to the channel:
>
>
> protected void force() throws SyncFailedException {
> try {
> swtch.await();
> } catch (InterruptedException e) {
> throw new SyncFailedException(e.toString());
> } catch (WaitFailureException e) {
> throw new SyncFailedException(e.toString());
> }
> }
>
>
>
> and I have a scheduled task that does the actual file sync:
>
> class FileSyncer implements Runnable {
>
> public void run() {
> while (swtch.lockIfWaiters()) {
> try {
> fileChannel.force(false);
> swtch.unlockAndSignalAll();
> } catch (Exception e){
> // error logging omitted
> swtch.signalFalure(e);
> }
> }
> }
> }
>
> regards,
>
> Chris Burnley
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/fe1fcda3/attachment.htm
From p.veentjer at anchormen.nl  Thu Sep 22 09:44:47 2005
From: p.veentjer at anchormen.nl (Peter Veentjer - Anchor Men)
Date: Thu Sep 22 09:45:17 2005
Subject: [concurrency-interest] Critique my class ?
Message-ID: <24CFCE44DCB015489FB96D38BDF4FCAA07123E@gerard.anchormen.nl>

I have made an example of what I mean:
 
interface ChannelCommand{
 void run(Channel channel);
}
 

class ChannelCommandWriter{
 
 private ScheduledExecutorService _executor = new
ThreadPoolExecutorService();
 private BLockingQueue<FutureTask> _futureQueue = new
LinkedBlockingQueue<FutureTask>();
 private Channel _channel = ...;
 
 public ChanneldCommandWriter(){
  _executor.scheduleAtFixedDelay(new
FlushRunnable(),0,50,TimeUnit.MILISECONDS);
 }
 
 public Future execute(final ChannelCommand command){
  Runnable r = new Runnable(){
   void run(){
    command.run(_channel);
   }   
  }; 
 
  FutureTask<Object> ftask = new FutureTask<Object>(r, null);
  _futureQueue.add(ftask);
  return ftask;         
 }
 
 private class FlushRunnable implements Runnable{
  public void run(){
   List<Future> futureList = new LinkedList<Future>();
   _futureQueue.draintTo(futureList);
   
   for(Future future: futureList){
    future.run();
   } 
  }
 }
}
 
 
 
And now you can use it asynchronous:
 
ChannelCommandWriter writer = new ChannelCommandWriter();
writer.execute(someChannelCommand);
 
or synchronous:
 
ChannelCommandWriter writer = new ChannelCommandWriter();
Future future = writer.execute(someChannelCommand);
future.get();//wait untill the execution completed.


________________________________

Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Chris Burnley
Verzonden: donderdag 22 september 2005 14:12
Aan: concurrency-interest@altair.cs.oswego.edu
Onderwerp: Re: [concurrency-interest] Critique my class ?


The whole point is that it is a XA database so each request must be
gauranteed that the sync has occurred and therfore will block. however,
new waiters that began waiting after the sync was started must not be
notified with the group of requests that began waiting before the sync
was started.


On 9/22/05, Peter Veentjer - Anchor Men <p.veentjer@anchormen.nl> wrote:


	And you could use a Future of you realy need to wait for the
result of the execution. 

________________________________

	Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Peter
Veentjer - Anchor Men
	Verzonden: donderdag 22 september 2005 13:17
	Aan: Chris Burnley; concurrency-interest@altair.cs.oswego.edu
	Onderwerp: RE: [concurrency-interest] Critique my class ?
	
	
	
	 
	Would it not be an idea the store all the requests for every
thread in the queue and periodically flush that queue? Now clients don`t
have to block untill they can write information to the channel.You can
use a bounded BlockingQueue to prevent that there are to many requests
and you can use a ScheduledExecutor to schedule a runnable for the
flusing task. 
	
	 
________________________________

	Van: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu] Namens Chris Burnley
	Verzonden: donderdag 22 september 2005 12:09
	Aan: concurrency-interest@altair.cs.oswego.edu
	Onderwerp: [concurrency-interest] Critique my class ?
	
	
	I have a use case where I've got several client threads that
write to a FileChannel but I must guarantee that the file gets synced
for each client. A file sync could take up to 40ms depending on the size
of the file. To get around this I want to buffer up the clients so I
only have to do the sync once every, say 50ms, thus drastically
improving the throughput at the cost of a little latency.
	
	Question : is there something already available that would help
me do this sort of thing ? I thought maybe a cyclicbarrier but somehow
it didn't fit ( I'm not concerned with the number of clients waiting but
rather the time elapsed since last sync)
	
	Otherwise, can anybody see anything wrong with the following
implementation ? (I've called it Switch for want of a better term). 
	
	
	class Switch {
	
	    private Lock lock = new ReentrantLock();
	
	    private Condition condition = lock.newCondition();
	
	    private boolean waiters;
	    private Exception failure;
	    
	    /**
	     * Lock, but only if there are waiters.
	     * @return if the lock was acquired.
	     */
	    public boolean lockIfWaiters() {
	        lock.lock();
	        failure = null;
	        if (!waiters) {
	            lock.unlock();
	            return false;
	        }
	        return true;
	    }
	
	    /**
	     * Unlock the switch and notify all those that have been
waiting.
	     */
	    public void unlockAndSignalAll() {
	        waiters = false;
	        condition.signalAll();
	        lock.unlock();
	    }
	    
	    /**
	     * Indicate to waiters that the operation has failed.
	     *
	     */
	    public void signalFailure(Exception cause){
	        this.failure = cause;
	        unlockAndSignalAll();
	    }
	
	    /**
	     * Used by waiters on the switch. 
	     * @throws InterruptedException
	     */
	    public void await() throws InterruptedException,
WaitFailureException{
	        lock.lock();
	        try {
	            waiters = true;
	            condition.await();
	            if(failure != null)
	                throw new WaitFailureException(failure);
	        } finally {
	            lock.unlock();
	        }
	    }
	}
	
	The clients call this method after they've written to the
channel:
	
	
	    protected void force() throws SyncFailedException {
	        try {
	            swtch.await();
	        } catch (InterruptedException e) {
	            throw new SyncFailedException(e.toString());
	        } catch (WaitFailureException e) {
	            throw new SyncFailedException(e.toString());        
	        }
	    }
	
	
	
	and I have a scheduled task that does the actual file sync:
	
	    class FileSyncer implements Runnable {
	
	        public void run() {
	            while (swtch.lockIfWaiters()) {
	                try {
	                    fileChannel.force(false);
	                    swtch.unlockAndSignalAll();
	                } catch (Exception e){
	                    // error logging omitted
	                    swtch.signalFalure(e);
	                }
	            }
	        }
	    }
	
	regards, 
	
	Chris Burnley
	

	_______________________________________________
	Concurrency-interest mailing list
	Concurrency-interest@altair.cs.oswego.edu 
	
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest 
	
	
	


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/ecfd3fc3/attachment-0001.htm
From tim at peierls.net  Thu Sep 22 15:44:27 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Sep 22 15:44:52 2005
Subject: [concurrency-interest] Critique my class ?
In-Reply-To: <76205f0b050922030942d2347c@mail.gmail.com>
References: <76205f0b050922030942d2347c@mail.gmail.com>
Message-ID: <4333099B.2070307@peierls.net>

Chris Burnley wrote:
> I have a use case where I've got several client threads that write to a 
> FileChannel but I must guarantee that the file gets synced for each 
> client. A file sync could take up to 40ms depending on the size of the 
> file. To get around this I want to buffer up the clients so I only have 
> to do the sync once every, say 50ms, thus drastically improving the 
> throughput at the cost of a little latency.
> 
> Question : is there something already available that would help me do 
> this sort of thing ? I thought maybe a cyclicbarrier but somehow it 
> didn't fit ( I'm not concerned with the number of clients waiting but 
> rather the time elapsed since last sync)
> 
> Otherwise, can anybody see anything wrong with the following 
> implementation ? (I've called it Switch for want of a better term).


Looks pretty reasonable. I made some specific comments below.

A nice way to package this would be to extend FileChannel to delegate to a "real" FileChannel, 
with force(boolean) overridden to work like Switch.force() in your code. Then the 
ScheduledExecutorService that runs FileSyncer periodically could be encapsulated inside the 
FileChannel implementation. Clients would just call the usual force method (you'd have to find a 
way to communicate the need for a file metadata refresh to the Switch) and catch a custom 
SyncFailedException that extends IOException.

If you do this, then there's no need to provide Switch on its own.



>     private Lock lock = new ReentrantLock();
>     private Condition condition = lock.newCondition();

Make these final. Two fewer things to worry about.


>     private boolean waiters;
>     private Exception failure;

Any particular reason not to keep a count of waiters? Might be useful for debugging, and might 
allow a small optimization if the count is 1.

   private int waiters;

And won't you want to catch Throwable in await(), not just Exception? If your call to 
FileChannel.force(false) throws OutOfMemoryError, aren't the awaiters going to want to know that?

   private Throwable failure;

You should document that waiters and failure (the mutable state of Switch) are guarded by lock. 
Simplifies reasoning for others who read the code.


>     /**
>      * Lock, but only if there are waiters.
>      * @return if the lock was acquired.
>      */
>     public boolean lockIfWaiters() {
>         lock.lock();
>         failure = null;
>         if (!waiters) {
>             lock.unlock();
>             return false;
>         }
>         return true;
>     }

Feels safer to have try-finally in anything that does a lock-unlock, even though I suppose it 
doesn't make any difference in this case. But this way you can see clearly that waiters and 
failure are accessed only with the lock held.

   boolean acquire = false;
   lock.lock();
   try {
       failure = null;
       acquire = waiters > 0;
       return acquire;
   } finally {
       if (!acquire) lock.unlock();
   }



>     public void unlockAndSignalAll() {

Document the precondition that lock is held by this thread.

>         waiters = false;
>         condition.signalAll();
>         lock.unlock();
>     }

       waiters = 0;


>     public void signalFailure(Exception cause){

Document the precondition that lock is held by this thread.

   public void signalFailure(Throwable cause){


>     public void await() throws InterruptedException,  WaitFailureException{
>         lock.lock();
>         try {
>             waiters = true;

   ++waiters;

>             condition.await();

Always call await() in a while loop! You could have a spurious wakeup; you need a condition 
predicate to decide whether the return from await is for real. In this case, the condition for 
continuing is "no waiters".

               while (waiters > 0) condition.await();

>             if(failure != null)
>                 throw new WaitFailureException(failure);
>         } finally {
>             lock.unlock();
>         }
>     }
> }


>     protected void force() throws SyncFailedException {
>         try {
>             swtch.await();
>         } catch (InterruptedException e) {
>             throw new SyncFailedException(e.toString());

If the *client* is interrupted you have two choices: propagate the InterruptedException or restore 
the interrupted status. In this case, since a client that calls force knows that it could block 
for a while, propagating is better:

      protected void force() throws InterruptedException, SyncFailedException {

and remove the InterruptedException catch clause.


>         } catch (WaitFailureException e) {
>             throw new SyncFailedException(e.toString());       

If you don't have to flatten the failure into string, don't. How about:

   throw new SyncFailedException(e.getCause());

That's assuming SyncFailedException is a class you control.


>     class FileSyncer implements Runnable {
>         public void run() {
>             while (swtch.lockIfWaiters()) {
>                 try {
>                     fileChannel.force(false);
>                     swtch.unlockAndSignalAll();
>                 } catch (Exception e){
>                     // error logging omitted
>                     swtch.signalFailure(e);
>                 }
>             }
>         }
>     }

Do you necessarily want to keep looping on signalFailure? There's a chance that blocked waiters 
will be able to do something with the knowledge that the sync failed, like cancel any further 
attempts. Maybe lockIfWaiters could test the failure field and throw immediately if not null. 
You'd have to provide a clear failure method to allow things to proceed again.

--tim

From chris.burnley at gmail.com  Thu Sep 22 16:36:02 2005
From: chris.burnley at gmail.com (Chris Burnley)
Date: Thu Sep 22 16:36:19 2005
Subject: [concurrency-interest] Critique my class ?
In-Reply-To: <4333099B.2070307@peierls.net>
References: <76205f0b050922030942d2347c@mail.gmail.com>
	<4333099B.2070307@peierls.net>
Message-ID: <76205f0b050922133672378bd5@mail.gmail.com>

Thanks Tim for your really well thought out critism. I'll take your
suggestions on board. This is the sort of stuff I was after to try and make
it solid.

I've actually got a class called ObjectFile which contains the FileChannel,
this is where the force() method lives ( although I didn't make that clear
because I didn't think it mattered).

This FileSyncer is an inner class (mainly becuase I didn't want to expose
run() to clients) of ObjectFile started up by the ExecutorService.

The reason I've got the loop in FileSyncer in there is that I seemed to get
higher throughput by reducing the schedule rate to about 100ms, and
increasing the effictive rate scheduling rate by using the loop , this also
has the effect of reducing the mean latency of clients. I'll have to
experiment on what effects this has on other resources, otherwise I might go
back to a if statement.

Thanks again,

Chris

On 9/22/05, Tim Peierls <tim@peierls.net> wrote:
>
> Chris Burnley wrote:
> > I have a use case where I've got several client threads that write to a
> > FileChannel but I must guarantee that the file gets synced for each
> > client. A file sync could take up to 40ms depending on the size of the
> > file. To get around this I want to buffer up the clients so I only have
> > to do the sync once every, say 50ms, thus drastically improving the
> > throughput at the cost of a little latency.
> >
> > Question : is there something already available that would help me do
> > this sort of thing ? I thought maybe a cyclicbarrier but somehow it
> > didn't fit ( I'm not concerned with the number of clients waiting but
> > rather the time elapsed since last sync)
> >
> > Otherwise, can anybody see anything wrong with the following
> > implementation ? (I've called it Switch for want of a better term).
>
>
> Looks pretty reasonable. I made some specific comments below.
>
> A nice way to package this would be to extend FileChannel to delegate to a
> "real" FileChannel,
> with force(boolean) overridden to work like Switch.force() in your code.
> Then the
> ScheduledExecutorService that runs FileSyncer periodically could be
> encapsulated inside the
> FileChannel implementation. Clients would just call the usual force method
> (you'd have to find a
> way to communicate the need for a file metadata refresh to the Switch) and
> catch a custom
> SyncFailedException that extends IOException.
>
> If you do this, then there's no need to provide Switch on its own.
>
>
>
> > private Lock lock = new ReentrantLock();
> > private Condition condition = lock.newCondition();
>
> Make these final. Two fewer things to worry about.
>
>
> > private boolean waiters;
> > private Exception failure;
>
> Any particular reason not to keep a count of waiters? Might be useful for
> debugging, and might
> allow a small optimization if the count is 1.
>
> private int waiters;
>
> And won't you want to catch Throwable in await(), not just Exception? If
> your call to
> FileChannel.force(false) throws OutOfMemoryError, aren't the awaiters
> going to want to know that?
>
> private Throwable failure;
>
> You should document that waiters and failure (the mutable state of Switch)
> are guarded by lock.
> Simplifies reasoning for others who read the code.
>
>
> > /**
> > * Lock, but only if there are waiters.
> > * @return if the lock was acquired.
> > */
> > public boolean lockIfWaiters() {
> > lock.lock();
> > failure = null;
> > if (!waiters) {
> > lock.unlock();
> > return false;
> > }
> > return true;
> > }
>
> Feels safer to have try-finally in anything that does a lock-unlock, even
> though I suppose it
> doesn't make any difference in this case. But this way you can see clearly
> that waiters and
> failure are accessed only with the lock held.
>
> boolean acquire = false;
> lock.lock();
> try {
> failure = null;
> acquire = waiters > 0;
> return acquire;
> } finally {
> if (!acquire) lock.unlock();
> }
>
>
>
> > public void unlockAndSignalAll() {
>
> Document the precondition that lock is held by this thread.
>
> > waiters = false;
> > condition.signalAll();
> > lock.unlock();
> > }
>
> waiters = 0;
>
>
> > public void signalFailure(Exception cause){
>
> Document the precondition that lock is held by this thread.
>
> public void signalFailure(Throwable cause){
>
>
> > public void await() throws InterruptedException, WaitFailureException{
> > lock.lock();
> > try {
> > waiters = true;
>
> ++waiters;
>
> > condition.await();
>
> Always call await() in a while loop! You could have a spurious wakeup; you
> need a condition
> predicate to decide whether the return from await is for real. In this
> case, the condition for
> continuing is "no waiters".
>
> while (waiters > 0) condition.await();
>
> > if(failure != null)
> > throw new WaitFailureException(failure);
> > } finally {
> > lock.unlock();
> > }
> > }
> > }
>
>
> > protected void force() throws SyncFailedException {
> > try {
> > swtch.await();
> > } catch (InterruptedException e) {
> > throw new SyncFailedException(e.toString());
>
> If the *client* is interrupted you have two choices: propagate the
> InterruptedException or restore
> the interrupted status. In this case, since a client that calls force
> knows that it could block
> for a while, propagating is better:
>
> protected void force() throws InterruptedException, SyncFailedException {
>
> and remove the InterruptedException catch clause.
>
>
> > } catch (WaitFailureException e) {
> > throw new SyncFailedException(e.toString());
>
> If you don't have to flatten the failure into string, don't. How about:
>
> throw new SyncFailedException(e.getCause());
>
> That's assuming SyncFailedException is a class you control.
>
>
> > class FileSyncer implements Runnable {
> > public void run() {
> > while (swtch.lockIfWaiters()) {
> > try {
> > fileChannel.force(false);
> > swtch.unlockAndSignalAll();
> > } catch (Exception e){
> > // error logging omitted
> > swtch.signalFailure(e);
> > }
> > }
> > }
> > }
>
> Do you necessarily want to keep looping on signalFailure? There's a chance
> that blocked waiters
> will be able to do something with the knowledge that the sync failed, like
> cancel any further
> attempts. Maybe lockIfWaiters could test the failure field and throw
> immediately if not null.
> You'd have to provide a clear failure method to allow things to proceed
> again.
>
> --tim
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050922/3b885951/attachment.htm
From gregg at cytetech.com  Thu Sep 22 17:13:18 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu Sep 22 17:13:32 2005
Subject: [concurrency-interest] Critique my class ?
In-Reply-To: <4333099B.2070307@peierls.net>
References: <76205f0b050922030942d2347c@mail.gmail.com>
	<4333099B.2070307@peierls.net>
Message-ID: <43331E6E.6080406@cytetech.com>



Tim Peierls wrote:
> Chris Burnley wrote:
>      protected void force() throws InterruptedException, 
> SyncFailedException {
> 
> and remove the InterruptedException catch clause.
> 
> 
>>         } catch (WaitFailureException e) {
>>             throw new SyncFailedException(e.toString());       
> 
> 
> If you don't have to flatten the failure into string, don't. How about:
> 
>   throw new SyncFailedException(e.getCause());

The ugly pattern that I always use is to create the wrapper exception with the message from the thrown exception that I 
caught, and then call initCause() with the caught exception.

	throw (SyncFailedException)new SyncFailedException(e.toString()).initCause(e);

This gets a little long to type.  A standard annotation would be nice for this pattern.

Gregg Wonderly
From hanson.char at gmail.com  Fri Sep 23 01:19:19 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Fri Sep 23 01:19:35 2005
Subject: [concurrency-interest] Thread safe or not ?
Message-ID: <ca53c8f805092222196745866b@mail.gmail.com>

Assuming JDK5, is the following code always thread safe when
SystemParameter.K is concurrently accessed ? If so, is the synchronization
used in the code minimal ? If not, why not ?

Thanks in advance.

Hanson

public class SystemParameter {
private static volatile SystemParameterBean bean = init();
public static final long K = bean.getK();
static {
bean = null; // hint to GC
}
private static SystemParameterBean init() {
// This part can be replaced by accessing an IoC framework
// such as Spring to retrieve an externally configured
// SystemParameterBean instance.
SystemParameterBean bean = new SystemParameterBean();
bean.setK(20);
return bean;
}
}

public class SystemParameterBean {
private long k;

public long getK() {
return k;
}
public void setK(long k) {
this.k = k;
}
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/8894daca/attachment-0001.htm
From dholmes at dltech.com.au  Fri Sep 23 01:35:10 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Fri Sep 23 01:35:31 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <ca53c8f805092222196745866b@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>

Hanson,

SystemParameter.K is a static final long value that is initialized during
static initialization from a newly constructed - and hence otherwise
inaccessible - object. So as it stands it is always threadsafe to access it,
as static initialization is itself threadsafe.

I don't know why the bean variable is volatile if it is only accessed during
static initialization. So it may not be minimal synchronization.

However the comment:
        // This part can be replaced by accessing an IoC framework
        // such as Spring to retrieve an externally configured
        // SystemParameterBean instance.

is not correct. If you use an externally configured bean object to
initialize K then you need to be guaranteed that that beans k field has been
correctly set and may not be concurrently set while being read from getK. As
these are long values then atomicity of reads/writes does not apply and you
may read a garbage value.

Hope that helps.

David Holmes

  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Hanson Char
  Sent: Friday, 23 September 2005 3:19 PM
  To: concurrency-interest@altair.cs.oswego.edu
  Subject: [concurrency-interest] Thread safe or not ?


  Assuming JDK5, is the following code always thread safe when
SystemParameter.K is concurrently accessed  ?  If so, is the synchronization
used in the code minimal ?  If not, why not ?

  Thanks in advance.

  Hanson

  public class SystemParameter {
      private static volatile SystemParameterBean bean = init();
      public static final long K = bean.getK();
      static {
          bean = null;    // hint to GC
      }
      private static SystemParameterBean init() {
          // This part can be replaced by accessing an IoC framework
          // such as Spring to retrieve an externally configured
          // SystemParameterBean instance.
          SystemParameterBean bean = new SystemParameterBean();
          bean.setK(20);
          return bean;
      }
  }

  public class SystemParameterBean {
      private long k;

      public long getK() {
          return k;
      }
      public void setK(long k) {
          this.k = k;
      }
  }

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/223de60f/attachment.htm
From hanson.char at gmail.com  Fri Sep 23 01:57:04 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Fri Sep 23 01:57:23 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>
References: <ca53c8f805092222196745866b@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>
Message-ID: <ca53c8f805092222576011b1ad@mail.gmail.com>

I see, so the amended code below is both thread-safe and minimal, and
hopefully with the correct comment.

Hanson

public class SystemParameter {
private static SystemParameterBean bean = init();
public static final long K = bean.getK();
static {
bean = null; // hint to GC
}
private static SystemParameterBean init() {
// This part can be replaced by accessing an IoC framework
// such as Spring to retrieve an externally configured
// SystemParameterBean instance, as long as such
// instance is constructed and accessed by only 1 thread
// (ie not concurrently.)
SystemParameterBean bean = new SystemParameterBean();
bean.setK(20);
return bean;
}
}

public class SystemParameterBean {
private long k;

public long getK() {
return k;
}
public void setK(long k) {
this.k = k;
}
}



On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
>
> Hanson,
>  SystemParameter.K is a static final long value that is initialized during
> static initialization from a newly constructed - and hence otherwise
> inaccessible - object. So as it stands it is always threadsafe to access it,
> as static initialization is itself threadsafe.
>  I don't know why the bean variable is volatile if it is only accessed
> during static initialization. So it may not be minimal synchronization.
>  However the comment:
>  // This part can be replaced by accessing an IoC framework
> // such as Spring to retrieve an externally configured
> // SystemParameterBean instance.
> is not correct. If you use an externally configured bean object to
> initialize K then you need to be guaranteed that that beans k field has been
> correctly set and may not be concurrently set while being read from getK. As
> these are long values then atomicity of reads/writes does not apply and you
> may read a garbage value.
>  Hope that helps.
>  David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu]*On Behalf Of *Hanson Char
> *Sent:* Friday, 23 September 2005 3:19 PM
> *To:* concurrency-interest@altair.cs.oswego.edu
> *Subject:* [concurrency-interest] Thread safe or not ?
>
> Assuming JDK5, is the following code always thread safe when
> SystemParameter.K is concurrently accessed ? If so, is the synchronization
> used in the code minimal ? If not, why not ?
>
> Thanks in advance.
>
> Hanson
>
> public class SystemParameter {
> private static volatile SystemParameterBean bean = init();
> public static final long K = bean.getK();
> static {
> bean = null; // hint to GC
> }
> private static SystemParameterBean init() {
> // This part can be replaced by accessing an IoC framework
> // such as Spring to retrieve an externally configured
> // SystemParameterBean instance.
> SystemParameterBean bean = new SystemParameterBean();
> bean.setK(20);
> return bean;
> }
> }
>
> public class SystemParameterBean {
> private long k;
>
> public long getK() {
> return k;
> }
> public void setK(long k) {
> this.k = k;
> }
> }
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/73ebd32d/attachment.htm
From hanson.char at gmail.com  Fri Sep 23 02:08:20 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Fri Sep 23 02:08:37 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <ca53c8f805092222576011b1ad@mail.gmail.com>
References: <ca53c8f805092222196745866b@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>
	<ca53c8f805092222576011b1ad@mail.gmail.com>
Message-ID: <ca53c8f805092223086ad290ef@mail.gmail.com>

Or more generally,
...
 // This part can be replaced by accessing an IoC framework
// such as Spring to retrieve an externally configured
// SystemParameterBean instance, as long as such
// instance is constructed and accessed in a thread safe manner.
...

Hanson

On 9/23/05, Hanson Char <hanson.char@gmail.com> wrote:
>
> I see, so the amended code below is both thread-safe and minimal, and
> hopefully with the correct comment.
>
> Hanson
>
> public class SystemParameter {
> private static SystemParameterBean bean = init();
> public static final long K = bean.getK();
> static {
> bean = null; // hint to GC
> }
> private static SystemParameterBean init() {
> // This part can be replaced by accessing an IoC framework
> // such as Spring to retrieve an externally configured
> // SystemParameterBean instance, as long as such
> // instance is constructed and accessed by only 1 thread
> // (ie not concurrently.)
> SystemParameterBean bean = new SystemParameterBean();
> bean.setK(20);
> return bean;
> }
> }
>
> public class SystemParameterBean {
> private long k;
>
> public long getK() {
> return k;
> }
> public void setK(long k) {
> this.k = k;
> }
> }
>
>
>
> On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
> >
> > Hanson,
> >  SystemParameter.K is a static final long value that is initialized
> > during static initialization from a newly constructed - and hence otherwise
> > inaccessible - object. So as it stands it is always threadsafe to access it,
> > as static initialization is itself threadsafe.
> >  I don't know why the bean variable is volatile if it is only accessed
> > during static initialization. So it may not be minimal synchronization.
> >  However the comment:
> >  // This part can be replaced by accessing an IoC framework
> > // such as Spring to retrieve an externally configured
> > // SystemParameterBean instance.
> > is not correct. If you use an externally configured bean object to
> > initialize K then you need to be guaranteed that that beans k field has been
> > correctly set and may not be concurrently set while being read from getK. As
> > these are long values then atomicity of reads/writes does not apply and you
> > may read a garbage value.
> >  Hope that helps.
> >  David Holmes
> >
> > -----Original Message-----
> > *From:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> > concurrency-interest-bounces@cs.oswego.edu]*On Behalf Of *Hanson Char
> > *Sent:* Friday, 23 September 2005 3:19 PM
> > *To:* concurrency-interest@altair.cs.oswego.edu
> > *Subject:* [concurrency-interest] Thread safe or not ?
> >
> > Assuming JDK5, is the following code always thread safe when
> > SystemParameter.K is concurrently accessed ? If so, is the
> > synchronization used in the code minimal ? If not, why not ?
> >
> > Thanks in advance.
> >
> > Hanson
> >
> > public class SystemParameter {
> > private static volatile SystemParameterBean bean = init();
> > public static final long K = bean.getK();
> > static {
> > bean = null; // hint to GC
> > }
> > private static SystemParameterBean init() {
> > // This part can be replaced by accessing an IoC framework
> > // such as Spring to retrieve an externally configured
> > // SystemParameterBean instance.
> > SystemParameterBean bean = new SystemParameterBean();
> > bean.setK(20);
> > return bean;
> > }
> > }
> >
> > public class SystemParameterBean {
> > private long k;
> >
> > public long getK() {
> > return k;
> > }
> > public void setK(long k) {
> > this.k = k;
> > }
> > }
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/4deac173/attachment-0001.htm
From joe.bowbeer at gmail.com  Fri Sep 23 03:03:38 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri Sep 23 03:04:00 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <ca53c8f805092222576011b1ad@mail.gmail.com>
References: <ca53c8f805092222196745866b@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>
	<ca53c8f805092222576011b1ad@mail.gmail.com>
Message-ID: <31f2a7bd05092300036b24b2e7@mail.gmail.com>

I guess I'm missing the point but GC hints always make me suspicious.

Can you assign K in the static initializer?  That would be more streamlined:

public class SystemParameter {
    public static final long K;
    static {
        SystemParameterBean bean = init();
        K = bean.getK();
    }
    // ...

On 9/22/05, Hanson Char <hanson.char@gmail.com> wrote:
> I see, so the amended code below is both thread-safe and minimal, and
> hopefully with the correct comment.
>
>  Hanson
>
>  public class SystemParameter {
>      private static SystemParameterBean bean = init();
>      public static final long K = bean.getK();
>      static {
>          bean = null;    // hint to GC
>      }
>      private static SystemParameterBean init() {
>          // This part can be replaced by accessing an IoC framework
>          // such as Spring to retrieve an externally configured
>          // SystemParameterBean instance, as long as such
>          // instance is constructed and accessed by only 1 thread
>          // (ie not concurrently.)
>          SystemParameterBean bean = new SystemParameterBean();
>          bean.setK(20);
>          return bean;
>      }
>  }
>
>  public class SystemParameterBean {
>      private long k;
>
>      public long getK() {
>          return k;
>      }
>      public void setK(long k) {
>          this.k = k;
>      }
>  }
>
>
> On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
> >
> > Hanson,
> >
> > SystemParameter.K is a static final long value that is initialized during
> static initialization from a newly constructed - and hence otherwise
> inaccessible - object. So as it stands it is always threadsafe to access it,
> as static initialization is itself threadsafe.
> >
> > I don't know why the bean variable is volatile if it is only accessed
> during static initialization. So it may not be minimal synchronization.
> >
> > However the comment:
> >         // This part can be replaced by accessing an IoC framework
> >         // such as Spring to retrieve an externally configured
> >         // SystemParameterBean instance.
> >
> > is not correct. If you use an externally configured bean object to
> initialize K then you need to be guaranteed that that beans k field has been
> correctly set and may not be concurrently set while being read from getK. As
> these are long values then atomicity of reads/writes does not apply and you
> may read a garbage value.
> >
> > Hope that helps.
> >
> > David Holmes
> >
> >
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> Behalf Of Hanson Char
> > Sent: Friday, 23 September 2005 3:19 PM
> > To: concurrency-interest@altair.cs.oswego.edu
> > Subject: [concurrency-interest] Thread safe or not ?
> >
> > Assuming JDK5, is the following code always thread safe when
> SystemParameter.K is concurrently accessed  ?  If so, is the synchronization
> used in the code minimal ?  If not, why not ?
> >
> > Thanks in advance.
> >
> > Hanson
> >
> > public class SystemParameter {
> >     private static volatile SystemParameterBean bean = init();
> >     public static final long K = bean.getK();
> >     static {
> >         bean = null;    // hint to GC
> >     }
> >     private static SystemParameterBean init() {
> >         // This part can be replaced by accessing an IoC framework
> >         // such as Spring to retrieve an externally configured
> >         // SystemParameterBean instance.
> >         SystemParameterBean bean = new SystemParameterBean();
> >         bean.setK(20);
> >         return bean;
> >     }
> > }
> >
> > public class SystemParameterBean {
> >     private long k;
> >
> >     public long getK() {
> >         return k;
> >     }
> >     public void setK(long k) {
> >         this.k = k;
> >     }
> > }
> >
> >
>

From hanson.char at gmail.com  Fri Sep 23 03:23:57 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Fri Sep 23 03:24:15 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <31f2a7bd05092300036b24b2e7@mail.gmail.com>
References: <ca53c8f805092222196745866b@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEPAGDAA.dholmes@dltech.com.au>
	<ca53c8f805092222576011b1ad@mail.gmail.com>
	<31f2a7bd05092300036b24b2e7@mail.gmail.com>
Message-ID: <ca53c8f8050923002368fa1db2@mail.gmail.com>

I agree. That's more streamlined. Thanks!

Hanson

On 9/23/05, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
>
> I guess I'm missing the point but GC hints always make me suspicious.
>
> Can you assign K in the static initializer? That would be more
> streamlined:
>
> public class SystemParameter {
> public static final long K;
> static {
> SystemParameterBean bean = init();
> K = bean.getK();
> }
> // ...
>
> On 9/22/05, Hanson Char <hanson.char@gmail.com> wrote:
> > I see, so the amended code below is both thread-safe and minimal, and
> > hopefully with the correct comment.
> >
> > Hanson
> >
> > public class SystemParameter {
> > private static SystemParameterBean bean = init();
> > public static final long K = bean.getK();
> > static {
> > bean = null; // hint to GC
> > }
> > private static SystemParameterBean init() {
> > // This part can be replaced by accessing an IoC framework
> > // such as Spring to retrieve an externally configured
> > // SystemParameterBean instance, as long as such
> > // instance is constructed and accessed by only 1 thread
> > // (ie not concurrently.)
> > SystemParameterBean bean = new SystemParameterBean();
> > bean.setK(20);
> > return bean;
> > }
> > }
> >
> > public class SystemParameterBean {
> > private long k;
> >
> > public long getK() {
> > return k;
> > }
> > public void setK(long k) {
> > this.k = k;
> > }
> > }
> >
> >
> > On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
> > >
> > > Hanson,
> > >
> > > SystemParameter.K is a static final long value that is initialized
> during
> > static initialization from a newly constructed - and hence otherwise
> > inaccessible - object. So as it stands it is always threadsafe to access
> it,
> > as static initialization is itself threadsafe.
> > >
> > > I don't know why the bean variable is volatile if it is only accessed
> > during static initialization. So it may not be minimal synchronization.
> > >
> > > However the comment:
> > > // This part can be replaced by accessing an IoC framework
> > > // such as Spring to retrieve an externally configured
> > > // SystemParameterBean instance.
> > >
> > > is not correct. If you use an externally configured bean object to
> > initialize K then you need to be guaranteed that that beans k field has
> been
> > correctly set and may not be concurrently set while being read from
> getK. As
> > these are long values then atomicity of reads/writes does not apply and
> you
> > may read a garbage value.
> > >
> > > Hope that helps.
> > >
> > > David Holmes
> > >
> > >
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces@cs.oswego.edu
> > [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> > Behalf Of Hanson Char
> > > Sent: Friday, 23 September 2005 3:19 PM
> > > To: concurrency-interest@altair.cs.oswego.edu
> > > Subject: [concurrency-interest] Thread safe or not ?
> > >
> > > Assuming JDK5, is the following code always thread safe when
> > SystemParameter.K is concurrently accessed ? If so, is the
> synchronization
> > used in the code minimal ? If not, why not ?
> > >
> > > Thanks in advance.
> > >
> > > Hanson
> > >
> > > public class SystemParameter {
> > > private static volatile SystemParameterBean bean = init();
> > > public static final long K = bean.getK();
> > > static {
> > > bean = null; // hint to GC
> > > }
> > > private static SystemParameterBean init() {
> > > // This part can be replaced by accessing an IoC framework
> > > // such as Spring to retrieve an externally configured
> > > // SystemParameterBean instance.
> > > SystemParameterBean bean = new SystemParameterBean();
> > > bean.setK(20);
> > > return bean;
> > > }
> > > }
> > >
> > > public class SystemParameterBean {
> > > private long k;
> > >
> > > public long getK() {
> > > return k;
> > > }
> > > public void setK(long k) {
> > > this.k = k;
> > > }
> > > }
> > >
> > >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/1a4d8848/attachment.htm
From bnewport at us.ibm.com  Fri Sep 23 06:44:25 2005
From: bnewport at us.ibm.com (Billy Newport)
Date: Fri Sep 23 06:44:47 2005
Subject: [concurrency-interest] Billy Newport/Rochester/IBM is out of the
	office.
Message-ID: <OFE97E2B37.05720F9F-ON86257085.003AFFC1-86257085.003AFFC2@us.ibm.com>

I will be out of the office starting  09/23/2005 and will not return until
09/29/2005.

I have no or very limited access to email. Please try my cell but I'll have
infrequent access to that also.

From dholmes at dltech.com.au  Fri Sep 23 08:10:13 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Fri Sep 23 08:10:39 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <ca53c8f805092223086ad290ef@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPHGDAA.dholmes@dltech.com.au>

Right.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Hanson Char
  Sent: Friday, 23 September 2005 4:08 PM
  To: David Holmes
  Cc: concurrency-interest@altair.cs.oswego.edu
  Subject: Re: [concurrency-interest] Thread safe or not ?


  Or more generally,
  ...
          // This part can be replaced by accessing an IoC framework
          // such as Spring to retrieve an externally configured
          // SystemParameterBean instance, as long as such
          // instance is constructed and accessed in a thread safe manner.
  ...

  Hanson


  On 9/23/05, Hanson Char <hanson.char@gmail.com> wrote:
    I see, so the amended code below is both thread-safe and minimal, and
hopefully with the correct comment.

    Hanson

    public class SystemParameter {
        private static SystemParameterBean bean = init();
        public static final long K = bean.getK();
        static {
            bean = null;    // hint to GC
        }
        private static SystemParameterBean init() {
            // This part can be replaced by accessing an IoC framework
            // such as Spring to retrieve an externally configured
            // SystemParameterBean instance, as long as such
            // instance is constructed and accessed by only 1 thread
            // (ie not concurrently.)
            SystemParameterBean bean = new SystemParameterBean();
            bean.setK(20);
            return bean;
        }
    }

    public class SystemParameterBean {
        private long k;

        public long getK() {
            return k;
        }
        public void setK(long k) {
            this.k = k;
        }
    }




    On 9/23/05, David Holmes < dholmes@dltech.com.au> wrote:
      Hanson,

      SystemParameter.K is a static final long value that is initialized
during static initialization from a newly constructed - and hence otherwise
inaccessible - object. So as it stands it is always threadsafe to access it,
as static initialization is itself threadsafe.

      I don't know why the bean variable is volatile if it is only accessed
during static initialization. So it may not be minimal synchronization.

      However the comment:
              // This part can be replaced by accessing an IoC framework
              // such as Spring to retrieve an externally configured
              // SystemParameterBean instance.

      is not correct. If you use an externally configured bean object to
initialize K then you need to be guaranteed that that beans k field has been
correctly set and may not be concurrently set while being read from getK. As
these are long values then atomicity of reads/writes does not apply and you
may read a garbage value.

      Hope that helps.

      David Holmes

        -----Original Message-----
        From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Hanson Char
        Sent: Friday, 23 September 2005 3:19 PM
        To: concurrency-interest@altair.cs.oswego.edu
        Subject: [concurrency-interest] Thread safe or not ?


        Assuming JDK5, is the following code always thread safe when
SystemParameter.K is concurrently accessed  ?  If so, is the synchronization
used in the code minimal ?  If not, why not ?

        Thanks in advance.

        Hanson

        public class SystemParameter {
            private static volatile SystemParameterBean bean = init();
            public static final long K = bean.getK();
            static {
                bean = null;    // hint to GC
            }
            private static SystemParameterBean init() {
                // This part can be replaced by accessing an IoC framework
                // such as Spring to retrieve an externally configured
                // SystemParameterBean instance.
                SystemParameterBean bean = new SystemParameterBean();
                bean.setK(20);
                return bean;
            }
        }

        public class SystemParameterBean {
            private long k;

            public long getK() {
                return k;
            }
            public void setK(long k) {
                this.k = k;
            }
        }





-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/1fdafff8/attachment-0001.htm
From dholmes at dltech.com.au  Fri Sep 23 08:10:25 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Fri Sep 23 08:10:50 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <ca53c8f8050923002368fa1db2@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEPHGDAA.dholmes@dltech.com.au>

I had presumed the code was an outline of something more elaborate and it
was the "pattern" of initialization that was significant - otherwise it can
be reduced to:

public static final long K = 20;

or if obtained from the "external" bean:

public static final long K = getExternalBean().getK();

there's no need to keep a reference to the bean. :)

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces@cs.oswego.edu
[mailto:concurrency-interest-bounces@cs.oswego.edu]On Behalf Of Hanson Char
  Sent: Friday, 23 September 2005 5:24 PM
  To: Joe Bowbeer
  Cc: concurrency-interest@altair.cs.oswego.edu
  Subject: Re: [concurrency-interest] Thread safe or not ?


  I agree.  That's more streamlined.  Thanks!

  Hanson


  On 9/23/05, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
    I guess I'm missing the point but GC hints always make me suspicious.

    Can you assign K in the static initializer?  That would be more
streamlined:

    public class SystemParameter {
        public static final long K;
        static {
            SystemParameterBean bean = init();
            K = bean.getK();
        }
        // ...

    On 9/22/05, Hanson Char <hanson.char@gmail.com> wrote:
    > I see, so the amended code below is both thread-safe and minimal, and
    > hopefully with the correct comment.
    >
    >  Hanson
    >
    >  public class SystemParameter {
    >      private static SystemParameterBean bean = init();
    >      public static final long K = bean.getK();
    >      static {
    >          bean = null;    // hint to GC
    >      }
    >      private static SystemParameterBean init() {
    >          // This part can be replaced by accessing an IoC framework
    >          // such as Spring to retrieve an externally configured
    >          // SystemParameterBean instance, as long as such
    >          // instance is constructed and accessed by only 1 thread
    >          // (ie not concurrently.)
    >          SystemParameterBean bean = new SystemParameterBean();
    >          bean.setK(20);
    >          return bean;
    >      }
    >  }
    >
    >  public class SystemParameterBean {
    >      private long k;
    >
    >      public long getK() {
    >          return k;
    >      }
    >      public void setK(long k) {
    >          this.k = k;
    >      }
    >  }
    >
    >
    > On 9/23/05, David Holmes < dholmes@dltech.com.au> wrote:
    > >
    > > Hanson,
    > >
    > > SystemParameter.K is a static final long value that is initialized
during
    > static initialization from a newly constructed - and hence otherwise
    > inaccessible - object. So as it stands it is always threadsafe to
access it,
    > as static initialization is itself threadsafe.
    > >
    > > I don't know why the bean variable is volatile if it is only
accessed
    > during static initialization. So it may not be minimal
synchronization.
    > >
    > > However the comment:
    > >         // This part can be replaced by accessing an IoC framework
    > >         // such as Spring to retrieve an externally configured
    > >         // SystemParameterBean instance.
    > >
    > > is not correct. If you use an externally configured bean object to
    > initialize K then you need to be guaranteed that that beans k field
has been
    > correctly set and may not be concurrently set while being read from
getK. As
    > these are long values then atomicity of reads/writes does not apply
and you
    > may read a garbage value.
    > >
    > > Hope that helps.
    > >
    > > David Holmes
    > >
    > >
    > >
    > > -----Original Message-----
    > > From: concurrency-interest-bounces@cs.oswego.edu
    > [mailto:concurrency-interest-bounces@cs.oswego.edu]On
    > Behalf Of Hanson Char
    > > Sent: Friday, 23 September 2005 3:19 PM
    > > To: concurrency-interest@altair.cs.oswego.edu
    > > Subject: [concurrency-interest] Thread safe or not ?
    > >
    > > Assuming JDK5, is the following code always thread safe when
    > SystemParameter.K is concurrently accessed  ?  If so, is the
synchronization
    > used in the code minimal ?  If not, why not ?
    > >
    > > Thanks in advance.
    > >
    > > Hanson
    > >
    > > public class SystemParameter {
    > >     private static volatile SystemParameterBean bean = init();
    > >     public static final long K = bean.getK();
    > >     static {
    > >         bean = null;    // hint to GC
    > >     }
    > >     private static SystemParameterBean init() {
    > >         // This part can be replaced by accessing an IoC framework
    > >         // such as Spring to retrieve an externally configured
    > >         // SystemParameterBean instance.
    > >         SystemParameterBean bean = new SystemParameterBean();
    > >         bean.setK(20);
    > >         return bean;
    > >     }
    > > }
    > >
    > > public class SystemParameterBean {
    > >     private long k;
    > >
    > >     public long getK() {
    > >         return k;
    > >     }
    > >     public void setK(long k) {
    > >         this.k = k;
    > >     }
    > > }
    > >
    > >
    >

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest@altair.cs.oswego.edu
    http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/5f0511d7/attachment.htm
From hanson.char at gmail.com  Fri Sep 23 09:13:20 2005
From: hanson.char at gmail.com (Hanson Char)
Date: Fri Sep 23 09:13:36 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEPHGDAA.dholmes@dltech.com.au>
References: <ca53c8f8050923002368fa1db2@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEPHGDAA.dholmes@dltech.com.au>
Message-ID: <ca53c8f805092306131d0ad9b3@mail.gmail.com>

That's exactly right - very astute observation as usual. It's an outline of
a pattern for initializing, in a thread-safe manner, multiple final static
constants via (optionally) some wiring of external configuration.

Clients of the final static constants don't need to worry about the external
configuration. The wiring framework (such as Spring) doesn't need to concern
about the external configuration actually ends up in a bunch of static final
constants.

In the trivial example I gave there is only one static final constant, K.
However, imagine we have multiple system constants. A SystemParameterBean
instance can be initialized once, and can then be used to initialize all the
static final constants in SystemParameter, which are then accessed by
clients in a simple way. Like SystemParameter.K, SystemParameter.J, etc.

In such multiple-constant scenario, we can avoid init().getK() and
init().getJ(), etc. but simply bean.getK() and bean.getJ(). The init()
method implementation, which may incur additional overheads, should be done
only once and not linear to the number of system constants.

For the lack of a better name, maybe we can call this "Static Final Constant
Initialization" pattern ?

Hanson

On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
>
> I had presumed the code was an outline of something more elaborate and it
> was the "pattern" of initialization that was significant - otherwise it can
> be reduced to:
>  public static final long K = 20;
>  or if obtained from the "external" bean:
>  public static final long K = getExternalBean().getK();
>  there's no need to keep a reference to the bean. :)
>  David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces@cs.oswego.edu [mailto:
> concurrency-interest-bounces@cs.oswego.edu]*On Behalf Of *Hanson Char
> *Sent:* Friday, 23 September 2005 5:24 PM
> *To:* Joe Bowbeer
> *Cc:* concurrency-interest@altair.cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Thread safe or not ?
>
> I agree. That's more streamlined. Thanks!
>
> Hanson
>
> On 9/23/05, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
> >
> > I guess I'm missing the point but GC hints always make me suspicious.
> >
> > Can you assign K in the static initializer? That would be more
> > streamlined:
> >
> > public class SystemParameter {
> > public static final long K;
> > static {
> > SystemParameterBean bean = init();
> > K = bean.getK();
> > }
> > // ...
> >
> > On 9/22/05, Hanson Char <hanson.char@gmail.com> wrote:
> > > I see, so the amended code below is both thread-safe and minimal, and
> > > hopefully with the correct comment.
> > >
> > > Hanson
> > >
> > > public class SystemParameter {
> > > private static SystemParameterBean bean = init();
> > > public static final long K = bean.getK();
> > > static {
> > > bean = null; // hint to GC
> > > }
> > > private static SystemParameterBean init() {
> > > // This part can be replaced by accessing an IoC framework
> > > // such as Spring to retrieve an externally configured
> > > // SystemParameterBean instance, as long as such
> > > // instance is constructed and accessed by only 1 thread
> > > // (ie not concurrently.)
> > > SystemParameterBean bean = new SystemParameterBean();
> > > bean.setK(20);
> > > return bean;
> > > }
> > > }
> > >
> > > public class SystemParameterBean {
> > > private long k;
> > >
> > > public long getK() {
> > > return k;
> > > }
> > > public void setK(long k) {
> > > this.k = k;
> > > }
> > > }
> > >
> > >
> > > On 9/23/05, David Holmes < dholmes@dltech.com.au> wrote:
> > > >
> > > > Hanson,
> > > >
> > > > SystemParameter.K is a static final long value that is initialized
> > during
> > > static initialization from a newly constructed - and hence otherwise
> > > inaccessible - object. So as it stands it is always threadsafe to
> > access it,
> > > as static initialization is itself threadsafe.
> > > >
> > > > I don't know why the bean variable is volatile if it is only
> > accessed
> > > during static initialization. So it may not be minimal
> > synchronization.
> > > >
> > > > However the comment:
> > > > // This part can be replaced by accessing an IoC framework
> > > > // such as Spring to retrieve an externally configured
> > > > // SystemParameterBean instance.
> > > >
> > > > is not correct. If you use an externally configured bean object to
> > > initialize K then you need to be guaranteed that that beans k field
> > has been
> > > correctly set and may not be concurrently set while being read from
> > getK. As
> > > these are long values then atomicity of reads/writes does not apply
> > and you
> > > may read a garbage value.
> > > >
> > > > Hope that helps.
> > > >
> > > > David Holmes
> > > >
> > > >
> > > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces@cs.oswego.edu
> > > [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> > > Behalf Of Hanson Char
> > > > Sent: Friday, 23 September 2005 3:19 PM
> > > > To: concurrency-interest@altair.cs.oswego.edu
> > > > Subject: [concurrency-interest] Thread safe or not ?
> > > >
> > > > Assuming JDK5, is the following code always thread safe when
> > > SystemParameter.K is concurrently accessed ? If so, is the
> > synchronization
> > > used in the code minimal ? If not, why not ?
> > > >
> > > > Thanks in advance.
> > > >
> > > > Hanson
> > > >
> > > > public class SystemParameter {
> > > > private static volatile SystemParameterBean bean = init();
> > > > public static final long K = bean.getK();
> > > > static {
> > > > bean = null; // hint to GC
> > > > }
> > > > private static SystemParameterBean init() {
> > > > // This part can be replaced by accessing an IoC framework
> > > > // such as Spring to retrieve an externally configured
> > > > // SystemParameterBean instance.
> > > > SystemParameterBean bean = new SystemParameterBean();
> > > > bean.setK(20);
> > > > return bean;
> > > > }
> > > > }
> > > >
> > > > public class SystemParameterBean {
> > > > private long k;
> > > >
> > > > public long getK() {
> > > > return k;
> > > > }
> > > > public void setK(long k) {
> > > > this.k = k;
> > > > }
> > > > }
> > > >
> > > >
> > >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050923/89900878/attachment-0001.htm
From Olivier.Dupuy at pwgsc.gc.ca  Fri Sep 23 09:53:55 2005
From: Olivier.Dupuy at pwgsc.gc.ca (Olivier Dupuy)
Date: Fri Sep 23 09:54:14 2005
Subject: [concurrency-interest] RE: Thread safe or not ?
Message-ID: <99A8F602A1892340A96A19DFD64E24CD01FB6305@mb-ncr-023.ad.pwgsc-tpsgc.gc.ca>

> > > >
> > > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces@cs.oswego.edu
> > > [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> > > Behalf Of Hanson Char
> > > > Sent: Friday, 23 September 2005 3:19 PM
> > > > To: concurrency-interest@altair.cs.oswego.edu
> > > > Subject: [concurrency-interest] Thread safe or not ?
> > > >
> > > > Assuming JDK5, is the following code always thread safe when
> > > SystemParameter.K is concurrently accessed ? If so, is the
> > synchronization
> > > used in the code minimal ? If not, why not ?
> > > >
> > > > Thanks in advance.
> > > >
> > > > Hanson
> > > >
> > > > public class SystemParameter {
> > > > private static volatile SystemParameterBean bean = init();
> > > > public static final long K = bean.getK();
> > > > static {
> > > > bean = null; // hint to GC
> > > > }
> > > > private static SystemParameterBean init() {
> > > > // This part can be replaced by accessing an IoC framework
> > > > // such as Spring to retrieve an externally configured
> > > > // SystemParameterBean instance.
> > > > SystemParameterBean bean = new SystemParameterBean();
> > > > bean.setK(20);
> > > > return bean;
> > > > }
> > > > }
> > > >
> > > > public class SystemParameterBean {
> > > > private long k;
> > > >
> > > > public long getK() {
> > > > return k;
> > > > }
> > > > public void setK(long k) {
> > > > this.k = k;
> > > > }
> > > > }
> > > >

    > these are long values then atomicity of reads/writes does not apply
and you
    > may read a garbage value.
    > >
    > > Hope that helps.
    > >
    > > David Holmes

Hi,

to add my 2 cents.
Outside of the initialization problem and as mentioned by David,
garbage can be retrieved and synchronization seems required on the getter and setter

from chapter 17.7 pp 579 of the Java language specification book
http://java.sun.com/docs/books/jls/download/langspec-3.0.pdf

17.7 Non-atomic Treatment of double and long
Some implementations may find it convenient to divide a single write action
on a 64-bit long or double value into two write actions on adjacent 32 bit values.
For efficiency's sake, this behavior is implementation specific; Java virtual
machines are free to perform writes to long and double values atomically or in two
parts.
For the purposes of the Java programming language memory model, a single
write to a non-volatile long or double value is treated as two separate writes: one
to each 32-bit half. This can result in a situation where a thread sees the first 32
bits of a 64 bit value from one write, and the second 32 bits from another write.
Writes and reads of volatile long and double values are always atomic. Writes to
and reads of references are always atomic, regardless of whether they are implemented
as 32 or 64 bit values.
VM implementors are encouraged to avoid splitting their 64-bit values where
possible. Programmers are encouraged to declare shared 64-bit values as volatile
or synchronize their programs correctly to avoid possible complications.

Thanks / Merci
Olivier DUPUY

From jason_mehrens at hotmail.com  Fri Sep 23 14:38:35 2005
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Fri Sep 23 14:38:52 2005
Subject: [concurrency-interest] Race condition in
	CopyOnWriteArrayList.equals Bug 6318638
Message-ID: <BAY105-F4254FF424C4DD710920EF083960@phx.gbl>

Won't this bug still carry over to the CopyOnWriteArraySet?  The 
CopyOnWriteArraySet uses the AbstractSet implementation of the of equals 
which calls also calls size and containsAll which could view two different 
snapshots.

Do collections have to make any guarantees on the behavior of input 
Collections being passed into bulk operation methods like equals, 
containsAll, removeAll, etc.?

For example, if a program calls equals on COWArrayList and the parameter is 
another COWArrayList, Vector, synchonizedList() the same type of race still 
exists between size() and ListIterator() on the input Collection (check the 
source code of COWArrayList.equals 1.56). If the input Collection size is 
reduced before or during the traversal of the ListIterator a 
NoSuchElementException or ConcurrentModificationException is thrown from 
equals.
As a user of the API I would consider the ConcurrentModifcationException my 
problem (misuse) but the NoSuchElementException I would consider something 
the COWArrayList would have to hide or prevent.

Regards,

Jason Mehrens


From joe.bowbeer at gmail.com  Fri Sep 23 15:02:31 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri Sep 23 15:02:47 2005
Subject: [concurrency-interest] Thread safe or not ?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEPHGDAA.dholmes@dltech.com.au>
References: <ca53c8f8050923002368fa1db2@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEPHGDAA.dholmes@dltech.com.au>
Message-ID: <31f2a7bd0509231202489c7eca@mail.gmail.com>

On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
>
> I had presumed the code was an outline of something more elaborate and it
> was the "pattern" of initialization that was significant - otherwise it can
> be reduced to:
>
> public static final long K = 20;
>

I was assuming there was some arbitrary amount of initialization
requiring a static block.

But if the bean instance is going to be nulled in the static block
anyway, then clearly all of the initialization can be moved into the
static block, thereby avoiding the confusing (and suspect)
instantiation in a static field and subsequent null assignment in the
static block.


On 9/23/05, David Holmes <dholmes@dltech.com.au> wrote:
>
> I had presumed the code was an outline of something more elaborate and it
> was the "pattern" of initialization that was significant - otherwise it can
> be reduced to:
>
> public static final long K = 20;
>
> or if obtained from the "external" bean:
>
> public static final long K = getExternalBean().getK();
>
> there's no need to keep a reference to the bean. :)
>
> David Holmes
>
> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu
> [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> Behalf Of Hanson Char
> Sent: Friday, 23 September 2005 5:24 PM
> To: Joe Bowbeer
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Thread safe or not ?
>
> I agree.  That's more streamlined.  Thanks!
>
> Hanson
>
>
> On 9/23/05, Joe Bowbeer <joe.bowbeer@gmail.com> wrote:
> > I guess I'm missing the point but GC hints always make me suspicious.
> >
> > Can you assign K in the static initializer?  That would be more
> streamlined:
> >
> > public class SystemParameter {
> >     public static final long K;
> >     static {
> >         SystemParameterBean bean = init();
> >         K = bean.getK();
> >     }
> >     // ...
> >
> > On 9/22/05, Hanson Char <hanson.char@gmail.com> wrote:
> > > I see, so the amended code below is both thread-safe and minimal, and
> > > hopefully with the correct comment.
> > >
> > >  Hanson
> > >
> > >  public class SystemParameter {
> > >      private static SystemParameterBean bean = init();
> > >      public static final long K = bean.getK();
> > >      static {
> > >          bean = null;    // hint to GC
> > >      }
> > >      private static SystemParameterBean init() {
> > >          // This part can be replaced by accessing an IoC framework
> > >          // such as Spring to retrieve an externally configured
> > >          // SystemParameterBean instance, as long as such
> > >          // instance is constructed and accessed by only 1 thread
> > >          // (ie not concurrently.)
> > >          SystemParameterBean bean = new SystemParameterBean();
> > >          bean.setK(20);
> > >          return bean;
> > >      }
> > >  }
> > >
> > >  public class SystemParameterBean {
> > >      private long k;
> > >
> > >      public long getK() {
> > >          return k;
> > >      }
> > >      public void setK(long k) {
> > >          this.k = k;
> > >      }
> > >  }
> > >
> > >
> > > On 9/23/05, David Holmes < dholmes@dltech.com.au> wrote:
> > > >
> > > > Hanson,
> > > >
> > > > SystemParameter.K is a static final long value that is initialized
> during
> > > static initialization from a newly constructed - and hence otherwise
> > > inaccessible - object. So as it stands it is always threadsafe to access
> it,
> > > as static initialization is itself threadsafe.
> > > >
> > > > I don't know why the bean variable is volatile if it is only accessed
> > > during static initialization. So it may not be minimal synchronization.
> > > >
> > > > However the comment:
> > > >         // This part can be replaced by accessing an IoC framework
> > > >         // such as Spring to retrieve an externally configured
> > > >         // SystemParameterBean instance.
> > > >
> > > > is not correct. If you use an externally configured bean object to
> > > initialize K then you need to be guaranteed that that beans k field has
> been
> > > correctly set and may not be concurrently set while being read from
> getK. As
> > > these are long values then atomicity of reads/writes does not apply and
> you
> > > may read a garbage value.
> > > >
> > > > Hope that helps.
> > > >
> > > > David Holmes
> > > >
> > > >
> > > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces@cs.oswego.edu
> > > [mailto:concurrency-interest-bounces@cs.oswego.edu]On
> > > Behalf Of Hanson Char
> > > > Sent: Friday, 23 September 2005 3:19 PM
> > > > To: concurrency-interest@altair.cs.oswego.edu
> > > > Subject: [concurrency-interest] Thread safe or not ?
> > > >
> > > > Assuming JDK5, is the following code always thread safe when
> > > SystemParameter.K is concurrently accessed  ?  If so, is the
> synchronization
> > > used in the code minimal ?  If not, why not ?
> > > >
> > > > Thanks in advance.
> > > >
> > > > Hanson
> > > >
> > > > public class SystemParameter {
> > > >     private static volatile SystemParameterBean bean = init();
> > > >     public static final long K = bean.getK();
> > > >     static {
> > > >         bean = null;    // hint to GC
> > > >     }
> > > >     private static SystemParameterBean init() {
> > > >         // This part can be replaced by accessing an IoC framework
> > > >         // such as Spring to retrieve an externally configured
> > > >         // SystemParameterBean instance.
> > > >         SystemParameterBean bean = new SystemParameterBean();
> > > >         bean.setK(20);
> > > >         return bean;
> > > >     }
> > > > }
> > > >
> > > > public class SystemParameterBean {
> > > >     private long k;
> > > >
> > > >     public long getK() {
> > > >         return k;
> > > >     }
> > > >     public void setK(long k) {
> > > >         this.k = k;
> > > >     }
> > > > }
> > > >

From Martin.Buchholz at Sun.COM  Sat Sep 24 14:30:26 2005
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Sat Sep 24 14:30:43 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <200509241600.j8OG09gT004366@altair.cs.oswego.edu>
References: <200509241600.j8OG09gT004366@altair.cs.oswego.edu>
Message-ID: <43359B42.8060600@Sun.COM>



Jason Mehrens wrote:
> Date: Fri, 23 Sep 2005 13:38:35 -0500
> 
> Won't this bug still carry over to the CopyOnWriteArraySet?  The 
> CopyOnWriteArraySet uses the AbstractSet implementation of the of equals 
> which calls also calls size and containsAll which could view two different 
> snapshots.

When calling equals on collections that may be concurrently mutated,
the answer is just an approximation.

In the case of CopyOnWriteArraySet, it is disturbing
that s.equals(other) might return true even if s and other were *never*
equal, for example if another thread was doing
for (;;) {
  s.clear(); s.add(new Object()); s.add(e);
}
and "other" contained only the one element {e}.
I consider this a bug.

One possible strategy for implementing Set.equals would be
new HashSet(this).equals(new HashSet(other));
which at one stroke eliminates concurrency issues and produces
an expected order N+M algorithm instead of an N*M algorithm.
The only downside is that this will always create garbage
which we would like to avoid for read operations.

> Do collections have to make any guarantees on the behavior of input 
> Collections being passed into bulk operation methods like equals, 
> containsAll, removeAll, etc.?

While reviewing this code it became clear to me that things can go
wrong when the "other" collection is being concurrently modified.
We should probably add some documentation on what the user can
expect in this sort of situation.

There is some conflict here between performance and safety.

> For example, if a program calls equals on COWArrayList and the parameter is 
> another COWArrayList, Vector, synchonizedList() the same type of race still 
> exists between size() and ListIterator() on the input Collection (check the 
> source code of COWArrayList.equals 1.56). If the input Collection size is 
> reduced before or during the traversal of the ListIterator a 
> NoSuchElementException or ConcurrentModificationException is thrown from 
> equals.

You have good reviewer eyes!  I also became aware of this problem while
reviewing the code, but it is another instance of the more
pervasive problem you pointed out above. This is something for the
expert group to think about.

> As a user of the API I would consider the ConcurrentModifcationException my 
> problem (misuse) but the NoSuchElementException I would consider something 
> the COWArrayList would have to hide or prevent.

I agree users will expect that they can use COWArrayFoos in their code
and not have to worry.

Martin

> Regards,
> 
> Jason Mehrens
From dl at cs.oswego.edu  Sat Sep 24 15:18:23 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat Sep 24 15:20:04 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <43359B42.8060600@Sun.COM>
References: <200509241600.j8OG09gT004366@altair.cs.oswego.edu>
	<43359B42.8060600@Sun.COM>
Message-ID: <4335A67F.4010201@cs.oswego.edu>

Martin Buchholz wrote:
> 
> 
> One possible strategy for implementing Set.equals would be
> new HashSet(this).equals(new HashSet(other));
> which at one stroke eliminates concurrency issues 

Although this places the burden on the HashSet(Collection c)
constructor, which is not specified to do anything special
in the face of concurrent modifications of "c" (and in fact
is likely to fail).

More generally, the java.util Collection APIs are not especially
consistent about the behavior of "binary bulk" collection
methods (Collection-constructors, putAll, equals, etc.)
The java.util.concurrent ones (ConcurrentMap, BlockingQueue)
are pretty clear about most of these. But I'm not sure whether or how
more can be said about the others. For example, while most people would
rather obtain a possibly (and defensibly) inaccurate result than
deadlock for a call to equals  with two concurrently accessible
collections, the specs cannot mandate this because many other people
have implemented these interfaces over the years, so at best, any
guarantees would hold only for those classes in the JDK.

The JSR166 expert group should/will explore alternatives
on this though.

-Doug
From Martin.Buchholz at Sun.COM  Sat Sep 24 17:03:14 2005
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Sat Sep 24 17:03:31 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <4335A67F.4010201@cs.oswego.edu>
References: <200509241600.j8OG09gT004366@altair.cs.oswego.edu>
	<43359B42.8060600@Sun.COM> <4335A67F.4010201@cs.oswego.edu>
Message-ID: <4335BF12.9040005@Sun.COM>



Doug Lea wrote:
> Martin Buchholz wrote:
> 
>>
>>One possible strategy for implementing Set.equals would be
>>new HashSet(this).equals(new HashSet(other));
>>which at one stroke eliminates concurrency issues 
> 
> 
> Although this places the burden on the HashSet(Collection c)
> constructor, which is not specified to do anything special
> in the face of concurrent modifications of "c" (and in fact
> is likely to fail).

Hmmmm.  In the current implementation, this eventually reduces
to a standard iterator loop over "c"

	Iterator<? extends E> e = c.iterator();
	while (e.hasNext()) {
	    add(e.next());

If "c" is not a concurrent collection, then concurrent modification
is simply not supposed to work, and users should expect
ConcurrentModificationException (or worse).

If "c" *is* a concurrent collection, then our implementations in
j.u.c. try to not have next() fail when hasNext() has just
succeeded, but I don't think we promise that.  Supposing we *did*
promise that, then
new HashSet(c)
would always give a "reasonable" result when c is a concurrent
collection, and cannot be expected to give a reasonable result
when c is not.

We could of course add a
try {...} catch (NoSuchElementException) {...}
to handle concurrently modified collections where next() might fail.

Unfortunately, if we implemented equals(Object) using this strategy,
we could still have equals return true when the two collections
never contained the same elements.  Indeed, there is no way to
get all the elements in a concurrent collection in such a way that
the returned elements represent a snapshot of a particular point in
time, and so there is in general no way to implement an intuitive
equals() method.  At least, if both collections are quiescent, then
c.equals(other) should give the expected result.  That is hard
to specify in the javadoc, because it depends on cooperation between two
unknown collection class implementations.

Martin
From mike.skells at ebizz-consulting.com  Sat Sep 24 17:22:39 2005
From: mike.skells at ebizz-consulting.com (Mike Skells)
Date: Sat Sep 24 17:22:56 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <4335BF12.9040005@Sun.COM>
Message-ID: <200509242122.j8OLMrgR007515@altair.cs.oswego.edu>

Hi,
Surely the logic is wrong here 

If you catch a ConcurrentModificationException  then equals() return false,
because at some time during the evaluation the collection was not equal

Similarly a NoSuchElementException should be caught and the collections
should not be equal unless they are == (in which case we should not the
iterating)

Both ConcurrentModificationException and NoSuchElementException are not
reasonable expected from a .equals() call. This may be an bug in the
java.util packages, but it does not need to be reploduced in j.u.c.

Just my 2c

Mike

> -----Original Message-----
> From: concurrency-interest-bounces@cs.oswego.edu 
> [mailto:concurrency-interest-bounces@cs.oswego.edu] On Behalf 
> Of Martin Buchholz
> Sent: 24 September 2005 22:03
> To: Doug Lea
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Race conditions in 
> concurrent collections
> 
> 
> 
> Doug Lea wrote:
> > Martin Buchholz wrote:
> > 
> >>
> >>One possible strategy for implementing Set.equals would be new 
> >>HashSet(this).equals(new HashSet(other)); which at one stroke 
> >>eliminates concurrency issues
> > 
> > 
> > Although this places the burden on the HashSet(Collection c) 
> > constructor, which is not specified to do anything special 
> in the face 
> > of concurrent modifications of "c" (and in fact is likely to fail).
> 
> Hmmmm.  In the current implementation, this eventually 
> reduces to a standard iterator loop over "c"
> 
> 	Iterator<? extends E> e = c.iterator();
> 	while (e.hasNext()) {
> 	    add(e.next());
> 
> If "c" is not a concurrent collection, then concurrent 
> modification is simply not supposed to work, and users should 
> expect ConcurrentModificationException (or worse).
> 
> If "c" *is* a concurrent collection, then our implementations 
> in j.u.c. try to not have next() fail when hasNext() has just 
> succeeded, but I don't think we promise that.  Supposing we 
> *did* promise that, then new HashSet(c) would always give a 
> "reasonable" result when c is a concurrent collection, and 
> cannot be expected to give a reasonable result when c is not.
> 
> We could of course add a
> try {...} catch (NoSuchElementException) {...} to handle 
> concurrently modified collections where next() might fail.
> 
> Unfortunately, if we implemented equals(Object) using this 
> strategy, we could still have equals return true when the two 
> collections never contained the same elements.  Indeed, there 
> is no way to get all the elements in a concurrent collection 
> in such a way that the returned elements represent a snapshot 
> of a particular point in time, and so there is in general no 
> way to implement an intuitive
> equals() method.  At least, if both collections are quiescent, then
> c.equals(other) should give the expected result.  That is 
> hard to specify in the javadoc, because it depends on 
> cooperation between two unknown collection class implementations.
> 
> Martin
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From dl at cs.oswego.edu  Sat Sep 24 20:15:06 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat Sep 24 20:16:49 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <200509242122.j8OLMrgR007515@altair.cs.oswego.edu>
References: <200509242122.j8OLMrgR007515@altair.cs.oswego.edu>
Message-ID: <4335EC0A.9050203@cs.oswego.edu>

Mike Skells wrote:
> 
> If you catch a ConcurrentModificationException  then equals() return false,
> because at some time during the evaluation the collection was not equal
> 
> Similarly a NoSuchElementException should be caught and the collections
> should not be equal unless they are == (in which case we should not the
> iterating)
> 
> Both ConcurrentModificationException and NoSuchElementException are not
> reasonable expected from a .equals() call. 

Issues like this are why concurrent collection iterators do not
throw these exceptions unexpectedly, so these problems should never
arise when dealing solely with concurrent collections. But I agree
that it would be nice if something better can be said and done
with calls using other kinds of collections, like:
   aConcurrentHashMap.equals(aHashtable)
   aConcurrentHashMap.equals(aHashMap)

I still don't know what that something is though. While it would
make sense to simply return false here if a Hashtable iterator
throws ConcurrentModificationException, it would not be
a good idea for a HashMap iterator, because in that case
the ConcurrentModificationException almost surely reflects
some kind of corruption -- it acts as a error that would be
swallowed if it simply triggers equals to return false.

(Note that concurrent/blocking queues evade these issues
entirely by relying on identity-based equality. Ideally,
most or all other concurrent collections would as well, but
doing so would have made it more difficult for people to switch from
java.util classes to instead use them.)

-Doug
From mike.skells at ebizz-consulting.com  Sat Sep 24 20:33:28 2005
From: mike.skells at ebizz-consulting.com (Mike Skells)
Date: Sat Sep 24 20:33:44 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <4335EC0A.9050203@cs.oswego.edu>
Message-ID: <200509250033.j8P0XfgR009584@altair.cs.oswego.edu>

 

> -----Original Message-----
> From: Doug Lea [mailto:dl@cs.oswego.edu] 
> Sent: 25 September 2005 01:15
> To: Mike Skells
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Race conditions in 
> concurrent collections
> 
> Mike Skells wrote:
> > 
> > If you catch a ConcurrentModificationException  then 
> equals() return 
> > false, because at some time during the evaluation the 
> collection was 
> > not equal
> > 
> > Similarly a NoSuchElementException should be caught and the 
> > collections should not be equal unless they are == (in 
> which case we 
> > should not the
> > iterating)
> > 
> > Both ConcurrentModificationException and NoSuchElementException are 
> > not reasonable expected from a .equals() call.
> 
> Issues like this are why concurrent collection iterators do 
> not throw these exceptions unexpectedly, so these problems 
> should never arise when dealing solely with concurrent 
> collections. But I agree that it would be nice if something 
> better can be said and done with calls using other kinds of 
> collections, like:
>    aConcurrentHashMap.equals(aHashtable)
>    aConcurrentHashMap.equals(aHashMap)
> 
> I still don't know what that something is though. While it 
> would make sense to simply return false here if a Hashtable 
> iterator throws ConcurrentModificationException, it would not 
> be a good idea for a HashMap iterator, because in that case 
> the ConcurrentModificationException almost surely reflects 
> some kind of corruption -- it acts as a error that would be 
> swallowed if it simply triggers equals to return false.
> 
> (Note that concurrent/blocking queues evade these issues 
> entirely by relying on identity-based equality. Ideally, most 
> or all other concurrent collections would as well, but doing 
> so would have made it more difficult for people to switch 
> from java.util classes to instead use them.)
> 
> -Doug

I was thinking not so much of the case when someone is dealing with a
collection per se, as when the ser is programming to say the object
interface

Object x = ...
Object y = ...

If (x.equals(y)) {
  ...
}


I dont think that it is reasonable to write 

try {
   if (x.equals(y)) {
      ...
   }
} catch RuntimeException re) {
}

-----

Worse still not I come o think if it is the cases where you are indirectly
iterating
For example isnt there a similar problem with hashCode(),or even toString(),
or some other API that is being used that indirectly iterates, or calls
equals ...


Mike


From dl at cs.oswego.edu  Sun Sep 25 09:48:26 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun Sep 25 09:50:08 2005
Subject: [concurrency-interest] Race conditions in concurrent collections
In-Reply-To: <200509250033.j8P0XhgR009597@altair.cs.oswego.edu>
References: <200509250033.j8P0XhgR009597@altair.cs.oswego.edu>
Message-ID: <4336AAAA.8030808@cs.oswego.edu>

Mike Skells wrote:
> 
> For example isnt there a similar problem with hashCode(),or even toString(),
> or some other API that is being used that indirectly iterates, or calls
> equals ...
> 

Right. The slogan is to use java.util.concurrent implementations for
all concurrently accessible collections. They are designed to handle
these operations in reasonable ways even under concurrent modification.
(Too bad that in Tiger we were still missing a few common ones
like ConcurrentSkipList{Map,Set} to substitute for Tree{Map, Set}.)
On the other hand, even though "reasonably" implemented,
some of these operations make little sense and should usually
be avoided when the collections are concurrently accessible.

For example, computing a hashCode for a collection that is undergoing
concurrent modification is almost never a good idea from an application
level point of view, so the fact that it doesn't throw an exception is
not all that helpful. It would almost be better for it to throw an
exception anyway to warn you that you are probably doing something
nonsensical, although that would be overly paternalistic :-)

-Doug
