From dl@cs.oswego.edu  Sun Aug  3 16:18:23 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 3 Aug 2003 11:18:23 -0400
Subject: [concurrency-interest] Enforced lock ordering
In-Reply-To: <1050195071.3087.16.camel@desktop.igoweb.org>
References: <1050195071.3087.16.camel@desktop.igoweb.org>
Message-ID: <16173.10175.43616.324718@altair.cs.oswego.edu>

Hi. Sorry for the long delay on this; I just noticed this never
got answered:

> Hi. I just joined the list, and see that last month there was a post
> related to enforced lock ordering. Before all threaded applications I've
> used had a lock order to prevent deadlock, and in some cases a C library
> that forces all locks to be strictly ordered and aborts the program when
> you try to acquire locks out of order was used. With the right tool set,
> checking your lock ordering can be done pretty painlessly, and it helps
> avoid disasterous "about once a month the damn program just locks up"
> type bugs. I see that the concurrency API is geared more towards using
> timeouts, but that seems to really be asking for major problems on
> systems where reliability is important - if you get halfway through a
> procedure, then timeout on a lock indicating possible deadlock, you must
> be able to safely undo all work so far. This would be a process that is
> tricky, happens rarely, and is hard to test, a great way to make sure
> there are bugs in your code.
> 
> I made a cut at a library to force lock ordering for the current java
> monitor operations
> ...

This sounds useful, but hard to standardize upon. What we WILL give
you though is an extensible framework that would make it possible to
better integrate this. for example:

class RankedLock implements Lock {
  RandkedLock(int rank); 
  void lock() {
    if (my rank conflicts with held locks) throw new Error(...)
    else delegate to a ReentrantLock.
    ...
  }
  // ... and so on
}

And then use it instead of ReentrantLock etc. As usuall, the downside
is that Users will have to accept the syntactic tradeoffs of not using
"synchronized" here. (We in JSR-166 really can't do anything about
that. There is no syntactic hole left in Java to syntactically support
user-defined locks.)

With any luck people will start to create such things and make them
available.

-Doug

From dl@cs.oswego.edu  Sun Aug  3 18:55:10 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 3 Aug 2003 13:55:10 -0400
Subject: [concurrency-interest] Enforced lock ordering
In-Reply-To: <16173.10175.43616.324718@altair.cs.oswego.edu>
References: <1050195071.3087.16.camel@desktop.igoweb.org>
 <16173.10175.43616.324718@altair.cs.oswego.edu>
Message-ID: <16173.19582.643737.418240@altair.cs.oswego.edu>

> 
> The email content filter has detected an inappropriate word in your email identified below.  Please review your message prior to any attempt to resend.
> 
> 
> Sender: concurrency-interest-admin@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Enforced lock ordering
> Violation: Profanity
> 

Well. I admit that we are a little stressed out trying to make
deadlines for JCP Community Review (this week), and locking can be a
racy subject, but I didn't think I said anything all that rude :-)

-Doug



From joshua.bloch@sun.com  Sun Aug  3 19:05:55 2003
From: joshua.bloch@sun.com (Joshua Bloch)
Date: Sun, 03 Aug 2003 11:05:55 -0700
Subject: [concurrency-interest] Enforced lock ordering
In-Reply-To: <16173.19582.643737.418240@altair.cs.oswego.edu>
References: <1050195071.3087.16.camel@desktop.igoweb.org> <16173.10175.43616.324718@altair.cs.oswego.edu> <16173.19582.643737.418240@altair.cs.oswego.edu>
Message-ID: <3F2D4F03.1020309@sun.com>

Doug,

   Well, my last message did contain the technical term "sucks"  but I 
don't see it as profanity.  After all, children suck lollipops, and 
medical doctors write technical papers on the "suck reflex."

                       Josh



From dl@cs.oswego.edu  Wed Aug  6 21:00:44 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 6 Aug 2003 16:00:44 -0400
Subject: [concurrency-interest] JCP Community Review Draft
Message-ID: <16177.24172.127418.484277@altair.cs.oswego.edu>

The APIs in the usual place,
  http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
were just submitted to JCP for Community Review (CR) phase. However,
the version here will continue to get updated as any changes arise.

For us, getting the CR draft together mostly means that the APIs are
getting more certain and more stable. Now would be a good time for you
to tell us if you really don't like something there, or really need
something that isn't there.

Thanks for all the hard work to JSR-166 expert group members Josh
Bloch, Joe Bowbeer, Cliff Click, Brian Goetz, David Holmes, and Tim
Peierls, with help from Dave Dice and Bill Pugh. (And countless
others!)

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From chussenet@yahoo.com  Thu Aug  7 02:20:25 2003
From: chussenet@yahoo.com (Claude Hussenet)
Date: Wed, 6 Aug 2003 18:20:25 -0700 (PDT)
Subject: [concurrency-interest] JCP Community Review Draft
In-Reply-To: <16177.24172.127418.484277@altair.cs.oswego.edu>
Message-ID: <20030807012025.54173.qmail@web41505.mail.yahoo.com>

I am currently a happy user of the concurrent package.

I didn't see in the JAVA doc how to define
a callable function for a given length of time
such as the TimedCallable class from the concurrent
package.

I have noticed some refactoring of the concurrent
package in the future JSR 166 implementation.

Is it planned to describe the differences between the
2 packages.

Rgds,Claude




--- Doug Lea <dl@cs.oswego.edu> wrote:
> 
> The APIs in the usual place,
>  
>
http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
> were just submitted to JCP for Community Review (CR)
> phase. However,
> the version here will continue to get updated as any
> changes arise.
> 
> For us, getting the CR draft together mostly means
> that the APIs are
> getting more certain and more stable. Now would be a
> good time for you
> to tell us if you really don't like something there,
> or really need
> something that isn't there.
> 
> Thanks for all the hard work to JSR-166 expert group
> members Josh
> Bloch, Joe Bowbeer, Cliff Click, Brian Goetz, David
> Holmes, and Tim
> Peierls, with help from Dave Dice and Bill Pugh.
> (And countless
> others!)
> 
> -- 
> Doug Lea, Computer Science Department, SUNY Oswego,
> Oswego, NY 13126 USA
> dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424
> http://gee.cs.oswego.edu/  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
>
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


=====
Claude Hussenet
Independent Consultant.
(516)942-8214 (Home Office)
(516)782-2614 (Mobile Phone)
www.portalsmart.com (Showcase Not Always up)

__________________________________
Do you Yahoo!?
Yahoo! SiteBuilder - Free, easy-to-use web site design software
http://sitebuilder.yahoo.com

From olivier.dupuy@hrdc-drhc.gc.ca  Thu Aug  7 18:57:11 2003
From: olivier.dupuy@hrdc-drhc.gc.ca (olivier.dupuy@hrdc-drhc.gc.ca)
Date: Thu, 7 Aug 2003 13:57:11 -0400
Subject: [concurrency-interest] RE: Concurrency-interest digest, Vol 1 #121 - 2 msgs
Message-ID: <0691D2A40A12164D88BC675BC8C4815C165D87@NCEV02.hrdc-drhc.net>

Hi

I was reading the javadoc of the classes AtomicInteger and equivalent. The method getAndIncrement() and others return only the previous value (such as 'a = b++' in C) and there is no way to obtain the new value (a = ++b). If I want the equivalent of a = ++b I will have to write
AtomicInteger b = ...
int a = b.getAndIncrement() + 1;
This become more cumbersome if I use the getAndAdd(int delta) with the delta being a function call because I will have to store its result.
AtomicInteger b = ...
int myCall = myMethodCall();
int a = b.getAndAdd(myCall) + myCall;

Could we add incrementAndGet(), addAndGet()... and equivalent for all the Atomic... classes ? It's a simple change making them more complete.

	Merci ... Thanks

	Olivier DUPUY


-----Original Message-----
From: concurrency-interest-request@cs.oswego.edu [mailto:concurrency-interest-request@cs.oswego.edu] 
Sent: Thursday, August 07, 2003 12:00 PM
To: concurrency-interest@altair.cs.oswego.edu
Subject: Concurrency-interest digest, Vol 1 #121 - 2 msgs


Send Concurrency-interest mailing list submissions to
	concurrency-interest@altair.cs.oswego.edu

To subscribe or unsubscribe via the World Wide Web, visit
	http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
	concurrency-interest-request@altair.cs.oswego.edu

You can reach the person managing the list at
	concurrency-interest-admin@altair.cs.oswego.edu

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

   1. JCP Community Review Draft (Doug Lea)
   2. Re: JCP Community Review Draft (Claude Hussenet)

--__--__--

Message: 1
From: Doug Lea <dl@cs.oswego.edu>
Date: Wed, 6 Aug 2003 16:00:44 -0400
To: concurrency-interest@altair.cs.oswego.edu
Subject: [concurrency-interest] JCP Community Review Draft


The APIs in the usual place,
  http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
were just submitted to JCP for Community Review (CR) phase. However,
the version here will continue to get updated as any changes arise.

For us, getting the CR draft together mostly means that the APIs are
getting more certain and more stable. Now would be a good time for you
to tell us if you really don't like something there, or really need
something that isn't there.

Thanks for all the hard work to JSR-166 expert group members Josh
Bloch, Joe Bowbeer, Cliff Click, Brian Goetz, David Holmes, and Tim
Peierls, with help from Dave Dice and Bill Pugh. (And countless
others!)

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

--__--__--

Message: 2
Date: Wed, 6 Aug 2003 18:20:25 -0700 (PDT)
From: Claude Hussenet <chussenet@yahoo.com>
Subject: Re: [concurrency-interest] JCP Community Review Draft
To: Doug Lea <dl@altair.cs.oswego.edu>,
   concurrency-interest@altair.cs.oswego.edu

I am currently a happy user of the concurrent package.

I didn't see in the JAVA doc how to define
a callable function for a given length of time
such as the TimedCallable class from the concurrent
package.

I have noticed some refactoring of the concurrent
package in the future JSR 166 implementation.

Is it planned to describe the differences between the
2 packages.

Rgds,Claude




--- Doug Lea <dl@cs.oswego.edu> wrote:
> 
> The APIs in the usual place,
>  
>
http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
> were just submitted to JCP for Community Review (CR)
> phase. However,
> the version here will continue to get updated as any
> changes arise.
> 
> For us, getting the CR draft together mostly means
> that the APIs are
> getting more certain and more stable. Now would be a
> good time for you
> to tell us if you really don't like something there,
> or really need
> something that isn't there.
> 
> Thanks for all the hard work to JSR-166 expert group
> members Josh
> Bloch, Joe Bowbeer, Cliff Click, Brian Goetz, David
> Holmes, and Tim
> Peierls, with help from Dave Dice and Bill Pugh.
> (And countless
> others!)
> 
> -- 
> Doug Lea, Computer Science Department, SUNY Oswego,
> Oswego, NY 13126 USA
> dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424
> http://gee.cs.oswego.edu/  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
>
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


=====
Claude Hussenet
Independent Consultant.
(516)942-8214 (Home Office)
(516)782-2614 (Mobile Phone)
www.portalsmart.com (Showcase Not Always up)

__________________________________
Do you Yahoo!?
Yahoo! SiteBuilder - Free, easy-to-use web site design software
http://sitebuilder.yahoo.com


--__--__--

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


End of Concurrency-interest Digest


From jozart@csi.com  Fri Aug  8 09:14:34 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Fri, 8 Aug 2003 01:14:34 -0700
Subject: [concurrency-interest] JCP Community Review Draft
References: <20030807012025.54173.qmail@web41505.mail.yahoo.com>
Message-ID: <03f601c35d85$1aa377a0$d3827cce@REPLICANT2>

Claude Hussenet writes:

> I didn't see in the JAVA doc how to define
> a callable function for a given length of time
> such as the TimedCallable class from the
> concurrent package.

A direct translation in the new API would be something like the following:

----------
public class TimedCallable implements Callable {

  private final Callable func;
  private final long msecs;

  public TimedCallable(Callable func, long msecs) {
    this.func = func;
    this.msecs = msecs;
  }

  public Object call() throws Exception {

    FutureTask ftask = new FutureTask(func);
    new Thread(ftask).start();

    try {
      return ftask.get(msecs, TimeUnit.MILLISECONDS);
    }
    catch (InterruptedException ex) {
      /* If we're interrupted waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
    catch (TimeoutException ex) {
      /* If we timeout waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
  }
}

----------

Note that TimeoutException now extends Exception rather than
InterruptedException.

FutureTask, which replaces FutureResult, simplies the code some because (1)
FutureTask is Runnable, and (2) FutureTask.cancel has an option to interrupt
its worker thread.

As before, the version above creates and starts its own thread.
Executors.newSingleThreadExecutor().execute could have been used instead.

The version below accepts an executor as a param.  This way you can pass a
cached thread pool to all of your TimedCallable constructors, and they will
reuse the worker threads when possible.

  executor = Executors.newCachedThreadPool(threadFactory);

----------
public class TimedCallable implements Callable {

  private final Executor exec;
  private final Callable func;
  private final long msecs;

  public TimedCallable(Executor exec, Callable func, long msecs) {
    this.exec = exec;
    this.func = func;
    this.msecs = msecs;
  }

  public Object call() throws Exception {

    FutureTask ftask = Executors.execute(exec, func);

    try {
      return ftask.get(msecs, TimeUnit.MILLISECONDS);
    }
    catch (InterruptedException ex) {
      /* If we're interrupted waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
    catch (TimeoutException ex) {
      /* If we timeout waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
  }
}
----------


----- Original Message ----- 
From: "Claude Hussenet" <chussenet@yahoo.com>
To: "Doug Lea" <dl@altair.cs.oswego.edu>;
<concurrency-interest@altair.cs.oswego.edu>
Sent: Wednesday, August 06, 2003 6:20 PM
Subject: Re: [concurrency-interest] JCP Community Review Draft

I am currently a happy user of the concurrent package.

I didn't see in the JAVA doc how to define
a callable function for a given length of time
such as the TimedCallable class from the concurrent
package.

I have noticed some refactoring of the concurrent
package in the future JSR 166 implementation.

Is it planned to describe the differences between the
2 packages.

Rgds,Claude


From jozart@csi.com  Fri Aug  8 09:32:44 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Fri, 8 Aug 2003 01:32:44 -0700
Subject: [concurrency-interest] JCP Community Review Draft
Message-ID: <040201c35d87$a4119650$d3827cce@REPLICANT2>

On second thought, it would be simpler to dispense with the exception
handling and simply make sure the task is cancelled when we return:

  public Object call() throws Exception {
    FutureTask ftask = Executors.execute(exec, func);
    try {
      return ftask.get(msecs, TimeUnit.MILLISECONDS);
    } finally {
      ftask.cancel(true);
    }
  }


----- Original Message ----- 
From: "Joseph Bowbeer" <jozart@csi.com>
To: "Claude Hussenet" <chussenet@yahoo.com>;
<concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, August 08, 2003 1:14 AM
Subject: Re: [concurrency-interest] JCP Community Review Draft


Claude Hussenet writes:

> I didn't see in the JAVA doc how to define
> a callable function for a given length of time
> such as the TimedCallable class from the
> concurrent package.

A direct translation in the new API would be something like the following:

----------
public class TimedCallable implements Callable {

  private final Callable func;
  private final long msecs;

  public TimedCallable(Callable func, long msecs) {
    this.func = func;
    this.msecs = msecs;
  }

  public Object call() throws Exception {

    FutureTask ftask = new FutureTask(func);
    new Thread(ftask).start();

    try {
      return ftask.get(msecs, TimeUnit.MILLISECONDS);
    }
    catch (InterruptedException ex) {
      /* If we're interrupted waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
    catch (TimeoutException ex) {
      /* If we timeout waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
  }
}

----------

Note that TimeoutException now extends Exception rather than
InterruptedException.

FutureTask, which replaces FutureResult, simplies the code some because (1)
FutureTask is Runnable, and (2) FutureTask.cancel has an option to interrupt
its worker thread.

As before, the version above creates and starts its own thread.
Executors.newSingleThreadExecutor().execute could have been used instead.

The version below accepts an executor as a param.  This way you can pass a
cached thread pool to all of your TimedCallable constructors, and they will
reuse the worker threads when possible.

  executor = Executors.newCachedThreadPool(threadFactory);

----------
public class TimedCallable implements Callable {

  private final Executor exec;
  private final Callable func;
  private final long msecs;

  public TimedCallable(Executor exec, Callable func, long msecs) {
    this.exec = exec;
    this.func = func;
    this.msecs = msecs;
  }

  public Object call() throws Exception {

    FutureTask ftask = Executors.execute(exec, func);

    try {
      return ftask.get(msecs, TimeUnit.MILLISECONDS);
    }
    catch (InterruptedException ex) {
      /* If we're interrupted waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
    catch (TimeoutException ex) {
      /* If we timeout waiting for the result,
         cancel task and interrupt its thread. */
      ftask.cancel(true);
      throw ex;
    }
  }
}
----------


----- Original Message ----- 
From: "Claude Hussenet" <chussenet@yahoo.com>
To: "Doug Lea" <dl@altair.cs.oswego.edu>;
<concurrency-interest@altair.cs.oswego.edu>
Sent: Wednesday, August 06, 2003 6:20 PM
Subject: Re: [concurrency-interest] JCP Community Review Draft

I am currently a happy user of the concurrent package.

I didn't see in the JAVA doc how to define
a callable function for a given length of time
such as the TimedCallable class from the concurrent
package.

I have noticed some refactoring of the concurrent
package in the future JSR 166 implementation.

Is it planned to describe the differences between the
2 packages.

Rgds,Claude


From dl@cs.oswego.edu  Fri Aug  8 11:37:28 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 8 Aug 2003 06:37:28 -0400
Subject: [concurrency-interest] Atomic ops (RE: Concurrency-interest digest, Vol 1 #121 - 2 msgs)
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C165D87@NCEV02.hrdc-drhc.net>
References: <0691D2A40A12164D88BC675BC8C4815C165D87@NCEV02.hrdc-drhc.net>
Message-ID: <16179.32104.69597.491242@altair.cs.oswego.edu>

Hi Olivier,

Well, this is a bad precedent (:-) in that we are at this point
supposed to say "there's no way we are going to add/change a feature
unless we have a set of compelling use cases that require it". But we
think you are right here. The reason for supporting getAndAdd,
getAndIncrement, etc was that this is how atomic ops have always been
expressed (as in testAndSet and fetchAndAdd instructions supported on
processors for decades). But as you note, the opposite forms are much
more convenient in some cases, and they are easy to support, so we
should just do it. Stay tuned for revisions showing Atomic{Int,Long}*
with

  addAndGet
  incrementAndGet
  decrementAndGet

-Doug

From chussenet@yahoo.com  Fri Aug  8 15:19:48 2003
From: chussenet@yahoo.com (Claude Hussenet)
Date: Fri, 8 Aug 2003 07:19:48 -0700 (PDT)
Subject: [concurrency-interest] JCP Community Review Draft
In-Reply-To: <040201c35d87$a4119650$d3827cce@REPLICANT2>
Message-ID: <20030808141948.7028.qmail@web41510.mail.yahoo.com>

Thx,Joe for your quick and complete reply.

Is there any reason why we don't add the class that u
proposed in your previous email in the reference ?
Especially ,when this class is in the "concurrent"
package !

If u do it,I will be very happy to help u to test it.

Rgds,Claude

Claude Hussenet
Independent Consultant.
(516)942-8214 (Home Office)
(516)782-2614 (Mobile Phone)
www.portalsmart.com (Showcase Not Always up)




 


--- Joseph Bowbeer <jozart@csi.com> wrote:
> On second thought, it would be simpler to dispense
> with the exception
> handling and simply make sure the task is cancelled
> when we return:
> 
>   public Object call() throws Exception {
>     FutureTask ftask = Executors.execute(exec,
> func);
>     try {
>       return ftask.get(msecs,
> TimeUnit.MILLISECONDS);
>     } finally {
>       ftask.cancel(true);
>     }
>   }
> 
> 
> ----- Original Message ----- 
> From: "Joseph Bowbeer" <jozart@csi.com>
> To: "Claude Hussenet" <chussenet@yahoo.com>;
> <concurrency-interest@altair.cs.oswego.edu>
> Sent: Friday, August 08, 2003 1:14 AM
> Subject: Re: [concurrency-interest] JCP Community
> Review Draft
> 
> 
> Claude Hussenet writes:
> 
> > I didn't see in the JAVA doc how to define
> > a callable function for a given length of time
> > such as the TimedCallable class from the
> > concurrent package.
> 
> A direct translation in the new API would be
> something like the following:
> 
> ----------
> public class TimedCallable implements Callable {
> 
>   private final Callable func;
>   private final long msecs;
> 
>   public TimedCallable(Callable func, long msecs) {
>     this.func = func;
>     this.msecs = msecs;
>   }
> 
>   public Object call() throws Exception {
> 
>     FutureTask ftask = new FutureTask(func);
>     new Thread(ftask).start();
> 
>     try {
>       return ftask.get(msecs,
> TimeUnit.MILLISECONDS);
>     }
>     catch (InterruptedException ex) {
>       /* If we're interrupted waiting for the
> result,
>          cancel task and interrupt its thread. */
>       ftask.cancel(true);
>       throw ex;
>     }
>     catch (TimeoutException ex) {
>       /* If we timeout waiting for the result,
>          cancel task and interrupt its thread. */
>       ftask.cancel(true);
>       throw ex;
>     }
>   }
> }
> 
> ----------
> 
> Note that TimeoutException now extends Exception
> rather than
> InterruptedException.
> 
> FutureTask, which replaces FutureResult, simplies
> the code some because (1)
> FutureTask is Runnable, and (2) FutureTask.cancel
> has an option to interrupt
> its worker thread.
> 
> As before, the version above creates and starts its
> own thread.
> Executors.newSingleThreadExecutor().execute could
> have been used instead.
> 
> The version below accepts an executor as a param. 
> This way you can pass a
> cached thread pool to all of your TimedCallable
> constructors, and they will
> reuse the worker threads when possible.
> 
>   executor =
> Executors.newCachedThreadPool(threadFactory);
> 
> ----------
> public class TimedCallable implements Callable {
> 
>   private final Executor exec;
>   private final Callable func;
>   private final long msecs;
> 
>   public TimedCallable(Executor exec, Callable func,
> long msecs) {
>     this.exec = exec;
>     this.func = func;
>     this.msecs = msecs;
>   }
> 
>   public Object call() throws Exception {
> 
>     FutureTask ftask = Executors.execute(exec,
> func);
> 
>     try {
>       return ftask.get(msecs,
> TimeUnit.MILLISECONDS);
>     }
>     catch (InterruptedException ex) {
>       /* If we're interrupted waiting for the
> result,
>          cancel task and interrupt its thread. */
>       ftask.cancel(true);
>       throw ex;
>     }
>     catch (TimeoutException ex) {
>       /* If we timeout waiting for the result,
>          cancel task and interrupt its thread. */
>       ftask.cancel(true);
>       throw ex;
>     }
>   }
> }
> ----------
> 
> 
> ----- Original Message ----- 
> From: "Claude Hussenet" <chussenet@yahoo.com>
> To: "Doug Lea" <dl@altair.cs.oswego.edu>;
> <concurrency-interest@altair.cs.oswego.edu>
> Sent: Wednesday, August 06, 2003 6:20 PM
> Subject: Re: [concurrency-interest] JCP Community
> Review Draft
> 
> I am currently a happy user of the concurrent
> package.
> 
> I didn't see in the JAVA doc how to define
> a callable function for a given length of time
> such as the TimedCallable class from the concurrent
> package.
> 
> I have noticed some refactoring of the concurrent
> package in the future JSR 166 implementation.
> 
> Is it planned to describe the differences between
> the
> 2 packages.
> 
> Rgds,Claude
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
>
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


=====
Claude Hussenet
Independent Consultant.
(516)942-8214 (Home Office)
(516)782-2614 (Mobile Phone)
www.portalsmart.com (Showcase Not Always up)

__________________________________
Do you Yahoo!?
Yahoo! SiteBuilder - Free, easy-to-use web site design software
http://sitebuilder.yahoo.com

From langer@camelot.de  Fri Aug 15 16:25:28 2003
From: langer@camelot.de (Angelika Langer)
Date: Fri, 15 Aug 2003 17:25:28 +0200
Subject: [concurrency-interest] problem with CyclicBarrier
Message-ID: <3F3CFB68.1090608@camelot.de>

This is a multi-part message in MIME format.
--------------020408010909040607090304
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Hi!

We've been playing around with the latest prototype release and ran into 
a problem with the reset of a cyclic barrier.

Our understanding is that threads waiting on the barrier would receive a 
  BrokenBarrierException if another thread resets the barrier.  In our 
program (see attachment) no exception is raised and the barrier is not 
broken either after the reset.

We are not sure whether we do not understand what the barrier is 
supposed to do, or whether we are seeing a bug in the prototype 
implementation, or perhaps a side effect of the emulation (we are using 
it on Windows XP).  Are there any known problems with CyclicBarrier.reset()?

Thanks,
Angelika
-- 
----------------------------------------------------------------
Angelika Langer & Klaus Kreft
Email: langer@camelot.de
http://www.langer.camelot.de/
----------------------------------------------------------------


--------------020408010909040607090304
Content-Type: text/plain;
 name="HighlevelSync.java"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="HighlevelSync.java"

package labs;


import java.util.*;
import java.util.concurrent.*;

public class HighlevelSync {

	private static class MiddleThread implements Runnable {	
		private BlockingQueue<Integer> src;
		private BlockingQueue<Integer> dest;
		private CyclicBarrier barrier;
		
		public MiddleThread(BlockingQueue<Integer> src, 
		                    BlockingQueue<Integer> dest,
		                    CyclicBarrier barrier) {
			this.src = src;
			this.dest = dest;
			this.barrier = barrier;
		}
		
		public void run() {
			Random generator = new Random();
			
			for (;;) {
				int originalValue = generator.nextInt();
				int receivedValue = 0;
					
				try {
					dest.put(new Integer(originalValue));
					receivedValue = src.take().intValue();
				} catch (InterruptedException e) {  }

				System.out.println("values: " + originalValue +" | "+ receivedValue);				
				
				if ((originalValue == receivedValue) && ! (originalValue % 25 == 0)) {
					try {
						barrier.await();
					} catch (Exception e) { break; }
				}
				else {
					while (barrier.getNumberWaiting() < 2) {
						try { Thread.sleep (100); }
						catch (InterruptedException e) {  }
					}
					barrier.reset();
					break;
				}
			}
		}
	}
	
	private static class OtherThread implements Runnable {
		private BlockingQueue<Integer> src;
		private BlockingQueue<Integer> dest;
		private CyclicBarrier barrier;
		
		public OtherThread(BlockingQueue<Integer> src, 
		                    BlockingQueue<Integer> dest,
		                    CyclicBarrier barrier) {
			this.src = src;
			this.dest = dest;
			this.barrier = barrier;
		}

		public void run() {
			for (;;) {
				try { dest.put(src.take()); }
				catch (InterruptedException e) {  }
			
				try { barrier.await(); } 
				catch (Exception e) { break; }
			}
		}		
	}

	public static void main(String array[]) {
		BlockingQueue<Integer> q1 = new ArrayBlockingQueue<Integer>(1);
	 	BlockingQueue<Integer> q2 = new ArrayBlockingQueue<Integer>(1);
	 	BlockingQueue<Integer> q3 = new ArrayBlockingQueue<Integer>(1);
	 	CyclicBarrier barrier = new CyclicBarrier(3);
	 	
		// lower
		new Thread(new OtherThread(q1, q2, barrier)).start();
		// upper
		new Thread(new OtherThread(q2, q3, barrier)).start();
		// middle
		new Thread(new MiddleThread(q3, q1, barrier)).start();
	}
}
--------------020408010909040607090304--


From dl@cs.oswego.edu  Fri Aug 15 16:45:35 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 15 Aug 2003 11:45:35 -0400
Subject: [concurrency-interest] problem with CyclicBarrier
In-Reply-To: <3F3CFB68.1090608@camelot.de>
References: <3F3CFB68.1090608@camelot.de>
Message-ID: <16189.31.723984.393565@altair.cs.oswego.edu>

Hi Angelika,

Thanks for the report. Yes, CyclicBarrier.reset did not do what it was
intended to do in some cases in PR2 version. Sorry!

Also, while I'm at it, ScheduledExecutor had several problems,
that were in part spec/design flaws that we've since fixed.

At the moment, it is difficult for us to issue another prerelease
because we are busy in preliminary JDK1.5 integration, which breaks
1.4.1-compatibility/emulatability. When this is over (probably a few
weeks), we will release a hopefully stable back-compatible
partially-emulated version to help people trying things out and
converting from dl.u.c until 1.5 is available.

I'll also work on making regular file-by-file source updates
available. In the mean time I'll mail you a CyclicBarrier update which
will work with PR2.

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From langer@camelot.de  Fri Aug 15 19:30:21 2003
From: langer@camelot.de (Angelika Langer)
Date: Fri, 15 Aug 2003 20:30:21 +0200
Subject: [concurrency-interest] problem with CyclicBarrier
In-Reply-To: <16189.31.723984.393565@altair.cs.oswego.edu>
References: <3F3CFB68.1090608@camelot.de> <16189.31.723984.393565@altair.cs.oswego.edu>
Message-ID: <3F3D26BD.1010609@camelot.de>

Hi Doug!

Thanks you. I'll compile the CyclicBarrier update and check whether it 
works.

I have another question:  will the classes and interface be modified to 
use wildcards (the variance feature in Java generics)?  Or will they 
basically remain the way they are right now?

For example: the constructor of class ThreadPoolExecutor could take a 
BlockingQueue<? extends Runnable>, as far as I understand it.

Best regards,
Angelika



Doug Lea wrote:

> Hi Angelika,
> 
> Thanks for the report. Yes, CyclicBarrier.reset did not do what it was
> intended to do in some cases in PR2 version. Sorry!
> 
> Also, while I'm at it, ScheduledExecutor had several problems,
> that were in part spec/design flaws that we've since fixed.
> 
> At the moment, it is difficult for us to issue another prerelease
> because we are busy in preliminary JDK1.5 integration, which breaks
> 1.4.1-compatibility/emulatability. When this is over (probably a few
> weeks), we will release a hopefully stable back-compatible
> partially-emulated version to help people trying things out and
> converting from dl.u.c until 1.5 is available.
> 
> I'll also work on making regular file-by-file source updates
> available. In the mean time I'll mail you a CyclicBarrier update which
> will work with PR2.
> 


-- 
----------------------------------------------------------------
Angelika Langer
Training & Consulting
Object-Oriented Software Development in C++ & Java
Email: langer@camelot.de
http://www.langer.camelot.de/
----------------------------------------------------------------


From dl@cs.oswego.edu  Fri Aug 15 19:41:23 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 15 Aug 2003 14:41:23 -0400
Subject: [concurrency-interest] problem with CyclicBarrier
In-Reply-To: <3F3D26BD.1010609@camelot.de>
References: <3F3CFB68.1090608@camelot.de>
 <16189.31.723984.393565@altair.cs.oswego.edu>
 <3F3D26BD.1010609@camelot.de>
Message-ID: <16189.10579.769894.238175@altair.cs.oswego.edu>

> I have another question:  will the classes and interface be modified to 
> use wildcards (the variance feature in Java generics)?  Or will they 
> basically remain the way they are right now?

We will be making them maximally compatible with conventions used in
java.util, which probably will entail a few changes to what is listed
now.  And we have more flexibility in cases like....

> For example: the constructor of class ThreadPoolExecutor could take a 
> BlockingQueue<? extends Runnable>, as far as I understand it.

I think you are right that we can do this; thanks for the suggestion!
Further comments along these lines (from anyone) would be welcome.  We
are the first new JDK API significantly using generics, so finding the
best ways to espress types is still uncharted territory.

-Doug


From matthias.ernst@coremedia.com  Sat Aug 16 11:48:25 2003
From: matthias.ernst@coremedia.com (matthias.ernst@coremedia.com)
Date: Sat, 16 Aug 2003 12:48:25 +0200 (CEST)
Subject: [concurrency-interest] problem with CyclicBarrier
In-Reply-To: <3F3D26BD.1010609@camelot.de>
Message-ID: <Pine.LNX.4.33.0308161235450.2285-100000@bebop.coremedia.com>

On Fri, 15 Aug 2003, Angelika Langer wrote:

> For example: the constructor of class ThreadPoolExecutor could take a
> BlockingQueue<? extends Runnable>, as far as I understand it.

I don't think so. Such a queue would be a 'Queue of items of some
anonymous type where all we know is that it extends Runnable'. While the
executor could pull "?"'s and thus Runnables out of the queue, it would
not be legal to store arbitrary Runnables into it. BlockingQueue<Runnable>
is the right signature.

Gruesse
Matthias

-- 
Matthias Ernst
Software Engineer

CoreMedia - Smart Content Technology


From blanshlu@netscape.net  Sat Aug 16 16:45:34 2003
From: blanshlu@netscape.net (Luke Blanshard)
Date: Sat, 16 Aug 2003 10:45:34 -0500
Subject: [concurrency-interest] problem with CyclicBarrier
In-Reply-To: <Pine.LNX.4.33.0308161235450.2285-100000@bebop.coremedia.com>
References: <Pine.LNX.4.33.0308161235450.2285-100000@bebop.coremedia.com>
Message-ID: <3F3E519E.1030805@netscape.net>

You could make ThreadPoolExecutor itself take a type parameter of <T 
extends Runnable>, and then have the queue be over <T>.  This would have 
to push all the way back into Executor.  This might be useful.

Luke

matthias.ernst@coremedia.com wrote:

>On Fri, 15 Aug 2003, Angelika Langer wrote:
>
>  
>
>>For example: the constructor of class ThreadPoolExecutor could take a
>>BlockingQueue<? extends Runnable>, as far as I understand it.
>>    
>>
>
>I don't think so. Such a queue would be a 'Queue of items of some
>anonymous type where all we know is that it extends Runnable'. While the
>executor could pull "?"'s and thus Runnables out of the queue, it would
>not be legal to store arbitrary Runnables into it. BlockingQueue<Runnable>
>is the right signature.
>
>Gruesse
>Matthias
>
>  
>


From langer@camelot.de  Sun Aug 17 12:01:38 2003
From: langer@camelot.de (Angelika Langer)
Date: Sun, 17 Aug 2003 13:01:38 +0200
Subject: [concurrency-interest] wildcards in ThreadPoolExecutor; was: problem with CyclicBarrier
In-Reply-To: <3F3E519E.1030805@netscape.net>
References: <Pine.LNX.4.33.0308161235450.2285-100000@bebop.coremedia.com> <3F3E519E.1030805@netscape.net>
Message-ID: <3F3F6092.3080709@camelot.de>

Luke Blanshard wrote:
> You could make ThreadPoolExecutor itself take a type parameter of <T 
> extends Runnable>, and then have the queue be over <T>.  This would have 
> to push all the way back into Executor.  This might be useful.
> 
> Luke
> 
> matthias.ernst@coremedia.com wrote:
>> On Fri, 15 Aug 2003, Angelika Langer wrote:
>>> For example: the constructor of class ThreadPoolExecutor could take a
>>> BlockingQueue<? extends Runnable>, as far as I understand it.
>>
>> I don't think so. Such a queue would be a 'Queue of items of some
>> anonymous type where all we know is that it extends Runnable'. While the
>> executor could pull "?"'s and thus Runnables out of the queue, it would
>> not be legal to store arbitrary Runnables into it. 
>> BlockingQueue<Runnable>
>> is the right signature.
>>
>> Gruesse
>> Matthias

We agree to both comments.  Parameterizing the with <T extends Runnable> 
would probably work. The question is just:  is it worth doing?

Declaring the queue argument of the constructor of class 
ThreadPoolExecutor as BlockingQueue<? extends Runnable> is debatable.

At one point the ThreadPoolExecutor will have to cast from 
BlockingQueue<? extends Runnable> to BlockingQueue<Runnable> in order to 
invoke add() or offer().  First, it is not clear whether this cast will 
be permitted; the whole cast and instanceof business is still a moving 
target in the generics JSR group.  In addition, the cast is potentially 
dangerous.  If the BlockingQueue<? extends Runnable> refers to 
DelayQueue<DelayedTask> for instance, the ThreadPoolExecutor would be 
capable of staffing other types of Runnables into the queue after such a 
cast.  Problems occur later when some uses the DelayQueue<DelayedTask> 
for taking objects from the queue.  The consumer would believe it will 
receive a DelayedTask, but in fact something else might be returned. 
So, yes, this is in principle dangerous.

But ... is it really intended that anybody, except the 
ThreadPoolExecutor itself, manipulates the queue?  From looking at class 
ThreadPoolExecutor and its subclass ScheduledExecutor we understand that 
the ScheduledExecutor provides the queue and the Runnables to be placed 
into the queue.  Insertion and extraction of Runnables to and from the 
queue is exclusively done by the ThreadPoolExcutor.  In this context the 
cast would be perfectly safe, because nobody has any interest in 
extracting DelayedTasks from the queue: the ThreadPoolExcutor does not 
and need not know of DelayedTasks, and the ScheduledExecutor simply does 
not take elements from the queue.  Someone else could take elements from 
the queue (after calling getQueue()), but not through the 
DelayQueue<DelayedTask> interface, because only the ScheduledExecutor 
knows that the BlockingQueue<Runnable> is in fact a 
DelayQueue<DelayedTask>.  Hence it is safe that ThreadPoolExecutor would 
cast from BlockingQueue<? extends Runnable> to BlockingQueue<Runnable>.

However, another subclass of ThreadPoolExecutor might do differently and 
might in fact extract elements from the queue and then we would have a 
problem if someone else staffed "aliens" into the queue.  This hole 
could be closed, though.  We were wondering why the ScheduledExecutor 
creates the queue instead of delegating _all_ responsibility for the 
queue (including its construction) to the ThreadPoolExecutor.  The 
ScheduledExecutor (as well as all other subclasses of 
ThreadPoolExecutor) could provide the type information (e.g. 
BlockingQueue.class) to the ThreadPoolExecutor to enable construction of 
the right type of queue in the ThreadPoolExecutor constructor.  And then 
we would not need the wildcard anymore ...

By and large, the use of wildcards would lead to a fragile solution or 
require a partial redesign of ThreadPoolExecutor and ScheduledExecutor. 
neither or which looks particularly enticing.


The idea of using a wildcard came about when we noticed the "annoying 
wrapper class" DelayedWorkQueue that is used in the ScheduledExecutor in 
order to convince the generics compiler to use a DelayQueue<DelayedTask> 
as a BlockingQueue<Runnable>.  If the ScheduledExecutor would pass a 
DelayQueue<Runnable> to the ThreadPoolExecutor constructor, no wrapper 
class would be needed.  The wrapper class isn't used anywhere in the 
ScheduledExecutor; the ThreadPoolExecutor has no interest in it; so, why 
define it in the first place?  The only thing that we would loose is a 
visible expression of the fact that the DelayQueue is a homogenous queue 
of DelayedTasks.


Any comments?  We've probably been overlooking something ...

Angelika









-- 
----------------------------------------------------------------
Angelika Langer & Klaus Kreft
Email: langer@camelot.de
http://www.langer.camelot.de/
----------------------------------------------------------------


From blanshlu@netscape.net  Sun Aug 17 15:39:15 2003
From: blanshlu@netscape.net (Luke Blanshard)
Date: Sun, 17 Aug 2003 09:39:15 -0500
Subject: [concurrency-interest] wildcards in ThreadPoolExecutor; was:
 problem with CyclicBarrier
In-Reply-To: <3F3F6092.3080709@camelot.de>
References: <Pine.LNX.4.33.0308161235450.2285-100000@bebop.coremedia.com> <3F3E519E.1030805@netscape.net> <3F3F6092.3080709@camelot.de>
Message-ID: <3F3F9393.4030203@netscape.net>

langer@camelot.de wrote:

>> You could make ThreadPoolExecutor itself take a type parameter of <T 
>> extends Runnable>, and then have the queue be over <T>.  This would 
>> have to push all the way back into Executor.  This might be useful.
>
> ...  Parameterizing the with <T extends Runnable> would probably work. 
> The question is just:  is it worth doing?
>
> ...The idea of using a wildcard came about when we noticed the 
> "annoying wrapper class" DelayedWorkQueue that is used in the 
> ScheduledExecutor in order to convince the generics compiler to use a 
> DelayQueue<DelayedTask> as a BlockingQueue<Runnable>.  If the 
> ScheduledExecutor would pass a DelayQueue<Runnable> to the 
> ThreadPoolExecutor constructor, no wrapper class would be needed...

In a nutshell: I think this is why generics have been delayed for so 
many years.  Specifying the types "correctly" is very difficult and 
yields few tangible rewards.

With the Executor interface parameterized, you could declare 
ScheduledExecutor something like this:

    ScheduledExecutor<T extends Runnable>
        extends ThreadPoolExecutor<DelayedTask>
        implements ExecutorService<T>

I say "something like this" because I don't know whether the nested 
class DelayedTask is available to use as part of the type signature of 
the outer class.  It may be -- but I doubt it.

Another option would be to make ScheduledExecutor contain a 
ThreadPoolExecutor instead of extending it.  This would be easier to get 
right, type-wise, but would be annoying.

Luke


From eamonn.mcmanus@sun.com  Mon Aug 18 15:47:44 2003
From: eamonn.mcmanus@sun.com (Eamonn McManus)
Date: Mon, 18 Aug 2003 16:47:44 +0200
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
Message-ID: <16192.59152.797668.143493@oneman.france.sun.com>

Hi,

I've read through the JSR 166 Community Draft with great interest.
It's fantastic to have support for things like thread pools at last!

I do have a number of comments.  My apologies for their terseness, and
also for possible duplication of what has already been discussed on
this mailing list, which I have not been following.

----

Overall comments on definitions:

"weakly consistent", I did not see a definition of exactly what this
means.  The package comment for java.util.concurrent says that a
weakly consistent iterator may or may not reflect any updates since
the iterator was created.  Does this mean that the keySet().iterator()
of a ConcurrentHashMap represents a key set that existed at a
particular moment in time, even if that moment is not necessarily the
moment at which keySet() was called?  Or does it mean that it
represents a key set that could logically have existed, but didn't
necessarily?  Or does it just mean that it represents the key set that
existed when keySet() was called, with some (possibly empty) subset of
the subsequent modifications?  This last option would leave open the
possibility that the same key would appear twice in the iterator, so
presumably it's not so.

"best-effort lower bound", I did not see a definition of this either.
Presumably it means that the wait time is guaranteed to be at least
the specified value, and that a best effort will be made for it to be
no longer than that.

Specific comments on classes and methods:

Delayed interface extends Comparable but doesn't say why.

What does ExecutorService.shutdown() do if it is called a second time?

Sample code in Future: ArchiveSearcher should be an interface.

ExecutionException: "a task that aborted", what does aborted mean?  I
think it means threw an exception (which is the getCause() of the
ExecutionException), in which case it could say that.

ArrayBlockingQueue: "Attempts to offer an element to a full queue will
result in the offer operation blocking", contradicts offer(E) which
says "returning immediately if this queue is full".  Could say "put an
element on a full queue" instead.

CancellableTask.InnerCancellableFuture: I think it will be hard for
anyone to use this class in a subclass of CancellableTask without
either a more complete specification or some sample code.

ConcurrentHashMap: The specification seems to include too much
implementation detail.  Why should it be specified that the
initialCapacity and segments are rounded up to a power of two?  What
does the loadFactor mean when the initialCapacity is rounded up?

ConcurrentHashMap.contains: what is this method for?  It doesn't seem
to add anything to except confusion to containsValue.  I occasionally
call Map.contains in my code, and of course it doesn't compile, but I
wouldn't like to say whether I more often mean containsKey or
containsValue.

CopyOnWriteArrayList.addIfAbsent: "can be used to obtain Set semantics
for lists".  Can't I just use CopyOnWriteArraySet if that's what I
want?  (I guess I'm just saying that this sentence should be deleted.)

CopyOnWriteArrayList: The way the last paragraph of the class comment
is written, you might think that "the only methods throwing
UnsupportedOperationException" includes "one-by-one mutative
operations".  It's reasonably clear from studying the individual
methods that that's not so, but this could be clearer.

CountDownLatch: class comment contains an {@link #await wait}.

CyclicBarrier: typo in class comment: "set [of] threads".

CyclicBarrier: If the barrierAction throws an exception, then the
thread that trips the barrier will get that exception.  But what
happens to the other threads?  Do they get notified of something
strange or do they complete their awaits normally?

Executors: static factory class has default public constructor,
presumably an oversight.

Executors.newSingleThreadExecutor: I think this is equivalent to
newFixedThreadPool(1), and if so the doc could say so.
newSingleThreadExecutor says what happens if there's a failure in
execution prior to shutdown, but newFixedThreadPool doesn't.

Executors.newCachedThreadPool: I was a bit surprised at the hardwired
"60 seconds", though if I understand correctly these methods are
basically wrappers for ThreadPoolExecutor, and you can use that class
directly if you don't like the defaults.  Still, this is perhaps
overspecified.

Semaphore: Not that it matters, but is it really likely that somebody
would need long rather than int for the number of permits?  Perhaps in
FairSemaphore, where permits represent huge chunks of resources?
(E.g., disk blocks.)

FairSemaphore: text copied from Semaphore saying "thread happens to be
chosen" and "threads are blocked...one is selected" is too vague here,
since the thread to be selected is clearly defined.

FairSemaphore.acquire(long): It's not clear what happens if a thread
is interrupted when it has acquired some but not all of the requested
permits.  I think this is what the sentence "Any available permits..."
is trying to say, but if so it should say something like "Any
already-acquired permits".  Likewise for the 3-arg tryAcquire.

ScheduledExecutor: The sentence in the class comment about drift is a
bit alarming.  Does an implementation have to use a DelayQueue?  Does
a DelayQueue implementation necessarily have to drift?  (I.e., can't
it compute the absolute time for each element when the element is
added?)

ScheduledExecutor.afterExecute: Description is incomprehensible on its
own.  I think it is supposed to be added to the description of the
overridden method.

ThreadPoolExecutor.setKeepAliveTime: Throws text refers to "msecs",
should be "time".

ThreadPoolExecutor.getCompletedTaskCount: "the returned value is only
an approximation".  Since the value is monotonically increasing, this
seems unnecessarily weak.  The returned value is presumably at least
the value that was current at the point just before the method was
called.

ThreadPoolExecutor.terminated: Could add the same advice about calling
the superclass method as for beforeExecute and afterExecute.

java.util.concurrent.atomic: Package comment contains a paragraph that
ends with "Finally,", missing the rest of the sentence.

AtomicInteger (etc): getAndIncrement/Decrement, I am not sure that it
is so universally understood that "increment" means "increment by one"
that "by one" should be omitted.  Could just say that
"getAndIncrement" is equivalent to "getAndAdd(+1)" and likewise for
Decrement.

AtomicBoolean.compareAndSet: contains text about spurious failure that
surely belongs in weakCompareAndSet?

Atomic*FieldUpdater: factory methods newUpdater all say "The Class
constructor argument(s)", but they are not constructors.  Apparently a
hold-over from an earlier version when they were.

Atomic*FieldUpdater.weakCompareAndSet: Doesn't include any text about
spurious failures and so is apparently equivalent to plain
compareAndSet.

AtomicMarkableReference: "This implementation maintains marked
references by internally "boxing" ..."  It's not perfectly clear
what's meant by boxing (though I can guess), but I think the sentence
should just be removed.  What difference does it make?  Likewise
AtomicStampedReference.

Lock: Text says that one of the advantages of Lock over "synchronized"
is that it doesn't have to be block-structured.  However if you want
to use try-finally then it *does* have to be block-structured.  And if
you *don't* use try-finally, then how do you recover from Errors?
E.g. if you get an OutOfMemoryError or LinkageError, say, during part
of your hand-over-hand logic that is not covered by a try-finally, how
are you going to get back into a consistent state?  Crashing out of
your application seems a bit brutal, and anything else is going to be
a huge mess of special-case logic.  This purported advantage seems a
little bit bogus compared to the other cited advantages.

Lock.newCondition: Does not explicitly say that every successful call
returns a different instance, which I think is the intent.

LockSupport: has a public constructor, apparently inadvertent.

LockSupport.park: The text says LockSupport is "useful only for those
developers implementing their own customized lock classes".  However,
as far as I can see, the fact that park() can either work or not work,
without any indication of which, means that this class is not useful
even to those developers.  I think what I'm getting at here is that
this class isn't precise enough to be useful.

ReentrantLock.tryLock: no-arg version says it doesn't respect
fairness.  Is that also true of the timeout version?

ReentrantLock: Class comment says getHoldCount can be used to make
non-reentrant locks from reentrant ones, but getHoldCount's own doc
says it is "typically only used for testing and debugging purposes".

ReentrantLock.isLocked: "This method is designed for use in
monitoring", the word "monitoring" is too ambiguous, and too close to
Java monitors in the "synchronized" sense.  I think what is meant is
that it is to be used for statistics, e.g. about lock contention, but
cannot be used for synchronization logic.

ReentrantReadWriteLock: In class comment, bullet item "Acquisition
order", the sentence "If readers are active and a writer
arrives..." is a separate paragraph.  Do I correctly interpret this as
meaning that it is always true, regardless of whether fairness has
been called for?  Perhaps this could be made explicit.

----

Anyway, thanks a lot for all the great work!  I hope these comments
are useful.

Regards,
-- 
amonn McManus, Sun JMX group


From dl@cs.oswego.edu  Tue Aug 19 00:33:24 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 18 Aug 2003 19:33:24 -0400
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <16192.59152.797668.143493@oneman.france.sun.com>
References: <16192.59152.797668.143493@oneman.france.sun.com>
Message-ID: <16193.25156.733963.550719@altair.cs.oswego.edu>

Hi Eamonn,

Thanks VERY much for the careful reading! We'll fix/improve the
specs and documentation. 

Most of your embedded questions are better answered by clarifying
wordings, but here are two that might not be:

> Semaphore: Not that it matters, but is it really likely that somebody
> would need long rather than int for the number of permits?  Perhaps in
> FairSemaphore, where permits represent huge chunks of resources?
> (E.g., disk blocks.)

Empirically, you can't measure the performance difference between
implmentations based on longs and ints here on the usual platforms, so
there's no motivation not to use the widest form, just in case someone
does need it someday. (But to be honest, this is mostly a remnant of
my not-very-fun experience many years ago debugging problems caused by
an 8-bit semaphore that wrapped around, and desire to spare others of
such agony.)

> AtomicMarkableReference: "This implementation maintains marked
> references by internally "boxing" ..."  It's not perfectly clear
> what's meant by boxing (though I can guess), but I think the sentence
> should just be removed.  What difference does it make?  Likewise
> AtomicStampedReferenc

We'll improve wording, but the difference is that heavy use will cause
lots of garbage collection. (We hope/believe that future
implmentations will not do this, which is why the statement is left as
an implementation note. More generally, we use "implementation notes"
to describe inessential but notable properties of the reference
implmentation that might be expected to change over time.

-Doug


From dholmes@dltech.com.au  Tue Aug 19 01:20:06 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 19 Aug 2003 10:20:06 +1000
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <16192.59152.797668.143493@oneman.france.sun.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEDMDGAA.dholmes@dltech.com.au>

Eamonn,

Thank you for the detailed comments, it is very much appreciated. I'd
just like to respond to a couple of point you made:

(I see Doug just beat me to it, but I'll still discuss a couple of
things anyway :) )

> ArrayBlockingQueue: "Attempts to offer an element to a full
> queue will result in the offer operation blocking",
> contradicts offer(E) which says "returning immediately if this
> queue is full".  Could say "put an element on a full queue" instead.

Well spotted. That sentence is part of some legacy docs that I
overlooked updating.

> Lock: Text says that one of the advantages of Lock over
> "synchronized" is that it doesn't have to be block-structured.
> However if you want to use try-finally then it *does* have to be
> block-structured.  And if you *don't* use try-finally, then how do
you
> recover from Errors?

First, with the dropping of Condition support for built-in locks, the
use cases for Locks have increased to include all those where you want
multiple conditions per lock. So non-block-structured locking is no
longer the single dominant use-case and we'll update the docs.

The simple use of try-finally that we show does require/use
block-structure.

However, you can must still use try-finally, or try-catch to deal with
errors even if the lock/unlock are not in the same block; it means you
need multiple try-finally/try-catch blocks, but all code must be
covered to ensure that you can recover from errors. Correct error
handling does greatly complicate the use of locks in a
non-block-structured way. (And meaningful examples tend to be far too
long for doc comments unfortunately).

> E.g. if you get an OutOfMemoryError or LinkageError, say,
> during part of your hand-over-hand logic that is not covered by a
> try-finally, how are you going to get back into a consistent state?

The code must be covered by a try-finally/try-catch to ensure this
can't happen.

> LockSupport.park: The text says LockSupport is "useful only
> for those developers implementing their own customized lock
classes".
> However, as far as I can see, the fact that park() can either work
> or not work, without any indication of which, means that this class
is
> not useful even to those developers.
> I think what I'm getting at here is that
> this class isn't precise enough to be useful.

park() is similar in some respects to a semaphore wait: you don't know
before hand whether or not you'll actually block, and you can't tell
afterwards if you actually did. As with semaphores park/unpark must be
used in such a way that it's not necessary to know whether or not you
blocked - you simply know that if you get past the "gate" then it's
okay to proceed with what you were doing. Your use of park/unpark in a
particular context must ensure that this is actually the case.

Thanks again.

David Holmes



From eamonn.mcmanus@sun.com  Tue Aug 19 11:05:32 2003
From: eamonn.mcmanus@sun.com (Eamonn McManus)
Date: Tue, 19 Aug 2003 12:05:32 +0200
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEDMDGAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCIEDMDGAA.dholmes@dltech.com.au>
Message-ID: <3F41F66C.90509@sun.com>

David,

Thanks for these explanations.  A couple more comments...

David Holmes wrote:
[...]
> The simple use of try-finally that we show does require/use
> block-structure.
> 
> However, you can must still use try-finally, or try-catch to deal with
> errors even if the lock/unlock are not in the same block; it means you
> need multiple try-finally/try-catch blocks, but all code must be
> covered to ensure that you can recover from errors. Correct error
> handling does greatly complicate the use of locks in a
> non-block-structured way. (And meaningful examples tend to be far too
> long for doc comments unfortunately).
> 
> 
>>E.g. if you get an OutOfMemoryError or LinkageError, say,
>>during part of your hand-over-hand logic that is not covered by a
>>try-finally, how are you going to get back into a consistent state?
> 
> 
> The code must be covered by a try-finally/try-catch to ensure this
> can't happen.

OK, so this is a bit far-fetched, but in principle you can get a 
VirtualMachineError such as InternalError or UnknownError between one 
try block and the next.  Arguably you are completely screwed if you ever 
get one of those errors, but then why do they exist?

>>LockSupport.park: The text says LockSupport is "useful only
>>for those developers implementing their own customized lock
> 
> classes".
> 
>>However, as far as I can see, the fact that park() can either work
>>or not work, without any indication of which, means that this class
> 
> is
> 
>>not useful even to those developers.
>>I think what I'm getting at here is that
>>this class isn't precise enough to be useful.
> 
> 
> park() is similar in some respects to a semaphore wait: you don't know
> before hand whether or not you'll actually block, and you can't tell
> afterwards if you actually did. As with semaphores park/unpark must be
> used in such a way that it's not necessary to know whether or not you
> blocked - you simply know that if you get past the "gate" then it's
> okay to proceed with what you were doing. Your use of park/unpark in a
> particular context must ensure that this is actually the case.

Well, I still don't think this is terribly clear.  The text says that 
park can return for "no reason".  I don't think the documentation 
explains what the method does or how it is meant to be used.  So, I 
don't see how a programmer can use this class without knowing something 
outside the spec.

Regards,
-- 
amonn


From dl@cs.oswego.edu  Tue Aug 19 12:11:06 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 19 Aug 2003 07:11:06 -0400
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <3F41F66C.90509@sun.com>
References: <NFBBKALFDCPFIDBNKAPCIEDMDGAA.dholmes@dltech.com.au>
 <3F41F66C.90509@sun.com>
Message-ID: <16194.1482.274679.901521@altair.cs.oswego.edu>

> The text says that 
> park can return for "no reason".  I don't think the documentation 
> explains what the method does or how it is meant to be used.  
> 

Right. The spec can't teach people how to build good synchronization
constructs on modern (especially multiprocessor) systems.  We'll still
make intent clearer though: To better convey the tradeoff vs the
useless/deprecate Thread.suspend/resume -- that park/unpark can be
used to ensure lack of liveness failuress in higher-level
constructions at the price of dealing with possibly spurious wakeups
inside their implementations.  This is tricky to spec. Like
Thread.yield and Thread.setPriority, "no-op" is a legal but
mean-spirited implementation of park; a reasonable implementation will
minimize wakeups not directly caused by unparks or interrupts.
Suggestions welcome.

I also just added an example adapted from David and my tutorial (to
next be presented at OOPSLA, and that will probably someday make its
way into a revised edition of my CPJ book):


 * <p><b>Sample Usage.</b> Here is a sketch of a First-in-first-out
 * non-reentrant lock class that should be made more efficient
 * and complete to be useful in practice, but illustrates basic usage.
 * <pre>
 * class FIFOMutex {
 *   private AtomicBoolean locked = new AtomicBoolean(false);
 *   private Queue<Thread> waiters = new ConcurrentLinkedQueue<Thread>();
 *
 *   public void lock() { 
 *     boolean wasInterrupted = false;
 *     Thread current = Thread.currentThread();
 *     waiters.add(current);
 *
 *     while(waiters.peek() != current || 
 *           !locked.compareAndSet(false, true)) { 
 *        LockSupport.park();
 *        if (Thread.interrupted()) // ignore interrupts while waiting
 *          wasInterrupted = true;
 *     }
 *     waiters.poll();
 *     if (wasInterrupted)          // reassert interrupt status on exit
 *        current.interrupt();
 *   }
 *
 *   public void unlock() {
 *     locked.set(false);
 *     LockSupport.unpark(waiters.peek());
 *   } 
 * }
 * </pre>

-Doug

From dholmes@dltech.com.au  Wed Aug 20 00:03:08 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 20 Aug 2003 09:03:08 +1000
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <3F41F66C.90509@sun.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEEIDGAA.dholmes@dltech.com.au>

> OK, so this is a bit far-fetched, but in principle you can get a
> VirtualMachineError such as InternalError or UnknownError
> between one try block and the next.  Arguably you are completely
> screwed if you ever get one of those errors, but then why do they
exist?

Why do they exist? My guess is that they "seemed like a good idea at
the time" ;-) But I've never seen one thrown - any
"VirtualMachineError" I've had causes a dump from the C code.

Such asynchronous exceptions are impossible to deal with, by any
means, if they occur. And if they do occur it means your VM is hosed
anyway so nothing you could ask it to do via a finally clause could be
relied upon.

Cheers,
David Holmes


From jhayes2@oswego.oswego.edu  Wed Aug 20 00:41:14 2003
From: jhayes2@oswego.oswego.edu (Jeff Hayes)
Date: Tue, 19 Aug 2003 19:41:14 -0400
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
References: <NFBBKALFDCPFIDBNKAPCEEEIDGAA.dholmes@dltech.com.au>
Message-ID: <000801c366ab$614ccdd0$0200a8c0@Babylon>

Consider for a minute, the alternatives.

Silent destruction of the VM or silently continuing VM execution, either of
those is simply not a reasonable option, without at the very least a
notification to the programmer/user. Even if you are screwed after any of
those errors, you are alerted that your VM is failing or there is something
really wrong with your system, very useful things to know.

----- Original Message -----
From: "David Holmes" <dholmes@dltech.com.au>
To: "Eamonn McManus" <eamonn.mcmanus@sun.com>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Tuesday, August 19, 2003 7:03 PM
Subject: RE: [concurrency-interest] Comments on JSR 166 Community Draft


> > OK, so this is a bit far-fetched, but in principle you can get a
> > VirtualMachineError such as InternalError or UnknownError
> > between one try block and the next.  Arguably you are completely
> > screwed if you ever get one of those errors, but then why do they
> exist?
>
> Why do they exist? My guess is that they "seemed like a good idea at
> the time" ;-) But I've never seen one thrown - any
> "VirtualMachineError" I've had causes a dump from the C code.
>
> Such asynchronous exceptions are impossible to deal with, by any
> means, if they occur. And if they do occur it means your VM is hosed
> anyway so nothing you could ask it to do via a finally clause could be
> relied upon.
>
> Cheers,
> David Holmes
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From eamonn.mcmanus@sun.com  Wed Aug 20 16:20:44 2003
From: eamonn.mcmanus@sun.com (Eamonn McManus)
Date: Wed, 20 Aug 2003 17:20:44 +0200
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <16194.1482.274679.901521@altair.cs.oswego.edu>
References: <NFBBKALFDCPFIDBNKAPCIEDMDGAA.dholmes@dltech.com.au>	<3F41F66C.90509@sun.com> <16194.1482.274679.901521@altair.cs.oswego.edu>
Message-ID: <3F4391CC.1080907@sun.com>

Doug,

LockSupport is much much clearer with that example!  I guess I wasn't 
picking up on the notion of thread parking clearly enough.

If I understand the intent correctly, how about this text in the doc 
comment for the class file:

     <p>This class associates with each Thread a single
     <em>permit</em>, in the sense of the {@link Semaphore}
     class.  Any given thread starts without the permit.  The
     {@link #unpark(Thread)} method grants the target thread
     its permit, if it does not already have it.  The various
     <code>park</code> methods consume the calling thread's
     permit if present, and otherwise block until the permit
     is granted, then consume it.  However, they may also
     return prematurely without the permit having been
     granted.  Thus, callers must check that the condition
     that was being waited for has in fact been met.  Another
     way of looking at this is that it is as if an unknown
     thread can arbitrarily grant permits at any time.</p>

-- 
amonn

Doug Lea wrote:
>>The text says that 
>>park can return for "no reason".  I don't think the documentation 
>>explains what the method does or how it is meant to be used.  
>>
> 
> 
> Right. The spec can't teach people how to build good synchronization
> constructs on modern (especially multiprocessor) systems.  We'll still
> make intent clearer though: To better convey the tradeoff vs the
> useless/deprecate Thread.suspend/resume -- that park/unpark can be
> used to ensure lack of liveness failuress in higher-level
> constructions at the price of dealing with possibly spurious wakeups
> inside their implementations.  This is tricky to spec. Like
> Thread.yield and Thread.setPriority, "no-op" is a legal but
> mean-spirited implementation of park; a reasonable implementation will
> minimize wakeups not directly caused by unparks or interrupts.
> Suggestions welcome.
> 
> I also just added an example adapted from David and my tutorial (to
> next be presented at OOPSLA, and that will probably someday make its
> way into a revised edition of my CPJ book):
> 
> 
>  * <p><b>Sample Usage.</b> Here is a sketch of a First-in-first-out
>  * non-reentrant lock class that should be made more efficient
>  * and complete to be useful in practice, but illustrates basic usage.
>  * <pre>
>  * class FIFOMutex {
>  *   private AtomicBoolean locked = new AtomicBoolean(false);
>  *   private Queue<Thread> waiters = new ConcurrentLinkedQueue<Thread>();
>  *
>  *   public void lock() { 
>  *     boolean wasInterrupted = false;
>  *     Thread current = Thread.currentThread();
>  *     waiters.add(current);
>  *
>  *     while(waiters.peek() != current || 
>  *           !locked.compareAndSet(false, true)) { 
>  *        LockSupport.park();
>  *        if (Thread.interrupted()) // ignore interrupts while waiting
>  *          wasInterrupted = true;
>  *     }
>  *     waiters.poll();
>  *     if (wasInterrupted)          // reassert interrupt status on exit
>  *        current.interrupt();
>  *   }
>  *
>  *   public void unlock() {
>  *     locked.set(false);
>  *     LockSupport.unpark(waiters.peek());
>  *   } 
>  * }
>  * </pre>
> 
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl@cs.oswego.edu  Fri Aug 22 14:27:34 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 22 Aug 2003 09:27:34 -0400
Subject: [concurrency-interest] jsr166 status
In-Reply-To: <3F45C3A9.80702@cs.york.ac.uk>
References: <3F45C3A9.80702@cs.york.ac.uk>
Message-ID: <16198.6726.893577.129182@altair.cs.oswego.edu>

Hi Andy,

I hope you don't mind my CC'ing reply to the concurrency-interest list
(http://gee.cs.oswego.edu/dl/concurrency-interest/index.html)
since some of the answers serve as a general status update.

> 1) Will the java.util.concurrent definitely appear in JDK 1.5? 

It is as definite as any other 1.5 JSR. It still needs to finish going
through JCP process and Sun engineering process (for the Sun J2SE 1.5
"Tiger" release), but we are approximately on schedule for both.

> If so, are
>      you anticipating may changes from the current JSR 166?

We think/hope that there will not be any major changes. We will
continue to improve specs and code, especially as guided by feedback
through JCP process, the concurrency-interests list, experiences with
pre-releases, etc, which will probably also result in a trickle of
various small API changes.

> 
> 2) Can I assume that there will be a new version of your book that will
>     appear which covers the utilities? 

That's my hope. Note though that most classes are refinements and
refactorings of those discussed in the second edition, so most
revisions will probably be more a matter of expanded and improved
coverage rather than purely new content.

>     Do you have a timescale for the book?

I'm shooting for release around next spring. I'll probably have a
better estimate once I actually start doing it!

> 
> 3) Do you think the specification of the utilities will change much to 
> reflect generics
>      and enumeration types?

We use generics extensively, but not the other JSR-201 syntax
enhancements. There are a couple of very small things that might be
made nicer with enums, which we might do,

> 
> 4) I get the impression from looking at the utilities that many of them 
> have to
>      use native methods and, therefore, as such cannot be implemented in 
> Java alone.

While it might appear otherwise, there are only three intrinsically
native/JVM-level aspects of JSR-166. While I'm at it, I'll annotate
with a few remarks directed toward implmementors.

  1. System.nanoTime
     This is designed to map easily onto the
     highest-precision timing available on a given platform.
     A version of this will also be exported at the "native" (C) API
     level via JSR-163, the monitoring and profiling API (http://jcp.org)

  2. java.util.concurrent.locks.LockSupport.{park,unpark}
     "Replacements" for Thread suspend/resume.
     Note: These need not (and are not spec'ed to) be exported at
     native/C level. The usage and semantics are designed to make
     them efficiently mappable onto just about any underlying
     blocking primitive, including posix condvars, various kinds of OS
     semaphores, Win32 Events, linux NPTL, etc.

  3. java.util.concurrent.atomics
     The JVM must be able to arrange a conditional atomic update on
     just about any field of just about any object.  This is
     translated to Java level in various ways in the classes in
     java.util.concurrent.atomic. On LL/SC hardware, weakCompareAndSet
     would probably be the VM primitive, and the normal compareAndSet
     built from it. On CAS-based, they are the same.  Conceptually,
     CAS acts as a new bytecode, but since we can't add a bytecode, it
     is exposed in this slightly quirky fashion. Different JVMs will
     probably go about implementing this very differently.  In hotspot
     it uses an internal intriniscs extension API.

While hotspot will be the reference implementation, we would be very
pleased to help other JVM implementors figure out how to go about this
support. (in fact, if we could, we would require that all JVM
implementors get in touch with us, so we could be more confident that
everyone gets it right!)

It probably seems that there is more native support than actually
present because JSR-166 is a layered API.  LockSupport and atomics are
designed to be used by only hundreds, not millions of programmers, but
their existence allows developers to build up new synchronization
utilities so we won't have to keep adding more of them into j.u.c
itself. For example, ReentrantLock is a built from these primitives,
and is used to build various Queues, which are used to build various
Executors, etc. Given the available primitives, it should be equally
possible to efficiently support different kinds of frameworks with a
look-and-feel similar to, say, Ada, Win32, or pure POSIX. We also
expect frameworks supporting tighter integeration with nio to be
introduced into J2SE someday (for example, async-IO via special
Executors.)

> 5) Is it possible for the web site to have a single pdf file with the 
> definitions in.

It is simple for us to make zip file snapshots of the html, which are
probably more convenient to browse than pdf.  I'll start doing this
regularly.  

That, and also (as I promised in a post last week) CVS source
repository viewing (via "viewcvs") are now available from
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

-Doug


From andy@cs.york.ac.uk  Fri Aug 22 15:13:52 2003
From: andy@cs.york.ac.uk (Andy Wellings)
Date: Fri, 22 Aug 2003 15:13:52 +0100
Subject: [concurrency-interest] jsr166 status
References: <3F45C3A9.80702@cs.york.ac.uk> <16198.6726.893577.129182@altair.cs.oswego.edu>
Message-ID: <3F462520.5020407@cs.york.ac.uk>

Thanks Doug.

Just to push you on one issue.

>>4) I get the impression from looking at the utilities that many of them 
>>have to
>>     use native methods and, therefore, as such cannot be implemented in 
>>Java alone.
>>
>
>While it might appear otherwise, there are only three intrinsically
>native/JVM-level aspects of JSR-166. While I'm at it, I'll annotate
>with a few remarks directed toward implmementors.
>
>  ...
>
>  2. java.util.concurrent.locks.LockSupport.{park,unpark}
>     "Replacements" for Thread suspend/resume.
>     Note: These need not (and are not spec'ed to) be exported at
>     native/C level. The usage and semantics are designed to make
>     them efficiently mappable onto just about any underlying
>     blocking primitive, including posix condvars, various kinds of OS
>     semaphores, Win32 Events, linux NPTL, etc.
>
> .....
>

I accept that, but does it mean that LockSupport cannot be implemented just
in Java, or are park and unpark just for efficiency?

Andy



-- 
Professor A.J. Wellings 
Department of Computer Science
University of York
Heslington
York 
YO10 5DD
UK




From dl@cs.oswego.edu  Fri Aug 22 15:35:03 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 22 Aug 2003 10:35:03 -0400
Subject: [concurrency-interest] jsr166 status
In-Reply-To: <3F462520.5020407@cs.york.ac.uk>
References: <3F45C3A9.80702@cs.york.ac.uk>
 <16198.6726.893577.129182@altair.cs.oswego.edu>
 <3F462520.5020407@cs.york.ac.uk>
Message-ID: <16198.10775.645598.11278@altair.cs.oswego.edu>

> 
> I accept that, but does it mean that LockSupport cannot be implemented just
> in Java, or are park and unpark just for efficiency?

Oh, sorry for not mentioning that they are indeed emulatable.

For park/unpark, you can keep a ThreadLocal associated with each
thread, and do Object.wait/notify on it.

It is legal (but not at all nice!) to emulate System.nanoTime()
as "{ return System.currentTimeMillis() * 1000000; }"

The atomics can be emulated with builtin locks, although doing this
right for the AtomicXFieldUpdaters would be incredibly slow
since every access would involve both reflection and synchronization

Our emulation version in PR2 did things along these lines. But even
with some internal accomodations to eliminate the worst of these
overheads, was way too slow for serious use.

-Doug



From ggregory@seagullsw.com  Fri Aug 22 17:19:41 2003
From: ggregory@seagullsw.com (Gary Gregory)
Date: Fri, 22 Aug 2003 12:19:41 -0400
Subject: [concurrency-interest] jsr166 status
Message-ID: <245A7290F0E0D311BF6E009027E7908B072047DE@atlanta.seagullsw.com>

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C368C9.31123D60
Content-Type: text/plain

" We will
> continue to improve specs and code, especially as guided by feedback
> through JCP process, the concurrency-interests list, experiences with
> pre-releases, etc, which will probably also result in a trickle of
> various small API changes."

And if I may: Javadoc, Javadoc, Javadoc. 

Gary

------_=_NextPart_001_01C368C9.31123D60
Content-Type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="Generator" CONTENT="MS Exchange Server version 5.5.2654.45">
<TITLE>RE: [concurrency-interest] jsr166 status</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=2>&quot; We will</FONT>
<BR><FONT SIZE=2>&gt; continue to improve specs and code, especially as guided by feedback</FONT>
<BR><FONT SIZE=2>&gt; through JCP process, the concurrency-interests list, experiences with</FONT>
<BR><FONT SIZE=2>&gt; pre-releases, etc, which will probably also result in a trickle of</FONT>
<BR><FONT SIZE=2>&gt; various small API changes.&quot;</FONT>
</P>

<P><FONT SIZE=2>And if I may: Javadoc, Javadoc, Javadoc. </FONT>
</P>

<P><FONT SIZE=2>Gary</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C368C9.31123D60--

From dl@cs.oswego.edu  Mon Aug 25 00:54:30 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 24 Aug 2003 19:54:30 -0400
Subject: [concurrency-interest] Comments on JSR 166 Community Draft
In-Reply-To: <16192.59152.797668.143493@oneman.france.sun.com>
References: <16192.59152.797668.143493@oneman.france.sun.com>
Message-ID: <16201.20534.514563.496228@altair.cs.oswego.edu>

Hi Eamonn,

Our response to one of your comments deserves some further explanation:

> ScheduledExecutor: The sentence in the class comment about drift is a
> bit alarming.  Does an implementation have to use a DelayQueue?  Does
> a DelayQueue implementation necessarily have to drift?  (I.e., can't
> it compute the absolute time for each element when the element is
> added?)

This was exactly the feedback we needed to decide to remove the
java.util.Date-based methods from ScheduledExecutor!  We had
previously decided to keep them with that caveat, but it seems that we
are just asking for trouble. As the javadoc now says:

  All schedule methods accept relative delays and periods as
  arguments, not absolute times or dates. It is a simple matter to
  transform an absolute time represented as a java.util.Date, to the
  required form. For example, to schedule at a certain future date,
  you can use: schedule(task, date.getTime() -
  System.currentTimeMillis(), TimeUnit.MILLISECONDS). Beware however
  that expiration of a relative delay need not coincide with the
  current Date at which the task is enabled due to network time
  synchronization protocols, clock drift, or other factors.


People do in fact get themselves into trouble because of NTP,
system-clock adustments, and the like. (There are unfixable "bug
reports" filed for java.util.Timer on this.) We'd rather make people
go through the inconvenience of manually converting to relative form
and thus conciously choosing to ignore possible problems if they so
desire. (A classic "don't-blame-us!" library design ploy :-)

The main underlying issue here is that System.currentTimeMillis will
on most (all?) systems reflect time-of-day clock adjustments, but
ongoing timed delays and System.nanoTime are typically not affected.

-Doug


