From matthias.ernst at coremedia.com  Fri Jul  1 01:42:21 2005
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Fri Jul  1 01:42:32 2005
Subject: [concurrency-interest] Locks with try/finally
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F635FEC@MARS.coremedia.com>

Hi,

this pattern is not specific to j.u.concurrent api but is the right way to deal with try-finally. With files, sql connections, ... I always do:

<open resource>
try {

} finally {
  <close resource>
}

If <open resource> returns a value, like with #getConnection,
the compiler's flow control will do the reasoning for you:

Connection connection;
try {
  connection = ds.getConnection();
} finally {
  connection.close();
}

will give you an error: if #getConnection fails, connection will not have been assigned.


Matthias
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050701/05cd5efc/attachment.htm
From nikolai at ifad.dk  Fri Jul  1 10:57:43 2005
From: nikolai at ifad.dk (Nikolai V. Chr.)
Date: Fri Jul  1 11:03:15 2005
Subject: [concurrency-interest] Synchronizing on AtomicBoolean safe?
In-Reply-To: <42C4274B.4000305@peierls.net>
References: <42C2B262.7020601@ifad.dk> <42C2CCA4.8080000@peierls.net>
	<42C3FA45.6040806@ifad.dk> <42C408F0.4050201@peierls.net>
	<42C4133A.9000508@ifad.dk> <42C4274B.4000305@peierls.net>
Message-ID: <42C559E7.6080209@ifad.dk>

Tim Peierls wrote:

> But could you explain why you think you need that synchronized block 
> in the first place?

I am not sure, did not design the code, guess it is not really needed. 
Found out that the only other method using the boolean is a get method 
in same class.

But thanks for the reply.

-- 
Nikolai V. Christensen, Computer Engineer,
Simulation and Training department
IFAD TS A/S, ?stre stationsvej 43 2.tv, DK-5000 Odense C
Denmark, EU
Phone: +45 63 11 02 11  Fax: +45 65 93 29 99
WWWeb: http://www.ifad.dk
e-mail: Nikolai.V.Christensen@ifad.dk
--


From nikolai at ifad.dk  Fri Jul  1 10:59:50 2005
From: nikolai at ifad.dk (Nikolai V. Chr.)
Date: Fri Jul  1 11:03:16 2005
Subject: [concurrency-interest] How do I replicate these
	in	java.util.concurrent
In-Reply-To: <42C420EE.1040307@cs.oswego.edu>
References: <42C4143E.2050007@ifad.dk> <42C420EE.1040307@cs.oswego.edu>
Message-ID: <42C55A66.3040106@ifad.dk>

Doug Lea wrote:
....


Thank you! Was very helpful info.

In fact I think you should put it on your website, calling it something 
like: How to migrate to java.util.concurrent or something. :)


Regards
Nikolai

-- 
Nikolai V. Christensen, Computer Engineer,
Simulation and Training department
IFAD TS A/S, ?stre stationsvej 43 2.tv, DK-5000 Odense C
Denmark, EU
Phone: +45 63 11 02 11  Fax: +45 65 93 29 99
WWWeb: http://www.ifad.dk
e-mail: Nikolai.V.Christensen@ifad.dk
--


From dholmes at dltech.com.au  Fri Jul  1 11:15:00 2005
From: dholmes at dltech.com.au (David Holmes)
Date: Fri Jul  1 11:15:13 2005
Subject: [concurrency-interest] How do I replicate
	thesein	java.util.concurrent
In-Reply-To: <42C55A66.3040106@ifad.dk>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEHIFOAA.dholmes@dltech.com.au>

Nikolai V. Chr. wrote:
> In fact I think you should put it on your website, calling it something
> like: How to migrate to java.util.concurrent or something. :)

Indeed! In fact we had a similar request for a "migration guide" at JavaOne.
Our response was to post here to ask :) but a simple guide would be nice.

Cheers,
David

From David.Biesack at sas.com  Fri Jul  1 13:35:22 2005
From: David.Biesack at sas.com (David J. Biesack)
Date: Fri Jul  1 13:35:32 2005
Subject: [concurrency-interest] How do I replicate these in
	java.util.concurrent
In-Reply-To: <200507011600.j61G09EC009627@altair.cs.oswego.edu>
	(concurrency-interest-request@cs.oswego.edu)
References: <200507011600.j61G09EC009627@altair.cs.oswego.edu>
Message-ID: <200507011735.j61HZM103559@mozart.unx.sas.com>

> Date: Fri, 01 Jul 2005 16:59:50 +0200
> From: "Nikolai V. Chr." <nikolai@ifad.dk>
> Subject: Re: [concurrency-interest] How do I replicate these in java.util.concurrent
> Message-ID: <42C55A66.3040106@ifad.dk>
> 
> Doug Lea wrote:
> ....
> 
> Thank you! Was very helpful info.
> 
> In fact I think you should put it on your website, calling it something 
> like: How to migrate to java.util.concurrent or something. :)
> 
> Regards
> Nikolai

If you jump over to http://www.jdocs.com/concurrent/1.3.4/api/index.html you will find that you can annotate the Javadoc for this API (and other API's). I added some of this migration information there; view http://www.jdocs.com/rss/recentMessages.jsp?shortname=concurrent&version=1.3.4 in an RSS reader.

Unfortunately, there is no way to add an annotation to the top level package.html to point to java.util.concurrent (although Doug does mention it at the very bottom).

It's not as ideal as actually having the migration info in the main distribution, but it may suffice.

-- 
David J. Biesack     SAS Institute Inc.
(919) 531-7771       SAS Campus Drive
http://www.sas.com   Cary, NC 27513

From David.Biesack at sas.com  Fri Jul  1 13:35:22 2005
From: David.Biesack at sas.com (David J. Biesack)
Date: Fri Jul  1 13:35:37 2005
Subject: [concurrency-interest] How do I replicate these in
	java.util.concurrent
In-Reply-To: <200507011600.j61G09EC009627@altair.cs.oswego.edu>
	(concurrency-interest-request@cs.oswego.edu)
References: <200507011600.j61G09EC009627@altair.cs.oswego.edu>
Message-ID: <200507011735.j61HZM103559@mozart.unx.sas.com>

> Date: Fri, 01 Jul 2005 16:59:50 +0200
> From: "Nikolai V. Chr." <nikolai@ifad.dk>
> Subject: Re: [concurrency-interest] How do I replicate these in java.util.concurrent
> Message-ID: <42C55A66.3040106@ifad.dk>
> 
> Doug Lea wrote:
> ....
> 
> Thank you! Was very helpful info.
> 
> In fact I think you should put it on your website, calling it something 
> like: How to migrate to java.util.concurrent or something. :)
> 
> Regards
> Nikolai

If you jump over to http://www.jdocs.com/concurrent/1.3.4/api/index.html you will find that you can annotate the Javadoc for this API (and other API's). I added some of this migration information there; view http://www.jdocs.com/rss/recentMessages.jsp?shortname=concurrent&version=1.3.4 in an RSS reader.

Unfortunately, there is no way to add an annotation to the top level package.html to point to java.util.concurrent (although Doug does mention it at the very bottom).

It's not as ideal as actually having the migration info in the main distribution, but it may suffice.

-- 
David J. Biesack     SAS Institute Inc.
(919) 531-7771       SAS Campus Drive
http://www.sas.com   Cary, NC 27513

From nikolai at ifad.dk  Mon Jul  4 02:52:44 2005
From: nikolai at ifad.dk (Nikolai V. Chr.)
Date: Mon Jul  4 02:52:49 2005
Subject: [concurrency-interest] double to long
Message-ID: <42C8DCBC.9080600@ifad.dk>

I am writing a AtomicDouble class.

I would like to know if these two produce the same result:

double initialValue;
a = Double.doubleToLongBits(initialValue);
b = (long) initialValue;

Regards
Nikolai

-- 
Nikolai V. Christensen, Computer Engineer,
Simulation and Training department
IFAD TS A/S, ?stre stationsvej 43 2.tv, DK-5000 Odense C
Denmark, EU
Phone: +45 63 11 02 11  Fax: +45 65 93 29 99
WWWeb: http://www.ifad.dk
e-mail: Nikolai.V.Christensen@ifad.dk
--


From joe.bowbeer at gmail.com  Mon Jul  4 06:48:55 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon Jul  4 06:49:05 2005
Subject: [concurrency-interest] double to long
In-Reply-To: <42C8DCBC.9080600@ifad.dk>
References: <42C8DCBC.9080600@ifad.dk>
Message-ID: <31f2a7bd0507040348345637ea@mail.gmail.com>

On 7/3/05, Nikolai V. Chr. <nikolai@ifad.dk> wrote:
> 
> I would like to know if these two produce the same result:
> 
> double initialValue;
> a = Double.doubleToLongBits(initialValue);
> b = (long) initialValue;
> 

Nope.

See http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Double.html

a is the IEEE bits
b is the truncated/rounded long value

Btw,

new Double(initialValue).longValue() == (long) initialValue

From nikolai at ifad.dk  Mon Jul  4 07:21:38 2005
From: nikolai at ifad.dk (Nikolai V. Chr.)
Date: Mon Jul  4 07:21:43 2005
Subject: [concurrency-interest] double to long
In-Reply-To: <31f2a7bd0507040348345637ea@mail.gmail.com>
References: <42C8DCBC.9080600@ifad.dk>
	<31f2a7bd0507040348345637ea@mail.gmail.com>
Message-ID: <42C91BC2.6070309@ifad.dk>

Joe Bowbeer wrote:

>
>Nope.
>  
>
thank you.

-- 
Nikolai V. Christensen, Computer Engineer,
Simulation and Training department
IFAD TS A/S, ?stre stationsvej 43 2.tv, DK-5000 Odense C
Denmark, EU
Phone: +45 63 11 02 11  Fax: +45 65 93 29 99
WWWeb: http://www.ifad.dk
e-mail: Nikolai.V.Christensen@ifad.dk
--


From yechielf at gigaspaces.com  Tue Jul  5 09:53:07 2005
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Tue Jul  5 08:48:34 2005
Subject: [concurrency-interest] a question regarding blocking threads
Message-ID: <D166C96F43D1D611B8E3000255A0C48C6BE20E@OFFICESRV>

Hi
Is there any mechanism  that JVMs use  in order  to minimize (as much as
possible) swaping  threads that are locking ? If such threads are swapped,
it will cause  starvation of other threads waiting for the locked monitors.
Or is a  kernel level problem ?

Regrds,
Yechiel     
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050705/2465cb4b/attachment.htm
From gregg at cytetech.com  Tue Jul  5 12:14:24 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue Jul  5 12:14:34 2005
Subject: [concurrency-interest] a question regarding blocking threads
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE20E@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE20E@OFFICESRV>
Message-ID: <42CAB1E0.9000205@cytetech.com>



Yechiel Feffer wrote:
> Is there any mechanism  that JVMs use  in order  to minimize (as much as 
> possible) swaping  threads that are locking ? If such threads are 
> swapped, it will cause  starvation of other threads waiting for the 
> locked monitors. Or is a  kernel level problem ?

If you are talking about swapping to disk as a part of virtual memory implementation, that is an underlying operating 
system policy issue.  Microsoft windows, will apparently flush pages (to disk, or release them from memory) when a 
window is covered, or otherwise sent to the back.  Applications with large RSS will thus come to the front fairly slowly 
in that environment.  At one point, I heard that there were special cases created for the microsoft office suite so that 
it wouldn't be as slow to come to the front as other applications.  Hence, a perceived performance advantage...

Gregg Wonderly
From dl at cs.oswego.edu  Tue Jul  5 12:25:01 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue Jul  5 12:25:03 2005
Subject: [concurrency-interest] a question regarding blocking threads
In-Reply-To: <D166C96F43D1D611B8E3000255A0C48C6BE20E@OFFICESRV>
References: <D166C96F43D1D611B8E3000255A0C48C6BE20E@OFFICESRV>
Message-ID: <42CAB45D.8060302@cs.oswego.edu>

Yechiel Feffer wrote:
> Hi
> Is there any mechanism  that JVMs use  in order  to minimize (as much as 
> possible) swaping  threads that are locking ? If such threads are 
> swapped, it will cause  starvation of other threads waiting for the 
> locked monitors. Or is a  kernel level problem ?
> 

This is usually mainly done in the converse sense by
preferentially blocking threads that are failing to
obtain locks. Plus programmers should nomrally avoid taking
actions that definitely block threads (I/O, acquiring
other locks, etc) while holding locks.

-Doug

From abaker at c-cor.com  Wed Jul  6 12:42:33 2005
From: abaker at c-cor.com (Baker, Anthony)
Date: Wed Jul  6 12:46:24 2005
Subject: [concurrency-interest] Performance of LinkedBlockingQueue.poll()
Message-ID: <85EC2A2F2D64DB4AB2F796CEBD7E2539E37E@beomail1.NTSCD.C-COR.com>

Thanks for the info.  The profiling vendor is investigating the issue and suspects a potential vm thread state reporting problem.  I've included a test case, just in case anyone is interested:

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
//import EDU.oswego.cs.dl.util.concurrent.BoundedLinkedQueue;

public class QueueTest {

  private static final int _rate = 5;
  private LinkedBlockingQueue<Object> _queue = new LinkedBlockingQueue<Object>(100);
  //private BoundedLinkedQueue _queue = new BoundedLinkedQueue(100);

  public static void main(String[] args) {
    QueueTest test = new QueueTest();
    new Thread(test.new RatedProducer()).start();
    new Thread(test.new Consumer()).start();
  }

  private class RatedProducer implements Runnable {
    public void run() {
      while (!Thread.interrupted()) {
        try {
          _queue.put(new Object());
          Thread.sleep(_rate); // simulate request/reply

        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }

  private class Consumer implements Runnable {

    public void run() {
      while (!Thread.interrupted()) {
        try {
          Object o = _queue.poll(1000, TimeUnit.MILLISECONDS);
//          Object o = _queue.poll(1000);

        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
}

Anthony



-----Original Message-----
From: Doug Lea [mailto:dl@cs.oswego.edu]
Sent: Thu 6/30/2005 8:27 AM
To: Baker, Anthony
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Performance of LinkedBlockingQueue.poll()
 
Baker, Anthony wrote:
> Hi,
> 
> During a recent profiling session, I was surprised to discover a 
> perfomance hotspot identified as LinkedBlockingQueue.poll().  The 
> profiler recorded about 39k invocations of poll() as accummulating 139s 
> of cpu time (that's an avg of about 3.5ms per invocation).  Is this a 
> known issue or perhaps a profiling artifact?  Switching back to Doug 
> Lea's BoundedLinkedQueue removed this hotspot.

LinkedBlockingQueue is faster than old BoundedLinkedQueue on
every test I have. If you can put something together that
we can use to replicate your results, we'd be happy to try to
help diagnose and further improve it.


-Doug


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050706/af9fdf1f/attachment.htm
From dawidk at mathcs.emory.edu  Wed Jul  6 13:39:06 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed Jul  6 13:39:25 2005
Subject: [concurrency-interest] backport-util-concurrent: release 2.0 now
	available
Message-ID: <42CC173A.2080901@mathcs.emory.edu>

The backport-util-concurrent, version 2.0, has been released:

http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/

Change log:

New features
 
*  Features and fixes resulting from reconcillation with JSR 166 as of
   Jul 4, such as: lazySet in atomics, 
AbstractExecutorService.newTaskFor(),
   RunnableFuture, RunnableScheduledFuture,
   ScheduledThreadPoolExecutor.decorateTask(), better interrupt detection
   in ThreadPoolExecutor, avoiding garbage retention with timeouts in
   SynchronousQueue, fixed reset in CyclicBarrier, remove(x,null) -> false
   in ConcurrentHashMap, changes in navigable maps, addAll fixed in
   CopyOnWriteArrayList, etc.

*  New backported classes: ConcurrentLinkedQueue, 
ConcurrentSkipList[Map,Set]
 
*  Optimizations (replacement of ReentrantLock by synchronized) in:
   CyclicBarrier, DelayQueue, Exchanger, ThreadPoolExecutor
 
*  Optimizations of atomic variables (simple reads are now volatile 
rather than
   synchronized)
 
*  New backported methods in the fair implementation of the ReentrantLock:
   hasWaiters(Condition), getWaitQueueLength(Condition),
   getWaitingThreads(Condition)
 
*  Retrofitted collection classes: AbstractMap, Collections, LinkedList,
   Tree[Map,Set]
 
*  Numerous javadoc clarifications and fixes
 
Bug fixes
 
*  Upon deserialization, ReentrantLock, ReentrantReadWriteLock, and 
Semaphore
   were potentially in a locked (or even illegal) state, contrary to the 
javadoc
 
*  In the fair implementation of ReentrantLock, wait queues of condition
   variables were not actually fair - they are now
 
*  LinkedBlockingQueue had potential deadlocks in remove() and 
toArray(). It has
   now been replaced by a completely new implementation, based on java.u.c
   (rather than dl.u.c)
 
*  Race condition in Condition.awaitUninterruptibly() could cause 
signals to be
   missed if they were coinciding with interrupt attempts
 
Tests
 
*  Updated unit tests for atomics, AbstractQueuedSynchonizer, 
ConcurrentHashMap,
   CyclicBarrier, ExecutorCompletionService, LinkedBlockingQueue, 
ReentrantLock,
   ReentrantReadWriteLock, ScheduledExecutor, ThreadPoolExecutor
 
*  New unit tests for ConcurrentLinkedQueue, ConcurrentSkipList[Map,Set],
   Utils.nanoTime(), LinkedList, Tree[Map,Set]
 
*  Updated numerous stress tests, and new ones added: CachedThreadPoolLoops,
   [Collection,Map]WordLoops, CASLoops, and more



From jhu at glog.com  Thu Jul  7 10:41:11 2005
From: jhu at glog.com (Hu, Jinsong)
Date: Thu Jul  7 10:41:28 2005
Subject: [concurrency-interest] maximum number of shared lock for
	ReentrantReadWriteLock
Message-ID: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD3@PA-GLOGEX01.glog.com>

Hi,

 

I found my self stuck on a basic bit number operation here, and I hope I
am wrong here, following is the code I extracted from this class:

 

        /** 

         * Perform nonfair tryLock for read. 

         */

        final int nonfairTryAcquireShared(int acquires) {

            for (;;) {

                int c = getState();

                int nextc = c + (acquires << SHARED_SHIFT);

                if (nextc < c)

                    throw new Error("Maximum lock count exceeded");

                if (exclusiveCount(c) != 0 && 

                    owner != Thread.currentThread())

                    return -1;

                if (compareAndSetState(c, nextc)) 

                    return 1;

                // Recheck count if lost CAS

            }

        }

 

Let's say, initially, c is 0, while I tried to acquire 0x80000 shared
lock, then 0x8000 << 16 is a negative number, then c + 0x8000 << 16 is
definitely less than c, then the maximum lock count exceeded exception
will be thrown out. If this is true, then the shared lock count can not
be beyond 0x8000 (32768), not 65536.

 

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050707/1d70af6a/attachment.htm
From tim at peierls.net  Thu Jul  7 11:32:53 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Jul  7 11:34:19 2005
Subject: [concurrency-interest] maximum number of shared lock for
	ReentrantReadWriteLock
In-Reply-To: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD3@PA-GLOGEX01.glog.com>
References: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD3@PA-GLOGEX01.glog.com>
Message-ID: <42CD4B25.5070906@peierls.net>

Your arithmetic is OK, but the acquires argument is always 1 for this RRWL 
method (though not in general with AQS), so nextc < c only on overflow of 
the shared count "field".

The documentation *is* wrong about 65536; it should be 65535. I think this 
has been fixed for Mustang.

--tim


Hu, Jinsong wrote:
> I found my self stuck on a basic bit number operation here, and I hope I 
> am wrong here, following is the code I extracted from this class:
> 
>         /**
>          * Perform nonfair tryLock for read.
>          */
>         final int nonfairTryAcquireShared(int acquires) {
>             for (;;) {
>                 int c = getState();
>                 int nextc = c + (acquires << SHARED_SHIFT);
>                 if (nextc < c)
>                     throw new Error("Maximum lock count exceeded");
>                 if (exclusiveCount(c) != 0 &&
>                     owner != Thread.currentThread())
>                     return -1;
>                 if (compareAndSetState(c, nextc))
>                     return 1;
>                 // Recheck count if lost CAS
>             }
>         }
> 
> Let?s say, initially, c is 0, while I tried to acquire 0x80000 shared 

You meant 0x8000 here, right?

> lock, then 0x8000 << 16 is a negative number, then c + 0x8000 << 16 is 
> definitely less than c, then the maximum lock count exceeded exception 
> will be thrown out. If this is true, then the shared lock count can not 
> be beyond 0x8000 (32768), not 65536.



From jhu at glog.com  Thu Jul  7 12:03:29 2005
From: jhu at glog.com (Hu, Jinsong)
Date: Thu Jul  7 12:03:47 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
Message-ID: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD5@PA-GLOGEX01.glog.com>

Let's say that current state is 0x7FFF0000, hence the current total
shared lock count is 0x7FFF. Now, let's acquire one more shared lock,
hence following are values of current variables:

int c = 0x7FFF0000
int i = 1 << 16 = 0x00010000
int nextc = c + i = 0x80000000 < 0

hence nextc < c and according to the code, the lock overflow exception
is still thrown out.

Jinsong



-----Original Message-----
From: Tim Peierls [mailto:tim@peierls.net] 
Sent: Thursday, July 07, 2005 11:33 AM
To: Hu, Jinsong
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] maximum number of shared lock
forReentrantReadWriteLock

Your arithmetic is OK, but the acquires argument is always 1 for this
RRWL 
method (though not in general with AQS), so nextc < c only on overflow
of 
the shared count "field".

The documentation *is* wrong about 65536; it should be 65535. I think
this 
has been fixed for Mustang.

--tim


Hu, Jinsong wrote:
> I found my self stuck on a basic bit number operation here, and I hope
I 
> am wrong here, following is the code I extracted from this class:
> 
>         /**
>          * Perform nonfair tryLock for read.
>          */
>         final int nonfairTryAcquireShared(int acquires) {
>             for (;;) {
>                 int c = getState();
>                 int nextc = c + (acquires << SHARED_SHIFT);
>                 if (nextc < c)
>                     throw new Error("Maximum lock count exceeded");
>                 if (exclusiveCount(c) != 0 &&
>                     owner != Thread.currentThread())
>                     return -1;
>                 if (compareAndSetState(c, nextc))
>                     return 1;
>                 // Recheck count if lost CAS
>             }
>         }
> 
> Let's say, initially, c is 0, while I tried to acquire 0x80000 shared 

You meant 0x8000 here, right?

> lock, then 0x8000 << 16 is a negative number, then c + 0x8000 << 16 is

> definitely less than c, then the maximum lock count exceeded exception

> will be thrown out. If this is true, then the shared lock count can
not 
> be beyond 0x8000 (32768), not 65536.



From scherer at cs.rochester.edu  Thu Jul  7 12:21:31 2005
From: scherer at cs.rochester.edu (Bill Scherer)
Date: Thu Jul  7 12:21:36 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
In-Reply-To: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD5@PA-GLOGEX01.glog.com>
Message-ID: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>

If acquires is 0x7FFF, then that's the maximum of 65535 that Tim mentioned 
below, so throwing an exception is correct in this case.
			-- Bill

On Thu, 7 Jul 2005, Hu, Jinsong wrote:

> Let's say that current state is 0x7FFF0000, hence the current total
> shared lock count is 0x7FFF. Now, let's acquire one more shared lock,
> hence following are values of current variables:
> 
> int c = 0x7FFF0000
> int i = 1 << 16 = 0x00010000
> int nextc = c + i = 0x80000000 < 0
> 
> hence nextc < c and according to the code, the lock overflow exception
> is still thrown out.
> 
> Jinsong
> 
> 
> 
> -----Original Message-----
> From: Tim Peierls [mailto:tim@peierls.net] 
> Sent: Thursday, July 07, 2005 11:33 AM
> To: Hu, Jinsong
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] maximum number of shared lock
> forReentrantReadWriteLock
> 
> Your arithmetic is OK, but the acquires argument is always 1 for this
> RRWL 
> method (though not in general with AQS), so nextc < c only on overflow
> of 
> the shared count "field".
> 
> The documentation *is* wrong about 65536; it should be 65535. I think
> this 
> has been fixed for Mustang.
> 
> --tim
> 
> 
> Hu, Jinsong wrote:
> > I found my self stuck on a basic bit number operation here, and I hope
> I 
> > am wrong here, following is the code I extracted from this class:
> > 
> >         /**
> >          * Perform nonfair tryLock for read.
> >          */
> >         final int nonfairTryAcquireShared(int acquires) {
> >             for (;;) {
> >                 int c = getState();
> >                 int nextc = c + (acquires << SHARED_SHIFT);
> >                 if (nextc < c)
> >                     throw new Error("Maximum lock count exceeded");
> >                 if (exclusiveCount(c) != 0 &&
> >                     owner != Thread.currentThread())
> >                     return -1;
> >                 if (compareAndSetState(c, nextc))
> >                     return 1;
> >                 // Recheck count if lost CAS
> >             }
> >         }
> > 
> > Let's say, initially, c is 0, while I tried to acquire 0x80000 shared 
> 
> You meant 0x8000 here, right?
> 
> > lock, then 0x8000 << 16 is a negative number, then c + 0x8000 << 16 is
> 
> > definitely less than c, then the maximum lock count exceeded exception
> 
> > will be thrown out. If this is true, then the shared lock count can
> not 
> > be beyond 0x8000 (32768), not 65536.
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From jhu at glog.com  Thu Jul  7 13:11:23 2005
From: jhu at glog.com (Hu, Jinsong)
Date: Thu Jul  7 13:11:40 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
Message-ID: <2E6D4A21A5611B4A8F1AA4E22BE04431877AD6@PA-GLOGEX01.glog.com>

0x7FFF = 32767 in decimal.


-----Original Message-----
From: Bill Scherer [mailto:scherer@cs.rochester.edu] 
Sent: Thursday, July 07, 2005 12:22 PM
To: Hu, Jinsong
Cc: Tim Peierls; concurrency-interest@altair.cs.oswego.edu
Subject: RE: [concurrency-interest] maximum number of shared lock
forReentrantReadWriteLock

If acquires is 0x7FFF, then that's the maximum of 65535 that Tim
mentioned 
below, so throwing an exception is correct in this case.
			-- Bill

On Thu, 7 Jul 2005, Hu, Jinsong wrote:

> Let's say that current state is 0x7FFF0000, hence the current total
> shared lock count is 0x7FFF. Now, let's acquire one more shared lock,
> hence following are values of current variables:
> 
> int c = 0x7FFF0000
> int i = 1 << 16 = 0x00010000
> int nextc = c + i = 0x80000000 < 0
> 
> hence nextc < c and according to the code, the lock overflow exception
> is still thrown out.
> 
> Jinsong
> 
> 
> 
> -----Original Message-----
> From: Tim Peierls [mailto:tim@peierls.net] 
> Sent: Thursday, July 07, 2005 11:33 AM
> To: Hu, Jinsong
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] maximum number of shared lock
> forReentrantReadWriteLock
> 
> Your arithmetic is OK, but the acquires argument is always 1 for this
> RRWL 
> method (though not in general with AQS), so nextc < c only on overflow
> of 
> the shared count "field".
> 
> The documentation *is* wrong about 65536; it should be 65535. I think
> this 
> has been fixed for Mustang.
> 
> --tim
> 
> 
> Hu, Jinsong wrote:
> > I found my self stuck on a basic bit number operation here, and I
hope
> I 
> > am wrong here, following is the code I extracted from this class:
> > 
> >         /**
> >          * Perform nonfair tryLock for read.
> >          */
> >         final int nonfairTryAcquireShared(int acquires) {
> >             for (;;) {
> >                 int c = getState();
> >                 int nextc = c + (acquires << SHARED_SHIFT);
> >                 if (nextc < c)
> >                     throw new Error("Maximum lock count exceeded");
> >                 if (exclusiveCount(c) != 0 &&
> >                     owner != Thread.currentThread())
> >                     return -1;
> >                 if (compareAndSetState(c, nextc))
> >                     return 1;
> >                 // Recheck count if lost CAS
> >             }
> >         }
> > 
> > Let's say, initially, c is 0, while I tried to acquire 0x80000
shared 
> 
> You meant 0x8000 here, right?
> 
> > lock, then 0x8000 << 16 is a negative number, then c + 0x8000 << 16
is
> 
> > definitely less than c, then the maximum lock count exceeded
exception
> 
> > will be thrown out. If this is true, then the shared lock count can
> not 
> > be beyond 0x8000 (32768), not 65536.
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From tim at peierls.net  Thu Jul  7 13:14:52 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Jul  7 13:16:25 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
In-Reply-To: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
Message-ID: <42CD630C.1010500@peierls.net>

Bill Scherer wrote:
> If acquires is 0x7FFF, then that's the maximum of 65535 that Tim mentioned 
> below, so throwing an exception is correct in this case.

0x7FFF is 32767 -- now I think Jinsong Hu is right. You get an overflow 
exception when acquiring the 32768th read lock.

--tim

From tim at peierls.net  Thu Jul  7 13:22:25 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Jul  7 13:23:18 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
In-Reply-To: <42CD630C.1010500@peierls.net>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
	<42CD630C.1010500@peierls.net>
Message-ID: <42CD64D1.6060704@peierls.net>

Tim Peierls wrote:
>> If acquires is 0x7FFF, then that's the maximum of 65535 that Tim 
>> mentioned below, so throwing an exception is correct in this case.
> 
> 0x7FFF is 32767 -- now I think Jinsong Hu is right. You get an overflow 
> exception when acquiring the 32768th read lock.

And if so, this is either a doc bug or code bug. As a doc bug it could be 
fixed by changing 65536 to 32767. As a code bug it could be fixed by 
changing the overflow test.

But maybe this has already been caught and fixed?

--tim

From tim at peierls.net  Thu Jul  7 13:49:04 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Jul  7 13:49:47 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
In-Reply-To: <42CD64D1.6060704@peierls.net>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
	<42CD630C.1010500@peierls.net> <42CD64D1.6060704@peierls.net>
Message-ID: <42CD6B10.3020901@peierls.net>

Tim Peierls wrote:
>>> If acquires is 0x7FFF, then that's the maximum of 65535 that Tim 
>>> mentioned below, so throwing an exception is correct in this case.
>>
>> 0x7FFF is 32767 -- now I think Jinsong Hu is right. You get an 
>> overflow exception when acquiring the 32768th read lock.
> 
> And if so, this is either a doc bug or code bug. As a doc bug it could 
> be fixed by changing 65536 to 32767. As a code bug it could be fixed by 
> changing the overflow test.
> 
> But maybe this has already been caught and fixed?

Hmm, doesn't look like it has. Here's a program that confirms the effective 
maximum counts:

import java.util.concurrent.locks.*;

public class ReadWriteOverflow {
     public static void main(String... args) {
         testWriteOverflow();
         testReadOverflow();
     }

     public static void testWriteOverflow() {
         ReadWriteLock rwl = new ReentrantReadWriteLock();
         for (int i = 1; i <= WMAX; ++i)
             rwl.writeLock().lock();
         System.out.printf(
             "%d write lock acquisitions, trying one more...%n",
             WMAX);
         try {
             rwl.writeLock().lock();
             System.out.printf(
                 "%d write lock acquisitions%n", WMAX+1);
         } catch (Error e) {
             System.out.println(e);
         }
     }

     public static void testReadOverflow() {
         ReadWriteLock rwl = new ReentrantReadWriteLock();
         for (int i = 1; i <= RMAX; ++i)
             rwl.readLock().lock();
         System.out.printf(
             "%d read lock acquisitions, trying one more...%n",
             RMAX);
         try {
             rwl.readLock().lock();
             System.out.printf(
                 "%d read lock acquisitions%n", RMAX+1);
         } catch (Error e) {
             System.out.println(e);
         }
     }

     static final int RMAX = 32767;
     static final int WMAX = 65535;
}

I get this output:

65535 write lock acquisitions, trying one more...
java.lang.Error: Maximum lock count exceeded
32767 read lock acquisitions, trying one more...
java.lang.Error: Maximum lock count exceeded

--tim

From joe.bowbeer at gmail.com  Thu Jul  7 13:51:37 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu Jul  7 13:51:45 2005
Subject: [concurrency-interest] maximum number of shared lock
	forReentrantReadWriteLock
In-Reply-To: <42CD64D1.6060704@peierls.net>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
	<42CD630C.1010500@peierls.net> <42CD64D1.6060704@peierls.net>
Message-ID: <31f2a7bd050707105138f8349c@mail.gmail.com>

FWIW, I also think the test is wrong.

This could be fixed to test for unsigned overflow, e.g., by ANDing
with 0xFFFFFFFFL, but I suspect there are other places in the code
where it is assumed that the acquire count is <= 0x7FFF.

As it stands, 32767 is the max acquire count.


On 7/7/05, Tim Peierls <tim@peierls.net> wrote:
> Tim Peierls wrote:
> >> If acquires is 0x7FFF, then that's the maximum of 65535 that Tim
> >> mentioned below, so throwing an exception is correct in this case.
> >
> > 0x7FFF is 32767 -- now I think Jinsong Hu is right. You get an overflow
> > exception when acquiring the 32768th read lock.
> 
> And if so, this is either a doc bug or code bug. As a doc bug it could be
> fixed by changing 65536 to 32767. As a code bug it could be fixed by
> changing the overflow test.
> 
> But maybe this has already been caught and fixed?
> 
> --tim
>

From fon.tran at gmail.com  Thu Jul  7 16:03:28 2005
From: fon.tran at gmail.com (Fon Francis Tran)
Date: Thu Jul  7 16:03:35 2005
Subject: [concurrency-interest] Execution Priority
Message-ID: <8a852fa505070713031434eee4@mail.gmail.com>

Hello,

I tried to test the ThreadPoolExecutor with a simple program but found that 
the runnable jobs
are not executed as FIFO (Using LinkedBlockingQueue) as I would expected 
when the 
corePoolSize is not 1. 

The result and the code are listed below. I would guess the task should be 
executed from
0 to 4 but they seem to be executed at random. Anyone knows why? 

Many thanks,

Fon


Result:

Starting task Task 4 at 04:39:29:179
Ending task Task 4 at 04:39:29:190 after 11 milliseconds
Starting task Task 1 at 04:39:29:200
Ending task Task 1 at 04:39:29:202 after 2 milliseconds
Starting task Task 2 at 04:39:29:207
Ending task Task 2 at 04:39:29:208 after 1 milliseconds
Starting task Task 3 at 04:39:29:211
Ending task Task 3 at 04:39:29:216 after 5 milliseconds
Starting task Task 0 at 04:39:29:219
Ending task Task 0 at 04:39:29:221 after 2 milliseconds
Process terminated with exit code 0
 
Code:

import edu.emory.mathcs.backport.java.util.concurrent.*;
import java.util.*;
import java.text.*;

public class TestConcurrent {
public static void main(String[] args) {
int nTasks = 5;
int fib = 4;

ExecutorServiceAccess esa = new ExecutorServiceAccess();
for (int i = 0; i < nTasks; i++)
esa.excute(new Task2(fib, "Task " + i));
esa.shutdown();
}
}

class ExecutorServiceAccess {
private ExecutorService service;

public ExecutorServiceAccess () {
service = Executors.newFixedThreadPool(5);
}
public void excute(Runnable r) {
service.execute(r);
}
public void shutdown() {
service.shutdown();
}
}

class Task2 implements Runnable {
long n;
String id;

private long doSomething(long n) {
return n*n-n;
}
public Task2(long n, String id) {
this.n = n;
this.id <http://this.id> = id;
}
public void run() {
DateFormat df = new SimpleDateFormat("HH:mm:ss:SSS");
long startTime = System.currentTimeMillis();
System.out.println("Starting task " + id + " at " + df.format(new Date()));
doSomething(n);
long endTime = System.currentTimeMillis();
System.out.println("Ending task " + id + " at " + df.format(new Date())
+ " after " + (endTime - startTime) + " milliseconds");
}
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050708/bf7faca7/attachment-0001.htm
From tim at peierls.net  Thu Jul  7 16:44:18 2005
From: tim at peierls.net (Tim Peierls)
Date: Thu Jul  7 16:45:08 2005
Subject: [concurrency-interest] Execution Priority
In-Reply-To: <8a852fa505070713031434eee4@mail.gmail.com>
References: <8a852fa505070713031434eee4@mail.gmail.com>
Message-ID: <42CD9422.80607@peierls.net>

The whole point of a thread pool is to run tasks independently, so that 
newly submitted tasks don't have to wait for other tasks to finish before 
running.

ThreadPoolExecutor's internal queue, which is normally FIFO, is only used 
to keep track of tasks that have not yet run because there was no worker 
thread available to run them when they were submitted. In your case, five 
threads are available, and there are five tasks, so the tasks never have to 
wait on the queue for a worker thread to free up.

So there is no particular order in which these tasks should execute their 
print statements. When I run your code I get two kinds of results:

  Starting task Task 0 at 16:21:10:421
  Starting task Task 1 at 16:21:10:421
  Starting task Task 3 at 16:21:10:421
  Starting task Task 4 at 16:21:10:421
  Starting task Task 2 at 16:21:10:421
  Ending task Task 0 at 16:21:10:421 after 0 milliseconds
  Ending task Task 1 at 16:21:10:421 after 0 milliseconds
  Ending task Task 4 at 16:21:10:421 after 0 milliseconds
  Ending task Task 2 at 16:21:10:437 after 16 milliseconds
  Ending task Task 3 at 16:21:10:437 after 16 milliseconds

and

  Starting task Task 2 at 16:28:48:250
  Ending task Task 2 at 16:28:48:265 after 15 milliseconds
  Starting task Task 4 at 16:28:48:281
  Ending task Task 4 at 16:28:48:281 after 0 milliseconds
  Starting task Task 3 at 16:28:48:281
  Ending task Task 3 at 16:28:48:281 after 0 milliseconds
  Starting task Task 1 at 16:28:48:281
  Ending task Task 1 at 16:28:48:281 after 0 milliseconds
  Starting task Task 0 at 16:28:48:281
  Ending task Task 0 at 16:28:48:281 after 0 milliseconds

But that's just my computer. *Any* ordering and interleaving of the tasks 
(where each task's start message precedes its end message) is theoretically 
possible.

Note that if you use a single thread executor, then you *do* get the FIFO 
ordering you were expecting.

     service = Executors.newSingleThreadExecutor();

--tim


Fon Francis Tran wrote:
> Hello,
> 
>   I tried to test the ThreadPoolExecutor with a simple program but found 
> that the runnable jobs
>   are not executed as FIFO (Using LinkedBlockingQueue) as I would 
> expected when the
>   corePoolSize is not 1. 
> 
>   The result and the code are listed below. I would guess the task 
> should be executed from
>   0 to 4 but they seem to be executed  at random.  Anyone knows why?
> 
>   Many thanks,
> 
> Fon
> 
> 
>    Result:
> 
> Starting task Task 4 at 04:39:29:179
> Ending task Task 4 at 04:39:29:190 after 11 milliseconds
> Starting task Task 1 at 04:39:29:200
> Ending task Task 1 at 04:39:29:202 after 2 milliseconds
> Starting task Task 2 at 04:39:29:207
> Ending task Task 2 at 04:39:29:208 after 1 milliseconds
> Starting task Task 3 at 04:39:29:211
> Ending task Task 3 at 04:39:29:216 after 5 milliseconds
> Starting task Task 0 at 04:39:29:219
> Ending task Task 0 at 04:39:29:221 after 2 milliseconds
> Process terminated with exit code 0
> 
>    Code:
> 
> import edu.emory.mathcs.backport.java.util.concurrent.*;
> import java.util.*;
> import java.text.*;
> 
> public class TestConcurrent {
>   public static void main(String[] args) {
>     int nTasks = 5;
>     int fib = 4;
> 
>     ExecutorServiceAccess esa = new ExecutorServiceAccess();
>     for (int i = 0; i < nTasks; i++)
>         esa.excute(new Task2(fib, "Task " + i));
>       esa.shutdown();
>     }
> }
> 
> class ExecutorServiceAccess {
>     private ExecutorService service;
> 
>     public ExecutorServiceAccess () {
>         service = Executors.newFixedThreadPool(5);
>     }
>     public void excute(Runnable r) {
>         service.execute(r);
>     }
>     public void shutdown() {
>         service.shutdown();
>     }
> }
> 
> class Task2 implements Runnable {
>   long n;
>   String id;
> 
>   private long doSomething(long n) {
>     return n*n-n;
>   }
>   public Task2(long n, String id) {
>     this.n = n;
>     this.id = id;
>   }
>   public void run() {
>     DateFormat df = new SimpleDateFormat("HH:mm:ss:SSS");
>     long startTime = System.currentTimeMillis();
>     System.out.println("Starting task " + id + " at " + df.format(new 
> Date()));
>     doSomething(n);
>     long endTime = System.currentTimeMillis();
>     System.out.println("Ending task " + id + " at " + df.format(new Date())
>         + " after " + (endTime - startTime) + " milliseconds");
>   }
> }
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From fon.tran at gmail.com  Thu Jul  7 17:33:09 2005
From: fon.tran at gmail.com (Fon Francis Tran)
Date: Thu Jul  7 17:33:12 2005
Subject: [concurrency-interest] Execution Priority
In-Reply-To: <42CD9422.80607@peierls.net>
References: <8a852fa505070713031434eee4@mail.gmail.com>
	<42CD9422.80607@peierls.net>
Message-ID: <8a852fa505070714334957e0c6@mail.gmail.com>

That make sense. Thanks.

On 7/8/05, Tim Peierls <tim@peierls.net> wrote:
> 
> The whole point of a thread pool is to run tasks independently, so that
> newly submitted tasks don't have to wait for other tasks to finish before
> running.
> 
> ThreadPoolExecutor's internal queue, which is normally FIFO, is only used
> to keep track of tasks that have not yet run because there was no worker
> thread available to run them when they were submitted. In your case, five
> threads are available, and there are five tasks, so the tasks never have 
> to
> wait on the queue for a worker thread to free up.
> 
> So there is no particular order in which these tasks should execute their
> print statements. When I run your code I get two kinds of results:
> 
> Starting task Task 0 at 16:21:10:421
> Starting task Task 1 at 16:21:10:421
> Starting task Task 3 at 16:21:10:421
> Starting task Task 4 at 16:21:10:421
> Starting task Task 2 at 16:21:10:421
> Ending task Task 0 at 16:21:10:421 after 0 milliseconds
> Ending task Task 1 at 16:21:10:421 after 0 milliseconds
> Ending task Task 4 at 16:21:10:421 after 0 milliseconds
> Ending task Task 2 at 16:21:10:437 after 16 milliseconds
> Ending task Task 3 at 16:21:10:437 after 16 milliseconds
> 
> and
> 
> Starting task Task 2 at 16:28:48:250
> Ending task Task 2 at 16:28:48:265 after 15 milliseconds
> Starting task Task 4 at 16:28:48:281
> Ending task Task 4 at 16:28:48:281 after 0 milliseconds
> Starting task Task 3 at 16:28:48:281
> Ending task Task 3 at 16:28:48:281 after 0 milliseconds
> Starting task Task 1 at 16:28:48:281
> Ending task Task 1 at 16:28:48:281 after 0 milliseconds
> Starting task Task 0 at 16:28:48:281
> Ending task Task 0 at 16:28:48:281 after 0 milliseconds
> 
> But that's just my computer. *Any* ordering and interleaving of the tasks
> (where each task's start message precedes its end message) is 
> theoretically
> possible.
> 
> Note that if you use a single thread executor, then you *do* get the FIFO
> ordering you were expecting.
> 
> service = Executors.newSingleThreadExecutor();
> 
> --tim
> 
> 
> Fon Francis Tran wrote:
> > Hello,
> >
> > I tried to test the ThreadPoolExecutor with a simple program but found
> > that the runnable jobs
> > are not executed as FIFO (Using LinkedBlockingQueue) as I would
> > expected when the
> > corePoolSize is not 1.
> >
> > The result and the code are listed below. I would guess the task
> > should be executed from
> > 0 to 4 but they seem to be executed at random. Anyone knows why?
> >
> > Many thanks,
> >
> > Fon
> >
> >
> > Result:
> >
> > Starting task Task 4 at 04:39:29:179
> > Ending task Task 4 at 04:39:29:190 after 11 milliseconds
> > Starting task Task 1 at 04:39:29:200
> > Ending task Task 1 at 04:39:29:202 after 2 milliseconds
> > Starting task Task 2 at 04:39:29:207
> > Ending task Task 2 at 04:39:29:208 after 1 milliseconds
> > Starting task Task 3 at 04:39:29:211
> > Ending task Task 3 at 04:39:29:216 after 5 milliseconds
> > Starting task Task 0 at 04:39:29:219
> > Ending task Task 0 at 04:39:29:221 after 2 milliseconds
> > Process terminated with exit code 0
> >
> > Code:
> >
> > import edu.emory.mathcs.backport.java.util.concurrent.*;
> > import java.util.*;
> > import java.text.*;
> >
> > public class TestConcurrent {
> > public static void main(String[] args) {
> > int nTasks = 5;
> > int fib = 4;
> >
> > ExecutorServiceAccess esa = new ExecutorServiceAccess();
> > for (int i = 0; i < nTasks; i++)
> > esa.excute(new Task2(fib, "Task " + i));
> > esa.shutdown();
> > }
> > }
> >
> > class ExecutorServiceAccess {
> > private ExecutorService service;
> >
> > public ExecutorServiceAccess () {
> > service = Executors.newFixedThreadPool(5);
> > }
> > public void excute(Runnable r) {
> > service.execute(r);
> > }
> > public void shutdown() {
> > service.shutdown();
> > }
> > }
> >
> > class Task2 implements Runnable {
> > long n;
> > String id;
> >
> > private long doSomething(long n) {
> > return n*n-n;
> > }
> > public Task2(long n, String id) {
> > this.n = n;
> > this.id <http://this.id> = id;
> > }
> > public void run() {
> > DateFormat df = new SimpleDateFormat("HH:mm:ss:SSS");
> > long startTime = System.currentTimeMillis();
> > System.out.println("Starting task " + id + " at " + df.format(new
> > Date()));
> > doSomething(n);
> > long endTime = System.currentTimeMillis();
> > System.out.println("Ending task " + id + " at " + df.format(new Date())
> > + " after " + (endTime - startTime) + " milliseconds");
> > }
> > }
> >
> >
> > ------------------------------------------------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest@altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050708/913f8cf1/attachment.htm
From spyromus at noizeramp.com  Fri Jul  8 05:37:16 2005
From: spyromus at noizeramp.com (Aleksey Gureev)
Date: Fri Jul  8 07:42:58 2005
Subject: [concurrency-interest] SynchronizedLong vs. other locks
Message-ID: <1120815437.7452.17.camel@thehole>

Hi,

I have a following piece of code:

---
    private static synchronized long getTomorrowTime()
    {
        final long current = System.currentTimeMillis();
        if (current > tomorrow)
        {
            GregorianCalendar cal = new GregorianCalendar();
            cal.add(Calendar.DATE, 1);
            cal.set(Calendar.HOUR_OF_DAY, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);
            tomorrow = cal.getTimeInMillis();
        }

        return tomorrow;
    }
---

"tomorrow" is static. It's obvious that the instance synchronization is
not really what's necessary because the other objects of this class can
still introduce race conditions. My question is can SynchronizedLong
help me somehow or it's better to replace instance locking with
class-wide locking?

Thank you,

Aleksey Gureev
Noizeramp Creative Group
http://www.noizeramp.com/


From spyromus at noizeramp.com  Fri Jul  8 05:39:09 2005
From: spyromus at noizeramp.com (Aleksey Gureev)
Date: Fri Jul  8 07:43:00 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <1120815437.7452.17.camel@thehole>
References: <1120815437.7452.17.camel@thehole>
Message-ID: <1120815549.7452.19.camel@thehole>

Actually, it is already class-wide, sorry, but anyway, any help from
SynchronizedLong?

Aleksey Gureev
Noizeramp Creative Group
http://www.noizeramp.com/

On Fri, 2005-07-08 at 12:37 +0300, Aleksey Gureev wrote:
> Hi,
> 
> I have a following piece of code:
> 
> ---
>     private static synchronized long getTomorrowTime()
>     {
>         final long current = System.currentTimeMillis();
>         if (current > tomorrow)
>         {
>             GregorianCalendar cal = new GregorianCalendar();
>             cal.add(Calendar.DATE, 1);
>             cal.set(Calendar.HOUR_OF_DAY, 0);
>             cal.set(Calendar.MINUTE, 0);
>             cal.set(Calendar.SECOND, 0);
>             cal.set(Calendar.MILLISECOND, 0);
>             tomorrow = cal.getTimeInMillis();
>         }
> 
>         return tomorrow;
>     }
> ---
> 
> "tomorrow" is static. It's obvious that the instance synchronization is
> not really what's necessary because the other objects of this class can
> still introduce race conditions. My question is can SynchronizedLong
> help me somehow or it's better to replace instance locking with
> class-wide locking?
> 
> Thank you,
> 
> Aleksey Gureev
> Noizeramp Creative Group
> http://www.noizeramp.com/
> 

From dawidk at mathcs.emory.edu  Fri Jul  8 09:58:25 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 09:58:39 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <1120815549.7452.19.camel@thehole>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole>
Message-ID: <42CE8681.3050700@mathcs.emory.edu>

Aleksey Gureev wrote:

>Actually, it is already class-wide, sorry, but anyway, any help from
>SynchronizedLong?
>  
>
>>---
>>    private static synchronized long getTomorrowTime()
>>    {
>>        final long current = System.currentTimeMillis();
>>        if (current > tomorrow)
>>        {
>>            GregorianCalendar cal = new GregorianCalendar();
>>            cal.add(Calendar.DATE, 1);
>>            cal.set(Calendar.HOUR_OF_DAY, 0);
>>            cal.set(Calendar.MINUTE, 0);
>>            cal.set(Calendar.SECOND, 0);
>>            cal.set(Calendar.MILLISECOND, 0);
>>            tomorrow = cal.getTimeInMillis();
>>        }
>>
>>        return tomorrow;
>>    }
>>---
>>
>>"tomorrow" is static. It's obvious that the instance synchronization is
>>not really what's necessary because the other objects of this class can
>>still introduce race conditions. My question is can SynchronizedLong
>>help me somehow or it's better to replace instance locking with
>>class-wide locking?
>>
>>    
>>
Not really, since you have "read-modify-write" operation; you need the 
lock if you want to keep it in a shared variable. But why not just do:

private static final long DAY = 24*60*60*1000;

private static long getTomorrowTime() {
    return (((System.currentTimeMillis() + DAY)/DAY)*DAY;
}

I bet this will be much faster than synchronization.

From dawidk at mathcs.emory.edu  Fri Jul  8 10:11:51 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 10:12:07 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE8681.3050700@mathcs.emory.edu>
References: <1120815437.7452.17.camel@thehole><1120815549.7452.19.camel@theh	ole>
	<42CE8681.3050700@mathcs.emory.edu>
Message-ID: <42CE89A7.4080308@mathcs.emory.edu>

Dawid Kurzyniec wrote:

> Aleksey Gureev wrote:
>
>> Actually, it is already class-wide, sorry, but anyway, any help from
>> SynchronizedLong?
>>  
>>
>>> ---
>>>    private static synchronized long getTomorrowTime()
>>>    {
>>>        final long current = System.currentTimeMillis();
>>>        if (current > tomorrow)
>>>        {
>>>            GregorianCalendar cal = new GregorianCalendar();
>>>            cal.add(Calendar.DATE, 1);
>>>            cal.set(Calendar.HOUR_OF_DAY, 0);
>>>            cal.set(Calendar.MINUTE, 0);
>>>            cal.set(Calendar.SECOND, 0);
>>>            cal.set(Calendar.MILLISECOND, 0);
>>>            tomorrow = cal.getTimeInMillis();
>>>        }
>>>
>>>        return tomorrow;
>>>    }
>>> ---
>>>
>>> "tomorrow" is static. It's obvious that the instance synchronization is
>>> not really what's necessary because the other objects of this class can
>>> still introduce race conditions. My question is can SynchronizedLong
>>> help me somehow or it's better to replace instance locking with
>>> class-wide locking?
>>>
>>>   
>>
> Not really, since you have "read-modify-write" operation; you need the 
> lock if you want to keep it in a shared variable. But why not just do:
>
Actually, sorry, in your case, the potential race is rather harmless 
since the same value would be written anyway (unless a thread is 
preempted for more than 24h). So in fact, you could drop the 
synchronization, and you don't even need atomic variables, just make 
"current" volatile. But I still think that the version without a shared 
variable will be the fastest.

Regards,
Dawid

From tim at peierls.net  Fri Jul  8 10:23:44 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Jul  8 10:23:55 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE8681.3050700@mathcs.emory.edu>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
Message-ID: <42CE8C70.1020307@peierls.net>

Dawid Kurzyniec wrote:
> private static final long DAY = 24*60*60*1000;
> 
> private static long getTomorrowTime() {
>    return (((System.currentTimeMillis() + DAY)/DAY)*DAY;
> }

Does this deal with leap seconds properly?

--tim

From dawidk at mathcs.emory.edu  Fri Jul  8 10:27:59 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 10:28:13 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <1120831712.30341.2.camel@thehole>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole>
	<42CE8681.3050700@mathcs.emory.edu>
	<1120831712.30341.2.camel@thehole>
Message-ID: <42CE8D6F.2050704@mathcs.emory.edu>

Aleksey Gureev wrote:

>Dawid,
>  
>
>:) You forget about the time zones.
>  
>
Yes I did. How about:

private static final TimeZone local = TimeZone.getDefault();

private static long getTomorrowTime() {
    long current = System.currentTimeMillis();
    long offset = local.getOffset(current);
    return (((current + offset + DAY)/DAY)*DAY - offset;
}

Now I'm less sure if this will be faster than shared volatile, but it's 
worth a shot.

Regards,
Dawid

From tim at peierls.net  Fri Jul  8 10:43:51 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Jul  8 10:44:04 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE8C70.1020307@peierls.net>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
	<42CE8C70.1020307@peierls.net>
Message-ID: <42CE9127.4020703@peierls.net>

Tim Peierls wrote:
> Dawid Kurzyniec wrote:
> 
>> private static final long DAY = 24*60*60*1000;
>>
>> private static long getTomorrowTime() {
>>    return (((System.currentTimeMillis() + DAY)/DAY)*DAY;
>> }
> 
> 
> Does this deal with leap seconds properly?

Answering my own question: No, it doesn't. The program below produces this 
output on my machine (today):

t1 = 1120881600000
t2 = 1120867200000

a difference of 4 minutes. (Hmm, why four minutes? Only 23 leap seconds 
have been inserted since the epoch.)

--tim


import java.util.*;

public class TomorrowTime {
     private static final long DAY = 24*60*60*1000;

     public static void main(String[] args) {
         System.out.printf("t1 = %d%nt2 = %d%n",
             getTomorrowTime1(),
             getTomorrowTime2());
     }

     private static long getTomorrowTime1() {
         GregorianCalendar cal = new GregorianCalendar();
         cal.add(Calendar.DATE, 1);
         cal.set(Calendar.HOUR_OF_DAY, 0);
         cal.set(Calendar.MINUTE, 0);
         cal.set(Calendar.SECOND, 0);
         cal.set(Calendar.MILLISECOND, 0);
         return cal.getTimeInMillis();
     }

     private static long getTomorrowTime2() {
        return ((System.currentTimeMillis() + DAY)/DAY)*DAY;
     }
}

From dawidk at mathcs.emory.edu  Fri Jul  8 10:49:14 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 10:49:22 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE9127.4020703@peierls.net>
References: <1120815437.7452.17.camel@thehole><1120815549.7452.19.camel@theh	ole>
	<42CE8681.3050700@mathcs.emory.edu><42CE8C70.1020307@peierls.net>
	<42CE9127.4020703@peierls.net>
Message-ID: <42CE926A.9010102@mathcs.emory.edu>

Tim Peierls wrote:

> Tim Peierls wrote:
>
>> Dawid Kurzyniec wrote:
>>
>>> private static final long DAY = 24*60*60*1000;
>>>
>>> private static long getTomorrowTime() {
>>>    return (((System.currentTimeMillis() + DAY)/DAY)*DAY;
>>> }
>>
>>
>>
>> Does this deal with leap seconds properly?
>
>
> Answering my own question: No, it doesn't. The program below produces 
> this output on my machine (today):
>
> t1 = 1120881600000
> t2 = 1120867200000
>
> a difference of 4 minutes. (Hmm, why four minutes? Only 23 leap 
> seconds have been inserted since the epoch.)
>
It's 4 *hours*, it probably accounts for the difference in time zone. I 
still am trying to convince myself that my second version (with the 
offset) is correct...

Looking at the source code of the GregorianCalendar, it doesn't seem 
that it has a concept of leap seconds...

Regards,
Dawid

From tim at peierls.net  Fri Jul  8 10:49:22 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Jul  8 10:49:37 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE9127.4020703@peierls.net>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
	<42CE8C70.1020307@peierls.net> <42CE9127.4020703@peierls.net>
Message-ID: <42CE9272.7010002@peierls.net>

Tim Peierls wrote:
> Answering my own question: No, it doesn't. The program below produces 
> this output on my machine (today):
> 
> t1 = 1120881600000
> t2 = 1120867200000
> 
> a difference of 4 minutes. (Hmm, why four minutes? Only 23 leap seconds 
> have been inserted since the epoch.)

Ah, four *hours*! That's the time zone difference. Sorry.

But can one always count on System.currentTimeMillis() in this way?

--tim

From dawidk at mathcs.emory.edu  Fri Jul  8 11:08:17 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 11:08:29 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE9272.7010002@peierls.net>
References: <1120815437.7452.17.camel@thehole><1120815549.7452.19.camel@theh	ole>
	<42CE8681.3050700@mathcs.emory.edu><42CE8C70.1020307@peierls.net>
	<42CE9127.4020703@peierls.net> <42CE9272.7010002@peierls.net>
Message-ID: <42CE96E1.6090503@mathcs.emory.edu>

Tim Peierls wrote:

> Tim Peierls wrote:
>
>> Answering my own question: No, it doesn't. The program below produces 
>> this output on my machine (today):
>>
>> t1 = 1120881600000
>> t2 = 1120867200000
>>
>> a difference of 4 minutes. (Hmm, why four minutes? Only 23 leap 
>> seconds have been inserted since the epoch.)
>
>
> Ah, four *hours*! That's the time zone difference. Sorry.
>
> But can one always count on System.currentTimeMillis() in this way?
>
Looking at GregorianCalendar.computeFieldsImpl(), it is clear that 
GregorianCalendar ignores leap seconds, so it seems safe to replace it 
with that arithmetics. (BTW. the arithmetics work correctly only for 
positive "currentTimeMillis", e.g. after 1970. I don't suppose it 
matters in the discussed application, though).

Regards,
Dawid

From tim at peierls.net  Fri Jul  8 11:12:31 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Jul  8 11:12:41 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE926A.9010102@mathcs.emory.edu>
References: <1120815437.7452.17.camel@thehole>
	<42CE8681.3050700@mathcs.emory.edu> <42CE8C70.1020307@peierls.net>
	<42CE9127.4020703@peierls.net> <42CE926A.9010102@mathcs.emory.edu>
Message-ID: <42CE97DF.3000800@peierls.net>

Dawid Kurzyniec wrote:
> Looking at the source code of the GregorianCalendar, it doesn't seem 
> that it has a concept of leap seconds...

So GregorianCalendar is broken -- because, for example, it reports the 
difference in seconds between the first second of 1998-Dec-31 and the first 
second of 1999-Jan-1 as 86400 rather than 86401.

It can't be fixed to deal with leap seconds without breaking existing code, 
so I guess it is safe to rely on its brokenness: computations using 
System.currentTimeMillis() and TimeZone.getOffset will yield the same 
results as GregorianCalendar computations. Yuck.

Seems like the docs should be fixed to make the lack of leap second 
treatment explicit. The Date class says something vague about this, but I 
couldn't draw any conclusions about GregorianCalendar from it.

--tim

From spyromus at noizeramp.com  Fri Jul  8 10:08:31 2005
From: spyromus at noizeramp.com (Aleksey Gureev)
Date: Fri Jul  8 11:28:13 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE8681.3050700@mathcs.emory.edu>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
Message-ID: <1120831712.30341.2.camel@thehole>

Dawid,

> Not really, since you have "read-modify-write" operation; you need the 
> lock if you want to keep it in a shared variable. But why not just do:
> 
> private static final long DAY = 24*60*60*1000;
> 
> private static long getTomorrowTime() {
>     return (((System.currentTimeMillis() + DAY)/DAY)*DAY;
> }
> 
> I bet this will be much faster than synchronization.

:) You forget about the time zones.

Thanks for advice!

Aleksey

From spyromus at noizeramp.com  Fri Jul  8 10:57:36 2005
From: spyromus at noizeramp.com (Aleksey Gureev)
Date: Fri Jul  8 11:28:15 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE9272.7010002@peierls.net>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
	<42CE8C70.1020307@peierls.net> <42CE9127.4020703@peierls.net>
	<42CE9272.7010002@peierls.net>
Message-ID: <1120834657.30341.14.camel@thehole>

On Fri, 2005-07-08 at 10:49 -0400, Tim Peierls wrote:
> But can one always count on System.currentTimeMillis() in this way?

Sure. It's very convenient. For example, if you write an application and
you need some timestamp to mark the event time or something --
currentTimeMillis() is your best friend. Just don't make a mistake
thinking about it as a precise date and you'll find tons of other
applications. :)

Aleksey


From gregg at cytetech.com  Fri Jul  8 11:39:32 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri Jul  8 11:39:52 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE9272.7010002@peierls.net>
References: <1120815437.7452.17.camel@thehole>	<1120815549.7452.19.camel@thehole>
	<42CE8681.3050700@mathcs.emory.edu>	<42CE8C70.1020307@peierls.net>
	<42CE9127.4020703@peierls.net> <42CE9272.7010002@peierls.net>
Message-ID: <42CE9E34.7050006@cytetech.com>



Tim Peierls wrote:
> Tim Peierls wrote:
> 
>> Answering my own question: No, it doesn't. The program below produces 
>> this output on my machine (today):
>>
>> t1 = 1120881600000
>> t2 = 1120867200000
>>
>> a difference of 4 minutes. (Hmm, why four minutes? Only 23 leap 
>> seconds have been inserted since the epoch.)
> 
> 
> Ah, four *hours*! That's the time zone difference. Sorry.
> 
> But can one always count on System.currentTimeMillis() in this way?

Millisecond times in Java are always UTC milliseconds.  The Locale forces the display of a particular 'time' when you 
use java.util.Date().toString(), or Calendar.toString() etc.

I do think that leap seconds are ignored as a concept in the GregorianCalendar implementation.

Gregg Wonderly
From joe.bowbeer at gmail.com  Fri Jul  8 12:09:14 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri Jul  8 12:09:44 2005
Subject: [concurrency-interest] SynchronizedLong vs. other locks
In-Reply-To: <1120815437.7452.17.camel@thehole>
References: <1120815437.7452.17.camel@thehole>
Message-ID: <31f2a7bd0507080909d421c40@mail.gmail.com>

One option would be to retain "tomorrow" as a Calendar and synchronize on that:

private static long getTomorrowTime() {
    synchronized (tomorrow) {
        long tomorrowMillis = tomorrow.getTimeMillis();
        if (System.currentTimeMillis() > tomorrowMillis) {
            tomorrow.add(Calendar.DATE, 1);
            tomorrowMillis = tomorrow.getTimeMillis();
        }
        return tomorrowMillis;
    }
}


NOTE: I'm suspicious of any use of the GregorianCalendar implementation.

See gotchas and possible alternative:

http://mindprod.com/jgloss/calendar.html
http://mindprod.com/jgloss/gotchas.html#DATE
http://mindprod.com/products1.html#BIGDATE


On 7/8/05, Aleksey Gureev <spyromus@noizeramp.com> wrote:
> Hi,
> 
> I have a following piece of code:
> 
> ---
>     private static synchronized long getTomorrowTime()
>     {
>         final long current = System.currentTimeMillis();
>         if (current > tomorrow)
>         {
>             GregorianCalendar cal = new GregorianCalendar();
>             cal.add(Calendar.DATE, 1);
>             cal.set(Calendar.HOUR_OF_DAY, 0);
>             cal.set(Calendar.MINUTE, 0);
>             cal.set(Calendar.SECOND, 0);
>             cal.set(Calendar.MILLISECOND, 0);
>             tomorrow = cal.getTimeInMillis();
>         }
> 
>         return tomorrow;
>     }
> ---
> 
> "tomorrow" is static. It's obvious that the instance synchronization is
> not really what's necessary because the other objects of this class can
> still introduce race conditions. My question is can SynchronizedLong
> help me somehow or it's better to replace instance locking with
> class-wide locking?
> 
> Thank you,
> 
> Aleksey Gureev
> Noizeramp Creative Group
> http://www.noizeramp.com/
>

From tim at peierls.net  Fri Jul  8 12:20:48 2005
From: tim at peierls.net (Tim Peierls)
Date: Fri Jul  8 12:21:13 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <1120834657.30341.14.camel@thehole>
References: <1120815437.7452.17.camel@thehole>
	<1120815549.7452.19.camel@thehole> <42CE8681.3050700@mathcs.emory.edu>
	<42CE8C70.1020307@peierls.net> <42CE9127.4020703@peierls.net>
	<42CE9272.7010002@peierls.net> <1120834657.30341.14.camel@thehole>
Message-ID: <42CEA7E0.5090405@peierls.net>

Aleksey Gureev wrote:
> ...if you write an application and you need some timestamp to mark the
> event time or something -- currentTimeMillis() is your best friend. Just
> don't make a mistake thinking about it as a precise date and you'll find
> tons of other applications. :)

It wasn't clear from your code fragment whether you were concerned about 
having a precise date. You might have thought (as I did until now) that 
GregorianCalendar works with corrected UTC time, in which case date 
computations using currentTimeMillis would not agree with GregorianCalendar 
date computations.

Seems like an appropriate time to remind folks that System.nanoTime (unlike 
System.currentTimeMillis) is *only* good for measuring elapsed time, never 
wall-clock time. This is pretty clearly spelled out in the javadocs, but it 
can't hurt to repeat it.

--tim

From dl at cs.oswego.edu  Fri Jul  8 13:14:13 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri Jul  8 13:14:16 2005
Subject: [concurrency-interest] maximum number of shared
	lock	forReentrantReadWriteLock
In-Reply-To: <42CD630C.1010500@peierls.net>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.edu>
	<42CD630C.1010500@peierls.net>
Message-ID: <42CEB465.3020500@cs.oswego.edu>


>  You get an overflow 
> exception when acquiring the 32768th read lock.
> 

Yes, sorry; the specified value should have been 32767.
This javadoc will (hopefully) be fixed for Mustang.

-Doug

From dawidk at mathcs.emory.edu  Fri Jul  8 13:46:54 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 13:47:07 2005
Subject: [concurrency-interest] maximum number of
	sharedlock	forReentrantReadWriteLock
In-Reply-To: <42CEB465.3020500@cs.oswego.edu>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.ed	u><42CD630C.1010500@peierls.net>
	<42CEB465.3020500@cs.oswego.edu>
Message-ID: <42CEBC0E.6070601@mathcs.emory.edu>

Doug Lea wrote:

>
>>  You get an overflow exception when acquiring the 32768th read lock.
>>
>
> Yes, sorry; the specified value should have been 32767.
> This javadoc will (hopefully) be fixed for Mustang.
>
Wouldn't it be better to modify the implementation to use unsigned 
arithmetic? E.g. using:

if (c<0 && nextc>=0)

as an overflow condition?

Regards,
Dawid

From dawidk at mathcs.emory.edu  Fri Jul  8 14:43:36 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri Jul  8 14:44:02 2005
Subject: [concurrency-interest] Re: SynchronizedLong vs. other locks
In-Reply-To: <42CE8D6F.2050704@mathcs.emory.edu>
References: <1120815437.7452.17.camel@thehole><1120815549.7452.19.camel@theh	ole><42CE8681.3050700@mathcs.emory.edu><1120831712.30341.2.camel@thehole>
	<42CE8D6F.2050704@mathcs.emory.edu>
Message-ID: <42CEC958.6000306@mathcs.emory.edu>

Dawid Kurzyniec wrote:

> Aleksey Gureev wrote:
>
>> Dawid,
>>  
>>
>> :) You forget about the time zones.
>>  
>>
> Yes I did. How about:
>
> private static final TimeZone local = TimeZone.getDefault();
>
> private static long getTomorrowTime() {
>    long current = System.currentTimeMillis();
>    long offset = local.getOffset(current);
>    return (((current + offset + DAY)/DAY)*DAY - offset;
> }
>
I apologize for dragging this a bit off-topic thread, but I've found one 
more issue here. What the above code does, it returns the date 24h after 
last midnight. The problem is, however, that due to daylight savings 
time, some days are 23h, and some are 25h; so the returned date may not 
be a local midnight! It seems that the needed correction is:

private static long getTomorrowTime() {
   long current = System.currentTimeMillis();
   long offset1 = local.getOffset(current);
   long tomorrow = (((current + offset1 + DAY)/DAY)*DAY - offset1;
   long offset2 = local.getOffset(tomorrow);
   tomorrow += (offset1-offset2);
   return tomorrow;
}

I haven't tested it though.

Regards,
Dawid


From dl at cs.oswego.edu  Fri Jul  8 15:57:28 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri Jul  8 15:57:29 2005
Subject: [concurrency-interest] maximum number
	of	sharedlock	forReentrantReadWriteLock
In-Reply-To: <42CEBC0E.6070601@mathcs.emory.edu>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.ed	u><42CD630C.1010500@peierls.net>	<42CEB465.3020500@cs.oswego.edu>
	<42CEBC0E.6070601@mathcs.emory.edu>
Message-ID: <42CEDAA8.6070009@cs.oswego.edu>

Dawid Kurzyniec wrote:
> Doug Lea wrote:
> 
> 
>>> You get an overflow exception when acquiring the 32768th read lock.
>>>
>>
>>Yes, sorry; the specified value should have been 32767.
>>This javadoc will (hopefully) be fixed for Mustang.
>>
> 
> Wouldn't it be better to modify the implementation to use unsigned 
> arithmetic? E.g. using:
> 
> if (c<0 && nextc>=0)
> 
> as an overflow condition?
> 

Yes. Silly me. Thanks!

While I'm at it, note that this part of javadoc is in an
"implementation note", which basically means that programmers
cannot rely on the exact numerical limitation. Essentially
all count-based locks have SOME limitation. The bound for
any implementation is left as a quality-of-implementation issue.


-Doug

From gregg at cytetech.com  Fri Jul  8 19:44:07 2005
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri Jul  8 19:44:15 2005
Subject: [concurrency-interest] maximum number
	of	sharedlock	forReentrantReadWriteLock
In-Reply-To: <42CEBC0E.6070601@mathcs.emory.edu>
References: <Pine.LNX.4.44.0507071220430.22192-100000@bogota.cs.rochester.ed	u><42CD630C.1010500@peierls.net>	<42CEB465.3020500@cs.oswego.edu>
	<42CEBC0E.6070601@mathcs.emory.edu>
Message-ID: <42CF0FC7.2040601@cytetech.com>



Dawid Kurzyniec wrote:
> Doug Lea wrote:
> 
>>
>>>  You get an overflow exception when acquiring the 32768th read lock.
>>>
>>
>> Yes, sorry; the specified value should have been 32767.
>> This javadoc will (hopefully) be fixed for Mustang.
>>
> Wouldn't it be better to modify the implementation to use unsigned 
> arithmetic? E.g. using:

If the value is masked by 0xffff0000, then it is possible to just do
(0xffff & (value >> 16)) to get a 65535 max value.

Gregg Wonderly
From alan.wiersba at oracle.com  Mon Jul 11 17:43:11 2005
From: alan.wiersba at oracle.com (Alan Wiersba)
Date: Mon Jul 11 18:38:14 2005
Subject: [concurrency-interest] Sun Licensing terms for
	backport-util-concurrent
Message-ID: <42D2E7EF.10808@oracle.com>

Hi David.  I'm a Release Manager at Oracle Corporation, and we're trying 
to use the Java 1.4 backport of JSR 166 (java.util.concurrent) in our 
new software which we're planning to ship shortly.

I have a question as to what the actual text is of the Sun License which 
some of the files in that backport use.

In http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/ it says:

"A few source files in this library originate from SUN JDK and bear SUN 
source code license, as stated in file headers."

However, I don't see an actual Sun License agreement in any of the 6 
files which appear to be Sun files.

In the readme.html of the source code, I see:
---------------------------------------------------------------------------- 

License
This software is released to the public domain, in the spirit of the 
original code written by Doug Lea. The code can be used for any purpose, 
modified, and redistributed without acknowledgment. No warranty is 
provided, either express or implied. A few source files in this library 
originate from SUN JDK and bear SUN source code license, as stated in 
file headers.
----------------------------------------------------------------------------

- In 64 source code files, I see:
---------------------------------------------------------------------------

/*
  * Written by Doug Lea with assistance from members of JCP JSR-166
  * Expert Group and released to the public domain, as explained at
  * http://creativecommons.org/licenses/publicdomain
  */
---------------------------------------------------------------------------

- In 6 source code files (AbstractMap.java, Collections.java, 
LinkedList.java, PriorityQueue.java, TreeMap.java, TreeSet.java), I see:
------------------------------------------
 * Copyright 2005 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
------------------------------------------

But there's no mention of what the license is.

- On one file, CopyOnWriteArrayList.java, I see:
-------------------------------------
/*

 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group.  Adapted and released, under explicit permission,
 * from JDK ArrayList.java which carries the following copyright:
 *
 * Copyright 1997 by Sun Microsystems, Inc.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Sun Microsystems, Inc. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

-------------------------------------
Could you point me to what the actual text is of the Sun license 
agreement is which applies to the 6 (or so) Sun files?

Thanks for your help.
Alan Wiersba, Release Manager
500 Oracle Parkway, Room 450, Ph: +1.650.506.3138, Fax: +1.650.506.7103

<http://otn.oracle.com/products/ifs>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20050711/dc0c4ada/attachment.htm
From joe.bowbeer at gmail.com  Wed Jul 13 14:58:52 2005
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed Jul 13 14:59:42 2005
Subject: [concurrency-interest] CSP for Java Programmers articles
Message-ID: <31f2a7bd05071311585b861eba@mail.gmail.com>

Fyi - 

"CSP for Java programmers" is a three-part introduction to
Communicating Sequential Processes (CSP)

http://www-128.ibm.com/developerworks/java/library/j-csp1.html
http://www-128.ibm.com/developerworks/java/library/j-csp2.html
http://www-128.ibm.com/developerworks/java/library/j-csp3.html

Includes some references to java.util.concurrent.

From dawidk at mathcs.emory.edu  Wed Jul 13 20:50:43 2005
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed Jul 13 20:51:05 2005
Subject: [concurrency-interest] Sun Licensing terms
	forbackport-util-concurrent
In-Reply-To: <42D2E7EF.10808@oracle.com>
References: <42D2E7EF.10808@oracle.com>
Message-ID: <42D5B6E3.8040200@mathcs.emory.edu>

Alan Wiersba wrote:

> Hi David.  I'm a Release Manager at Oracle Corporation, and we're 
> trying to use the Java 1.4 backport of JSR 166 (java.util.concurrent) 
> in our new software which we're planning to ship shortly.
>
> I have a question as to what the actual text is of the Sun License 
> which some of the files in that backport use.
>
> In http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/ it says:
>
> "A few source files in this library originate from SUN JDK and bear 
> SUN source code license, as stated in file headers."
>
> However, I don't see an actual Sun License agreement in any of the 6 
> files which appear to be Sun files.
>
After consulting with Doug Lea, I can say the following in regard to the 
7 source files in question:

CopyOnWriteArrayList: this file is not in public domain, but it can be 
used and distributed as a part of a larger work in source and binary 
forms, with or without modification, provided that the conditions stated 
in http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/readme 
are met (those are: not using SUN name/trademarks as an endorsement, and 
retaining the disclaimer acknowledging SUN partial copyright and 
disclaimers.)

PriorityQueue, AbstractMap: these files will be replaced in backport 
2.0_01 by new, clean-room, public domain implementations. The timeline 
for this change is the next two weeks. (The new AbstractMap is already 
available in CVS).

LinkedList, Collections, TreeMap, TreeSet: quoting Doug Lea: (those 
files) "are ones we (JSR166) are still coordinating
with Sun to change in Mustang. Since they are neither purely Sun's (they 
don't appear yet even in Mustang builds at java.net) nor ours, they 
don't yet have a clear status."

I am planning to contact SUN legal representatives to clarify the 
redistribution/modification policy of these files.

These files have been added to the backport very recently (in the 
version 2.0), and they do not belong to the core API. People concerned 
about their licensing, and not needing them, will be able to remove them 
from the backport before redistributing it. Also, I will probably 
provide an appropriate download option.

Until 2.0_01 is available, I can provide upon request a stripped release 
of the backport, with the 6 files in question, and their dependencies, 
removed.

I will also try to clarify the licensing issues posted on the Web page.

Regards,
Dawid Kurzyniec


From chris.burnley at gmail.com  Tue Jul 19 05:53:47 2005
From: chris.burnley at gmail.com (Chris Burnley)
Date: Tue Jul 19 05:56:58 2005
Subject: [concurrency-interest] Re: Locks with try/finally
Message-ID: <76205f0b05071902532f98480@mail.gmail.com>

If find the best way to do it is something like this:

Connection connection = ds.getConnection();
try {
    connection.xxxx();
}
finally {
   connection.close();
}


If getConnection fails and throws an exception then flow control will
never go below this line and hence there is no risk of nullpointer in
the finally.

From matthias.ernst at coremedia.com  Wed Jul 20 08:33:09 2005
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Wed Jul 20 08:33:14 2005
Subject: [concurrency-interest] [dl.u.c] PooledExecutor race ?
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5FC0459B@MARS.coremedia.com>

Hi,

I have a vague memory of this being discussed before, but anyways:

I have a thread dump from a customer with a e.o.cs.dl.u.c.PooledExecutor
that has a thread in WaitWhenBlocked, waiting on the synchronous channel
(Pool was created using new PooledExecutor(maxSize);
pool.waitWhenBlocked).

Yet I cannot see any active worker thread that would eventually take
over the offered work.

When looking at this, I think I found a race condition between the last
part of #execute after the synchronized block and workerDone().

Assume a pool with maxSize=1, the only worker busy.

T1 in #execute: leaves the synchronized block heading for the
blockedExecutionHandler.
T2 in Worker#run: for example, task.run throws, executes workerDone,
decrements pool size to 0, polls the handOff --- nothing there yet, so
it quits.
T1 reaches WaitWhenBlocked and waits forever.


A simple testcase hangs shortly after start:

package test;

import EDU.oswego.cs.dl.util.concurrent.PooledExecutor;

public class PooledExecutorTest {
  public static void main(String[] args) throws InterruptedException {
    PooledExecutor pool = new PooledExecutor(1);
    pool.waitWhenBlocked();

    while(true) {
      pool.execute(new Runnable() {
	  public void run() {
	    throw new RuntimeException();
	  }
      });
    }
  }
}

With maximum pool size=2 the test lives longer but still comes to halt
eventually.

Matthias

From dl at cs.oswego.edu  Thu Jul 28 20:33:01 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu Jul 28 20:33:03 2005
Subject: [concurrency-interest] ReentrantReadWriteLock improvements
In-Reply-To: <31f2a7bd0507040348345637ea@mail.gmail.com>
References: <42C8DCBC.9080600@ifad.dk>
	<31f2a7bd0507040348345637ea@mail.gmail.com>
Message-ID: <42E9793D.9030803@cs.oswego.edu>


The specs for ReentrantReadWriteLock included two different
errors, that led to confusion and complaints:
   1. In one sentence it said that nonfair lock order might be
      different than arrival order, but in another, it said that
      readers wouldn't get lock if writers were waiting (which is
      meaningless given the first sentence).
   2. A statement about readers waiting for writers in fair mode
      contradicted the re-rentrancy requirements. (But the implementation
      stupidly obeyed it anyway.)

We've fixed (for Mustang) the javadoc/spec to be clearer and
non-contradictory. And we've improved the implementation
to not only obey the more sensible spec, but to also support
a method that we've had several requests and RFEs for:
     public int getReadHoldCount()
     Queries the number of reentrant read holds on this lock by the
     current thread. A reader thread has a hold on a lock for each lock
     action that is not matched by an unlock action.

Additionally,
   * unlock of a readlock not held by current thread always throws error
      (before, it would throw an error only if no thread held readlock).
   * the nonfair implementation includes a (cheap) heuristic that
     probablistically avoids writer starvation without incurring
     the overhead of fair mode. This helps avoid unwanted surprises.

These improvements come at a small (5-15%) performance cost when
measured under extreme loads. In realistic applications, there's
probably no noticeable performance effect, and nicer behavior.

You can see current drafts of revised specs in the usual place
   http://gee.cs.oswego.edu/dl/jsr166/dist/docs/
And sources etc in their usual places.

Comments and suggestions would be welcome.

-Doug




From Aaron.Harshbarger at crown.com  Fri Jul 29 16:02:17 2005
From: Aaron.Harshbarger at crown.com (Aaron.Harshbarger@crown.com)
Date: Fri Jul 29 16:02:40 2005
Subject: [concurrency-interest] Aaron Harshbarger is out of the office.
Message-ID: <OF13E462F8.C8C1ABEA-ON8525704D.006E1289-8525704D.006E1289@crown.com>


I will be out of the office starting  07/29/2005 and will not return until
08/01/2005.

I will respond to your message when I return.

From bsder at allcaps.org  Fri Jul 29 20:04:31 2005
From: bsder at allcaps.org (Andrew Lentvorski)
Date: Fri Jul 29 20:04:32 2005
Subject: [concurrency-interest] JSR166X gone?
Message-ID: <42EAC40F.8050108@allcaps.org>

Has the stuff in JSR166X migrated to some other, possibly official package?

I can't seem to find the jar for it anymore in the CVS repository.

Thanks,
-a
From jbloch at gmail.com  Sun Jul 31 13:30:17 2005
From: jbloch at gmail.com (Joshua Bloch)
Date: Sun Jul 31 13:30:23 2005
Subject: [concurrency-interest] ReentrantReadWriteLock improvements
In-Reply-To: <42E9793D.9030803@cs.oswego.edu>
References: <42C8DCBC.9080600@ifad.dk>
	<31f2a7bd0507040348345637ea@mail.gmail.com>
	<42E9793D.9030803@cs.oswego.edu>
Message-ID: <b097ac510507311030580b3ab6@mail.gmail.com>

Doug,

   Looks good.

           Josh

On 7/28/05, Doug Lea <dl@cs.oswego.edu> wrote:
> 
> The specs for ReentrantReadWriteLock included two different
> errors, that led to confusion and complaints:
>   1. In one sentence it said that nonfair lock order might be
>      different than arrival order, but in another, it said that
>      readers wouldn't get lock if writers were waiting (which is
>      meaningless given the first sentence).
>   2. A statement about readers waiting for writers in fair mode
>      contradicted the re-rentrancy requirements. (But the implementation
>      stupidly obeyed it anyway.)
> 
> We've fixed (for Mustang) the javadoc/spec to be clearer and
> non-contradictory. And we've improved the implementation
> to not only obey the more sensible spec, but to also support
> a method that we've had several requests and RFEs for:
>     public int getReadHoldCount()
>     Queries the number of reentrant read holds on this lock by the
>     current thread. A reader thread has a hold on a lock for each lock
>     action that is not matched by an unlock action.
> 
> Additionally,
>   * unlock of a readlock not held by current thread always throws error
>      (before, it would throw an error only if no thread held readlock).
>   * the nonfair implementation includes a (cheap) heuristic that
>     probablistically avoids writer starvation without incurring
>     the overhead of fair mode. This helps avoid unwanted surprises.
> 
> These improvements come at a small (5-15%) performance cost when
> measured under extreme loads. In realistic applications, there's
> probably no noticeable performance effect, and nicer behavior.
> 
> You can see current drafts of revised specs in the usual place
>   http://gee.cs.oswego.edu/dl/jsr166/dist/docs/
> And sources etc in their usual places.
> 
> Comments and suggestions would be welcome.
> 
> -Doug
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Sun Jul 31 20:11:04 2005
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun Jul 31 20:11:23 2005
Subject: [concurrency-interest] JSR166X gone?
In-Reply-To: <42EAC40F.8050108@allcaps.org>
References: <42EAC40F.8050108@allcaps.org>
Message-ID: <42ED6898.50705@cs.oswego.edu>

Andrew Lentvorski wrote:
> Has the stuff in JSR166X migrated to some other, possibly official package?
> 
> I can't seem to find the jar for it anymore in the CVS repository.
> 

Sorry, this was just a mechanical error on my part. I need to swap
around various settings to build Tiger vs Mustang versions whenever
regenerating public javadocs and jars and sometimes get it wrong without
noticing. The jsr166x.jar should be in its usual place now.

On the larger question though, yes, the NavigableMaps and Deques in
jsr166x are still slated to be included in Mustang. Integrating them
into Sun builds is taking longer than planned, but they should be
in the java.net Mustang snapshots sometime.

-Doug

