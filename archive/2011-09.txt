From ben at ThinkingSoftware.com  Thu Sep  1 04:16:49 2011
From: ben at ThinkingSoftware.com (ben@thinkingsoftware.com)
Date: Thu, 01 Sep 2011 01:16:49 -0700
Subject: [concurrency-interest] Instead of "To Be or Not To Be" try "Has
 Been or Has Not Been" - A new tool that answers Java concurrency questions.
Message-ID: <4E5F3F71.8020404@ThinkingSoftware.com>

_To All Interested in Concurrency Interest Group:_

We would like to introduce for your consideration a new tool, SUM4Java 
Threads Analyzer.
Your experience with it and your opinion about it will be greatly 
appreciated.

SUM stands for Software Understanding Machine?. The tool promises 0% 
false positive results, total independence from any IDE, analysis done 
directly on byte code, obfuscated or not, and an unusually small 
overhead, allowing the applicability to most of production applications 
and not only the ones still under test.

SUM4Java serves as insurance for Race Free reliability of your applications.
It answers the Java concurrency question: "Has Been or Has Not Been 
there a multithreading contention" with a 0% false positive rate of results.
It provides you with the certainty and the peace of mind - if races were 
not caught - they did not occur.Any race experienced in test (or in 
production) is automatically caught and analyzed.You are then presented 
with the results.That allows a boost in the reliability of your Java 
applications.You also get a bust in program understanding.Any Java code 
- with race conditions or without them, no matter what-can now be seen 
through animated graphs and icons.

If you used to call yourself a Black Box Tester, you are now a White Box 
Tester.The Black Box is gone.
If you used to call yourself a White Box Tester - you can now speak to a 
programmer with confidence - the request to reproduce the failure is not 
going to be there - the failure is not only already recorded but is also 
already analyzed.

If you are a programmer - allow SUM agent to become a natural addition 
to your JVM environment and to stand on guard for you.  Have a new look 
at any java code, now from a new perspective, through animated graphs 
and icons.

The links to video demo:
http://thinkingsoftware.com/video47   - 47 seconds video
http://thinkingsoftware.com/video        - 5 minutes video

The link for ROI calculator, Standard and Enterprise versions:  
http://thinkingsoftware.com/purchase/
The link to the RFOS (Race Free Open Source) version:  
http://thinkingsoftware.com/purchase/rfos

Please let us know your opinion.

suport at ThinkingSoftware.com


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110901/1d02c4a0/attachment.html>

From mike.duigou at oracle.com  Thu Sep  1 15:07:01 2011
From: mike.duigou at oracle.com (Mike Duigou)
Date: Thu, 1 Sep 2011 12:07:01 -0700
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <mailman.294.1314586409.3597.concurrency-interest@cs.oswego.edu>
References: <mailman.294.1314586409.3597.concurrency-interest@cs.oswego.edu>
Message-ID: <7035CA42-02AB-441C-AF35-E977CBB83536@oracle.com>

On Aug 28 2011, at 19:53 , concurrency-interest-request at cs.oswego.edu wrote:
> 
>  4. Re: ConcurrentHashMapV8 (Joe Bowbeer)

> From: Joe Bowbeer <joe.bowbeer at gmail.com>
> Subject: Re: [concurrency-interest] ConcurrentHashMapV8
> First impressions:
> 
> 1. I like the MappingFunction name.  I hope the JDK8 name is as clear *and*
> specialized.


The current proposed name for Java SE 8 is 'Mapper' and it has the same signature as Doug's placeholder.

http://hg.openjdk.java.net/lambda/lambda/jdk/file/38969e64b60e/src/share/classes/java/util/functions/Mapper.java

One key difference is that the proposed Java SE 8 Mapper does not say anything about null handling and it is anticipated that Mapper will be used in places where null must be accommodated. The CHM may choose to just use the Mapper and document it's handling of null or could alternately create a specialized sub-interface to document the extended semantics.

If there are any concerns with the current proposed Mapper or the other basic functional interfaces proposed for Java SE 8 we'd be very interested to hear them on the lambda-dev at openjdk.java.net list.

Thanks!

Mike

From kasper at kav.dk  Thu Sep  1 16:35:39 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Thu, 01 Sep 2011 22:35:39 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <7035CA42-02AB-441C-AF35-E977CBB83536@oracle.com>
References: <mailman.294.1314586409.3597.concurrency-interest@cs.oswego.edu>
	<7035CA42-02AB-441C-AF35-E977CBB83536@oracle.com>
Message-ID: <4E5FEC9B.4000102@kav.dk>

On 01-09-2011 21:07, Mike Duigou wrote:
> On Aug 28 2011, at 19:53 , concurrency-interest-request at cs.oswego.edu wrote:
>>
>>   4. Re: ConcurrentHashMapV8 (Joe Bowbeer)
>
>> From: Joe Bowbeer<joe.bowbeer at gmail.com>
>> Subject: Re: [concurrency-interest] ConcurrentHashMapV8
>> First impressions:
>>
>> 1. I like the MappingFunction name.  I hope the JDK8 name is as clear *and*
>> specialized.
>
>
> The current proposed name for Java SE 8 is 'Mapper' and it has the same signature as Doug's placeholder.
>
> http://hg.openjdk.java.net/lambda/lambda/jdk/file/38969e64b60e/src/share/classes/java/util/functions/Mapper.java
>
> One key difference is that the proposed Java SE 8 Mapper does not say anything about null handling and it is anticipated that Mapper will be used in places where null must be accommodated. The CHM may choose to just use the Mapper and document it's handling of null or could alternately create a specialized sub-interface to document the extended semantics.
>
> If there are any concerns with the current proposed Mapper or the other basic functional interfaces proposed for Java SE 8 we'd be very interested to hear them on the lambda-dev at openjdk.java.net list.
>
> Thanks!
>
> Mike

Thanks for bringing this up. I must admit I really don't like the name 
Block. I might be damage by working to much with concurrency and IO but 
I really thought it had something to do with blocking/non-blocking.

I really like the name Procedure as used in Doug's ParallelArray classes 
much better. 
(http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/extra166y/Ops.java?revision=1.3&view=markup)

cheers
   Kasper



From kasper at kav.dk  Thu Sep  1 16:41:16 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Thu, 01 Sep 2011 22:41:16 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <7035CA42-02AB-441C-AF35-E977CBB83536@oracle.com>
References: <mailman.294.1314586409.3597.concurrency-interest@cs.oswego.edu>
	<7035CA42-02AB-441C-AF35-E977CBB83536@oracle.com>
Message-ID: <4E5FEDEC.6090808@kav.dk>

On 01-09-2011 21:07, Mike Duigou wrote:
> On Aug 28 2011, at 19:53 , concurrency-interest-request at cs.oswego.edu wrote:
> One key difference is that the proposed Java SE 8 Mapper does not say anything about null handling and it is anticipated that Mapper will be used in places where null must be accommodated. The CHM may choose to just use the Mapper and document it's handling of null or could alternately create a specialized sub-interface to document the extended semantics.
No need to create specialized sub-interface for this.
Just document on the Mapper interface that some consumers of this 
interface may place restrictions on the type of output they accept from 
a mapper. Like ju.Map does it. HashMap accepts null keys and values. 
ConcurrentHashMap doesn't.

Cheers
   Kasper

From mohanr at fss.co.in  Fri Sep  2 01:55:43 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Fri, 2 Sep 2011 11:25:43 +0530
Subject: [concurrency-interest] tools for parallel performance debugging
In-Reply-To: <CADiYQu6jx2j2KTZDwFEGzjw6H51PsKnmmXXKNfm4kB-dHHxAqg@mail.gmail.com>
Message-ID: <65F4195D4E2C6042BA66D4114E5BB9DC1067B8@fssbemail.fss.india>

Hi,
      I found this link http://hpctoolkit.org/ from some older references in this forum.


Thanks,
Mohan

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny Dig
Sent: Tuesday, August 30, 2011 12:28 AM
To: Concurrency; Nathan Reynolds
Subject: Re: [concurrency-interest] tools for parallel performance debugging

Thanks Nathan. These tools are all good suggestions. I am curious what
other tools do people on this mailing list use for parallel
programming in Java.

best,
Danny


On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
<nathan.reynolds at oracle.com> wrote:
> For identifying threading correctness issues, I recommend using Java Path
> Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every possible
> thread scheduling combination.  It does so by trying one thread scheduling
> combination and then back tracking (i.e. revert the state of the program) to
> simulate other combinations.  If there is a data race or deadlock, it will
> find it and report it.  It doesn't just tell you that a data race or
> deadlock exists but the steps that got to that state.  Because of the number
> of combinations, it is best to run it on a small piece of the overall
> program.
>
> As for synchronization contention, there are several tools available.
> Looking through a dump of call stacks and seeing where the most threads are
> blocked works for cases where the lock is dropping the throughput by 10% or
> more.  The call stacks are easy to obtain but can be time consuming to sift
> through.  JRockit's Mission Control can tell you exactly which locks are
> most contended and give you the call stacks of where that lock is used.  I
> am pretty sure most of the profilers can tell you which locks are most
> contended, but since JRockit's Mission Control is free for me I haven't
> looked at the profilers for a while.  I thought that JConsole or some tool
> in the JDK could tell you the most contended lock... but I am really not
> sure of that.
>
> As for false sharing, this is something that only the processor can tell
> you.  For Intel, I *think* VTune can tell you about false sharing.  I know
> that VTune can deal with Java optimized code.
>
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 8/24/2011 8:07 PM, Danny Dig wrote:
>
> This community has been providing some great library features for
> taming parallelism in Java.
>
> When it comes to tools for parallel performance debugging, it looks to
> me that Java is trailing behind C++/Intel's ParallelStudio, or
> C#/Microsoft's Visual Studio. When working with Java programs, what
> are the tools that you recommend for:
> - identifying threading correctness issues (e.g., data-races, deadlocks),
> - identifying performance issues (load imbalance, synchronization
> contention, false sharing)
>
> best,
> Danny
>
>



-- 
Danny Dig
Visiting Research Assistant Professor at UIUC

http://netfiles.uiuc.edu/dig/www

Motto: "Success is not for the chosen few but for the few who choose"

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


DISCLAIMER:
==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the author and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================


From heinz at javaspecialists.eu  Fri Sep  2 09:51:53 2011
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Fri, 02 Sep 2011 16:51:53 +0300
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <4E5A95E0.1080309@cs.oswego.edu>
References: <4E5A95E0.1080309@cs.oswego.edu>
Message-ID: <4E60DF79.2080600@javaspecialists.eu>

Hi Doug,

we had a look at the CHM yesterday and were wondering why you did not 
explicitly check for MOVED instead of the more obscure

            else if (e.hash < 0)
                tab = (Node[])e.key;

If would be clearer if that had been:

            else if (e.hash == MOVED)
                tab = (Node[])e.key;

Magic constants are usually a bad idea, even with < 0.

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun Java Champion
IEEE Certified Software Development Professional
http://www.javaspecialists.eu
Tel: +30 69 72 850 460
Skype: kabutz 



On 8/28/11 10:24 PM, Doug Lea wrote:
>
> A candidate replacement for java.util.concurrent.ConcurrentHashMap
> is now available as jsr166e.ConcurrentHashMapV8. This version
> is much more amenable to upcoming support for aggregate
> parallel operations (including, already, method "computeIfAbsent'
> using a stand-in MappingFunction type).
>
> The internal design is interestingly different.
> Read the internal documentation for details.
> (http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?view=log) 
>
>
> Please give it a try, and let us know about experiences.
>
> Links:
>     *  API specs:  http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/
>     * jar file: http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166e.jar 
> (compiled using Java7 javac).
>     * Browsable CVS sources: 
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Fri Sep  2 14:38:58 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 02 Sep 2011 14:38:58 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <4E60DF79.2080600@javaspecialists.eu>
References: <4E5A95E0.1080309@cs.oswego.edu>
	<4E60DF79.2080600@javaspecialists.eu>
Message-ID: <4E6122C2.9000200@cs.oswego.edu>

On 09/02/11 09:51, Dr Heinz M. Kabutz wrote:
> else if (e.hash < 0)
> tab = (Node[])e.key;
>
> If would be clearer if that had been:
>
> else if (e.hash == MOVED)
> tab = (Node[])e.key;
>
> Magic constants are usually a bad idea, even with < 0.

Thanks. Changed to ...
     else if (eh < 0) { // sign bit set -- bin was moved during resize
... (plus some other internal documentation improvements),
because in the next update, forwarding nodes will have other
information encoded in hash fields to support range traversals
needed for parallel aggregate operations. The only distinguishing
property is the sign bit, which is most sensibly expressed as
a check of  < 0.

-Doug

From brian at briangoetz.com  Fri Sep  2 21:42:22 2011
From: brian at briangoetz.com (Brian Goetz)
Date: Fri, 02 Sep 2011 21:42:22 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <CACuKZqGz=xU6R8Qyq8rCRwecSFnQ1jz90u0z4FJB1eVbPou-RQ@mail.gmail.com>
References: <4E5A95E0.1080309@cs.oswego.edu>	<CAHzJPEoXfdgW3xsVF-AL7995qDAc2G5W9Z_6oA3=eVZAEDEsiw@mail.gmail.com>	<4E5BCE50.50205@cs.oswego.edu>	<CAGmsiP6SsNufd=Zkc2J9_xZZvA30q9wZanbUZeFNDvujKuaBdg@mail.gmail.com>	<4E5C2429.3080009@cs.oswego.edu>	<CACuKZqGg++AiZ9s3Q6sozj+S=S2ZL1aM5FEX=TGKwuZ3TnsFAw@mail.gmail.com>	<4E5CC5D4.4040104@cs.oswego.edu>
	<CACuKZqGz=xU6R8Qyq8rCRwecSFnQ1jz90u0z4FJB1eVbPou-RQ@mail.gmail.com>
Message-ID: <4E6185FE.5010204@briangoetz.com>

> In the lambda expression example,
>
>      computeIfAbsent( k, #{ k ->  calc(k) } );
>
> a new object (the function) is created every time, which is quite
> expensive relative to get(). So it pays to

No, this is incorrect for a significant fraction of the cases.  For 
lambdas that don't capture values from the enclosing scope (which is not 
all of them, but a lot of them), no object will be created (after the 
first one.)


From yechielf at gigaspaces.com  Tue Sep  6 04:50:15 2011
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Tue, 6 Sep 2011 01:50:15 -0700
Subject: [concurrency-interest] regarding Striped64 class-
Message-ID: <F5A3854EDBB4D440A098DEF1EFFC922B010F233C94@IE2RD2XVS661.red002.local>

Why are the padding vars of the Cell declared as volatile too ? Sure-they are not touched so no cost. Is it related to Jvm reordering ?

Yechiel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/130e03c6/attachment.html>

From oleksiy.khilkevich at gmail.com  Tue Sep  6 06:13:33 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Tue, 6 Sep 2011 13:13:33 +0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
Message-ID: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>

Hi Concurrency Champs

I'm implementing non-blocking cyclic counter mostly for learning purposes,
and faced the following problem, which i'm not sure how to solve.

The method in question implements the following

    /**
     * Sets counter value to initial (boundary) value
     * @return true if counter value was changed
     */
    boolean reset();

The implementation I'm not sure about

    @Override
    public boolean reset() {
        for (;;) {
            int curValue = value.get();
            int curBoundary = boundary.get();
            if (curValue == curBoundary) return false;

            // TODO: if boundary and value were not changed, set the value
to boundary

            return true;
        }
    }

Here I have two values which are both AtomicIntegers and which may change -
value can be incremented or decremented by another thread, and boundary can
be changed too.

I'm not quite sure how to do this without introducing critical sections. In
general the question refers to any shared state change based on values of
several other shared states.

What is the correct way to implement such operation atomically without
critical sections? IS it possible to build composite CAS operations based on
AtomicInteger#compareAndSet ?

Thank you and kindly waiting for your ideas
Oleksiy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/592eafae/attachment.html>

From oleksiy.khilkevich at gmail.com  Tue Sep  6 06:23:17 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Tue, 6 Sep 2011 13:23:17 +0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
References: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
Message-ID: <CANUh1YzBPX6AJ0R83v6r7TVVa6vp5YtqWStcXM59-M1y1CNA=Q@mail.gmail.com>

One way came to my mind right now, is there possibility to introduce
versioning here?
Say AtomicInteger version is incremented each time, the counter state is
changed, whether it is boundary change or value change. And instead of
checking value and boundary I'll just check if the version was changed?

Looks like a possibility to me, but please judge my thinking :)

Thanks

2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

> Hi Concurrency Champs
>
> I'm implementing non-blocking cyclic counter mostly for learning purposes,
> and faced the following problem, which i'm not sure how to solve.
>
> The method in question implements the following
>
>     /**
>      * Sets counter value to initial (boundary) value
>      * @return true if counter value was changed
>      */
>     boolean reset();
>
> The implementation I'm not sure about
>
>     @Override
>     public boolean reset() {
>         for (;;) {
>             int curValue = value.get();
>             int curBoundary = boundary.get();
>             if (curValue == curBoundary) return false;
>
>             // TODO: if boundary and value were not changed, set the value
> to boundary
>
>             return true;
>         }
>     }
>
> Here I have two values which are both AtomicIntegers and which may change -
> value can be incremented or decremented by another thread, and boundary can
> be changed too.
>
> I'm not quite sure how to do this without introducing critical sections. In
> general the question refers to any shared state change based on values of
> several other shared states.
>
> What is the correct way to implement such operation atomically without
> critical sections? IS it possible to build composite CAS operations based on
> AtomicInteger#compareAndSet ?
>
> Thank you and kindly waiting for your ideas
> Oleksiy
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/b99aa3e6/attachment.html>

From daniel.yokomizo at gmail.com  Tue Sep  6 06:39:54 2011
From: daniel.yokomizo at gmail.com (Daniel Yokomizo)
Date: Tue, 6 Sep 2011 07:39:54 -0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1YzBPX6AJ0R83v6r7TVVa6vp5YtqWStcXM59-M1y1CNA=Q@mail.gmail.com>
References: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
	<CANUh1YzBPX6AJ0R83v6r7TVVa6vp5YtqWStcXM59-M1y1CNA=Q@mail.gmail.com>
Message-ID: <CAOF0wK-kdg03vAfE1BLREniSMHdkzzYO3aHTR_kOxo9Cw1o92Q@mail.gmail.com>

java.util.concurrent.atomic.AtomicStampedReference<V> may be relevant to
your problem.

On Sep 6, 2011 7:26 AM, "Oleksiy Khilkevich" <oleksiy.khilkevich at gmail.com>
wrote:
>
> One way came to my mind right now, is there possibility to introduce
versioning here?
> Say AtomicInteger version is incremented each time, the counter state is
changed, whether it is boundary change or value change. And instead of
checking value and boundary I'll just check if the version was changed?
>
> Looks like a possibility to me, but please judge my thinking :)
>
> Thanks
>
> 2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
>>
>> Hi Concurrency Champs
>>
>> I'm implementing non-blocking cyclic counter mostly for learning
purposes, and faced the following problem, which i'm not sure how to solve.
>>
>> The method in question implements the following
>>
>>     /**
>>      * Sets counter value to initial (boundary) value
>>      * @return true if counter value was changed
>>      */
>>     boolean reset();
>>
>> The implementation I'm not sure about
>>
>>     @Override
>>     public boolean reset() {
>>         for (;;) {
>>             int curValue = value.get();
>>             int curBoundary = boundary.get();
>>             if (curValue == curBoundary) return false;
>>
>>             // TODO: if boundary and value were not changed, set the
value to boundary
>>
>>             return true;
>>         }
>>     }
>>
>> Here I have two values which are both AtomicIntegers and which may change
- value can be incremented or decremented by another thread, and boundary
can be changed too.
>>
>> I'm not quite sure how to do this without introducing critical sections.
In general the question refers to any shared state change based on values of
several other shared states.
>>
>> What is the correct way to implement such operation atomically without
critical sections? IS it possible to build composite CAS operations based on
AtomicInteger#compareAndSet ?
>>
>> Thank you and kindly waiting for your ideas
>> Oleksiy
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/13df3537/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep  6 06:51:20 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 6 Sep 2011 20:51:20 +1000
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIELPIPAA.davidcholmes@aapt.net.au>

You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.

I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

David Holmes

  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
  Sent: Tuesday, 6 September 2011 8:14 PM
  To: Concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


  Hi Concurrency Champs


  I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


  The method in question implements the following 


      /**
       * Sets counter value to initial (boundary) value
       * @return true if counter value was changed
       */
      boolean reset();


  The implementation I'm not sure about


      @Override
      public boolean reset() {
          for (;;) {
              int curValue = value.get();
              int curBoundary = boundary.get();
              if (curValue == curBoundary) return false;


              // TODO: if boundary and value were not changed, set the value to boundary


              return true;
          }
      }


  Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


  I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


  What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


  Thank you and kindly waiting for your ideas
  Oleksiy

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/46befdb2/attachment-0001.html>

From dl at cs.oswego.edu  Tue Sep  6 07:00:16 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 06 Sep 2011 07:00:16 -0400
Subject: [concurrency-interest] regarding Striped64 class-
In-Reply-To: <F5A3854EDBB4D440A098DEF1EFFC922B010F233C94@IE2RD2XVS661.red002.local>
References: <F5A3854EDBB4D440A098DEF1EFFC922B010F233C94@IE2RD2XVS661.red002.local>
Message-ID: <4E65FD40.3030703@cs.oswego.edu>

On 09/06/11 04:50, Yechiel Feffer wrote:
> Why are the padding vars of the Cell declared as volatile too ? Sure-they are
> not touched so no cost. Is it related to Jvm reordering ?

Until some standardized form of advice appears (a new "@Contended"
annotation is the best proposal I've heard), the most effective
way to do padding is entirely empirical. The way it is done
in Striped64.Cell works well for volatile longs on current
versions of OpenJDK/hotspot and IBM J9, and might not generalize.
However, VMs are known to sometimes reorder fields based on
types and qualifiers, so using the exact same types and qualifiers
is a good rule of thumb.

BTW, people seeing a lot of cache contention problems might
also try the hotspot switch -XX:+UseCondCardMark.

-Doug





From viktor.klang at gmail.com  Tue Sep  6 07:57:43 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 6 Sep 2011 13:57:43 +0200
Subject: [concurrency-interest] regarding Striped64 class-
In-Reply-To: <4E65FD40.3030703@cs.oswego.edu>
References: <F5A3854EDBB4D440A098DEF1EFFC922B010F233C94@IE2RD2XVS661.red002.local>
	<4E65FD40.3030703@cs.oswego.edu>
Message-ID: <CANPzfU9ERb+Jqy8zCmdsnmgwzphL1CJsrdb1p_+3fsuuDRQC-Q@mail.gmail.com>

On Tue, Sep 6, 2011 at 1:00 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 09/06/11 04:50, Yechiel Feffer wrote:
>
>> Why are the padding vars of the Cell declared as volatile too ? Sure-they
>> are
>> not touched so no cost. Is it related to Jvm reordering ?
>>
>
> Until some standardized form of advice appears (a new "@Contended"
> annotation is the best proposal I've heard), the most effective
> way to do padding is entirely empirical. The way it is done
> in Striped64.Cell works well for volatile longs on current
> versions of OpenJDK/hotspot and IBM J9, and might not generalize.
> However, VMs are known to sometimes reorder fields based on
> types and qualifiers, so using the exact same types and qualifiers
> is a good rule of thumb.
>

Would be nice with a @NoFalseSharingPlease ;-)


>
> BTW, people seeing a lot of cache contention problems might
> also try the hotspot switch -XX:+UseCondCardMark.
>
> -Doug
>
>
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/302deab5/attachment.html>

From oleksiy.khilkevich at gmail.com  Tue Sep  6 08:07:15 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Tue, 6 Sep 2011 15:07:15 +0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1Yy-mYUtSH4o+327K1eYjOjhB_qrzGi=0FTxB3_wu+rr8Q@mail.gmail.com>
References: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIELPIPAA.davidcholmes@aapt.net.au>
	<CANUh1Yy-mYUtSH4o+327K1eYjOjhB_qrzGi=0FTxB3_wu+rr8Q@mail.gmail.com>
Message-ID: <CANUh1YztpD3UKYHvVBzu6nPp2a_XFK4i2RcsJvs+tPGZ3NoTug@mail.gmail.com>

It just happens on occasion :)

2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

> Hi David and folks
>
> 2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>
>> **
>> You can not compose CAS operations to get atomic updates to multiple
>> variables. A DCAS would solve your problem but we don't have one :)
>> AtomicStampedReference (as mentioned by Daniel) is a very restricted form of
>> DCAS and in fact is implemented by locking in the JDK.
>>
>>
> Can you tell in more detail about DCAS concept? Maybe some relevant link?
> Google is not of much help unfortunately. I'll try to figure
> AtomicStampedReference in the meantime.
>
> You either need a mutual exclusion mechanism that is applied to all
>> variables (eg locking), or you need a protocol that allows optimistic
>> updates and can account for conflicts/contention. Or you encode both
>> variables into a single atomic variable.
>>
> I thought about encoding the state in a single variable as well, but I was
> also looking for some general approach to such case. Single-state variable
> is not very scalable.
>
>>
>> I must admit though that I don't really understand the semantics of your
>> reset() operation, and I'm unclear why the value and the boundary can be
>> modified independently.
>>
>>
> The cyclic counter is supposed to incrementally decrease its value from
> some boundary till zero and set it value again to boundary, in my
> implementation, the boundary is supposed to be adjustable, so you can
> increase or decrease counter value space in thread-safe manner. the reset()
> is supposed to reset the counter value to it's boundary.
>
> I plan to reuse this interface further to implement work schedulers and few
> similar things on top of it in my further journey through
> java.util.concurrent.*
>
> I've attached the interface so you have an idea about it.
>
> @Viktor: no, am looking into it, transactional memory is somewhere deep
> inside my learning backlog :o)
>
> Thanks for all your answers
> Oleksiy
>
>
>>
>  David Holmes
>>
>>
>> -----Original Message-----
>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Oleksiy
>> Khilkevich
>> *Sent:* Tuesday, 6 September 2011 8:14 PM
>> *To:* Concurrency-interest at cs.oswego.edu
>> *Subject:* [concurrency-interest] Composite compare-and-swap based on
>> twovalues
>>
>> Hi Concurrency Champs
>>
>> I'm implementing non-blocking cyclic counter mostly for learning purposes,
>> and faced the following problem, which i'm not sure how to solve.
>>
>> The method in question implements the following
>>
>>     /**
>>      * Sets counter value to initial (boundary) value
>>      * @return true if counter value was changed
>>      */
>>     boolean reset();
>>
>> The implementation I'm not sure about
>>
>>     @Override
>>     public boolean reset() {
>>         for (;;) {
>>             int curValue = value.get();
>>             int curBoundary = boundary.get();
>>             if (curValue == curBoundary) return false;
>>
>>             // TODO: if boundary and value were not changed, set the value
>> to boundary
>>
>>             return true;
>>         }
>>     }
>>
>> Here I have two values which are both AtomicIntegers and which may change
>> - value can be incremented or decremented by another thread, and boundary
>> can be changed too.
>>
>> I'm not quite sure how to do this without introducing critical sections.
>> In general the question refers to any shared state change based on values of
>> several other shared states.
>>
>> What is the correct way to implement such operation atomically without
>> critical sections? IS it possible to build composite CAS operations based on
>> AtomicInteger#compareAndSet ?
>>
>> Thank you and kindly waiting for your ideas
>> Oleksiy
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/476fa4ac/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep  6 08:27:41 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 6 Sep 2011 22:27:41 +1000
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1YztpD3UKYHvVBzu6nPp2a_XFK4i2RcsJvs+tPGZ3NoTug@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEMAIPAA.davidcholmes@aapt.net.au>

DCAS is double-compare-and-swap. It allows you to atomically check and update two independent memory locations. No current hardware that I know supports it. It makes some lock-free algorithms trivial to implement in theory.

AtomicStampedReference is a special variant of storing two logical values in one variable, but if I recall correctly the second variable here is limited to 1-bit - a mark or stamp bit. This could be implemented by using the unused address bits to hold the stamp/mark while the variable holds the actual data. But in the JDK it is just doned with locking. Some lock free algorthims are based on having this kind of composite variable.

But based on your description of the counter and the boundary it isn't clear to me that reset() needs to be atomic, as the boundary or value could change the instant after you set them anyway.

Cheers,
David
  -----Original Message-----
  From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
  Sent: Tuesday, 6 September 2011 10:07 PM
  To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


  It just happens on occasion :)


  2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

    Hi David and folks


    2011/9/6 David Holmes <davidcholmes at aapt.net.au>

      You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

    Can you tell in more detail about DCAS concept? Maybe some relevant link? Google is not of much help unfortunately. I'll try to figure AtomicStampedReference in the meantime.


      You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.
    I thought about encoding the state in a single variable as well, but I was also looking for some general approach to such case. Single-state variable is not very scalable.  

      I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

    The cyclic counter is supposed to incrementally decrease its value from some boundary till zero and set it value again to boundary, in my implementation, the boundary is supposed to be adjustable, so you can increase or decrease counter value space in thread-safe manner. the reset() is supposed to reset the counter value to it's boundary.


    I plan to reuse this interface further to implement work schedulers and few similar things on top of it in my further journey through java.util.concurrent.*


    I've attached the interface so you have an idea about it.


    @Viktor: no, am looking into it, transactional memory is somewhere deep inside my learning backlog :o)

    Thanks for all your answers
    Oleksiy



      David Holmes

        -----Original Message-----
        From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
        Sent: Tuesday, 6 September 2011 8:14 PM
        To: Concurrency-interest at cs.oswego.edu
        Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


        Hi Concurrency Champs 


        I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


        The method in question implements the following 


            /**
             * Sets counter value to initial (boundary) value
             * @return true if counter value was changed
             */
            boolean reset();


        The implementation I'm not sure about


            @Override
            public boolean reset() {
                for (;;) {
                    int curValue = value.get();
                    int curBoundary = boundary.get();
                    if (curValue == curBoundary) return false;


                    // TODO: if boundary and value were not changed, set the value to boundary


                    return true;
                }
            }


        Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


        I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


        What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


        Thank you and kindly waiting for your ideas
        Oleksiy





-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/7b7e0d6d/attachment-0001.html>

From kasper at kav.dk  Tue Sep  6 08:28:32 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Tue, 06 Sep 2011 14:28:32 +0200
Subject: [concurrency-interest] Composite compare-and-swap based on two
 values
In-Reply-To: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
References: <CANUh1YzyutbKuKth9yb2x_awEEE9GS83eZVk6yOiatYhJDAEtA@mail.gmail.com>
Message-ID: <4E6611F0.8010705@kav.dk>

Since you are using to ints.
You might just go with an AtomicLong and mask the values.

(high 32 bits = value, low 32 bits = boundary)

cheers
   Kasper


On 06-09-2011 12:13, Oleksiy Khilkevich wrote:
> Hi Concurrency Champs
>
> I'm implementing non-blocking cyclic counter mostly for learning
> purposes, and faced the following problem, which i'm not sure how to solve.
>
> The method in question implements the following
>
>      /**
>       * Sets counter value to initial (boundary) value
>       * @return true if counter value was changed
>       */
>      boolean reset();
>
> The implementation I'm not sure about
>
>      @Override
>      public boolean reset() {
>          for (;;) {
>              int curValue = value.get();
>              int curBoundary = boundary.get();
>              if (curValue == curBoundary) return false;
>
>              // TODO: if boundary and value were not changed, set the
> value to boundary
>
>              return true;
>          }
>      }
>
> Here I have two values which are both AtomicIntegers and which may
> change - value can be incremented or decremented by another thread, and
> boundary can be changed too.
>
> I'm not quite sure how to do this without introducing critical sections.
> In general the question refers to any shared state change based on
> values of several other shared states.
>
> What is the correct way to implement such operation atomically without
> critical sections? IS it possible to build composite CAS operations
> based on AtomicInteger#compareAndSet ?
>
> Thank you and kindly waiting for your ideas
> Oleksiy
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksiy.khilkevich at gmail.com  Tue Sep  6 08:45:58 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Tue, 6 Sep 2011 15:45:58 +0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEMAIPAA.davidcholmes@aapt.net.au>
References: <CANUh1YztpD3UKYHvVBzu6nPp2a_XFK4i2RcsJvs+tPGZ3NoTug@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEMAIPAA.davidcholmes@aapt.net.au>
Message-ID: <CANUh1YxpBdKWW__8Sxfo9H37LYy_os9+hYH+Vhi_qerEf4ZKpQ@mail.gmail.com>

I guess you mean AtomicMarkableReference. stamped one indeed provides the
versioning that can help - it stores the int as a stamp. I think it's quite
possible to emulate DCAS with help of these classes.

Regarding the reset() i'm just trying to stick to the contract i've imposed
on it (so it return true if the counter value was really reset). Without
requirement to return change status, i'd not bother at all

But surprisingly to provide more information out of reset() i faced this
interesting issue. The drawback is the performance drop on reset() due to
possible contention, but i expect value to be changed magnitudes more
frequently than boundary, so performance should not be a problem.

TBH, I can't even imagine the practical case when i'd need reset() at all, I
am very short on useful and realistic concurrency examples. If anybody has a
treasure chest of such examples, I'd be infinitely grateful.

But since reset() it's there, I now can't ignore it :)

Oleksiy

2011/9/6 David Holmes <davidcholmes at aapt.net.au>

> **
> DCAS is double-compare-and-swap. It allows you to atomically check and
> update two independent memory locations. No current hardware that I
> know supports it. It makes some lock-free algorithms trivial to implement in
> theory.
>
> AtomicStampedReference is a special variant of storing two logical values
> in one variable, but if I recall correctly the second variable here is
> limited to 1-bit - a mark or stamp bit. This could be implemented by using
> the unused address bits to hold the stamp/mark while the variable holds the
> actual data. But in the JDK it is just doned with locking. Some lock free
> algorthims are based on having this kind of composite variable.
>
> But based on your description of the counter and the boundary it isn't
> clear to me that reset() needs to be atomic, as the boundary or value could
> change the instant after you set them anyway.
>
> Cheers,
> David
>
> -----Original Message-----
> *From:* Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
> *Sent:* Tuesday, 6 September 2011 10:07 PM
> *To:* dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> It just happens on occasion :)
>
> 2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
>
>> Hi David and folks
>>
>>  2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>>
>>> **
>>> You can not compose CAS operations to get atomic updates to multiple
>>> variables. A DCAS would solve your problem but we don't have one :)
>>> AtomicStampedReference (as mentioned by Daniel) is a very restricted form of
>>> DCAS and in fact is implemented by locking in the JDK.
>>>
>>>
>> Can you tell in more detail about DCAS concept? Maybe some relevant link?
>> Google is not of much help unfortunately. I'll try to figure
>> AtomicStampedReference in the meantime.
>>
>>
>>
>>>  You either need a mutual exclusion mechanism that is applied to all
>>> variables (eg locking), or you need a protocol that allows optimistic
>>> updates and can account for conflicts/contention. Or you encode both
>>> variables into a single atomic variable.
>>>
>> I thought about encoding the state in a single variable as well, but I was
>> also looking for some general approach to such case. Single-state variable
>> is not very scalable.
>>
>>>
>>> I must admit though that I don't really understand the semantics of your
>>> reset() operation, and I'm unclear why the value and the boundary can be
>>> modified independently.
>>>
>>>
>> The cyclic counter is supposed to incrementally decrease its value from
>> some boundary till zero and set it value again to boundary, in my
>> implementation, the boundary is supposed to be adjustable, so you can
>> increase or decrease counter value space in thread-safe manner. the reset()
>> is supposed to reset the counter value to it's boundary.
>>
>> I plan to reuse this interface further to implement work schedulers and
>> few similar things on top of it in my further journey through
>> java.util.concurrent.*
>>
>> I've attached the interface so you have an idea about it.
>>
>> @Viktor: no, am looking into it, transactional memory is somewhere deep
>> inside my learning backlog :o)
>>
>> Thanks for all your answers
>> Oleksiy
>>
>>
>>>
>>  David Holmes
>>>
>>>
>>> -----Original Message-----
>>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>>> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Oleksiy
>>> Khilkevich
>>> *Sent:* Tuesday, 6 September 2011 8:14 PM
>>> *To:* Concurrency-interest at cs.oswego.edu
>>> *Subject:* [concurrency-interest] Composite compare-and-swap based on
>>> twovalues
>>>
>>> Hi Concurrency Champs
>>>
>>> I'm implementing non-blocking cyclic counter mostly for learning
>>> purposes, and faced the following problem, which i'm not sure how to solve.
>>>
>>> The method in question implements the following
>>>
>>>     /**
>>>      * Sets counter value to initial (boundary) value
>>>      * @return true if counter value was changed
>>>      */
>>>     boolean reset();
>>>
>>> The implementation I'm not sure about
>>>
>>>     @Override
>>>     public boolean reset() {
>>>         for (;;) {
>>>             int curValue = value.get();
>>>             int curBoundary = boundary.get();
>>>             if (curValue == curBoundary) return false;
>>>
>>>             // TODO: if boundary and value were not changed, set the
>>> value to boundary
>>>
>>>             return true;
>>>         }
>>>     }
>>>
>>> Here I have two values which are both AtomicIntegers and which may change
>>> - value can be incremented or decremented by another thread, and boundary
>>> can be changed too.
>>>
>>> I'm not quite sure how to do this without introducing critical sections.
>>> In general the question refers to any shared state change based on values of
>>> several other shared states.
>>>
>>> What is the correct way to implement such operation atomically without
>>> critical sections? IS it possible to build composite CAS operations based on
>>> AtomicInteger#compareAndSet ?
>>>
>>> Thank you and kindly waiting for your ideas
>>> Oleksiy
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110906/884f7143/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep  6 17:48:06 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 7 Sep 2011 07:48:06 +1000
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1YxpBdKWW__8Sxfo9H37LYy_os9+hYH+Vhi_qerEf4ZKpQ@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>

Sorry - yes I was mixing AtomicMarkableReference and AtomicStampedreference. AtomicStampedReference does present itself in a form similar to DCAS.

Good luck.

David
  -----Original Message-----
  From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
  Sent: Tuesday, 6 September 2011 10:46 PM
  To: dholmes at ieee.org
  Cc: Concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


  I guess you mean AtomicMarkableReference. stamped one indeed provides the versioning that can help - it stores the int as a stamp. I think it's quite possible to emulate DCAS with help of these classes.


  Regarding the reset() i'm just trying to stick to the contract i've imposed on it (so it return true if the counter value was really reset). Without requirement to return change status, i'd not bother at all 


  But surprisingly to provide more information out of reset() i faced this interesting issue. The drawback is the performance drop on reset() due to possible contention, but i expect value to be changed magnitudes more frequently than boundary, so performance should not be a problem.


  TBH, I can't even imagine the practical case when i'd need reset() at all, I am very short on useful and realistic concurrency examples. If anybody has a treasure chest of such examples, I'd be infinitely grateful.


  But since reset() it's there, I now can't ignore it :)


  Oleksiy


  2011/9/6 David Holmes <davidcholmes at aapt.net.au>

    DCAS is double-compare-and-swap. It allows you to atomically check and update two independent memory locations. No current hardware that I know supports it. It makes some lock-free algorithms trivial to implement in theory.

    AtomicStampedReference is a special variant of storing two logical values in one variable, but if I recall correctly the second variable here is limited to 1-bit - a mark or stamp bit. This could be implemented by using the unused address bits to hold the stamp/mark while the variable holds the actual data. But in the JDK it is just doned with locking. Some lock free algorthims are based on having this kind of composite variable.

    But based on your description of the counter and the boundary it isn't clear to me that reset() needs to be atomic, as the boundary or value could change the instant after you set them anyway.

    Cheers,
    David
      -----Original Message-----
      From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
      Sent: Tuesday, 6 September 2011 10:07 PM
      To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
      Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


      It just happens on occasion :)


      2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

        Hi David and folks


        2011/9/6 David Holmes <davidcholmes at aapt.net.au>

          You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

        Can you tell in more detail about DCAS concept? Maybe some relevant link? Google is not of much help unfortunately. I'll try to figure AtomicStampedReference in the meantime.

         
          You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.
        I thought about encoding the state in a single variable as well, but I was also looking for some general approach to such case. Single-state variable is not very scalable.  

          I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

        The cyclic counter is supposed to incrementally decrease its value from some boundary till zero and set it value again to boundary, in my implementation, the boundary is supposed to be adjustable, so you can increase or decrease counter value space in thread-safe manner. the reset() is supposed to reset the counter value to it's boundary.


        I plan to reuse this interface further to implement work schedulers and few similar things on top of it in my further journey through java.util.concurrent.*


        I've attached the interface so you have an idea about it.


        @Viktor: no, am looking into it, transactional memory is somewhere deep inside my learning backlog :o)

        Thanks for all your answers
        Oleksiy



          David Holmes

            -----Original Message-----
            From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
            Sent: Tuesday, 6 September 2011 8:14 PM
            To: Concurrency-interest at cs.oswego.edu
            Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


            Hi Concurrency Champs 


            I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


            The method in question implements the following 


                /**
                 * Sets counter value to initial (boundary) value
                 * @return true if counter value was changed
                 */
                boolean reset();


            The implementation I'm not sure about


                @Override
                public boolean reset() {
                    for (;;) {
                        int curValue = value.get();
                        int curBoundary = boundary.get();
                        if (curValue == curBoundary) return false;


                        // TODO: if boundary and value were not changed, set the value to boundary


                        return true;
                    }
                }


            Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


            I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


            What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


            Thank you and kindly waiting for your ideas
            Oleksiy







-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110907/aaca6eaf/attachment.html>

From davidcholmes at aapt.net.au  Tue Sep  6 17:51:24 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 7 Sep 2011 07:51:24 +1000
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>

But I should add that this form of DCAS is no different to choosing to encode your two values into one variable.

David
  -----Original Message-----
  From: David Holmes [mailto:davidcholmes at aapt.net.au]
  Sent: Wednesday, 7 September 2011 7:48 AM
  To: Oleksiy Khilkevich
  Cc: Concurrency-interest at cs.oswego.edu
  Subject: RE: [concurrency-interest] Composite compare-and-swap based on two values


  Sorry - yes I was mixing AtomicMarkableReference and AtomicStampedreference. AtomicStampedReference does present itself in a form similar to DCAS.

  Good luck.

  David
    -----Original Message-----
    From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
    Sent: Tuesday, 6 September 2011 10:46 PM
    To: dholmes at ieee.org
    Cc: Concurrency-interest at cs.oswego.edu
    Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


    I guess you mean AtomicMarkableReference. stamped one indeed provides the versioning that can help - it stores the int as a stamp. I think it's quite possible to emulate DCAS with help of these classes. 


    Regarding the reset() i'm just trying to stick to the contract i've imposed on it (so it return true if the counter value was really reset). Without requirement to return change status, i'd not bother at all 


    But surprisingly to provide more information out of reset() i faced this interesting issue. The drawback is the performance drop on reset() due to possible contention, but i expect value to be changed magnitudes more frequently than boundary, so performance should not be a problem.


    TBH, I can't even imagine the practical case when i'd need reset() at all, I am very short on useful and realistic concurrency examples. If anybody has a treasure chest of such examples, I'd be infinitely grateful.


    But since reset() it's there, I now can't ignore it :)


    Oleksiy


    2011/9/6 David Holmes <davidcholmes at aapt.net.au>

      DCAS is double-compare-and-swap. It allows you to atomically check and update two independent memory locations. No current hardware that I know supports it. It makes some lock-free algorithms trivial to implement in theory.

      AtomicStampedReference is a special variant of storing two logical values in one variable, but if I recall correctly the second variable here is limited to 1-bit - a mark or stamp bit. This could be implemented by using the unused address bits to hold the stamp/mark while the variable holds the actual data. But in the JDK it is just doned with locking. Some lock free algorthims are based on having this kind of composite variable.

      But based on your description of the counter and the boundary it isn't clear to me that reset() needs to be atomic, as the boundary or value could change the instant after you set them anyway.

      Cheers,
      David
        -----Original Message-----
        From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
        Sent: Tuesday, 6 September 2011 10:07 PM
        To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
        Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


        It just happens on occasion :)


        2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

          Hi David and folks


          2011/9/6 David Holmes <davidcholmes at aapt.net.au>

            You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

          Can you tell in more detail about DCAS concept? Maybe some relevant link? Google is not of much help unfortunately. I'll try to figure AtomicStampedReference in the meantime.

           
            You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.
          I thought about encoding the state in a single variable as well, but I was also looking for some general approach to such case. Single-state variable is not very scalable.  

            I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

          The cyclic counter is supposed to incrementally decrease its value from some boundary till zero and set it value again to boundary, in my implementation, the boundary is supposed to be adjustable, so you can increase or decrease counter value space in thread-safe manner. the reset() is supposed to reset the counter value to it's boundary.


          I plan to reuse this interface further to implement work schedulers and few similar things on top of it in my further journey through java.util.concurrent.*


          I've attached the interface so you have an idea about it.


          @Viktor: no, am looking into it, transactional memory is somewhere deep inside my learning backlog :o)

          Thanks for all your answers
          Oleksiy



            David Holmes

              -----Original Message-----
              From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
              Sent: Tuesday, 6 September 2011 8:14 PM
              To: Concurrency-interest at cs.oswego.edu
              Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


              Hi Concurrency Champs 


              I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


              The method in question implements the following 


                  /**
                   * Sets counter value to initial (boundary) value
                   * @return true if counter value was changed
                   */
                  boolean reset();


              The implementation I'm not sure about


                  @Override
                  public boolean reset() {
                      for (;;) {
                          int curValue = value.get();
                          int curBoundary = boundary.get();
                          if (curValue == curBoundary) return false;


                          // TODO: if boundary and value were not changed, set the value to boundary


                          return true;
                      }
                  }


              Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


              I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


              What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


              Thank you and kindly waiting for your ideas
              Oleksiy







-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110907/cd7028cd/attachment-0001.html>

From vgrazi at gmail.com  Wed Sep  7 15:46:05 2011
From: vgrazi at gmail.com (Victor Grazi)
Date: Wed, 7 Sep 2011 19:46:05 +0000
Subject: [concurrency-interest] Does Semaphore have the same memory model
	visibility guarantees as synchronizing?
Message-ID: <CA+y1Pu8WfTWZpCv+qzt8nCWDxR99xAkocomV6ZwY0BfBVvT3OA@mail.gmail.com>

Hi - The JMM guarantees that when a Thread A enters a block that is
synchronized on some object, it is guaranteed to see anything that had been
visible to another thread B when thread B was synchronized on the same
object.

ReentrantLock has the same characteristic.

Is Semaphore required to have the same semantics?

Thanks, Victor
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110907/4a111244/attachment.html>

From kasper at kav.dk  Wed Sep  7 16:10:39 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Wed, 07 Sep 2011 22:10:39 +0200
Subject: [concurrency-interest] Does Semaphore have the same memory
 model visibility guarantees as synchronizing?
In-Reply-To: <CA+y1Pu8WfTWZpCv+qzt8nCWDxR99xAkocomV6ZwY0BfBVvT3OA@mail.gmail.com>
References: <CA+y1Pu8WfTWZpCv+qzt8nCWDxR99xAkocomV6ZwY0BfBVvT3OA@mail.gmail.com>
Message-ID: <4E67CFBF.7050007@kav.dk>

On 07-09-2011 21:46, Victor Grazi wrote:
> Hi - The JMM guarantees that when a Thread A enters a block that is
> synchronized on some object, it is guaranteed to see anything that had
> been visible to another thread B when thread B was synchronized on the
> same object.
>
> ReentrantLock has the same characteristic.
>
> Is Semaphore required to have the same semantics?
>
> Thanks, Victor

 From Semaphore.java

Memory consistency effects: Actions in a thread prior to calling a 
"release" method such as release() happen-before actions following a 
successful "acquire" method such as acquire() in another thread.

So I guess the answer is yes.

- Kasper

From dl at cs.oswego.edu  Thu Sep  8 07:45:13 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 08 Sep 2011 07:45:13 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <4E5A95E0.1080309@cs.oswego.edu>
References: <4E5A95E0.1080309@cs.oswego.edu>
Message-ID: <4E68AAC9.9070800@cs.oswego.edu>


Among some further ongoing improvements and extensions (mainly
to support parallel aggregate operations), I'm contemplating
(nearly) ignoring "loadFactor" constructor arguments for
ConcurrentHashMap (in "V8" form for now, but ultimately
targeting revised j.u.c version). The main motivation
is that in concurrent hash maps  (of any form) collisions
and contention are interdependent, so anyone using a
higher-than-default load factor because they think it will
save space is also unexpectedly getting poorer multithreaded
performance. Given how hard it was to give clear answers to
questions on this list about exactly what blocks when based on
probability distributions with a parameter based on load factor,
I'm now thinking that is best to internally always use
the default, and use the optional constructor parameter
only as an initial sizing hint (larger loadFactor ->
smaller initial capacity).  This will enable simpler
characterization of expected performance.

Scanning for uses of ConcurrentHashMap constructors
on google code search, it seems that hardly anyone ever
overrides the default anyway, so this probably doesn't
matter much either way. But if you have ever done so,
and have a good reason, could you let me know? Thanks!

-Doug



From alex at puredanger.com  Thu Sep  8 12:10:51 2011
From: alex at puredanger.com (Alex Miller)
Date: Thu, 8 Sep 2011 11:10:51 -0500
Subject: [concurrency-interest] ConcurrentHashMapV8
Message-ID: <CAOdgdgz5s0PGibsp9CtoHs4=-qcE++G_EFYeu-jvCOWCDKpFfQ@mail.gmail.com>

> Doug Lea said:

> Scanning for uses of ConcurrentHashMap constructors
> on google code search, it seems that hardly anyone ever
> overrides the default anyway, so this probably doesn't
> matter much either way. But if you have ever done so,
> and have a good reason, could you let me know? Thanks!

I think the only time I have ever seen someone use an alternate load
factor is in the case where they are creating a Map that has a known
maximum fixed size and they want to ensure that the map will never
need to rehash.  It might be helpful to specify in Javadoc how to
achieve that goal.

Alex

From oleksiy.khilkevich at gmail.com  Thu Sep  8 12:50:33 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Thu, 8 Sep 2011 19:50:33 +0300
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>
Message-ID: <CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>

Hi All

Getting back to this I'd like to present what I've came up with. I need a
volunteer for code review.

I'm going to give a tech talk about java.util.concurrent soon, so The Right
Way(tm) and bug-free code is critical

Here is a piece of cyclic counter responsible for reset

    // CounterState is private nested class to hold value and boundary, see
attached source
    @Override
    public boolean reset() {
        for (;;) {
            int[] stampHolder = new int[1];
            CounterState current = stateRef.get(stampHolder); // 1
            int currentStamp = stampHolder[0];

            if (current.value == current.boundary) return false;

            CounterState next = new CounterState(current.boundary,
current.boundary);
            if (stateRef.compareAndSet(current, next, currentStamp,
currentStamp + 1)) {
                return true;
            }
        }
    }

If I am not mistaken, at (!) i can't just access
stateRef.getReference().value and stateRef.getReference.boundary, as stamp
can change in between of that reads, so i need to get

Also in general, the more complex is shared state, the more performance
degradation would be on state writes, as there is more contention over the
shared state.

I've attached the source in case you may wanna look

Thanks and waiting for the feedback
Oleksiy

2011/9/7 David Holmes <davidcholmes at aapt.net.au>

> **
> But I should add that this form of DCAS is no different to choosing to
> encode your two values into one variable.
>
> David
>
> -----Original Message-----
> *From:* David Holmes [mailto:davidcholmes at aapt.net.au]
> *Sent:* Wednesday, 7 September 2011 7:48 AM
> *To:* Oleksiy Khilkevich
> *Cc:* Concurrency-interest at cs.oswego.edu
> *Subject:* RE: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> Sorry - yes I was mixing AtomicMarkableReference and
> AtomicStampedreference. AtomicStampedReference does present itself in a form
> similar to DCAS.
>
> Good luck.
>
> David
>
> -----Original Message-----
> *From:* Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
> *Sent:* Tuesday, 6 September 2011 10:46 PM
> *To:* dholmes at ieee.org
> *Cc:* Concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> I guess you mean AtomicMarkableReference. stamped one indeed provides the
> versioning that can help - it stores the int as a stamp. I think it's quite
> possible to emulate DCAS with help of these classes.
>
> Regarding the reset() i'm just trying to stick to the contract i've imposed
> on it (so it return true if the counter value was really reset). Without
> requirement to return change status, i'd not bother at all
>
> But surprisingly to provide more information out of reset() i faced this
> interesting issue. The drawback is the performance drop on reset() due to
> possible contention, but i expect value to be changed magnitudes more
> frequently than boundary, so performance should not be a problem.
>
> TBH, I can't even imagine the practical case when i'd need reset() at all,
> I am very short on useful and realistic concurrency examples. If anybody has
> a treasure chest of such examples, I'd be infinitely grateful.
>
> But since reset() it's there, I now can't ignore it :)
>
> Oleksiy
>
> 2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>
>> **
>> DCAS is double-compare-and-swap. It allows you to atomically check and
>> update two independent memory locations. No current hardware that I
>> know supports it. It makes some lock-free algorithms trivial to implement in
>> theory.
>>
>> AtomicStampedReference is a special variant of storing two logical values
>> in one variable, but if I recall correctly the second variable here is
>> limited to 1-bit - a mark or stamp bit. This could be implemented by using
>> the unused address bits to hold the stamp/mark while the variable holds the
>> actual data. But in the JDK it is just doned with locking. Some lock free
>> algorthims are based on having this kind of composite variable.
>>
>> But based on your description of the counter and the boundary it isn't
>> clear to me that reset() needs to be atomic, as the boundary or value could
>> change the instant after you set them anyway.
>>
>> Cheers,
>> David
>>
>> -----Original Message-----
>> *From:* Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
>> *Sent:* Tuesday, 6 September 2011 10:07 PM
>> *To:* dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] Composite compare-and-swap based on
>> two values
>>
>> It just happens on occasion :)
>>
>> 2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
>>
>>> Hi David and folks
>>>
>>>  2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>>>
>>>> **
>>>> You can not compose CAS operations to get atomic updates to multiple
>>>> variables. A DCAS would solve your problem but we don't have one :)
>>>> AtomicStampedReference (as mentioned by Daniel) is a very restricted form of
>>>> DCAS and in fact is implemented by locking in the JDK.
>>>>
>>>>
>>> Can you tell in more detail about DCAS concept? Maybe some relevant link?
>>> Google is not of much help unfortunately. I'll try to figure
>>> AtomicStampedReference in the meantime.
>>>
>>>
>>>
>>>>  You either need a mutual exclusion mechanism that is applied to all
>>>> variables (eg locking), or you need a protocol that allows optimistic
>>>> updates and can account for conflicts/contention. Or you encode both
>>>> variables into a single atomic variable.
>>>>
>>> I thought about encoding the state in a single variable as well, but I
>>> was also looking for some general approach to such case. Single-state
>>> variable is not very scalable.
>>>
>>>>
>>>> I must admit though that I don't really understand the semantics of your
>>>> reset() operation, and I'm unclear why the value and the boundary can be
>>>> modified independently.
>>>>
>>>>
>>> The cyclic counter is supposed to incrementally decrease its value from
>>> some boundary till zero and set it value again to boundary, in my
>>> implementation, the boundary is supposed to be adjustable, so you can
>>> increase or decrease counter value space in thread-safe manner. the reset()
>>> is supposed to reset the counter value to it's boundary.
>>>
>>> I plan to reuse this interface further to implement work schedulers and
>>> few similar things on top of it in my further journey through
>>> java.util.concurrent.*
>>>
>>> I've attached the interface so you have an idea about it.
>>>
>>> @Viktor: no, am looking into it, transactional memory is somewhere deep
>>> inside my learning backlog :o)
>>>
>>> Thanks for all your answers
>>> Oleksiy
>>>
>>>
>>>>
>>>  David Holmes
>>>>
>>>>
>>>> -----Original Message-----
>>>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>>>> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Oleksiy
>>>> Khilkevich
>>>> *Sent:* Tuesday, 6 September 2011 8:14 PM
>>>> *To:* Concurrency-interest at cs.oswego.edu
>>>> *Subject:* [concurrency-interest] Composite compare-and-swap based on
>>>> twovalues
>>>>
>>>> Hi Concurrency Champs
>>>>
>>>> I'm implementing non-blocking cyclic counter mostly for learning
>>>> purposes, and faced the following problem, which i'm not sure how to solve.
>>>>
>>>> The method in question implements the following
>>>>
>>>>     /**
>>>>      * Sets counter value to initial (boundary) value
>>>>      * @return true if counter value was changed
>>>>      */
>>>>     boolean reset();
>>>>
>>>> The implementation I'm not sure about
>>>>
>>>>     @Override
>>>>     public boolean reset() {
>>>>         for (;;) {
>>>>             int curValue = value.get();
>>>>             int curBoundary = boundary.get();
>>>>             if (curValue == curBoundary) return false;
>>>>
>>>>             // TODO: if boundary and value were not changed, set the
>>>> value to boundary
>>>>
>>>>             return true;
>>>>         }
>>>>     }
>>>>
>>>> Here I have two values which are both AtomicIntegers and which may
>>>> change - value can be incremented or decremented by another thread, and
>>>> boundary can be changed too.
>>>>
>>>> I'm not quite sure how to do this without introducing critical sections.
>>>> In general the question refers to any shared state change based on values of
>>>> several other shared states.
>>>>
>>>> What is the correct way to implement such operation atomically without
>>>> critical sections? IS it possible to build composite CAS operations based on
>>>> AtomicInteger#compareAndSet ?
>>>>
>>>> Thank you and kindly waiting for your ideas
>>>> Oleksiy
>>>>
>>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110908/343670f9/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: CyclicCounter.java
Type: application/octet-stream
Size: 609 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110908/343670f9/attachment-0002.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: AtomicCyclicCounter2.java
Type: application/octet-stream
Size: 5310 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110908/343670f9/attachment-0003.obj>

From nathan.reynolds at oracle.com  Thu Sep  8 17:02:35 2011
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Thu, 08 Sep 2011 14:02:35 -0700
Subject: [concurrency-interest] Composite compare-and-swap based on two
 values
In-Reply-To: <CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>
	<CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
Message-ID: <4E692D6B.5060600@oracle.com>

The correct way is to copy the volatile state into a local variable, as 
you have done.  Then test the conditions on the local variable.

Are CounterState.value and CounterState.boundary final?

Nathan Reynolds 
<http://psr.us.oracle.com/wiki/index.php/User:Nathan_Reynolds> | 
Consulting Member of Technical Staff | 602.333.9091
Oracle PSR Engineering <http://psr.us.oracle.com/> | Server Technology

On 9/8/2011 9:50 AM, Oleksiy Khilkevich wrote:
> Hi All
>
> Getting back to this I'd like to present what I've came up with. I 
> need a volunteer for code review.
>
> I'm going to give a tech talk about java.util.concurrent soon, so The 
> Right Way(tm) and bug-free code is critical
>
> Here is a piece of cyclic counter responsible for reset
>
>     // CounterState is private nested class to hold value and 
> boundary, see attached source
>     @Override
>     public boolean reset() {
>         for (;;) {
>             int[] stampHolder = new int[1];
>             CounterState current = stateRef.get(stampHolder); // 1
>             int currentStamp = stampHolder[0];
>
>             if (current.value == current.boundary) return false;
>
>             CounterState next = new CounterState(current.boundary, 
> current.boundary);
>             if (stateRef.compareAndSet(current, next, currentStamp, 
> currentStamp + 1)) {
>                 return true;
>             }
>         }
>     }
>
> If I am not mistaken, at (!) i can't just access 
> stateRef.getReference().value and stateRef.getReference.boundary, as 
> stamp can change in between of that reads, so i need to get
>
> Also in general, the more complex is shared state, the more 
> performance degradation would be on state writes, as there is more 
> contention over the shared state.
>
> I've attached the source in case you may wanna look
>
> Thanks and waiting for the feedback
> Oleksiy
>
> 2011/9/7 David Holmes <davidcholmes at aapt.net.au 
> <mailto:davidcholmes at aapt.net.au>>
>
>     But I should add that this form of DCAS is no different to
>     choosing to encode your two values into one variable.
>     David
>
>         -----Original Message-----
>         *From:* David Holmes [mailto:davidcholmes at aapt.net.au
>         <mailto:davidcholmes at aapt.net.au>]
>         *Sent:* Wednesday, 7 September 2011 7:48 AM
>         *To:* Oleksiy Khilkevich
>         *Cc:* Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         *Subject:* RE: [concurrency-interest] Composite
>         compare-and-swap based on two values
>
>         Sorry - yes I was mixing AtomicMarkableReference and
>         AtomicStampedreference. AtomicStampedReference does present
>         itself in a form similar to DCAS.
>         Good luck.
>         David
>
>             -----Original Message-----
>             *From:* Oleksiy Khilkevich
>             [mailto:oleksiy.khilkevich at gmail.com
>             <mailto:oleksiy.khilkevich at gmail.com>]
>             *Sent:* Tuesday, 6 September 2011 10:46 PM
>             *To:* dholmes at ieee.org <mailto:dholmes at ieee.org>
>             *Cc:* Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             *Subject:* Re: [concurrency-interest] Composite
>             compare-and-swap based on two values
>
>             I guess you mean AtomicMarkableReference. stamped one
>             indeed provides the versioning that can help - it stores
>             the int as a stamp. I think it's quite possible to emulate
>             DCAS with help of these classes.
>
>             Regarding the reset() i'm just trying to stick to the
>             contract i've imposed on it (so it return true if the
>             counter value was really reset). Without requirement to
>             return change status, i'd not bother at all
>
>             But surprisingly to provide more information out of
>             reset() i faced this interesting issue. The drawback is
>             the performance drop on reset() due to possible
>             contention, but i expect value to be changed magnitudes
>             more frequently than boundary, so performance should not
>             be a problem.
>
>             TBH, I can't even imagine the practical case when i'd need
>             reset() at all, I am very short on useful and realistic
>             concurrency examples. If anybody has a treasure chest of
>             such examples, I'd be infinitely grateful.
>
>             But since reset() it's there, I now can't ignore it :)
>
>             Oleksiy
>
>             2011/9/6 David Holmes <davidcholmes at aapt.net.au
>             <mailto:davidcholmes at aapt.net.au>>
>
>                 DCAS is double-compare-and-swap. It allows you to
>                 atomically check and update two independent memory
>                 locations. No current hardware that I
>                 know supports it. It makes some lock-free algorithms
>                 trivial to implement in theory.
>                 AtomicStampedReference is a special variant of storing
>                 two logical values in one variable, but if I recall
>                 correctly the second variable here is limited to 1-bit
>                 - a mark or stamp bit. This could be implemented by
>                 using the unused address bits to hold the stamp/mark
>                 while the variable holds the actual data. But in the
>                 JDK it is just doned with locking. Some lock free
>                 algorthims are based on having this kind of composite
>                 variable.
>                 But based on your description of the counter and the
>                 boundary it isn't clear to me that reset() needs to be
>                 atomic, as the boundary or value could change the
>                 instant after you set them anyway.
>                 Cheers,
>                 David
>
>                     -----Original Message-----
>                     *From:* Oleksiy Khilkevich
>                     [mailto:oleksiy.khilkevich at gmail.com
>                     <mailto:oleksiy.khilkevich at gmail.com>]
>                     *Sent:* Tuesday, 6 September 2011 10:07 PM
>                     *To:* dholmes at ieee.org <mailto:dholmes at ieee.org>;
>                     Concurrency-interest at cs.oswego.edu
>                     <mailto:Concurrency-interest at cs.oswego.edu>
>                     *Subject:* Re: [concurrency-interest] Composite
>                     compare-and-swap based on two values
>
>                     It just happens on occasion :)
>
>                     2011/9/6 Oleksiy Khilkevich
>                     <oleksiy.khilkevich at gmail.com
>                     <mailto:oleksiy.khilkevich at gmail.com>>
>
>                         Hi David and folks
>
>                         2011/9/6 David Holmes
>                         <davidcholmes at aapt.net.au
>                         <mailto:davidcholmes at aapt.net.au>>
>
>                             You can not compose CAS operations to get
>                             atomic updates to multiple variables. A
>                             DCAS would solve your problem but we don't
>                             have one :) AtomicStampedReference (as
>                             mentioned by Daniel) is a very restricted
>                             form of DCAS and in fact is implemented by
>                             locking in the JDK.
>
>                         Can you tell in more detail about DCAS
>                         concept? Maybe some relevant link? Google is
>                         not of much help unfortunately. I'll try to
>                         figure AtomicStampedReference in the meantime.
>
>                             You either need a mutual exclusion
>                             mechanism that is applied to all variables
>                             (eg locking), or you need a protocol that
>                             allows optimistic updates and can account
>                             for conflicts/contention. Or you encode
>                             both variables into a single atomic variable.
>
>                         I thought about encoding the state in a single
>                         variable as well, but I was also looking for
>                         some general approach to such case.
>                         Single-state variable is not very scalable.
>
>                             I must admit though that I don't really
>                             understand the semantics of your reset()
>                             operation, and I'm unclear why the value
>                             and the boundary can be modified
>                             independently.
>
>                         The cyclic counter is supposed to
>                         incrementally decrease its value from some
>                         boundary till zero and set it value again to
>                         boundary, in my implementation, the boundary
>                         is supposed to be adjustable, so you can
>                         increase or decrease counter value space in
>                         thread-safe manner. the reset() is supposed to
>                         reset the counter value to it's boundary.
>
>                         I plan to reuse this interface further to
>                         implement work schedulers and few similar
>                         things on top of it in my further journey
>                         through java.util.concurrent.*
>
>                         I've attached the interface so you have an
>                         idea about it.
>
>                         @Viktor: no, am looking into it, transactional
>                         memory is somewhere deep inside my learning
>                         backlog :o)
>                         Thanks for all your answers
>                         Oleksiy
>
>                             David Holmes
>
>                                 -----Original Message-----
>                                 *From:*
>                                 concurrency-interest-bounces at cs.oswego.edu
>                                 <mailto:concurrency-interest-bounces at cs.oswego.edu>
>                                 [mailto:concurrency-interest-bounces at cs.oswego.edu
>                                 <mailto:concurrency-interest-bounces at cs.oswego.edu>]*On
>                                 Behalf Of *Oleksiy Khilkevich
>                                 *Sent:* Tuesday, 6 September 2011 8:14 PM
>                                 *To:*
>                                 Concurrency-interest at cs.oswego.edu
>                                 <mailto:Concurrency-interest at cs.oswego.edu>
>                                 *Subject:* [concurrency-interest]
>                                 Composite compare-and-swap based on
>                                 twovalues
>
>                                 Hi Concurrency Champs
>
>                                 I'm implementing non-blocking cyclic
>                                 counter mostly for learning purposes,
>                                 and faced the following problem, which
>                                 i'm not sure how to solve.
>
>                                 The method in question implements the
>                                 following
>
>                                     /**
>                                      * Sets counter value to initial
>                                 (boundary) value
>                                      * @return true if counter value
>                                 was changed
>                                      */
>                                     boolean reset();
>
>                                 The implementation I'm not sure about
>
>                                     @Override
>                                     public boolean reset() {
>                                         for (;;) {
>                                             int curValue = value.get();
>                                             int curBoundary =
>                                 boundary.get();
>                                             if (curValue ==
>                                 curBoundary) return false;
>
>                                             // TODO: if boundary and
>                                 value were not changed, set the value
>                                 to boundary
>
>                                             return true;
>                                         }
>                                     }
>
>                                 Here I have two values which are both
>                                 AtomicIntegers and which may change -
>                                 value can be incremented or
>                                 decremented by another thread, and
>                                 boundary can be changed too.
>
>                                 I'm not quite sure how to do this
>                                 without introducing critical sections.
>                                 In general the question refers to any
>                                 shared state change based on values of
>                                 several other shared states.
>
>                                 What is the correct way to implement
>                                 such operation atomically without
>                                 critical sections? IS it possible to
>                                 build composite CAS operations based
>                                 on AtomicInteger#compareAndSet ?
>
>                                 Thank you and kindly waiting for your
>                                 ideas
>                                 Oleksiy
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110908/a02c31c3/attachment-0001.html>

From davidcholmes at aapt.net.au  Thu Sep  8 18:13:49 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 9 Sep 2011 08:13:49 +1000
Subject: [concurrency-interest] Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMENIIPAA.davidcholmes@aapt.net.au>

Just an observation but you no longer treat the counter value and the boundary as separate variables, but elements of a composite state object - which is often what has to happen to deal with compound atomic operations. But it is no longer the problem you originally formulated.

I'm not seeing why a stamped reference is needed here, but then I still don't fully grok the intended semantics.

David
  -----Original Message-----
  From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
  Sent: Friday, 9 September 2011 2:51 AM
  To: dholmes at ieee.org
  Cc: Concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


  Hi All


  Getting back to this I'd like to present what I've came up with. I need a volunteer for code review.


  I'm going to give a tech talk about java.util.concurrent soon, so The Right Way(tm) and bug-free code is critical  


  Here is a piece of cyclic counter responsible for reset


      // CounterState is private nested class to hold value and boundary, see attached source
      @Override
      public boolean reset() {
          for (;;) {
              int[] stampHolder = new int[1];
              CounterState current = stateRef.get(stampHolder); // 1
              int currentStamp = stampHolder[0];


              if (current.value == current.boundary) return false;


              CounterState next = new CounterState(current.boundary, current.boundary);
              if (stateRef.compareAndSet(current, next, currentStamp, currentStamp + 1)) {
                  return true;
              }
          }
      }


  If I am not mistaken, at (!) i can't just access stateRef.getReference().value and stateRef.getReference.boundary, as stamp can change in between of that reads, so i need to get 


  Also in general, the more complex is shared state, the more performance degradation would be on state writes, as there is more contention over the shared state. 


  I've attached the source in case you may wanna look


  Thanks and waiting for the feedback
  Oleksiy


  2011/9/7 David Holmes <davidcholmes at aapt.net.au>

    But I should add that this form of DCAS is no different to choosing to encode your two values into one variable.

    David
      -----Original Message-----
      From: David Holmes [mailto:davidcholmes at aapt.net.au]
      Sent: Wednesday, 7 September 2011 7:48 AM
      To: Oleksiy Khilkevich
      Cc: Concurrency-interest at cs.oswego.edu

      Subject: RE: [concurrency-interest] Composite compare-and-swap based on two values


      Sorry - yes I was mixing AtomicMarkableReference and AtomicStampedreference. AtomicStampedReference does present itself in a form similar to DCAS.

      Good luck.

      David
        -----Original Message-----
        From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
        Sent: Tuesday, 6 September 2011 10:46 PM
        To: dholmes at ieee.org
        Cc: Concurrency-interest at cs.oswego.edu
        Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


        I guess you mean AtomicMarkableReference. stamped one indeed provides the versioning that can help - it stores the int as a stamp. I think it's quite possible to emulate DCAS with help of these classes. 


        Regarding the reset() i'm just trying to stick to the contract i've imposed on it (so it return true if the counter value was really reset). Without requirement to return change status, i'd not bother at all 


        But surprisingly to provide more information out of reset() i faced this interesting issue. The drawback is the performance drop on reset() due to possible contention, but i expect value to be changed magnitudes more frequently than boundary, so performance should not be a problem.


        TBH, I can't even imagine the practical case when i'd need reset() at all, I am very short on useful and realistic concurrency examples. If anybody has a treasure chest of such examples, I'd be infinitely grateful.


        But since reset() it's there, I now can't ignore it :)


        Oleksiy


        2011/9/6 David Holmes <davidcholmes at aapt.net.au>

          DCAS is double-compare-and-swap. It allows you to atomically check and update two independent memory locations. No current hardware that I know supports it. It makes some lock-free algorithms trivial to implement in theory.

          AtomicStampedReference is a special variant of storing two logical values in one variable, but if I recall correctly the second variable here is limited to 1-bit - a mark or stamp bit. This could be implemented by using the unused address bits to hold the stamp/mark while the variable holds the actual data. But in the JDK it is just doned with locking. Some lock free algorthims are based on having this kind of composite variable.

          But based on your description of the counter and the boundary it isn't clear to me that reset() needs to be atomic, as the boundary or value could change the instant after you set them anyway.

          Cheers,
          David
            -----Original Message-----
            From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
            Sent: Tuesday, 6 September 2011 10:07 PM
            To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
            Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


            It just happens on occasion :)


            2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

              Hi David and folks


              2011/9/6 David Holmes <davidcholmes at aapt.net.au>

                You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

              Can you tell in more detail about DCAS concept? Maybe some relevant link? Google is not of much help unfortunately. I'll try to figure AtomicStampedReference in the meantime.

               
                You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.
              I thought about encoding the state in a single variable as well, but I was also looking for some general approach to such case. Single-state variable is not very scalable.  

                I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

              The cyclic counter is supposed to incrementally decrease its value from some boundary till zero and set it value again to boundary, in my implementation, the boundary is supposed to be adjustable, so you can increase or decrease counter value space in thread-safe manner. the reset() is supposed to reset the counter value to it's boundary.


              I plan to reuse this interface further to implement work schedulers and few similar things on top of it in my further journey through java.util.concurrent.*


              I've attached the interface so you have an idea about it.


              @Viktor: no, am looking into it, transactional memory is somewhere deep inside my learning backlog :o)

              Thanks for all your answers
              Oleksiy



                David Holmes

                  -----Original Message-----
                  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
                  Sent: Tuesday, 6 September 2011 8:14 PM
                  To: Concurrency-interest at cs.oswego.edu
                  Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


                  Hi Concurrency Champs 


                  I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


                  The method in question implements the following 


                      /**
                       * Sets counter value to initial (boundary) value
                       * @return true if counter value was changed
                       */
                      boolean reset();


                  The implementation I'm not sure about


                      @Override
                      public boolean reset() {
                          for (;;) {
                              int curValue = value.get();
                              int curBoundary = boundary.get();
                              if (curValue == curBoundary) return false;


                              // TODO: if boundary and value were not changed, set the value to boundary


                              return true;
                          }
                      }


                  Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


                  I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


                  What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


                  Thank you and kindly waiting for your ideas
                  Oleksiy









-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110909/a16c3f55/attachment-0001.html>

From dhanji at gmail.com  Thu Sep  8 18:16:41 2011
From: dhanji at gmail.com (dhanji at gmail.com)
Date: Thu, 08 Sep 2011 15:16:41 -0700 (PDT)
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <4E5A95E0.1080309@cs.oswego.edu>
References: <4E5A95E0.1080309@cs.oswego.edu>
Message-ID: <710322218.48.1315520201808.JavaMail.mailsy@ip-10-168-186-51>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110908/767d623c/attachment.html>

From jeffhain at rocketmail.com  Thu Sep  8 19:14:03 2011
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Fri, 9 Sep 2011 00:14:03 +0100 (BST)
Subject: [concurrency-interest] Re : Composite compare-and-swap based on two
	values
In-Reply-To: <CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>
	<CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
Message-ID: <1315523643.57611.YahooMailNeo@web29208.mail.ird.yahoo.com>

It would be more efficient to put bothstates(value and boundary) in a single atomic long
(I don't see the need for stamp either).


inc()/dec():

Why just "inc" and "dec", and not "increment" and "decrement" for homogeneity with other methods, and clarity?
The doc says it returns true "if counter was not reset", which could be interpreted either as "if counter's value previously was not boundary (value after reset)" or as "if counter's value did not get set to boundary".
Though, your implementation aims at something different, which is returning true if counter's value did "jump" to zero (inc) or boundary (dec).
Also, if boundaryCrossed is set to true and CAS fails, it will remain true whatever happens next.

setBoundary(int):
Should use newBoundary when creating "next".
Is it intentional not to bring back value in [0,boundary] range,
or throw an exception, if new boundary is < to value?

stampHolder could be created once and for all outside the loops.
I ~think~ that also applies to "next" (fields not final but CAS done beforeother threads can see it).

-Jeff


________________________________
De?: Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
??: dholmes at ieee.org
Cc?: Concurrency-interest at cs.oswego.edu
Envoy? le : Jeudi 8 Septembre 2011 18h50
Objet?: Re: [concurrency-interest] Composite compare-and-swap based on two values


Hi All

Getting back to this I'd like to present what I've came up with. I need a volunteer for code review.

I'm going to give a tech talk about java.util.concurrent soon, so The Right Way(tm) and bug-free code is critical ?

Here is a piece of cyclic counter responsible for reset

? ? // CounterState is private nested class to hold value and boundary, see attached source
? ? @Override
? ? public boolean reset() {
? ? ? ? for (;;) {
? ? ? ? ? ? int[] stampHolder = new int[1];
? ? ? ? ? ? CounterState current = stateRef.get(stampHolder); // 1
? ? ? ? ? ? int currentStamp = stampHolder[0];

? ? ? ? ? ? if (current.value == current.boundary) return false;

? ? ? ? ? ? CounterState next = new CounterState(current.boundary, current.boundary);
? ? ? ? ? ? if (stateRef.compareAndSet(current, next, currentStamp, currentStamp + 1)) {
? ? ? ? ? ? ? ? return true;
? ? ? ? ? ? }
? ? ? ? }
? ? }

If I am not mistaken, at (!) i can't just access stateRef.getReference().value and stateRef.getReference.boundary, as stamp can change in between of that reads, so i need to get?

Also in general, the more complex is shared state, the more performance degradation would be on state writes, as there is more contention over the shared state.?

I've attached the source in case you may wanna look

Thanks and waiting for the feedback
Oleksiy

2011/9/7 David Holmes <davidcholmes at aapt.net.au>

 
>But I 
should add that this form of DCAS is no different to choosing to encode your two 
values into one variable.
>?David
>-----Original Message-----
>>From: David Holmes  [mailto:davidcholmes at aapt.net.au]
>>Sent: Wednesday, 7 September 2011  7:48 AM
>>To: Oleksiy Khilkevich
>>Cc: Concurrency-interest at cs.oswego.edu
>>
>>Subject: RE:  [concurrency-interest] Composite compare-and-swap based on two  values
>>
>>
>>Sorry - yes I was mixing AtomicMarkableReference and  AtomicStampedreference. AtomicStampedReference does present itself in a form  similar to DCAS.
>>?
>>Good  luck.
>>?
>>David
>>-----Original Message-----
>>>From: Oleksiy Khilkevich  [mailto:oleksiy.khilkevich at gmail.com]
>>>Sent: Tuesday, 6 September  2011 10:46 PM
>>>To: dholmes at ieee.org
>>>Cc: Concurrency-interest at cs.oswego.edu
>>>Subject: Re:  [concurrency-interest] Composite compare-and-swap based on two  values
>>>
>>>I guess you mean AtomicMarkableReference. stamped  one indeed provides the versioning that can help - it stores the int as a  stamp. I think it's quite possible to emulate DCAS with help of these  classes. 
>>>
>>>
>>>Regarding the reset() i'm just trying to stick to the contract i've  imposed on it (so it return true if the counter value was really reset).  Without requirement to return change status, i'd not bother at  all?
>>>
>>>
>>>But surprisingly to provide more information out of reset() i faced  this interesting issue. The drawback is the performance drop on reset() due  to possible contention, but i expect value to be changed magnitudes more  frequently than boundary, so performance should not be a problem.
>>>
>>>
>>>TBH, I can't even imagine the practical case when i'd need reset() at  all, I am very short on useful and realistic concurrency examples. If  anybody has a treasure chest of such examples, I'd be infinitely  grateful.
>>>
>>>
>>>But since reset() it's there, I now can't ignore it :)
>>>
>>>
>>>Oleksiy
>>>
>>>
>>>2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>>>
>>> 
>>>>DCAS is  double-compare-and-swap. It allows you to atomically check and update two  independent memory locations. No current hardware that I  know?supports?it. It makes some lock-free algorithms trivial to  implement in theory.
>>>>?
>>>>AtomicStampedReference is  a special variant of storing two logical values in one variable, but if I  recall correctly the second variable here is limited to 1-bit - a mark or  stamp bit. This could be implemented by using the unused address bits to  hold the stamp/mark while the variable holds the actual data. But in the  JDK it is just doned with locking. Some lock free algorthims are based on  having this kind of composite variable.
>>>>?
>>>>But based on your  description of the counter and the boundary it isn't clear to me that  reset() needs to be atomic, as the boundary or value could change the  instant after you set them anyway.
>>>>?
>>>>Cheers,
>>>>David
>>>>-----Original  Message-----
>>>>>From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
>>>>>Sent: Tuesday,  6 September 2011 10:07 PM
>>>>>To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
>>>>>Subject: Re: [concurrency-interest] Composite compare-and-swap based on two  values
>>>>>
>>>>>It just happens on occasion :)
>>>>>
>>>>>
>>>>>2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
>>>>>
>>>>>Hi David and folks
>>>>>>
>>>>>>
>>>>>>2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>>>>>>
>>>>>> 
>>>>>>>You can not compose  CAS operations to get atomic updates to multiple variables. A DCAS  would solve your problem but we don't have one :)  AtomicStampedReference (as mentioned by Daniel) is a very restricted  form of DCAS and in fact is implemented by locking in the  JDK.
>>>>>>>?
>>>>>>Can you tell in more detail about DCAS concept? Maybe some  relevant link? Google is not of much help unfortunately. I'll try to  figure AtomicStampedReference in the meantime.
>>>>>>
>>>>>>?
>>>>>>You either need a  mutual exclusion mechanism that is applied to all variables (eg  locking), or you need a protocol that allows optimistic updates and  can account for conflicts/contention. Or you encode both variables  into a single atomic variable.
>>>>>>I thought about encoding the state in a single variable as well,  but I was also looking for some general approach to such case.  Single-state variable is not very scalable. ?
>>>>>>?
>>>>>>>I must admit though  that I don't really understand the semantics of your reset()  operation, and I'm unclear why the value and the boundary can be  modified independently.
>>>>>>>?
>>>>>>The cyclic counter is supposed to incrementally decrease its  value from some boundary till zero and set it value again to boundary,  in my implementation, the boundary is supposed to be adjustable, so  you can increase or decrease counter value space in thread-safe  manner. the reset() is supposed to reset the counter value to it's  boundary.
>>>>>>
>>>>>>
>>>>>>I plan to reuse this interface further to implement work  schedulers and few similar things on top of it in my further journey  through java.util.concurrent.*
>>>>>>
>>>>>>
>>>>>>I've attached the interface so you have an idea about it.
>>>>>>
>>>>>>
>>>>>>@Viktor: no, am looking into it, transactional memory is  somewhere deep inside my learning backlog :o)
>>>>>>?
>>>>>>Thanks for all your answers
>>>>>>Oleksiy
>>>>>>
>>>>>>
>>>>>>?
>>>>>>David  Holmes 
>>>>>>>?
>>>>>>>-----Original  Message-----
>>>>>>>>From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On  Behalf Of Oleksiy Khilkevich
>>>>>>>>Sent: Tuesday, 6  September 2011 8:14 PM
>>>>>>>>To: Concurrency-interest at cs.oswego.edu
>>>>>>>>Subject: [concurrency-interest] Composite compare-and-swap based on  twovalues
>>>>>>>>
>>>>>>>>Hi Concurrency Champs 
>>>>>>>>
>>>>>>>>
>>>>>>>>I'm implementing non-blocking cyclic counter mostly for  learning purposes, and faced the following problem, which i'm not  sure how to solve.
>>>>>>>>
>>>>>>>>
>>>>>>>>The method in question implements the following?
>>>>>>>>
>>>>>>>>
>>>>>>>>? ? /**
>>>>>>>>? ? ?* Sets counter value to initial  (boundary) value
>>>>>>>>? ? ?* @return true if counter value was  changed
>>>>>>>>? ? ?*/
>>>>>>>>? ? boolean reset();
>>>>>>>>
>>>>>>>>
>>>>>>>>The implementation I'm not sure about
>>>>>>>>
>>>>>>>>
>>>>>>>>? ? @Override
>>>>>>>>? ? public boolean reset() {
>>>>>>>>? ? ? ? for (;;) {
>>>>>>>>? ? ? ? ? ? int curValue =  value.get();
>>>>>>>>? ? ? ? ? ? int curBoundary =  boundary.get();
>>>>>>>>? ? ? ? ? ? if (curValue ==  curBoundary) return false;
>>>>>>>>
>>>>>>>>
>>>>>>>>? ? ? ? ? ? // TODO: if  boundary and value were not changed, set the value to  boundary
>>>>>>>>
>>>>>>>>
>>>>>>>>? ? ? ? ? ? return true;
>>>>>>>>? ? ? ? }
>>>>>>>>? ? }
>>>>>>>>
>>>>>>>>
>>>>>>>>Here I have two values which are both AtomicIntegers and  which may change - value can be incremented or decremented by  another thread, and boundary can be changed too. 
>>>>>>>>
>>>>>>>>
>>>>>>>>I'm not quite sure how to do this without introducing  critical sections. In general the question refers to any shared  state change based on values of several other shared states.
>>>>>>>>
>>>>>>>>
>>>>>>>>What is the correct way to implement such operation  atomically without critical sections? IS it possible to build  composite CAS operations based on AtomicInteger#compareAndSet  ?
>>>>>>>>
>>>>>>>>
>>>>>>>>Thank you and kindly waiting for your ideas
>>>>>>>>Oleksiy
>>>>>>>>
>>>>>>>>
>>>>>>
>>>>>
>>>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110909/6f3ea871/attachment-0001.html>

From oleksiy.khilkevich at gmail.com  Fri Sep  9 06:45:34 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Fri, 9 Sep 2011 13:45:34 +0300
Subject: [concurrency-interest] Re : Composite compare-and-swap based on
 two values
In-Reply-To: <1315523643.57611.YahooMailNeo@web29208.mail.ird.yahoo.com>
References: <NFBBKALFDCPFIDBNKAPCGEMDIPAA.davidcholmes@aapt.net.au>
	<NFBBKALFDCPFIDBNKAPCOEMDIPAA.davidcholmes@aapt.net.au>
	<CANUh1Yx5-4BDY4YS6-i5J_TkNJ-MByMAaf2rga9Ev9sJmYKk_g@mail.gmail.com>
	<1315523643.57611.YahooMailNeo@web29208.mail.ird.yahoo.com>
Message-ID: <CANUh1YyB77PsuVAgj1H56hbve7LiPkf6rnHf3yHFQOP-nA8Y0g@mail.gmail.com>

Huge thanks for the feedback.

Agree on all except "next" being created outside the loop. I've made it
immutable to simplify reasoning on the flow as Nathan suggested.

As for use of AtomicLong vs stamped reference, my aim was to illustrate the
general concept of composite shared state. It's possible to pack two
integers into AtomicLong, but this would not work for more complex states.

However now I think it's quite possible to use just plain AtomicReference
here, that's basically how stamped one is implemented :)

Also thinking about AtomicLong, I expect it should be implemented using
mutual exclusion on architectures that doesn't support CAS of two adjacent
locations. So I can't rely it'd be completely non-blocking, or can I?

Oleksiy

2011/9/9 Jeff Hain <jeffhain at rocketmail.com>

> It would be more efficient to put both states (value and boundary) in a
> single atomic long
> (I don't see the need for stamp either).
>
> inc()/dec():
> Why just "inc" and "dec", and not "increment" and "decrement" for
> homogeneity with other methods, and clarity?
> The doc says it returns true "if counter was not reset", which could be
> interpreted either as "if counter's value previously was not boundary (value
> after reset)" or as "if counter's value did not get set to boundary".
> Though, your implementation aims at something different, which is returning
> true if counter's value did "jump" to zero (inc) or boundary (dec).
> Also, if boundaryCrossed is set to true and CAS fails, it will remain true
> whatever happens next.
>
> setBoundary(int):
> Should use newBoundary when creating "next".
> Is it intentional not to bring back value in [0,boundary] range,
> or throw an exception, if new boundary is < to value?
>
> stampHolder could be created once and for all outside the loops.
> I ~think~ that also applies to "next" (fields not final but CAS done beforeother threads can see it).
>
> -Jeff
>
> ------------------------------
> *De :* Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
> *? :* dholmes at ieee.org
>
> *Cc :* Concurrency-interest at cs.oswego.edu
> *Envoy? le :* Jeudi 8 Septembre 2011 18h50
> *Objet :* Re: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> Hi All
>
> Getting back to this I'd like to present what I've came up with. I need a
> volunteer for code review.
>
> I'm going to give a tech talk about java.util.concurrent soon, so The Right
> Way(tm) and bug-free code is critical
>
> Here is a piece of cyclic counter responsible for reset
>
>     // CounterState is private nested class to hold value and boundary, see
> attached source
>     @Override
>     public boolean reset() {
>         for (;;) {
>             int[] stampHolder = new int[1];
>             CounterState current = stateRef.get(stampHolder); // 1
>             int currentStamp = stampHolder[0];
>
>             if (current.value == current.boundary) return false;
>
>             CounterState next = new CounterState(current.boundary,
> current.boundary);
>             if (stateRef.compareAndSet(current, next, currentStamp,
> currentStamp + 1)) {
>                 return true;
>             }
>         }
>     }
>
> If I am not mistaken, at (!) i can't just access
> stateRef.getReference().value and stateRef.getReference.boundary, as stamp
> can change in between of that reads, so i need to get
>
> Also in general, the more complex is shared state, the more performance
> degradation would be on state writes, as there is more contention over the
> shared state.
>
> I've attached the source in case you may wanna look
>
> Thanks and waiting for the feedback
> Oleksiy
>
> 2011/9/7 David Holmes <davidcholmes at aapt.net.au>
>
> **
> But I should add that this form of DCAS is no different to choosing to
> encode your two values into one variable.
>
> David
>
> -----Original Message-----
> *From:* David Holmes [mailto:davidcholmes at aapt.net.au]
> *Sent:* Wednesday, 7 September 2011 7:48 AM
> *To:* Oleksiy Khilkevich
> *Cc:* Concurrency-interest at cs.oswego.edu
> *Subject:* RE: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> Sorry - yes I was mixing AtomicMarkableReference and
> AtomicStampedreference. AtomicStampedReference does present itself in a form
> similar to DCAS.
>
> Good luck.
>
> David
>
> -----Original Message-----
> *From:* Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
> *Sent:* Tuesday, 6 September 2011 10:46 PM
> *To:* dholmes at ieee.org
> *Cc:* Concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> I guess you mean AtomicMarkableReference. stamped one indeed provides the
> versioning that can help - it stores the int as a stamp. I think it's quite
> possible to emulate DCAS with help of these classes.
>
> Regarding the reset() i'm just trying to stick to the contract i've imposed
> on it (so it return true if the counter value was really reset). Without
> requirement to return change status, i'd not bother at all
>
> But surprisingly to provide more information out of reset() i faced this
> interesting issue. The drawback is the performance drop on reset() due to
> possible contention, but i expect value to be changed magnitudes more
> frequently than boundary, so performance should not be a problem.
>
> TBH, I can't even imagine the practical case when i'd need reset() at all,
> I am very short on useful and realistic concurrency examples. If anybody has
> a treasure chest of such examples, I'd be infinitely grateful.
>
> But since reset() it's there, I now can't ignore it :)
>
> Oleksiy
>
> 2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>
> **
> DCAS is double-compare-and-swap. It allows you to atomically check and
> update two independent memory locations. No current hardware that I
> know supports it. It makes some lock-free algorithms trivial to implement in
> theory.
>
> AtomicStampedReference is a special variant of storing two logical values
> in one variable, but if I recall correctly the second variable here is
> limited to 1-bit - a mark or stamp bit. This could be implemented by using
> the unused address bits to hold the stamp/mark while the variable holds the
> actual data. But in the JDK it is just doned with locking. Some lock free
> algorthims are based on having this kind of composite variable.
>
> But based on your description of the counter and the boundary it isn't
> clear to me that reset() needs to be atomic, as the boundary or value could
> change the instant after you set them anyway.
>
> Cheers,
> David
>
> -----Original Message-----
> *From:* Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
> *Sent:* Tuesday, 6 September 2011 10:07 PM
> *To:* dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Composite compare-and-swap based on
> two values
>
> It just happens on occasion :)
>
> 2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
>
> Hi David and folks
>
>  2011/9/6 David Holmes <davidcholmes at aapt.net.au>
>
> **
> You can not compose CAS operations to get atomic updates to multiple
> variables. A DCAS would solve your problem but we don't have one :)
> AtomicStampedReference (as mentioned by Daniel) is a very restricted form of
> DCAS and in fact is implemented by locking in the JDK.
>
>
> Can you tell in more detail about DCAS concept? Maybe some relevant link?
> Google is not of much help unfortunately. I'll try to figure
> AtomicStampedReference in the meantime.
>
>
>
>  You either need a mutual exclusion mechanism that is applied to all
> variables (eg locking), or you need a protocol that allows optimistic
> updates and can account for conflicts/contention. Or you encode both
> variables into a single atomic variable.
>
> I thought about encoding the state in a single variable as well, but I was
> also looking for some general approach to such case. Single-state variable
> is not very scalable.
>
>
> I must admit though that I don't really understand the semantics of your
> reset() operation, and I'm unclear why the value and the boundary can be
> modified independently.
>
>
> The cyclic counter is supposed to incrementally decrease its value from
> some boundary till zero and set it value again to boundary, in my
> implementation, the boundary is supposed to be adjustable, so you can
> increase or decrease counter value space in thread-safe manner. the reset()
> is supposed to reset the counter value to it's boundary.
>
> I plan to reuse this interface further to implement work schedulers and few
> similar things on top of it in my further journey through
> java.util.concurrent.*
>
> I've attached the interface so you have an idea about it.
>
> @Viktor: no, am looking into it, transactional memory is somewhere deep
> inside my learning backlog :o)
>
> Thanks for all your answers
> Oleksiy
>
>
>
>  David Holmes
>
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Oleksiy
> Khilkevich
> *Sent:* Tuesday, 6 September 2011 8:14 PM
> *To:* Concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Composite compare-and-swap based on
> twovalues
>
> Hi Concurrency Champs
>
> I'm implementing non-blocking cyclic counter mostly for learning purposes,
> and faced the following problem, which i'm not sure how to solve.
>
> The method in question implements the following
>
>     /**
>      * Sets counter value to initial (boundary) value
>      * @return true if counter value was changed
>      */
>     boolean reset();
>
> The implementation I'm not sure about
>
>     @Override
>     public boolean reset() {
>         for (;;) {
>             int curValue = value.get();
>             int curBoundary = boundary.get();
>             if (curValue == curBoundary) return false;
>
>             // TODO: if boundary and value were not changed, set the value
> to boundary
>
>             return true;
>         }
>     }
>
> Here I have two values which are both AtomicIntegers and which may change -
> value can be incremented or decremented by another thread, and boundary can
> be changed too.
>
> I'm not quite sure how to do this without introducing critical sections. In
> general the question refers to any shared state change based on values of
> several other shared states.
>
> What is the correct way to implement such operation atomically without
> critical sections? IS it possible to build composite CAS operations based on
> AtomicInteger#compareAndSet ?
>
> Thank you and kindly waiting for your ideas
> Oleksiy
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110909/7f56a8d0/attachment-0001.html>

From dl at cs.oswego.edu  Fri Sep  9 09:06:24 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 09 Sep 2011 09:06:24 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <CAOdgdgz5s0PGibsp9CtoHs4=-qcE++G_EFYeu-jvCOWCDKpFfQ@mail.gmail.com>
References: <CAOdgdgz5s0PGibsp9CtoHs4=-qcE++G_EFYeu-jvCOWCDKpFfQ@mail.gmail.com>
Message-ID: <4E6A0F50.8090007@cs.oswego.edu>

Thanks as always for the on- and off-list feedback.
It seems worthwhile to simplify use and documentation of
load factors, so the current update does so.


On 09/08/11 12:10, Alex Miller wrote:
> I think the only time I have ever seen someone use an alternate load
> factor is in the case where they are creating a Map that has a known
> maximum fixed size and they want to ensure that the map will never
> need to rehash.  It might be helpful to specify in Javadoc how to
> achieve that goal.
>

Yes, thanks. The answer should be utterly obvious:
Use the constructor with this fixed size as the initialCapacity.

Unfortunately, the existing j.u.c specs and javadocs made this
confusing; and worse, not absolutely guaranteed to be true.
Some of the confusion was due to the unintended
implication that the default constructor is sized to hold 16
elements, when instead it is just 16 period.
In practice, most of the slop doesn't matter at all.
With power of two tables, there are only 30 possible
table sizes, so calculations based on misunderstandings
about the meaning of constructor parameters usually end up
to be what people expect anyway. But still it should be,
and now is, straightened out.

> On 09/08/11 18:16, dhanji at gmail.com wrote:
>> I think this is a reasonable position for loadFactors > default. But perhaps not
>> lower.
>>

The adjustment works both ways, but only for initial
sizing, which is the only aspect that is fully controllable
in a concurrent table. So if you'd like an extremely sparsely
populated table for say 1000 elements, you can use
   new ConcurrentHashMap(1000, 0.25f);
The only difference from existing j.u.c version is that if you
don't have a good size estimate, and want it sparsely
populated anyway, we can't help you. But we could never exactly
promise this anyway; among other reasons because sizes may fluctuate
while resizing is in progress.

So little actual control is lost, and we gain a more understandable
characterization in the revised constructor and class-level javadocs.
The class-level now includes just barely enough background on
hashing to clearly explain what's up without making people plod through
Too Much Information. I hope. See:
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/ConcurrentHashMapV8.html

-Doug







From kumpera at gmail.com  Fri Sep  9 15:42:20 2011
From: kumpera at gmail.com (Rodrigo Kumpera)
Date: Fri, 9 Sep 2011 16:42:20 -0300
Subject: [concurrency-interest] LongAdder (was: StripedAdder) and
	LongAdderTable
In-Reply-To: <4E356CEF.6050003@cs.oswego.edu>
References: <4E356CEF.6050003@cs.oswego.edu>
Message-ID: <CACmR+BCQQR5LSnCmyV1CQyZL-n2ga2O8r=fJJhsO-hWuNg6+vw@mail.gmail.com>

On Sun, Jul 31, 2011 at 11:55 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> It is much nicer not to have to decide ahead of time that
> a program will have enough threads updating a variable
> to need a class that can adaptively spread out contention.
> So a reworked version of StripedAdder is now known as "LongAdder".
> It is a variant of AtomicLong with a stripped-down API (suitable
> only for adding and counting), that expands to use striping
> when needed while avoiding noticeable overhead when not needed.
>
>
This class doesn't look to be 32bits safe as it does non-atomic load/store
of 64bits types.
It certainly is not a problem on IA32 systems with TSO, but definitely an
issue ppc or arm.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110909/15c0eb8d/attachment.html>

From davidcholmes at aapt.net.au  Fri Sep  9 18:02:34 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 10 Sep 2011 08:02:34 +1000
Subject: [concurrency-interest] Re : Composite compare-and-swap based on
	two values
In-Reply-To: <CANUh1YyB77PsuVAgj1H56hbve7LiPkf6rnHf3yHFQOP-nA8Y0g@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKENOIPAA.davidcholmes@aapt.net.au>

Re AtomicLong - yes if the underlying platform doesn't support a 64-bit CAS (known as either a wide-CAS or CAS2 on 32-bit platforms) then locking is used (at least in the OpenJDK)

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
  Sent: Friday, 9 September 2011 8:46 PM
  To: Jeff Hain
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Re : Composite compare-and-swap based on two values


  Huge thanks for the feedback.


  Agree on all except "next" being created outside the loop. I've made it immutable to simplify reasoning on the flow as Nathan suggested.


  As for use of AtomicLong vs stamped reference, my aim was to illustrate the general concept of composite shared state. It's possible to pack two integers into AtomicLong, but this would not work for more complex states. 


  However now I think it's quite possible to use just plain AtomicReference here, that's basically how stamped one is implemented :)


  Also thinking about AtomicLong, I expect it should be implemented using mutual exclusion on architectures that doesn't support CAS of two adjacent locations. So I can't rely it'd be completely non-blocking, or can I?


  Oleksiy


  2011/9/9 Jeff Hain <jeffhain at rocketmail.com>

    It would be more efficient to put both states (value and boundary) in a single atomic long
    (I don't see the need for stamp either).


    inc()/dec():

    Why just "inc" and "dec", and not "increment" and "decrement" for homogeneity with other methods, and clarity?

    The doc says it returns true "if counter was not reset", which could be interpreted either as "if counter's value previously was not boundary (value after reset)" or as "if counter's value did not get set to boundary".
    Though, your implementation aims at something different, which is returning true if counter's value did "jump" to zero (inc) or boundary (dec).
    Also, if boundaryCrossed is set to true and CAS fails, it will remain true whatever happens next.


    setBoundary(int):
    Should use newBoundary when creating "next".
    Is it intentional not to bring back value in [0,boundary] range,
    or throw an exception, if new boundary is < to value?


    stampHolder could be created once and for all outside the loops.
    I ~think~ that also applies to "next" (fields not final but CAS done before other threads can see it).


    -Jeff



----------------------------------------------------------------------------
    De : Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>
    ? : dholmes at ieee.org

    Cc : Concurrency-interest at cs.oswego.edu

    Envoy? le : Jeudi 8 Septembre 2011 18h50
    Objet : Re: [concurrency-interest] Composite compare-and-swap based on two values



    Hi All


    Getting back to this I'd like to present what I've came up with. I need a volunteer for code review.


    I'm going to give a tech talk about java.util.concurrent soon, so The Right Way(tm) and bug-free code is critical  


    Here is a piece of cyclic counter responsible for reset


        // CounterState is private nested class to hold value and boundary, see attached source
        @Override
        public boolean reset() {
            for (;;) {
                int[] stampHolder = new int[1];
                CounterState current = stateRef.get(stampHolder); // 1
                int currentStamp = stampHolder[0];


                if (current.value == current.boundary) return false;


                CounterState next = new CounterState(current.boundary, current.boundary);
                if (stateRef.compareAndSet(current, next, currentStamp, currentStamp + 1)) {
                    return true;
                }
            }
        }


    If I am not mistaken, at (!) i can't just access stateRef.getReference().value and stateRef.getReference.boundary, as stamp can change in between of that reads, so i need to get 


    Also in general, the more complex is shared state, the more performance degradation would be on state writes, as there is more contention over the shared state. 


    I've attached the source in case you may wanna look


    Thanks and waiting for the feedback
    Oleksiy


    2011/9/7 David Holmes <davidcholmes at aapt.net.au>

      But I should add that this form of DCAS is no different to choosing to encode your two values into one variable.

      David
        -----Original Message-----
        From: David Holmes [mailto:davidcholmes at aapt.net.au]
        Sent: Wednesday, 7 September 2011 7:48 AM
        To: Oleksiy Khilkevich
        Cc: Concurrency-interest at cs.oswego.edu

        Subject: RE: [concurrency-interest] Composite compare-and-swap based on two values


        Sorry - yes I was mixing AtomicMarkableReference and AtomicStampedreference. AtomicStampedReference does present itself in a form similar to DCAS.

        Good luck.

        David
          -----Original Message-----
          From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
          Sent: Tuesday, 6 September 2011 10:46 PM
          To: dholmes at ieee.org
          Cc: Concurrency-interest at cs.oswego.edu
          Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


          I guess you mean AtomicMarkableReference. stamped one indeed provides the versioning that can help - it stores the int as a stamp. I think it's quite possible to emulate DCAS with help of these classes. 


          Regarding the reset() i'm just trying to stick to the contract i've imposed on it (so it return true if the counter value was really reset). Without requirement to return change status, i'd not bother at all 


          But surprisingly to provide more information out of reset() i faced this interesting issue. The drawback is the performance drop on reset() due to possible contention, but i expect value to be changed magnitudes more frequently than boundary, so performance should not be a problem.


          TBH, I can't even imagine the practical case when i'd need reset() at all, I am very short on useful and realistic concurrency examples. If anybody has a treasure chest of such examples, I'd be infinitely grateful.


          But since reset() it's there, I now can't ignore it :)


          Oleksiy


          2011/9/6 David Holmes <davidcholmes at aapt.net.au>

            DCAS is double-compare-and-swap. It allows you to atomically check and update two independent memory locations. No current hardware that I know supports it. It makes some lock-free algorithms trivial to implement in theory.

            AtomicStampedReference is a special variant of storing two logical values in one variable, but if I recall correctly the second variable here is limited to 1-bit - a mark or stamp bit. This could be implemented by using the unused address bits to hold the stamp/mark while the variable holds the actual data. But in the JDK it is just doned with locking. Some lock free algorthims are based on having this kind of composite variable.

            But based on your description of the counter and the boundary it isn't clear to me that reset() needs to be atomic, as the boundary or value could change the instant after you set them anyway.

            Cheers,
            David
              -----Original Message-----
              From: Oleksiy Khilkevich [mailto:oleksiy.khilkevich at gmail.com]
              Sent: Tuesday, 6 September 2011 10:07 PM
              To: dholmes at ieee.org; Concurrency-interest at cs.oswego.edu
              Subject: Re: [concurrency-interest] Composite compare-and-swap based on two values


              It just happens on occasion :)


              2011/9/6 Oleksiy Khilkevich <oleksiy.khilkevich at gmail.com>

                Hi David and folks


                2011/9/6 David Holmes <davidcholmes at aapt.net.au>

                  You can not compose CAS operations to get atomic updates to multiple variables. A DCAS would solve your problem but we don't have one :) AtomicStampedReference (as mentioned by Daniel) is a very restricted form of DCAS and in fact is implemented by locking in the JDK.

                Can you tell in more detail about DCAS concept? Maybe some relevant link? Google is not of much help unfortunately. I'll try to figure AtomicStampedReference in the meantime.

                 
                  You either need a mutual exclusion mechanism that is applied to all variables (eg locking), or you need a protocol that allows optimistic updates and can account for conflicts/contention. Or you encode both variables into a single atomic variable.
                I thought about encoding the state in a single variable as well, but I was also looking for some general approach to such case. Single-state variable is not very scalable.  

                  I must admit though that I don't really understand the semantics of your reset() operation, and I'm unclear why the value and the boundary can be modified independently.

                The cyclic counter is supposed to incrementally decrease its value from some boundary till zero and set it value again to boundary, in my implementation, the boundary is supposed to be adjustable, so you can increase or decrease counter value space in thread-safe manner. the reset() is supposed to reset the counter value to it's boundary.


                I plan to reuse this interface further to implement work schedulers and few similar things on top of it in my further journey through java.util.concurrent.*


                I've attached the interface so you have an idea about it.


                @Viktor: no, am looking into it, transactional memory is somewhere deep inside my learning backlog :o)

                Thanks for all your answers
                Oleksiy



                  David Holmes

                    -----Original Message-----
                    From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Oleksiy Khilkevich
                    Sent: Tuesday, 6 September 2011 8:14 PM
                    To: Concurrency-interest at cs.oswego.edu
                    Subject: [concurrency-interest] Composite compare-and-swap based on twovalues


                    Hi Concurrency Champs 


                    I'm implementing non-blocking cyclic counter mostly for learning purposes, and faced the following problem, which i'm not sure how to solve.


                    The method in question implements the following 


                        /**
                         * Sets counter value to initial (boundary) value
                         * @return true if counter value was changed
                         */
                        boolean reset();


                    The implementation I'm not sure about


                        @Override
                        public boolean reset() {
                            for (;;) {
                                int curValue = value.get();
                                int curBoundary = boundary.get();
                                if (curValue == curBoundary) return false;


                                // TODO: if boundary and value were not changed, set the value to boundary


                                return true;
                            }
                        }


                    Here I have two values which are both AtomicIntegers and which may change - value can be incremented or decremented by another thread, and boundary can be changed too. 


                    I'm not quite sure how to do this without introducing critical sections. In general the question refers to any shared state change based on values of several other shared states.


                    What is the correct way to implement such operation atomically without critical sections? IS it possible to build composite CAS operations based on AtomicInteger#compareAndSet ?


                    Thank you and kindly waiting for your ideas
                    Oleksiy












    _______________________________________________
    Concurrency-interest mailing list

    Concurrency-interest at cs.oswego.edu

    http://cs.oswego.edu/mailman/listinfo/concurrency-interest




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110910/b85a3f26/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Sep  9 18:14:31 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 10 Sep 2011 08:14:31 +1000
Subject: [concurrency-interest] LongAdder (was: StripedAdder)
	andLongAdderTable
In-Reply-To: <CACmR+BCQQR5LSnCmyV1CQyZL-n2ga2O8r=fJJhsO-hWuNg6+vw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGENPIPAA.davidcholmes@aapt.net.au>

If those longs are volatile then they must be atomically read and written as
per the Java language specification. It is up to the VM implementation to
ensure it provides such atomicity, even on ARM and PPC. In the worst-case
locking must be used. If the longs are not volatile then there is no
expectation of atomicity on any platform.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Rodrigo
Kumpera
  Sent: Saturday, 10 September 2011 5:42 AM
  To: Doug Lea
  Cc: Concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] LongAdder (was: StripedAdder)
andLongAdderTable





  On Sun, Jul 31, 2011 at 11:55 AM, Doug Lea <dl at cs.oswego.edu> wrote:

    It is much nicer not to have to decide ahead of time that
    a program will have enough threads updating a variable
    to need a class that can adaptively spread out contention.
    So a reworked version of StripedAdder is now known as "LongAdder".
    It is a variant of AtomicLong with a stripped-down API (suitable
    only for adding and counting), that expands to use striping
    when needed while avoiding noticeable overhead when not needed.




  This class doesn't look to be 32bits safe as it does non-atomic load/store
of 64bits types.
  It certainly is not a problem on IA32 systems with TSO, but definitely an
issue ppc or arm.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110910/86c3ae0b/attachment.html>

From alarmnummer at gmail.com  Mon Sep 12 12:39:02 2011
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 12 Sep 2011 19:39:02 +0300
Subject: [concurrency-interest] tools for parallel performance debugging
In-Reply-To: <65F4195D4E2C6042BA66D4114E5BB9DC1067B8@fssbemail.fss.india>
References: <CADiYQu6jx2j2KTZDwFEGzjw6H51PsKnmmXXKNfm4kB-dHHxAqg@mail.gmail.com>
	<65F4195D4E2C6042BA66D4114E5BB9DC1067B8@fssbemail.fss.india>
Message-ID: <CAGuAWdDi+f9VeZXwdTyNESwKCei1LnmV+zAm00wYqbxkpnANCw@mail.gmail.com>

You might have a look at Intel VTune 9.0. It is able to do performance
analysis on a very low level (based on cpu feedback) on machine
instructions, and it also is able to connect this information back to
bytecode/java-code.

So you can exactly see in your Java application what is happening on a very
low level.

Unfortunately Intel VTune XE doesn't have support anymore for Java.

And interpreting the information is a expertise in itself.

And.. you need an Intel (and not even all cpu's) box for it too work.
Getting it installed also can be very challenging.


On Fri, Sep 2, 2011 at 8:55 AM, Mohan Radhakrishnan <mohanr at fss.co.in>wrote:

> Hi,
>      I found this link http://hpctoolkit.org/ from some older references
> in this forum.
>
>
> Thanks,
> Mohan
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny Dig
> Sent: Tuesday, August 30, 2011 12:28 AM
> To: Concurrency; Nathan Reynolds
> Subject: Re: [concurrency-interest] tools for parallel performance
> debugging
>
> Thanks Nathan. These tools are all good suggestions. I am curious what
> other tools do people on this mailing list use for parallel
> programming in Java.
>
> best,
> Danny
>
>
> On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
> <nathan.reynolds at oracle.com> wrote:
> > For identifying threading correctness issues, I recommend using Java Path
> > Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every
> possible
> > thread scheduling combination.  It does so by trying one thread
> scheduling
> > combination and then back tracking (i.e. revert the state of the program)
> to
> > simulate other combinations.  If there is a data race or deadlock, it
> will
> > find it and report it.  It doesn't just tell you that a data race or
> > deadlock exists but the steps that got to that state.  Because of the
> number
> > of combinations, it is best to run it on a small piece of the overall
> > program.
> >
> > As for synchronization contention, there are several tools available.
> > Looking through a dump of call stacks and seeing where the most threads
> are
> > blocked works for cases where the lock is dropping the throughput by 10%
> or
> > more.  The call stacks are easy to obtain but can be time consuming to
> sift
> > through.  JRockit's Mission Control can tell you exactly which locks are
> > most contended and give you the call stacks of where that lock is used.
>  I
> > am pretty sure most of the profilers can tell you which locks are most
> > contended, but since JRockit's Mission Control is free for me I haven't
> > looked at the profilers for a while.  I thought that JConsole or some
> tool
> > in the JDK could tell you the most contended lock... but I am really not
> > sure of that.
> >
> > As for false sharing, this is something that only the processor can tell
> > you.  For Intel, I *think* VTune can tell you about false sharing.  I
> know
> > that VTune can deal with Java optimized code.
> >
> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering | Server Technology
> > On 8/24/2011 8:07 PM, Danny Dig wrote:
> >
> > This community has been providing some great library features for
> > taming parallelism in Java.
> >
> > When it comes to tools for parallel performance debugging, it looks to
> > me that Java is trailing behind C++/Intel's ParallelStudio, or
> > C#/Microsoft's Visual Studio. When working with Java programs, what
> > are the tools that you recommend for:
> > - identifying threading correctness issues (e.g., data-races, deadlocks),
> > - identifying performance issues (load imbalance, synchronization
> > contention, false sharing)
> >
> > best,
> > Danny
> >
> >
>
>
>
> --
> Danny Dig
> Visiting Research Assistant Professor at UIUC
>
> http://netfiles.uiuc.edu/dig/www
>
> Motto: "Success is not for the chosen few but for the few who choose"
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> DISCLAIMER:
> ==========================================================================================================================================================The
> information contained in this e-mail message may be privileged and/or
> confidential and protected from disclosure under applicable law. It is
> intended only for the individual to whom or entity to which it is addressed
> as shown at the beginning of the message. If the reader of this message is
> not the intended recipient, or if the employee or agent responsible for
> delivering the message is not an employee or agent of the intended
> recipient, you are hereby notified that any review,
> dissemination,distribution, use, or copying of this message is strictly
> prohibited. If you have received this message in error, please notify us
> immediately by return e-mail and permanently delete this message and your
> reply to the extent it includes this message. Any views or opinions
> presented in this message or attachments are those of the aut!
>  hor and do not necessarily represent those of the Company. All e-mails and
> attachments sent and received are subject to monitoring, reading, and
> archival by the
> Company.==========================================================================================================================================================
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110912/f9a9f7cc/attachment.html>

From jallen at chariotsolutions.com  Mon Sep 12 13:27:46 2011
From: jallen at chariotsolutions.com (Jamie Allen)
Date: Mon, 12 Sep 2011 13:27:46 -0400
Subject: [concurrency-interest] tools for parallel performance debugging
In-Reply-To: <CAGuAWdDi+f9VeZXwdTyNESwKCei1LnmV+zAm00wYqbxkpnANCw@mail.gmail.com>
References: <CADiYQu6jx2j2KTZDwFEGzjw6H51PsKnmmXXKNfm4kB-dHHxAqg@mail.gmail.com>
	<65F4195D4E2C6042BA66D4114E5BB9DC1067B8@fssbemail.fss.india>
	<CAGuAWdDi+f9VeZXwdTyNESwKCei1LnmV+zAm00wYqbxkpnANCw@mail.gmail.com>
Message-ID: <3DEC1711-B59B-43E9-AA2D-E8D94EABC7E0@chariotsolutions.com>

Isn't VTune also Windows and Linux only?  No OSX support, IIRC.



On Sep 12, 2011, at 12:39 PM, Peter Veentjer <alarmnummer at gmail.com> wrote:

> You might have a look at Intel VTune 9.0. It is able to do performance analysis on a very low level (based on cpu feedback) on machine instructions, and it also is able to connect this information back to bytecode/java-code.
> 
> So you can exactly see in your Java application what is happening on a very low level.
> 
> Unfortunately Intel VTune XE doesn't have support anymore for Java.
> 
> And interpreting the information is a expertise in itself.
> 
> And.. you need an Intel (and not even all cpu's) box for it too work. Getting it installed also can be very challenging.
> 
> 
> On Fri, Sep 2, 2011 at 8:55 AM, Mohan Radhakrishnan <mohanr at fss.co.in> wrote:
> Hi,
>      I found this link http://hpctoolkit.org/ from some older references in this forum.
> 
> 
> Thanks,
> Mohan
> 
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny Dig
> Sent: Tuesday, August 30, 2011 12:28 AM
> To: Concurrency; Nathan Reynolds
> Subject: Re: [concurrency-interest] tools for parallel performance debugging
> 
> Thanks Nathan. These tools are all good suggestions. I am curious what
> other tools do people on this mailing list use for parallel
> programming in Java.
> 
> best,
> Danny
> 
> 
> On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
> <nathan.reynolds at oracle.com> wrote:
> > For identifying threading correctness issues, I recommend using Java Path
> > Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every possible
> > thread scheduling combination.  It does so by trying one thread scheduling
> > combination and then back tracking (i.e. revert the state of the program) to
> > simulate other combinations.  If there is a data race or deadlock, it will
> > find it and report it.  It doesn't just tell you that a data race or
> > deadlock exists but the steps that got to that state.  Because of the number
> > of combinations, it is best to run it on a small piece of the overall
> > program.
> >
> > As for synchronization contention, there are several tools available.
> > Looking through a dump of call stacks and seeing where the most threads are
> > blocked works for cases where the lock is dropping the throughput by 10% or
> > more.  The call stacks are easy to obtain but can be time consuming to sift
> > through.  JRockit's Mission Control can tell you exactly which locks are
> > most contended and give you the call stacks of where that lock is used.  I
> > am pretty sure most of the profilers can tell you which locks are most
> > contended, but since JRockit's Mission Control is free for me I haven't
> > looked at the profilers for a while.  I thought that JConsole or some tool
> > in the JDK could tell you the most contended lock... but I am really not
> > sure of that.
> >
> > As for false sharing, this is something that only the processor can tell
> > you.  For Intel, I *think* VTune can tell you about false sharing.  I know
> > that VTune can deal with Java optimized code.
> >
> > Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> > Oracle PSR Engineering | Server Technology
> > On 8/24/2011 8:07 PM, Danny Dig wrote:
> >
> > This community has been providing some great library features for
> > taming parallelism in Java.
> >
> > When it comes to tools for parallel performance debugging, it looks to
> > me that Java is trailing behind C++/Intel's ParallelStudio, or
> > C#/Microsoft's Visual Studio. When working with Java programs, what
> > are the tools that you recommend for:
> > - identifying threading correctness issues (e.g., data-races, deadlocks),
> > - identifying performance issues (load imbalance, synchronization
> > contention, false sharing)
> >
> > best,
> > Danny
> >
> >
> 
> 
> 
> --
> Danny Dig
> Visiting Research Assistant Professor at UIUC
> 
> http://netfiles.uiuc.edu/dig/www
> 
> Motto: "Success is not for the chosen few but for the few who choose"
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> DISCLAIMER:
> ==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the aut!
>  hor and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110912/272e5dfd/attachment-0001.html>

From nichole.king at gmail.com  Mon Sep 12 13:38:29 2011
From: nichole.king at gmail.com (Nichole King)
Date: Mon, 12 Sep 2011 10:38:29 -0700
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 80,
	Issue 17
In-Reply-To: <mailman.422.1315848490.3597.concurrency-interest@cs.oswego.edu>
References: <mailman.422.1315848490.3597.concurrency-interest@cs.oswego.edu>
Message-ID: <56D67E30-0130-489D-9573-F58DDEA0E48A@gmail.com>


Java's Visual VM is included in the Java distribution now.

or several tools from Intel:
    http://software.intel.com/en-us/articles/idb-linux/
    http://software.intel.com/en-us/articles/intel-inspector-xe/   
    http://software.intel.com/en-us/articles/intel-parallel-studio-home/




On Sep 12, 2011, at 10:28 AM, concurrency-interest-request at cs.oswego.edu wrote:

> Send Concurrency-interest mailing list submissions to
> 	concurrency-interest at cs.oswego.edu
> 
> To subscribe or unsubscribe via the World Wide Web, visit
> 	http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> 	concurrency-interest-request at cs.oswego.edu
> 
> You can reach the person managing the list at
> 	concurrency-interest-owner at cs.oswego.edu
> 
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
> 
> 
> Today's Topics:
> 
>   1. Re: tools for parallel performance debugging (Peter Veentjer)
>   2. Re: tools for parallel performance debugging (Jamie Allen)
> 
> 
> ----------------------------------------------------------------------
> 
> Message: 1
> Date: Mon, 12 Sep 2011 19:39:02 +0300
> From: Peter Veentjer <alarmnummer at gmail.com>
> Subject: Re: [concurrency-interest] tools for parallel performance
> 	debugging
> To: Mohan Radhakrishnan <mohanr at fss.co.in>
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Message-ID:
> 	<CAGuAWdDi+f9VeZXwdTyNESwKCei1LnmV+zAm00wYqbxkpnANCw at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
> 
> You might have a look at Intel VTune 9.0. It is able to do performance
> analysis on a very low level (based on cpu feedback) on machine
> instructions, and it also is able to connect this information back to
> bytecode/java-code.
> 
> So you can exactly see in your Java application what is happening on a very
> low level.
> 
> Unfortunately Intel VTune XE doesn't have support anymore for Java.
> 
> And interpreting the information is a expertise in itself.
> 
> And.. you need an Intel (and not even all cpu's) box for it too work.
> Getting it installed also can be very challenging.
> 
> 
> On Fri, Sep 2, 2011 at 8:55 AM, Mohan Radhakrishnan <mohanr at fss.co.in>wrote:
> 
>> Hi,
>>     I found this link http://hpctoolkit.org/ from some older references
>> in this forum.
>> 
>> 
>> Thanks,
>> Mohan
>> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:
>> concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny Dig
>> Sent: Tuesday, August 30, 2011 12:28 AM
>> To: Concurrency; Nathan Reynolds
>> Subject: Re: [concurrency-interest] tools for parallel performance
>> debugging
>> 
>> Thanks Nathan. These tools are all good suggestions. I am curious what
>> other tools do people on this mailing list use for parallel
>> programming in Java.
>> 
>> best,
>> Danny
>> 
>> 
>> On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
>> <nathan.reynolds at oracle.com> wrote:
>>> For identifying threading correctness issues, I recommend using Java Path
>>> Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every
>> possible
>>> thread scheduling combination.  It does so by trying one thread
>> scheduling
>>> combination and then back tracking (i.e. revert the state of the program)
>> to
>>> simulate other combinations.  If there is a data race or deadlock, it
>> will
>>> find it and report it.  It doesn't just tell you that a data race or
>>> deadlock exists but the steps that got to that state.  Because of the
>> number
>>> of combinations, it is best to run it on a small piece of the overall
>>> program.
>>> 
>>> As for synchronization contention, there are several tools available.
>>> Looking through a dump of call stacks and seeing where the most threads
>> are
>>> blocked works for cases where the lock is dropping the throughput by 10%
>> or
>>> more.  The call stacks are easy to obtain but can be time consuming to
>> sift
>>> through.  JRockit's Mission Control can tell you exactly which locks are
>>> most contended and give you the call stacks of where that lock is used.
>> I
>>> am pretty sure most of the profilers can tell you which locks are most
>>> contended, but since JRockit's Mission Control is free for me I haven't
>>> looked at the profilers for a while.  I thought that JConsole or some
>> tool
>>> in the JDK could tell you the most contended lock... but I am really not
>>> sure of that.
>>> 
>>> As for false sharing, this is something that only the processor can tell
>>> you.  For Intel, I *think* VTune can tell you about false sharing.  I
>> know
>>> that VTune can deal with Java optimized code.
>>> 
>>> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering | Server Technology
>>> On 8/24/2011 8:07 PM, Danny Dig wrote:
>>> 
>>> This community has been providing some great library features for
>>> taming parallelism in Java.
>>> 
>>> When it comes to tools for parallel performance debugging, it looks to
>>> me that Java is trailing behind C++/Intel's ParallelStudio, or
>>> C#/Microsoft's Visual Studio. When working with Java programs, what
>>> are the tools that you recommend for:
>>> - identifying threading correctness issues (e.g., data-races, deadlocks),
>>> - identifying performance issues (load imbalance, synchronization
>>> contention, false sharing)
>>> 
>>> best,
>>> Danny
>>> 
>>> 
>> 
>> 
>> 
>> --
>> Danny Dig
>> Visiting Research Assistant Professor at UIUC
>> 
>> http://netfiles.uiuc.edu/dig/www
>> 
>> Motto: "Success is not for the chosen few but for the few who choose"
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> DISCLAIMER:
>> ==========================================================================================================================================================The
>> information contained in this e-mail message may be privileged and/or
>> confidential and protected from disclosure under applicable law. It is
>> intended only for the individual to whom or entity to which it is addressed
>> as shown at the beginning of the message. If the reader of this message is
>> not the intended recipient, or if the employee or agent responsible for
>> delivering the message is not an employee or agent of the intended
>> recipient, you are hereby notified that any review,
>> dissemination,distribution, use, or copying of this message is strictly
>> prohibited. If you have received this message in error, please notify us
>> immediately by return e-mail and permanently delete this message and your
>> reply to the extent it includes this message. Any views or opinions
>> presented in this message or attachments are those of the aut!
>> hor and do not necessarily represent those of the Company. All e-mails and
>> attachments sent and received are subject to monitoring, reading, and
>> archival by the
>> Company.==========================================================================================================================================================
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110912/f9a9f7cc/attachment-0001.html>
> 
> ------------------------------
> 
> Message: 2
> Date: Mon, 12 Sep 2011 13:27:46 -0400
> From: Jamie Allen <jallen at chariotsolutions.com>
> Subject: Re: [concurrency-interest] tools for parallel performance
> 	debugging
> To: Peter Veentjer <alarmnummer at gmail.com>
> Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Message-ID:
> 	<3DEC1711-B59B-43E9-AA2D-E8D94EABC7E0 at chariotsolutions.com>
> Content-Type: text/plain; charset="us-ascii"
> 
> Isn't VTune also Windows and Linux only?  No OSX support, IIRC.
> 
> 
> 
> On Sep 12, 2011, at 12:39 PM, Peter Veentjer <alarmnummer at gmail.com> wrote:
> 
>> You might have a look at Intel VTune 9.0. It is able to do performance analysis on a very low level (based on cpu feedback) on machine instructions, and it also is able to connect this information back to bytecode/java-code.
>> 
>> So you can exactly see in your Java application what is happening on a very low level.
>> 
>> Unfortunately Intel VTune XE doesn't have support anymore for Java.
>> 
>> And interpreting the information is a expertise in itself.
>> 
>> And.. you need an Intel (and not even all cpu's) box for it too work. Getting it installed also can be very challenging.
>> 
>> 
>> On Fri, Sep 2, 2011 at 8:55 AM, Mohan Radhakrishnan <mohanr at fss.co.in> wrote:
>> Hi,
>>     I found this link http://hpctoolkit.org/ from some older references in this forum.
>> 
>> 
>> Thanks,
>> Mohan
>> 
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny Dig
>> Sent: Tuesday, August 30, 2011 12:28 AM
>> To: Concurrency; Nathan Reynolds
>> Subject: Re: [concurrency-interest] tools for parallel performance debugging
>> 
>> Thanks Nathan. These tools are all good suggestions. I am curious what
>> other tools do people on this mailing list use for parallel
>> programming in Java.
>> 
>> best,
>> Danny
>> 
>> 
>> On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
>> <nathan.reynolds at oracle.com> wrote:
>>> For identifying threading correctness issues, I recommend using Java Path
>>> Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every possible
>>> thread scheduling combination.  It does so by trying one thread scheduling
>>> combination and then back tracking (i.e. revert the state of the program) to
>>> simulate other combinations.  If there is a data race or deadlock, it will
>>> find it and report it.  It doesn't just tell you that a data race or
>>> deadlock exists but the steps that got to that state.  Because of the number
>>> of combinations, it is best to run it on a small piece of the overall
>>> program.
>>> 
>>> As for synchronization contention, there are several tools available.
>>> Looking through a dump of call stacks and seeing where the most threads are
>>> blocked works for cases where the lock is dropping the throughput by 10% or
>>> more.  The call stacks are easy to obtain but can be time consuming to sift
>>> through.  JRockit's Mission Control can tell you exactly which locks are
>>> most contended and give you the call stacks of where that lock is used.  I
>>> am pretty sure most of the profilers can tell you which locks are most
>>> contended, but since JRockit's Mission Control is free for me I haven't
>>> looked at the profilers for a while.  I thought that JConsole or some tool
>>> in the JDK could tell you the most contended lock... but I am really not
>>> sure of that.
>>> 
>>> As for false sharing, this is something that only the processor can tell
>>> you.  For Intel, I *think* VTune can tell you about false sharing.  I know
>>> that VTune can deal with Java optimized code.
>>> 
>>> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
>>> Oracle PSR Engineering | Server Technology
>>> On 8/24/2011 8:07 PM, Danny Dig wrote:
>>> 
>>> This community has been providing some great library features for
>>> taming parallelism in Java.
>>> 
>>> When it comes to tools for parallel performance debugging, it looks to
>>> me that Java is trailing behind C++/Intel's ParallelStudio, or
>>> C#/Microsoft's Visual Studio. When working with Java programs, what
>>> are the tools that you recommend for:
>>> - identifying threading correctness issues (e.g., data-races, deadlocks),
>>> - identifying performance issues (load imbalance, synchronization
>>> contention, false sharing)
>>> 
>>> best,
>>> Danny
>>> 
>>> 
>> 
>> 
>> 
>> --
>> Danny Dig
>> Visiting Research Assistant Professor at UIUC
>> 
>> http://netfiles.uiuc.edu/dig/www
>> 
>> Motto: "Success is not for the chosen few but for the few who choose"
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> DISCLAIMER:
>> ==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the a!
> ut!
>> hor and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110912/272e5dfd/attachment.html>
> 
> ------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> End of Concurrency-interest Digest, Vol 80, Issue 17
> ****************************************************



From mohanr at fss.co.in  Wed Sep 14 07:53:10 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Wed, 14 Sep 2011 17:23:10 +0530
Subject: [concurrency-interest] tools for parallel performance debugging
In-Reply-To: <CAGuAWdDi+f9VeZXwdTyNESwKCei1LnmV+zAm00wYqbxkpnANCw@mail.gmail.com>
Message-ID: <65F4195D4E2C6042BA66D4114E5BB9DC2BD2AE@fssbemail.fss.india>

Many of you might have received this list of books on multi-core
hardware and software.

 

http://www.intel.com/technology/rr/?utm_source=iContact&utm_medium=email
&utm_campaign=Marchpromo

 

Is any of these books recommended ? I think it might be useful to
understand why the concurrency API is written the way it is by looking
at the underlying concepts.

 

Thanks,

Mohan

 

________________________________

From: Peter Veentjer [mailto:alarmnummer at gmail.com] 
Sent: Monday, September 12, 2011 10:09 PM
To: Mohan Radhakrishnan
Cc: concurrency-interest
Subject: Re: [concurrency-interest] tools for parallel performance
debugging

 

You might have a look at Intel VTune 9.0. It is able to do performance
analysis on a very low level (based on cpu feedback) on machine
instructions, and it also is able to connect this information back to
bytecode/java-code.

 

So you can exactly see in your Java application what is happening on a
very low level.

 

Unfortunately Intel VTune XE doesn't have support anymore for Java.

 

And interpreting the information is a expertise in itself.

 

And.. you need an Intel (and not even all cpu's) box for it too work.
Getting it installed also can be very challenging.

 

 

On Fri, Sep 2, 2011 at 8:55 AM, Mohan Radhakrishnan <mohanr at fss.co.in>
wrote:

Hi,
     I found this link http://hpctoolkit.org/ from some older references
in this forum.


Thanks,
Mohan


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Danny
Dig
Sent: Tuesday, August 30, 2011 12:28 AM
To: Concurrency; Nathan Reynolds
Subject: Re: [concurrency-interest] tools for parallel performance
debugging

Thanks Nathan. These tools are all good suggestions. I am curious what
other tools do people on this mailing list use for parallel
programming in Java.

best,
Danny


On Thu, Aug 25, 2011 at 11:01 AM, Nathan Reynolds
<nathan.reynolds at oracle.com> wrote:
> For identifying threading correctness issues, I recommend using Java
Path
> Finder (http://babelfish.arc.nasa.gov/trac/jpf).  It executes every
possible
> thread scheduling combination.  It does so by trying one thread
scheduling
> combination and then back tracking (i.e. revert the state of the
program) to
> simulate other combinations.  If there is a data race or deadlock, it
will
> find it and report it.  It doesn't just tell you that a data race or
> deadlock exists but the steps that got to that state.  Because of the
number
> of combinations, it is best to run it on a small piece of the overall
> program.
>
> As for synchronization contention, there are several tools available.
> Looking through a dump of call stacks and seeing where the most
threads are
> blocked works for cases where the lock is dropping the throughput by
10% or
> more.  The call stacks are easy to obtain but can be time consuming to
sift
> through.  JRockit's Mission Control can tell you exactly which locks
are
> most contended and give you the call stacks of where that lock is
used.  I
> am pretty sure most of the profilers can tell you which locks are most
> contended, but since JRockit's Mission Control is free for me I
haven't
> looked at the profilers for a while.  I thought that JConsole or some
tool
> in the JDK could tell you the most contended lock... but I am really
not
> sure of that.
>
> As for false sharing, this is something that only the processor can
tell
> you.  For Intel, I *think* VTune can tell you about false sharing.  I
know
> that VTune can deal with Java optimized code.
>
> Nathan Reynolds | Consulting Member of Technical Staff | 602.333.9091
> Oracle PSR Engineering | Server Technology
> On 8/24/2011 8:07 PM, Danny Dig wrote:
>
> This community has been providing some great library features for
> taming parallelism in Java.
>
> When it comes to tools for parallel performance debugging, it looks to
> me that Java is trailing behind C++/Intel's ParallelStudio, or
> C#/Microsoft's Visual Studio. When working with Java programs, what
> are the tools that you recommend for:
> - identifying threading correctness issues (e.g., data-races,
deadlocks),
> - identifying performance issues (load imbalance, synchronization
> contention, false sharing)
>
> best,
> Danny
>
>



--
Danny Dig
Visiting Research Assistant Professor at UIUC

http://netfiles.uiuc.edu/dig/www

Motto: "Success is not for the chosen few but for the few who choose"

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



DISCLAIMER:
========================================================================
========================================================================
==========The information contained in this e-mail message may be
privileged and/or confidential and protected from disclosure under
applicable law. It is intended only for the individual to whom or entity
to which it is addressed as shown at the beginning of the message. If
the reader of this message is not the intended recipient, or if the
employee or agent responsible for delivering the message is not an
employee or agent of the intended recipient, you are hereby notified
that any review, dissemination,distribution, use, or copying of this
message is strictly prohibited. If you have received this message in
error, please notify us immediately by return e-mail and permanently
delete this message and your reply to the extent it includes this
message. Any views or opinions presented in this message or attachments
are those of the aut!

 hor and do not necessarily represent those of the Company. All e-mails
and attachments sent and received are subject to monitoring, reading,
and archival by the
Company.================================================================
========================================================================
==================

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 



DISCLAIMER:
==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the author and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110914/ad134913/attachment.html>

From mohanr at fss.co.in  Fri Sep 16 02:08:37 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Fri, 16 Sep 2011 11:38:37 +0530
Subject: [concurrency-interest] Phaser question
Message-ID: <65F4195D4E2C6042BA66D4114E5BB9DC3408F4@fssbemail.fss.india>

Hi,

       My code using the Phaser works the first time. I think here when
the onAdvance method is overridden (  return phase >= 2 ||
registeredParties == 0; )  I see log messages showing that the Phase is
advancing

but I suspect that since the Platform.runLater is a separate thread it
does not execute the task the second and third time.

 

Even though this is not strictly Phaser code only I am trying to
understand if any thread co-ordination is required here.

 

Thanks,

Mohan

 

 

        List<Runnable> tasks = new ArrayList<Runnable>();

        Runnable tsk = new Runnable(){

 

                        @Override

                        public void run() {

                            Platform.runLater(new Runnable() {

                                public void run() {

                                    //JavaFX animate works fine the
first time but does not iterate.

                                }

                            });

                        }

                    };

        tasks.add( tsk );

 

        phaser.register();

        for ( final Runnable task : tasks ) {

          phaser.register();

          new Thread() {

            public void run() {

                try {

                    sleep(1500);

                } catch (InterruptedException e) {

                    //Print info.                }

                do {

                    task.run();

                    phaser.arriveAndAwaitAdvance(); //Finish phase

                } while (!phaser.isTerminated());

            }

          }.start();

        }



DISCLAIMER:
==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the author and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/788d475e/attachment.html>

From joe.bowbeer at gmail.com  Fri Sep 16 02:58:36 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 15 Sep 2011 23:58:36 -0700
Subject: [concurrency-interest] Phaser question
In-Reply-To: <65F4195D4E2C6042BA66D4114E5BB9DC3408F4@fssbemail.fss.india>
References: <65F4195D4E2C6042BA66D4114E5BB9DC3408F4@fssbemail.fss.india>
Message-ID: <CAHzJPEpmRYO3UZxr6b0=ewRJ9FdPiZ5GuaoM0tjvkQszU=fhJg@mail.gmail.com>

I suggest not advancing the phaser until the associated JavaFX task has
completed.  Otherwise, the phaser will stop too soon.

Looking at your sample code, where most of the work happens in JavaFX-land,
I'm wondering if the JavaFX animation timeline support might be a better
match for this than a phaser running in a background thread.

Joe

On Thu, Sep 15, 2011 at 11:08 PM, Mohan Radhakrishnan wrote:

>  Hi,****
>
>        My code using the Phaser works the first time. I think here when the
> onAdvance method is overridden (  return phase >= 2 || registeredParties ==
> 0; )  I see log messages showing that the Phase is advancing****
>
> but I suspect that since the Platform.runLater is a separate thread it does
> not execute the task the second and third time.****
>
> ** **
>
> Even though this is not strictly Phaser code only I am trying to understand
> if any thread co-ordination is required here.****
>
> ** **
>
> Thanks,****
>
> Mohan****
>
> ** **
>
> ** **
>
>         List<Runnable> tasks = new ArrayList<Runnable>();****
>
>         Runnable tsk = new Runnable(){****
>
> ** **
>
>                         @Override****
>
>                         public void run() {****
>
>                             Platform.runLater(new Runnable() {****
>
>                                 public void run() {****
>
>                                     //JavaFX animate works fine the first
> time but does not iterate.****
>
>                                 }****
>
>                             });****
>
>                         }****
>
>                     };****
>
>         tasks.add( tsk );****
>
> ** **
>
>         phaser.register();****
>
>         for ( final Runnable task : tasks ) {****
>
>           phaser.register();****
>
>           new Thread() {****
>
>             public void run() {****
>
>                 try {****
>
>                     sleep(1500);****
>
>                 } catch (InterruptedException e) {****
>
>                     //Print info.                }****
>
>                 do {****
>
>                     task.run();****
>
>                     phaser.arriveAndAwaitAdvance(); //Finish phase****
>
>                 } while (!phaser.isTerminated());****
>
>             }****
>
>           }.start();****
>
>         }
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110915/f12142fc/attachment-0001.html>

From mohanr at fss.co.in  Fri Sep 16 04:53:53 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Fri, 16 Sep 2011 14:23:53 +0530
Subject: [concurrency-interest] Phaser question
In-Reply-To: <CAHzJPEpmRYO3UZxr6b0=ewRJ9FdPiZ5GuaoM0tjvkQszU=fhJg@mail.gmail.com>
Message-ID: <65F4195D4E2C6042BA66D4114E5BB9DC340A14@fssbemail.fss.india>

Ok. I did what you suggested that using a latch. This is not a JavaFX
project but a way of showing a simulation of what the Phaser is doing.

 

Thanks,

Mohan

 

________________________________

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe
Bowbeer
Sent: Friday, September 16, 2011 12:29 PM
To: concurrency-interest
Subject: Re: [concurrency-interest] Phaser question

 

I suggest not advancing the phaser until the associated JavaFX task has
completed.  Otherwise, the phaser will stop too soon.

 

Looking at your sample code, where most of the work happens in
JavaFX-land, I'm wondering if the JavaFX animation timeline support
might be a better match for this than a phaser running in a background
thread.

 

Joe

 

On Thu, Sep 15, 2011 at 11:08 PM, Mohan Radhakrishnan wrote:

	Hi,

	       My code using the Phaser works the first time. I think
here when the onAdvance method is overridden (  return phase >= 2 ||
registeredParties == 0; )  I see log messages showing that the Phase is
advancing

	but I suspect that since the Platform.runLater is a separate
thread it does not execute the task the second and third time.

	 

	Even though this is not strictly Phaser code only I am trying to
understand if any thread co-ordination is required here.

	 

	Thanks,

	Mohan

	 

	 

	        List<Runnable> tasks = new ArrayList<Runnable>();

	        Runnable tsk = new Runnable(){

	 

	                        @Override

	                        public void run() {

	                            Platform.runLater(new Runnable() {

	                                public void run() {

	                                    //JavaFX animate works fine
the first time but does not iterate.

	                                }

	                            });

	                        }

	                    };

	        tasks.add( tsk );

	 

	        phaser.register();

	        for ( final Runnable task : tasks ) {

	          phaser.register();

	          new Thread() {

	            public void run() {

	                try {

	                    sleep(1500);

	                } catch (InterruptedException e) {

	                    //Print info.                }

	                do {

	                    task.run();

	                    phaser.arriveAndAwaitAdvance(); //Finish
phase

	                } while (!phaser.isTerminated());

	            }

	          }.start();

	        }



DISCLAIMER:
==========================================================================================================================================================The information contained in this e-mail message may be privileged and/or confidential and protected from disclosure under applicable law. It is intended only for the individual to whom or entity to which it is addressed as shown at the beginning of the message. If the reader of this message is not the intended recipient, or if the employee or agent responsible for delivering the message is not an employee or agent of the intended recipient, you are hereby notified that any review, dissemination,distribution, use, or copying of this message is strictly prohibited. If you have received this message in error, please notify us immediately by return e-mail and permanently delete this message and your reply to the extent it includes this message. Any views or opinions presented in this message or attachments are those of the author and do not necessarily represent those of the Company. All e-mails and attachments sent and received are subject to monitoring, reading, and archival by the Company.==========================================================================================================================================================
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/b47c47c1/attachment.html>

From dig at illinois.edu  Fri Sep 16 11:21:06 2011
From: dig at illinois.edu (Danny Dig)
Date: Fri, 16 Sep 2011 10:21:06 -0500
Subject: [concurrency-interest] samples for parallel programming with Java 7
Message-ID: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>

I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
and other goodies for improving throughput on Java programs.

One reason could be the lack of small (but realistic) projects that
illustrate how to use parallelism to improve throughput. I think
Microsoft is doing a good job to show samples of such programs:
http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/

Does anyone know where to find such sample programs for Java?

best,
Danny

-- 
Danny Dig
Visiting Research Assistant Professor at UIUC

http://netfiles.uiuc.edu/dig/www

Motto: "Success is not for the chosen few but for the few who choose"

From oleksiy.khilkevich at gmail.com  Fri Sep 16 12:16:33 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Fri, 16 Sep 2011 19:16:33 +0300
Subject: [concurrency-interest] samples for parallel programming with
	Java 7
In-Reply-To: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
Message-ID: <CANUh1YxaOZg66anPZEAXxX73tje5-M9_fgxVQRyT8cuDAmQUxg@mail.gmail.com>

Danny, you're my hero today.

I've been searching for such kind of examples for a while and didn't find
anything useful.

A big thank you!

- Oleksiy

2011/9/16 Danny Dig <dig at illinois.edu>

> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
> and other goodies for improving throughput on Java programs.
>
> One reason could be the lack of small (but realistic) projects that
> illustrate how to use parallelism to improve throughput. I think
> Microsoft is doing a good job to show samples of such programs:
> http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/
>
> Does anyone know where to find such sample programs for Java?
>
> best,
> Danny
>
> --
> Danny Dig
> Visiting Research Assistant Professor at UIUC
>
> http://netfiles.uiuc.edu/dig/www
>
> Motto: "Success is not for the chosen few but for the few who choose"
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
-Oleksiy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/2bc96a9b/attachment.html>

From gregg at cytetech.com  Fri Sep 16 13:30:27 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 16 Sep 2011 12:30:27 -0500
Subject: [concurrency-interest] samples for parallel programming with
 Java 7
In-Reply-To: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
Message-ID: <4E7387B3.70404@cytetech.com>

On 9/16/2011 10:21 AM, Danny Dig wrote:
> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
> and other goodies for improving throughput on Java programs.
>
> One reason could be the lack of small (but realistic) projects that
> illustrate how to use parallelism to improve throughput. I think
> Microsoft is doing a good job to show samples of such programs:
> http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/
>
> Does anyone know where to find such sample programs for Java?

I feel that current, relevant documentation is the single largest issue that 
Java has to deal with.  You might find some examples at ibm.com and on some 
other commercial vendor sites who actually do provide support for a Java VM, or 
Java related technologies.

My viewpoint is that Java has been shepherded by a largely technical and "on 
college campus" community which doesn't seem to "document" solutions, just APIs. 
  I guess that this would be because it takes time which they would have to 
volunteer, away from their real job, and in many cases, it could document how 
they are "competing" with others, and thus close the gap on any advantage they 
get from Java.

Sun used to create a lot of good examples in the early days, of basic stuff. 
But so much of that stopped when everyone and their dog were publishing books on 
Java, or so it seems to me.

The book written by Brian Goetz, and others, "Java Concurrency in Practice" 
(http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601) 
provides a great deal of resources for what existed when it was written.

But, ultimately, that is why technical books, in the end are pretty worthless 
after a few months.  Since things continue to change in the j.u.c APIs, it would 
be much better for there to be some type of online version of that book that 
could be purchased with continued updates happening.  Maybe, someday, the 
publishing industry will understand the need and implement something useful. 
The Kindle version, for example, could just be continually updated and I'd be 
extremely excited by that, particularly if there were new examples being added 
regularly as "patterns" were proven or tuned up.

Gregg Wonderly

From studdugie at gmail.com  Fri Sep 16 13:41:19 2011
From: studdugie at gmail.com (Dane Foster)
Date: Fri, 16 Sep 2011 13:41:19 -0400
Subject: [concurrency-interest] samples for parallel programming with
	Java 7
In-Reply-To: <4E7387B3.70404@cytetech.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
	<4E7387B3.70404@cytetech.com>
Message-ID: <CA+WxinLqZL1=53jSEZ68SDL4eaZqxUezofaBx1jNLUE07tw1Nw@mail.gmail.com>

+1 on Gregg Wonderly's suggestion for what to do w/ JCP.

Dane


On Fri, Sep 16, 2011 at 1:30 PM, Gregg Wonderly <gregg at cytetech.com> wrote:

> On 9/16/2011 10:21 AM, Danny Dig wrote:
>
>> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
>> and other goodies for improving throughput on Java programs.
>>
>> One reason could be the lack of small (but realistic) projects that
>> illustrate how to use parallelism to improve throughput. I think
>> Microsoft is doing a good job to show samples of such programs:
>> http://code.msdn.microsoft.**com/Samples-for-Parallel-**b4b76364/<http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/>
>>
>> Does anyone know where to find such sample programs for Java?
>>
>
> I feel that current, relevant documentation is the single largest issue
> that Java has to deal with.  You might find some examples at ibm.com and
> on some other commercial vendor sites who actually do provide support for a
> Java VM, or Java related technologies.
>
> My viewpoint is that Java has been shepherded by a largely technical and
> "on college campus" community which doesn't seem to "document" solutions,
> just APIs.  I guess that this would be because it takes time which they
> would have to volunteer, away from their real job, and in many cases, it
> could document how they are "competing" with others, and thus close the gap
> on any advantage they get from Java.
>
> Sun used to create a lot of good examples in the early days, of basic
> stuff. But so much of that stopped when everyone and their dog were
> publishing books on Java, or so it seems to me.
>
> The book written by Brian Goetz, and others, "Java Concurrency in Practice"
> (http://www.amazon.com/Java-**Concurrency-Practice-Brian-**
> Goetz/dp/0321349601<http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601>)
> provides a great deal of resources for what existed when it was written.
>
> But, ultimately, that is why technical books, in the end are pretty
> worthless after a few months.  Since things continue to change in the j.u.c
> APIs, it would be much better for there to be some type of online version of
> that book that could be purchased with continued updates happening.  Maybe,
> someday, the publishing industry will understand the need and implement
> something useful. The Kindle version, for example, could just be continually
> updated and I'd be extremely excited by that, particularly if there were new
> examples being added regularly as "patterns" were proven or tuned up.
>
> Gregg Wonderly
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/2bcfe5d9/attachment.html>

From oleksiy.khilkevich at gmail.com  Fri Sep 16 15:55:16 2011
From: oleksiy.khilkevich at gmail.com (Oleksiy Khilkevich)
Date: Fri, 16 Sep 2011 22:55:16 +0300
Subject: [concurrency-interest] samples for parallel programming with
	Java 7
In-Reply-To: <CA+WxinLqZL1=53jSEZ68SDL4eaZqxUezofaBx1jNLUE07tw1Nw@mail.gmail.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
	<4E7387B3.70404@cytetech.com>
	<CA+WxinLqZL1=53jSEZ68SDL4eaZqxUezofaBx1jNLUE07tw1Nw@mail.gmail.com>
Message-ID: <CANUh1Yy9ujRnrssCH2wXkvA4yt-Ou+eMQRK0z71VOC4Znv0Ekg@mail.gmail.com>

+1 for Gregg's view on docs and +1 for Gregg's view on what online books
should do :)

As for the topic, i'd like to start to fill that gap. I'm not a pro in
concurrency, but aim to be, so taking my hands on filling this gap seems
like very challenging for me and very exciting to work on. This is so much
better than writing code for wastebin.

I'd like to suggest everyone who is ready to volunteer their time and
experience to help. We can start from porting the examples to Java, and end
up with a book that will be both innovative and exceptionally useful.

I can provide some resources like hosting and maintenance, can do some
coding, can do some writing, what i can't provide is a lot of experience
that is a valuable asset in such task.

I'm also not imply pretending to lead this process, i think the person with
broad enough vision and experience should.

Anyone?

-Oleksiy


2011/9/16 Dane Foster <studdugie at gmail.com>

> +1 on Gregg Wonderly's suggestion for what to do w/ JCP.
>
> Dane
>
>
>
> On Fri, Sep 16, 2011 at 1:30 PM, Gregg Wonderly <gregg at cytetech.com>wrote:
>
>> On 9/16/2011 10:21 AM, Danny Dig wrote:
>>
>>> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
>>> and other goodies for improving throughput on Java programs.
>>>
>>> One reason could be the lack of small (but realistic) projects that
>>> illustrate how to use parallelism to improve throughput. I think
>>> Microsoft is doing a good job to show samples of such programs:
>>> http://code.msdn.microsoft.**com/Samples-for-Parallel-**b4b76364/<http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/>
>>>
>>> Does anyone know where to find such sample programs for Java?
>>>
>>
>> I feel that current, relevant documentation is the single largest issue
>> that Java has to deal with.  You might find some examples at ibm.com and
>> on some other commercial vendor sites who actually do provide support for a
>> Java VM, or Java related technologies.
>>
>> My viewpoint is that Java has been shepherded by a largely technical and
>> "on college campus" community which doesn't seem to "document" solutions,
>> just APIs.  I guess that this would be because it takes time which they
>> would have to volunteer, away from their real job, and in many cases, it
>> could document how they are "competing" with others, and thus close the gap
>> on any advantage they get from Java.
>>
>> Sun used to create a lot of good examples in the early days, of basic
>> stuff. But so much of that stopped when everyone and their dog were
>> publishing books on Java, or so it seems to me.
>>
>> The book written by Brian Goetz, and others, "Java Concurrency in
>> Practice" (http://www.amazon.com/Java-**Concurrency-Practice-Brian-**
>> Goetz/dp/0321349601<http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601>)
>> provides a great deal of resources for what existed when it was written.
>>
>> But, ultimately, that is why technical books, in the end are pretty
>> worthless after a few months.  Since things continue to change in the j.u.c
>> APIs, it would be much better for there to be some type of online version of
>> that book that could be purchased with continued updates happening.  Maybe,
>> someday, the publishing industry will understand the need and implement
>> something useful. The Kindle version, for example, could just be continually
>> updated and I'd be extremely excited by that, particularly if there were new
>> examples being added regularly as "patterns" were proven or tuned up.
>>
>> Gregg Wonderly
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
-Oleksiy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/7db22d86/attachment-0001.html>

From studdugie at gmail.com  Fri Sep 16 16:05:39 2011
From: studdugie at gmail.com (Dane Foster)
Date: Fri, 16 Sep 2011 16:05:39 -0400
Subject: [concurrency-interest] samples for parallel programming with
	Java 7
In-Reply-To: <CANUh1Yy9ujRnrssCH2wXkvA4yt-Ou+eMQRK0z71VOC4Znv0Ekg@mail.gmail.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
	<4E7387B3.70404@cytetech.com>
	<CA+WxinLqZL1=53jSEZ68SDL4eaZqxUezofaBx1jNLUE07tw1Nw@mail.gmail.com>
	<CANUh1Yy9ujRnrssCH2wXkvA4yt-Ou+eMQRK0z71VOC4Znv0Ekg@mail.gmail.com>
Message-ID: <CA+WxinKy+O=mQL-rO5_gNrrbYRsn+h67q1kKurWnZyDBMA=x-w@mail.gmail.com>

I don't have any free cycles at the moment to port any of the examples, but
if some infrastructure (e.g., wiki, git or mercurial repo, etc) is put in
place then people can contribute at their own pace, myself included.

Dane


On Fri, Sep 16, 2011 at 3:55 PM, Oleksiy Khilkevich <
oleksiy.khilkevich at gmail.com> wrote:

> +1 for Gregg's view on docs and +1 for Gregg's view on what online books
> should do :)
>
> As for the topic, i'd like to start to fill that gap. I'm not a pro in
> concurrency, but aim to be, so taking my hands on filling this gap seems
> like very challenging for me and very exciting to work on. This is so much
> better than writing code for wastebin.
>
> I'd like to suggest everyone who is ready to volunteer their time and
> experience to help. We can start from porting the examples to Java, and end
> up with a book that will be both innovative and exceptionally useful.
>
> I can provide some resources like hosting and maintenance, can do some
> coding, can do some writing, what i can't provide is a lot of experience
> that is a valuable asset in such task.
>
> I'm also not imply pretending to lead this process, i think the person with
> broad enough vision and experience should.
>
> Anyone?
>
> -Oleksiy
>
>
> 2011/9/16 Dane Foster <studdugie at gmail.com>
>
>> +1 on Gregg Wonderly's suggestion for what to do w/ JCP.
>>
>> Dane
>>
>>
>>
>> On Fri, Sep 16, 2011 at 1:30 PM, Gregg Wonderly <gregg at cytetech.com>wrote:
>>
>>> On 9/16/2011 10:21 AM, Danny Dig wrote:
>>>
>>>> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
>>>> and other goodies for improving throughput on Java programs.
>>>>
>>>> One reason could be the lack of small (but realistic) projects that
>>>> illustrate how to use parallelism to improve throughput. I think
>>>> Microsoft is doing a good job to show samples of such programs:
>>>> http://code.msdn.microsoft.**com/Samples-for-Parallel-**b4b76364/<http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/>
>>>>
>>>> Does anyone know where to find such sample programs for Java?
>>>>
>>>
>>> I feel that current, relevant documentation is the single largest issue
>>> that Java has to deal with.  You might find some examples at ibm.com and
>>> on some other commercial vendor sites who actually do provide support for a
>>> Java VM, or Java related technologies.
>>>
>>> My viewpoint is that Java has been shepherded by a largely technical and
>>> "on college campus" community which doesn't seem to "document" solutions,
>>> just APIs.  I guess that this would be because it takes time which they
>>> would have to volunteer, away from their real job, and in many cases, it
>>> could document how they are "competing" with others, and thus close the gap
>>> on any advantage they get from Java.
>>>
>>> Sun used to create a lot of good examples in the early days, of basic
>>> stuff. But so much of that stopped when everyone and their dog were
>>> publishing books on Java, or so it seems to me.
>>>
>>> The book written by Brian Goetz, and others, "Java Concurrency in
>>> Practice" (http://www.amazon.com/Java-**Concurrency-Practice-Brian-**
>>> Goetz/dp/0321349601<http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601>)
>>> provides a great deal of resources for what existed when it was written.
>>>
>>> But, ultimately, that is why technical books, in the end are pretty
>>> worthless after a few months.  Since things continue to change in the j.u.c
>>> APIs, it would be much better for there to be some type of online version of
>>> that book that could be purchased with continued updates happening.  Maybe,
>>> someday, the publishing industry will understand the need and implement
>>> something useful. The Kindle version, for example, could just be continually
>>> updated and I'd be extremely excited by that, particularly if there were new
>>> examples being added regularly as "patterns" were proven or tuned up.
>>>
>>> Gregg Wonderly
>>> ______________________________**_________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.**oswego.edu<Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> --
> -Oleksiy
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110916/730fb6fe/attachment.html>

From dig at illinois.edu  Fri Sep 16 16:12:00 2011
From: dig at illinois.edu (Danny Dig)
Date: Fri, 16 Sep 2011 15:12:00 -0500
Subject: [concurrency-interest] samples for parallel programming with
	Java 7
In-Reply-To: <CANUh1Yy9ujRnrssCH2wXkvA4yt-Ou+eMQRK0z71VOC4Znv0Ekg@mail.gmail.com>
References: <CADiYQu4ZRPRQwP9N74pQEFSrnECmNtz2FayT3guetLbMzJMS1Q@mail.gmail.com>
	<4E7387B3.70404@cytetech.com>
	<CA+WxinLqZL1=53jSEZ68SDL4eaZqxUezofaBx1jNLUE07tw1Nw@mail.gmail.com>
	<CANUh1Yy9ujRnrssCH2wXkvA4yt-Ou+eMQRK0z71VOC4Znv0Ekg@mail.gmail.com>
Message-ID: <CADiYQu75Jys=ogbB1fYL6MhUBKXc2Nd_xOJK7D9H4EbBjao-0A@mail.gmail.com>

On Fri, Sep 16, 2011 at 2:55 PM, Oleksiy Khilkevich
<oleksiy.khilkevich at gmail.com> wrote:
> I'd like to suggest everyone who is ready to volunteer their time and
> experience to help. We can start from porting the examples to Java,

I already asked a couple of my students to start porting some examples
to Java. It would be useful to first port those that have some
graphical interface (like BlendingImage, Morph, RayTracer). It's very
easy to see speedups by just watching the program run.

Some things are easy to port (e.g., algorithmic code from C# -> Java),
while others are more complex (translating the
GUI).

> and end up with a book that will be both innovative and exceptionally useful.

At this point I do not have resources for publishing books.

I would be happy with a set of small, but realistic programs that use
parallelism. We certainly can use some help with porting.

best,
Danny


> 2011/9/16 Dane Foster <studdugie at gmail.com>
>>
>> +1 on Gregg Wonderly's suggestion for what to do w/ JCP.
>>
>> Dane
>>
>>
>> On Fri, Sep 16, 2011 at 1:30 PM, Gregg Wonderly <gregg at cytetech.com>
>> wrote:
>>>
>>> On 9/16/2011 10:21 AM, Danny Dig wrote:
>>>>
>>>> I am frustrated by the slow adoption of ForkJoinTask, ParallelArray,
>>>> and other goodies for improving throughput on Java programs.
>>>>
>>>> One reason could be the lack of small (but realistic) projects that
>>>> illustrate how to use parallelism to improve throughput. I think
>>>> Microsoft is doing a good job to show samples of such programs:
>>>> http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364/
>>>>
>>>> Does anyone know where to find such sample programs for Java?
>>>
>>> I feel that current, relevant documentation is the single largest issue
>>> that Java has to deal with. ?You might find some examples at ibm.com and on
>>> some other commercial vendor sites who actually do provide support for a
>>> Java VM, or Java related technologies.
>>>
>>> My viewpoint is that Java has been shepherded by a largely technical and
>>> "on college campus" community which doesn't seem to "document" solutions,
>>> just APIs. ?I guess that this would be because it takes time which they
>>> would have to volunteer, away from their real job, and in many cases, it
>>> could document how they are "competing" with others, and thus close the gap
>>> on any advantage they get from Java.
>>>
>>> Sun used to create a lot of good examples in the early days, of basic
>>> stuff. But so much of that stopped when everyone and their dog were
>>> publishing books on Java, or so it seems to me.
>>>
>>> The book written by Brian Goetz, and others, "Java Concurrency in
>>> Practice"
>>> (http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601)
>>> provides a great deal of resources for what existed when it was written.
>>>
>>> But, ultimately, that is why technical books, in the end are pretty
>>> worthless after a few months. ?Since things continue to change in the j.u.c
>>> APIs, it would be much better for there to be some type of online version of
>>> that book that could be purchased with continued updates happening. ?Maybe,
>>> someday, the publishing industry will understand the need and implement
>>> something useful. The Kindle version, for example, could just be continually
>>> updated and I'd be extremely excited by that, particularly if there were new
>>> examples being added regularly as "patterns" were proven or tuned up.
>>>
>>> Gregg Wonderly
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> -Oleksiy
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>



-- 
Danny Dig
Visiting Research Assistant Professor at UIUC

http://netfiles.uiuc.edu/dig/www

Motto: "Success is not for the chosen few but for the few who choose"


From zhong.j.yu at gmail.com  Fri Sep 16 18:31:04 2011
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Fri, 16 Sep 2011 17:31:04 -0500
Subject: [concurrency-interest] Thread Safety of java.lang.ClassValue
Message-ID: <CACuKZqGuvCTLgYQ4cGa8xitBm-grROtYLT_ap=LV=acp-Pbqqw@mail.gmail.com>

The impl of java.lang.ClassValue seems very wrong

http://www.docjar.com/html/api/java/lang/ClassValue.java.html

The code calls get() on WeakHashMap without any memory fense, while
other threads could be updating the map concurrently. That cannot be
right!? Since this is in the java.lang pakcage, I have to assume first
that there's something I don't know. Could anyone double check the
source and see if it's correct?


Zhong Yu

From wolfgang.hoschek at mac.com  Sat Sep 17 20:27:12 2011
From: wolfgang.hoschek at mac.com (Wolfgang Hoschek)
Date: Sat, 17 Sep 2011 17:27:12 -0700
Subject: [concurrency-interest] Using TimSort merges for ParallelArray.sort()
Message-ID: <A4D3B062-AD1C-4CBD-879F-E3822FD5B0F6@mac.com>

We're considering to use the parallel merge sort in the ParallelArray class of the extra166y package for stable sorting.

However, I recently learned that Java 7 ships with TimSort, an optimized sequential adaptive merge sort that includes clever optimizations for partially ordered data in the merge phase, which is often a common case in practise. Here are some numbers:

http://mail.openjdk.java.net/pipermail/core-libs-dev/2009-June/001933.html

I'm wondering if the ideas in TimSort could be successfully applied to the merge phase of the ParallelArray sort algorithm as well. And I'm wondering to what extent the parallel implementation can remain competitive with the sequential Java 7 sort for partially ordered data. With, say, 8 cores, partially ordered data and relatively expensive comparison functions.

Are there any plans to explore refining the algorithm before the release of extra166y?

P.S. The Java 7 TimSort was ported from Python for use in Android and contributed to Java by Josh Bloch @ Google, who is also the original author of the sort code in Java prior to JDK 7. 

References:
http://bugs.python.org/file4451/timsort.txt
http://en.wikipedia.org/wiki/Timsort
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6804124
http://mail.openjdk.java.net/pipermail/core-libs-dev/2009-June/001937.html
http://hg.openjdk.java.net/jdk7/jdk7/jdk/raw-file/bfd7abda8f79/src/share/classes/java/util/TimSort.java

-Wolfgang Hoschek

From davidcholmes at aapt.net.au  Sun Sep 18 06:27:12 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sun, 18 Sep 2011 20:27:12 +1000
Subject: [concurrency-interest] Phaser question
In-Reply-To: <65F4195D4E2C6042BA66D4114E5BB9DC3408F4@fssbemail.fss.india>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEAAJAAA.davidcholmes@aapt.net.au>

Maybe I'm missing something but your main thread is registered with the
Phaser but never arrives, so any of the task threads calling
arriveAndAwaitAdvance would block forever.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mohan
Radhakrishnan
  Sent: Friday, 16 September 2011 4:09 PM
  To: concurrency-interest
  Subject: [concurrency-interest] Phaser question


  Hi,

         My code using the Phaser works the first time. I think here when
the onAdvance method is overridden (  return phase >= 2 || registeredParties
== 0; )  I see log messages showing that the Phase is advancing

  but I suspect that since the Platform.runLater is a separate thread it
does not execute the task the second and third time.



  Even though this is not strictly Phaser code only I am trying to
understand if any thread co-ordination is required here.



  Thanks,

  Mohan





          List<Runnable> tasks = new ArrayList<Runnable>();

          Runnable tsk = new Runnable(){



                          @Override

                          public void run() {

                              Platform.runLater(new Runnable() {

                                  public void run() {

                                      //JavaFX animate works fine the first
time but does not iterate.

                                  }

                              });

                          }

                      };

          tasks.add( tsk );



          phaser.register();

          for ( final Runnable task : tasks ) {

            phaser.register();

            new Thread() {

              public void run() {

                  try {

                      sleep(1500);

                  } catch (InterruptedException e) {

                      //Print info.                }

                  do {

                      task.run();

                      phaser.arriveAndAwaitAdvance(); //Finish phase

                  } while (!phaser.isTerminated());

              }

            }.start();

          }


  DISCLAIMER:
  ==========================================================================
============================================================================
====
  The information contained in this e-mail message may be privileged and/or
confidential and protected from disclosure under applicable law. It is
intended only for the individual to whom or entity to which it is addressed
as shown at the beginning of the message. If the reader of this message is
not the intended recipient, or if the employee or agent responsible for
delivering the message is not an employee or agent of the intended
recipient, you are hereby notified that any review,
dissemination,distribution, use, or copying of this message is strictly
prohibited. If you have received this message in error, please notify us
immediately by return e-mail and permanently delete this message and your
reply to the extent it includes this message. Any views or opinions
presented in this message or attachments are those of the author and do not
necessarily represent those of the Company. All e-mails and attachments sent
and received are subject to monitoring, reading, and archival by the
Company.
  ==========================================================================
============================================================================
====
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110918/2d157f03/attachment.html>

From dl at cs.oswego.edu  Sun Sep 18 08:09:55 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 18 Sep 2011 08:09:55 -0400
Subject: [concurrency-interest] Using TimSort merges for
	ParallelArray.sort()
In-Reply-To: <A4D3B062-AD1C-4CBD-879F-E3822FD5B0F6@mac.com>
References: <A4D3B062-AD1C-4CBD-879F-E3822FD5B0F6@mac.com>
Message-ID: <4E75DF93.6080509@cs.oswego.edu>

On 09/17/11 20:27, Wolfgang Hoschek wrote:
> We're considering to use the parallel merge sort in the ParallelArray class
> of the extra166y package for stable sorting.

There's an intrinsic mismatch between stable-sort guarantees
(i.e., that ties are kept in original sequential order) and
parallelism. It's possible to get some parallelism here, but
the added sequential constraint reduces potential speedups.
I think that it is still an open question whether it is
usually worthwhile, since stable sorts are often desired
when data are already mostly sorted anyway, in which
case a sequential application of TimSort will likely
be about as fast as anything else you can do.

>
> I'm wondering if the ideas in TimSort could be successfully applied to the
> merge phase of the ParallelArray sort algorithm as well.

An additional small snag here is that TimSort internally
allocates small merge space arrays. But a parallel sort must
bulk-allocate the entire merge array anyway, which should
ideally be used in these calls, but won't be unless/until
TimSort has an internal API that allows callers to provide
them.

-Doug


From dl at cs.oswego.edu  Fri Sep 30 12:41:58 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 30 Sep 2011 12:41:58 -0400
Subject: [concurrency-interest] AtomicXXX.lazySet and happens-before
	reasoning
In-Reply-To: <CAOwENiKRpG6-5tizEfhU7vK9TbGtbLBC=4g-T93Kaw1dtHdJkw@mail.gmail.com>
References: <CAOwENi+Z5=TcukpoAHp-ROaMuNuRM6iG-igOy43TjEJtRm0ytg@mail.gmail.com>	<4E85AFB2.3070804@cs.oswego.edu>	<CAOwENiLmWKhwaemUqg9jf6K2FP7GeGBQKqa8rait5yYf_BQgrA@mail.gmail.com>	<4E85CECC.3050209@cs.oswego.edu>
	<CAOwENiKRpG6-5tizEfhU7vK9TbGtbLBC=4g-T93Kaw1dtHdJkw@mail.gmail.com>
Message-ID: <4E85F156.40607@cs.oswego.edu>


On 09/30/11 11:18, Ruslan Cheremin wrote:
> I still do not catch it. As far as I see we have 2 question about the code:

These are still good questions, because they have no direct answers in JLS.
But because they don't, you need to use other existing information to decode.
One more try:

>
> 1) Will lazySet write actually happens in some finite time?

The most you can say from the spec is that it will be written
no later than at the point that the process must write anything
else in the Synchronization Order, if such a point exists.
However, independently of the spec, we know that so long as
any process makes progress,  only a finite number of writes
can be delayed. So, yes.

> 2) If it happens (== we see spin-wait loop finished) -- does it mean, what
> all writes preceeding lazySet are also done, commited, _and visible_ to
> thread 2, which finished spin-wait loop?

Yes, although technically, you cannot show this by reference
to the Synchronization Order in the current JLS. A fully
integrated account would be along the lines of that for
the (non-existent) order{Writes,Accesses} Fences in
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

-Doug

From jason.greene at redhat.com  Fri Sep 30 12:58:26 2011
From: jason.greene at redhat.com (Jason T. Greene)
Date: Fri, 30 Sep 2011 11:58:26 -0500
Subject: [concurrency-interest] ConcurrentHashMapV8
In-Reply-To: <4E68AAC9.9070800@cs.oswego.edu>
References: <4E5A95E0.1080309@cs.oswego.edu> <4E68AAC9.9070800@cs.oswego.edu>
Message-ID: <4E85F532.1040808@redhat.com>

On 9/8/11 6:45 AM, Doug Lea wrote:
>
> Among some further ongoing improvements and extensions (mainly
> to support parallel aggregate operations), I'm contemplating
> (nearly) ignoring "loadFactor" constructor arguments for
> ConcurrentHashMap (in "V8" form for now, but ultimately
> targeting revised j.u.c version). The main motivation
> is that in concurrent hash maps (of any form) collisions
> and contention are interdependent, so anyone using a
> higher-than-default load factor because they think it will
> save space is also unexpectedly getting poorer multithreaded
> performance. Given how hard it was to give clear answers to
> questions on this list about exactly what blocks when based on
> probability distributions with a parameter based on load factor,
> I'm now thinking that is best to internally always use
> the default, and use the optional constructor parameter
> only as an initial sizing hint (larger loadFactor ->
> smaller initial capacity). This will enable simpler
> characterization of expected performance.
>
> Scanning for uses of ConcurrentHashMap constructors
> on google code search, it seems that hardly anyone ever
> overrides the default anyway, so this probably doesn't
> matter much either way. But if you have ever done so,
> and have a good reason, could you let me know? Thanks!

What about just limiting the upper range? I could see someone dropping 
the default load factor to get marginally better throughput.

Although, IMO the only must-have scenario for exposing a load factor is 
if you have an open addressed map and the factor heavily affects access 
time.

-- 
Jason T. Greene
JBoss AS Lead / EAP Platform Architect
JBoss, a division of Red Hat

From dl at cs.oswego.edu  Fri Sep 30 13:03:41 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 30 Sep 2011 13:03:41 -0400
Subject: [concurrency-interest] AtomicXXX.lazySet and happens-before
	reasoning
In-Reply-To: <4E85E435.5060707@oracle.com>
References: <CAOwENi+Z5=TcukpoAHp-ROaMuNuRM6iG-igOy43TjEJtRm0ytg@mail.gmail.com>	<4E85AFB2.3070804@cs.oswego.edu>
	<CAOwENiLmWKhwaemUqg9jf6K2FP7GeGBQKqa8rait5yYf_BQgrA@mail.gmail.com>
	<4E85CECC.3050209@cs.oswego.edu> <4E85E435.5060707@oracle.com>
Message-ID: <4E85F66D.2020202@cs.oswego.edu>

On 09/30/11 11:45, Nathan Reynolds wrote:
> ... lazySet() ...
> won't be reordered with respect to preceding stores.

The important part of the spec is to prohibit reordering
wrt previous writes. Sorry again for the terrible method name.

For those familiar with new C++ spec, it is the same as
store(memory_order_release). Because all of these modes were
spec'ed at the same time, the C++ specs have a much better
integration with the data-race-free parts of the memory model,
so it is in some ways a better guide, modulo all the ways
Java and C++ memory models differ wrt thin-air reads.

>
> weakCompareAndSet() appear to simply defer to compareAndSet() in the JDK code.

In the base implementations on x86 and sparc, it is the same.
But others can specialize it, and at least Azul does so.
In particular, a weakCompareAndset can be mapped to LL/SC
on ARM and POWER or other machines that have it but not CAS.
We don't use weakCompareAndSet much inside j.u.c. because we
normally need the fully-fenced version anyway.

-Doug

From hans.boehm at hp.com  Fri Sep 30 16:25:27 2011
From: hans.boehm at hp.com (Boehm, Hans)
Date: Fri, 30 Sep 2011 20:25:27 +0000
Subject: [concurrency-interest] AtomicXXX.lazySet and
	happens-before	reasoning
In-Reply-To: <CAOwENiLmWKhwaemUqg9jf6K2FP7GeGBQKqa8rait5yYf_BQgrA@mail.gmail.com>
References: <CAOwENi+Z5=TcukpoAHp-ROaMuNuRM6iG-igOy43TjEJtRm0ytg@mail.gmail.com>
	<4E85AFB2.3070804@cs.oswego.edu>
	<CAOwENiLmWKhwaemUqg9jf6K2FP7GeGBQKqa8rait5yYf_BQgrA@mail.gmail.com>
Message-ID: <A3E67C2071F49C4CBC4F17E6D77CDDD203FB0A@G4W3299.americas.hpqcorp.net>

> c) Does it mean what next JMM release will throw out HB reasoning and
> move to memory barriers/fences notation?
> 
Adding to Doug's answer, the answer to this question is a resounding "no".  Happens-before reasoning largely remains valid with lazySet, as you can see in the C++ model (which is unfortunately also significantly complicated by memory_order_consume, which currently has no Java analog, though it's closely related to some of the final field extension discussions).  What I believe goes away is any meaningful notion of a single total synchronization order.

I do not believe you ever want to reason in terms of fences.  Such reasoning is not usually sound for Java, since the memory model is carefully designed to allow elimination of synchronization on e.g. a volatile accessible form accessed by only a single thread.  Java volatiles etc. do not have fence semantics.  I do not know of any language-level memory models that have been successfully expressed in terms of fences.  See http://dl.acm.org/citation.cfm?doid=1988915.1988919 for a discussion of why I don't consider a couple of better known attempts to be fully successful.

Hans


