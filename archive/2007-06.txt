From hanson.char at gmail.com  Fri Jun  1 00:43:20 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Thu, 31 May 2007 21:43:20 -0700
Subject: [concurrency-interest] Synchronized between private methods in
	a servlet
In-Reply-To: <10905476.post@talk.nabble.com>
References: <10905476.post@talk.nabble.com>
Message-ID: <ca53c8f80705312143q112449far7603a9bd2b2ca70e@mail.gmail.com>

String is immutable so it doesn't need any synchronization.   Is "list"
always locally created in doPost and only used in doPost ?  If so, it is
inherently thread-safe and there is no need for any synchronization.  If
not, localizing the synchronization locking to the list per se rather than
the executing servlet is probably a better option.

My 2 cents.

Hanson Char

On 5/31/07, David Harrigan <dharrigan at gmail.com> wrote:
>
>
> Hi,
>
> I hope not too basic a question for this illustrious list...
>
> I'm using Java 6 update 1.
>
> I have 3 private methods. I want to ensure that I'm thread safe when these
> methods are called from the doPost in a servlet (I know servlets aren't
> threadsafe and I want to ensure that my little servlet is executing in the
> best way) thus:
>
> public void doPost(HttpServletRequest request, HttpServletResponse
> response)
> {
>    ...
>    List<String> list = ...;
>    A(list);
>    ...
> }
>
> private synchronized void A(List<String> list) {
>    ...
>    B(stringValue);
>    ...
> }
>
> private void B(final String stringValue) {
>    ...
>    C(stringValue);
>    ...
> }
>
> private void C(final String stringValue) {
>    ...
>    ...
> }
>
> My questions are:
>
> 1. Is it sufficient just to put the synchronized on method A since methods
> B
> and C are only called from within A?
> 2. Maybe I don't need to put synchronized on, since method A is only
> called
> from the doPost?
> 3. Maybe I can use the lock...unlock in doPost, wrapped around the call to
> method A?
> 4. If I have to use synchronized, would I get better performance using
> lock...unlock inside method A?
>
> Thanks everyone!
>
> -=david=-
> --
> View this message in context:
> http://www.nabble.com/Synchronized-between-private-methods-in-a-servlet-tf3849923.html#a10905476
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070531/127d1699/attachment.html 

From holger at wizards.de  Fri Jun  1 05:24:08 2007
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Fri, 01 Jun 2007 11:24:08 +0200
Subject: [concurrency-interest] Synchronized between private methods in
 a servlet
In-Reply-To: <10905476.post@talk.nabble.com>
References: <10905476.post@talk.nabble.com>
Message-ID: <465FE5B8.7010109@wizards.de>

David Harrigan wrote:
> I have 3 private methods. I want to ensure that I'm thread safe when these
> methods are called from the doPost in a servlet (I know servlets aren't
> threadsafe and I want to ensure that my little servlet is executing in the

"Servlets are not threadsafe" is not true. They are executed by multiple
threads concurrently; that's something else. It's usually best to avoid
the imprecise term "threadsafe" because it is too context-dependent.

> best way) thus:
> 
> public void doPost(HttpServletRequest request, HttpServletResponse response)
> {
>    ...
>    List<String> list = ...;
>    A(list);
>    ...
> }
> 
> private synchronized void A(List<String> list) {
>    ...
>    B(stringValue);
>    ...
> }
> 
> private void B(final String stringValue) {
>    ...
>    C(stringValue);
>    ...
> }
> 
> private void C(final String stringValue) {
>    ...
>    ...
> }
> 
> My questions are:
> 
> 1. Is it sufficient just to put the synchronized on method A since methods B
> and C are only called from within A?

Yes, it would - if: see 2.

> 2. Maybe I don't need to put synchronized on, since method A is only called
> from the doPost?

If A does not use any shared state or does not need to order operations in
some way (which it probably should not do in the servlet for architectural
reasons anyway) then you can just as well leave the synchronization out, yes.

> 3. Maybe I can use the lock...unlock in doPost, wrapped around the call to
> method A?

You could do that and it would have the same effect: only one
request/response at a time would be able to enter A in that servlet
instance. (!)

> 4. If I have to use synchronized, would I get better performance using
> lock...unlock inside method A?

No, not really; one path, one lock. Only if there is significant work
(e.g. a long calculation) being done before or after the locked region
then you'd shorten the time in the lock.

-h


From dharrigan at gmail.com  Fri Jun  1 08:36:08 2007
From: dharrigan at gmail.com (David Harrigan)
Date: Fri, 01 Jun 2007 13:36:08 +0100
Subject: [concurrency-interest] Synchronized between private methods in
 a servlet
In-Reply-To: <465FE5B8.7010109@wizards.de>
References: <10905476.post@talk.nabble.com> <465FE5B8.7010109@wizards.de>
Message-ID: <466012B8.70904@gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello,

Thanks everyone. Following advice, and looking at the code, I can remove
the synchronization because the List is only created in the doPost and
not referenced anywhere else. Thanks Holger and thanks Hanson!

- -=david=-

Holger Hoffst?tte wrote:
> David Harrigan wrote:
>> I have 3 private methods. I want to ensure that I'm thread safe when these
>> methods are called from the doPost in a servlet (I know servlets aren't
>> threadsafe and I want to ensure that my little servlet is executing in the
> 
> "Servlets are not threadsafe" is not true. They are executed by multiple
> threads concurrently; that's something else. It's usually best to avoid
> the imprecise term "threadsafe" because it is too context-dependent.
> 
>> best way) thus:
>>
>> public void doPost(HttpServletRequest request, HttpServletResponse response)
>> {
>>    ...
>>    List<String> list = ...;
>>    A(list);
>>    ...
>> }
>>
>> private synchronized void A(List<String> list) {
>>    ...
>>    B(stringValue);
>>    ...
>> }
>>
>> private void B(final String stringValue) {
>>    ...
>>    C(stringValue);
>>    ...
>> }
>>
>> private void C(final String stringValue) {
>>    ...
>>    ...
>> }
>>
>> My questions are:
>>
>> 1. Is it sufficient just to put the synchronized on method A since methods B
>> and C are only called from within A?
> 
> Yes, it would - if: see 2.
> 
>> 2. Maybe I don't need to put synchronized on, since method A is only called
>> from the doPost?
> 
> If A does not use any shared state or does not need to order operations in
> some way (which it probably should not do in the servlet for architectural
> reasons anyway) then you can just as well leave the synchronization out, yes.
> 
>> 3. Maybe I can use the lock...unlock in doPost, wrapped around the call to
>> method A?
> 
> You could do that and it would have the same effect: only one
> request/response at a time would be able to enter A in that servlet
> instance. (!)
> 
>> 4. If I have to use synchronized, would I get better performance using
>> lock...unlock inside method A?
> 
> No, not really; one path, one lock. Only if there is significant work
> (e.g. a long calculation) being done before or after the locked region
> then you'd shorten the time in the lock.
> 
> -h
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

- --

PGP Key Id: 0xE2BE72FC
Public Key: http://www.harrigan.info/public.asc

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGYBK4a5vShOK+cvwRApUwAKDXuKPZcHDswiZiX4h5hBkAmNxpYwCdGu+b
itOPFf2nXP9p6LbNic2cJI0=
=t/8e
-----END PGP SIGNATURE-----

From bflat1 at gmx.net  Tue Jun  5 16:45:53 2007
From: bflat1 at gmx.net (Felix Berger)
Date: Tue, 5 Jun 2007 16:45:53 -0400
Subject: [concurrency-interest] ThreadPoolExecutor: maximumPoolSize not
	honored for practically unlimited queues
Message-ID: <6275f96c0706051345o299cfbbbk1d39b2ab317a9cea@mail.gmail.com>

Hi,

we're creating an ThreadPoolExecutor with a fixed maximum number of
threads like this:

 ThreadPoolExecutor tpe =  new ThreadPoolExecutor(1, size,
                5L, TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(),
                daemonThreadFactory(name));
        tpe.allowCoreThreadTimeOut(true);

where size is the maximum number of threads executing the tasks.

We noticed that only one thread (the core thread) is actually started,
because the LinkedBlockingQueue practically accepts all queued up
tasks in ThreadPoolExecutor.execute():

int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }

---> workQueue.offer() returns true here for any practical case:

        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);

I think using a different queue wouldn't help, since we don't want to
reject any tasks but the condition:

else if (workerCountOf(recheck) == 0)
                addWorker(null, false);

could be loosened to also add workers if the number is smaller than
maximumPoolSize.

Would that work?

Thanks,
Felix

From dcholmes at optusnet.com.au  Tue Jun  5 18:20:01 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 6 Jun 2007 08:20:01 +1000
Subject: [concurrency-interest] ThreadPoolExecutor: maximumPoolSize
	nothonored for practically unlimited queues
In-Reply-To: <6275f96c0706051345o299cfbbbk1d39b2ab317a9cea@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEFBHHAA.dcholmes@optusnet.com.au>

Felix,

The maximum size only comes into play if your BlockingQueue gets full. With
an unbounded queue it never comes into play. This is working as designed.

You need to increase your core size. In Java 6 you can set the idle timeout
for core threads so that the actual number of threads will still rise and
fall. But note that when under core size, submission of a task always causes
thread creation. Again this is working as designed.

The basic threading strategy is based around expected service times and
throughput requirements. If you characterise your task workload, identify
the arrival rate and determine what your throughput/response-time
requirements are then you can determine the necessary number of threads to
handle your steady-state workload. The queue is then used to buffer requests
when you get transient overloads. By bounding the queue you set a second
overload threshhold at which new threads are brought in (up to max) to try
and service the overload and get the system back to the expected
steady-state.

The above scheme works generally well for well behaved workloads, but if the
load varies considerably (either very high or very low extremes) then it can
be less than ideal.

There have been a number of discussions in the mailing list about
alternative strategies and potential modifications to enable those
strategies. A search of the archives should reveal those.

Hope this helps.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Felix
> Berger
> Sent: Wednesday, 6 June 2007 6:46 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] ThreadPoolExecutor: maximumPoolSize
> nothonored for practically unlimited queues
>
>
> Hi,
>
> we're creating an ThreadPoolExecutor with a fixed maximum number of
> threads like this:
>
>  ThreadPoolExecutor tpe =  new ThreadPoolExecutor(1, size,
>                 5L, TimeUnit.SECONDS,
>                 new LinkedBlockingQueue<Runnable>(),
>                 daemonThreadFactory(name));
>         tpe.allowCoreThreadTimeOut(true);
>
> where size is the maximum number of threads executing the tasks.
>
> We noticed that only one thread (the core thread) is actually started,
> because the LinkedBlockingQueue practically accepts all queued up
> tasks in ThreadPoolExecutor.execute():
>
> int c = ctl.get();
>         if (workerCountOf(c) < corePoolSize) {
>             if (addWorker(command, true))
>                 return;
>             c = ctl.get();
>         }
>
> ---> workQueue.offer() returns true here for any practical case:
>
>         if (isRunning(c) && workQueue.offer(command)) {
>             int recheck = ctl.get();
>             if (! isRunning(recheck) && remove(command))
>                 reject(command);
>             else if (workerCountOf(recheck) == 0)
>                 addWorker(null, false);
>         }
>         else if (!addWorker(command, false))
>             reject(command);
>
> I think using a different queue wouldn't help, since we don't want to
> reject any tasks but the condition:
>
> else if (workerCountOf(recheck) == 0)
>                 addWorker(null, false);
>
> could be loosened to also add workers if the number is smaller than
> maximumPoolSize.
>
> Would that work?
>
> Thanks,
> Felix
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From paul at kungfoocoder.org  Wed Jun  6 07:12:34 2007
From: paul at kungfoocoder.org (Paul Wagland)
Date: Wed, 6 Jun 2007 13:12:34 +0200
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
Message-ID: <1EB58F1A-04C4-4804-978A-FFBD2F3B9BE7@kungfoocoder.org>

Hi all,

I have found what I believe to be a bug in java.math.BigDecimal, and  
I would be interested in confirmation :-)

The bug was introduced in JDK 1.5, and can till be seen in jdk-6u2-ea- 
src-b02-jrl-12_apr_2007.jar.

The issue is the following (excerpted) code:

     public long longValueExact() {
...
         if (num.precision() >= 19) {    // need to check carefully
             if (LONGMIN == null) {      // initialize constants
                 LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
                 LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
             }
             if ((num.intVal.compareTo(LONGMIN) < 0) ||
                 (num.intVal.compareTo(LONGMAX) > 0))
                 throw new java.lang.ArithmeticException("Overflow");
         }
         return num.intVal.longValue();
     }
     // These constants are only initialized if needed
     /** BigInteger equal to Long.MIN_VALUE. */
     private static BigInteger LONGMIN = null;
     /** BigInteger equal to Long.MAX_VALUE. */
     private static BigInteger LONGMAX = null;



Now I see two problems with this code:
a) every single thread could (potentially) create and assign LONGMIN  
and LONGMAX as there are no "happens-before"s to ensure that the  
statics are propagated across threads.
b) It is possible to get a NPE if LONGMIN is null, then both LONGMIN  
and LONGMAX are instantiated, however in the case of competing  
threads then it is possible for thread 2 to see LONGMIN as non-null,  
and LONGMAX as null, resulting in a NPE in BigInteger#compareTo 
(BigInteger)

Now, b) I am pretty sure of, but I would like to confirm that a) is  
also a 'real' problem.

Cheers,
Paul


From mike.quilleash at subexazure.com  Wed Jun  6 07:46:27 2007
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Wed, 6 Jun 2007 07:46:27 -0400
Subject: [concurrency-interest] Potential concurrency problem in
 java.math.BigDecimal?
In-Reply-To: <1EB58F1A-04C4-4804-978A-FFBD2F3B9BE7@kungfoocoder.org>
Message-ID: <DAE04D9F6FD21448A220918A522FB60E0723FD19@MI8NYCMAIL15.Mi8.com>

I don't think a) is a problem because LONGMIN and LONGMAX are always
going to calculate to the same value regardless which thread executes
it.  The worst case is that *every* thread that executes this method
would do this calculation as it does not "see" the already calculated
value by another thread.  However this is unlikely to happen in
practice, eventually the values will propogate across.  I believe the
String.hashCode() implementation uses a similar lazy-calculate method.

Re b) I think this is an issue.  If the check was  LONGMIN == null ||
LONGMAX == null then it might be fine but I'm not 100% sure on this.

Cheers.

Mike.

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Paul
Wagland
Sent: 06 June 2007 12:13
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Potential concurrency problem in
java.math.BigDecimal?

Hi all,

I have found what I believe to be a bug in java.math.BigDecimal, and I
would be interested in confirmation :-)

The bug was introduced in JDK 1.5, and can till be seen in jdk-6u2-ea-
src-b02-jrl-12_apr_2007.jar.

The issue is the following (excerpted) code:

     public long longValueExact() {
...
         if (num.precision() >= 19) {    // need to check carefully
             if (LONGMIN == null) {      // initialize constants
                 LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
                 LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
             }
             if ((num.intVal.compareTo(LONGMIN) < 0) ||
                 (num.intVal.compareTo(LONGMAX) > 0))
                 throw new java.lang.ArithmeticException("Overflow");
         }
         return num.intVal.longValue();
     }
     // These constants are only initialized if needed
     /** BigInteger equal to Long.MIN_VALUE. */
     private static BigInteger LONGMIN = null;
     /** BigInteger equal to Long.MAX_VALUE. */
     private static BigInteger LONGMAX = null;



Now I see two problems with this code:
a) every single thread could (potentially) create and assign LONGMIN and
LONGMAX as there are no "happens-before"s to ensure that the statics are
propagated across threads.
b) It is possible to get a NPE if LONGMIN is null, then both LONGMIN and
LONGMAX are instantiated, however in the case of competing threads then
it is possible for thread 2 to see LONGMIN as non-null, and LONGMAX as
null, resulting in a NPE in BigInteger#compareTo
(BigInteger)

Now, b) I am pretty sure of, but I would like to confirm that a) is also
a 'real' problem.

Cheers,
Paul

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From paul at kungfoocoder.org  Wed Jun  6 10:00:10 2007
From: paul at kungfoocoder.org (Paul Wagland)
Date: Wed, 6 Jun 2007 16:00:10 +0200
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E0723FD19@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E0723FD19@MI8NYCMAIL15.Mi8.com>
Message-ID: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>

Actually, I think that a) is more of a problem than it is for String,  
since String only propagates an integer, it is possible for  
BigDecimal to propagate a partially instantiated BigInteger, once  
again since there is no happens-before edge between the creation of  
the object and the usage of it in another thread. Now, in practice,  
that has no effect, however my question is more of a theoretical is  
this theoretically wrong, or was I missing some happens-before edge  
that would prevent it.

Cheers,
Paul

On 6 Jun 2007, at 13:46, Mike Quilleash wrote:

> I don't think a) is a problem because LONGMIN and LONGMAX are always
> going to calculate to the same value regardless which thread executes
> it.  The worst case is that *every* thread that executes this method
> would do this calculation as it does not "see" the already calculated
> value by another thread.  However this is unlikely to happen in
> practice, eventually the values will propogate across.  I believe the
> String.hashCode() implementation uses a similar lazy-calculate method.
>
> Re b) I think this is an issue.  If the check was  LONGMIN == null ||
> LONGMAX == null then it might be fine but I'm not 100% sure on this.
>
> Cheers.
>
> Mike.
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Paul
> Wagland
> Sent: 06 June 2007 12:13
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Potential concurrency problem in
> java.math.BigDecimal?
>
> Hi all,
>
> I have found what I believe to be a bug in java.math.BigDecimal, and I
> would be interested in confirmation :-)
>
> The bug was introduced in JDK 1.5, and can till be seen in jdk-6u2-ea-
> src-b02-jrl-12_apr_2007.jar.
>
> The issue is the following (excerpted) code:
>
>      public long longValueExact() {
> ...
>          if (num.precision() >= 19) {    // need to check carefully
>              if (LONGMIN == null) {      // initialize constants
>                  LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
>                  LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
>              }
>              if ((num.intVal.compareTo(LONGMIN) < 0) ||
>                  (num.intVal.compareTo(LONGMAX) > 0))
>                  throw new java.lang.ArithmeticException("Overflow");
>          }
>          return num.intVal.longValue();
>      }
>      // These constants are only initialized if needed
>      /** BigInteger equal to Long.MIN_VALUE. */
>      private static BigInteger LONGMIN = null;
>      /** BigInteger equal to Long.MAX_VALUE. */
>      private static BigInteger LONGMAX = null;
>
>
>
> Now I see two problems with this code:
> a) every single thread could (potentially) create and assign  
> LONGMIN and
> LONGMAX as there are no "happens-before"s to ensure that the  
> statics are
> propagated across threads.
> b) It is possible to get a NPE if LONGMIN is null, then both  
> LONGMIN and
> LONGMAX are instantiated, however in the case of competing threads  
> then
> it is possible for thread 2 to see LONGMIN as non-null, and LONGMAX as
> null, resulting in a NPE in BigInteger#compareTo
> (BigInteger)
>
> Now, b) I am pretty sure of, but I would like to confirm that a) is  
> also
> a 'real' problem.
>
> Cheers,
> Paul
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  This e-mail is bound by the terms and conditions described at  
> http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



From mike.quilleash at subexazure.com  Wed Jun  6 10:43:53 2007
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Wed, 6 Jun 2007 10:43:53 -0400
Subject: [concurrency-interest] Potential concurrency problem in
 java.math.BigDecimal?
In-Reply-To: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
Message-ID: <DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>

That's a fair point.  I assumed BigInteger and BigDecimal were immutable
(final fields) as it is written without mutators but this doesn't appear
to be the case.  Probably something to do with the Serialising code
needing to write to the internal fields.

-----Original Message-----
From: Paul Wagland [mailto:paul at kungfoocoder.org] 
Sent: 06 June 2007 15:00
To: Mike Quilleash 
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Potential concurrency problem in
java.math.BigDecimal?

Actually, I think that a) is more of a problem than it is for String,
since String only propagates an integer, it is possible for BigDecimal
to propagate a partially instantiated BigInteger, once again since there
is no happens-before edge between the creation of the object and the
usage of it in another thread. Now, in practice, that has no effect,
however my question is more of a theoretical is this theoretically
wrong, or was I missing some happens-before edge that would prevent it.

Cheers,
Paul

On 6 Jun 2007, at 13:46, Mike Quilleash wrote:

> I don't think a) is a problem because LONGMIN and LONGMAX are always 
> going to calculate to the same value regardless which thread executes 
> it.  The worst case is that *every* thread that executes this method 
> would do this calculation as it does not "see" the already calculated 
> value by another thread.  However this is unlikely to happen in 
> practice, eventually the values will propogate across.  I believe the
> String.hashCode() implementation uses a similar lazy-calculate method.
>
> Re b) I think this is an issue.  If the check was  LONGMIN == null || 
> LONGMAX == null then it might be fine but I'm not 100% sure on this.
>
> Cheers.
>
> Mike.
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Paul 
> Wagland
> Sent: 06 June 2007 12:13
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Potential concurrency problem in 
> java.math.BigDecimal?
>
> Hi all,
>
> I have found what I believe to be a bug in java.math.BigDecimal, and I

> would be interested in confirmation :-)
>
> The bug was introduced in JDK 1.5, and can till be seen in jdk-6u2-ea-

> src-b02-jrl-12_apr_2007.jar.
>
> The issue is the following (excerpted) code:
>
>      public long longValueExact() {
> ...
>          if (num.precision() >= 19) {    // need to check carefully
>              if (LONGMIN == null) {      // initialize constants
>                  LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
>                  LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
>              }
>              if ((num.intVal.compareTo(LONGMIN) < 0) ||
>                  (num.intVal.compareTo(LONGMAX) > 0))
>                  throw new java.lang.ArithmeticException("Overflow");
>          }
>          return num.intVal.longValue();
>      }
>      // These constants are only initialized if needed
>      /** BigInteger equal to Long.MIN_VALUE. */
>      private static BigInteger LONGMIN = null;
>      /** BigInteger equal to Long.MAX_VALUE. */
>      private static BigInteger LONGMAX = null;
>
>
>
> Now I see two problems with this code:
> a) every single thread could (potentially) create and assign LONGMIN 
> and LONGMAX as there are no "happens-before"s to ensure that the 
> statics are propagated across threads.
> b) It is possible to get a NPE if LONGMIN is null, then both LONGMIN 
> and LONGMAX are instantiated, however in the case of competing threads

> then it is possible for thread 2 to see LONGMIN as non-null, and 
> LONGMAX as null, resulting in a NPE in BigInteger#compareTo
> (BigInteger)
>
> Now, b) I am pretty sure of, but I would like to confirm that a) is 
> also a 'real' problem.
>
> Cheers,
> Paul
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  This e-mail is bound by the terms and conditions described at 
> http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From bflat1 at gmx.net  Wed Jun  6 11:15:24 2007
From: bflat1 at gmx.net (Felix Berger)
Date: Wed, 6 Jun 2007 11:15:24 -0400
Subject: [concurrency-interest] ThreadPoolExecutor: maximumPoolSize
	nothonored for practically unlimited queues
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEFBHHAA.dcholmes@optusnet.com.au>
References: <6275f96c0706051345o299cfbbbk1d39b2ab317a9cea@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEFBHHAA.dcholmes@optusnet.com.au>
Message-ID: <6275f96c0706060815l43ac5c44qa0e2300a3aaf24cc@mail.gmail.com>

Thanks David,

since we have tpe.allowCoreThreadTimeOut(true) enabled and core
threads are only created on demand we can just set corePoolSize to the
same value as maximumPoolSize and should be fine.

Thanks,
Felix

From matthias at mernst.org  Wed Jun  6 11:32:46 2007
From: matthias at mernst.org (Matthias Ernst)
Date: Wed, 6 Jun 2007 17:32:46 +0200
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
Message-ID: <22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>

>     // These constants are only initialized if needed
>    /** BigInteger equal to Long.MIN_VALUE. */
>    private static BigInteger LONGMIN = null;
>    /** BigInteger equal to Long.MAX_VALUE. */
>    private static BigInteger LONGMAX = null;

Wow, someone was REALLY concerned with performance here...

I think you're right with your concerns. IMHO, It should be fixed to
private static final fields. I would like to see the difference in
performance.

On 6/6/07, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> Probably something to do with the Serialising code
> needing to write to the internal fields.

No, they're static fields.

Matthias

From josh at bloch.us  Wed Jun  6 13:35:39 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 6 Jun 2007 10:35:39 -0700
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
Message-ID: <b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>

This absolutely is a problem!  It could result in an NPE.  It isn't even
subtle.  One thread could initialize LONGMIN, and then another thread could
attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it reeks of
premature optimization.  Why on earth would they initialize those fields
lazily?  LONGMIN and LONGMAX should be private static finals.  Also they
should be named LONG_MIN and LONG_MAX, but I digress.

        Josh


On 6/6/07, Matthias Ernst <matthias at mernst.org> wrote:
>
> >     // These constants are only initialized if needed
> >    /** BigInteger equal to Long.MIN_VALUE. */
> >    private static BigInteger LONGMIN = null;
> >    /** BigInteger equal to Long.MAX_VALUE. */
> >    private static BigInteger LONGMAX = null;
>
> Wow, someone was REALLY concerned with performance here...
>
> I think you're right with your concerns. IMHO, It should be fixed to
> private static final fields. I would like to see the difference in
> performance.
>
> On 6/6/07, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> > Probably something to do with the Serialising code
> > needing to write to the internal fields.
>
> No, they're static fields.
>
> Matthias
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070606/be08ce5f/attachment.html 

From hanson.char at gmail.com  Wed Jun  6 14:53:18 2007
From: hanson.char at gmail.com (Hanson Char)
Date: Wed, 6 Jun 2007 11:53:18 -0700
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
Message-ID: <ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>

This is worrying, as there are lots of code relying on the "immutability" of
BigInteger and BigDecimal, and therefore there is no attempt to provide
thread-safety on the use of these objects.

One idea to get around the problem, at least temporarily for new code, is to
provide and use our own subclass of BigDecimal and BigInteger that are
truely immutable, and avoid using the jdk's ones altogether.  Or do these
beasts already exist somewhere in some opensource projects ?

Hanson Char

On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
>
> This absolutely is a problem!  It could result in an NPE.  It isn't even
> subtle.  One thread could initialize LONGMIN, and then another thread could
> attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it reeks of
> premature optimization.  Why on earth would they initialize those fields
> lazily?  LONGMIN and LONGMAX should be private static finals.  Also they
> should be named LONG_MIN and LONG_MAX, but I digress.
>
>         Josh
>
>
> On 6/6/07, Matthias Ernst <matthias at mernst.org> wrote:
> >
> > >     // These constants are only initialized if needed
> > >    /** BigInteger equal to Long.MIN_VALUE . */
> > >    private static BigInteger LONGMIN = null;
> > >    /** BigInteger equal to Long.MAX_VALUE. */
> > >    private static BigInteger LONGMAX = null;
> >
> > Wow, someone was REALLY concerned with performance here...
> >
> > I think you're right with your concerns. IMHO, It should be fixed to
> > private static final fields. I would like to see the difference in
> > performance.
> >
> > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > > Probably something to do with the Serialising code
> > > needing to write to the internal fields.
> >
> > No, they're static fields.
> >
> > Matthias
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070606/8575c879/attachment.html 

From chastang at ucar.edu  Wed Jun  6 15:40:15 2007
From: chastang at ucar.edu (Julien Chastang)
Date: Wed, 6 Jun 2007 13:40:15 -0600
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
Message-ID: <61EA1095-D54C-4968-A9B9-0F419640FF64@ucar.edu>

As a temporary fix, what about wrapping it with ThreadLocal --  
performance considerations notwithstanding.

-Julien

On Jun 6, 2007, at 12:53 PM, Hanson Char wrote:

> This is worrying, as there are lots of code relying on the  
> "immutability" of BigInteger and BigDecimal, and therefore there is  
> no attempt to provide thread-safety on the use of these objects.
>
> One idea to get around the problem, at least temporarily for new  
> code, is to provide and use our own subclass of BigDecimal and  
> BigInteger that are truely immutable, and avoid using the jdk's  
> ones altogether.  Or do these beasts already exist somewhere in  
> some opensource projects ?
>
> Hanson Char
>
> On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
> This absolutely is a problem!  It could result in an NPE.  It isn't  
> even subtle.  One thread could initialize LONGMIN, and then another  
> thread could attempt to use LONGMIN and LONGMAX, throwing an NPE.   
> Moreover it reeks of premature optimization.  Why on earth would  
> they initialize those fields lazily?  LONGMIN and LONGMAX should be  
> private static finals.  Also they should be named LONG_MIN and  
> LONG_MAX, but I digress.
>
>         Josh
>
>
> On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> >     // These constants are only initialized if needed
> >    /** BigInteger equal to Long.MIN_VALUE . */
> >    private static BigInteger LONGMIN = null;
> >    /** BigInteger equal to Long.MAX_VALUE. */
> >    private static BigInteger LONGMAX = null;
>
> Wow, someone was REALLY concerned with performance here...
>
> I think you're right with your concerns. IMHO, It should be fixed to
> private static final fields. I would like to see the difference in
> performance.
>
> On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > Probably something to do with the Serialising code
> > needing to write to the internal fields.
>
> No, they're static fields.
>
> Matthias
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070606/fb5e9b75/attachment.html 

From josh at bloch.us  Wed Jun  6 16:43:01 2007
From: josh at bloch.us (Joshua Bloch)
Date: Wed, 6 Jun 2007 13:43:01 -0700
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
Message-ID: <b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>

Actually I wouldn't worry to hard about it.  It's in the new
(fixed-precision) stuff, which is not so heavily used, and (like many
concurrency bugs), the odds of seeing it happen are incredibly low.  We
should just file a bug and get it fixed in the next release.

          Josh


On 6/6/07, Hanson Char <hanson.char at gmail.com> wrote:
>
> This is worrying, as there are lots of code relying on the "immutability"
> of BigInteger and BigDecimal, and therefore there is no attempt to provide
> thread-safety on the use of these objects.
>
> One idea to get around the problem, at least temporarily for new code, is
> to provide and use our own subclass of BigDecimal and BigInteger that are
> truely immutable, and avoid using the jdk's ones altogether.  Or do these
> beasts already exist somewhere in some opensource projects ?
>
> Hanson Char
>
>  On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
>
> >  This absolutely is a problem!  It could result in an NPE.  It isn't
> > even subtle.  One thread could initialize LONGMIN, and then another thread
> > could attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it
> > reeks of premature optimization.  Why on earth would they initialize those
> > fields lazily?  LONGMIN and LONGMAX should be private static finals.  Also
> > they should be named LONG_MIN and LONG_MAX, but I digress.
> >
> >         Josh
> >
> >
> >  On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> > >
> > > >     // These constants are only initialized if needed
> > > >    /** BigInteger equal to Long.MIN_VALUE . */
> > > >    private static BigInteger LONGMIN = null;
> > > >    /** BigInteger equal to Long.MAX_VALUE. */
> > > >    private static BigInteger LONGMAX = null;
> > >
> > > Wow, someone was REALLY concerned with performance here...
> > >
> > > I think you're right with your concerns. IMHO, It should be fixed to
> > > private static final fields. I would like to see the difference in
> > > performance.
> > >
> > > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > > > Probably something to do with the Serialising code
> > > > needing to write to the internal fields.
> > >
> > > No, they're static fields.
> > >
> > > Matthias
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070606/320816ab/attachment-0001.html 

From peter.kovacs.1.0rc at gmail.com  Thu Jun  7 06:01:51 2007
From: peter.kovacs.1.0rc at gmail.com (Peter Kovacs)
Date: Thu, 7 Jun 2007 12:01:51 +0200
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
	<b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
Message-ID: <b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>

On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
> Actually I wouldn't worry to hard about it.  It's in the new
> (fixed-precision) stuff, which is not so heavily used, and (like many
> concurrency bugs), the odds of seeing it happen are incredibly low.  We

I am always startled to hear this kind of arguments. Without having a
real theoretical background to deal with this kind of problem, I find
it extremely hard to say anything about the probability of seeing a
specific potential concurrency problem actually manifest itself -- due
to the large number of (often unforeseeable) factors influencing the
outcome.

We have a rough-and-dirty (actually pretty dilettante), not
"air-tight" solution to a specific concurrency problem. One of my
colleagues favorite argument to defend the solution is to say that the
probability of it not working is less than that of guessing all the
lottery numbers right. While there is clear and simple conceptual
model to calculate the odds for winning the lottery, there is no such
model for most of the real-life concurrency problems. Possible
factors: kind of input data, kind of the system, degree of
concurrency, load of the system... And the worst is that we cannot
even be sure we can think of all the possible factors at work. Though
I seem to remember having heard something of the concept of confidence
intervals at my statistics course in the university, I have no idea if
it is applicable here.

This is off-topic, but I would be glad to hear comments on this from
the more knowledgeable.

Thanks
Peter

> should just file a bug and get it fixed in the next release.
>
>           Josh
>
>
>
> On 6/6/07, Hanson Char <hanson.char at gmail.com> wrote:
> > This is worrying, as there are lots of code relying on the "immutability"
> of BigInteger and BigDecimal, and therefore there is no attempt to provide
> thread-safety on the use of these objects.
> >
> > One idea to get around the problem, at least temporarily for new code, is
> to provide and use our own subclass of BigDecimal and BigInteger that are
> truely immutable, and avoid using the jdk's ones altogether.  Or do these
> beasts already exist somewhere in some opensource projects ?
> >
> > Hanson Char
> >
> >
> >
> > On 6/6/07, Joshua Bloch < josh at bloch.us> wrote:
> > >
> > >
> > > This absolutely is a problem!  It could result in an NPE.  It isn't even
> subtle.  One thread could initialize LONGMIN, and then another thread could
> attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it reeks of
> premature optimization.  Why on earth would they initialize those fields
> lazily?  LONGMIN and LONGMAX should be private static finals.  Also they
> should be named LONG_MIN and LONG_MAX, but I digress.
> > >
> > >         Josh
> > >
> > >
> > >
> > > On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> > > > >     // These constants are only initialized if needed
> > > > >    /** BigInteger equal to Long.MIN_VALUE . */
> > > > >    private static BigInteger LONGMIN = null;
> > > > >    /** BigInteger equal to Long.MAX_VALUE. */
> > > > >    private static BigInteger LONGMAX = null;
> > > >
> > > > Wow, someone was REALLY concerned with performance here...
> > > >
> > > > I think you're right with your concerns. IMHO, It should be fixed to
> > > > private static final fields. I would like to see the difference in
> > > > performance.
> > > >
> > > > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > > > > Probably something to do with the Serialising code
> > > > > needing to write to the internal fields.
> > > >
> > > > No, they're static fields.
> > > >
> > > > Matthias
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> >
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From sberlin at gmail.com  Thu Jun  7 11:10:41 2007
From: sberlin at gmail.com (Sam Berlin)
Date: Thu, 7 Jun 2007 11:10:41 -0400
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
	<b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
	<b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
Message-ID: <19196d860706070810p57bc2e22n655a29cbd2080e58@mail.gmail.com>

I would wager that the chances of a concurrency problem manifesting
itself increase in proportion to the number of different
architectures, workloads, and types of the computers they run on.  For
enterprise systems, generally the only difference is the workload, as
the architecture and other factors tend to remain the same.  For
consumer systems, nearly anything can be different, and the workloads
different not only in the active program and other known programs, but
in the number and range of executables being run.

Based on this completely unscientific hypothesis, I would believe that
concurrency bugs are more likely to occur in widespread
consumer-oriented programs.  (That is, programs shipped to consumers
and run on their machines.)

Sam

On 6/7/07, Peter Kovacs <peter.kovacs.1.0rc at gmail.com> wrote:
> On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
> > Actually I wouldn't worry to hard about it.  It's in the new
> > (fixed-precision) stuff, which is not so heavily used, and (like many
> > concurrency bugs), the odds of seeing it happen are incredibly low.  We
>
> I am always startled to hear this kind of arguments. Without having a
> real theoretical background to deal with this kind of problem, I find
> it extremely hard to say anything about the probability of seeing a
> specific potential concurrency problem actually manifest itself -- due
> to the large number of (often unforeseeable) factors influencing the
> outcome.
>
> We have a rough-and-dirty (actually pretty dilettante), not
> "air-tight" solution to a specific concurrency problem. One of my
> colleagues favorite argument to defend the solution is to say that the
> probability of it not working is less than that of guessing all the
> lottery numbers right. While there is clear and simple conceptual
> model to calculate the odds for winning the lottery, there is no such
> model for most of the real-life concurrency problems. Possible
> factors: kind of input data, kind of the system, degree of
> concurrency, load of the system... And the worst is that we cannot
> even be sure we can think of all the possible factors at work. Though
> I seem to remember having heard something of the concept of confidence
> intervals at my statistics course in the university, I have no idea if
> it is applicable here.
>
> This is off-topic, but I would be glad to hear comments on this from
> the more knowledgeable.
>
> Thanks
> Peter
>
> > should just file a bug and get it fixed in the next release.
> >
> >           Josh
> >
> >
> >
> > On 6/6/07, Hanson Char <hanson.char at gmail.com> wrote:
> > > This is worrying, as there are lots of code relying on the "immutability"
> > of BigInteger and BigDecimal, and therefore there is no attempt to provide
> > thread-safety on the use of these objects.
> > >
> > > One idea to get around the problem, at least temporarily for new code, is
> > to provide and use our own subclass of BigDecimal and BigInteger that are
> > truely immutable, and avoid using the jdk's ones altogether.  Or do these
> > beasts already exist somewhere in some opensource projects ?
> > >
> > > Hanson Char
> > >
> > >
> > >
> > > On 6/6/07, Joshua Bloch < josh at bloch.us> wrote:
> > > >
> > > >
> > > > This absolutely is a problem!  It could result in an NPE.  It isn't even
> > subtle.  One thread could initialize LONGMIN, and then another thread could
> > attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it reeks of
> > premature optimization.  Why on earth would they initialize those fields
> > lazily?  LONGMIN and LONGMAX should be private static finals.  Also they
> > should be named LONG_MIN and LONG_MAX, but I digress.
> > > >
> > > >         Josh
> > > >
> > > >
> > > >
> > > > On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> > > > > >     // These constants are only initialized if needed
> > > > > >    /** BigInteger equal to Long.MIN_VALUE . */
> > > > > >    private static BigInteger LONGMIN = null;
> > > > > >    /** BigInteger equal to Long.MAX_VALUE. */
> > > > > >    private static BigInteger LONGMAX = null;
> > > > >
> > > > > Wow, someone was REALLY concerned with performance here...
> > > > >
> > > > > I think you're right with your concerns. IMHO, It should be fixed to
> > > > > private static final fields. I would like to see the difference in
> > > > > performance.
> > > > >
> > > > > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > > > > > Probably something to do with the Serialising code
> > > > > > needing to write to the internal fields.
> > > > >
> > > > > No, they're static fields.
> > > > >
> > > > > Matthias
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > >
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > >
> > >
> > >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From Darron_Shaffer at stercomm.com  Thu Jun  7 11:45:57 2007
From: Darron_Shaffer at stercomm.com (Shaffer, Darron)
Date: Thu, 7 Jun 2007 11:45:57 -0400
Subject: [concurrency-interest] Potential concurrency problem
	injava.math.BigDecimal?
In-Reply-To: <b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
Message-ID: <303629700276DF4D9ED7D011221B8FAA0B15BEB8@scidubmsg03.sci.local>

"Around here, one in a million happens tomorrow afternoon".

:-)

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Peter
Kovacs
Sent: Thursday, June 07, 2007 5:02 AM
To: Joshua Bloch
Cc: Hanson Char; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Potential concurrency problem
injava.math.BigDecimal?

On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
> Actually I wouldn't worry to hard about it.  It's in the new
> (fixed-precision) stuff, which is not so heavily used, and (like many
> concurrency bugs), the odds of seeing it happen are incredibly low.
We

I am always startled to hear this kind of arguments. Without having a
real theoretical background to deal with this kind of problem, I find
it extremely hard to say anything about the probability of seeing a
specific potential concurrency problem actually manifest itself -- due
to the large number of (often unforeseeable) factors influencing the
outcome.

We have a rough-and-dirty (actually pretty dilettante), not
"air-tight" solution to a specific concurrency problem. One of my
colleagues favorite argument to defend the solution is to say that the
probability of it not working is less than that of guessing all the
lottery numbers right. While there is clear and simple conceptual
model to calculate the odds for winning the lottery, there is no such
model for most of the real-life concurrency problems. Possible
factors: kind of input data, kind of the system, degree of
concurrency, load of the system... And the worst is that we cannot
even be sure we can think of all the possible factors at work. Though
I seem to remember having heard something of the concept of confidence
intervals at my statistics course in the university, I have no idea if
it is applicable here.

This is off-topic, but I would be glad to hear comments on this from
the more knowledgeable.

Thanks
Peter

> should just file a bug and get it fixed in the next release.
>
>           Josh
>
>
>
> On 6/6/07, Hanson Char <hanson.char at gmail.com> wrote:
> > This is worrying, as there are lots of code relying on the
"immutability"
> of BigInteger and BigDecimal, and therefore there is no attempt to
provide
> thread-safety on the use of these objects.
> >
> > One idea to get around the problem, at least temporarily for new
code, is
> to provide and use our own subclass of BigDecimal and BigInteger that
are
> truely immutable, and avoid using the jdk's ones altogether.  Or do
these
> beasts already exist somewhere in some opensource projects ?
> >
> > Hanson Char
> >
> >
> >
> > On 6/6/07, Joshua Bloch < josh at bloch.us> wrote:
> > >
> > >
> > > This absolutely is a problem!  It could result in an NPE.  It
isn't even
> subtle.  One thread could initialize LONGMIN, and then another thread
could
> attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it
reeks of
> premature optimization.  Why on earth would they initialize those
fields
> lazily?  LONGMIN and LONGMAX should be private static finals.  Also
they
> should be named LONG_MIN and LONG_MAX, but I digress.
> > >
> > >         Josh
> > >
> > >
> > >
> > > On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> > > > >     // These constants are only initialized if needed
> > > > >    /** BigInteger equal to Long.MIN_VALUE . */
> > > > >    private static BigInteger LONGMIN = null;
> > > > >    /** BigInteger equal to Long.MAX_VALUE. */
> > > > >    private static BigInteger LONGMAX = null;
> > > >
> > > > Wow, someone was REALLY concerned with performance here...
> > > >
> > > > I think you're right with your concerns. IMHO, It should be
fixed to
> > > > private static final fields. I would like to see the difference
in
> > > > performance.
> > > >
> > > > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com>
wrote:
> > > > > Probably something to do with the Serialising code
> > > > > needing to write to the internal fields.
> > > >
> > > > No, they're static fields.
> > > >
> > > > Matthias
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> >
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Thu Jun  7 13:12:26 2007
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 7 Jun 2007 10:12:26 -0700
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
	<b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
	<b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
Message-ID: <31f2a7bd0706071012q6a10d761o53b333845a560dea@mail.gmail.com>

On 6/7/07, Peter Kovacs <peter.kovacs.1.0rc at gmail.com> wrote:
>
> I am always startled to hear this kind of arguments.

I agree with you that bravado does not substitute for clean design and
robust implementation, but sometimes that's all we're left with.
Sometimes the cost of the patch or the risk that it will be bungled
are higher than the risk of failure (until an official patch is
released).  That's Josh's opinion.  But who's to know?

Around here, if there's disagreement over such matters, we back it up
with a small wager.

--Joe

From josh at bloch.us  Thu Jun  7 13:16:52 2007
From: josh at bloch.us (Joshua Bloch)
Date: Thu, 7 Jun 2007 10:16:52 -0700
Subject: [concurrency-interest] Potential concurrency problem in
	java.math.BigDecimal?
In-Reply-To: <b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
	<b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
	<b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
Message-ID: <b097ac510706071016m79f61811x8647a57bc23efc6b@mail.gmail.com>

Peter,

Let me make myself clear.  UNDER NO CIRCUMSTANCES, EVER, should this sort of
argument be made to justify including broken concurrent code.  It has to be
right, and the only way to make it hard is to do ALL 3 of these things:

(1) Design it as carefully as you can  think hard - convince yourself it's
correct.
(2) Code review - convince someone else that it's correct, ideally a
concurrency expert
(3) Test - test, test, and more test; it takes huge amounts of time to shake
out concurrency bug

As Doug is fond of saying, it's a 3-legged stool; leave out any of these
things and you're setting yourself up for a fall.

It's also worth using all of the static analysis tools that you have at your
disposal.  (Findbugs, etc.)

That said, the world is absolutely rife with concurrency bugs.  The JDK is
chock-full of race conditions.  We all have only a finite amount of time to
fix bugs, so we have to prioritize.  Is this something that's likely to
cause a problem?  Is it likely to be a severe problem?  If so, it's a P1 bug
and a workaround is demanded until it's fixed.  If it's extremely unlikely
to occur and/or the consequences are not so severe, then it can be fixed
later and/or no workaround is required in the interim.  This feels to me
like a P3 on a 5 scale.  That's all I meant to say.

         Josh


On 6/7/07, Peter Kovacs <peter.kovacs.1.0rc at gmail.com> wrote:
>
> On 6/6/07, Joshua Bloch <josh at bloch.us> wrote:
> > Actually I wouldn't worry to hard about it.  It's in the new
> > (fixed-precision) stuff, which is not so heavily used, and (like many
> > concurrency bugs), the odds of seeing it happen are incredibly low.  We
>
> I am always startled to hear this kind of arguments. Without having a
> real theoretical background to deal with this kind of problem, I find
> it extremely hard to say anything about the probability of seeing a
> specific potential concurrency problem actually manifest itself -- due
> to the large number of (often unforeseeable) factors influencing the
> outcome.
>
> We have a rough-and-dirty (actually pretty dilettante), not
> "air-tight" solution to a specific concurrency problem. One of my
> colleagues favorite argument to defend the solution is to say that the
> probability of it not working is less than that of guessing all the
> lottery numbers right. While there is clear and simple conceptual
> model to calculate the odds for winning the lottery, there is no such
> model for most of the real-life concurrency problems. Possible
> factors: kind of input data, kind of the system, degree of
> concurrency, load of the system... And the worst is that we cannot
> even be sure we can think of all the possible factors at work. Though
> I seem to remember having heard something of the concept of confidence
> intervals at my statistics course in the university, I have no idea if
> it is applicable here.
>
> This is off-topic, but I would be glad to hear comments on this from
> the more knowledgeable.
>
> Thanks
> Peter
>
> > should just file a bug and get it fixed in the next release.
> >
> >           Josh
> >
> >
> >
> > On 6/6/07, Hanson Char <hanson.char at gmail.com> wrote:
> > > This is worrying, as there are lots of code relying on the
> "immutability"
> > of BigInteger and BigDecimal, and therefore there is no attempt to
> provide
> > thread-safety on the use of these objects.
> > >
> > > One idea to get around the problem, at least temporarily for new code,
> is
> > to provide and use our own subclass of BigDecimal and BigInteger that
> are
> > truely immutable, and avoid using the jdk's ones altogether.  Or do
> these
> > beasts already exist somewhere in some opensource projects ?
> > >
> > > Hanson Char
> > >
> > >
> > >
> > > On 6/6/07, Joshua Bloch < josh at bloch.us> wrote:
> > > >
> > > >
> > > > This absolutely is a problem!  It could result in an NPE.  It isn't
> even
> > subtle.  One thread could initialize LONGMIN, and then another thread
> could
> > attempt to use LONGMIN and LONGMAX, throwing an NPE.  Moreover it reeks
> of
> > premature optimization.  Why on earth would they initialize those fields
> > lazily?  LONGMIN and LONGMAX should be private static finals.  Also they
> > should be named LONG_MIN and LONG_MAX, but I digress.
> > > >
> > > >         Josh
> > > >
> > > >
> > > >
> > > > On 6/6/07, Matthias Ernst <matthias at mernst.org > wrote:
> > > > > >     // These constants are only initialized if needed
> > > > > >    /** BigInteger equal to Long.MIN_VALUE . */
> > > > > >    private static BigInteger LONGMIN = null;
> > > > > >    /** BigInteger equal to Long.MAX_VALUE. */
> > > > > >    private static BigInteger LONGMAX = null;
> > > > >
> > > > > Wow, someone was REALLY concerned with performance here...
> > > > >
> > > > > I think you're right with your concerns. IMHO, It should be fixed
> to
> > > > > private static final fields. I would like to see the difference in
> > > > > performance.
> > > > >
> > > > > On 6/6/07, Mike Quilleash < mike.quilleash at subexazure.com> wrote:
> > > > > > Probably something to do with the Serialising code
> > > > > > needing to write to the internal fields.
> > > > >
> > > > > No, they're static fields.
> > > > >
> > > > > Matthias
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > >
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > >
> > >
> > >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070607/161c57f5/attachment.html 

From josh at bloch.us  Thu Jun  7 17:39:26 2007
From: josh at bloch.us (Joshua Bloch)
Date: Thu, 7 Jun 2007 14:39:26 -0700
Subject: [concurrency-interest] Potential concurrency problem
	injava.math.BigDecimal?
In-Reply-To: <BDA38860DCFD334EAEA905E44EE8E7EFC32FE0@G3W0067.americas.hpqcorp.net>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org>
	<DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com>
	<22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com>
	<b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com>
	<ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com>
	<b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com>
	<b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
	<19196d860706070810p57bc2e22n655a29cbd2080e58@mail.gmail.com>
	<BDA38860DCFD334EAEA905E44EE8E7EFC32FE0@G3W0067.americas.hpqcorp.net>
Message-ID: <b097ac510706071439u6a4c5ad7x385db6354c6e87b8@mail.gmail.com>

As usual, I think Hans and I are in violent agreement.  It makes sense to
fix this as fast as possible, and thankfully Paul Wagland has made sure that
this will happen: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6566349 .
I expect to see it fixed in the next 1.6 maintenance release.  But I also
can't see  panicking about this particular bug, except perhaps as part of a
generalized panic that most concurrent code is broken;)

            Josh


On 6/7/07, Boehm, Hans <hans.boehm at hp.com> wrote:
>
> > From:  Sam Berlin
> >
> > I would wager that the chances of a concurrency problem
> > manifesting itself increase in proportion to the number of
> > different architectures, workloads, and types of the
> > computers they run on.  For enterprise systems, generally the
> > only difference is the workload, as the architecture and
> > other factors tend to remain the same.  For consumer systems,
> > nearly anything can be different, and the workloads different
> > not only in the active program and other known programs, but
> > in the number and range of executables being run.
> >
> I would at least add OS versions to the list.  I have several dim
> recollections of old buggy software exercising previously improbable
> race conditions as a result of a scheduler change or the like.  Thus I
> do think it's important to get such problems fixed asap.  They may
> unexpectedly become visible in response to some other change that
> influences timing.
>
> On the other hand, based on what I've seen, current software generally
> contains enough low-frequency-of-occurrence bugs that I'm not sure it
> makes sense to panic as a result of finding another one.  (Pet peeve:
> How much code out there guards against premature finalization/ref
> enqueueing with synchronized(this){} or the like?  Nearly all code that
> uses either finalization, and a lot that uses java.lang.ref, is
> currently also broken, with similarly low occurrence probability.)
>
> Hans
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070607/06e8d804/attachment.html 

From hans.boehm at hp.com  Thu Jun  7 15:56:52 2007
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 7 Jun 2007 19:56:52 -0000
Subject: [concurrency-interest] Potential concurrency problem
	injava.math.BigDecimal?
In-Reply-To: <19196d860706070810p57bc2e22n655a29cbd2080e58@mail.gmail.com>
References: <C1AAFE8B-1C38-4A04-A634-63624E9D6D99@kungfoocoder.org><DAE04D9F6FD21448A220918A522FB60E0723FF98@MI8NYCMAIL15.Mi8.com><22ec15240706060832j9a19abbs82663dbf79abfaa2@mail.gmail.com><b097ac510706061035t687bb391ja8d45bd632d471b7@mail.gmail.com><ca53c8f80706061153r2f1e9f6ek437bf0c5ec16326a@mail.gmail.com><b097ac510706061343q3842a28cmf52db9b41f58012e@mail.gmail.com><b6e8f2e80706070301v47b06d6cm3a08ffa62fa575df@mail.gmail.com>
	<19196d860706070810p57bc2e22n655a29cbd2080e58@mail.gmail.com>
Message-ID: <BDA38860DCFD334EAEA905E44EE8E7EFC32FE0@G3W0067.americas.hpqcorp.net>

> From:  Sam Berlin
> 
> I would wager that the chances of a concurrency problem 
> manifesting itself increase in proportion to the number of 
> different architectures, workloads, and types of the 
> computers they run on.  For enterprise systems, generally the 
> only difference is the workload, as the architecture and 
> other factors tend to remain the same.  For consumer systems, 
> nearly anything can be different, and the workloads different 
> not only in the active program and other known programs, but 
> in the number and range of executables being run.
> 
I would at least add OS versions to the list.  I have several dim
recollections of old buggy software exercising previously improbable
race conditions as a result of a scheduler change or the like.  Thus I
do think it's important to get such problems fixed asap.  They may
unexpectedly become visible in response to some other change that
influences timing.

On the other hand, based on what I've seen, current software generally
contains enough low-frequency-of-occurrence bugs that I'm not sure it
makes sense to panic as a result of finding another one.  (Pet peeve:
How much code out there guards against premature finalization/ref
enqueueing with synchronized(this){} or the like?  Nearly all code that
uses either finalization, and a lot that uses java.lang.ref, is
currently also broken, with similarly low occurrence probability.)

Hans


From raghuram.nidagal at gmail.com  Mon Jun 11 11:59:55 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Mon, 11 Jun 2007 21:29:55 +0530
Subject: [concurrency-interest] ConcurrentHashMap solves HashMap infinite
	loop issue ?
Message-ID: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>

Hi,
I wanted to find out if the ConcurrentHashMap takes care of this issue where
a HashMap get can cause an infinite loop
http://blogs.opensymphony.com/plightbo/2005/07/hashmapget_can_cause_an_infini.html


Thanks
Raghu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070611/8af5b0b8/attachment.html 

From josh at bloch.us  Mon Jun 11 12:05:10 2007
From: josh at bloch.us (Joshua Bloch)
Date: Mon, 11 Jun 2007 09:05:10 -0700
Subject: [concurrency-interest] ConcurrentHashMap solves HashMap
	infinite loop issue ?
In-Reply-To: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>
References: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>
Message-ID: <b097ac510706110905x9fe8523he52c65843c8c2768@mail.gmail.com>

Absolutely!  You needn't and *SHOULD NOT* manually synchronize access to
ConcurrentHashMap.  It just does the right thing, and it does it fast.

       Josh


On 6/11/07, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
>
> Hi,
> I wanted to find out if the ConcurrentHashMap takes care of this issue
> where a HashMap get can cause an infinite loop
>
> http://blogs.opensymphony.com/plightbo/2005/07/hashmapget_can_cause_an_infini.html
>
>
> Thanks
> Raghu
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070611/46e65ccf/attachment.html 

From crazybob at crazybob.org  Mon Jun 11 12:10:35 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Mon, 11 Jun 2007 09:10:35 -0700
Subject: [concurrency-interest] ConcurrentHashMap solves HashMap
	infinite loop issue ?
In-Reply-To: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>
References: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>
Message-ID: <a74683f90706110910i250af16j52772bc4ea30e0e6@mail.gmail.com>

It does because the map itself is thread safe, but that doesn't necessarily
mean your program is correct.

Bob

On 6/11/07, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
>
> Hi,
> I wanted to find out if the ConcurrentHashMap takes care of this issue
> where a HashMap get can cause an infinite loop
>
> http://blogs.opensymphony.com/plightbo/2005/07/hashmapget_can_cause_an_infini.html
>
>
> Thanks
> Raghu
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070611/6f83b8cd/attachment.html 

From raghuram.nidagal at gmail.com  Tue Jun 12 06:23:06 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Tue, 12 Jun 2007 15:53:06 +0530
Subject: [concurrency-interest] ConcurrentHashMap solves HashMap
	infinite loop issue ?
In-Reply-To: <b097ac510706110905x9fe8523he52c65843c8c2768@mail.gmail.com>
References: <7874b1f60706110859g6b2ea6abp478c5b4f4a496f3e@mail.gmail.com>
	<b097ac510706110905x9fe8523he52c65843c8c2768@mail.gmail.com>
Message-ID: <7874b1f60706120323m53c7fdb7q4ad6dc6acc7f5620@mail.gmail.com>

Thanks.
Raghu


On 6/11/07, Joshua Bloch <josh at bloch.us> wrote:
>
> Absolutely!  You needn't and *SHOULD NOT* manually synchronize access to
> ConcurrentHashMap.  It just does the right thing, and it does it fast.
>
>        Josh
>
>
>  On 6/11/07, raghuram nidagal <raghuram.nidagal at gmail.com> wrote:
>
> >  Hi,
> > I wanted to find out if the ConcurrentHashMap takes care of this issue
> > where a HashMap get can cause an infinite loop
> > http://blogs.opensymphony.com/plightbo/2005/07/hashmapget_can_cause_an_infini.html
> >
> >
> >
> > Thanks
> > Raghu
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070612/4c673bcb/attachment.html 

From harneetk at gmail.com  Tue Jun 12 13:09:20 2007
From: harneetk at gmail.com (Harneet Kaur)
Date: Tue, 12 Jun 2007 22:39:20 +0530
Subject: [concurrency-interest] ConcurrentModificationException with
	SyncCollectionIterator
Message-ID: <225be07d0706121009m2bb38881kb895201553748db@mail.gmail.com>

Hi,
  I am trying to use the SyncCollection and SyncCollectionIterator to
iterate over a collection and do remove operations in a multithreaded
environment. However, it results in ConcurrentModificationException.

Does the SyncCollection and SyncCollectionIterator API not take care of
this?

Regards,
Harneet
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070612/5902e366/attachment.html 

From sberlin at gmail.com  Tue Jun 12 14:22:34 2007
From: sberlin at gmail.com (Sam Berlin)
Date: Tue, 12 Jun 2007 14:22:34 -0400
Subject: [concurrency-interest] Backwards incompatible API Change in 1.6
	ExecutorService?
Message-ID: <19196d860706121122r22493668p954e0b70515adc95@mail.gmail.com>

Hi Folks,

This is probably a well-known and well-discussed change, but I
couldn't find any mentions of it online or elsewhere, and I've never
seen a change like this happen between major releases in the Java API
before...

In Java 1.5, java.util.concurrent.ExecutorService declared the
following methods:

 <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks)
        throws InterruptedException;

  <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

   <T> T invokeAny(Collection<Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

and

     <T> T invokeAny(Collection<Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;

In Java 1.6, all these signatures were changed to take "Collection<?
extends Callable<T>> tasks".

Any implementation of these classes can not be written to compile for
both 1.5 and 1.6.  This can be partially worked around by extending
from the built-in AbstractExecutorService, but even in that case, it
is not possible to add extra functionality to those methods (by
overriding them in the subclass) if you wish to maintain compile
compatibility between the releases.

Is this just a known change?  Is there any workaround available?
There doesn't seem to be a binary incompatibility (as they all erase
down to Callable), but it is a large issue for loosely managed
projects, where the program targets 1.5, but the compile environment
could be 1.5 or 1.6.  The issue is compounded by OS's that do not have
a 1.6 implementation available, such as OSX (where Apple has not yet
released a stable Java 1.6 release).

Thanks,
 Sam

From kasper at kav.dk  Tue Jun 12 17:19:16 2007
From: kasper at kav.dk (Kasper Nielsen)
Date: Tue, 12 Jun 2007 23:19:16 +0200
Subject: [concurrency-interest] Backwards incompatible API Change in 1.6
 ExecutorService?
In-Reply-To: <19196d860706121122r22493668p954e0b70515adc95@mail.gmail.com>
References: <19196d860706121122r22493668p954e0b70515adc95@mail.gmail.com>
Message-ID: <466F0DD4.3040805@kav.dk>

Hi Sam,

Take look at this bug
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6267833

If you want to provide an implementation of ExecutorService that is 
source compatible with both 1.5 and 6.0 just use the raw type, for example,
class My15_60ExecutorService implements ExecutorService {
   List invokeAll(Collection tasks) throws InterruptedException;
}
instead of

<T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks) or
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)

Obvious, the downside is that if you reference an instance of 
My15_60ExecutorService (instead of the ExecutorService interface) the 
methods aren't generified.

cheers
   Kasper

Sam Berlin wrote:
> Hi Folks,
> 
> This is probably a well-known and well-discussed change, but I
> couldn't find any mentions of it online or elsewhere, and I've never
> seen a change like this happen between major releases in the Java API
> before...
> 
> In Java 1.5, java.util.concurrent.ExecutorService declared the
> following methods:
> 
>  <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks)
>         throws InterruptedException;
> 
>   <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks,
>                                   long timeout, TimeUnit unit)
>         throws InterruptedException;
> 
>    <T> T invokeAny(Collection<Callable<T>> tasks)
>         throws InterruptedException, ExecutionException;
> 
> and
> 
>      <T> T invokeAny(Collection<Callable<T>> tasks,
>                     long timeout, TimeUnit unit)
>         throws InterruptedException, ExecutionException, TimeoutException;
> 
> In Java 1.6, all these signatures were changed to take "Collection<?
> extends Callable<T>> tasks".
> 
> Any implementation of these classes can not be written to compile for
> both 1.5 and 1.6.  This can be partially worked around by extending
> from the built-in AbstractExecutorService, but even in that case, it
> is not possible to add extra functionality to those methods (by
> overriding them in the subclass) if you wish to maintain compile
> compatibility between the releases.
> 
> Is this just a known change?  Is there any workaround available?
> There doesn't seem to be a binary incompatibility (as they all erase
> down to Callable), but it is a large issue for loosely managed
> projects, where the program targets 1.5, but the compile environment
> could be 1.5 or 1.6.  The issue is compounded by OS's that do not have
> a 1.6 implementation available, such as OSX (where Apple has not yet
> released a stable Java 1.6 release).
> 
> Thanks,
>  Sam
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From sberlin at gmail.com  Tue Jun 12 17:29:44 2007
From: sberlin at gmail.com (Sam Berlin)
Date: Tue, 12 Jun 2007 17:29:44 -0400
Subject: [concurrency-interest] Backwards incompatible API Change in 1.6
	ExecutorService?
In-Reply-To: <466F0DD4.3040805@kav.dk>
References: <19196d860706121122r22493668p954e0b70515adc95@mail.gmail.com>
	<466F0DD4.3040805@kav.dk>
Message-ID: <19196d860706121429u45bc4ce7h4b77b0320f68c438@mail.gmail.com>

Ahh --- Thank you very much, Kasper.  I guess my search wasn't very exhaustive.

We locally resolved our problem just by extending
AbstractExecutorService instead of directly implementing
ExecutorService, but I was confused at the apparent API
incompatibility.  The bugreport sheds much light.

Thanks,
Sam

On 6/12/07, Kasper Nielsen <kasper at kav.dk> wrote:
> Hi Sam,
>
> Take look at this bug
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6267833
>
> If you want to provide an implementation of ExecutorService that is
> source compatible with both 1.5 and 6.0 just use the raw type, for example,
> class My15_60ExecutorService implements ExecutorService {
>   List invokeAll(Collection tasks) throws InterruptedException;
> }
> instead of
>
> <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks) or
> <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
>
> Obvious, the downside is that if you reference an instance of
> My15_60ExecutorService (instead of the ExecutorService interface) the
> methods aren't generified.
>
> cheers
>   Kasper
>
> Sam Berlin wrote:
> > Hi Folks,
> >
> > This is probably a well-known and well-discussed change, but I
> > couldn't find any mentions of it online or elsewhere, and I've never
> > seen a change like this happen between major releases in the Java API
> > before...
> >
> > In Java 1.5, java.util.concurrent.ExecutorService declared the
> > following methods:
> >
> >  <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks)
> >         throws InterruptedException;
> >
> >   <T> List<Future<T>> invokeAll(Collection<Callable<T>> tasks,
> >                                   long timeout, TimeUnit unit)
> >         throws InterruptedException;
> >
> >    <T> T invokeAny(Collection<Callable<T>> tasks)
> >         throws InterruptedException, ExecutionException;
> >
> > and
> >
> >      <T> T invokeAny(Collection<Callable<T>> tasks,
> >                     long timeout, TimeUnit unit)
> >         throws InterruptedException, ExecutionException, TimeoutException;
> >
> > In Java 1.6, all these signatures were changed to take "Collection<?
> > extends Callable<T>> tasks".
> >
> > Any implementation of these classes can not be written to compile for
> > both 1.5 and 1.6.  This can be partially worked around by extending
> > from the built-in AbstractExecutorService, but even in that case, it
> > is not possible to add extra functionality to those methods (by
> > overriding them in the subclass) if you wish to maintain compile
> > compatibility between the releases.
> >
> > Is this just a known change?  Is there any workaround available?
> > There doesn't seem to be a binary incompatibility (as they all erase
> > down to Callable), but it is a large issue for loosely managed
> > projects, where the program targets 1.5, but the compile environment
> > could be 1.5 or 1.6.  The issue is compounded by OS's that do not have
> > a 1.6 implementation available, such as OSX (where Apple has not yet
> > released a stable Java 1.6 release).
> >
> > Thanks,
> >  Sam
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>

From dcholmes at optusnet.com.au  Tue Jun 12 20:37:04 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 13 Jun 2007 10:37:04 +1000
Subject: [concurrency-interest] ConcurrentModificationException
	withSyncCollectionIterator
In-Reply-To: <225be07d0706121009m2bb38881kb895201553748db@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEGPHHAA.dcholmes@optusnet.com.au>

Are you referring to a synchronized Collection, such as one obtained from
Collections.synchronizedCollection, and an iterator obtained from such a
collection? The docs for those methods clearly states that you must
synchronize on the collection object before using the iterator.

Otherwise I don't know of the SyncCollection or SyncCollectionIterator
types.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Harneet Kaur
  Sent: Wednesday, 13 June 2007 3:09 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] ConcurrentModificationException
withSyncCollectionIterator


  Hi,
    I am trying to use the SyncCollection and SyncCollectionIterator to
iterate over a collection and do remove operations in a multithreaded
environment. However, it results in ConcurrentModificationException.

  Does the SyncCollection and SyncCollectionIterator API not take care of
this?

  Regards,
  Harneet
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070613/e980d082/attachment.html 

From kasper at kav.dk  Wed Jun 13 02:25:07 2007
From: kasper at kav.dk (Kasper Nielsen)
Date: Wed, 13 Jun 2007 08:25:07 +0200
Subject: [concurrency-interest]
	ConcurrentModificationException	withSyncCollectionIterator
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEGPHHAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCAEGPHHAA.dcholmes@optusnet.com.au>
Message-ID: <466F8DC3.1020009@kav.dk>

David,

I think he is referring to types in the old util.concurrent,
 
http://gee.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/SyncCollection 


Harneet, you need to hold a lock on a writer lock while doing the 
iteration, for example,

Collection c = new SyncCollection(new ArrayList(),
new ReentrantWriterPreferenceReadWriteLock());
    // ...
    c.writeLock().acquire();
    try {
      Iterator it = coll.unprotectedIterator();
      while (it.hasNext()) {
   	it.remove();
      }
    }
    catch (IOException iox) {
      ...
    }
    finally {
      c.writeLock().release();
    }
And also check the docs for SyncCollection, it should be pretty clear 
what is wrong with your original code.

Cheers
  Kasper
David Holmes wrote:
> Are you referring to a synchronized Collection, such as one obtained 
> from Collections.synchronizedCollection, and an iterator obtained from 
> such a collection? The docs for those methods clearly states that you 
> must synchronize on the collection object before using the iterator.
>  
> Otherwise I don't know of the SyncCollection or SyncCollectionIterator 
> types.
>  
> Cheers,
> David Holmes
> 
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
>     *Harneet Kaur
>     *Sent:* Wednesday, 13 June 2007 3:09 AM
>     *To:* concurrency-interest at cs.oswego.edu
>     *Subject:* [concurrency-interest] ConcurrentModificationException
>     withSyncCollectionIterator
> 
>     Hi,
>       I am trying to use the SyncCollection and SyncCollectionIterator
>     to iterate over a collection and do remove operations in a
>     multithreaded environment. However, it results in
>     ConcurrentModificationException.
>      
>     Does the SyncCollection and SyncCollectionIterator API not take care
>     of this?
>      
>     Regards,
>     Harneet
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dcholmes at optusnet.com.au  Wed Jun 13 02:58:58 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 13 Jun 2007 16:58:58 +1000
Subject: [concurrency-interest]
	ConcurrentModificationException	withSyncCollectionIterator
In-Reply-To: <466F8DC3.1020009@kav.dk>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEHCHHAA.dcholmes@optusnet.com.au>

Ah I see! Thanks Kaspar :)

The iterator behaviour of those classes is also well documented.

Cheers,
David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kasper
> Nielsen
> Sent: Wednesday, 13 June 2007 4:25 PM
> To: dholmes at ieee.org
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest]ConcurrentModificationException
> withSyncCollectionIterator
>
>
> David,
>
> I think he is referring to types in the old util.concurrent,
>
> http://gee.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/
> SyncCollection
>
>
> Harneet, you need to hold a lock on a writer lock while doing the
> iteration, for example,
>
> Collection c = new SyncCollection(new ArrayList(),
> new ReentrantWriterPreferenceReadWriteLock());
>     // ...
>     c.writeLock().acquire();
>     try {
>       Iterator it = coll.unprotectedIterator();
>       while (it.hasNext()) {
>    	it.remove();
>       }
>     }
>     catch (IOException iox) {
>       ...
>     }
>     finally {
>       c.writeLock().release();
>     }
> And also check the docs for SyncCollection, it should be pretty clear
> what is wrong with your original code.
>
> Cheers
>   Kasper
> David Holmes wrote:
> > Are you referring to a synchronized Collection, such as one obtained
> > from Collections.synchronizedCollection, and an iterator obtained from
> > such a collection? The docs for those methods clearly states that you
> > must synchronize on the collection object before using the iterator.
> >
> > Otherwise I don't know of the SyncCollection or SyncCollectionIterator
> > types.
> >
> > Cheers,
> > David Holmes
> >
> >     -----Original Message-----
> >     *From:* concurrency-interest-bounces at cs.oswego.edu
> >     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
> >     *Harneet Kaur
> >     *Sent:* Wednesday, 13 June 2007 3:09 AM
> >     *To:* concurrency-interest at cs.oswego.edu
> >     *Subject:* [concurrency-interest] ConcurrentModificationException
> >     withSyncCollectionIterator
> >
> >     Hi,
> >       I am trying to use the SyncCollection and SyncCollectionIterator
> >     to iterate over a collection and do remove operations in a
> >     multithreaded environment. However, it results in
> >     ConcurrentModificationException.
> >
> >     Does the SyncCollection and SyncCollectionIterator API not take care
> >     of this?
> >
> >     Regards,
> >     Harneet
> >
> >
> > ------------------------------------------------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From harneetk at gmail.com  Wed Jun 13 09:24:33 2007
From: harneetk at gmail.com (Harneet Kaur)
Date: Wed, 13 Jun 2007 18:54:33 +0530
Subject: [concurrency-interest] ConcurrentModificationException
	withSyncCollectionIterator
In-Reply-To: <466F8DC3.1020009@kav.dk>
References: <NFBBKALFDCPFIDBNKAPCAEGPHHAA.dcholmes@optusnet.com.au>
	<466F8DC3.1020009@kav.dk>
Message-ID: <225be07d0706130624x5ba66782v77aaf8cb33b43399@mail.gmail.com>

Hi Kasper,
  I am doing the following in my code:
===============================
ArrayList ar = new ArrayList();
ar.add("match");
ar.add("xyz");
ar.add("match");
ar.add("abc");
ReentrantWriterPreferenceReadWriteLock lock = new
ReentrantWriterPreferenceReadWriteLock();
SyncCollection sc = new SyncCollection(ar, lock);
SyncCollectionIterator it = (SyncCollectionIterator)sc.iterator();
   while(it.hasNext()) {
    String str = (String)it.next();
    if( str == "match") {
     it.remove();
    }
   }
===============================
As you see above, I am getting the SyncCollectionIterator and not the
unprotected Iterator. Will it still be required to obtain a write lock?
If I see the SyncCollectionIterator implementation, I see that the
hasNext(), next(), remove() etc methods acquire the read and the write locks
internally. Then why do we further need to acquire these locks in our
implementation while using these methods?
Is this some bug or some lack in my understanding?

Regards,
Harneet

On 6/13/07, Kasper Nielsen <kasper at kav.dk> wrote:
>
> David,
>
> I think he is referring to types in the old util.concurrent,
>
>
> http://gee.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/SyncCollection
>
>
> Harneet, you need to hold a lock on a writer lock while doing the
> iteration, for example,
>
> Collection c = new SyncCollection(new ArrayList(),
> new ReentrantWriterPreferenceReadWriteLock());
>    // ...
>    c.writeLock().acquire();
>    try {
>      Iterator it = coll.unprotectedIterator();
>      while (it.hasNext()) {
>        it.remove();
>      }
>    }
>    catch (IOException iox) {
>      ...
>    }
>    finally {
>      c.writeLock().release();
>    }
> And also check the docs for SyncCollection, it should be pretty clear
> what is wrong with your original code.
>
> Cheers
> Kasper
> David Holmes wrote:
> > Are you referring to a synchronized Collection, such as one obtained
> > from Collections.synchronizedCollection, and an iterator obtained from
> > such a collection? The docs for those methods clearly states that you
> > must synchronize on the collection object before using the iterator.
> >
> > Otherwise I don't know of the SyncCollection or SyncCollectionIterator
> > types.
> >
> > Cheers,
> > David Holmes
> >
> >     -----Original Message-----
> >     *From:* concurrency-interest-bounces at cs.oswego.edu
> >     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
> >     *Harneet Kaur
> >     *Sent:* Wednesday, 13 June 2007 3:09 AM
> >     *To:* concurrency-interest at cs.oswego.edu
> >     *Subject:* [concurrency-interest] ConcurrentModificationException
> >     withSyncCollectionIterator
> >
> >     Hi,
> >       I am trying to use the SyncCollection and SyncCollectionIterator
> >     to iterate over a collection and do remove operations in a
> >     multithreaded environment. However, it results in
> >     ConcurrentModificationException.
> >
> >     Does the SyncCollection and SyncCollectionIterator API not take care
> >     of this?
> >
> >     Regards,
> >     Harneet
> >
> >
> > ------------------------------------------------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070613/d87924bb/attachment.html 

From kasper at kav.dk  Wed Jun 13 14:06:05 2007
From: kasper at kav.dk (Kasper Nielsen)
Date: Wed, 13 Jun 2007 20:06:05 +0200
Subject: [concurrency-interest] ConcurrentModificationException
	withSyncCollectionIterator
In-Reply-To: <225be07d0706130624x5ba66782v77aaf8cb33b43399@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEGPHHAA.dcholmes@optusnet.com.au>	
	<466F8DC3.1020009@kav.dk>
	<225be07d0706130624x5ba66782v77aaf8cb33b43399@mail.gmail.com>
Message-ID: <4670320D.7000107@kav.dk>

Hi Harneet,

yes you still need to obtain a write lock as in the example provided.

 >        Collection c = new SyncCollection(new ArrayList(),
 >        new ReentrantWriterPreferenceReadWriteLock());
 >        // ...
 >        c.writeLock().acquire();
 >        try {
 >          Iterator it = coll.unprotectedIterator();
 >          while (it.hasNext()) {
 >            it.remove();
 >          }
 >        }
 >        finally {
 >          c.writeLock().release();
 >        }
while the individual operations, in your example, such as it.hasNext() 
and it.next() are synchronized another thread might interleave between 
the two calls.
while(it.hasNext()) {
   //another thread remove the "next" element here
   String str = (String)it.next();
}
If you read the javadoc of SyncCollection you will read:
The iterator() method returns a SyncCollectionIterator with properties 
and methods that are analogous to those of SyncCollection itself: 
hasNext and next are read-only, and remove is mutative. These methods 
allow fine-grained controlled access, but do NOT  preclude concurrent 
modifications from being interleaved with traversals, which may lead to 
ConcurrentModificationExceptions.

cheers
   Kasper


Harneet Kaur wrote:
> Hi Kasper,
>   I am doing the following in my code:
> ===============================
> ArrayList ar = new ArrayList();
> ar.add("match");
> ar.add("xyz");
> ar.add("match");
> ar.add("abc");
> ReentrantWriterPreferenceReadWriteLock lock = new 
> ReentrantWriterPreferenceReadWriteLock();
> SyncCollection sc = new SyncCollection(ar, lock);
> SyncCollectionIterator it = (SyncCollectionIterator)sc.iterator();
>    while(it.hasNext()) {
>     String str = (String)it.next();
>     if( str == "match") {
>      it.remove();
>     }
>    }  
> ===============================
> As you see above, I am getting the SyncCollectionIterator and not the 
> unprotected Iterator. Will it still be required to obtain a write lock?
> If I see the SyncCollectionIterator implementation, I see that the 
> hasNext(), next(), remove() etc methods acquire the read and the write 
> locks internally. Then why do we further need to acquire these locks in 
> our implementation while using these methods?
> Is this some bug or some lack in my understanding?
>  
> Regards,
> Harneet

From kaitchuc at amazon.com  Wed Jun 13 14:57:10 2007
From: kaitchuc at amazon.com (Tom Kaitchuck)
Date: Wed, 13 Jun 2007 11:57:10 -0700
Subject: [concurrency-interest] backport: Error in
	ScheduledThreadPoolExecutor.
Message-ID: <46703E06.7010902@amazon.com>

In the 3.0 version of backport-util-concurrent for Java 1.4 I am seeing
this stack trace:

java.lang.ClassCastException: org.apache.activemq.transport.InactivityMonitor$1 cannot be cast to edu.emory.mathcs.backport.java.util.concurrent.Delayed { java.lang.ClassCastException: org.apache.activemq.transport.InactivityMonitor$1 cannot
be cast to edu.emory.mathcs.backport.java.util.concurrent.Delayed
     at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.compareTo(ScheduledThreadPoolExecutor.java:189)
     at edu.emory.mathcs.backport.java.util.PriorityQueue.remove(PriorityQueue.java:507)
     at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue.remove(DelayQueue.java:379)
     at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.remove(ScheduledThreadPoolExecutor.java:707)
     at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor.remove(ThreadPoolExecutor.java:1582) 

I notice there has been some refactoring on the this function and it's
callers. Does this jump out at anyone?

From raghuram.nidagal at gmail.com  Thu Jun 14 02:10:05 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Thu, 14 Jun 2007 11:40:05 +0530
Subject: [concurrency-interest] volatile inside ConcurrentHashMap
Message-ID: <7874b1f60706132310l7bb6eca6k31edfc21f0ba7812@mail.gmail.com>

Hi,
I wanted to understand the working of the ConcurrentHashMap in a little more
detail. Specifically, I have a scenario where I plan to store
ConcurrentLinkedQueues as values inside this Map. It is a scenario where
read will be around 90% of the time and write will be around 10% of the
time. I read the documentation which says that you use volatile variables to
store values and make sure the map is in sync. I wanted to understand if
there are any performance drawbacks due to this, in terms of syncing up
memory and will this be a negative factor in a use case such as the one I
have mentioned above.
Thanks
Raghu
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070614/5b23bbea/attachment.html 

From dawid.kurzyniec at gmail.com  Thu Jun 14 08:42:21 2007
From: dawid.kurzyniec at gmail.com (Dawid Kurzyniec)
Date: Thu, 14 Jun 2007 14:42:21 +0200
Subject: [concurrency-interest] backport: ClassCastException in
	ScheduledThreadPoolExecutor for v3.0
In-Reply-To: <7ADC90A5E95BA74DA5CA5A6C390D530509D037F9@VS4.EXCHPROD.USA.NET>
References: <AceGhBs5d3KFWMVaSq+PdBzUaSSL8A==>
	<7ADC90A5E95BA74DA5CA5A6C390D530509D037F9@VS4.EXCHPROD.USA.NET>
Message-ID: <3cbaca580706140542o2113c5b1rbec42edf292780b@mail.gmail.com>

On 4/24/07, Burgel, Alex <alex at dailycandy.com> wrote:
> (...) in the java 5 version of backport-util-concurrent 3.0, the
> implementation of
> ScheduledThreadPoolExecutor.ScheduledFutureTask.compareTo leads to
> ClassCastExceptions.
>
> ScheduledThreadPoolExecutor.remove() takes a Runnable, however, all the
> objects stored in the DelayedWorkQueue are of ScheduledFutureTask.
>
> ScheduledFutureTask.compareTo immediately does a cast to Delayed, so
> when comparing to a regular Runnable, you get a ClassCastException.
>
> i think ScheduledFutureTask.compareTo should do an instanceof or
> something to make sure that what is it comparing to is Delayed before
> casting.
>
>
> on a side note, the ClassCastException was helpful in tracking down a
> bug in ActiveMQ, which was incorrectly passing in a Runnable when it
> should have been passing in a ScheduledFutureTask to
> ScheduledThreadPoolExecutor.remove().

First of all, I apologize for late answer;

As you noticed, you should only remove() what you've got back from
schedule*(). It always is RunnableScheduledFuture, which implements
Delayed, and everything works fine then. In particular, you should not
try removing the original runnable passed earlier as the schedule()
argument.

So, the exception exposes a (quite easy to make) mistake in the
client's code. Exposition in itself is a Good Thing since otherwise
the bug might go unnoticed. Unfortunately, the exception is obscure
and doesn't suggest what's really going on.

I am finishing work on a new release of the backport, which should be
more consistent with j.u.c. in handling of this scenario. However, I
have doubts whether j.u.c. handling is actually superior. As far as I
can see, the j.u.c. would silently do nothing (following an expensive
linear scan) upon an erroneous attempt to remove an arbitrary runnable
from the queue. Clients would get no indication that the attempt was
erroneous, and the items would accumulate.

If that's indeed the case (I haven't actually tested it), perhaps it
would be better to change the j.u.c. (and the backport) behavior to
enforce type casting and have this type of error catched early. Should
we file a bug?

Regards,
Dawid

From kasper at kav.dk  Thu Jun 14 14:32:58 2007
From: kasper at kav.dk (Kasper Nielsen)
Date: Thu, 14 Jun 2007 20:32:58 +0200
Subject: [concurrency-interest] volatile inside ConcurrentHashMap
In-Reply-To: <7874b1f60706132310l7bb6eca6k31edfc21f0ba7812@mail.gmail.com>
References: <7874b1f60706132310l7bb6eca6k31edfc21f0ba7812@mail.gmail.com>
Message-ID: <467189DA.1080905@kav.dk>

Hi Raghu,

Your question is much like asking if there are any performance penalties
using j.u.Calendar because it needs to take summer and winter time into
account. Sure there is, but you would rather have a working program then
one that occasionally fails, right?

Same thing goes for ConcurrentHashMap. Yes, there is a performance 
penalty because it uses volatile references instead of normal 
references. But if you are creating a datastructure that is accessed by 
multiple threads you need synchronization in some form.

But I wouldn't worry about it if I were you. Even for single threaded
access I think people have found ConcurrentHashMap to be just as fast as 
HashMap.

Cheers
   Kasper

raghuram nidagal wrote:
> Hi,
> I wanted to understand the working of the ConcurrentHashMap in a little 
> more detail. Specifically, I have a scenario where I plan to store 
> ConcurrentLinkedQueues as values inside this Map. It is a scenario where 
> read will be around 90% of the time and write will be around 10% of the 
> time. I read the documentation which says that you use volatile 
> variables to store values and make sure the map is in sync. I wanted to 
> understand if there are any performance drawbacks due to this, in terms 
> of syncing up memory and will this be a negative factor in a use case 
> such as the one I have mentioned above.
> Thanks
> Raghu
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From gregg at cytetech.com  Thu Jun 14 16:28:39 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 14 Jun 2007 15:28:39 -0500
Subject: [concurrency-interest] volatile inside ConcurrentHashMap
In-Reply-To: <467189DA.1080905@kav.dk>
References: <7874b1f60706132310l7bb6eca6k31edfc21f0ba7812@mail.gmail.com>
	<467189DA.1080905@kav.dk>
Message-ID: <4671A4F7.9050202@cytetech.com>



Kasper Nielsen wrote:
> But I wouldn't worry about it if I were you. Even for single threaded
> access I think people have found ConcurrentHashMap to be just as fast as 
> HashMap.

I think this is where you need to understand how to draw the line.  HashMap was 
intended to help the performance of largely single threaded applications.  If 
you are using a concurrent software architecture where threading is prevalent, I 
would highly suggest that you use the java.util.concurrent version of data 
structures everywhere.

As Kasper alludes performance differences associated with the concurrent data 
structures is probably not an important issue compared to the help in mediating 
software bugs when your architecture changes.

Gregg Wonderly

From dcholmes at optusnet.com.au  Thu Jun 14 19:43:47 2007
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 15 Jun 2007 09:43:47 +1000
Subject: [concurrency-interest] backport: ClassCastException
	inScheduledThreadPoolExecutor for v3.0
In-Reply-To: <3cbaca580706140542o2113c5b1rbec42edf292780b@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEHLHHAA.dcholmes@optusnet.com.au>

Dawid,

> I am finishing work on a new release of the backport, which should be
> more consistent with j.u.c. in handling of this scenario. However, I
> have doubts whether j.u.c. handling is actually superior. As far as I
> can see, the j.u.c. would silently do nothing (following an expensive
> linear scan) upon an erroneous attempt to remove an arbitrary runnable
> from the queue. Clients would get no indication that the attempt was
> erroneous, and the items would accumulate.

The general philosophy from the collections package is that it is okay to
try to do something impossible - eg. remove from a collection something that
can't possibly be there. I don't think that can or should change for
TPE.remove. So simply returning false is the "right" behaviour.

That said I find the way in which wrapped tasks are handled to be generally
unsatisfactory. But there's no general solution. You can't look inside the
wrapper and examine the internal Runnable/Callable because it might be
intentionally submitted multiple times.

For ScheduledThreadPoolExecutor, when all submitted tasks are always wrapped
it would probably have been better to have a remove() method that required a
ScheduledFuture. I suppose in the same fashion as compareTo we could have:

   boolean remove(Runnable r) {
      return remove((ScheduledFuture)r);
   }
   boolean remove(SchedulerFuture r) {
      ...
   }

and override remove(Runnable) to allow the potential ClassCastException.
Adding the overloaded form in the future may be possible, but changing the
semantics of the existing method is a compatability issue - and without that
change the problem wouldn't solved.

Cheers,
David Holmes


From raghuram.nidagal at gmail.com  Thu Jun 14 22:59:32 2007
From: raghuram.nidagal at gmail.com (raghuram nidagal)
Date: Fri, 15 Jun 2007 08:29:32 +0530
Subject: [concurrency-interest] volatile inside ConcurrentHashMap
In-Reply-To: <4671A4F7.9050202@cytetech.com>
References: <7874b1f60706132310l7bb6eca6k31edfc21f0ba7812@mail.gmail.com>
	<467189DA.1080905@kav.dk> <4671A4F7.9050202@cytetech.com>
Message-ID: <7874b1f60706141959s1cb274d1h10dbad9f80a344ee@mail.gmail.com>

thanks for your inputs..we are using the concurrent data structures but I
wanted to get a sense of the performance difference..as you mentioned
handling concurrency correctly is critical for our application so that is
the primary motivator

On 6/15/07, Gregg Wonderly <gregg at cytetech.com> wrote:
>
>
>
> Kasper Nielsen wrote:
> > But I wouldn't worry about it if I were you. Even for single threaded
> > access I think people have found ConcurrentHashMap to be just as fast as
> > HashMap.
>
> I think this is where you need to understand how to draw the
> line.  HashMap was
> intended to help the performance of largely single threaded
> applications.  If
> you are using a concurrent software architecture where threading is
> prevalent, I
> would highly suggest that you use the java.util.concurrent version of data
> structures everywhere.
>
> As Kasper alludes performance differences associated with the concurrent
> data
> structures is probably not an important issue compared to the help in
> mediating
> software bugs when your architecture changes.
>
> Gregg Wonderly
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070615/9becd5e8/attachment.html 

From dominik.klimczak at gmail.com  Mon Jun 18 08:11:10 2007
From: dominik.klimczak at gmail.com (Dominik Klimczak)
Date: Mon, 18 Jun 2007 14:11:10 +0200
Subject: [concurrency-interest] Concurrent HashMap of Queues
Message-ID: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>

Hi,
I need special kind of concurrent data structure a HashMap of Queues with
operations:

void add(key, value) - add value to the end of queued elements for the key
value remove(key) - remove first value from the queue for the given key

It has to be concurrent, because it's a bottleneck of my program. It is
expected to be 100 add/remove operations per second.

1. Is there any common solution to this problem? Is there a general solution
for creating  concurrent collection of concurrent collections?

In my first version of application, I developed some kind of pattern for
solving the problem of thread-safetly joining two collections.

I have got special dummy object, which is used for "locking". In every
update operations, first I put this object to lock the key, if the previous
value was this dummy object, than this key is "locked", so I have to
reprobe, if it is other object, I can do modification.

2. Do you see any weakness of this pattern? Is there a better solution
(except writting such a concurrent structure from scratch - which I try, if
it would be necessary and possible)?
Here is some code:

public class ConcurrentMapQueue<K, V> {

    private List<V> locked = new ArrayList<V>();

    private ConcurrentMap<K, List<V>> map = new ConcurrentHashMap<K,
List<V>>();

    public void add(K key, V val) {
        while (true) {
            List<V> old = map.put(key, locked);
            if (old == locked) {
                // race lost - retry
                Thread.yield();
                continue;
            }
            // race won
            if (old == null) {
                // no previous entry
                old = new ArrayList<V>();
            } else {
                // got previous entry
            }
            // race won, got previous entry
            try {                                //try-finally prevents from
inconsistency caused by exceptions in add method
                old.add(val);
            } finally {
                map.put(key, old);
            }
            return;
        }

    }


    public V remove(K key) {
        while (true) {
            List<V> old = map.replace(key, locked);
            if (old == locked) {
                // race lost - retry
                Thread.yield();
                continue;
            }
            // race won
            if (old == null) {
                // no previous entry
                return null;
            } else {
                // got previous entry
                V res;
                try {                                //try-finally prevents
from inconsistency caused by exceptions in remove method
                    res = old.remove(0);
                } finally {
                    if (old.size() == 0) {
                        // remove if this is last element
                        map.remove(key);
                    } else {
                        // put the list back
                        map.put(key, old);
                    }
                }
                return res;
            }
        }
    }

}

Regards,
Klimczak
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/0a422434/attachment.html 

From tim at peierls.net  Mon Jun 18 08:55:20 2007
From: tim at peierls.net (Tim Peierls)
Date: Mon, 18 Jun 2007 08:55:20 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
Message-ID: <63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>

On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
>
> I need special kind of concurrent data structure a HashMap of Queues with
> operations:
>
> void add(key, value) - add value to the end of queued elements for the key
> value remove(key) - remove first value from the queue for the given key
>
> It has to be concurrent, because it's a bottleneck of my program. It is
> expected to be 100 add/remove operations per second.
>

Is there some reason why a ConcurrentHashMap<K, Queue<V>> isn't sufficient
for your purposes?

public class ConcurrentMapQueue<K, V> {

    public void add(K key, V val) {
        queueFor(key).add(val);
    }

    public V remove(K key) {
        queueFor(key).remove();
    }

    private Queue<V> queueFor(K key) {
        Queue<V> q = map.get(key);
        if (q == null) {
            q = new ConcurrentLinkedQueue<V>();
            Queue<V> prev = map.putIfAbsent(key, q);
            if (prev != null) q = prev;
        }
        return q;
    }

    private ConcurrentMap<K, Queue<V>> map =
        new ConcurrentHashMap<K, Queue<V>>();
}

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/7d396480/attachment.html 

From dominik.klimczak at gmail.com  Mon Jun 18 09:20:49 2007
From: dominik.klimczak at gmail.com (Dominik Klimczak)
Date: Mon, 18 Jun 2007 15:20:49 +0200
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
Message-ID: <5c8321dc0706180620q491c4eb2ob6da79047285ca7b@mail.gmail.com>

2007/6/18, Tim Peierls <tim at peierls.net>:
>
> On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
> >
> > I need special kind of concurrent data structure a HashMap of Queues
> > with operations:
> >
> > void add(key, value) - add value to the end of queued elements for the
> > key
> > value remove(key) - remove first value from the queue for the given key
> >
> > It has to be concurrent, because it's a bottleneck of my program. It is
> > expected to be 100 add/remove operations per second.
> >
>
> Is there some reason why a ConcurrentHashMap<K, Queue<V>> isn't sufficient
> for your purposes?
>
> public class ConcurrentMapQueue<K, V> {
>
>     public void add(K key, V val) {
>         queueFor(key).add(val);
>     }
>
>     public V remove(K key) {
>         queueFor(key).remove();
>     }
>
>     private Queue<V> queueFor(K key) {
>         Queue<V> q = map.get(key);
>         if (q == null) {
>             q = new ConcurrentLinkedQueue<V>();
>             Queue<V> prev = map.putIfAbsent(key, q);
>             if (prev != null) q = prev;
>         }
>         return q;
>     }
>
>     private ConcurrentMap<K, Queue<V>> map =
>         new ConcurrentHashMap<K, Queue<V>>();
> }
>
> --tim
>

Yes, operations must be thread-safe i.e. if I implement adding as getting
Queue from ConcurrentHashMap and then adding a value to it, than after
getting and before adding other thread can remove the last element and the
whole queue from the map.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/5cb3fd3b/attachment.html 

From dominik.klimczak at gmail.com  Mon Jun 18 09:36:41 2007
From: dominik.klimczak at gmail.com (Dominik Klimczak)
Date: Mon, 18 Jun 2007 15:36:41 +0200
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
Message-ID: <5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>

And one more thing, the queues should be removed from the map.
One thing is that without removing, map will grow and will be huge - 100
millions keys expected, while with removing it should be about 100 - 500
keys at once.
Moreover my exact data structure is a little bit more complicated: first
element with a key only creates an empty queue and the rest are queued;
removing last element leaves the empty queue and next removing removes the
whole queue. It is some kind of objects lock. Only one object with a given
key can be processed at once.

Regard,
Dominik Klimczak
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/96837ae6/attachment.html 

From tim at peierls.net  Mon Jun 18 09:45:37 2007
From: tim at peierls.net (Tim Peierls)
Date: Mon, 18 Jun 2007 09:45:37 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
Message-ID: <63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>

On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
>
> And one more thing, the queues should be removed from the map.
> One thing is that without removing, map will grow and will be huge - 100
> millions keys expected, while with removing it should be about 100 - 500
> keys at once.
> Moreover my exact data structure is a little bit more complicated: first
> element with a key only creates an empty queue and the rest are queued;
> removing last element leaves the empty queue and next removing removes the
> whole queue. It is some kind of objects lock. Only one object with a given
> key can be processed at once.


I don't understand. Calling add(k, v) should *not* enqueue v if the no queue
currently exists for k?

Maybe you could describe how these particular requirements arose?

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/ac78d8a8/attachment-0001.html 

From dominik.klimczak at gmail.com  Mon Jun 18 10:14:09 2007
From: dominik.klimczak at gmail.com (Dominik Klimczak)
Date: Mon, 18 Jun 2007 16:14:09 +0200
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
Message-ID: <5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>

2007/6/18, Tim Peierls <tim at peierls.net>:
>
> On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
> >
> > And one more thing, the queues should be removed from the map.
> > One thing is that without removing, map will grow and will be huge - 100
> > millions keys expected, while with removing it should be about 100 - 500
> > keys at once.
> > Moreover my exact data structure is a little bit more complicated: first
> > element with a key only creates an empty queue and the rest are queued;
> > removing last element leaves the empty queue and next removing removes the
> > whole queue. It is some kind of objects lock. Only one object with a given
> > key can be processed at once.
>
>
> I don't understand. Calling add(k, v) should *not* enqueue v if the no
> queue currently exists for k?
>
> Maybe you could describe how these particular requirements arose?
>
> --tim
>

Thank You for your attention.
Maybe I start from the beggining:)
There are request objects with key property, I have to guarantee that only
one request with a given key is being processed at once.
So I need a structure that can
1. tell me, if there are any object in process with a given key and
 a. queue given request, if (1) is true
 b. if (1) is false mark given key as "in process", so that any further
request cannot be processed
2. after processing first request, get next (if present) to process

So in my structure there is
boolean add(k, v) - if (1a) than add request to queue and returns false
(request queued)
                         - if (1b) than add empty queue to map and return
true (request can be processed)
v remove(k) - remove first element from queue and return it, if it is last
than remove the whole queue and return null

Maybe now it is a little bit clearer.
Dominik Klimczak
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/caf2aef8/attachment.html 

From elihusmails at gmail.com  Mon Jun 18 10:48:36 2007
From: elihusmails at gmail.com (Mark Webb)
Date: Mon, 18 Jun 2007 10:48:36 -0400
Subject: [concurrency-interest] Blocking Hashmap
Message-ID: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>

I have been in search of a blocking HashMap implementation.  There is
nothing in the Java6 libraries that support a blocking map and have been
working on my own implementation based off of ConcurrentHashMap.  What I
have written so far is based off of the LinkedBlockingQueue class and all
seems to be working well.  The LinkedBlockingQueue gave me some insight to
the proper way to lock and signal to prevent deadlocks and race conditions.

My question is, what was the reasoning for not putting a blocking map into
the Java6 API?  Based on what I have done so far this does not seem
difficult and thought that if it really is that easy, why has no one else
had to write one.

Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/a2eee897/attachment.html 

From oliver at zeigermann.de  Mon Jun 18 11:13:58 2007
From: oliver at zeigermann.de (Oliver Zeigermann)
Date: Mon, 18 Jun 2007 17:13:58 +0200
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
Message-ID: <9da4f4520706180813w79a3fa4bs88505f4fc6ed9213@mail.gmail.com>

There has been a synchronized map ever since 1.2 I guess:

http://java.sun.com/j2se/1.4.2/docs/api/java/util/Collections.html#synchronizedMap(java.util.Map)

Not sure if this is what you were after.

HTH

Oliver

2007/6/18, Mark Webb <elihusmails at gmail.com>:
> I have been in search of a blocking HashMap implementation.  There is
> nothing in the Java6 libraries that support a blocking map and have been
> working on my own implementation based off of ConcurrentHashMap.  What I
> have written so far is based off of the LinkedBlockingQueue class and all
> seems to be working well.  The LinkedBlockingQueue gave me some insight to
> the proper way to lock and signal to prevent deadlocks and race conditions.
>
> My question is, what was the reasoning for not putting a blocking map into
> the Java6 API?  Based on what I have done so far this does not seem
> difficult and thought that if it really is that easy, why has no one else
> had to write one.
>
> Mark
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From elihusmails at gmail.com  Mon Jun 18 11:18:45 2007
From: elihusmails at gmail.com (Mark Webb)
Date: Mon, 18 Jun 2007 11:18:45 -0400
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <9da4f4520706180813w79a3fa4bs88505f4fc6ed9213@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
	<9da4f4520706180813w79a3fa4bs88505f4fc6ed9213@mail.gmail.com>
Message-ID: <9f066ee90706180818v11f7d7e2o53d2b4d746f6e14@mail.gmail.com>

I was looking for the blocking aspect of the map.  I have been torn between
using FutureTasks and a BlockingMap and was trying out the BlockingMap
first.  Plus I just wanted to see how such a beast would perform.

Thanks for the response...

On 6/18/07, Oliver Zeigermann <oliver at zeigermann.de> wrote:
>
> There has been a synchronized map ever since 1.2 I guess:
>
>
> http://java.sun.com/j2se/1.4.2/docs/api/java/util/Collections.html#synchronizedMap(java.util.Map)
>
> Not sure if this is what you were after.
>
> HTH
>
> Oliver
>
> 2007/6/18, Mark Webb <elihusmails at gmail.com>:
> > I have been in search of a blocking HashMap implementation.  There is
> > nothing in the Java6 libraries that support a blocking map and have been
> > working on my own implementation based off of ConcurrentHashMap.  What I
> > have written so far is based off of the LinkedBlockingQueue class and
> all
> > seems to be working well.  The LinkedBlockingQueue gave me some insight
> to
> > the proper way to lock and signal to prevent deadlocks and race
> conditions.
> >
> > My question is, what was the reasoning for not putting a blocking map
> into
> > the Java6 API?  Based on what I have done so far this does not seem
> > difficult and thought that if it really is that easy, why has no one
> else
> > had to write one.
> >
> > Mark
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>



-- 
..Cheers
Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/8df77349/attachment.html 

From gregg at cytetech.com  Mon Jun 18 11:58:34 2007
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Jun 2007 10:58:34 -0500
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
Message-ID: <4676ABAA.5030008@cytetech.com>



Mark Webb wrote:
> My question is, what was the reasoning for not putting a blocking map 
> into the Java6 API?  Based on what I have done so far this does not seem 
> difficult and thought that if it really is that easy, why has no one 
> else had to write one.

One way to do this is with Futures.  Have you considered putting Futures into a 
ConcurrentHashMap?

Gregg Wonderly

From tim at peierls.net  Mon Jun 18 14:53:11 2007
From: tim at peierls.net (Tim Peierls)
Date: Mon, 18 Jun 2007 14:53:11 -0400
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <4676ABAA.5030008@cytetech.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
	<4676ABAA.5030008@cytetech.com>
Message-ID: <63b4e4050706181153s47a286eemb9e7f3bc83013df7@mail.gmail.com>

On 6/18/07, Gregg Wonderly <gregg at cytetech.com> wrote:
>
> Mark Webb wrote:
> > My question is, what was the reasoning for not putting a blocking map
> > into the Java6 API?  Based on what I have done so far this does not seem
> > difficult and thought that if it really is that easy, why has no one
> > else had to write one.
>
> One way to do this is with Futures.  Have you considered putting Futures
> into a
> ConcurrentHashMap?
>

And see the Memoizer example from Java Concurrency in Practice, which acts
like a blocking map.


--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/6e13d472/attachment.html 

From elihusmails at gmail.com  Mon Jun 18 14:57:29 2007
From: elihusmails at gmail.com (Mark Webb)
Date: Mon, 18 Jun 2007 14:57:29 -0400
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <63b4e4050706181153s47a286eemb9e7f3bc83013df7@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
	<4676ABAA.5030008@cytetech.com>
	<63b4e4050706181153s47a286eemb9e7f3bc83013df7@mail.gmail.com>
Message-ID: <9f066ee90706181157t6156b226i8b22f5a1ac486692@mail.gmail.com>

Will do.  Tim, great book btw.

On 6/18/07, Tim Peierls <tim at peierls.net> wrote:
>
> On 6/18/07, Gregg Wonderly <gregg at cytetech.com> wrote:
> >
> > Mark Webb wrote:
> > > My question is, what was the reasoning for not putting a blocking map
> > > into the Java6 API?  Based on what I have done so far this does not
> > seem
> > > difficult and thought that if it really is that easy, why has no one
> > > else had to write one.
> >
> > One way to do this is with Futures.  Have you considered putting Futures
> > into a
> > ConcurrentHashMap?
> >
>
> And see the Memoizer example from Java Concurrency in Practice, which acts
> like a blocking map.
>
>
> --tim




-- 
..Cheers
Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/a0bca225/attachment.html 

From crazybob at crazybob.org  Mon Jun 18 15:50:03 2007
From: crazybob at crazybob.org (Bob Lee)
Date: Mon, 18 Jun 2007 12:50:03 -0700
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <9f066ee90706181157t6156b226i8b22f5a1ac486692@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
	<4676ABAA.5030008@cytetech.com>
	<63b4e4050706181153s47a286eemb9e7f3bc83013df7@mail.gmail.com>
	<9f066ee90706181157t6156b226i8b22f5a1ac486692@mail.gmail.com>
Message-ID: <a74683f90706181250o28e9bda9m24a57462a086a998@mail.gmail.com>

It's an internal class, but you might find
AbstractReferenceCache/ReferenceCache in Guice interesting:
http://google-guice.googlecode.com/svn/trunk/src/com/google/inject/internal/

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070618/8cb47625/attachment.html 

From brian at quiotix.com  Mon Jun 18 16:42:45 2007
From: brian at quiotix.com (Brian Goetz)
Date: Mon, 18 Jun 2007 16:42:45 -0400
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
Message-ID: <4676EE45.5000301@quiotix.com>

And there won't be, because grafting blocking functionality onto a class 
not designed for it causes all sorts of problems.

Let's assume for a second that by "blocking Map", you mean that if there 
is no mapping for key k, get(k) will block until someone calls put(k,v).

Now, get() is a blocking method, but the specification of Map suggests 
otherwise.  This will be very confusing when someone passes a blocking 
map to a method expecting a Map.  If get() is a blocking method, there 
should be a way of interrupting a blocking action, which would require 
it to throw InterruptedException.  But you can't add new checked 
exceptions to interface methods.

Bottom line: blocking data structures are different from "regular" data 
structures (I can't say non-blocking because that means something else.) 
  However, the suggestions here (like Map<K,Future<V>>) may get you to 
where you need to be by moving the blocking functionality to another 
class.

Mark Webb wrote:
> I have been in search of a blocking HashMap implementation.  There is 
> nothing in the Java6 libraries that support a blocking map and have been 
> working on my own implementation based off of ConcurrentHashMap.  What I 
> have written so far is based off of the LinkedBlockingQueue class and 
> all seems to be working well.  The LinkedBlockingQueue gave me some 
> insight to the proper way to lock and signal to prevent deadlocks and 
> race conditions.
> 
> My question is, what was the reasoning for not putting a blocking map 
> into the Java6 API?  Based on what I have done so far this does not seem 
> difficult and thought that if it really is that easy, why has no one 
> else had to write one.
> 
> Mark
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From gergg at cox.net  Tue Jun 19 11:08:30 2007
From: gergg at cox.net (Gregg Wonderly)
Date: Tue, 19 Jun 2007 10:08:30 -0500
Subject: [concurrency-interest] Blocking Hashmap
In-Reply-To: <4676EE45.5000301@quiotix.com>
References: <9f066ee90706180748s48aa89deh3550eff1ae527ea6@mail.gmail.com>
	<4676EE45.5000301@quiotix.com>
Message-ID: <4677F16E.30008@cox.net>

Brian Goetz wrote:
> Bottom line: blocking data structures are different from "regular" data 
> structures (I can't say non-blocking because that means something else.) 
>   However, the suggestions here (like Map<K,Future<V>>) may get you to 
> where you need to be by moving the blocking functionality to another 
> class.

That was part of my reasoning behind this suggestion.  By putting the future in 
there, the software using the map, has a known API for dealing with blocking 
data retrieval.

Gregg Wonderly

From tim at peierls.net  Tue Jun 19 19:25:19 2007
From: tim at peierls.net (Tim Peierls)
Date: Tue, 19 Jun 2007 19:25:19 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
	<5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
Message-ID: <63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>

On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
>
> So I need a structure that can
> 1. tell me, if there are any object in process with a given key and
>  a. queue given request, if (1) is true
>  b. if (1) is false mark given key as "in process", so that any further
> request cannot be processed
> 2. after processing first request, get next (if present) to process
>
> So in my structure there is
> boolean add(k, v) - if (1a) than add request to queue and returns false
> (request queued)
>                          - if (1b) than add empty queue to map and return
> true (request can be processed)
> v remove(k) - remove first element from queue and return it, if it is last
> than remove the whole queue and return null
>

Sorry for the late reply.

Does this fit your requirements?

public class ConcurrentMapQueue<K, V> {

  public boolean add(K key, V val) {
    while (true) {
      CountingQueue<V> q = map.get(key);
      if (q == null) {
        q = map.putIfAbsent(key, new CountingQueue<V>());
        if (q == null) {
          return true;
        }
      }
      if (q.offer(val)) {
        return false;
      }
    }
  }

  public V remove(K key) {
    CountingQueue<V> q = map.get(key);
    if (q == null) {
      return null;
    }
    V val = q.poll();
    if (q.isRemovable()) {
      map.remove(key, q);
    }
    return val;
  }

  static class CountingQueue<V> {
    final Queue<V> queue = new LinkedList<V>();
    int count = 0;

    synchronized V poll() {
      V val = queue.poll();
      --count;
      return val;
    }

    synchronized boolean offer(V val) {
      if (isRemovable() || !queue.offer(val)) {
        return false;
      }
      ++count;
      return true;
    }

    synchronized boolean isRemovable() {
      return count < 0;
    }
  }

  private ConcurrentMap<K, CountingQueue<V>> map =
    new ConcurrentHashMap<K, CountingQueue<V>>();
}

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070619/fd7b0f6e/attachment.html 

From sberlin at gmail.com  Tue Jun 19 22:23:08 2007
From: sberlin at gmail.com (Sam Berlin)
Date: Tue, 19 Jun 2007 22:23:08 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
	<5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
	<63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
Message-ID: <19196d860706191923x512a79fbi474ef746a9a82c97@mail.gmail.com>

This is a really neat structure.  I initially thought there would be a
problem if it reached q.offer in the add but then switched over to do
a remove, and then realized that the offer fails if the queue ever
reached a removable state.  That's very cool.

Is such a structure really an improvement over a simpler locking
structure, though?  The code would seem to be conceptually much
simpler if the initial ConcurrentMapQueue just synchronized it's
add/remove calls, so each was atomic with respect to the other.  It
seems that the desire for a non-blocking implementation ends up making
things more complicated, as the needs dictate some form of atomicity
over multiple variables, which seems to inherently require locking.
In this implementation, locking is used in every call anyway for the
offer & poll methods -- in some cases, two locks could even be
acquired for a single add (except the first, which acquires no locks),
two locks are acquired for every remove (except the last, which again
acquires no locks), and multiple allocations of the Queue could be
attempted.

This particular structure seems to have the most improvements in the
scenario where things are added and very rapidly removed, leaving a
particular key empty for the majority of the time.  This is as opposed
to a scenario where many things are added in succession and then
removed, leaving a key within the map for most of the time.

Sam

On 6/19/07, Tim Peierls <tim at peierls.net> wrote:
> On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
> > So I need a structure that can
> > 1. tell me, if there are any object in process with a given key and
> >  a. queue given request, if (1) is true
> >  b. if (1) is false mark given key as "in process", so that any further
> request cannot be processed
> > 2. after processing first request, get next (if present) to process
> >
> > So in my structure there is
> > boolean add(k, v) - if (1a) than add request to queue and returns false
> (request queued)
> >                          - if (1b) than add empty queue to map and return
> true (request can be processed)
> > v remove(k) - remove first element from queue and return it, if it is last
> than remove the whole queue and return null
> >
>
> Sorry for the late reply.
>
> Does this fit your requirements?
>
> public class ConcurrentMapQueue<K, V> {
>
>   public boolean add(K key, V val) {
>     while (true) {
>       CountingQueue<V> q = map.get(key);
>       if (q == null) {
>         q = map.putIfAbsent(key, new CountingQueue<V>());
>         if (q == null) {
>           return true;
>         }
>       }
>       if (q.offer(val)) {
>         return false;
>       }
>     }
>   }
>
>   public V remove(K key) {
>     CountingQueue<V> q = map.get(key);
>     if (q == null) {
>       return null;
>     }
>     V val = q.poll();
>     if (q.isRemovable()) {
>       map.remove(key, q);
>     }
>     return val;
>   }
>
>   static class CountingQueue<V> {
>     final Queue<V> queue = new LinkedList<V>();
>     int count = 0;
>
>     synchronized V poll() {
>       V val = queue.poll();
>       --count;
>       return val;
>     }
>
>     synchronized boolean offer(V val) {
>       if (isRemovable() || !queue.offer(val)) {
>         return false;
>       }
>       ++count;
>       return true;
>     }
>
>     synchronized boolean isRemovable() {
>       return count < 0;
>     }
>   }
>
>   private ConcurrentMap<K, CountingQueue<V>> map =
>     new ConcurrentHashMap<K, CountingQueue<V>>();
> }
>
> --tim
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From sberlin at gmail.com  Wed Jun 20 02:28:26 2007
From: sberlin at gmail.com (Sam Berlin)
Date: Wed, 20 Jun 2007 02:28:26 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <19196d860706191923x512a79fbi474ef746a9a82c97@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
	<5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
	<63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
	<19196d860706191923x512a79fbi474ef746a9a82c97@mail.gmail.com>
Message-ID: <19196d860706192328n1901310fs8337cbc6eb6fb1d3@mail.gmail.com>

I thought about this a little more and realized the obvious
improvement was staring me in the face.  The structure as-written has
the obvious improvement over a purely synchronized structure in that
locks are acquired on a per-key basis instead of over the entire map.
That is definitely a nice improvement.

Sam

On 6/19/07, Sam Berlin <sberlin at gmail.com> wrote:
> This is a really neat structure.  I initially thought there would be a
> problem if it reached q.offer in the add but then switched over to do
> a remove, and then realized that the offer fails if the queue ever
> reached a removable state.  That's very cool.
>
> Is such a structure really an improvement over a simpler locking
> structure, though?  The code would seem to be conceptually much
> simpler if the initial ConcurrentMapQueue just synchronized it's
> add/remove calls, so each was atomic with respect to the other.  It
> seems that the desire for a non-blocking implementation ends up making
> things more complicated, as the needs dictate some form of atomicity
> over multiple variables, which seems to inherently require locking.
> In this implementation, locking is used in every call anyway for the
> offer & poll methods -- in some cases, two locks could even be
> acquired for a single add (except the first, which acquires no locks),
> two locks are acquired for every remove (except the last, which again
> acquires no locks), and multiple allocations of the Queue could be
> attempted.
>
> This particular structure seems to have the most improvements in the
> scenario where things are added and very rapidly removed, leaving a
> particular key empty for the majority of the time.  This is as opposed
> to a scenario where many things are added in succession and then
> removed, leaving a key within the map for most of the time.
>
> Sam
>
> On 6/19/07, Tim Peierls <tim at peierls.net> wrote:
> > On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
> > > So I need a structure that can
> > > 1. tell me, if there are any object in process with a given key and
> > >  a. queue given request, if (1) is true
> > >  b. if (1) is false mark given key as "in process", so that any further
> > request cannot be processed
> > > 2. after processing first request, get next (if present) to process
> > >
> > > So in my structure there is
> > > boolean add(k, v) - if (1a) than add request to queue and returns false
> > (request queued)
> > >                          - if (1b) than add empty queue to map and return
> > true (request can be processed)
> > > v remove(k) - remove first element from queue and return it, if it is last
> > than remove the whole queue and return null
> > >
> >
> > Sorry for the late reply.
> >
> > Does this fit your requirements?
> >
> > public class ConcurrentMapQueue<K, V> {
> >
> >   public boolean add(K key, V val) {
> >     while (true) {
> >       CountingQueue<V> q = map.get(key);
> >       if (q == null) {
> >         q = map.putIfAbsent(key, new CountingQueue<V>());
> >         if (q == null) {
> >           return true;
> >         }
> >       }
> >       if (q.offer(val)) {
> >         return false;
> >       }
> >     }
> >   }
> >
> >   public V remove(K key) {
> >     CountingQueue<V> q = map.get(key);
> >     if (q == null) {
> >       return null;
> >     }
> >     V val = q.poll();
> >     if (q.isRemovable()) {
> >       map.remove(key, q);
> >     }
> >     return val;
> >   }
> >
> >   static class CountingQueue<V> {
> >     final Queue<V> queue = new LinkedList<V>();
> >     int count = 0;
> >
> >     synchronized V poll() {
> >       V val = queue.poll();
> >       --count;
> >       return val;
> >     }
> >
> >     synchronized boolean offer(V val) {
> >       if (isRemovable() || !queue.offer(val)) {
> >         return false;
> >       }
> >       ++count;
> >       return true;
> >     }
> >
> >     synchronized boolean isRemovable() {
> >       return count < 0;
> >     }
> >   }
> >
> >   private ConcurrentMap<K, CountingQueue<V>> map =
> >     new ConcurrentHashMap<K, CountingQueue<V>>();
> > }
> >
> > --tim
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>

From dominik.klimczak at gmail.com  Wed Jun 20 05:34:07 2007
From: dominik.klimczak at gmail.com (Dominik Klimczak)
Date: Wed, 20 Jun 2007 11:34:07 +0200
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
	<5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
	<63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
Message-ID: <5c8321dc0706200234tfa8a35ene646aca35f37b7e2@mail.gmail.com>

2007/6/20, Tim Peierls <tim at peierls.net>:
>
> On 6/18/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
> >
> > So I need a structure that can
> > 1. tell me, if there are any object in process with a given key and
> >  a. queue given request, if (1) is true
> >  b. if (1) is false mark given key as "in process", so that any further
> > request cannot be processed
> > 2. after processing first request, get next (if present) to process
> >
> > So in my structure there is
> > boolean add(k, v) - if (1a) than add request to queue and returns false
> > (request queued)
> >                          - if (1b) than add empty queue to map and
> > return true (request can be processed)
> > v remove(k) - remove first element from queue and return it, if it is
> > last than remove the whole queue and return null
> >
>
> Sorry for the late reply.
>
> Does this fit your requirements?
>
> public class ConcurrentMapQueue<K, V> {
>
>   public boolean add(K key, V val) {
>     while (true) {
>       CountingQueue<V> q = map.get(key);
>       if (q == null) {
>         q = map.putIfAbsent(key, new CountingQueue<V>());
>         if (q == null) {
>           return true;
>         }
>       }
>       if (q.offer(val)) {
>         return false;
>       }
>     }
>   }
>
>   public V remove(K key) {
>     CountingQueue<V> q = map.get(key);
>     if (q == null) {
>       return null;
>     }
>     V val = q.poll();
>     if (q.isRemovable()) {
>       map.remove(key, q);
>     }
>     return val;
>   }
>
>   static class CountingQueue<V> {
>     final Queue<V> queue = new LinkedList<V>();
>     int count = 0;
>
>     synchronized V poll() {
>       V val = queue.poll();
>       --count;
>       return val;
>     }
>
>     synchronized boolean offer(V val) {
>       if (isRemovable() || !queue.offer(val)) {
>         return false;
>       }
>       ++count;
>       return true;
>     }
>
>     synchronized boolean isRemovable() {
>       return count < 0;
>     }
>   }
>
>   private ConcurrentMap<K, CountingQueue<V>> map =
>     new ConcurrentHashMap<K, CountingQueue<V>>();
> }
>
> --tim


Tim:
Thank You very much. Your structure is very nice with clean code and it
doesn't need two map inserts as in my version! It would help me much.

I'm wondering which solution would be the best, if we consider lock-free map
instead of j.u.c.ConcurrentHashMap. Maybe I do some tests with
j.u.c.ConcurrentSkipListMap. Anyway in my project I am using JDK 5, so Tim's
structure fits very well.

Thanks,
Dominik
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070620/a9de5b39/attachment-0001.html 

From tim at peierls.net  Wed Jun 20 07:03:48 2007
From: tim at peierls.net (Tim Peierls)
Date: Wed, 20 Jun 2007 07:03:48 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <5c8321dc0706200234tfa8a35ene646aca35f37b7e2@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com>
	<63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com>
	<5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com>
	<63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com>
	<5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com>
	<63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com>
	<5c8321dc0706200234tfa8a35ene646aca35f37b7e2@mail.gmail.com>
Message-ID: <63b4e4050706200403l43b5df4dn6b1d32a09a57a5dd@mail.gmail.com>

On 6/20/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote:
>
> Thank You very much. Your structure is very nice with clean code and it
> doesn't need two map inserts as in my version! It would help me much.


You're welcome!

Minor point: I forgot to make the map field final.

And CountingQueue.poll could be simplified to

--count;
return queue.poll();

except the way I put it originally, if queue.poll() throws something, the
count isn't decremented. But you might take the stance that all bets are off
if queue.poll() throws unchecked, and so might as well use the simpler code.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070620/518e6d8d/attachment.html 

From gdipersio at nyc.saic.com  Wed Jun 20 09:06:47 2007
From: gdipersio at nyc.saic.com (Glen Di Persio)
Date: Wed, 20 Jun 2007 09:06:47 -0400
Subject: [concurrency-interest] Concurrent HashMap of Queues
In-Reply-To: <63b4e4050706200403l43b5df4dn6b1d32a09a57a5dd@mail.gmail.com>
References: <5c8321dc0706180511r4272b9bwfaa60d258f08d61a@mail.gmail.com><63b4e4050706180555r6c3827f1rfd03233ab33bb1c7@mail.gmail.com><5c8321dc0706180636h79fa6521h83b574778a3f298a@mail.gmail.com><63b4e4050706180645r12947078ya82f3b68d13ef912@mail.gmail.com><5c8321dc0706180714r572b5a25p375b4e6989d4a4e8@mail.gmail.com><63b4e4050706191625y43b88a93lc5a7a3d708283169@mail.gmail.com><5c8321dc0706200234tfa8a35ene646aca35f37b7e2@mail.gmail.com>
	<63b4e4050706200403l43b5df4dn6b1d32a09a57a5dd@mail.gmail.com>
Message-ID: <12AE7DE71168B8419F619FF3079F969C01C0F6A0@nyc-1250-srv04.nyc.com>

Is it something of a misnomer to call this a queue?  If I insert two
elements in the order x then y, it is not guaranteed that x will have
been removed when y is being removed.
 
Glen

________________________________

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Tim
Peierls
Sent: Wednesday, June 20, 2007 7:04 AM
To: Dominik Klimczak
Cc: Concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Concurrent HashMap of Queues


On 6/20/07, Dominik Klimczak <dominik.klimczak at gmail.com> wrote: 

	Thank You very much. Your structure is very nice with clean code
and it doesn't need two map inserts as in my version! It would help me
much.


You're welcome! 

Minor point: I forgot to make the map field final. 

And CountingQueue.poll could be simplified to

--count;
return queue.poll();

except the way I put it originally, if queue.poll() throws something,
the count isn't decremented. But you might take the stance that all bets
are off if queue.poll() throws unchecked, and so might as well use the
simpler code. 


--tim

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070620/81d2255a/attachment.html 

From geoffrey.wiseman at gmail.com  Mon Jun 25 00:07:00 2007
From: geoffrey.wiseman at gmail.com (Geoffrey Wiseman)
Date: Mon, 25 Jun 2007 00:07:00 -0400
Subject: [concurrency-interest] InfoQ Article on jsr166y
Message-ID: <835d522e0706242107r1f99a3d1rf452e481dbb3a7a6@mail.gmail.com>

Greetings,

I'm writing up a little on jsr166y for InfoQ to give people a sense of what
may be coming in Java SE 7 as far as concurrency.  The list and the javadoc
as well as the forkjoin paper have been useful resources, and I've probably
got enough, but I have a few questions that might help me to make the news
better, and clearer for the readers.

So i'm passing these on; if some of you are able to answer some of them,
I'll try and fold that new knowledge into what i'm writing.

So, here's a few questions that I had, if any of you have the time to answer
some of them, I'll see if I can fold some of it into the InfoQ Article:

   - How close is jsr166y to expected concurrency features in Java SE 7?
   Are there likely to be other features joining 166y in the months to come, or
   is this fairly 'complete'?  I gather from an earlier posting that the odds
   of the existing elements of 166y making SE 7 are pretty good?  (I'm not
   really asking for prognostication; if there's no way to tell, there's no way
   to tell, just don't want to make unsupported implications in the article one
   way or another).
   - The Javadoc says that TransferQueue would be useful in
   message-passing applications.   I'm having trouble imagining scenarios that
   don't feel contrived (maybe just shows my inexperience with the kind of
   application that would benefit from this, but I'm happy to learn).  Can
   anyone give me a more concrete example?
   - The examples listed for forkjoin all seem like both good and
   reasonable examples of the sorts of things that I expect will benefit most
   from a framework like this, but may be less accessible to some readers.  A
   large sort is pretty accessible, but still the kind of thing that many
   readers will rely on a sort library method, rather than writing it
   themselves.  Do you think forkjoin is likely to remain niche for those
   people who really need improved performance, or is it something you see as
   being a tool for most Java programmers?
   - Finally, when we're at a point closer to the release of Java SE 7,
   if one of you is interested in writing up a detailed and yet accessible
   (sometimes a tough combination, but a very useful one) introductory article
   on ForkJoin, I think that's something that could benefit a lot of people and
   help ease them into using it the right way, and I imagine that I could get
   InfoQ interested in publishing it.  If you're interested, let me know and I
   can follow up with interested parties.

-- 
Geoffrey Wiseman
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20070625/a973c231/attachment.html 

From dl at cs.oswego.edu  Mon Jun 25 08:30:27 2007
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 25 Jun 2007 08:30:27 -0400
Subject: [concurrency-interest] InfoQ Article on jsr166y
In-Reply-To: <835d522e0706242107r1f99a3d1rf452e481dbb3a7a6@mail.gmail.com>
References: <835d522e0706242107r1f99a3d1rf452e481dbb3a7a6@mail.gmail.com>
Message-ID: <467FB563.4010500@cs.oswego.edu>

Geoffrey Wiseman wrote:
> 
> So, here's a few questions that I had, if any of you have the time to 
> answer some of them, I'll see if I can fold some of it into the InfoQ 
> Article:
> 
>     * How close is jsr166y to expected concurrency features in Java SE
>       7?  Are there likely to be other features joining 166y in the
>       months to come, or is this fairly 'complete'?  I gather from an
>       earlier posting that the odds of the existing elements of 166y
>       making SE 7 are pretty good?  (I'm not really asking for
>       prognostication; if there's no way to tell, there's no way to
>       tell, just don't want to make unsupported implications in the
>       article one way or another).

We hope the forkjoin package makes it. Big (32+) multicores will be
coming out in volume during the lifetime of Java 7, and having
this framework in place will allow people running them to get
relatively simple speedups for computation-intensive tasks.
Right now, forkjoin works best on machines like Sun Niagaras
and Azuls, which are the only current processors of the form that
will soon be common. It also works well on standard SMPs. In general,
you don't get many speedup benefits with less than 4 processors
though -- the main targets are in the dozens to hundreds of
processors range.

There are of course other approaches to fine-grained
parallelism besides forkjoin, and maybe some will someday
be supported. But work-stealing-based forkjoin frameworks
are the most efficient I know that excel in portability:
they work well across all sorts of machines. And even
though they don't give big speedups for small numbers
of processors, normal sensible usages also don't give
big slowdowns even on uniprocessors, so you can use them
routinely without worrying much about performance issues.

As a few people who are trying to use it know, the forkjoin
package APIs are still evolving. (The CVS versions never
contain known bugs, but do sometimes contain methods and
classes that go away or change.) A fair amount of this is
due to interactions with likely users, including the X10
(http://x10.sourceforge.net/x10home.shtml)
(http://domino.research.ibm.com/comm/research_projects.nsf/pages/x10.index.html)
(thanks especially to Vijay Saraswat of IBM) and Fortress
(http://research.sun.com/projects/plrg/) groups. Ongoing
work includes better extensibility
hooks, better support for programmers to exploit locality,
and better data structures for collecting and maintaining
results of parallel operations. I'm hoping this will all
stabilize within a month or so.

The non-forkjoin contents of jsr166y will also probably
grow. There are a bunch of ongoing wish-list/RFE components
people have asked for and we look into, including scalable
counters and a ConcurrentIdentityHashMap based in some way on
Cliff Click's work. Also a few additions to the atomics package
to better support expert-mode fine-tuning of memory model effects,
which can't be part of a jsr166y release since they require
VM intrinsics support. Plus algorithmic improvements to existing
j.u.c classes.


>     * The Javadoc says that TransferQueue would be useful in
>       message-passing applications.   I'm having trouble imagining
>       scenarios that don't feel contrived (maybe just shows my
>       inexperience with the kind of application that would benefit from
>       this, but I'm happy to learn).  Can anyone give me a more concrete
>       example?

TransferQueues are a little niche-y, but when you need them, nothing
else will do. One of the motivations is to create a simpler-to-use
thread pool, in which sometimes tasks must be synchronously transfered.

>     * The examples listed for forkjoin all seem like both good and
>       reasonable examples of the sorts of things that I expect will
>       benefit most from a framework like this, but may be less
>       accessible to some readers.  A large sort is pretty accessible,
>       but still the kind of thing that many readers will rely on a sort
>       library method, rather than writing it themselves.  Do you think
>       forkjoin is likely to remain niche for those people who really
>       need improved performance, or is it something you see as being a
>       tool for most Java programmers?

I was initially hoping for some better language support so it
would be easier to express things like: Add up these numbers
in parallel. I don't think this will happen before Java 7 though.
Or maybe ever. It might someday be the case that the nicest way
to express some usages (see below) will be to code in X10, Scala,
or Fortress, all of which compile to Java bytecodes that
might/could use the forkjoin framework and can coexist with other
Java code.

Overall, I expect an adoption curve vaguely similar to other
concurrency utilities. At first only a few people who really
need them will use them, but eventually, it will be hard
to find programs that don't somehow rely on them, often buried
deep inside infrastructure components. For this reason, surface
syntax support might not be all that important anyway -- the kinds
of library/component developers most likely to want to incorporate
them are more likely to put up with awkward usage.

Ideally, there will be several layers of usages:

1. "Do this stuff in parallel" level, where a language or tools
translates into parallel-ese, while also checking for safety/liveness.
This is still partially in the realm of research though.

2. Arranging for parallel operations on collections. -- map, reduce,
apply, etc. Programmers who can think about manipulating collections
using aggregate all-at-once operations can use these to speed up
common kinds of processing. (This is the ListTasks, ArrayTasks, etc
layer.)

3. Hand-crafting an efficient forkjoin solution for a given problem.
This is the layer I'm right now concentrating on, to be sure we can
support the wide range of parallel algorithms possible using
work-stealing frameworks. (Some of the currently odd-looking and
under-explained methods like isQuiescent are designed for such
advanced usages. Most programs just use "fork" and "join", but
the others are there when you need them.)

4. Extending the framework to create new kinds of ForkJoinTasks etc.
For example, those that operate transactionally. Only a very small
number of people (for example, perhaps the Fortress runtime library
developers) will ever need to do this, but there need to be enough
base extension hooks to pull this off.

>     * Finally, when we're at a point closer to the release of Java SE 7,
>       if one of you is interested in writing up a detailed and yet
>       accessible (sometimes a tough combination, but a very useful one)
>       introductory article on ForkJoin, I think that's something that
>       could benefit a lot of people and help ease them into using it the
>       right way, and I imagine that I could get InfoQ interested in
>       publishing it.  If you're interested, let me know and I can follow
>       up with interested parties.
> 

We will be putting out as much usage guidance as we can.
Expect some nice articles etc by Brian. (Right Brian? :-).
But probably still not for a while. At this point it is
probably best to have bleeding-edge folks as main users.
Which includes many of you on the concurrency-interest list,
so do please give things a try and tell us about problems
or possible improvements while it is still possible to change
things without going through the many layers of red tape that
go into effect once components are put in JDK.

-Doug



From gregg at wonderly.org  Tue Jun 26 11:40:16 2007
From: gregg at wonderly.org (Gregg Wonderly)
Date: Tue, 26 Jun 2007 10:40:16 -0500
Subject: [concurrency-interest] Logging synchronization.
Message-ID: <46813360.40500@wonderly.org>

The logging APIs include a very large amount of use of synchronized blocks. 
There have been issues associated with the formatter using synchronization in 
call outs to toString() etc.  Does anyone on this list know of anyone at sun or 
in the open source community forming post opensourcing working on this issue?

Gregg Wonderly

