From david@walend.net  Mon Sep  8 18:58:29 2003
From: david@walend.net (David Walend)
Date: Mon, 08 Sep 2003 13:58:29 -0400
Subject: [concurrency-interest] Too late to add a pushBack method to BlockingQueue?
Message-ID: <3F5CC345.6070507@walend.net>

A friend of mine is trying to add message acknowledgment to Somnifugi 
JMS. I'm trying to make some long-range plans to use 
java.util.concurrent.BlockingQueues, and I think I need a method that 
isn't there.

JMS acknowledge is a little strange. Under CLIENT_ACKNOWLEDGE, a JMS 
client can keep taking messages without acknowledging any of them 
immediately. Normally the client will acknowledge one of the messages 
before a time out. If the client doesn't acknowledge in time, then the 
JMS Session has to redeliver all of the unacknowledged messages in the 
correct order. To keep the order correct, we need to be able to push a 
message back onto the head of the queue.

My friend is about to hack Professor Lea's LinkedNodes to get the 
pushBack method we need. When jskd 1.5 comes out, I'd like to upgrade 
from hacked Channel API to not-hacked BlockingQueue API.

Is it too late to plead a case for a pushBack method? Does anyone else 
need this?

Thanks,

Dave

-- 
David Walend
david@walend.net
http://www.walend.net



From Darron_Shaffer@stercomm.com  Mon Sep  8 19:31:20 2003
From: Darron_Shaffer@stercomm.com (Shaffer, Darron)
Date: Mon, 8 Sep 2003 13:31:20 -0500
Subject: [concurrency-interest] Too late to add a pushBack method to B
 lockingQueue?
Message-ID: <D0E281E7D3C7164399488D7AD8BEEFEB01C14E3E@scidalmsg02.csg.stercomm.com>

I'm currently using a LinkedQueue in a mode where I could use a pushback.
In my code it's only one object at a time, so I was able to restructure the
code.  It does a peek() and, if the decision is made to "consume" the
retrieved object, a take().

A pushback would make the code structure cleaner, but I wonder if it would
cost more in synchronization?

Darron Shaffer

> -----Original Message-----
> From: David Walend [mailto:david@walend.net]
> Sent: Monday, September 08, 2003 12:58 PM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Too late to add a pushBack method to
> BlockingQueue?
> 
> 
> A friend of mine is trying to add message acknowledgment to Somnifugi 
> JMS. I'm trying to make some long-range plans to use 
> java.util.concurrent.BlockingQueues, and I think I need a method that 
> isn't there.
> 
> JMS acknowledge is a little strange. Under CLIENT_ACKNOWLEDGE, a JMS 
> client can keep taking messages without acknowledging any of them 
> immediately. Normally the client will acknowledge one of the messages 
> before a time out. If the client doesn't acknowledge in time, 
> then the 
> JMS Session has to redeliver all of the unacknowledged 
> messages in the 
> correct order. To keep the order correct, we need to be able 
> to push a 
> message back onto the head of the queue.
> 
> My friend is about to hack Professor Lea's LinkedNodes to get the 
> pushBack method we need. When jskd 1.5 comes out, I'd like to upgrade 
> from hacked Channel API to not-hacked BlockingQueue API.
> 
> Is it too late to plead a case for a pushBack method? Does 
> anyone else 
> need this?
> 
> Thanks,
> 
> Dave
> 
> -- 
> David Walend
> david@walend.net
> http://www.walend.net
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From dl@cs.oswego.edu  Tue Sep  9 00:19:40 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 8 Sep 2003 19:19:40 -0400
Subject: [concurrency-interest] Too late to add a pushBack method to BlockingQueue?
In-Reply-To: <3F5CC345.6070507@walend.net>
References: <3F5CC345.6070507@walend.net>
Message-ID: <16221.3724.253337.399503@altair.cs.oswego.edu>

We had considered supporting Deques, that allow additions and removals
from both ends, which would work for you. The main issue here though
is that the best implementations of this API tend to vary too much
across contexts. For example, one good for work-stealing is unlikely
to be very good for message buffering and vice versa. So, we haven't
found it to be a good candidate for inclusion in JSR-166.  (It IS a
good candidate for a post-1.5 dl.u.c though.)

-Doug







From dl@cs.oswego.edu  Tue Sep  9 00:46:11 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 8 Sep 2003 19:46:11 -0400
Subject: [concurrency-interest] JSR-166 Status update
Message-ID: <16221.5315.253802.350576@altair.cs.oswego.edu>

I haven't done one of these for a while so,...

1. There is one week left in the JCP community review phase for
JSR-166. Assuming this passes, we will almost immediately file for
public review. When we do this, I'll post something summarizaing
changes since the community review version (there are only a few).
These phases don't impact JSR-166 too much simce we've been in
"public" review via this list, the web site etc since the beginning.

2. Something extremely close to the current APIs and sources at
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html is moving
through Sun 1.5.0 engineering process. Although I don't know how this
works at Sun, I believe that if you promise to "seriously" help test
things, you can ask to get into an early-access program and get a copy
(probably within a few weeks). If this applies to you -- i.e., you
would start using and beating hard on j.u.c soon, send me (not the
list) mail, and I'll investigate.

3. We aim to make j.u.c completely error-free. While we've made tests
etc., your help in making more tests, and especially, doing code
reviews, would be very much appreciated.

4. While we are getting further and further into resist-changing-anything
mode, comments and suggestions are always of course welcome.

5. I still hope to make a "transitional" dl.u.c/j.u.c package that
does not rely on JDK1.5 available, although I can't predict when I'll
have time to do it.

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From ggregory@seagullsw.com  Tue Sep  9 17:39:50 2003
From: ggregory@seagullsw.com (Gary Gregory)
Date: Tue, 9 Sep 2003 12:39:50 -0400
Subject: [concurrency-interest] JSR-166 Status update
Message-ID: <245A7290F0E0D311BF6E009027E7908B07204815@atlanta.seagullsw.com>

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C376F0.FCDB3980
Content-Type: text/plain

> 5. I still hope to make a "transitional" dl.u.c/j.u.c package that
> does not rely on JDK1.5 available, although I can't predict when I'll
> have time to do it.

Are we talking reliance on 1.4 then? I do recall seing a newer version with
1.4 as a dependency instead of <1.4.

For the curious, we are "stuck" on 1.3.1 for now due to circumstances out of
our control. We have been using a now rather old version of the package,
without any issues (we only use the thread pool for now).

Thanks,
Gary

------_=_NextPart_001_01C376F0.FCDB3980
Content-Type: text/html
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
5.5.2654.45">
<TITLE>RE: [concurrency-interest] JSR-166 Status update</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=3D2>&gt; 5. I still hope to make a =
&quot;transitional&quot; dl.u.c/j.u.c package that</FONT>
<BR><FONT SIZE=3D2>&gt; does not rely on JDK1.5 available, although I =
can't predict when I'll</FONT>
<BR><FONT SIZE=3D2>&gt; have time to do it.</FONT>
</P>

<P><FONT SIZE=3D2>Are we talking reliance on 1.4 then? I do recall =
seing a newer version with 1.4 as a dependency instead of =
&lt;1.4.</FONT>
</P>

<P><FONT SIZE=3D2>For the curious, we are &quot;stuck&quot; on 1.3.1 =
for now due to circumstances out of our control. We have been using a =
now rather old version of the package, without any issues (we only use =
the thread pool for now).</FONT></P>

<P><FONT SIZE=3D2>Thanks,</FONT>
<BR><FONT SIZE=3D2>Gary</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C376F0.FCDB3980--

From news@kav.dk  Wed Sep 10 11:57:50 2003
From: news@kav.dk (Kasper Nielsen)
Date: Wed, 10 Sep 2003 12:57:50 +0200
Subject: [concurrency-interest] Timeunit.convertMillies()
Message-ID: <3F5F03AE.9010900@kav.dk>

Hi,

I was wondering if it was possible to add a unit.toMills() function to 
TimeUnit just like there is allready a unit.toNanos().

I find myself writing a lot of
unit.convert(time, TimeUnit.MILLISECONDS)
in all my calls to sleep and wait, would be much nicer with just
unit.toMillies(time);

It would also avoid the risk of people using 
TimeUnit.MILLISECONDS.convert(time, unit) by mistake.

regards
   Kasper


From dl@cs.oswego.edu  Wed Sep 10 21:16:53 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 10 Sep 2003 16:16:53 -0400
Subject: [concurrency-interest] Timeunit.convertMillies()
In-Reply-To: <3F5F03AE.9010900@kav.dk>
References: <3F5F03AE.9010900@kav.dk>
Message-ID: <16223.34485.996097.115357@altair.cs.oswego.edu>

> I was wondering if it was possible to add a unit.toMills() 

> It would also avoid the risk of people using 
> TimeUnit.MILLISECONDS.convert(time, unit) by mistake.


And for consistency, all four:
  toNanos, no Micros, toMillis, toSeconds

This is the kind of usage-discovered API flaw that we are thrilled to
be able to fix at this stage! We'll put it in. Thanks!

-Doug

From dl@cs.oswego.edu  Wed Sep 10 21:19:09 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 10 Sep 2003 16:19:09 -0400
Subject: [concurrency-interest] Timeunit.convertMillies()
In-Reply-To: <16223.34485.996097.115357@altair.cs.oswego.edu>
References: <3F5F03AE.9010900@kav.dk>
 <16223.34485.996097.115357@altair.cs.oswego.edu>
Message-ID: <16223.34621.542359.895911@altair.cs.oswego.edu>

I wish I could type. I meant of course:

And for consistency, all four:
   toNanos, toMicros, toMillis, toSeconds

-Doug

From dholmes@dltech.com.au  Thu Sep 11 03:26:28 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 11 Sep 2003 12:26:28 +1000
Subject: [concurrency-interest] Timeunit.convertMillies()
In-Reply-To: <3F5F03AE.9010900@kav.dk>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEAIDHAA.dholmes@dltech.com.au>

Kasper Nielsen wrote:
> I find myself writing a lot of
> unit.convert(time, TimeUnit.MILLISECONDS)
> in all my calls to sleep and wait, would be much nicer with just
> unit.toMillies(time);

Why not use the TimeUnit sleep and timedwait methods rather than
converting?

David Holmes


From news@kav.dk  Thu Sep 11 11:47:58 2003
From: news@kav.dk (Kasper Nielsen)
Date: Thu, 11 Sep 2003 12:47:58 +0200
Subject: [concurrency-interest] Timeunit.convertMillies()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEAIDHAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCGEAIDHAA.dholmes@dltech.com.au>
Message-ID: <3F6052DE.10102@kav.dk>

David Holmes wrote:
> Kasper Nielsen wrote:
> 
>>I find myself writing a lot of
>>unit.convert(time, TimeUnit.MILLISECONDS)
>>in all my calls to sleep and wait, would be much nicer with just
>>unit.toMillies(time);
> 
> 
> Why not use the TimeUnit sleep and timedwait methods rather than
> converting?
> 
> David Holmes
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

You are absolutely right! I’m not using the pre-released version of 
jsr166 I had just copied what I thought was all the methods into my own 
little TimeUnit class that I could later easily replace with what’s in 
JSR166.
But thanks for the hint.

- Kasper


From kav@it.edu  Thu Sep 11 12:13:41 2003
From: kav@it.edu (Kasper Nielsen)
Date: Thu, 11 Sep 2003 13:13:41 +0200
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
Message-ID: <000701c37855$c1d39c90$f0adf33e@kav>

Hi,

It seems as the javadoc for the offer method has just been copied from
the Queue interface. What it makes it look like is that there is some
kind of difference between the add-method and offer-method because the
later may return false if the offer didn't succed.

Are they anywhere else its better to send javadoc corrections to then
this list?

- Kasper


From dl@cs.oswego.edu  Thu Sep 11 12:29:10 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 11 Sep 2003 07:29:10 -0400
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <000701c37855$c1d39c90$f0adf33e@kav>
References: <000701c37855$c1d39c90$f0adf33e@kav>
Message-ID: <16224.23686.408334.613952@altair.cs.oswego.edu>

> It seems as the javadoc for the offer method has just been copied from
> the Queue interface. What it makes it look like is that there is some
> kind of difference between the add-method and offer-method because the
> later may return false if the offer didn't succed.

Thanks. We will change this. 

> 
> Are they anywhere else its better to send javadoc corrections to then
> this list?

You could just send to me directly, but using the list is fine.

Also, although it doesn't apply in the above case, our javadoc hacks
that are in place until full 1.5.0 javadoc is available to handle
generics etc sometimes doesn't correctly show inherited specs.  Don't
bother telling us about this :-)

-Doug

From kav@it.edu  Thu Sep 11 12:48:21 2003
From: kav@it.edu (Kasper Nielsen)
Date: Thu, 11 Sep 2003 13:48:21 +0200
Subject: [concurrency-interest] Lock & semaphore
Message-ID: <000b01c3785a$99d3a500$f0adf33e@kav>

Hi,

Looking at the Semaphore and the Lock interface they both have almost
the same methods (with different names though).

--------Lock---------
void lock                  -
void lockInterruptibly     - interrupted
bool trylock (timeunit)    - interrupted
bool trylock         

--------Semaphore-----
FairSemaphore
void acquire               - interrupted
void acquireUninterruptibly 
bool tryacquire (timeunit) - interrupted
bool tryacquire   

I think it would be more consistent if _both_ lock and acquire either
threw an interrupted exception or didn't.

- Kasper


From dl@cs.oswego.edu  Thu Sep 11 12:58:44 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 11 Sep 2003 07:58:44 -0400
Subject: [concurrency-interest] Lock & semaphore
In-Reply-To: <000b01c3785a$99d3a500$f0adf33e@kav>
References: <000b01c3785a$99d3a500$f0adf33e@kav>
Message-ID: <16224.25460.735862.914756@altair.cs.oswego.edu>

> I think it would be more consistent if _both_ lock and acquire either
> threw an interrupted exception or didn't.

In Java, "locking" vs "waiting" methods have the opposite defaults:
locking isn't interruptible; waiting is. Our APIs preserve this, but
also supply the non-default versions. Because Semaphores can play both
kinds of role, choosing the default here was a judgement call, but we
chose these versions because Semaphores will probably be more commonly
used for "waiting".  No matter which way we did this, it will seem
unnatural in some contexts.

-Doug


From dholmes@dltech.com.au  Thu Sep 11 13:05:35 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 11 Sep 2003 22:05:35 +1000
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <000701c37855$c1d39c90$f0adf33e@kav>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEAODHAA.dholmes@dltech.com.au>

Kasper Nielsen wrote:
> It seems as the javadoc for the offer method has just been
> copied from the Queue interface. What it makes it look like is that
> there is some kind of difference between the add-method and
offer-method
> because the later may return false if the offer didn't succed.

I don't understand what you perceive as the problem. The javadoc for
offer() hasn't been copied, it's been redefined to indicate that the
offer can't fail (ie return false). For an unbounded collection
offer() and add() have the same behaviour as they differ only in the
failure mode related to capacity restrictions.

David Holmes


From dholmes@dltech.com.au  Thu Sep 11 13:18:05 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 11 Sep 2003 22:18:05 +1000
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEAODHAA.dholmes@dltech.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEAODHAA.dholmes@dltech.com.au>

I wrote:
> I don't understand what you perceive as the problem. The
> javadoc for offer() hasn't been copied, it's been redefined
> to indicate that the offer can't fail (ie return false).
> For an unbounded collection offer() and add() have the same
> behaviour as they differ only in the failure mode related
> to capacity restrictions.


I just realized that Kasper may be looking at a packaged version of
the docs that has since been updated. The current docs are online at:

http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html

Sorry for any confusion.

David Holmes


From kav@it.edu  Thu Sep 11 13:55:30 2003
From: kav@it.edu (Kasper Nielsen)
Date: Thu, 11 Sep 2003 14:55:30 +0200
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEAODHAA.dholmes@dltech.com.au>
Message-ID: <000d01c37863$fb8ca5e0$f0adf33e@kav>

Actually I'm looking at the current version.

1.
If offer() and add() doesn't differ for ConcurrentLinkedQueue I can't
see why the javadoc for offer() should be any different from add(), by
looking at offer() alone it sounds like it might fail under certain
circumstances "Adds the specified element to this queue, if possible...
Returns: true if it was possible to add the element to this queue, else
false" and that add() will allways succeed "Adds the specified element
to the tail of this queue... Returns true (as per the general contract
of Collection.add)"

I also think it should be explicitly indicated that they do the same
thing, two methods that do exactly the same thing is allways suspicious.

2.
Btw: Why do some of the queues throw IllegalStateException (if this
queue is full) on add() when it can just return false?

The contract of Collection.add says
 Returns:
   true if this collection changed as a result of the call

So I can't see why we just can't indicate that a queue is full by
returning false.

- Kasper

> -----Original Message-----
> From: David Holmes [mailto:dholmes@dltech.com.au] 
> Sent: 11. september 2003 14:18
> To: Kasper Nielsen; concurrency-interest@altair.cs.oswego.edu
> Cc: Doug Lea
> Subject: RE: [concurrency-interest] Javadoc for offer method 
> in ConcurrentLinkedQueue
> 
> 
> I wrote:
> > I don't understand what you perceive as the problem. The 
> javadoc for 
> > offer() hasn't been copied, it's been redefined to indicate 
> that the 
> > offer can't fail (ie return false). For an unbounded collection 
> > offer() and add() have the same behaviour as they differ 
> only in the 
> > failure mode related to capacity restrictions.
> 
> 
> I just realized that Kasper may be looking at a packaged 
> version of the docs that has since been updated. The current 
> docs are online at:
> 
http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html

Sorry for any confusion.

David Holmes



From dl@cs.oswego.edu  Thu Sep 11 16:51:10 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 11 Sep 2003 11:51:10 -0400
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <000d01c37863$fb8ca5e0$f0adf33e@kav>
References: <NFBBKALFDCPFIDBNKAPCOEAODHAA.dholmes@dltech.com.au>
 <000d01c37863$fb8ca5e0$f0adf33e@kav>
Message-ID: <16224.39406.191331.123928@altair.cs.oswego.edu>

Methods add(x) and offer(x) differ in that the return values mean
different things. In add, a true return means that the collection
changed; in offer, it means thjat the element was added. The difference
IS somewhat subtle and confusing; suggestions for clarifying would
be welcome.

The return value for add(x) is only useful for Sets, where it tells
you whether an element was already present.  In a sequential program, it
is always the case that:
  c.add(x);
  assert(c.contains(x))
but only that
  if (c.offer(x)) 
    assert(c.contains(x))

And since add cannot "normally" refuse to add an element, it can
do so only by throwing an exception.

It might have been nice to somehow collapse these, but it cannot be done
without changing the specs for Collection.add, which could break
existing programs. (Interfaces are forever...)

-Doug

From dholmes@dltech.com.au  Fri Sep 12 00:29:16 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 12 Sep 2003 09:29:16 +1000
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <000d01c37863$fb8ca5e0$f0adf33e@kav>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBHDHAA.dholmes@dltech.com.au>

> Actually I'm looking at the current version.

Well now I'm really confused. The online docs give the following for
ConcurrentLinkedQueue.offer:

public boolean offer(E o)
  Adds the specified element to this queue.
Specified by:
  offer in interface Queue
Parameters:
  o - the element to add.
Returns:
  true (as per the general contract of Queue.offer).
Throws:
  NullPointerException - if the specified element is null

And this is what I referred to yesterday.

But my cvs copy does not contain this. Doug?

> 2. Btw: Why do some of the queues throw IllegalStateException (if
this
> queue is full) on add() when it can just return false?
>
> The contract of Collection.add says
>  Returns:
>    true if this collection changed as a result of the call
>
> So I can't see why we just can't indicate that a queue is full by
> returning false.

The contract for Collection.add also states:

"If a collection refuses to add a particular element for any reason
other than that it already contains the element, it *must* throw an
exception (rather than returning false). This preserves the invariant
that a collection always contains the specified element after this
call returns."

Hence it cannot return false on full.

David Holmes


From dl@cs.oswego.edu  Fri Sep 12 16:47:12 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 12 Sep 2003 11:47:12 -0400
Subject: [concurrency-interest] Javadoc for offer method in ConcurrentLinkedQueue
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBHDHAA.dholmes@dltech.com.au>
References: <000d01c37863$fb8ca5e0$f0adf33e@kav>
 <NFBBKALFDCPFIDBNKAPCOEBHDHAA.dholmes@dltech.com.au>
Message-ID: <16225.60032.681162.774579@altair.cs.oswego.edu>

> But my cvs copy does not contain this. Doug?

Sorry. You saw intermediate versions displayed while I was adjusting
javadocs to display right when j.u.c code is integrated with other
generic collection sources.

-Doug

From levmatta@uol.com.br  Fri Sep 12 20:40:27 2003
From: levmatta@uol.com.br (=?iso-8859-1?Q?Lu=EDs_Eduardo_V._Matta?=)
Date: Fri, 12 Sep 2003 16:40:27 -0300
Subject: [concurrency-interest] Real Time Java
Message-ID: <004401c37965$b7ed0ed0$0200a8c0@lepc>

This is a multi-part message in MIME format.

------=_NextPart_000_0041_01C3794C.92703B50
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

I apologize if this is out of the context of this list, but:

=20

I would like to know how this API relates RTJ (Real Time Java):

  - do they complement each other?

  - are they compatible?

  - where should I use each one?

=20

Some background on my needs...

=20

I want to implement a Java Petri Net all purpose API for my graduation =
project, it will be very simple (because of time constraints) but I =
believe much more satisfying then LADDER. Its not one of my goals to =
have it implement RTJ to all the real needs of a complete Petri Net =
embeddable software, but I will have to implement some Queues, IO, and =
it must have a emergency stop rotine. Therefore, I think I'm a good =
candidate user to both APIs.

=20

Any explanation on usage relating these topics are welcomed.

Thanks,

Lu=EDs Matta

=20

PS. If you don't know what LADDER is, but is curious to know how painful =
commercial controllers programming is, go to IEC. It really helps one to =
realize how fortunate we are to use Java.

PS2. I also apologize for English mistakes

------=_NextPart_000_0041_01C3794C.92703B50
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1226" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">I=20
apologize if this is out of the context of this list, but:</SPAN><SPAN=20
lang=3DEN-US style=3D"mso-ansi-language: EN-US"><?xml:namespace prefix =
=3D o ns =3D=20
"urn:schemas-microsoft-com:office:office" /><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><FONT size=3D3><FONT=20
face=3D"Times New Roman">&nbsp;<o:p></o:p></FONT></FONT></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">I would=20
like to know how this API relates&nbsp;RTJ (Real Time Java):</SPAN><SPAN =

lang=3DEN-US style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">&nbsp; -=20
do they complement each other?</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">&nbsp; -=20
are they compatible?</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">&nbsp; -=20
where should I use each one?</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><FONT size=3D3><FONT=20
face=3D"Times New Roman">&nbsp;<o:p></o:p></FONT></FONT></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">Some=20
background on my needs...</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><FONT size=3D3><FONT=20
face=3D"Times New Roman">&nbsp;<o:p></o:p></FONT></FONT></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">I want to=20
implement a Java Petri Net all purpose API for my graduation project, it =
will be=20
very simple (because of time constraints) but I believe much more =
satisfying=20
then LADDER. Its not one of my goals to have it implement RTJ to all the =
real=20
needs of a complete Petri Net embeddable software, but&nbsp;I will have =
to=20
implement some Queues, IO, and it must have a emergency stop rotine. =
Therefore,=20
I think I'm a good candidate user to both APIs.</SPAN><SPAN lang=3DEN-US =

style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><FONT size=3D3><FONT=20
face=3D"Times New Roman">&nbsp;<o:p></o:p></FONT></FONT></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">Any=20
explanation on usage relating these topics are welcomed.</SPAN><SPAN =
lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">Thanks,</SPAN><SPAN=20
lang=3DEN-US style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">Lu=EDs=20
Matta</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><FONT size=3D3><FONT=20
face=3D"Times New Roman">&nbsp;<o:p></o:p></FONT></FONT></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">PS. If you=20
don't know what LADDER is, but is curious to know how painful commercial =

controllers programming is, go to IEC. It really helps one to =
realize&nbsp;how=20
fortunate we are to use Java.</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: EN-US"><o:p></o:p></SPAN></P>
<P class=3DMsoNormal style=3D"MARGIN: 0cm 0cm 0pt"><SPAN lang=3DEN-US=20
style=3D"FONT-SIZE: 10pt; FONT-FAMILY: Arial; mso-ansi-language: =
EN-US">PS2. I=20
also apologize for English mistakes</SPAN><SPAN lang=3DEN-US=20
style=3D"mso-ansi-language: =
EN-US"><o:p></o:p></SPAN></P></FONT></DIV></BODY></HTML>

------=_NextPart_000_0041_01C3794C.92703B50--



From dholmes@dltech.com.au  Sun Sep 14 11:58:15 2003
From: dholmes@dltech.com.au (David Holmes)
Date: Sun, 14 Sep 2003 20:58:15 +1000
Subject: [concurrency-interest] Real Time Java
In-Reply-To: <004401c37965$b7ed0ed0$0200a8c0@lepc>
Message-ID: <NFBBKALFDCPFIDBNKAPCAECIDHAA.dholmes@dltech.com.au>

Luís Eduardo V. Matta wrote:

> I would like to know how this API relates RTJ (Real Time Java):
>  - do they complement each other?
>  - are they compatible?
>  - where should I use each one?

The two API's are largely orthogonal and so, to some extent,
complement each other. But not everything between them is compatible
in that certain parts of JSR-166 wouldn't make sense in a real-time
environment. The lock implementations provided in JSR-166 are based
mostly on performance considerations, not on scheduling
predictability, or priority inversion avoidance - you probably don't
want a "fair" anything in a real-time environment. Of course, you
could define RTSJ compatible implementations of things like
ReentrantLock, but it wouldn't be trivial to deal with priority
inversion issues.

Utilities like the Atomic classes can be useful in real-time
environment just to avoid the priority inversion problems of using
locks. Lock free and wait-free algorithms can also be of benefit for
the same reason.

Thread pools aka executors are still useful in RT environments, but
some of the details of policies might be different in such an
environment.

There is some overlap in things like scheduled tasks: JSR-166 has
scheduledExecutor while RTSJ supports periodic threads. But in each
case these were designed for an environment where the other did not
exist.


You are not likely to see a VM that supports both in the near future -
just my opinion, of course.

David Holmes


From adam@bea.com  Tue Sep 16 02:18:05 2003
From: adam@bea.com (Adam Messinger)
Date: Mon, 15 Sep 2003 18:18:05 -0700
Subject: [concurrency-interest] Instrumentation for locks
Message-ID: <9FC0BC94-E7E3-11D7-A034-000A9568414C@bea.com>

One feature which we've found to be quite useful in the locking classes 
we currently use in WebLogic Server, is the ability to interrogate 
locks/semaphores for the current/high-water-mark number of waiters and 
wait times.  In some cases this functionality can be obtained at 
little/no additional runtime cost.  In other cases it does have a 
slight impact.

This data lets us look at a system as a whole and understand where the 
bottlenecks are.  For instance we can determine if the problem is that 
there are not enough instances of an EJB or enough connections to the 
database and suggest that the administrator increase the appropriate 
limit.  While this is a specific example, I wonder if this task of 
bottleneck identification might not be common enough to be supported by 
the standard concurrency utilities?

Cheers!

Adam


From dl@cs.oswego.edu  Tue Sep 16 11:27:23 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 16 Sep 2003 06:27:23 -0400
Subject: [concurrency-interest] JSR166 passed JCP community review
Message-ID: <16230.58763.92713.625771@altair.cs.oswego.edu>

JSR166 passed JCP community review yesterday by a vote of 13 to 0.  We
plan to next submit for public review phase as soon as we can.

The related JSR133 (Java Memory Model) also passed by the same vote.

While I'm at it: The javadocs at the usual place,
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
are now generated by a somewhat improved (but still ad hoc) process
that includes enough existing genericized JDK classes (that are not of
course part of JSR166) to properly show "inherited" specs.  So
they are now a very close approximation of their intended forms. Which
means that we would now especially welcome comments about the details
of specs/javadocs, the pickier the better :-)

-Doug


From dl@cs.oswego.edu  Tue Sep 16 11:54:41 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 16 Sep 2003 06:54:41 -0400
Subject: [concurrency-interest] Instrumentation for locks
In-Reply-To: <9FC0BC94-E7E3-11D7-A034-000A9568414C@bea.com>
References: <9FC0BC94-E7E3-11D7-A034-000A9568414C@bea.com>
Message-ID: <16230.60401.568918.607791@altair.cs.oswego.edu>

Hi Adam,

> One feature which we've found to be quite useful in the locking classes 
> we currently use in WebLogic Server, is the ability to interrogate 
> locks/semaphores for the current/high-water-mark number of waiters and 
> wait times.  In some cases this functionality can be obtained at 
> little/no additional runtime cost.  In other cases it does have a 
> slight impact.

Thanks for the suggestion! Usually people who want lock monitoring ask
for so much of it that it really cannot and should not be supported in
an "ordinary" lock class.  But in our ReentrantLock class, it would
indeed be possible to generalize method isLocked to return an estimate
of the number of threads blocked, at no overhead cost for any other
operations. Unless we find some reason not to do it after thinking it
through some more, we will add method
getEstimatedNumberOfWaitingThreads (or some similar/better name).

In our current ReentrantLock implementation, getting a list of wait
times would not be possible, but I'll investigate to see if any simple
set of adjustments that don't otherwise impact performance could be
done here.

Similar functionality can be added to ReentrantLock.Condition,
although possibly not in such a usable/useful form. You need to hold a
lock to do anything at all with its condition; even to see if there
are any waiters. Which means that monitoring could interfere with
use. Plus, I worry a bit about the bad programming practices that
condition wait-queue inspection methods can lead to. It is almost
never correct to base any action on whether their are any waiters, yet
people might be very tempted to do this if we supply such a method.
What do you think?

Also, the ReentrantReadWriteLock class currently does not contain any
inspection methods. For uniformity, we may be able to add some
analogous methods.

-Doug

From dl@cs.oswego.edu  Tue Sep 16 12:56:05 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 16 Sep 2003 07:56:05 -0400
Subject: [concurrency-interest] Pausing Executors
In-Reply-To: <73C10A8E30ECD311ADAA00508B6693F00898B584@cfukexch04.ws.london.cantor.com>
References: <73C10A8E30ECD311ADAA00508B6693F00898B584@cfukexch04.ws.london.cantor.com>
Message-ID: <16230.64085.507724.719037@altair.cs.oswego.edu>

Hi Peter,

I hope you don't mind me CC'ing the JSR166 concurrency-interest list
on reply.

Your question/suggestion about dl.u.c PooledExecutor...

>    This allowed me to pause() the thread queue to ensure nothing was
> happening.  The pause() is called by a gui request, which is not a thread
> inside the pool. This allows me to ensure all the tasks in the queue stop
> cleanly in a way that can be resumed.  This was used to pause a game before
> saving its state. 

Since there are several possible senses and policies for what you
might mean by "pausing" (for example, whether multiple, "stacked"
pause/resumes are allowed), and pausing doesn't always mix nicely with
other tunable settings/policies, it would probably be a mistake to
build this into the main thread pool class. But in the JSR166
ThreadPoolExecutor version, you can to do something like this using
before/after hooks in a subclass. Here's one way to set up the
simplest policy, using JSR166 lock/condition classes, just for the
sake of illustration (in this case you could probably more easily just
use builtin sync):

class PausableThreadPoolExecutor extends ThreadPoolExecutor {
  private boolean isPaused;
  private ReentrantLock pauseLock = new ReentrantLock();
  private Condition unpaused = pauseLock.newCondition();

  protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    pauseLock.lock();
    try {
      while (isPaused) unpaused.await();
    } catch(InterruptedException ie) {
      Thread.currentThread().interrupt();
    } finally {
       pauseLock.unlock();
    }
  }

  public void pause() {
    pauseLock.lock();
    try {
      isPaused = true;
    } finally {
       pauseLock.unlock();
    }
  }

  public void resume() {
    pauseLock.lock();
    try {
      isPaused = false;
      unpaused.signalAll();
    } finally {
       pauseLock.unlock();
    }
  }
}

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From dl@cs.oswego.edu  Wed Sep 17 18:10:23 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 17 Sep 2003 13:10:23 -0400
Subject: [concurrency-interest] Instrumentation for locks
In-Reply-To: <16230.60401.568918.607791@altair.cs.oswego.edu>
References: <9FC0BC94-E7E3-11D7-A034-000A9568414C@bea.com>
 <16230.60401.568918.607791@altair.cs.oswego.edu>
Message-ID: <16232.38271.797024.503698@altair.cs.oswego.edu>

Adam (and anyone else interested in lock instrumentation),

I put out some tentative changes in ReentrantLock at:

http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/locks/ReentrantLock.html
http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/locks/ReentrantLock.ReentrantLockCondition.html

These establish what I hope is a useful basis for instrumentation and
monitoring without otherwise changing semantics or performance of main
locking methods. The monitoring-based ReentrantLock methods are also
pasted in below. (There are similar methods for Conditions).

The idea here, that we hadn't previously appreciated, is that most
people adding instrumentation do not want to make a full new
Lock/Condition class just to do so; they instead usually want to
subclass or adapt one of the standard ones. The new methods cannot
support all such usages, but I think should nicely support the most
common ones. If anyone believes otherwise, please let us know.

Thanks again for prodding us into this!


public boolean isLocked()
    Queries if this lock is held by any thread. This method is
    designed for use in monitoring of the system state, not for
    synchronization control.
    Returns:
        true if any thread holds this lock and false otherwise.

public int getLockQueueLength()
    Returns an estimate of the number of threads waiting to acquire
    this lock. The value is only an estimate because the number of
    threads may change dynamically while this method traverses
    internal data structures. This method is designed for use in
    monitoring of the system state, not for synchronization control.
    Returns:
        the estimated number of threads waiting for this lock

protected Collection getQueuedThreads()
    Returns a collection containing threads that may be waiting to
    acquire this lock. Because the actual set of threads may change
    dynamically while constructing this result, the returned
    collection is only a best-effort estimate. The elements of the
    returned collection are in no particular order. This method is
    designed to facilate construction of subclasses that provide more
    extensive lock monitoring facilities.
    Returns:
        the collection of threads

protected Thread getCurrentOwner()
    Returns the thread that currently owns the lock, or null if not
    owned. Note that the owner may be momentarily null even if there
    are threads trying to acquire the lock but have not yet done
    so. This method is designed to facilate construction of subclasses
    that provide more extensive lock monitoring facilities.
    Returns:
        the owner, or null if not owned.

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From dl@cs.oswego.edu  Fri Sep 26 17:41:34 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 26 Sep 2003 12:41:34 -0400
Subject: [concurrency-interest] JSR166 going into public review
Message-ID: <16244.27710.375710.860981@altair.cs.oswego.edu>

The version of JSR-166 spec at (the usual place),
  http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
was just submitted for JCP public review. (It will probably take a few
days to show up at JCP.org)

All differences from the Community Review version are minor.  Most
changes are javadoc spec clarifications and improvements. Also, there
are a few new convenience methods for atomics and TimeUnit, some
instrumentation methods for ReentrantLock, and some minor refactorings
in ScheduledExecutor.

As always, we welcome all comments, critiques, and suggestions.  As we
continue to push toward final spec, major changes become less likely,
but we remain happy to take people up on good ideas that we can find
some way to accommodate.

-Doug

From Andreas.Sterbenz@Sun.COM  Fri Sep 26 18:33:53 2003
From: Andreas.Sterbenz@Sun.COM (Andreas Sterbenz)
Date: Fri, 26 Sep 2003 18:33:53 +0100
Subject: [concurrency-interest] ThreadPoolExecutor
Message-ID: <3F747881.5000304@sun.com>

Hi,

I was just looking at ThreadPoolExecutor and I think it really needs a 
constructor with less than the 5 arguments it requires now for EOU in 
unsophisticated applications (currently: 
http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/ThreadPoolExecutor.html#constructor_summary 
).

I believe adding some subset of

ThreadPoolExecutor()
ThreadPoolExecutor(int corePoolSize)
ThreadPoolExecutor(int corePoolSize, BlockingQueue<Runnable> workQueue)

would be reasonable.

Andreas.



From dl@cs.oswego.edu  Fri Sep 26 18:39:12 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 26 Sep 2003 13:39:12 -0400
Subject: [concurrency-interest] ThreadPoolExecutor
In-Reply-To: <3F747881.5000304@sun.com>
References: <3F747881.5000304@sun.com>
Message-ID: <16244.31168.149180.477682@altair.cs.oswego.edu>

> I was just looking at ThreadPoolExecutor and I think it really needs a 
> constructor with less than the 5 arguments it requires now for EOU in 
> unsophisticated applications (currently: 

Thanks. This tells us that we are not doing a good job of immediately
directing your attention to the Executors factory methods:
 http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/Executors.html

Any suggestions about how we could do so?!

-Doug


From joshua.bloch@sun.com  Fri Sep 26 18:56:04 2003
From: joshua.bloch@sun.com (Joshua Bloch)
Date: Fri, 26 Sep 2003 19:56:04 +0200
Subject: [concurrency-interest] ThreadPoolExecutor
In-Reply-To: <16244.31168.149180.477682@altair.cs.oswego.edu>
References: <3F747881.5000304@sun.com> <16244.31168.149180.477682@altair.cs.oswego.edu>
Message-ID: <3F747DB4.4030006@sun.com>

Doug,

>>I was just looking at ThreadPoolExecutor and I think it really needs a 
>>constructor with less than the 5 arguments it requires now for EOU in 
>>unsophisticated applications (currently: 
>>    
>>
>
>Thanks. This tells us that we are not doing a good job of immediately
>directing your attention to the Executors factory methods:
> http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/Executors.html
>
>Any suggestions about how we could do so?!
>
A big, boldface (<strong></strong>) comment in all implementations 
classes pointing you to the appropriate static factory with a {@link} tag!

           Josh



From kav@kav.dk  Fri Sep 26 23:35:50 2003
From: kav@kav.dk (Kasper Nielsen)
Date: Sat, 27 Sep 2003 00:35:50 +0200
Subject: [concurrency-interest] LinkedBlockedQueue
Message-ID: <000201c3847e$89ea5f50$f0adf33e@kav>

Hi,

I was looking at the toArray() methods in LinkedBlockingQueue 

1.
Any reason why we set first.item = null in extract() but not in
toArray()

2.
Looking at the code,
        fullyLock();
        try {
            int size = count.get();
            Object[] a = new Object[size];
            int k = 0;
            for (Node<E> p = head.next; p != null; p = p.next)
                a[k++] = p.item;
            return a;
        } finally {
            fullyUnlock();
        }

I was wondering why the lock was kept all the time why not just
something like

	  Object[] a;
        Node<E> oldhead;        
        fullyLock();
        try {
            int size = count.get();
            a = new Object[size];
            oldHead=head;
           last = head = new Node<E>(null);
        } finally {
            fullyUnlock();
        }
            int k = 0;
            for (Node<E> p = oldHead.next; p != null; p = p.next)
                a[k++] = p.item;
            return a;

3.
Would be nice with some methods
  poll(int numberOfElements)
  poll(int numberOfElements, long time,TimeUnit unit)
  pollAll (long time,TimeUnit unit) (same as toarray() but blocking)
These methods would be usefull when using it as a queue of events to be
processed. 
Sometimes I would need a large batching factor (higher cache locality &
higher throughput) and sometimes a low (lower response time) by being
able to specify how many elements I wanted to fetch I could accomplish
this.


4. Javadoc corrections
In all classes except Semaphore & Future its TimeUnit unit instead of
TimeUnit granularity

- Kasper


From dl@cs.oswego.edu  Sat Sep 27 00:43:32 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 26 Sep 2003 19:43:32 -0400
Subject: [concurrency-interest] LinkedBlockedQueue
In-Reply-To: <000201c3847e$89ea5f50$f0adf33e@kav>
References: <000201c3847e$89ea5f50$f0adf33e@kav>
Message-ID: <16244.53028.246325.4579@altair.cs.oswego.edu>

Hi Kasper,

> I was looking at the toArray() methods in LinkedBlockingQueue 

I think you misinterpreted this method. It does not extract elements
into the array; it copies them (as do all other Collection.toArray
methods).

I think this accounts for your confusion about questions 1-2.

I gather that what you are looking for is a non-existent method
  <T> T[] drain(T[] array)
and/or  
  void drain(Collection<E> c, int maxElements)
that drains (i.e., removes) up to maxElements elements into an array
or collection.  (It would need to be non-blocking, poll-like rather
than take-like, or else multiple drain's could be starved out unless
there were uniform fairness guarantees across queues, which there
aren't.  This is analogous to why FairSemaphore supports acquire(n),
but non-guaranteed-fair Semaphore does not.)

Could you give a compelling use case or two showing why you need
something like this?  Can anyone else?

> 4. Javadoc corrections
> In all classes except Semaphore & Future its TimeUnit unit instead of
> TimeUnit granularity

Thanks! Yes, we should change these to be consistent.

-Doug

From kav@kav.dk  Sat Sep 27 09:52:11 2003
From: kav@kav.dk (Kasper Nielsen)
Date: Sat, 27 Sep 2003 10:52:11 +0200
Subject: [concurrency-interest] LinkedBlockedQueue
In-Reply-To: <16244.53028.246325.4579@altair.cs.oswego.edu>
Message-ID: <000101c384d4$a4623aa0$f0adf33e@kav>

> > I was looking at the toArray() methods in LinkedBlockingQueue
> 
> I think you misinterpreted this method. It does not extract 
> elements into the array; it copies them (as do all other 
> Collection.toArray methods).

I most certainly have.. And its not the first time I tend to forget that
this queue also has collection semantics and not just ordinary queue
semantics.

> I think this accounts for your confusion about questions 1-2.
> 
> I gather that what you are looking for is a non-existent method
>   <T> T[] drain(T[] array)
> and/or  
>   void drain(Collection<E> c, int maxElements)
> that drains (i.e., removes) up to maxElements elements into 
> an array or collection.  (It would need to be non-blocking, 
> poll-like rather than take-like, or else multiple drain's 
> could be starved out unless there were uniform fairness 
> guarantees across queues, which there aren't.  This is 
> analogous to why FairSemaphore supports acquire(n), but 
> non-guaranteed-fair Semaphore does not.)
> 
> Could you give a compelling use case or two showing why you 
> need something like this?  Can anyone else?

Can't speak for others, but I use queues to introduce an isolated
execution boundary in my application. The units of work enqueued on each
queue are small and fast to compute so I would like to process a big
batch (say 100-1000) of events each time. If I need to poll each single
element I would pay a penalty both in form of acquiring/releasing a lot
of locks and in form of a lot of switches between unrelated pieces of
code, thereby destroying the program locality (caching/ branch
predictors).

- Kasper


From dl@cs.oswego.edu  Tue Sep 30 01:11:56 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 29 Sep 2003 20:11:56 -0400
Subject: [concurrency-interest] LinkedBlockedQueue
In-Reply-To: <000101c384d4$a4623aa0$f0adf33e@kav>
References: <16244.53028.246325.4579@altair.cs.oswego.edu>
 <000101c384d4$a4623aa0$f0adf33e@kav>
Message-ID: <16248.51788.181665.873376@altair.cs.oswego.edu>

> > I gather that what you are looking for is a non-existent method
> >   <T> T[] drain(T[] array)
> > and/or  
> >   void drain(Collection<E> c, int maxElements)
> > that drains (i.e., removes) up to maxElements elements into 
> > an array or collection.  
> >
> > Could you give a compelling use case or two showing why you 
> > need something like this?  Can anyone else?
> 
> Can't speak for others, but I use queues to introduce an isolated
> execution boundary in my application. The units of work enqueued on each
> queue are small and fast to compute so I would like to process a big
> batch (say 100-1000) of events each time. If I need to poll each single
> element I would pay a penalty both in form of acquiring/releasing a lot
> of locks and in form of a lot of switches between unrelated pieces of
> code, thereby destroying the program locality (caching/ branch
> predictors).

While I can see the benefit, I'm waiting to see if someone else on
this list says "yes I really need this". Otherwise, the amount of
effort to add this to all BlockingQueues is hard to justify for a
specialized usage.

-Doug


