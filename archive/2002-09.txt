From paul@paulhaahr.com Sun,  1 Sep 2002 15:56:58 -0700 (PDT)
Date: Sun,  1 Sep 2002 15:56:58 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Structure and function

I'll offer a split opinion.

> * There's no Mutex because the combination of ReentrantLock and
> Semaphore(1) hits all the common cases that arise. 

As I said before, I think there's good reasons for a Mutex which is
separate for Semaphore(1), if only because two releases after a single
acquire can be made an error with a Mutex.  (Semaphores with upper
bounds on the number of outstanding permits (releases) would also fit
the bill for me.)

> * ThreadPool is the only implementation of Executor we supply.  Even
> though there are several other niche Executors that people might want
> to build (e.g., one that does remote execution, or one that maintains
> multiple queues to manage QoS), all of the "normal" common ones can be
> somehow obtained via ThreadPool. For example, you'd always prefer
> ThreadPool.fixedThreadPool(1) to something like a suitably revamped
> dl.u.c.QueuedExecutor.

I really liked the design of ThreadPool/ThreadExecutor and the static
factory methods for the idiomatic cases.  I would like to see an added
predefined factory method:

  variableThreadPool(int maxThreads, long keepAliveTime, Clock granularity)

equivalent to a fixed thread pool but with the given keepAliveTime and
granularity and a minThreads of 0.  That's the type of pool I ended up
using most often at a previous employer and they worked very well.
(Especially with an ExecutorInterceptor-like handler that reported the
count of number of live threads.)

(The name I see in the docs is ThreadExecutor, but I really prefer
ThreadPool.  I don't think using an implementation name that differs
from the interface name should be a problem here.)

On the other hand, DelayableThreadPool is really a terrible name.  I
don't mind the conflation of all the functionality in that one class (in
fact, I really like it), I just don't think ``Delayable'' conveys that
functionality.  ``TimerBased...'' is a little better, but I don't like
that either.  Anyone have a suggestion they like?

--p




From crahen@cse.Buffalo.EDU Sun, 1 Sep 2002 19:28:02 -0400 (EDT)
Date: Sun, 1 Sep 2002 19:28:02 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

On Sun, 1 Sep 2002, Paul Haahr wrote:

> On the other hand, DelayableThreadPool is really a terrible name.  I
> don't mind the conflation of all the functionality in that one class (in
> fact, I really like it), I just don't think ``Delayable'' conveys that
> functionality.  ``TimerBased...'' is a little better, but I don't like
> that either.  Anyone have a suggestion they like?

I think the name isn't all that bad. Its a ThreadExecutor that executes
tasks with a delay. So it seems pretty decent. The only other word that
comes to mind other than Delayed is Scheduled - but I don't think its much
better than the name it has now really.

I like the Executor name better then the Pool one ;)

- Eric
http://www.cse.buffalo.edu/~crahen





From crahen@cse.Buffalo.EDU Sun, 1 Sep 2002 19:32:46 -0400 (EDT)
Date: Sun, 1 Sep 2002 19:32:46 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Structure and function

I like the new ExecutorIntercepts class, I think that fits much better
standing on its own as an interface rather than being bound to the
ThreadExecutor. My only question about this is should it really extend the
ThreadFactory class? I'm thinking of the familiy of non-threaded Executors
that would be able to make use of intercepts but really have no need to
ever actually produce a thread directly.

- Eric
http://www.cse.buffalo.edu/~crahen





From dl@cs.oswego.edu Sun, 1 Sep 2002 19:37:43 -0400
Date: Sun, 1 Sep 2002 19:37:43 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Structure and function

Paul, thanks for the suggestions. A few followups from your last
few messages:

> I really liked the design of ThreadPool/ThreadExecutor and the static
> factory methods for the idiomatic cases.  I would like to see an added
> predefined factory method:
> 
>   variableThreadPool(int maxThreads, long keepAliveTime, Clock granularity)

I agree it is useful. Pick a really good name, and we'll consider
adding it to collection of factory methods.  ("Variable" doesn't
immediately reflect what it is that is variable.)

> 
> (The name I see in the docs is ThreadExecutor, but I really prefer
> ThreadPool.  I don't think using an implementation name that differs
> from the interface name should be a problem here.)

Every time I change it from one name to the other people complain!
Can't win...

> 
> On the other hand, DelayableThreadPool is really a terrible name.  

We know that. The class is begging to be given a better name.
Please save us.

> Fair enough, but there's utility for a mutex construct that can be
> passed from thread to thread but has a max release count of 1.
> Conflating the two concepts (acquire-here/release-there and variable
> number of tickets) in Semaphores, while also grounded in historical
> practice, doesn't provide much help to the user.
> 

Note that we decided NOT to make Semaphore implement Lock any more,
mainly to avoid confusion about the senses in which acquire/release
gives you locking.

There are too many choices for non-rentrant semantics to settle on a
particular recommended implementation to include it in j.u.c.  We've
tentatively decided just to leave them all out, since anyone who knows
enough to have a preference about semantics is very likely to be able
to implement a custom Lock class themselves; for example, just
delegate to Semaphore(1), or intercept around a ReentrantLock.

> Consider me biased, however:  I never met a semaphore I liked.  They've
> always seemed an obfuscating construct.

Concurrent programmers have eclectic tastes. (Mine: counting
semaphores have several elegant, classic usages, but also have many
ugly abuses seen in systems where they they are the only sync
primitive. I'm hoping that people just use the elegant designs :-)

> Given that, I suggest that the term you're looking for is ``stable,'' by
> analogy to stable sorting, to describe priority queues which preserve
> FIFO order.
> 

Yes, thanks!

-Doug




From dl@cs.oswego.edu Sun, 1 Sep 2002 19:44:27 -0400
Date: Sun, 1 Sep 2002 19:44:27 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]Structure and function

Eric  Crahen wrote:

> I like the new ExecutorIntercepts class, I think that fits much better
> standing on its own as an interface rather than being bound to the
> ThreadExecutor. My only question about this is should it really extend the
> ThreadFactory class?

This is mainly just definitional: ThreadFactory has only "newThread",
which is (and always has been) also in ExecutorIntercepts. The
ThreadFactory superinterface is useful in itself (not just in
conjunction with Executors) so is now split out so you can implement
one without having to buy into the Executor framework. Can you think
of any use cases where any of this is a problem? We couldn't.

-Doug





From crahen@cse.Buffalo.EDU Sun, 1 Sep 2002 20:11:33 -0400 (EDT)
Date: Sun, 1 Sep 2002 20:11:33 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Structure and function

On Sun, 1 Sep 2002, Doug Lea wrote:

> This is mainly just definitional: ThreadFactory has only "newThread",
> which is (and always has been) also in ExecutorIntercepts. The
> ThreadFactory superinterface is useful in itself (not just in
> conjunction with Executors) so is now split out so you can implement
> one without having to buy into the Executor framework. Can you think
> of any use cases where any of this is a problem? We couldn't.

I don't think the ThreadFactory interface being separate is a problem at
all, its definently useful on its own. I was wondering if it was
neccessary for an ExecutorIntercepts to actually be a ThreadFactory. The
reason was that I'm thinking of a RemoteExecutor, or a LockedExecutor or
some other Executor that may not ever actually need to create a Thread
directly but would still be able to find alot of use for the before and
after methods of ExecutorIntercepts interface. For those non-threaded
Executors it seemed sort of strange to provide them with a ThreadFactory
(an intercept object w/ newThread) when they never really need it. For
non-threaded executors, all they'd need would be the methods doing the
intercepting. I think that maybe keeping the ThreadFactory & the
ExecutorIntercepts interfaces separate would be clearer since they are
functionaly different and the one (intercepts) may not always need the
other (factory).


- Eric
http://www.cse.buffalo.edu/~crahen





From brian@quiotix.com Sun, 01 Sep 2002 17:41:48 -0700
Date: Sun, 01 Sep 2002 17:41:48 -0700
From: Brian Goetz brian@quiotix.com
Subject: [concurrency-interest] Structure and function

> >   variableThreadPool(int maxThreads, long keepAliveTime, Clock granularity)
>
>I agree it is useful. Pick a really good name, and we'll consider
>adding it to collection of factory methods.  ("Variable" doesn't
>immediately reflect what it is that is variable.)

expandableThreadPool

> > On the other hand, DelayableThreadPool is really a terrible name.
>
>We know that. The class is begging to be given a better name.
>Please save us.

SchedulingThreadPool?  SchedulableThreadPool? 
ThreadPoolThatCanAlsoRunTimerTasks?  :)



--
Brian Goetz
Quiotix Corporation
brian@quiotix.com           Tel: 650-843-1300            Fax: 650-324-8032

http://www.quiotix.com





From paul@paulhaahr.com Sun,  1 Sep 2002 20:44:32 -0700 (PDT)
Date: Sun,  1 Sep 2002 20:44:32 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Structure and function

> >   variableThreadPool(int maxThreads, long keepAliveTime, Clock granularity)
> 
> I agree it is useful. Pick a really good name, and we'll consider
> adding it to collection of factory methods.  ("Variable" doesn't
> immediately reflect what it is that is variable.)

I picked ``variable'' by analogy to ``fixed,'' which doesn't seem to
make clear what's fixed, either.  Perhaps ``variableSized...'' or
``limited...''?

> > (The name I see in the docs is ThreadExecutor, but I really prefer
> > ThreadPool.  I don't think using an implementation name that differs
> > from the interface name should be a problem here.)
> 
> Every time I change it from one name to the other people complain!
> Can't win...

(That's what committees are like.  Naming decisions are things everyone
can understand, so everyone offers an opinion.)

> > On the other hand, DelayableThreadPool is really a terrible name.  
> 
> We know that. The class is begging to be given a better name.

I think Eric's suggestion of ``Scheduled...'' is excellent (even if I
disagree with him about ThreadPool vs. ThreadExecutor).

> Note that we decided NOT to make Semaphore implement Lock any more,
> mainly to avoid confusion about the senses in which acquire/release
> gives you locking.

I think that's good, though fairly subtle.  It seems to conflict with
the idea of using Semaphore(1) directly as a non-reentrant lock.

> There are too many choices for non-rentrant semantics to settle on a
> particular recommended implementation to include it in j.u.c.  We've
> tentatively decided just to leave them all out,

I think this is a shame.

> since anyone who knows enough to have a preference about semantics is
> very likely to be able to implement a custom Lock class themselves;
> for example, just delegate to Semaphore(1), or intercept around a
> ReentrantLock.

Seems like a lot of work to get what I'd consider the simplest possible
mutual exclusion construct.  It's like saying, ``We'll give you
multiplication, logarithms, and exponentiation; you can build addition
from those if you want it.''

> > Consider me biased, however:  I never met a semaphore I liked.  They've
> > always seemed an obfuscating construct.
> 
> Concurrent programmers have eclectic tastes. (Mine: counting
> semaphores have several elegant, classic usages, but also have many
> ugly abuses seen in systems where they they are the only sync
> primitive. I'm hoping that people just use the elegant designs :-)

I've mostly seen the non-elegant uses.  I always attributed their
prevalence to the fact that they were the first mutual exclusion
primitive which were described publicly.

A note to the effect of

  Semaphores are provided for algorithms in which they are the natural
  tool.  Often subclasses of Lock provide similar funcionality to
  Semaphores in an easier to use form.

would be nice in the Semaphore documentation.  Such a note, though,
might conflict with using Semaphore(1) as a non-reentract lock.

BTW, these are niggling details.  I should mention that I really like
the package overall and am looking forward to being able to count on it
being there.

--p




From dholmes@dltech.com.au Mon, 2 Sep 2002 14:36:42 +1000
Date: Mon, 2 Sep 2002 14:36:42 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

Paul Haahr wrote:
> I think that's good, though fairly subtle.  It seems to
> conflict with
> the idea of using Semaphore(1) directly as a non-reentrant lock.

We decided that making Semaphore a Lock was catering for the very
small section of the community that not-only wanted to use a binary
semaphore as a Lock (either for it's non-reentrant property, or the
ability to release other than by the 'owner'), but also wanted that
usage to be interchangeable with different types of Lock. This need
seemed small compared to the confusion that can be caused by equating
Semaphores with Locks.

This decision was made after the discussion that took place on this
list.

> Seems like a lot of work to get what I'd consider the
> simplest possible mutual exclusion construct.

There are two things that people are asking for:
 - non-reentrant locks
 - locks that can be released by a thread other than the owner

These properties are independent, but you're more likely to want the
second with a non-reentrant lock.

People tend to ask for non-reentrant locks for three reasons that I've
seen:

a) It's what they are familiar with from other systems (mainly because
they accept the default type of a pthreads mutex :) )

b) They want to detect errors where a lock is unintentionally acquired
more than once

c) They perceive that a non-reentrant lock must be faster/better than
a reentrant one.

Point c) is probably not going to be the case here. The intrinsic lock
support in a JVM is a reentrant lock and that is what we see being
optimised. We don't envisage (but don't prohibit) VM's expending
effort making non-reentrant locks fast - *especially* when you take
into account that these locks must also be interruptible hence
preventing direct native implementation.

Point b) is realized either through deadlocks or, if supported,
error-checking lock versions that can report the error. This effect is
easily mimicked using a wrapper on a ReentrantLock:

class NonReentrantLock implements Lock {
   ReentrantLock l = new ReentrantLock();
   void lock() {
      if (l.getHoldCount() == 1) {
         // spin forever or throw an exception
      }
      l.lock();
   }

 ...
}

Given the optimisation for ReentrantLock that is envisaged, this might
well outperform a version written using wait/notify directly - but
that's just my opinion.

Should we provide this wrapper? What should we call it? [People keep
asking for a Mutex but what flavour of Mutex would it be?]

Point a) is addressed through good documentation which will convince
people that unless they really need b) then a ReentrantLock will work
just fine.

The need to release a lock held by another thread is far more rarely
needed and very context dependent. We couldn't build one on top of
ReentrantLock so we wouldn't get the optimisation benefit there. You
could use a Semaphore instead - as long as you don't also want to
prevent unintentional releases. Should we try and provide
implementations for this? Reentrant or NonReentrant, or both? How
about the WriteLock as well? We could end up with a group of lock
implementations that are only needed in rare circumstances but the
presence of which greatly decreases the understandability and
ease-of-use of the package. I'm more inclined to let people define
their own locks for this, if using a Semaphore is not suitable for
them.

> I've mostly seen the non-elegant uses.  I always attributed their
> prevalence to the fact that they were the first mutual exclusion
> primitive which were described publicly.

Ahh you see that is the root of the problem. A Semaphore is not a
mutual exclusion primitive - it is a state, or condition
synchronization primitive. Mutual exclusion using a semaphore is only
achieved by using the semaphore in a particular restricted way. In
essence a Semaphore is a mutual exclusion capability, plus a condition
queue, plus a counter - all neatly packaged together.
:)

> A note to the effect of
>
>   Semaphores are provided for algorithms in which they are
> the natural
>   tool.  Often subclasses of Lock provide similar funcionality to
>   Semaphores in an easier to use form.
>
> would be nice in the Semaphore documentation.  Such a note, though,
> might conflict with using Semaphore(1) as a non-reentract lock.

The documentation will be quite detailed and extensive, clarifying the
usage and purpose of each of the components. We want people to
understand not just what they do but when/why they might want to use
one.

Cheers,
David Holmes





From paul@paulhaahr.com Mon,  2 Sep 2002 03:03:30 -0700 (PDT)
Date: Mon,  2 Sep 2002 03:03:30 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Structure and function

David Holmes wrote
> There are two things that people are asking for:
>  - non-reentrant locks
>  - locks that can be released by a thread other than the owner
> 
> These properties are independent, but you're more likely to want the
> second with a non-reentrant lock.

Yes.  Talking about lock passing/stealing first, I've used one system
where that was part of the toolset, and it did make some sense.
However, debugging in it only became possible when we made the handoff
an explicit operation, by threads that said either ``I'm going to let
someone else take this lock from me'' or ``I'm going to steal this lock
which thread x acquired.''

While I was initially sympathetic to this argument for putting
non-reentrant locks into JSR 166, I withdraw that sympathy, because lock
stealing is so easily done wrong.  Semaphores should address that need
most of the time.

> People tend to ask for non-reentrant locks for three reasons that I've
> seen:
> 
> a) It's what they are familiar with from other systems (mainly because
> they accept the default type of a pthreads mutex :) )
> 
> b) They want to detect errors where a lock is unintentionally acquired
> more than once
> 
> c) They perceive that a non-reentrant lock must be faster/better than
> a reentrant one.

I like this taxonomy.  The only relevant point, I think, is (b), though
I'd generalize the statement to ``errors where a lock is acquired or
released an incorrect number of times.''

I'm less sanguine than you about general deadlock detection tools, but
will cede the point.  I'm pretty happy with the tools recent VMs have
provided, but a little more concerned with JSR 166, because locks no
longer necessarily follow stack discipline.  That makes the existing
tools less useful.

Nonetheless, I think I've been convinced that point (b) isn't a big
enough reason to justify such a built-om class.


[On semaphores, tangentially:]

> A Semaphore is not a mutual exclusion primitive - it is a state, or
> condition synchronization primitive. Mutual exclusion using a
> semaphore is only achieved by using the semaphore in a particular
> restricted way. In essence a Semaphore is a mutual exclusion
> capability, plus a condition queue, plus a counter - all neatly
> packaged together.  :)

Thank you.  I took that as a cue to reread the appendix to

  The Structure of the ``THE''-Multiprogramming System
  Edsger W. Dijkstra
  CACM, Volume 11 / Number 5 / May, 1968

available at

  http://www.acm.org/classics/mar96/
  http://www.deas.harvard.edu/courses/cs261/papers/theTHE.pdf

I had forgotten the whole ``private semaphores'' section, which
establishes a very clever convention inside the THE kernel:

  Whenever a process reaches a stage where the permission for dynamic
  progress depends on current values of state variables, it follows the
  pattern:

  P(mutex);
  ``inspection and modification of state variables including a conditional
  V(private semaphore)'';
  V(mutex);
  P(private semaphore).

  If the inspection learns that the process in question should continue,
  it performs the operation ``V (private semaphore)''- the semaphore value
  then changes from 0 to 1 - otherwise, this V-operation is skipped,
  leaving to the other processes the obligation to perform this
  V-operation at a suitable moment. The absence or presence of this
  obligation is reflected in the final values of the state variables upon
  leaving the critical section.

While it's not the way I would structure things given the full set of
tools that, say, JSR 166 provides, it does remind one that semaphores
are a good single primitive:  you can build anything on top of them but,
more importantly, you can use them directly to do quite a lot.

I see Doug's elegance point.

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 03:48:57 -0700 (PDT)
Date: Mon,  2 Sep 2002 03:48:57 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest]Callables, Runnables, Executors, & Futures

The basic functionality of Executors is, I think, right on target.
However, I've got some issues.


1 - Callables shouldn't take an argument.

  Unlike Runnables, Callables take a single argument of type Object.
  Why?  How many naturally-written callables will take precisely one
  argument?

  Since callables will typically be created as inner classes, there
  doesn't appear to be any benefit to passing the argument.  Instead,
  that's exactly what closing over arguments is ideally suited to.

  More importantly, that's exactly what programmers will expect, given
  experience with Runnables.  Why change something so well understood
  to something that's reminiscent of C's ubiquitous void *args?

  I suspect there's some thinking that, with generics, passing in a
  single argument might not be as bad, because it could have arbitrary
  reference type.  But, I don't buy it.  I see lots of ignored null
  parameters being passed around.

  (Mark D. Anderson and I raised this point when this list started, but
  I don't think anybody from the EG ever commented.)


2 - executeAsFuture is a hack

  I don't see the point of executeAsFuture.  I think it's equivalent to
  wrapping a runnable inside a Callable, along the lines of:

    execute(new Callable {
      void call(Object ignored) {
	runnable.run();
        return Boolean.TRUE;
      }, null);

  but giving it a separate function in the executor confuses what it's
  doing.  I'd much rather see a convenience class (CallRunnable?) which
  provides that wrapper.


3 - DelayableThreadExecutor always produces Futures

  All the non-inherited methods on DelayableThreadExecutor supposedly
  produce Futures.  I'm not sure why, because:

    - In six cases, they take Runnables but produce Futures.  This
      implies a hidden executeAsFuture step.  Why bother?

    - In four cases (execute{AtFixedRate,Periodically}), multiple
      computations are hidden behind a single Future, so it's not clear
      what you're waiting for if you wait for the future to complete.
      The first execution?  One which throws an exception?

  I suspect that what's going on here is that the future is used to
  collect exceptions which occur inside the runnable, but it seems like
  the wrong interface for doing so.  (I'd rather supply a queue, for
  example, which receives pairs of (Runnable, Exception) for the
  periodic tasks, if that functionality is needed.)

  Perhaps cancellation is really what this is about?  If so, I'd rather
  have an explicit cancellation API, though, for my purposes, just
  shutting down the executor should be sufficient.

  Given what I know now, though, I'd prefer to see the interface
  simplified to:

    Future executeAfter(Callable callable, Date time)
    Future executeAfter(Callable callable, long delay, Clock unit)
    void executeAfter(Runnable task, Date time)
    void executeAfter(Runnable task, long delay, Clock unit)
    void executeAtFixedRate(Runnable task, Date first, long period, Clock unit)
    void executeAtFixedRate(Runnable task, long delay, long period, Clock unit)
    void executePeriodically(Runnable task, Date first, long period, Clock unit)
    void executePeriodically(Runnable task, long delay, long period, Clock unit)

  For execute{AtFixedRate,Periodically}, it's probably necessary to
  specify the behavior when an exception is thrown:  does the period
  task run again at its next scheduled time or does it stop running
  after the first exception?

  Apologies if I'm drawing incorrect conclusions.  The APIs don't say
  enough here, I'm afraid, or I'm missing something.


4 - What are the elements of the queues for ThreadExecutors?

  When creating a thread pool, one gets to decide what form of blocking
  queue is used.  This does let one decide on fixed-length vs. linked
  list vs. synchronous style, but misses what I thought would be a key
  point for such queues:  priority.  It appears that if I want to have
  priority queues for the tasks fed into an executor, I need to have two
  queues and an extra thread.  Seems awkward.

  If possible, I'd like to see a specification of an interface that the
  elements of the queue obeyed, which allowed one to extract the
  Callable or Runnable and use that in a comparator for a priority queue.


5 - Can we have a common ancestor of Callable and Runnable?

  I don't know what to call it, but there's probably a useful common
  superinterface we can invent to allow uniform handling (in places like
  Executors) of Callables and Runnables.  Perhaps ``Invokable''?

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 03:25:09 -0700 (PDT)
Date: Mon,  2 Sep 2002 03:25:09 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest]UnboundedArrayBlockingQueue

My personal favorite queue implementation appears to be missing from
JSR166:  an unbounded but array-backed blocking queue.  Implementation
is easy:  a circular buffer that resizes the underlying arrays.

I like it because there's no size limit which causes adding an element
to block for long periods of time (unlike ArrayBlockingQueue) and
there's no per-element consing overhead (unlike LinkedBlockingQueue).

Anyone else miss this?

--p




From crahen@cse.Buffalo.EDU Mon, 2 Sep 2002 07:35:29 -0400 (EDT)
Date: Mon, 2 Sep 2002 07:35:29 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]UnboundedArrayBlockingQueue

On Mon, 2 Sep 2002, Paul Haahr wrote:

> I like it because there's no size limit which causes adding an element
> to block for long periods of time (unlike ArrayBlockingQueue) and
> there's no per-element consing overhead (unlike LinkedBlockingQueue).

The LinkedBlockingQueue is wait-free so it would tend to involve less time
and synchronization overhead (because it avoids typical synchronization
primatives) than a synchronized array-based queue when items are added. Is
the consing overhead your concerned about the allocation of a node of some
kind for each item?

- Eric
http://www.cse.buffalo.edu/~crahen





From dl@cs.oswego.edu Mon, 2 Sep 2002 07:44:42 -0400
Date: Mon, 2 Sep 2002 07:44:42 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]Callables, Runnables, Executors, & Futures

Paul Haahr wrote:

> 1 - Callables shouldn't take an argument.
> 
>   Unlike Runnables, Callables take a single argument of type Object.
>   Why?  How many naturally-written callables will take precisely one
>   argument?
> 
>   Since callables will typically be created as inner classes, there
>   doesn't appear to be any benefit to passing the argument.  Instead,
>   that's exactly what closing over arguments is ideally suited to.

Having one argument allows people to use Callables without creating an
additional level of wrapping in the most common use case. Improving
usability and performance in the most common case seems worth doing,
since it doesn't in any way rule out making wrappers in other cases.
Don't you think?


> 2 - executeAsFuture is a hack
> 
>   I don't see the point of executeAsFuture.  I think it's equivalent to
>   wrapping a runnable inside a Callable, along the lines of:
> 
>     execute(new Callable {
>       void call(Object ignored) {
> 	runnable.run();
>         return Boolean.TRUE;
>       }, null);

Yes, it is equivalent. The usage will probably be common, so why not
just provide it for people instead of making them write this all the
time?

>  I'd much rather see a convenience class (CallRunnable?) which
>   provides that wrapper.

Where would you define the class? This question more than any other led
to current solution. 

(Aside: Adding a package impacting core functionality of a 7 year old
language/library often requires more compromise than you'd like.)

> 3 - DelayableThreadExecutor always produces Futures

DelayableThreadExecutor currently exists in only a very rough form.
We decided that we want it, but all the details are still under
discussion.  (I foolishly/bravely push out APIs du jour at 
  http://gee.cs.oswego.edu/dl/concurrent/index.html
where can see them though.)

>   Perhaps cancellation is really what this is about? 

Yes. Futures are cancellable, and getting a Future back is the only
way we support per-task cancellation. (java.util.TimerTasks are also
cancellable, but have mechanics that are tied too closely to
java.util.Timers.)  We might add a superinterface to Future, but this
means adding yet another small interface to the package solely for the
sake of elegance, not functionality -- a Future works fine here, and
doesn't impose any unnecessary overhead. It just looks weird.  But
each such interface we add at this point will be a battle, since they
impact the perceived complexity and learnability of the package.

In short: yes, we are considering alternatives. Suggestions welcome,


> 4 - What are the elements of the queues for ThreadExecutors?
> 
>   When creating a thread pool, one gets to decide what form of blocking
>   queue is used.  This does let one decide on fixed-length vs. linked
>   list vs. synchronous style, but misses what I thought would be a key
>   point for such queues:  priority.  It appears that if I want to have
>   priority queues for the tasks fed into an executor, I need to have two
>   queues and an extra thread.  Seems awkward.
> 
>   If possible, I'd like to see a specification of an interface that the
>   elements of the queue obeyed, which allowed one to extract the
>   Callable or Runnable and use that in a comparator for a priority queue.

There are two ways you can go about supporting prioritized tasks.

You can adopt an approach similar to that of DelayableThreadExecutor:
create a subclass with extra execute methods that accept priority
arguments, and subclass BasicFuture or somesuch to include priority
information. In which case, when you get something out of the queue
you can downcast it if you need to compare it to others. Also, as in
DelayableThreadExecutor, you'd need a default rule for dealing with
unprioritized tasks.

A cheaper but still occasionally useful way is to just adopt a set of
usage conventions: That you will only execute tasks of type, say
MyPrioritizedRunnable, and internally use a special queue that only
accepts these. In this case, applications would need to make clear
what the expected interface is (as enforced by some internal
downcasts).

Were you thinking of a different way?

> 5 - Can we have a common ancestor of Callable and Runnable?

Yes, it is called "Object" :-)

-Doug





From crahen@cse.Buffalo.EDU Mon, 2 Sep 2002 07:49:51 -0400 (EDT)
Date: Mon, 2 Sep 2002 07:49:51 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Callables, Runnables, Executors, & Futures

On Mon, 2 Sep 2002, Doug Lea wrote:

> Having one argument allows people to use Callables without creating an
> additional level of wrapping in the most common use case. Improving
> usability and performance in the most common case seems worth doing,
> since it doesn't in any way rule out making wrappers in other cases.
> Don't you think?

Maybe the generic Java things that are being developed will eventually
allow for more generic Callables? Ones that allow you to use your
arguments more directly through some kind of template without having to
pack them all into a single Object.

- Eric
http://www.cse.buffalo.edu/~crahen





From dl@cs.oswego.edu Mon, 2 Sep 2002 09:01:15 -0400
Date: Mon, 2 Sep 2002 09:01:15 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]UnboundedArrayBlockingQueue

Paul Haahr wrote:

> My personal favorite queue implementation appears to be missing from
> JSR166:  an unbounded but array-backed blocking queue.  Implementation
> is easy:  a circular buffer that resizes the underlying arrays.
> 
> I like it because there's no size limit which causes adding an element
> to block for long periods of time (unlike ArrayBlockingQueue) and
> there's no per-element consing overhead (unlike LinkedBlockingQueue).

Eric Crahen's reply was mostly on target -- Performance testing
various algorithms I've put together on various JVMs indicates that
Linked are normally best for unbounded, and Array-based for
bounded/non-resizable. (A different intermediate choice,
BoundedLinked, present in dl.u.c, also didn't make it into JSR-166.)

The main trade-off here is that with linked, you get more object
construction, but less-often-contending synchronization in the
unbounded case.  For bounded case, there are fewer contention
benefits; they don't normally outweigh construction overhead compared
to Array-based.

There are of course some situations in which BoundedLinked or
UnboundedArray would be a better choice than the ones provided, but
they don't seem very common.

-Doug










From TEREKHOV@de.ibm.com Mon, 2 Sep 2002 15:16:05 +0200
Date: Mon, 2 Sep 2002 15:16:05 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] Structure and function

David Holmes wrote:
[...]
> Point c) is probably not going to be the case here. The intrinsic lock
> support in a JVM is a reentrant lock and that is what we see being
> optimised. We don't envisage (but don't prohibit) VM's expending
> effort making non-reentrant locks fast - *especially* when you take
> into account that these locks must also be interruptible ...
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

But why the heck "these locks must also be interruptible"?
Locking (for short duration) and waiting (for long/unbound
duration) are *different* things, really; well, "IMHO".

What am I missing here?

> Point b) is realized either through deadlocks or, if supported,
> error-checking lock versions that can report the error. This effect is
> easily mimicked using a wrapper on a ReentrantLock:
>
> class NonReentrantLock implements Lock {
>    ReentrantLock l = new ReentrantLock();
>    void lock() {
>       if (l.getHoldCount() == 1) {
>          // spin forever or throw an exception
>       }
>       l.lock();
>    }
>
>  ...
> }

Uhmm, you probably mean something along the line of:

class NonReentrantLock implements Lock {
   ReentrantLock l = new ReentrantLock();
   ThreadLocal s = new ThreadLocal(); // thread specific binary state
   void lock() {
      if (null != s.get() && 0 != l.getHoldCount()) {
         // spin forever or throw an exception
      }
      s.set(s); // whatever !null
      l.lock();
   }
   void unlock() {
      if (null == s.get() ) {
         // spin forever or throw an exception
      }
      l.unlock();
      s.set(null);
   }

oder? Oh, now I see: "getHoldCount() Return the number of holds
of this lock by current Thread, or zero if lock not held by current
thread." Well, but note that you have also wrote: "The only reason
you can release a mutex from another thread is purely and simply
that the currentThread test was so expensive back then that Doug
omitted the check for ownership of the mutex for performance
reasons." So, are we going to end up with: "ownership check will
be put in place for the mutex class(es) whether reentrant or not"
on lock interface (and specifically on its getHoldCount() method)?

> Ahh you see that is the root of the problem. A Semaphore is not a
> mutual exclusion primitive - it is a state, or condition
> synchronization primitive.

Yep, A Semaphore is...

http://groups.google.com/groups?threadm=c29b5e33.0201310709.3ffc3476%40posting.google.com
(Subject: Re: mutex or semaphores?)

"...actually a mixture of TWO concepts:

 a) locking (right choice: mutexes)
 b) waiting (right choice: condvars)

 they are really BAD:

 1) Lock operation is a *cancellation* point!
    (and is interruptible by signals: [EINTR])

 2) They cannot be used together with condition
    variables to build robust synchronization
    protocols.

 3) They do not support mutex priority protocols;
    BEWARE *Priority Inversion*

 4) They are slow and error-prone!

 Hmmm.. Did I miss something? ;-) ..."

http://groups.google.com/groups?threadm=slrn9e684t.hp.kaz%40cafe.net
(Subject: Re: A theoretical question on synchronization)

"... So really, the samephore provides only a kludgy solution to
synchronization
 problems that are based on simple counting. ..."

regards,
alexander.



"David Holmes" <dholmes@dltech.com.au>@cs.oswego.edu on 09/02/2002 06:36:42
AM

Sent by:    concurrency-interest-admin@cs.oswego.edu


To:    <concurrency-interest@altair.cs.oswego.edu>
cc:
Subject:    RE: [concurrency-interest] Structure and function


Paul Haahr wrote:
> I think that's good, though fairly subtle.  It seems to
> conflict with
> the idea of using Semaphore(1) directly as a non-reentrant lock.

We decided that making Semaphore a Lock was catering for the very
small section of the community that not-only wanted to use a binary
semaphore as a Lock (either for it's non-reentrant property, or the
ability to release other than by the 'owner'), but also wanted that
usage to be interchangeable with different types of Lock. This need
seemed small compared to the confusion that can be caused by equating
Semaphores with Locks.

This decision was made after the discussion that took place on this
list.

> Seems like a lot of work to get what I'd consider the
> simplest possible mutual exclusion construct.

There are two things that people are asking for:
 - non-reentrant locks
 - locks that can be released by a thread other than the owner

These properties are independent, but you're more likely to want the
second with a non-reentrant lock.

People tend to ask for non-reentrant locks for three reasons that I've
seen:

a) It's what they are familiar with from other systems (mainly because
they accept the default type of a pthreads mutex :) )

b) They want to detect errors where a lock is unintentionally acquired
more than once

c) They perceive that a non-reentrant lock must be faster/better than
a reentrant one.

Point c) is probably not going to be the case here. The intrinsic lock
support in a JVM is a reentrant lock and that is what we see being
optimised. We don't envisage (but don't prohibit) VM's expending
effort making non-reentrant locks fast - *especially* when you take
into account that these locks must also be interruptible hence
preventing direct native implementation.

Point b) is realized either through deadlocks or, if supported,
error-checking lock versions that can report the error. This effect is
easily mimicked using a wrapper on a ReentrantLock:

class NonReentrantLock implements Lock {
   ReentrantLock l = new ReentrantLock();
   void lock() {
      if (l.getHoldCount() == 1) {
         // spin forever or throw an exception
      }
      l.lock();
   }

 ...
}

Given the optimisation for ReentrantLock that is envisaged, this might
well outperform a version written using wait/notify directly - but
that's just my opinion.

Should we provide this wrapper? What should we call it? [People keep
asking for a Mutex but what flavour of Mutex would it be?]

Point a) is addressed through good documentation which will convince
people that unless they really need b) then a ReentrantLock will work
just fine.

The need to release a lock held by another thread is far more rarely
needed and very context dependent. We couldn't build one on top of
ReentrantLock so we wouldn't get the optimisation benefit there. You
could use a Semaphore instead - as long as you don't also want to
prevent unintentional releases. Should we try and provide
implementations for this? Reentrant or NonReentrant, or both? How
about the WriteLock as well? We could end up with a group of lock
implementations that are only needed in rare circumstances but the
presence of which greatly decreases the understandability and
ease-of-use of the package. I'm more inclined to let people define
their own locks for this, if using a Semaphore is not suitable for
them.

> I've mostly seen the non-elegant uses.  I always attributed their
> prevalence to the fact that they were the first mutual exclusion
> primitive which were described publicly.

Ahh you see that is the root of the problem. A Semaphore is not a
mutual exclusion primitive - it is a state, or condition
synchronization primitive. Mutual exclusion using a semaphore is only
achieved by using the semaphore in a particular restricted way. In
essence a Semaphore is a mutual exclusion capability, plus a condition
queue, plus a counter - all neatly packaged together.
:)

> A note to the effect of
>
>   Semaphores are provided for algorithms in which they are
> the natural
>   tool.  Often subclasses of Lock provide similar funcionality to
>   Semaphores in an easier to use form.
>
> would be nice in the Semaphore documentation.  Such a note, though,
> might conflict with using Semaphore(1) as a non-reentract lock.

The documentation will be quite detailed and extensive, clarifying the
usage and purpose of each of the components. We want people to
understand not just what they do but when/why they might want to use
one.

Cheers,
David Holmes


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest








From paul@paulhaahr.com Mon,  2 Sep 2002 09:24:00 -0700 (PDT)
Date: Mon,  2 Sep 2002 09:24:00 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]UnboundedArrayBlockingQueue

> Eric Crahen's reply was mostly on target -- Performance testing
> various algorithms I've put together on various JVMs indicates that
> Linked are normally best for unbounded, and Array-based for
> bounded/non-resizable. (A different intermediate choice,
> BoundedLinked, present in dl.u.c, also didn't make it into JSR-166.)

I suspect it depends quite a lot on the application.  There are times
I've needed work hard to avoid consing, but didn't want to throttle a
producer thread.

Since it's so easy to write UnboundedArrayBlockingQueue on ones own,
I'll give up pressing for it, but I see the utility as high enough that
I'd still prefer to include it in the APIs.

> There are of course some situations in which BoundedLinked or
> UnboundedArray would be a better choice than the ones provided, but
> they don't seem very common.

I suspect BoundedLinked would be pretty rare.  YMMV.

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 10:01:43 -0700 (PDT)
Date: Mon,  2 Sep 2002 10:01:43 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

> > 1 - Callables shouldn't take an argument.
> 
> Having one argument allows people to use Callables without creating an
> additional level of wrapping in the most common use case.

I see exactly one level of wrapping being necessary in either case.  The
draft APIs just do that wrapping behind the scenes.  In the case where
the user's code doesn't naturally fit ``one argument of reference type,''
there's an extra level of wrapping for Callables.

Perhaps if there weren't the object/primitive distinction in Java I'd be
less biased against this interface.

> Improving usability and performance in the most common case seems
> worth doing, since it doesn't in any way rule out making wrappers in
> other cases.  Don't you think?

I don't see either usability or performance advantages.

Heck, the example of Callables in the API docs is exactly the wrong
thing:  it creates a new Callable for each iteration, yet passes in this
argument.  That seems like a contortion to make the usage fit the
interface.

I see the assymetry with Runnables as far worse than any possible
advantages.  There's an unnecessary difference, and that just makes it
harder to explain.

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 12:45:02 -0700 (PDT)
Date: Mon,  2 Sep 2002 12:45:02 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

Eric D. Crahen wrote, replying to Doug Lea:
> > Having one argument allows people to use Callables without creating an
> > additional level of wrapping in the most common use case. Improving
> > usability and performance in the most common case seems worth doing,
> > since it doesn't in any way rule out making wrappers in other cases.
> > Don't you think?
> 
> Maybe the generic Java things that are being developed will eventually
> allow for more generic Callables? Ones that allow you to use your
> arguments more directly through some kind of template without having to
> pack them all into a single Object.

Maybe eventually, but it's a lot different than the GJ stuff that was in
the JSR.

--p




From brian@quiotix.com Mon, 2 Sep 2002 12:54:02 -0700
Date: Mon, 2 Sep 2002 12:54:02 -0700
From: Brian Goetz brian@quiotix.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

> I see exactly one level of wrapping being necessary in either case.  The
> draft APIs just do that wrapping behind the scenes.  In the case where
> the user's code doesn't naturally fit ``one argument of reference type,''
> there's an extra level of wrapping for Callables.

There's a pretty common case which requires no wrapping at all. 

Lets say you have a queue of records to be deleted from a database,
identified by ID, which runs as a background thread.  Now, instead of
queueing a deletion like this:

taskQueue.schedule(new Runnable() { 
  public void run() {
    doDeletion(deleteKey);
  }
}

which creates a new inner class element for each deletion, you can
create a single Callable to handle all deletions which takes the ID as
a parameter, store it as a static, and then simply queue that object,
with different keys, to the queue.  Many fewer inner class
instantiations.





From paul@paulhaahr.com Mon,  2 Sep 2002 12:58:08 -0700 (PDT)
Date: Mon,  2 Sep 2002 12:58:08 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

> > 2 - executeAsFuture is a hack
> > 
> >   I don't see the point of executeAsFuture.  I think it's equivalent to
> >   wrapping a runnable inside a Callable, along the lines of:
> > 
> >     execute(new Callable {
> >       void call(Object ignored) {
> >     runnable.run();
> >         return Boolean.TRUE;
> >       }, null);
> 
> Yes, it is equivalent. The usage will probably be common, so why not
> just provide it for people instead of making them write this all the
> time?

I wouldn't.  I'd package it as a convenience class.

> >  I'd much rather see a convenience class (CallRunnable?) which
> >   provides that wrapper.
> 
> Where would you define the class?

I would do it as a final, static, nested class in Callable:

    public interface Callable
    {
        public Object call() throws Exception;
        public final static class ForRunnable implements Callable
        {
            private Runnable runnable;
            public ForRunnable(final Runnable runnable) 
            {
                this.runnable = runnable;
            }
            public Object call() {
                runnable.run();
                return Boolean.TRUE;
            }
        }
    }

Usage would be:

  execute(new Callable.ForRunnable(runnable));

Slightly more verbose, but more orthogonal, which is the usual way Java
has made those tradeoffs.

> This question more than any other led to current solution.
> 
> (Aside: Adding a package impacting core functionality of a 7 year old
> language/library often requires more compromise than you'd like.)

Of course.  But we'd like those compromises to be as clean and
orthogonal as possible, wouldn't we?

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 13:10:09 -0700 (PDT)
Date: Mon,  2 Sep 2002 13:10:09 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

Brian Goetz wrote
> > I see exactly one level of wrapping being necessary in either case.  The
> > draft APIs just do that wrapping behind the scenes.  In the case where
> > the user's code doesn't naturally fit ``one argument of reference type,''
> > there's an extra level of wrapping for Callables.
> 
> There's a pretty common case which requires no wrapping at all. 
> 
> Lets say you have a queue of records to be deleted from a database,
> identified by ID, which runs as a background thread.  Now, instead of
> queueing a deletion like this:
> 
> taskQueue.schedule(new Runnable() { 
>   public void run() {
>     doDeletion(deleteKey);
>   }
> }
> 
> which creates a new inner class element for each deletion, you can
> create a single Callable to handle all deletions which takes the ID as
> a parameter, store it as a static, and then simply queue that object,
> with different keys, to the queue.  Many fewer inner class
> instantiations.

Yes, but then the Executor ends up doing exactly the same kind of
packaging of the Callable and its argument as you're complaining about,
just behind the scenes.  Which is how I got to ``exactly one.''

I'm not arguing that there's zero utility to this pattern, though I
think the utility is lower than other people seem to.  I am arguing that
(1) it's culturally incompatible with how other Java interfaces (e.g.,
Runnable or MouseListener) work and (2) the pattern forces you into more
contortions when your usage doesn't fit it than would the zero-argument
version.  Either of those arguments is strong enough on its own, I
think, to justify making call() a single argument method.

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 13:12:45 -0700 (PDT)
Date: Mon,  2 Sep 2002 13:12:45 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

I wrote
> Either of those arguments is strong enough on its own, I
> think, to justify making call() a single argument method.

I meant ``zero argument,'' of course.

--p




From paul@paulhaahr.com Mon,  2 Sep 2002 13:20:14 -0700 (PDT)
Date: Mon,  2 Sep 2002 13:20:14 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

> > 3 - DelayableThreadExecutor always produces Futures
> 
> DelayableThreadExecutor currently exists in only a very rough form.

(I noticed.  I'm glad we got to see the sketch at this stage, though.)

> >   Perhaps cancellation is really what this is about? 
> 
> Yes. Futures are cancellable, and getting a Future back is the only
> way we support per-task cancellation. (java.util.TimerTasks are also
> cancellable, but have mechanics that are tied too closely to
> java.util.Timers.)  We might add a superinterface to Future, but this
> means adding yet another small interface to the package solely for the
> sake of elegance, not functionality -- a Future works fine here, and
> doesn't impose any unnecessary overhead. It just looks weird.  But
> each such interface we add at this point will be a battle, since they
> impact the perceived complexity and learnability of the package.

I think the real, as opposed to perceived, complexity and learnability
is more severly impacted by having interfaces used in ``weird''
situations than by adding properly factored interfaces.

In particular, if I were looking for cancel functionality on a runnable,
the last place I would look is Future.  I'd be hunting through the
Executor documentation for a long time first.

Who is this battle with?  I thought we were all on the side of bringing
an actually usable and easily learnable API for concurrency to standard
Java.  Why start out with warts that offer no compatibility advantages?

> In short: yes, we are considering alternatives. Suggestions welcome,

I'll propose something in the next day or two.  And it will almost
certainly involve a superinterface.

(Enough for me today...)

--p




From dholmes@dltech.com.au Tue, 3 Sep 2002 07:57:45 +1000
Date: Tue, 3 Sep 2002 07:57:45 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

Alexander Terekhov wrote:
> oder? Oh, now I see: "getHoldCount() Return the number of holds
> of this lock by current Thread, or zero if lock not held by current
> thread." Well, but note that you have also wrote: "The only reason
> you can release a mutex from another thread is purely and simply
> that the currentThread test was so expensive back then that Doug
> omitted the check for ownership of the mutex for performance
> reasons." So, are we going to end up with: "ownership check will
> be put in place for the mutex class(es) whether reentrant or not"
> on lock interface (and specifically on its getHoldCount() method)?

getHoldCount is not part of the Lock interface. ReentrantLock
(naturally) defines it, and so it can be used to prevent reentrant
usage as per my example.

Whether or not a simple mutex class should check ownership when
unlocking is yet another policy choice that deters us from providing
that class. As I've said before, exactly what flavour of mutex should
we provide if we were to provide one? If you want something that could
map to an underlying native locking mechanism then your preferred
flavour will depend on your platform.

David Holmes






From dholmes@dltech.com.au Tue, 3 Sep 2002 09:02:34 +1000
Date: Tue, 3 Sep 2002 09:02:34 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

Brian Goetz wrote
> Lets say you have a queue of records to be deleted from a
> database, identified by ID, which runs as a background thread.
> Now, instead of queueing a deletion like this:
>
> taskQueue.schedule(new Runnable() {
>   public void run() {
>     doDeletion(deleteKey);
>   }
> }
>
> which creates a new inner class element for each deletion, you
> can create a single Callable to handle all deletions which
> takes the ID as a parameter, store it as a static, and then
> simply queue that object, with different keys, to the queue.
> Many fewer inner class instantiations.

Paul Haahr responded:
> Yes, but then the Executor ends up doing exactly the same kind of
> packaging of the Callable and its argument as you're
> complaining about, just behind the scenes.

I don't understand Paul's comment here. Here's an example similar in
principle to what Brian describes:

   for( Iterator iter = coll.iterator(); iter.hasNext(); ) {
       final Object val = iter.next();
       threadpool.execute( new Runnable() {
           public void run() {
               process(val);
           }
        });
   }

This creates an inner class instance on each iteration of the loop.

Instead we can do this:

   Callable c = new Callable() {
        public Object call(Object o) {
           process(o);
        }
    };
    for( Iterator iter = coll.iterator(); iter.hasNext(); ) {
        threadpool.execute(c, iter.next());
   }

Threadpool.execute simply places the Runnable, or Callable+arg into a
queue node, and a worker thread dequeues and either invokes run() or
call(o) depending on the type of node. In both cases a queue node is
needed. If the threadpool uses an array as a workqueue then a callable
uses up two slots: one for the callable and one for the arg. Either
way we don't get the extra allocation per iteration that is needed in
the Runnable case. So where is the packaging that Paul as concerned
about?

Ideally there would be a family of interfaces defining:

  void call();  // aka run
  void call() throws Exception;
  void call(Object args);
  void call(Object args) throws Exception;
  Object call();
  Object call() throws Exception;
  Object call(Object args);
  Object call(Object args) throws Exception;

But that would be completely unmanageable. We already have the first
case in run(), so we provide the last. That covers all of the
requirements but means that sometimes you don't need to use all of the
features. If this were being proposed before inner classes had been
introduced I don't think we'd be having this discussion. Inner classes
allowed us to work around the limitations of run() without having to
do tedious wrapper classes just to hold arguments values and return
values. We've grown somewhat accustomed to using them - we had to they
were all we had. Now we have the opportunity to makes things the way
they (perhaps) should have been in the first place. I for one, will
start advocating the use of Callable instead of anonymous Runnables
where it provides a better solution.

Cheers,
David Holmes





From jozart@csi.com Mon, 2 Sep 2002 18:07:34 -0700
Date: Mon, 2 Sep 2002 18:07:34 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: Callables shouldn't take an argument  (was: Callables, Runnables, Executors, & Futures)

Paul Haahr writes:

> 1 - Callables shouldn't take an argument.

I'm sympathetic stylistically, but I think an Object argument is useful
enough to make this worthwhile.

I do object, however, to having it appear as "Object arguments" in the
javadoc.  This highlights a mismatch that may not actually exist.  It
believe it should be documented as "Object arg" (or argument).


Here's an example where I've found it helps to have an argument:

A cache with Future entries, similar to FutureTable in jhpc

 http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/jhpc/jhpc/thread/

Futures are stored in the cache so that a second thread can wait for the
Future result without having to lock the entire cache:

    Future result = null;
    boolean added = false;
    synchronize (cache) {
        result = cache.get(key);
        if (result == null) {
            result = new BasicFuture(loader, key);
            cache.put(key, result);
            added = true;
        }
    }
    if (added) {
        result.run(); // load
    }
    return result.get();


The Callable's argument allows loader to be implemented as a constant
function:

  final Callable loader = new Callable() {
    public Object call(Object arg) throws Exception {
        return load(arg);
    }
  };



----- Original Message -----
From: "Paul Haahr" <paul@paulhaahr.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Monday, September 02, 2002 10:01 AM
Subject: [concurrency-interest] Re: [concurrency-interest]Callables,
Runnables, Executors, & Futures

> > 1 - Callables shouldn't take an argument.
>
> Having one argument allows people to use Callables without creating an
> additional level of wrapping in the most common use case.

I see exactly one level of wrapping being necessary in either case.  The
draft APIs just do that wrapping behind the scenes.  In the case where
the user's code doesn't naturally fit ``one argument of reference type,''
there's an extra level of wrapping for Callables.

Perhaps if there weren't the object/primitive distinction in Java I'd be
less biased against this interface.

> Improving usability and performance in the most common case seems
> worth doing, since it doesn't in any way rule out making wrappers in
> other cases.  Don't you think?

I don't see either usability or performance advantages.

Heck, the example of Callables in the API docs is exactly the wrong
thing:  it creates a new Callable for each iteration, yet passes in this
argument.  That seems like a contortion to make the usage fit the
interface.

I see the assymetry with Runnables as far worse than any possible
advantages.  There's an unnecessary difference, and that just makes it
harder to explain.

--p






From jozart@csi.com Tue, 3 Sep 2002 03:11:20 -0700
Date: Tue, 3 Sep 2002 03:11:20 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: executeAsFuture is a hack (was: Callables, Runnables, Executors, & Futures)

Paul Haahr writes:

> 2 - executeAsFuture is a hack
>
>   I don't see the point of executeAsFuture.  I think it's equivalent to
>   wrapping a runnable inside a Callable, along the lines of:
>
>     execute(new Callable {
>       void call(Object ignored) {
>     runnable.run();
>         return Boolean.TRUE;
>       }, null);
>
>
> I would do it as a final, static, nested class in Callable.
>

I can see your point, and I also observe that executeAsFuture is less
functional in at least one way than letting the user create the Runnable
task (aka BasicFuture).  When the executor creates the Future task and
returns it to the caller, the caller is not guaranteed to get its hands on
the task "handle" before the task starts.  In fact, the caller may not
receive the handle until after the task has finished.  In the past I have
found it necessary to have an active task's handle "firmly in hand" before
the task executes.

Concerning Callable.ForRunnable, note that adding a BasicFuture(Runnable)
constructor is another approach:

  public BasicFuture(final Runnable r) {
    return new BasicFuture(new Callable() {
      public Object call(Object ignored) {
        r.run();
        return Boolean.TRUE;
      }
    }, null);
  }

Usage would be:

  execute(new BasicFuture(runnable));

FWIW, a more memory-efficient implementation follows.  This implementation
exploits Callable's Object argument, and should look familiar to LISP
programmers :-)

  public BasicFuture(Runnable r) {
    this(RUNNER, r);
  }

where RUNNER is the static Callable that "runs" its argument:

  private static Callable RUNNER = new Callable() {
    public Object call(Object runnable) {
      ((Runnable) runnable).run();
      return Boolean.TRUE;
    }
  };


NOTE: A basic assumption above is that BasicFuture.run() will bail-out if
the future was cancelled before run() was invoked.


Aside: Now I wonder whether BasicFuture would be better served by the name
BasicTask.


----- Original Message -----
From: "Paul Haahr" <paul@paulhaahr.com>
To: "Doug Lea" <dl@altair.cs.oswego.edu>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Monday, September 02, 2002 12:58 PM
Subject: [concurrency-interest] Re: [concurrency-interest]Callables,
Runnables, Executors, & Futures

>> 2 - executeAsFuture is a hack
>>
>>   I don't see the point of executeAsFuture.  I think it's equivalent to
>>   wrapping a runnable inside a Callable, along the lines of:
>>
>>     execute(new Callable {
>>       void call(Object ignored) {
>>     runnable.run();
>>         return Boolean.TRUE;
>>       }, null);
>
> Yes, it is equivalent. The usage will probably be common, so why not
> just provide it for people instead of making them write this all the
> time?

I wouldn't.  I'd package it as a convenience class.

>>  I'd much rather see a convenience class (CallRunnable?) which
>>   provides that wrapper.
>
> Where would you define the class?

I would do it as a final, static, nested class in Callable:

    public interface Callable
    {
        public Object call() throws Exception;
        public final static class ForRunnable implements Callable
        {
            private Runnable runnable;
            public ForRunnable(final Runnable runnable)
            {
                this.runnable = runnable;
            }
            public Object call() {
                runnable.run();
                return Boolean.TRUE;
            }
        }
    }

Usage would be:

  execute(new Callable.ForRunnable(runnable));

Slightly more verbose, but more orthogonal, which is the usual way Java
has made those tradeoffs.

> This question more than any other led to current solution.
>
> (Aside: Adding a package impacting core functionality of a 7 year old
> language/library often requires more compromise than you'd like.)

Of course.  But we'd like those compromises to be as clean and
orthogonal as possible, wouldn't we?

--p








From TEREKHOV@de.ibm.com Tue, 3 Sep 2002 17:44:34 +0200
Date: Tue, 3 Sep 2002 17:44:34 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] Structure and function

> getHoldCount is not part of the Lock interface.

Yep. Sorry for the confusion. Now [I've double checked it *this*
time ;-) ], Lock interface seems to have the newCondition() method,
and the Condition interface seems to have a whole bunch of methods
which are all supposed to throw IllegalMonitorStateException "if
lock not held". How does this all fit together?

regards,
alexander.






From paul@paulhaahr.com Thu,  5 Sep 2002 02:42:17 -0700 (PDT)
Date: Thu,  5 Sep 2002 02:42:17 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

David Holmes wrote, quoting me:
> > Yes, but then the Executor ends up doing exactly the same kind of
> > packaging of the Callable and its argument as you're
> > complaining about, just behind the scenes.
> 
> I don't understand Paul's comment here.

I'll try to explain it, though it's off base for a different reason than
you note.

But, my arguments against the argument for Callables were independent of
performance issues.  I think the arguments are strong enough that, even
though there are some cases where it will cost some consing, it's worth
getting rid of this extra argument.

> Here's an example similar in principle to what Brian describes: [...]
> This creates an inner class instance on each iteration of the loop.
> 
> Instead we can do this: [...]
> Threadpool.execute simply places the Runnable, or Callable+arg into a
> queue node, and a worker thread dequeues and either invokes run() or
> call(o) depending on the type of node. In both cases a queue node is
> needed.

I disagree.  All that's needed for Runnables is placing the Runnable
itself on the Queue.  You don't need to cons up any queue node, at least
for the current spec, with Runnables.

This isn't true with Callables, though, independent of the extra
argument, because of the Futures that are returned.  The Future for a
specific execute(Callable) needs to be packaged in the same queue node
as the Callable.  (If Runnables get back some superinterface of Future,
then the same thing applies to them.)

(The obvious performance hack is to make the queue nodes implement
Future, so they can do double duty.)

> If the threadpool uses an array as a workqueue then a callable
> uses up two slots: one for the callable and one for the arg.

(I think this has atomicity problems: consider a thread executor with
multiple threads.  I'd love for it to work, but I just don't believe it
will.)

> Either way we don't get the extra allocation per iteration that is
> needed in the Runnable case. So where is the packaging that Paul as
> concerned about?

I think I was wrong, because of the Future issue.

> Ideally there would be a family of interfaces defining:
> 
>   void call();  // aka run
>   void call() throws Exception;
>   void call(Object args);
>   void call(Object args) throws Exception;
>   Object call();
>   Object call() throws Exception;
>   Object call(Object args);
>   Object call(Object args) throws Exception;
> 
> But that would be completely unmanageable. We already have the first
> case in run(), so we provide the last. That covers all of the
> requirements but means that sometimes you don't need to use all of the
> features.

Ugh.  Any time you're convinced you need to provide m^n interfaces for n
features, you've got to factor the design somehow.  One of those
factorings is to always go with zero-argument style and put the argument
into the object, exactly as is already done for Runnable.

Choosing the first and the last of a spectrum of APIs might make sense,
though I can see few cases where it applies.  But putting them in an
ordering like this has taken completely independent features and made a
claim that they're a continuous spectrum, which I just don't buy.

The variation between Runnable and Callable is necessary in Java because
void isn't a subclass of Object.  (I, for one, wish it were.)  I might
agree that Runnable should have returned a value all along, though it
would have been pretty unsightly.

While you're listing these, why not add versions for all the primtive
types?  For two argument versions of call()?  What distinguishes the
single argument case so strongly?

(By the way, in declaring that call() throws Exception, I see a tacit
statement by the EG that checked exceptions were a mistake.  Would
anyone on the EG like to comment?)

> If this were being proposed before inner classes had been introduced I
> don't think we'd be having this discussion. Inner classes allowed us
> to work around the limitations of run() without having to do tedious
> wrapper classes just to hold arguments values and return values. We've
> grown somewhat accustomed to using them - we had to they were all we
> had. Now we have the opportunity to makes things the way they
> (perhaps) should have been in the first place. I for one, will start
> advocating the use of Callable instead of anonymous Runnables where it
> provides a better solution.

I'm 100% in the opposite camp.  If we didn't have inner classes, I'd
still argue against it.

If Runnable took an explicit argument, it would have been a wart on the
original Java design.  (Not that Java was wart-free, but...)

(If there were a way to, ML-style, package a tuple of 0 or more values,
including primitive values, as a single value, transparently in syntax
and without extra consing, then I'd probably agree with you.  Why
``without extra consing''?  Because I think it's important to the flavor
of Java that consing is explicit.)

I'll restate my case:

  (1) There are enough cases where the single argument of reference type
      is the wrong thing for the program design that it gets in the way.

      (What fraction of uses of Callable would be declared to be defined
      with ``call(Object ignored)'' before the believers in it think
      it's worth getting away from?  My figure is about 10%.)

  (2) The asymmetry between Runnable (and other, existing Java
      interfaces) and Callable makes it harder to learn and explain.
      Nobody's made an argument why this interface is different in usage
      from all other interfaces in Java for similar things.

I believe either of these is strong enough to be worth changing the
draft API for Callable to match Runnable.

--p




From paul@paulhaahr.com Thu,  5 Sep 2002 02:47:48 -0700 (PDT)
Date: Thu,  5 Sep 2002 02:47:48 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

> > In short: yes, we are considering alternatives. Suggestions welcome,
> 
> I'll propose something in the next day or two.  And it will almost
> certainly involve a superinterface.

I've been informed that a proposal similar to what I would have made
(and, given my tendencies towards overdesign, cleaner) is being
discussed by the EG already, so I'm not going to make a proposal.

--p




From paul@paulhaahr.com Thu,  5 Sep 2002 03:01:28 -0700 (PDT)
Date: Thu,  5 Sep 2002 03:01:28 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: executeAsFuture is a hack (was: Callables, Runnables, Executors, & Futures)

Joseph Bowbeer wrote
> I can see your point, and I also observe that executeAsFuture is less
> functional in at least one way than letting the user create the Runnable
> task (aka BasicFuture).  When the executor creates the Future task and
> returns it to the caller, the caller is not guaranteed to get its hands on
> the task "handle" before the task starts.  In fact, the caller may not
> receive the handle until after the task has finished.  In the past I have
> found it necessary to have an active task's handle "firmly in hand" before
> the task executes.
> 
> Concerning Callable.ForRunnable, note that adding a BasicFuture(Runnable)
> constructor is another approach:
> 
>   public BasicFuture(final Runnable r) {
>     return new BasicFuture(new Callable() {
>       public Object call(Object ignored) {
>         r.run();
>         return Boolean.TRUE;
>       }
>     }, null);
>   }
> 
> Usage would be:
> 
>   execute(new BasicFuture(runnable));

That seems quite reasonable to me.  I had forgotten that BasicFuture is
a Runnable.  (Somehow, that strikes me as counterintuitive.)  Even
though I knew BasicFuture existed, I was thinking of Future as an
interface with no exposed implementations.

> FWIW, a more memory-efficient implementation follows.  This implementation
> exploits Callable's Object argument,

Well, we should all know by now that I won't like that approach.  :-)

> and should look familiar to LISP programmers :-) [...]

(Lisp 1.5 programmers, maybe, but the lexically-scoped Lisps -- CL,
Scheme and its offspring -- make such ugly constructs pretty rare in
practice.  Especially Scheme.)

> NOTE: A basic assumption above is that BasicFuture.run() will bail-out if
> the future was cancelled before run() was invoked.

I assume that's what it has to do.

> Aside: Now I wonder whether BasicFuture would be better served by the name
> BasicTask.

Maybe.  Implementing both Future and Runnable is quite odd to me;  as I
said, I haven't quite internalized how you use it.

Hmmm... the documentation for BasicFuture seems to have disappeared.  As
has Executor.executeAsFuture(Runnable) and Executor.execute(Callable).
And DelayableThreadExecutor.  I guess changes are afoot.

--p




From paul@paulhaahr.com Thu,  5 Sep 2002 03:10:01 -0700 (PDT)
Date: Thu,  5 Sep 2002 03:10:01 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

I wrote
> 4 - What are the elements of the queues for ThreadExecutors?
> 
>   When creating a thread pool, one gets to decide what form of blocking
>   queue is used.  This does let one decide on fixed-length vs. linked
>   list vs. synchronous style, but misses what I thought would be a key
>   point for such queues:  priority.  It appears that if I want to have
>   priority queues for the tasks fed into an executor, I need to have two
>   queues and an extra thread.  Seems awkward.
> 
>   If possible, I'd like to see a specification of an interface that the
>   elements of the queue obeyed, which allowed one to extract the
>   Callable or Runnable and use that in a comparator for a priority queue.

Doug wrote
> There are two ways you can go about supporting prioritized tasks.
> 
> You can adopt an approach similar to that of DelayableThreadExecutor:
> create a subclass with extra execute methods that accept priority
> arguments, and subclass BasicFuture or somesuch to include priority
> information. In which case, when you get something out of the queue
> you can downcast it if you need to compare it to others. Also, as in
> DelayableThreadExecutor, you'd need a default rule for dealing with
> unprioritized tasks.

(I dislike this because I think it requires a separate thread in the
middle.)

> A cheaper but still occasionally useful way is to just adopt a set of
> usage conventions: That you will only execute tasks of type, say
> MyPrioritizedRunnable, and internally use a special queue that only
> accepts these. In this case, applications would need to make clear
> what the expected interface is (as enforced by some internal
> downcasts).
> 
> Were you thinking of a different way?

I was thinking of your second approach, but can't see how to make it
work, because it's not clear from the Executor spec that the queued
elements are the original Runnables (or Callables, if those are still
supported by Executors.)

Assuming there's some queue node class, as David Holmes suggested, to
make this approach work requires exposing a method for extracting the
Runnable from a queue node.  Either that or a specification that the
elements of the queue are exactly the Runnables that were passed in.

--p




From paul@paulhaahr.com Thu,  5 Sep 2002 03:14:54 -0700 (PDT)
Date: Thu,  5 Sep 2002 03:14:54 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

Doug wrote, replying to me:
> > 5 - Can we have a common ancestor of Callable and Runnable?
> 
> Yes, it is called "Object" :-)

It does appear that there's resistance to more superinterfaces, but when
you have two interfaces so similar as Runnable and Callable, it's very
odd not to have them share a more specific common ancestor, even if that
ancestor specifies no methods.

I propose Executable.

Of course, Executable is much more useful if Callable's call method
doesn't take an argument.

--p




From jozart@csi.com Thu, 5 Sep 2002 04:16:55 -0700
Date: Thu, 5 Sep 2002 04:16:55 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: Callables, Runnables, Executors, & Futures

Paul Haahr writes:

> (By the way, in declaring that call() throws Exception,
> I see a tacit statement by the EG that checked
> exceptions were a mistake.  Would anyone on the
> EG like to comment?)

No comment :)

Seriously, the only question that arose was whether call() throws Exception
or Throwable.

The Callable is usually invoked in a different thread than the client and we
wanted the client that scheduled the Callable to be able to inspect any
exception that was raised during the invocation.

If call() didn't throw anything, then Callable implementers would be forced
to deal with every exception and/or rethrow them as RuntimeExceptions.  That
would be bad.

If call() throws Throwable, then any client that invoked a Callable directly
would be forced to catch Throwable, and that wouldn't be good.  It would
encourage dangerous practices.

That left us with call() throws Exception.

Note: Future.get() throws InvocationTargetException.  Any exception thrown
during the invocation of Callable will be returned via
invocationTargetException.getTargetException().  Even though call() is
declared to throw Exception, the Future implementation will catch all
Throwables.



----- Original Message -----
From: "Paul Haahr" <paul@paulhaahr.com>
To: "David Holmes" <dholmes@dltech.com.au>
Cc: <concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, September 05, 2002 2:42 AM
Subject: RE: [concurrency-interest] Re: [concurrency-interest]Callables,
Runnables, Executors, & Futures



David Holmes wrote, quoting me:
> > Yes, but then the Executor ends up doing exactly the same kind of
> > packaging of the Callable and its argument as you're
> > complaining about, just behind the scenes.
>
> I don't understand Paul's comment here.

I'll try to explain it, though it's off base for a different reason than
you note.

But, my arguments against the argument for Callables were independent of
performance issues.  I think the arguments are strong enough that, even
though there are some cases where it will cost some consing, it's worth
getting rid of this extra argument.

> Here's an example similar in principle to what Brian describes: [...]
> This creates an inner class instance on each iteration of the loop.
>
> Instead we can do this: [...]
> Threadpool.execute simply places the Runnable, or Callable+arg into a
> queue node, and a worker thread dequeues and either invokes run() or
> call(o) depending on the type of node. In both cases a queue node is
> needed.

I disagree.  All that's needed for Runnables is placing the Runnable
itself on the Queue.  You don't need to cons up any queue node, at least
for the current spec, with Runnables.

This isn't true with Callables, though, independent of the extra
argument, because of the Futures that are returned.  The Future for a
specific execute(Callable) needs to be packaged in the same queue node
as the Callable.  (If Runnables get back some superinterface of Future,
then the same thing applies to them.)

(The obvious performance hack is to make the queue nodes implement
Future, so they can do double duty.)

> If the threadpool uses an array as a workqueue then a callable
> uses up two slots: one for the callable and one for the arg.

(I think this has atomicity problems: consider a thread executor with
multiple threads.  I'd love for it to work, but I just don't believe it
will.)

> Either way we don't get the extra allocation per iteration that is
> needed in the Runnable case. So where is the packaging that Paul as
> concerned about?

I think I was wrong, because of the Future issue.

> Ideally there would be a family of interfaces defining:
>
>   void call();  // aka run
>   void call() throws Exception;
>   void call(Object args);
>   void call(Object args) throws Exception;
>   Object call();
>   Object call() throws Exception;
>   Object call(Object args);
>   Object call(Object args) throws Exception;
>
> But that would be completely unmanageable. We already have the first
> case in run(), so we provide the last. That covers all of the
> requirements but means that sometimes you don't need to use all of the
> features.

Ugh.  Any time you're convinced you need to provide m^n interfaces for n
features, you've got to factor the design somehow.  One of those
factorings is to always go with zero-argument style and put the argument
into the object, exactly as is already done for Runnable.

Choosing the first and the last of a spectrum of APIs might make sense,
though I can see few cases where it applies.  But putting them in an
ordering like this has taken completely independent features and made a
claim that they're a continuous spectrum, which I just don't buy.

The variation between Runnable and Callable is necessary in Java because
void isn't a subclass of Object.  (I, for one, wish it were.)  I might
agree that Runnable should have returned a value all along, though it
would have been pretty unsightly.

While you're listing these, why not add versions for all the primtive
types?  For two argument versions of call()?  What distinguishes the
single argument case so strongly?

(By the way, in declaring that call() throws Exception, I see a tacit
statement by the EG that checked exceptions were a mistake.  Would
anyone on the EG like to comment?)

> If this were being proposed before inner classes had been introduced I
> don't think we'd be having this discussion. Inner classes allowed us
> to work around the limitations of run() without having to do tedious
> wrapper classes just to hold arguments values and return values. We've
> grown somewhat accustomed to using them - we had to they were all we
> had. Now we have the opportunity to makes things the way they
> (perhaps) should have been in the first place. I for one, will start
> advocating the use of Callable instead of anonymous Runnables where it
> provides a better solution.

I'm 100% in the opposite camp.  If we didn't have inner classes, I'd
still argue against it.

If Runnable took an explicit argument, it would have been a wart on the
original Java design.  (Not that Java was wart-free, but...)

(If there were a way to, ML-style, package a tuple of 0 or more values,
including primitive values, as a single value, transparently in syntax
and without extra consing, then I'd probably agree with you.  Why
``without extra consing''?  Because I think it's important to the flavor
of Java that consing is explicit.)

I'll restate my case:

  (1) There are enough cases where the single argument of reference type
      is the wrong thing for the program design that it gets in the way.

      (What fraction of uses of Callable would be declared to be defined
      with ``call(Object ignored)'' before the believers in it think
      it's worth getting away from?  My figure is about 10%.)

  (2) The asymmetry between Runnable (and other, existing Java
      interfaces) and Callable makes it harder to learn and explain.
      Nobody's made an argument why this interface is different in usage
      from all other interfaces in Java for similar things.

I believe either of these is strong enough to be worth changing the
draft API for Callable to match Runnable.

--p







From paul@paulhaahr.com Thu,  5 Sep 2002 07:35:20 -0700 (PDT)
Date: Thu,  5 Sep 2002 07:35:20 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Callable.call() throws Exception

> Seriously, the only question that arose was whether call() throws
> Exception or Throwable.

The subtleties of this distinction are beyond me.  However, this
concerns me:

> If call() throws Throwable, then any client that invoked a Callable
> directly would be forced to catch Throwable, and that wouldn't be
> good.  It would encourage dangerous practices.

That seems to leave us with a situation where implementators 

> Note: Future.get() throws InvocationTargetException.

Yeah, I saw this and it bothered me.  InvocationTargetException is in
java.lang.reflect and is, in theory, about reflection.  Why is it the
right place?  Wouldn't an exception that implied something about
Futures, rather than reflection, be more appropriate?

A notion of substitutability seems like the right way to decide if this
is enough like other uses of InvocationTargetException:  are there cases
where the the catcher of such an exception doesn't know which possible
source (reflection or futures) might be causing it?  If those cases seem
rare, as I think they do, it would argue for two separate classes.

(I will note, by the way, that a former colleague made exactly the same
design decision with Futures in a previous system I worked on, before I
joined that venture.  I criticized him at the time and I think he came
around to believing that it was the wrong exception to use.)

I'm sure the rejoinder I'll get here is something like ``We didn't want
to introduce a new class.''

I see this whole ``let's introduce as few possible new classes''
approach that JSR 166 is taking as rather problematic, because the new
package should be an exemplar of Java design.  But a good design is one
that has the right number of classes for the job, not the minimal
number.  In particular, puns in the use of existing classes don't help
learnability or usability at all.

--p




From paul@paulhaahr.com Thu,  5 Sep 2002 07:41:55 -0700 (PDT)
Date: Thu,  5 Sep 2002 07:41:55 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Callable.call() throws Exception

I wrote
> > If call() throws Throwable, then any client that invoked a Callable
> > directly would be forced to catch Throwable, and that wouldn't be
> > good.  It would encourage dangerous practices.
> 
> That seems to leave us with a situation where implementators 

and trailed off.  I meant to write:

That seems to leave us with a situation where implementators of Callable
expect to have Error or other Throwables caught, but implementators of
Future won't necessarily catch it.  That could lead to more, hard to
find problems than the ``dangerous practice'' of catching Throwable
occasionally.

But I never really bought into the Error/Exception/RuntimeException
distinction anyway.

--p




From spmymcnospm@hotmail.com Thu, 05 Sep 2002 18:40:13 +0000
Date: Thu, 05 Sep 2002 18:40:13 +0000
From: Bill Gates spmymcnospm@hotmail.com
Subject: [concurrency-interest] Interupition advantages

I feel interruption is a very useful thing, but there does not seem to be 
much written about it. Can any EG person compare the pluses and minuses of 
interruption vs something like simple cancelation - especially in the 
context of an OO application? Or just list its strengths and weaknesses? 
Certainly there are instances where it is best to exit after being 
interrupted (cancelation like) but there must be many more examples where 
interruption offers something cancelation can not.

Thanks much,

Spammy McNospam





_________________________________________________________________
MSN Photos is the easiest way to share and print your photos: 
http://photos.msn.com/support/worldwide.aspx





From larryr@saturn.sdsu.edu 5 Sep 2002 18:56:37 -0000
Date: 5 Sep 2002 18:56:37 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] Interupition advantages

And I am interested in what are the expected semantic
interpretations of InterruptedException, ie. what is
the interrupter communicating to the interruptee.


Larry





From sparmar@necam.com Thu, 5 Sep 2002 15:08:14 -0500
Date: Thu, 5 Sep 2002 15:08:14 -0500
From: Sumeet Parmar sparmar@necam.com
Subject: [concurrency-interest] Interupition advantages

Rarely I come across that is so profound and funny at the same time!
-Sumeet

On Thursday 05 September 2002 01:56 pm, Larry Riedel wrote:
> And I am interested in what are the expected semantic
> interpretations of InterruptedException, ie. what is
> the interrupter communicating to the interruptee.
>
>
> Larry
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






From dholmes@dltech.com.au Fri, 6 Sep 2002 08:47:08 +1000
Date: Fri, 6 Sep 2002 08:47:08 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Interupition advantages

> I feel interruption is a very useful thing, but there does
> not seem to be much written about it.

"Concurrent Programming in Java", 2nd Edition, Chapter 3, Section
3.1.2. See also http://gee.cs.oswego.edu/dl/cpj/index.html and in
particular http://gee.cs.oswego.edu/dl/cpj/cancel.html

The Java Programming Language, 3rd Edition, Chapter 10, Section 10.8.1

Multithreaded programming with Java Technology, Chapter 9

And I'm pretty sure that all the other "Java Threads" books cover this
in some detail.

> Can any EG person compare the pluses and minuses of
> interruption vs something like simple cancelation -
> especially in the  context of an OO application? Or just list its
> strengths and weaknesses?
> Certainly there are instances where it is best to exit after being
> interrupted (cancelation like) but there must be many more
> examples where interruption offers something cancelation can not.

There is no such thing as "simple cancellation" - what did you have in
mind? POSIX style deferred cancellation?

The interrupt mechanism is a cooperative cancellation mechanism - like
deferred cancellation in pthreads. Unlike with pthread_cancel a thread
that is interrupted is not forced to terminate - hence it is more
flexible. An interrupted thread should terminate by unwinding the call
stack - either through error return values or by throwing an
exception. Unwinding the call stack ensures that all finally blocks
are executed on the way out - this is functionally equivalent pthread
style cancellation handlers/hooks.

Please see one of the above references for more details.

David Holmes





From spmymcnospm@hotmail.com Thu, 05 Sep 2002 23:04:02 +0000
Date: Thu, 05 Sep 2002 23:04:02 +0000
From: Bill Gates spmymcnospm@hotmail.com
Subject: [concurrency-interest] Interupition advantages

>There is no such thing as "simple cancellation" - what did you have in
>mind? POSIX style deferred cancellation?

I meant simply using cancelation (deferred).

>Please see one of the above references for more details.

I do understand when you'd want to use and how it works (I have also read 
those references). What I'm asking is are there any examples that really 
show how interruption is more flexible than cancelation. I'd like to see an 
example that really makes interruption stand out as a better solution than 
deferred cancelation would be.

_________________________________________________________________
Chat with friends online, try MSN Messenger: http://messenger.msn.com





From dholmes@dltech.com.au Fri, 6 Sep 2002 09:24:13 +1000
Date: Fri, 6 Sep 2002 09:24:13 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Interupition advantages

> I do understand when you'd want to use and how it works (I
> have also read those references). What I'm asking is are there any
> examples that really show how interruption is more flexible than
> cancelation. I'd like to see an example that really makes
> interruption stand out as a better solution than deferred
> cancelation would be.

deferred cancellation takes a thread from where it is, straight to
termination, executing any registered handlers on the way.

interruption allows a thread to choose how it wants to respond to the
cancellation request at the time it is received. Really only the
top-level of a thread knows enough about what it is doing to know how
to respond to cancellation. Code lower in the stack either advertises
that it can respond to interruption by throwing InterruptedException
or it can return a generic error, or it can ignore the interuption for
now and ensure that higher-level code can see it. Most library code
doesn't concern itself with interruption - they are not "cancellation
points".

deferred cancellation doesn't fit in with the Java language semantics
because we expect finally blocks to always be executed. finally blocks
replace the cancellation handlers that is used in pthreads style
cancellation - that mechanism was designed for use with C, not
language like C++ or Java.

A simple example of interrupt over pthreads style cancellation is in
worker thread designs. You can use interrupt to cancel a piece of
work, but still have the worker return to the work queue to get the
next piece. You then don't have to replace workers just because work
was cancelled.

To sum it up in the way I like to express it:

interruption cancels the work
pthread_cancel cancels the worker

David Holmes





From dholmes@dltech.com.au Fri, 6 Sep 2002 09:27:54 +1000
Date: Fri, 6 Sep 2002 09:27:54 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

I've bcc'ed the EG on this because I think it needs to be flagged.

> Doug wrote
> > There are two ways you can go about supporting prioritized tasks.

Paul wrote:
> I was thinking of your second approach, but can't see how to make
> it work, because it's not clear from the Executor spec that the
> queued elements are the original Runnables (or Callables, if those
> are still supported by Executors.)

I agree there is a problem here. If the Executor wraps your
PrioritizedRunnable's before adding them to the queue, the queue
comparator (which you supplied in your custom queue) will see the
wrapped type not the expected type, and probably throw a
ClassCastException.

A solution, though I'm not sure how it fits into the abstract design,
would be for the Executor to replace any comparator with its own. The
comparator would do the unwrapping and delegate to the original
comparator. That said, current queues don't support replacing of the
comparator.

David Holmes





From dholmes@dltech.com.au Fri, 6 Sep 2002 09:56:32 +1000
Date: Fri, 6 Sep 2002 09:56:32 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Callable.call() throws Exception

> Yeah, I saw this and it bothered me.
> InvocationTargetException is in java.lang.reflect and is, in
> theory, about reflection.  Why is it the right place?  Wouldn't an
> exception that implied something about Futures, rather than
> reflection, be more appropriate?

I firmly believe that we should reuse appropriate exceptions rather
than define context specific ones. In hindsight
InvocationTargetException is a general exception that should not have
been put in the reflect package in my view. I would use
InvocationTargetException for any method that executed "code" on my
behalf and for which I wanted exceptions reported "directly".

I don't like class counting (but it is a practical concern the EG has
to be concerned with) but I also don't advocate creating new
exceptions unless no existing exception type is appropriate.

Just my opinion.

David Holmes





From dholmes@dltech.com.au Fri, 6 Sep 2002 10:01:20 +1000
Date: Fri, 6 Sep 2002 10:01:20 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Callable.call() throws Exception

> That seems to leave us with a situation where
> implementators of Callable expect to have Error or other Throwables
> caught, but implementators of Future won't necessarily catch it.

No more so than the majority of methods that don't catch unchecked
exceptions, nor the majority of callers that don't catch them either.

The ability to throw a checked exception allows a Callable to invoke
other methods that can throw checked exceptions and have those
exceptions propagate. The callable then doesn't have to concern itself
with how to pass on to the caller that an exception did in fact occur.
It's that simple.

David Holmes





From dholmes@dltech.com.au Fri, 6 Sep 2002 10:42:13 +1000
Date: Fri, 6 Sep 2002 10:42:13 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Re: [concurrency-interest]Callables, Runnables, Executors, & Futures

A few rejoinders to a range of things:

> I disagree.  All that's needed for Runnables is placing the
> Runnable itself on the Queue.

How does my arbitrary Runnable link into your Executors queue? If the
queue is an array - sure. If it is a linked list then you need a
Node - for both a Runnable or a Callable.

> > If the threadpool uses an array as a workqueue then a callable
> > uses up two slots: one for the callable and one for the arg.
>
> (I think this has atomicity problems

Atomicity problems are solved with synchronisation. If this is just an
array then you're probably using synchronisation to update the "next"
index anyway.

> > Ideally there would be a family of interfaces defining:
> >
> >   void call();  // aka run
> >   void call() throws Exception;
> >   void call(Object args);
> >   void call(Object args) throws Exception;
> >   Object call();
> >   Object call() throws Exception;
> >   Object call(Object args);
> >   Object call(Object args) throws Exception;
> >
>
> Choosing the first and the last of a spectrum of APIs might
> make sense, though I can see few cases where it applies.  But
> putting them in an ordering like this has taken completely
> independent features and made a claim that they're a continuous
> spectrum, which I just don't buy.

What don't you buy? There are three things that can vary:
 - return something or not
 - take arg or not
 - throw checked exception or not

that gives eight possible basic combinations.

> While you're listing these, why not add versions for all
> the primtive types?  For two argument versions of call()?  What
> distinguishes the single argument case so strongly?

The single argument of Object can cover all the other cases, albeit
with additional wrapping/unwrapping of arguments. Primitives are
passed as their wrapper, multi-args are passed as an array. This is
already accepted practice in the reflection API's and other parts of
Java (though it would be nice to get auto-boxing/unboxing someday).

> (By the way, in declaring that call() throws Exception, I
> see a tacit
> statement by the EG that checked exceptions were a mistake.  Would
> anyone on the EG like to comment?)

??? Exception *is* a checked exception. This allows call() to invoke
code that throws checked exceptions while "passing" those exceptions
back to the caller.

Checked exceptions are definitely *not* a mistake - just my opinion -
but sometimes a wrong choice may have been made as to which exceptions
should be checked or unchecked. Hindsight is a wonderful thing - as
always.

>   (2) The asymmetry between Runnable (and other, existing Java
>       interfaces) and Callable makes it harder to learn and
>       explain.

What asymmetry? Runnable is an interface that has a void method that
takes no-args and can throw no checked exceptions. Callable is an
interface that has method that returns Object, takes a single Object
arg and can throw checked exceptions. Two interfaces for two different
roles. What do other Java interfaces have to do with anything? I'm
sorry but I don't see what point you are trying to make.

David Holmes





From ggregory@seagullsw.com Thu, 5 Sep 2002 20:56:41 -0400
Date: Thu, 5 Sep 2002 20:56:41 -0400
From: Gary Gregory ggregory@seagullsw.com
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor method
 names

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C25540.432B1500
Content-Type: text/plain;
	charset="iso-8859-1"

> The Javadocs are at:
>    <http://gee.cs.oswego.edu/dl/concurrent/index.html>

A comment on some method names in ThreadExecutor. I think that factory
methods could be better named. May I suggest:

constructCachedThreadPool 		// was: cachedThreadPool 
constructFixedThreadPool 		// was: fixedThreadPool 
constructSingleThreadExecutor 	// was: singleThreadExecutor 

The current method names name things and do not IMHO say "I am factory that
makes widgets".

I do not consider the length of a method name to be an issue, but this is of
course a personal preference.

I picked "constructXXX" in this case as opposed to "newXXX" or "createXXX"
since the verb "Construct" is used to describe what these methods do in
their respective Javadoc comments. I assumed that this verb was chosen by
the authors and is used consistently throughout (but I have not checked).

(Positive side effect of naming these factory methods with a common prefix:
the method names sort together in Javadoc and in whatever IDE you may use,
for me it's Eclipse. When the factory methods bunch together I can more
easily see what is available to me. If Java had method categories...)

Thank you for considering this,
Gary

------_=_NextPart_001_01C25540.432B1500
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
5.5.2654.45">
<TITLE>[concurrency-interest] JSR 166 draft API - ThreadExecutor method =
names</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=3D2>&gt; The Javadocs are at:</FONT>
<BR><FONT SIZE=3D2>&gt;&nbsp;&nbsp;&nbsp; &lt;<A =
HREF=3D"http://gee.cs.oswego.edu/dl/concurrent/index.html" =
TARGET=3D"_blank">http://gee.cs.oswego.edu/dl/concurrent/index.html</A>&=
gt;</FONT>
</P>

<P><FONT SIZE=3D2>A comment on some method names in ThreadExecutor. I =
think that factory methods could be better named. May I suggest:</FONT>
</P>

<P><FONT SIZE=3D2>constructCachedThreadPool =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // was: cachedThreadPool =
</FONT>
<BR><FONT SIZE=3D2>constructFixedThreadPool =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // was: fixedThreadPool =
</FONT>
<BR><FONT SIZE=3D2>constructSingleThreadExecutor &nbsp; // was: =
singleThreadExecutor </FONT>
</P>

<P><FONT SIZE=3D2>The current method names name things and do not IMHO =
say &quot;I am factory that makes widgets&quot;.</FONT>
</P>

<P><FONT SIZE=3D2>I do not consider the length of a method name to be =
an issue, but this is of course a personal preference.</FONT>
</P>

<P><FONT SIZE=3D2>I picked &quot;constructXXX&quot; in this case as =
opposed to &quot;newXXX&quot; or &quot;createXXX&quot; since the verb =
&quot;Construct&quot; is used to describe what these methods do in =
their respective Javadoc comments. I assumed that this verb was chosen =
by the authors and is used consistently throughout (but I have not =
checked).</FONT></P>

<P><FONT SIZE=3D2>(Positive side effect of naming these factory methods =
with a common prefix: the method names sort together in Javadoc and in =
whatever IDE you may use, for me it's Eclipse. When the factory methods =
bunch together I can more easily see what is available to me. If Java =
had method categories...)</FONT></P>

<P><FONT SIZE=3D2>Thank you for considering this,</FONT>
<BR><FONT SIZE=3D2>Gary</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C25540.432B1500--




From paul@paulhaahr.com Thu,  5 Sep 2002 17:57:34 -0700 (PDT)
Date: Thu,  5 Sep 2002 17:57:34 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] Callable.call() throws Exception

> I firmly believe that we should reuse appropriate exceptions rather than
> define context specific ones. In hindsight InvocationTargetException is
> a general exception that should not have been put in the reflect package
> in my view.

For it to have the general meaning you're giving it, yes, putting it in
java.lang.reflect is wrong.

Assuming people actually do use this interface, because
InvocationTargetException is a checked exception, lots of people will be
importing it and only it from java.lang.reflect to use concurrency
features.  That's much more confusing than a new exception type.

> I would use InvocationTargetException for any method that executed
> "code" on my behalf and for which I wanted exceptions reported
> "directly".

That's a great exception to have.  As I read the packaging of
InvocationTargetException, it's not what we've got.

> I don't like class counting (but it is a practical concern the EG has
> to be concerned with)

Why?  What's the practical concern here?

> but I also don't advocate creating new exceptions unless no existing
> exception type is appropriate.

I agree.  We just have a disagreement on what's ``appropriate.''

--p




From dholmes@dltech.com.au Fri, 6 Sep 2002 11:45:23 +1000
Date: Fri, 6 Sep 2002 11:45:23 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Callable.call() throws Exception

> For it to have the general meaning you're giving it, yes,
> putting it in java.lang.reflect is wrong.

It probably seemed right at the time. Too late to change. Pity as this
will impede its use in J2ME configurations.

> Why?  What's the practical concern here?

One general concern is that every new type in the core J2SE packages
has to be either explicitly accepted or rejected for J2ME
configurations - those guys count classes for the obvious reasons.
We'd certainly like the JSR-166 stuff to filter down to J2ME where
applicable.

David Holmes





From dl@cs.oswego.edu Fri, 6 Sep 2002 07:18:49 -0400
Date: Fri, 6 Sep 2002 07:18:49 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor method
 names

Gary Gregory wrote:

> A comment on some method names in ThreadExecutor. I think that factory
> methods could be better named. 
> ...
> The current method names name things and do not IMHO say "I am factory that
> makes widgets".

Thanks for the suggestions.

The initial reason we omitted prefixes here is that an upcoming version
of javadoc is planned to automatically place static factory methods in a
separate category, so this reason for name-based-hinting will eventually
disappear. But on second thought, it is probably still worthwhile to 
more closely follow established conventions, so we'll rename them with
"new" prefixes, which seems to be the most common scheme.

-Doug




From TEREKHOV@de.ibm.com Fri, 6 Sep 2002 14:18:54 +0200
Date: Fri, 6 Sep 2002 14:18:54 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] Interupition advantages


David Holmes wrote:

[...posix cancellation/exceptions...]

http://www.opengroup.org/onlinepubs/007904975/functions/xsh_chap02_09.html#tag_02_09_05
(Thread Cancelation, XSH-Normative volume)

http://www.opengroup.org/onlinepubs/007904975/xrat/xsh_chap02.html#tag_03_02_09_20
(Thread Cancelation, Rationale volume)

"The alternative to providing these simple cancelation cleanup
 handlers (whose only use is for cleaning up when a thread is
 canceled) is to define a general exception package that could
 be used for handling and cleaning up after hardware traps and
 software-detected errors. This was too far removed from the
 charter of providing threads to handle asynchrony. However,
 it is an explicit goal of IEEE Std 1003.1-2001 to be
 compatible with existing exception facilities and languages
 having exceptions."

http://groups.google.com/groups?selm=0rGn8.1449%24fL6.28759%40news.cpqcorp.net
(Re: C++ and threads, "...mystery spoof 'murder by death'..." ;-) )

http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/V51_HTML/ARH9RBTE/DOCU0009.HTM#excep_about_pkg

"....
 5.1 About the Exceptions Package

 The exceptions package is a part of the POSIX Threads Library.
 A C language header file ( pthread_exception.h ) provides an
 interface for defining and handling exceptions. It is designed
 for use with the pthreads interface routines. If the exceptions
 package is used, your application must be linked with the
 Threads Library.

 5.1.1 Supported Programming Languages

 The exceptions package can be used only when you are programming
 in the C language. While the exceptions will compile under C++,
 they will not behave properly. In addition, gcc lacks the Compaq
 C extensions that are needed to interact with the native exception
 handling system, and will not interoperate correctly with other
 language exception facilities.

 You can use the C language exception handling mechanism (SEH)
 to catch exceptions. You can catch exceptions in C++ using
 catch(...) , and propagation of exceptions will run C++ object
 destructors. Currently, C++ code cannot catch specific exceptions.
 Also, CATCH , CATCH_ALL and FINALLY clauses will not run when
 C++ code raises an exception. (These restrictions will be reduced
 or removed in a future release.)

 5.1.2 Relation of Exceptions to Return Codes and Signals

 The Threads Library uses exceptions in the following cases:

    - The pthread_exit() routine raises the exception pthread_exit_e
      defined by the Threads Library.

    - Canceling a thread causes the Threads Library to raise the
      exception pthread_cancel_e defined by the Threads Library.

    - On Tru64 UNIX, synchronous signals (such as SIGSEGV) are
      converted to exceptions unless a signal action is declared.

 ...."

> To sum it up in the way I like to express it:
>
> interruption cancels the work
> pthread_cancel cancels the worker

Yep... unless you happen to use some PThreads implementation that
DOES raise cancel exception (Tru64 aside, pthreads-win32 does it
too, f.ex) and simply catch and finalize it... manually enabling
cancel state after setting cancel type back to deferred (just in
case cancel exception can be raised from some async-cancel region).

regards,
alexander.






From dl@cs.oswego.edu Fri, 6 Sep 2002 08:51:21 -0400
Date: Fri, 6 Sep 2002 08:51:21 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Callable.call() throws Exception

Hi Paul; here are a few replies:

On Callable call() vs call(Object arg). I'm sympathetic to your
concerns, but I still believe that defining call to take an argument
is more natural to most people. Given that the main motivation is to
simplify and encourage a standardized way of invoking "functional"
tasks, making the most commonly useful and (apparently) intuitive
version the default still seems like the best tactic. The dl.u.c
package has used this form for four years now, and I cannot recall
receiving a suggestion to change it.

> > I don't like class counting (but it is a practical concern the EG has
> > to be concerned with)
> 
> Why?  What's the practical concern here?
> 

Mostly, it is the "How many words do you really need for snow" question.
(http://www.urbanlegends.com/language/eskimo_words_for_snow_derby.html)
Experts like to, and sometimes need to, make fine distinctions.
Novices and more casual users don't. We try to compromise so that
experts can always get what they need, sometimes less elegantly than
they want, and others don't have to study for a year just to make,
say, a basic threadpool.  As spec lead, I have to balance all the
desires like those expressed on c-i list (almost by definition
experts) with my best guesses about how others might react. Keeping
class count down is one aspect of this.  (But of course, not the only
one.)  For example, at another extreme, some potential users have
suggested hiding/killing nearly all concrete classes and replacing
them with factory methods opaquely handing out implementations that we
experts in our infinite wisdom have chosen for people to use.  As
another example of the tradeoffs here, purists complain about the
decision to make relatively fat Collections interfaces at the expense
of having UnsupportOperationExceptions.  But this framework seems to
be the most successful addition to Java ever.

In other words ...

> But a good design is one
> that has the right number of classes for the job, not the minimal
> number. 

We agree, except "not" should be "not necessarily". 

> But I never really bought into the Error/Exception/RuntimeException
> distinction anyway.

For what it's worth: I agree with David Holmes's reply. The basic
distinction is fine. Several of the choices about which flavor of
exception to use are not. If I knew what to propose, my highest
priority would be to introduce some trivially easy way of rethrowing a
checked as unchecked, thus avoiding the horrible practice of
"catch(Exception ex) {}".  Similarly for the incantations surrounding
interruptions.

Finally to a technical question:

> Assuming there's some queue node class, as David Holmes suggested, to
> make this approach work requires exposing a method for extracting the
> Runnable from a queue node.  Either that or a specification that the
> elements of the queue are exactly the Runnables that were passed in.
> 

The base ThreadExecutor class can and should simply make the latter
guarantee -- that it is a queue of Runnables submitted using
execute. Thanks for pointing out the need to document this.

To make, say, a prioritized thread pool, you'd probably still
want to subclass or wrap around ThreadExecutor to ensure that
all calls to execute provided known forms of Runnables.

-Doug




From paul@paulhaahr.com Sun,  8 Sep 2002 12:03:15 -0700 (PDT)
Date: Sun,  8 Sep 2002 12:03:15 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException

David Homes wrote, replying to me about the exception thrown by
Future.get() wrapping an exception in the underlying Callable:

> > For it to have the general meaning you're giving it, yes,
> > putting it in java.lang.reflect is wrong.
> 
> It probably seemed right at the time. Too late to change. Pity as this
> will impede its use in J2ME configurations.
> 
> > Why?  What's the practical concern here?
> 
> One general concern is that every new type in the core J2SE packages
> has to be either explicitly accepted or rejected for J2ME
> configurations - those guys count classes for the obvious reasons.
> We'd certainly like the JSR-166 stuff to filter down to J2ME where
> applicable.

So what you're saying is:

  - J2ME wants to keep the number of classes down.

  - We want as much as possible of JSR 166 adopted by J2ME.

  - J2ME doesn't include the reflection library and referring to
    java.lang.reflect will impede adoption by J2ME.

I don't quite follow why these three things imply that we want to use
an exception from java.lang.reflect in JSR 166 for something that has
nothing to do with reflection.

Seems to me, we've got a new class for J2ME, regardless of whether it's
in the reflection package (inappropriately) or not, and putting the new
exception in java.util.concurrent might actually ``impede'' the adoption
we're hoping for.

Aside from J2ME, what's the argument against more classes versus the
number of classes that conceptually fit what we're trying to express?

--p




From paul@paulhaahr.com Sun,  8 Sep 2002 12:19:32 -0700 (PDT)
Date: Sun,  8 Sep 2002 12:19:32 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] queue objects for ThreadExecutor

I wrote:
> Assuming there's some queue node class, as David Holmes suggested, to
> make this approach work requires exposing a method for extracting the
> Runnable from a queue node.  Either that or a specification that the
> elements of the queue are exactly the Runnables that were passed in.

Doug wrote:
> The base ThreadExecutor class can and should simply make the latter
> guarantee -- that it is a queue of Runnables submitted using
> execute. Thanks for pointing out the need to document this.

This means that there's no way to prioritize Callables directly, only
the runnables that wrap them, right?

(I note that Executor no longer has a execute(Callable) method, which I
guess is related.)

By the way, I like FutureTask, and especially its constructor that takes
a runnable and an object.  Much better than the hardcoded Boolean.TRUE.

> To make, say, a prioritized thread pool, you'd probably still
> want to subclass or wrap around ThreadExecutor to ensure that
> all calls to execute provided known forms of Runnables.

Depends on how widely accessible the executor is.  Something local
wouldn't need it any more than you'd subclass ArrayList when only
putting objects of a specified type on it.

--p




From paul@paulhaahr.com Sun,  8 Sep 2002 12:55:31 -0700 (PDT)
Date: Sun,  8 Sep 2002 12:55:31 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] class counting

Doug wrote, in response to my question about class counting:

> Experts like to, and sometimes need to, make fine distinctions.
> Novices and more casual users don't. ...  As spec lead, I have to
> balance all the desires like those expressed on c-i list (almost by
> definition experts) with my best guesses about how others might
> react. Keeping class count down is one aspect of this.  (But of
> course, not the only one.) ...

I like the way you've described this trade-off.  I was getting scared
from earlier notes that the class count was being treated far more
seriously than this -- that is, out of proportion with other design
goals.

I've raised two issues which triggered class count reactions so far.
Here are my current opinions:

  Future.get() throws java.lang.reflect.InvocationTargetException

    Novices that I've watched tend to be pretty scared of reflection.  I
    think a new class here is not a fine distinction wanted by an expert,
    but a real desire to have the API say exactly what we mean;  in this
    case, that means saying nothing about reflection and not implying
    that there's reflection going on.

  A superinterface for Runnable and Callable (Executable?)

    This was mostly motivated by my expectation that we'd see both
    Runnables and Callables in the queues used by ThreadExectors.
    Since that's no longer the case, and since Callable appears no
    longer to be a valid argument to Executor.execute(), I withdraw the
    suggestion.

--p




From dl@cs.oswego.edu Sun, 8 Sep 2002 15:59:37 -0400
Date: Sun, 8 Sep 2002 15:59:37 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException

Paul Haahr wrote:

>  things imply that we want to use
> an exception from java.lang.reflect in JSR 166 for something that has
> nothing to do with reflection.

As I've said on EG list, I just cannot get myself to like creating an
new Exception class solely because of questionable package placement
of an existing one that has the right semantics and a good-enough
name.  But the issue really doesn't matter much, and given the
religious fervor here, maybe we ought to anyway.

-Doug





From jozart@csi.com Sun, 8 Sep 2002 13:59:56 -0700
Date: Sun, 8 Sep 2002 13:59:56 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: java.lang.reflect.InvocationTargetException

Paul Haahr writes:

> Seems to me, we've got a new class for J2ME, regardless
> of whether it's in the reflection package (inappropriately)
> or not, and putting the new exception in java.util.concurrent
> might actually ``impede'' the adoption we're hoping for.

Comments:

1. InvocationTargetException has been around since JDK1.1 and is part of the
PersonalJava platform, which is being repackaged as CDC + PersonalProfile
under the J2ME umbrella.

2. The description of InvocationTargetException matches our intended use: "A
checked exception that wraps an exception thrown by an invoked method or
constructor."

3. The place where class counting matters most, however, is down at the CLDC
configuration (MIDP), which does not include the java.lang.reflect package.
Here, I'm not sure which would be more of an impediment: adding a new
exception to java.util.concurrent or using an exception from a package that
is not part of CLDC.

  http://wireless.java.sun.com

--
Joe Bowbeer


----- Original Message -----
From: "Paul Haahr" <paul@paulhaahr.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Sunday, September 08, 2002 12:03 PM
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException


David Homes wrote, replying to me about the exception thrown by
Future.get() wrapping an exception in the underlying Callable:

> > For it to have the general meaning you're giving it, yes,
> > putting it in java.lang.reflect is wrong.
>
> It probably seemed right at the time. Too late to change. Pity as this
> will impede its use in J2ME configurations.
>
> > Why?  What's the practical concern here?
>
> One general concern is that every new type in the core J2SE packages
> has to be either explicitly accepted or rejected for J2ME
> configurations - those guys count classes for the obvious reasons.
> We'd certainly like the JSR-166 stuff to filter down to J2ME where
> applicable.

So what you're saying is:

  - J2ME wants to keep the number of classes down.

  - We want as much as possible of JSR 166 adopted by J2ME.

  - J2ME doesn't include the reflection library and referring to
    java.lang.reflect will impede adoption by J2ME.

I don't quite follow why these three things imply that we want to use
an exception from java.lang.reflect in JSR 166 for something that has
nothing to do with reflection.

Seems to me, we've got a new class for J2ME, regardless of whether it's
in the reflection package (inappropriately) or not, and putting the new
exception in java.util.concurrent might actually ``impede'' the adoption
we're hoping for.

Aside from J2ME, what's the argument against more classes versus the
number of classes that conceptually fit what we're trying to express?

--p






From dholmes@dltech.com.au Mon, 9 Sep 2002 08:41:12 +1000
Date: Mon, 9 Sep 2002 08:41:12 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException

I think this has all been addressed now, but just to clarify one
thing:

> I don't quite follow why these three things imply that we
> want to use an exception from java.lang.reflect in JSR 166 for
> something that has nothing to do with reflection.

I think, as Joe has also stated, that InvocationTargetException has
exactly the right semantics for where we want to use it in JSR-166.
Unfortunately, the fact that it is in java.lang.reflect means that it
would impede usage of JSR-166 in J2ME CLDC. So we have the right
exception but in the wrong place. For that reason, we would/will
define a new exception in j.u.c

David Holmes





From dholmes@dltech.com.au Mon, 9 Sep 2002 08:43:47 +1000
Date: Mon, 9 Sep 2002 08:43:47 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

Alexander Terekhov wrote:
> Yep. Sorry for the confusion. Now [I've double checked it *this*
> time ;-) ], Lock interface seems to have the newCondition() method,
> and the Condition interface seems to have a whole bunch of methods
> which are all supposed to throw IllegalMonitorStateException "if
> lock not held". How does this all fit together?

The Condition interface has now been amended to not require the
throwing of IllegalMonitorStateException.

David Holmes





From larryr@saturn.sdsu.edu 9 Sep 2002 08:41:53 -0000
Date: 9 Sep 2002 08:41:53 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException

> I think, as Joe has also stated, that InvocationTargetException has
> exactly the right semantics for where we want to use it in JSR-166.
> Unfortunately, the fact that it is in java.lang.reflect means that it
> would impede usage of JSR-166 in J2ME CLDC. So we have the right
> exception but in the wrong place.

I think I may not understand all the issues, and I may just be
clueless, so I apologize if I am saying something dumb; it would
be fine with me if the semantics for Future.get() are that it
throws InterruptedException if there was an interrupt, and throws
plain old Exception "if the underlying computation threw an
exception", with the implication that I can use Throwable.getCause
to get the Exception from the underlying computation.


Larry





From dholmes@dltech.com.au Tue, 10 Sep 2002 15:32:38 +1000
Date: Tue, 10 Sep 2002 15:32:38 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] java.lang.reflect.InvocationTargetException

> I think I may not understand all the issues, and I may just be
> clueless, so I apologize if I am saying something dumb; it would
> be fine with me if the semantics for Future.get() are that it
> throws InterruptedException if there was an interrupt, and throws
> plain old Exception "if the underlying computation threw an
> exception", with the implication that I can use Throwable.getCause
> to get the Exception from the underlying computation.

Two things that make that option less attractive than it might seem:

a) Even if you don't care about catching the IE (say you'll propagate
it) you are forced to have two catch clauses to separate the IE from
the plain Exception carrying the real cause.

b) As it relies on 1.4 exception capabilities and that may impede its
usage in other J2SE or J2ME platforms.

Probably worth thinking about though.

David Holmes





From paul@paulhaahr.com Tue, 10 Sep 2002 16:37:16 -0700 (PDT)
Date: Tue, 10 Sep 2002 16:37:16 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

This is a jumble of collected comments about things that stuck out;
hopefully none are as controversial as things I said before (but I
thought those would be uncontroversial, too).  Most are probably just
requests for clarifications in the documentation.


AtomicReference says:

  attemptUpdate(java.lang.Object expect, java.lang.Object update)

    Atomically set the value to the given updated value if the current
    value is equal to the expected value.

I assume this means ``is == to'' and not ``is .equals() to''?


CopyOnWriteArrayList and CopyOnWriteArraySet:

  (1) I keep thinking that it's possible to copy only those instances of
  the underlying structures for which iterators have been created but
  without locking.  My schemes, however, end up doubling the memory
  needed in the steady state and doubling the amount of work needed.
  Nonetheless, it would be nice if the description were to admit an
  implementation which didn't copy on every write.

  (2) Truly atrocious names, though useful classes.  Can we at least
  drop ``Array'' from the names?


ScheduledExecutor:

  (1) This class has no cancellation.  I take it you do cancellation by
  submitting a FutureTask (or something like it) that handles
  cancellation internally?  (I approve of such an answer.)

  (2) For executePeriodically and executeAtFixedRate, if one execution
  of the Runnable throws an Exception, does it run again or does an
  exception remove it from the queue?

  (3) For executeAtFixedRate, can two executions of the same runnable
  overlap?


FifoSemaphore:

  Wouldn't FIFOSemaphore match existing Java conventions (e.g.,
  URLConnection) better?

  Why FIFOSemaphore but not FIFOReentrantLock?  Or LIFOSemaphore?
  (Probably just a documentation issue.)


Locks:

  There are two obvious missing cases here (attempt with multiple locks
  or objects and a timeout) and I can guess why they're not included (I
  can't think of an efficient implementation), but, at very least, that
  should be documented.  Or if someone knows a good way to build them...


Queue and BlockingQueue:

  Offering isEmpty(), size(), and toArray() as part of this interface
  seems wrong, because BlockingQueue is a subinterface.  The collections
  which implement queue will already have those methods, but asking for
  size() of a BlockingQueue seems like a way to get yourself in trouble.
  (Perhaps that's what UnsupportedOperationExceptions are for?)


ReentrantLock:

  isHeldByCurrentThread() seems like too long a name.


Condition and Lock:

  I know why the defaults are what they are, but the await
  vs. awaitUninterruptibly example makes lock vs. lockInterruptibly seem
  strange.  I don't know that consistency is worth anything, but the
  document should spell out that this is for compatibility with the
  underlying Java constructs.


Finally, I really like this package.  I'm thrilled that Java will have
standard notation for queues, thread pools, and reader/writer locks.
The cleanups to Thread are something it's needed for a long time.  And
the Atomic* classes are a best-of-breed addition -- providing some low
level functionality in a clean and high-level way.  Many thanks to Doug
and the EG.

--p




From dawidk@mathcs.emory.edu Tue, 10 Sep 2002 21:25:10 -0400
Date: Tue, 10 Sep 2002 21:25:10 -0400
From: Dawid Kurzyniec dawidk@mathcs.emory.edu
Subject: [concurrency-interest] Futures, callbacks, callables, runnables, and executors once again

Hello everybody,

Since it is my first posting to this group, let me first introduce
myself. My name is Dawid Kurzyniec, and I am working on distributed
systems at Emory University, for a couple years now. I have been using
Doug Lea's package for a few months (and some other libraries earlier),
especially the part related do futures - mostly in the context of
asynchronous remote invocation. 

Anyway, I think I made my homework of checking out the current API draft
+ list archives. First let me say that I think that java.util.concurrent
is heading in the right direction, and I can't wait to see it in J2SE
(as that will make software I develop little more lightweight :)
However, I have some comments about the API so I would like to
contribute yet another voice into the discussion :) Just to shake things
up again :)

So, let me address the futures first:

1. I believe that future in Java should be an interface. Well, it is in
the current API draft, but - unless I did something wrong, which is
quite likely - it was a class (as in dl.u.c) for some short time a few
days ago. So, let me just go on here anyway:
i) You would probably agree that future is an abstract programming
concept which essence is wait-by-neccessity. General practice in Java
(and even more true in java.util) is to represent abstract concepts with
interfaces. 
ii) The simple interface having only get() and isCompleted() methods
nicely encapsulate the wait-by-neccessity concept, whereas a full-blown
implementation class (like FutureTask) hinders it with other
functionality.
iii) I anticipate usage of j.u.c.Future in much broader context than
just j.u.c - it will be used in third-party libraries as well. For
instance, it makes perfect sense to make Future a return value from
remote method invoked asynchronously. Forcing everybody to use a
specific implementation class would be too much of a constraint; one
counterexample that comes to my mind (perhaps not the best one) is of a
future that is a remote object, with get() being a remote method.

2. Futures vs callbacks. There are two ways of dealing with asynchronous
completion that I am aware of: 1) futures and 2) callbacks. To my best
knowledge, none is proclaimed to be generally superior to the other (for
instance, CORBA supports both). Currently, java.util.concurrent supports
only futures, and callbacks are left out (is there a specific reason for
that?). This does not seem like a big deal, since you can simply put any
callback invocation at the and of your callable.call (or runnable.run).
However, it gets a little bit more complicated when you have to deal
with third-party callables. Also, consider ScheduledExecutor (aka
DelayableThreadExecutor). I completely agree with Paul Haahr that there
is little reason in returning a Future from executePeriodically-kind of
methods (as I see, it has been actually changed so they now return
void). However, it would make perfect sense to use callbacks in this
context, since they may be invoked more than once. 

These two cases make me thinking that callbacks actually may deserve
explicit treatment in the j.u.c. and that it could make the API more
consistent. What I propose is to introduce callback interface of some
form, e.g.:

public interface Callback {
    void callback(Object arg);
    void callbackOnException(Throwable cause);
}

(It could actually make sense to make this a static subinterface of
Callable). Then, there could be a static method:

public static Callable addCallback(Callable c, Callback cb) {
    return new Callable() {
        public Object call() throws Exception {
            Object result;
            try {
                result = c.call();
            }
            catch (Exception e) {
                cb.callbackOnException(e);
                throw e;
            }
            catch (RuntimeException e) {
                cb.callbackOnException(e);
                throw e;
            }
            catch (Error e) {
                cb.callbackOnException(e);
                throw e;
            }
            cb.callback(result);
        }
    };
}

The question is where this method should be placed - I would argue to
create java.util.concurrent.Callables class, by analogy to
java.util.Collections and java.util.Arrays. Of course it would look
weird if this was the only method in such a  class, but I think there
are more methods that could go there, and if there are still not enough,
maybe some other static class, shared by the whole j.u.c, could be used
instead.

Code snippet:

Callable c = new MyCallable(...);
Callback cb = new MyCallback(...);
// use callback with scheduled executor:
ScheduledExecutor se = new ScheduledExecutor(...);
se.executePeriodically(Callables.addCallback(c, cb)); // and with
ordinary executor, instead of future: Executor e = ...;
e.execute(Callables.addCallback(c, cb));

The question remains what to do with cancellability of tasks submitted
to ScheduledExecutor; EG must be thinking about it since "returns
Future" has been removed. Maybe the "Cancellable" interface would not be
so bad idea after all?... executePeriodically could just return
cancellable; futures could (optionally) implement cancellable (e.g.
FutureTask would), plus the interface is so generic that it could
actually go into the java.util, alongside with Observable and the like.


3. This one may be hard to win, but let me try it anyway. I liked the
version of Executor that took callable and returned future a whole lot
better than the new (or should I say old) version, that accepts
runnables and returns void. In general, I would prefer futures in Java
to be created by the invokee, not the invoker. There are the reasons for
that:

i) I would like to think of futures in analogy to postal tracking
numbers. You prepare your shipment (callable), bring it over to the
shipping company (executor) and you get back a receipt with a tracking
number (future) that allows you to check status of your shipment at any
time. Alternatively, you can give the shipping company your address
(instance of a callback) and they send you delivery acknowledgement when
your shipment reaches its destination.

ii) I think that such natural analogy would make the concept easier to
comprehend for new users. For instance, when I came across dl.u.c for
the first time, I found the future setter mechanism rather peculiar. On
the other hand, when I first saw ProActive that also uses futures
(http://www-sop.inria.fr/sloop/javall/) it seemed very natural and it
was easy to grasp.

iii) It seems to me, callable (and runnable) itself does not have
anything to do with asynchronous execution. In particular, it carries no
invocation-related state and so it can be reused. On the other hand,
future is strictly bound to a concrete asynchronous invocation, and has
a lot of state in it. Thus, I would like having this two concepts
clearly separated in the class library. The current version does the
opposite, mandating usage of FutureTask (the only one realization of a
future in j.u.c) that implements both Runnable and Future. (However, I
appreciate reasons that inspired this change, and I am not saying we
should get rid of FutureTask - I think these two concepts can go
together; let me come back to this later).

iv) In libraries that support asynchronous, non-blocking method
invocation (usually remote, like ProActive or ARMI
http://citeseer.nj.nec.com/39174.html), it is a common practice to use
some sort of future as a return value from a non-blocking call. Since
executor.execute() is nothing but a way to perform asynchronous,
non-blocking method invocation, it would seem consistent to me if
execute() returned Future as well.

v) Error resistance. Perhaps the single most important point here. If it
is the invoker to create future, what will prevent him to submit it to
more than one executor at the same time?... Of course, you can tell
people not to do it, but they will, anyway :) And, it can lead to very
subtle bugs. So, is it not better to make this kind of mistakes
impossible by design?... (A solution facilitated by the current API
draft is to have execute-once semantics for FutureTask, but still, that
kind of programming errors are then captured as late as at the runtime).

vi) Cancellation. I think that it is the executor who knows best how to
cancel submitted task. So, if the executor created futures, it could
provide future.cancel() with appropriate cancellation semantics. For
example, if this is a remote call, fancy executor could forward
cancellation request to the remote host - simple interruption of a local
thread does not seem to be sufficient in this case. I am not sure how
you are going to deal with this problem in FutureTask. 

Also, if it was executor to create futures, it could furnish them with
some optional features. For example, assuming the "Cancellable"
interface was agreed upon, callables could optionally implement
cancellable. Then, executors could choose to check this inside
"execute", and return cancellable futures for cancellable callables, and
plain futures for non-cancellable ones.

vii) consistency of the API. If executors returned futures, it would
imply they would accepted callables rather than runnables. And I think
that would be good. I am afraid that mixing callables and runnables in
one class library is somewhat confusing, so I think that runnables
should not really be first-class citizens of j.u.c - I believe it would
be good enough to provide some convenience static methods for them, e.g.
wrapping them in callables.

Now, let me address Joseph Bowbeer comments that (probably) motivated
the change:
> I can see your point, and I also observe that executeAsFuture is less 
> functional in at least one way than letting the user create the 
> Runnable task (aka BasicFuture).  When the executor creates the Future

> task and returns it to the caller, the caller is not guaranteed to get

> its hands on the task "handle" before the task starts.  In fact, the 
> caller may not receive the handle until after the task has finished.
> In the past I have found it necessary to have an active task's
> handle "firmly in hand" before the task executes.

Well, without an example I am not quite sure in what context it really
matters. As I said, for me invoking execute() is like sending a shipment
- it indicates some commitment to do the thing. If I change my mind, I
can rush to the post office and try to get my package back, but there is
no guarantee that it has not already shipped (or even been delivered).
However, I assume there are situations when it matters. Actually, I do
agree that the concept of "executable task" that encapsulates both
callable and future, makes sense anyway. So, why not doing this by
adding execute(Executor executor) method to the FutureTask directly:

class FutureTask implements Future {
   Callable callable;
   Future future;
   public FutureTask(Callable callable) {
      this.callable = callable;
   }
   public synchronized void execute(Executor executor) {
      if (future != null) throw new IllegalStateException();
      future = executor.execute(callable);
      notifyAll();
   }
   public synchronized Object get() throws ... {
      if (future == null) wait();
      return future.get();
   }
   ... and so on
}

One other thing: I agree with Paul and Joseph that "executeAsFuture is a
hack". I like the Paul's solution with Callable.ForRunnable class, but I
think it would be more consistent with java.util to use static factory
method instead. So how about this:

public static Callable wrap(final Runnable runnable) {
    return new Callable() {
        public Object call() {
            r.run();
            return Boolean.TRUE;
        }
    };
}

(and/or the same with (final Runnable runnable, final Object result)). I
would add this method to the Callables class I proposed (now it would
had 2 or even 3 methods); otherwise, the method name should be changed
to reflect dependency on callables.


4. This one looks like it is being currently addressed by EG, but let me
go through it and express my opinion. I would argue to make futures
immutable, that is, to impose a requirement that any future is
determined at most once, and that its result, once determined, never
changes. It looks like current FutureTask already has this property,
since set() and setException() are now protected and reset() has
dissapeared, but I would be even happier to see it as an explicit
functional requirement in Future's javadoc. 
Here are reasons:

i) it seems consistent with definitions of a future that I came across
(e.g. "future is a read-only capability of a logic variable")

ii) it seems consistent with the spirit of Java: Java usually prefers
immutability to reusability (examples: strings, primitive type wrappers,
InetAddress)

iii) there actually very limited usage scenarios when reuse of a future
is safe; it is only when invoker does not share the future with anyone
else and if he is positive that executor that deals with this future
also does not share it with anyone else. It cannot be guaranteed in
general case, if people use third-party executors. We could forbid
executors to share futures but it looks like much less natural
constraint than the immutability constraint placed on the future
directly.

iv) Error resistance. In cases when reuse of a future is not safe, it
will lead to very subtle bugs. Consider this example. My company
develops some software that consists of independent modules written by
independent programmers. Let there be modules M1 and M2 in the picture.
Now, lets say I am responsible for module M1, and I make asynchronous
call that M2 also expressed interest in. So, I faithfully pass the
future to M2. When the result arrives, it may happen that M2 gets it
first, and if it is clueless, it can try to reuse the future (e.g. call
reset). Then, by the time I check the result, the future may can
actually be undetermined again, or - even worse - determined with a
different result. Now my module does not work, but it may not be
obvious: instead of throwing exceptions, it may e.g. show incorrect
dollar amounts. And - guess who would be blamed for that?

v) FutureTask is rather lightweight (I guess about 20 bytes per
instance), so its creation time should not be of much concern. I think
that it is the callable itself that may be more heavyweight, but it can
be reused so there is no problem here.


Other things:

5. How about renaming FutureTask to just Task? 

6. Regarding the discussion on InvocationTargetException. I do agree
with David Holmes that InvocationTargetException "has exactly the right
semantics for where we want to use it in JSR-166", and I would stick
with it. Regarding the concern about J2ME CLDC. In my understanding, in
case JSR 166 introduced a new exception in place of
InvocationTargetException, CLDC would have to accept this new exception
class anyway to support j.u.c. So, couldn't CLDC include
java.lang.reflect.InvocationTargetException instead, without any other
stuff from java.lang.reflect package?... Is that so big problem that
fully qualified name of this class contains the "r" word? I know this is
a little bit of a hack, but only because InvocationTargetException is
not where it should be in the first place. On the other hand, it has
excellent name and matching semantics.

Paul Haahr is concerned that "r" word may confuse novice users. I agree,
but I do believe that having two exception classes in the core Java
library that have exactly the same semantics (and perhaps name) but
different package placement would be much more confusing.

However, I don't think this issue is of so big practical importance, so
I will buy whatever is decided. If this battle is unresolvable, you
might want to consider little altered Future interface that avoids the
problem:

interface Future {
    void waitFor();
    void waitFor(timeout);
    /** throws IllegalStateException if future is not yet 
        determined, or if the exception occured */
    Object getResult();
    /** returns the cause of abrupt completion, or null if 
     *  completed successfully. Throws IllegalStateException
     *  if future is not yet determined. */
    Throwable getException();
}

I have been used this version for some time now; the disadvantage is
that you need at least two invocations (three in general case) to do
wait-by-necessity, but the advantage is that if you know that your
callable does not throw checked exceptions, you can omit getException()
step and you do not have to wrap getResult() in the try {} block.

(Just yet another idea, I will not insist on that if nobody likes it)


7. Callable.call() with or without argument. I vote without; I agree
with Paul on this, however, I can understand the points in favor of the
version with a single argument so I will not cry whatever the final
decision is. Not so important issue in my opinion.

8. Common subinterface of callable and runnable: I would vote against,
as I would make callable the "first class citizens" of in j.u.c. For
runnables, I would only include static factory method to wrap them into
callables.

Cheers,
Dawid






From larryr@saturn.sdsu.edu 11 Sep 2002 02:24:14 -0000
Date: 11 Sep 2002 02:24:14 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

> CopyOnWriteArrayList and CopyOnWriteArraySet:
>   (2) Truly atrocious names, though useful classes.
>       Can we at least drop ``Array'' from the names?

How about "COW" instead of "CopyOnWrite"?  Is "COW" that
much less recognized a buzzword than "CopyOnWrite"; in
other words is "CopyOnWrite" really meaningful by itself?


> FifoSemaphore:
>   Wouldn't FIFOSemaphore match existing Java conventions (e.g.,
>   URLConnection) better?

I think in the early Java days they were doing, for
example "Http", but I think it has become acceptable
to put acronyms in all upper-case...  I hope so.

I definitely prefer FIFOSemaphore to FirstInFirstOutSemaphore. :-)


> ReentrantLock:
>   isHeldByCurrentThread() seems like too long a name.

How about isHBCT()?  No, ok, then how about verifyThread()?


Larry





From paul@paulhaahr.com Tue, 10 Sep 2002 20:11:57 -0700 (PDT)
Date: Tue, 10 Sep 2002 20:11:57 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

> How about "COW" instead of "CopyOnWrite"?  Is "COW" that
> much less recognized a buzzword than "CopyOnWrite"; in
> other words is "CopyOnWrite" really meaningful by itself?

I tend to dislike acronyms, so I'd hope it stayed CopyOnWrite.  On the
other hand, I see your point -- CopyOnWrite is pretty much a single
concept separated from the underlying words.

> > ReentrantLock:
> >   isHeldByCurrentThread() seems like too long a name.
> 
> How about isHBCT()?  No, ok, then how about verifyThread()?

I was hoping for something shorter than the current proposal, but
both of those seem fairly unclear.  Since Thread.holdsLock() is the
model here, I would see the analogous name being currentThreadHolds().
Though I'm not sure the tense is right...

Probably best to leave the name alone.

--p




From dl@cs.oswego.edu Wed, 11 Sep 2002 06:20:03 -0400
Date: Wed, 11 Sep 2002 06:20:03 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

Paul, thanks for the comments. Some replies:

> AtomicReference says:
> 
>   attemptUpdate(java.lang.Object expect, java.lang.Object update)
> 
>     Atomically set the value to the given updated value if the current
>     value is equal to the expected value.
> 
> I assume this means ``is == to'' and not ``is .equals() to''?

Thanks. Clarified. We still have a lot of specification/documentation
left to do.

> 
> 
> CopyOnWriteArrayList and CopyOnWriteArraySet:
> 
>   (1) I keep thinking that it's possible to copy only those instances of
>   the underlying structures for which iterators have been created but
>   without locking.  My schemes, however, end up doubling the memory
>   needed in the steady state and doubling the amount of work needed.
>   Nonetheless, it would be nice if the description were to admit an
>   implementation which didn't copy on every write.

Some improvements over dl.u.c version are indeed possible, that may
eliminate need for so many writes. Also, we are assuming passage of
JMM JSR (133), which will itself allow some speedups compred to
dl.u.c. version.


> 
>   (2) Truly atrocious names, though useful classes.  Can we at least
>   drop ``Array'' from the names?

I don't think so. 

> 
> 
> ScheduledExecutor:

This is among the last classes we are putting together. I'll withhold
comments for now.
> 
> FifoSemaphore:
> 
>   Wouldn't FIFOSemaphore match existing Java conventions (e.g.,
>   URLConnection) better?

Josh Bloch especially likes "FifoSemaphore" name better.  I decided to
accept the suggestion of the author of the best selling book on Java
style :-)

> 
> 
> Locks:
> 
>   There are two obvious missing cases here (attempt with multiple locks
>   or objects and a timeout) and I can guess why they're not included (I
>   can't think of an efficient implementation), but, at very least, that
>   should be documented.  Or if someone knows a good way to build them...

Right.

> 
> 
> Queue and BlockingQueue:
> 
>   Offering isEmpty(), size(), and toArray() as part of this interface
>   seems wrong, because BlockingQueue is a subinterface.  The collections
>   which implement queue will already have those methods, but asking for
>   size() of a BlockingQueue seems like a way to get yourself in trouble.
>   (Perhaps that's what UnsupportedOperationExceptions are for?)

Having a size() method and something like toArray were among the most
frequently requested features of dl.u.c.Channels. I had omitted them
there because of the same concerns you express, but there do turn out
to be many legitimate, good usages. For example, in monitoring
faciltiies that check queue lengths periodically and then maybe add
consumer threads or slow down producers.

> 
> ReentrantLock:
> 
>   isHeldByCurrentThread() seems like too long a name.

Yes, it does seem that way. But is still the best we know.

> 
> 
> Condition and Lock:
> 
>   I know why the defaults are what they are, but the await
>   vs. awaitUninterruptibly example makes lock vs. lockInterruptibly seem
>   strange.  I don't know that consistency is worth anything, but the
>   document should spell out that this is for compatibility with the
>   underlying Java constructs.
> 

Right. The slogan is: locking is by default not interruptible, but
waiting is by default interruptible. It bothered us too that the
defaults differ, but it is most consistent with builtin monitors, and
you can still get the other behavior.

-Doug




From dl@cs.oswego.edu Wed, 11 Sep 2002 08:42:30 -0400
Date: Wed, 11 Sep 2002 08:42:30 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Futures, callbacks, callables, runnables, and executors once again

Dawid, thanks for the comments.

First, an aside: One of the risks I take in making the actual APIs du
jour that are being discussed by expert group available to anyone is
that it sometimes includes versions that exist only for a day or two
just to see what we think. For those who don't like the uncertainty
of all this: When we hit a version that we believe is stable, I'll
post announcement to this list.

> 1. I believe that future in Java should be an interface. 

We do too.

> 2. Futures vs callbacks. 

Thanks for the suggestion. We'll consider something along these lines.

> 3. This one may be hard to win, but let me try it anyway. I liked the
> version of Executor that took callable and returned future 

Sorry! There seem to be only two good approaches to this API, and of
these the (current) separate FutureTask version seems to have fewer
problems.

> 4. This one looks like it is being currently addressed by EG, but let me
> go through it and express my opinion. I would argue to make futures
> immutable, that is, to impose a requirement that any future is
> determined at most once, and that its result, once determined, never
> changes. It looks like current FutureTask already has this property,
> since set() and setException() are now protected and reset() has
> dissapeared, but I would be even happier to see it as an explicit
> functional requirement in Future's javadoc. 

There are a few situations in which Future resettability is almost a
necessity. Consider for example the Computation Trees in section 4.4.2
of my CPJ book, where the Futures need to be reset after each
iteration of the entire tree computation (alternatives would be
awkward and/or slow). The argument against supplying it even it
protected form in (concrete) FutureTask is that in most (all?)  such
applications, you'd need to create a custom Future implementation
class anyway. But it remains a reason not to require immutability as
an interface contract.


> 5. How about renaming FutureTask to just Task? 

I don't want to have a class just called "Task" here, because the name
is so commonly used (and in many different senses) in existing
applications, many of which might be adapted to use j.u.c classes, in
which case the name-clash would be a big problem.

> 6. Regarding the discussion on InvocationTargetException. ...

My final(!) take of all the views expressed on this is that the
balance of argument was to add j.u.c.ExecutionException, even though
it still bothers me a little to do it.

> 7. Callable.call() with or without argument. I vote without.

We did too. (BTW, contrary to something I wrote on this list last
week, this is in keeping with dl.u.c verssion.)

-Doug






From larryr@saturn.sdsu.edu 11 Sep 2002 19:43:34 -0000
Date: 11 Sep 2002 19:43:34 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

> > FifoSemaphore:
> > 
> >     Wouldn't FIFOSemaphore match existing Java conventions
> >     (e.g., URLConnection) better?
> 
> Josh Bloch especially likes "FifoSemaphore" name better.
> I decided to accept the suggestion of the author of the
> best selling book on Java style :-)

The only Java style book with a link from the J2se docs page
and prestigious "The Java(Tm) Series... from the Source(Tm)" seal!
Designer of the award winning Java(Tm) Collections framework!  :-)

I prefer new class names follow the initial acronym capitalization
conventions of this (small) sample of the existing core Jdk classes:

java.awt.AWTEvent
java.awt.image.RGBImageFilter
java.beans.XMLEncoder
java.io.EOFException
java.io.IOException
java.net.URL
java.rmi.server.RMIClassLoader
java.security.interfaces.RSAKey
java.sql.SQLData
java.util.logging.XMLFormatter

Ignoring the convention for writing acronyms outside the software
programming world, I think even a perusal of the Jdk 1.4 classes
will show that the number of mixed case initial acronyms is a
fraction of the number of all upper-case initial acronyms.

http://java.sun.com/j2se/1.4.1/docs/api/allclasses-frame.html


Personally, I like FiFoSemaphore... (o:>


Larry





From tim@peierls.net Wed, 11 Sep 2002 16:24:05 -0400
Date: Wed, 11 Sep 2002 16:24:05 -0400
From: Tim Peierls tim@peierls.net
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

Larry Riedel wrote:
> I prefer new class names follow the initial acronym capitalization
> conventions ... a perusal of the Jdk 1.4 classes will show that the 
> number of mixed case initial acronyms is a fraction of the number 
> of all upper-case initial acronyms.

"Jdk" -- I get it. :-)


Doug Lea wrote:
> > Josh Bloch especially likes "FifoSemaphore" name better.

Must have been a private communication. I can't find any mention
of the issue in the archives. The relevant section of "Effective
Java" reads:

"There is little consensus as to whether acronyms should be uppercase 
or have only their first letter capitalized. While uppercase is more 
common, a strong argument can be made in favor of capitalizing only 
the first letter. Even if multiple acronyms occur back-to-back, you 
can still tell where one word starts and the next word ends. Which 
class name would you rather see, HTTPURL or HttpUrl?"

This is consistent with Larry's claim, and is hardly an appeal for 
mindless enforcement of a rule.

In this instance, unless there is a popular operating system from 
the Factory Instantiation Foundation that I don't know of, 
FIFOSemaphore is pretty unambiguous. 

But I still prefer the latter because "fifo" has entered the 
technical lingo as a word -- unlike "http", it can be pronounced 
as one -- which means it need not be subject to acronym case 
conventions. And that way we don't have to spend any more time 
on it.

OK? Ok. :-)

--tim





From tim@peierls.net Wed, 11 Sep 2002 16:26:46 -0400
Date: Wed, 11 Sep 2002 16:26:46 -0400
From: Tim Peierls tim@peierls.net
Subject: [concurrency-interest] my remaining comments on JSR 166 draft APIs

Tim Peierls wrote:
> But I still prefer the latter ...

I lost the referent of "latter" while editing. I meant to say that
I prefer "FifoSemaphore", in case that wasn't clear.

--tim





From dholmes@dltech.com.au Thu, 12 Sep 2002 12:23:27 +1000
Date: Thu, 12 Sep 2002 12:23:27 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

Just following up with something that was on hold

> David Holmes wrote:
> > effort making non-reentrant locks fast - *especially*
> > when you take into account that these locks must also be
> > interruptible ...

Alexander Terekhov replied:
> But why the heck "these locks must also be interruptible"?

The default is that lock() is not interruptible, but all Lock
implementations must implement lockInterruptibly, just as they must
support tryLock with a timeout. The implementation is free to
implement these in the most convenient way without having to give any
kind of performance guarantees. So lock() and tryLock() might map down
to pthread_mutex_lock and pthread_mutex_trylock, for example, and
somehow interruptible locking and timed locking will be built on top
of that. Locks that guarantee ordering will have to document whether
interruptible locking and timed locking are guaranteed to preserve
that order - they need not.

This approach was considered the most appropriate given the possible
permutations on supporting (or not) interruptability and timeouts, and
even tryLock itself.

David Holmes





From dawidk@mathcs.emory.edu Fri, 13 Sep 2002 01:30:31 -0400
Date: Fri, 13 Sep 2002 01:30:31 -0400
From: Dawid Kurzyniec dawidk@mathcs.emory.edu
Subject: [concurrency-interest] Futures, callbacks, callables, runnables, and executors once again

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Doug Lea
> Sent: Wednesday, September 11, 2002 8:43 AM
> To: Concurrency-Interest
> Subject: Re: [concurrency-interest] Futures, callbacks, 
> callables, runnables, and executors once again

Let me answer in the reverse order:

> > I would argue to make futures 
> > immutable, that is, to impose a requirement that any future is 
> > determined at most once, and that its result, once 
> > determined, never 
> > changes. It looks like current FutureTask already has this 
> > property, 
> > since set() and setException() are now protected and reset() has 
> > dissapeared, but I would be even happier to see it as an explicit 
> > functional requirement in Future's javadoc.
> 
> There are a few situations in which Future resettability is 
> almost a necessity. Consider for example the Computation 
> Trees in section 4.4.2 of my CPJ book, where the Futures need 
> to be reset after each iteration of the entire tree 
> computation (alternatives would be awkward and/or slow). The 
> argument against supplying it even it protected form in 
> (concrete) FutureTask is that in most (all?)  such 
> applications, you'd need to create a custom Future 
> implementation class anyway. But it remains a reason not to 
> require immutability as an interface contract.

Well, this example does not seem to use futures, but I see your point -
you might use resettable future for fork-join. However, I believe that
in this case (and actually in any other case when you might be tempted
to use resettable futures) callbacks are better alternative. For
Computation Trees, you need some kind of a barrier; here is a solution
with callbacks:

private class Barrier implements Callback {
    int total;
    int idx;
    Barrier(int total) { this.total = total; }
    synchronized void callback(Object arg) {
        idx++;
        if (idx == total) {
            notifyAll();
        } else if (idx > total) {
            throw new IllegalStateException();
        }
    }
    public synchronized void reset() { idx = 0; }
    public synchronized void waitFor() throws ... {
        while (idx < total) wait();
        
    }
}

Barrier barrier = new Barrier(tasks.length);

for (i=0; i<tasks.length; i++) {
    tasks[i] = Callables.addCallback(tasks[i], barrier);
}

void coInvoke() {
    for (int i=0; i<tasks.length; i++) {
        executor.execute(tasks[i]);
    }
    barrier.waitFor();
    barrier.reset();
}


Now I don't think it is awkward at all; actually I think it looks more
natural than using resettable future as a barrier. And it has no
performance penalty.

> > I liked the 
> > version of Executor that took callable and returned future
> 
> Sorry! There seem to be only two good approaches to this API, 
> and of these the (current) separate FutureTask version seems 
> to have fewer problems.

First of all, I did not argue against FutureTask. Second of all, I think
that such an important design decision deserves more elaborate rationale
than that. I don't think that the points I made in my previous mail have
been discussed in public yet. I made every effort to present them
clearly and distinctively, so that they were easy to address one by one.
So, I will appreciate if you describe problems with { Future
execute(Callable) } you refer to, and explain why they are worse than
problems with { void execute(Runnable) } I listed.

Also, I would be happy to hear other people's opinion on that.

Actually, I have two more arguments supporting { Future
execute(Callable) }:

viii) with Future execute(Callable), Executor interface nicely binds
three concepts of the new API: executors, futures, and callables. They
then look like three pieces of the same picture. Also, people would be
likely to associate executors with callables in their minds. Callable
would become a fundamental, native component of the API, and Runnable
would have a status of external component that is supported for
convenience. Otherwise, foundation of the Callable (and the Future) in
the API is kind of weak: it looks like the Callable is used only in one
place (the FutureTask constructor); not much better for the Future. It
will raise questions why those interfaces are there anyway. Also, mixing
Runnables with Callables in single API is confusing, much like it would
be to mix Iterators with Enumerators.

ix) I think that despite obvious similarities, there is a conceptual
difference between threads and executors. Thread is meant to _run_ the
code, usually "forever" - with unbound duration. It is quite common that
thread terminates before its code has finished: it is true for all
threads when program is stopped with System.exit(), and for daemon
threads when non-daemon threads finished. Runnable.run(), that does not
return any value, is a perfect solution here. On the other hand, the
primary usage pattern of executors is to _call_ the code. That is, the
duration of the execution is bound, and somebody is usually waiting for
the code to finish and yield some result. This allows to reuse threads -
otherwise, why bother to use executors at all. Consequently, I think
that { Object call() } is much better choice here. 


>From your reply, I guess that there is a performance concern about {
Future execute(Callable) }, related to inability to reuse futures and to
the cost of creating them on every execute() call. Let me - in advance -
argue with that. First of all, most futures will have very simple
constructors, in comparison to the code of typical execute() method. It
looks to me like an overhead of scheduling asynchronous task will easily
outweight creation time of a small object. Second of all, in many
scenarios you do not care about futures at all (as you could have used
callbacks, like in the example with computation trees). In such case,
you may disregard future object returned by execute(). Since
constructors of futures will not usually have side effects, JIT may
actually be able to get rid of the object creation completely, reducing
this to essentially no-cost operation. Anyway, all of this is a
speculation, but if you decide to trade design for performance, you must
have strong evidence that you actually gain any of it. Without the
actual figures, the performance argument against { Future
execute(Callable) } seems rather weak.

> > 5. How about renaming FutureTask to just Task?
> 
> I don't want to have a class just called "Task" here, because 
> the name is so commonly used (and in many different senses) 
> in existing applications, many of which might be adapted to 
> use j.u.c classes, in which case the name-clash would be a 
> big problem.

True.

> > 6. Regarding the discussion on InvocationTargetException. ...
> 
> My final(!) take of all the views expressed on this is that 
> the balance of argument was to add j.u.c.ExecutionException, 
> even though it still bothers me a little to do it.

Me also, but as I said - I am buying, whatever :)

Regards,
Dawid





From ggregory@seagullsw.com Fri, 13 Sep 2002 21:09:49 -0400
Date: Fri, 13 Sep 2002 21:09:49 -0400
From: Gary Gregory ggregory@seagullsw.com
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C25B8B.6C404BD0
Content-Type: text/plain;
	charset="iso-8859-1"

Hello,

The constructor for ThreadExecutor allows for a
java.util.concurrent.BlockingQueue workQueue parameter but there is no
setQueue() API. There is a setter method for all other items passed in
though. Is this a simple omission?

The setMinimumPoolSize/setMaximumPoolSize APIs do not specify if or when or
how the pool is grown or shrunk to meet the new size. A little more details
in these comments would be appreciated.

Thank you,
Gary

------_=_NextPart_001_01C25B8B.6C404BD0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
5.5.2654.45">
<TITLE>[concurrency-interest] JSR 166 draft API - =
ThreadExecutor</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=3D2>Hello,</FONT>
</P>

<P><FONT SIZE=3D2>The constructor for ThreadExecutor allows for a =
java.util.concurrent.BlockingQueue workQueue parameter but there is no =
setQueue() API. There is a setter method for all other items passed in =
though. Is this a simple omission?</FONT></P>

<P><FONT SIZE=3D2>The setMinimumPoolSize/setMaximumPoolSize APIs do not =
specify if or when or how the pool is grown or shrunk to meet the new =
size. A little more details in these comments would be =
appreciated.</FONT></P>

<P><FONT SIZE=3D2>Thank you,</FONT>
<BR><FONT SIZE=3D2>Gary</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C25B8B.6C404BD0--




From education_saver1@yahoo.com Sat, 14 Sep 2002 00:52:44 -0400
Date: Sat, 14 Sep 2002 00:52:44 -0400
From: Erlinda Irwin education_saver1@yahoo.com
Subject: [concurrency-interest] Deep Academic Software Discounts

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Office XP Standard at 70</title>
</head>

<body>

<div align="center">
  <center>
  <table border="0" width="60%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
        <p align="center">Office XP Standard at <font color="#FF0000"><b>70%</b></font>
        OFF,<br>
        Adobe Photoshop at <font color="#FF0000"><b>52%</b></font> OFF,&nbsp;<br>
        Microsoft Visual Studio.NET at <font color="#FF0000"><b>91%</b></font>
        OFF,<br>
        Macromedia Studio MX at <font color="#FF0000"><b>76%</b></font>
        OFF,&nbsp;<br>
        Adobe Design Collection at <font color="#FF0000"><b>62%</b></font> OFF
        <p align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
<p>
<b>Dear <font color="#000080">Students</font>, <font color="#008000">Teachers</font>, 
<font color="#800000">Faculty</font>, <font color="#000080">Staff</font> and 
<font color="#008000">Schools</font>:</b><br>
<br>
COMPUTER PRODUCTS FOR EDUCATION is pleased to offer to you the best prices on
<b><font color="#000080">ACADEMIC EDITION SOFTWARE</font></b> from 
<font color="#0000FF"><b>MICROSOFT</b></font>, <b><font color="#800000">ADOBE</font></b>, 
<b><font color="#000080">MACROMEDIA</font></b>, <b><font color="#008000">COREL</font></b>, and others -
AT UP TO <b><font color="#FF0000">91% OFF </font></b>STANDARD COMMERCIAL RETAIL PRICES. If you are a 
<b>Qualified
Education Buyer</b> (defined below) you can purchase software products from CPE at
HUGE DISCOUNTS during our BACK-TO-SCHOOL SALE!<br>
<br>
Qualified Education Buyers include K-12 and HIGHER EDUCATION STUDENTS, TEACHERS,
FACULTY, STAFF, and SCHOOLS.</p>
<p>&nbsp;</p>
      </td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0" height="457">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4" height="19">
        <p align="center"><font color="#FFFFFF"><b>ADOBE (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">
        <p align="center">Description</td>
      <td width="21%" align="center" height="19">Education Price&nbsp;</td>
      <td width="15%" align="center" height="19">Standard Retail</td>
      <td width="17%" align="center" height="19">You Save</td>
    </tr>
    <tr>
      <td width="47%" height="19">Acrobat 5.0</td>
      <td width="21%" align="center" height="19">$57.95</td>
      <td width="15%" align="center" height="19">$249</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">After Effects 5.5</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$649</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>55%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">GoLive 6.0/LiveMotion 2.0</td>
      <td width="21%" align="center" height="19">$84.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>79%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Illustrator 10.0</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">InDesign 2.0</td>
      <td width="21%" align="center" height="19">$189.95</td>
      <td width="15%" align="center" height="19">$699</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>73%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0</td>
      <td width="21%" align="center" height="19">$279.95</td>
      <td width="15%" align="center" height="19">$499</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>44%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$609</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>52%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5</td>
      <td width="21%" align="center" height="19">$224.95</td>
      <td width="15%" align="center" height="19">$549</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" bgcolor="#800000" height="19">
      <p align="center"><font color="#FFFFFF"><b>*******Adobe Collections*******</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Design Collection 6.0 BTS PROMO</b></td>
      <td width="21%" align="center" height="19"><b>$379.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>62%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(InDesign 2/Photoshop 7/Illustrator 10/Acrobat 5/GoLive 
        6/Live Mo 2)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Digital Video Collection 8.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$1199</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="14">
        <p align="center">(Premiere 6.5/AfterEffects 5.5/Photoshop 7/Illustrator 10)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Publishing Collection 12.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>51%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(PageMaker 7/Photoshop 7/Illustrator 10/Acrobat 5)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Web Collection 5.0</b></td>
      <td width="21%" align="center" height="19"><b>$339.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(Photoshop 7/Illustrator 10/GoLive 6/LiveMotion 2)</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#000080" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MACROMEDIA (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Commercial Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">Authorware 6.0 E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$2699</td>
      <td width="17%" align="center"><font color="#FF0000"><b>87%</b></font></td>
    </tr>
    <tr>
      <td width="47%">ColdFusion MX Server Pro</td>
      <td width="21%" align="center">$529.95</td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>34%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Director 8.5 Shockwave Std E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$1199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>71%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Dreamweaver MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>67%</b></font></td>
    </tr>
    <tr>
      <td width="47%">eLearning Studio (Authorware 6.0/Flash MX/DreamwvMX)</td>
      <td width="21%" align="center">$489.95</td>
      <td width="15%" align="center">$2999</td>
      <td width="17%" align="center"><font color="#FF0000"><b>84%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Fireworks MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>50%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Flash MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%">FreeHand 10</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%"><b>STUDIO MX </b>(Dreamweaver MX/Fireworks MX/Flash MX/Freehand 10/ColdFusion MX)</td>
      <td width="21%" align="center"><b>$189.95</b></td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>76%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#008000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MICROSOFT</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Standard</td>
      <td width="21%" align="center">$148.95</td>
      <td width="15%" align="center">$479</td>
      <td width="17%" align="center"><font color="#FF0000"><b>70%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Professional</td>
      <td width="21%" align="center">$199.95</td>
      <td width="15%" align="center">$579</td>
      <td width="17%" align="center"><font color="#FF0000"><b>66%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office 2001 Macintosh</td>
      <td width="21%" align="center">$209.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office Mac v.X for Mac OS X</td>
      <td width="21%" align="center">$215.95</td>
      <td width="15%" align="center">$459</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        FrontPage 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$169</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Publisher 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$129</td>
      <td width="17%" align="center"><font color="#FF0000"><b>38%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Standard 2002&nbsp;</td>
      <td width="21%" align="center">$69.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Professional 2002</td>
      <td width="21%" align="center">$159.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>69%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Basic.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C++.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C#(sharp).Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Studio.Net Professional</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$1079</td>
      <td width="17%" align="center"><font color="#FF0000"><b>91%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows XP Professional Upg*</td>
      <td width="21%" align="center">$ 94.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>68%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows 2000 Professional Upg*</td>
      <td width="21%" align="center">$129.95</td>
      <td width="15%" align="center">$319</td>
      <td width="17%" align="center"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4">
        <p align="center">* Windows XP/2000 Pro Upgrade will install on a blank hard drive.</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>Corel</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Wordperfect Office 2002 w/Voice</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$389</td>
      <td width="17%" align="center"><font color="#FF0000"><b>74%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Corel Draw 11.0</td>
      <td width="21%" align="center">$142.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>72%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Procreate Painter 7.0</td>
      <td width="21%" align="center">$229.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
  </table>
  </center>
</div>
<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="6" color="#FF0000"><b>To Order&nbsp;</b></font> 
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="4">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%69%6E%64%65%78%2E%68%74%6D%6C">Click Here</a>&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75">
<font size="6" color="#FFFFFF">Click Here</font></a><font size="6">&nbsp; </font><b> 
<font size="6" color="#FF0000">or call us at: </font> 
<font size="6" color="#000080">800-679-7007</font></b><font size="6">&nbsp;
</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C">
<font size="6" color="#FFFFFF">Click Here</font></a></p>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%"><b><u>
LICENSING:</u></b><br>
For school purchases of five to ten (5-10) or more units, depending on the
product, please call 800-679-7007 for even deeper discounts on license packs. <br>
        <br>
For hundreds of other software products available from CPE at similar discounts,
visit our website or call us at 800-679-7007. <br>
      <br>
Academic Edition software is exactly the same as the Full-Retail version except
that it has been deeply discounted for Qualified Education Buyers. <br>
<br>
      Purchasers must provide fax-verification of status as
being a current faculty, staff, or student. After placing your order, you simply
fax to CPE either: (a) a copy of a current picture School I.D. Card or, (b) a
current paycheck stub with an alternative picture I.D. (drivers license, etc.).
Schools may purchase by faxing a valid school purchase order. For more details,
please call us 800-679-7007.<br>
<br>
All software sold by CPE is authentic original software from the manufacturer.
THESE ARE NOT PIRATED COPIES. ALL SOFTWARE COMES IN ORIGINAL MANUFACTURERS
BOXES AND INCLUDES A VALID LICENSE.<br>
<br>
CPE is an Authorized Education Reseller for Microsoft, Adobe, Corel, Symantec
and many other major software manufacturers. CPE is the only national software
distributor committed to providing the lowest prices EXCLUSIVELY to the
Education community with the best customer service.<br>
<br>
All prices and availability are subject to change without notice.</td>
    </tr>
  </table>
  </center>
</div>
<p>
<u><b>EASY REMOVAL:</b></u><br>
We hope you find this message valuable. If you do not wish to receive special
offers and updates from us and you would like to REMOVE your email from our list, please 
click below:
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click He<b>re</b></font></a><b>&nbsp;
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%6C%75%72%2E%68%74%6D%6C">
TO REMOVE CLICK HERE</a>&nbsp;</b>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">
ick Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
__________________<br>
<br>
<b><font size="6">THANK YOU!<br>
</font></b>
<br>
</p>

</body>

</html>




From paul@paulhaahr.com Fri, 13 Sep 2002 23:21:07 -0700 (PDT)
Date: Fri, 13 Sep 2002 23:21:07 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor

Gary Gregory wrote
> The constructor for ThreadExecutor allows for a
> java.util.concurrent.BlockingQueue workQueue parameter but there is no
> setQueue() API. There is a setter method for all other items passed in
> though. Is this a simple omission?

I don't know for sure what the experts group's thoughts were, but I
would imagine that the problem is that you could lose objects in the
queue when switching queues, unless more synchronization is used than
currently implied by the documentation.

That seems more problematic than just not letting the queue change.  If
you really want that, shutdown the executor, start a new one with a new
queue, and, optionally, drain the old queue and use its contents to fill
the new one.

> The setMinimumPoolSize/setMaximumPoolSize APIs do not specify if or
> when or how the pool is grown or shrunk to meet the new size. A little
> more details in these comments would be appreciated.

I suspect growing for an increased minimum or maximum isn't hard:  right
away and when the executor would wait rather than start another task,
respectively.  Shrinking for a new setMinimumPoolSize is also easy:  the
existing rules for keep alive time should apply.  setMaximumPoolSize is
easy when the number of threads is above the number currently in use.

That leaves the case where there are more threads in the pool than the
new maximum.  The documentation probably needs to be explicit about that
case -- the answer should probably be either that the setMaximumPoolSize
throws an exception or the executor stays above the new maximum until
some runnables exit.  (I thought I'd read something which said that the
former happened, but I can't find that now.)

--p




From education_saver1@yahoo.com Sat, 14 Sep 2002 03:24:50 -0400
Date: Sat, 14 Sep 2002 03:24:50 -0400
From: Cathleen Coxum education_saver1@yahoo.com
Subject: [concurrency-interest] Education Software Discounts

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Office XP Standard at 70</title>
</head>

<body>

<div align="center">
  <center>
  <table border="0" width="60%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
        <p align="center">Office XP Standard at <font color="#FF0000"><b>70%</b></font>
        OFF,<br>
        Adobe Photoshop at <font color="#FF0000"><b>52%</b></font> OFF,&nbsp;<br>
        Microsoft Visual Studio.NET at <font color="#FF0000"><b>91%</b></font>
        OFF,<br>
        Macromedia Studio MX at <font color="#FF0000"><b>76%</b></font>
        OFF,&nbsp;<br>
        Adobe Design Collection at <font color="#FF0000"><b>62%</b></font> OFF
        <p align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
<p>
<b>Dear <font color="#000080">Students</font>, <font color="#008000">Teachers</font>, 
<font color="#800000">Faculty</font>, <font color="#000080">Staff</font> and 
<font color="#008000">Schools</font>:</b><br>
<br>
COMPUTER PRODUCTS FOR EDUCATION is pleased to offer to you the best prices on
<b><font color="#000080">ACADEMIC EDITION SOFTWARE</font></b> from 
<font color="#0000FF"><b>MICROSOFT</b></font>, <b><font color="#800000">ADOBE</font></b>, 
<b><font color="#000080">MACROMEDIA</font></b>, <b><font color="#008000">COREL</font></b>, and others -
AT UP TO <b><font color="#FF0000">91% OFF </font></b>STANDARD COMMERCIAL RETAIL PRICES. If you are a 
<b>Qualified
Education Buyer</b> (defined below) you can purchase software products from CPE at
HUGE DISCOUNTS during our BACK-TO-SCHOOL SALE!<br>
<br>
Qualified Education Buyers include K-12 and HIGHER EDUCATION STUDENTS, TEACHERS,
FACULTY, STAFF, and SCHOOLS.</p>
<p>&nbsp;</p>
      </td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0" height="457">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4" height="19">
        <p align="center"><font color="#FFFFFF"><b>ADOBE (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">
        <p align="center">Description</td>
      <td width="21%" align="center" height="19">Education Price&nbsp;</td>
      <td width="15%" align="center" height="19">Standard Retail</td>
      <td width="17%" align="center" height="19">You Save</td>
    </tr>
    <tr>
      <td width="47%" height="19">Acrobat 5.0</td>
      <td width="21%" align="center" height="19">$57.95</td>
      <td width="15%" align="center" height="19">$249</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">After Effects 5.5</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$649</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>55%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">GoLive 6.0/LiveMotion 2.0</td>
      <td width="21%" align="center" height="19">$84.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>79%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Illustrator 10.0</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">InDesign 2.0</td>
      <td width="21%" align="center" height="19">$189.95</td>
      <td width="15%" align="center" height="19">$699</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>73%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0</td>
      <td width="21%" align="center" height="19">$279.95</td>
      <td width="15%" align="center" height="19">$499</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>44%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$609</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>52%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5</td>
      <td width="21%" align="center" height="19">$224.95</td>
      <td width="15%" align="center" height="19">$549</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" bgcolor="#800000" height="19">
      <p align="center"><font color="#FFFFFF"><b>*******Adobe Collections*******</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Design Collection 6.0 BTS PROMO</b></td>
      <td width="21%" align="center" height="19"><b>$379.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>62%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(InDesign 2/Photoshop 7/Illustrator 10/Acrobat 5/GoLive 
        6/Live Mo 2)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Digital Video Collection 8.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$1199</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="14">
        <p align="center">(Premiere 6.5/AfterEffects 5.5/Photoshop 7/Illustrator 10)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Publishing Collection 12.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>51%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(PageMaker 7/Photoshop 7/Illustrator 10/Acrobat 5)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Web Collection 5.0</b></td>
      <td width="21%" align="center" height="19"><b>$339.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(Photoshop 7/Illustrator 10/GoLive 6/LiveMotion 2)</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#000080" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MACROMEDIA (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Commercial Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">Authorware 6.0 E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$2699</td>
      <td width="17%" align="center"><font color="#FF0000"><b>87%</b></font></td>
    </tr>
    <tr>
      <td width="47%">ColdFusion MX Server Pro</td>
      <td width="21%" align="center">$529.95</td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>34%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Director 8.5 Shockwave Std E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$1199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>71%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Dreamweaver MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>67%</b></font></td>
    </tr>
    <tr>
      <td width="47%">eLearning Studio (Authorware 6.0/Flash MX/DreamwvMX)</td>
      <td width="21%" align="center">$489.95</td>
      <td width="15%" align="center">$2999</td>
      <td width="17%" align="center"><font color="#FF0000"><b>84%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Fireworks MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>50%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Flash MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%">FreeHand 10</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%"><b>STUDIO MX </b>(Dreamweaver MX/Fireworks MX/Flash MX/Freehand 10/ColdFusion MX)</td>
      <td width="21%" align="center"><b>$189.95</b></td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>76%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#008000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MICROSOFT</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Standard</td>
      <td width="21%" align="center">$148.95</td>
      <td width="15%" align="center">$479</td>
      <td width="17%" align="center"><font color="#FF0000"><b>70%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Professional</td>
      <td width="21%" align="center">$199.95</td>
      <td width="15%" align="center">$579</td>
      <td width="17%" align="center"><font color="#FF0000"><b>66%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office 2001 Macintosh</td>
      <td width="21%" align="center">$209.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office Mac v.X for Mac OS X</td>
      <td width="21%" align="center">$215.95</td>
      <td width="15%" align="center">$459</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        FrontPage 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$169</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Publisher 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$129</td>
      <td width="17%" align="center"><font color="#FF0000"><b>38%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Standard 2002&nbsp;</td>
      <td width="21%" align="center">$69.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Professional 2002</td>
      <td width="21%" align="center">$159.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>69%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Basic.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C++.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C#(sharp).Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Studio.Net Professional</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$1079</td>
      <td width="17%" align="center"><font color="#FF0000"><b>91%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows XP Professional Upg*</td>
      <td width="21%" align="center">$ 94.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>68%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows 2000 Professional Upg*</td>
      <td width="21%" align="center">$129.95</td>
      <td width="15%" align="center">$319</td>
      <td width="17%" align="center"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4">
        <p align="center">* Windows XP/2000 Pro Upgrade will install on a blank hard drive.</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>Corel</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Wordperfect Office 2002 w/Voice</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$389</td>
      <td width="17%" align="center"><font color="#FF0000"><b>74%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Corel Draw 11.0</td>
      <td width="21%" align="center">$142.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>72%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Procreate Painter 7.0</td>
      <td width="21%" align="center">$229.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
  </table>
  </center>
</div>
<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="6" color="#FF0000"><b>To Order&nbsp;</b></font> 
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="4">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%69%6E%64%65%78%2E%68%74%6D%6C">Click Here</a>&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75">
<font size="6" color="#FFFFFF">Click Here</font></a><font size="6">&nbsp; </font><b> 
<font size="6" color="#FF0000">or call us at: </font> 
<font size="6" color="#000080">800-679-7007</font></b><font size="6">&nbsp;
</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C">
<font size="6" color="#FFFFFF">Click Here</font></a></p>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%"><b><u>
LICENSING:</u></b><br>
For school purchases of five to ten (5-10) or more units, depending on the
product, please call 800-679-7007 for even deeper discounts on license packs. <br>
        <br>
For hundreds of other software products available from CPE at similar discounts,
visit our website or call us at 800-679-7007. <br>
      <br>
Academic Edition software is exactly the same as the Full-Retail version except
that it has been deeply discounted for Qualified Education Buyers. <br>
<br>
      Purchasers must provide fax-verification of status as
being a current faculty, staff, or student. After placing your order, you simply
fax to CPE either: (a) a copy of a current picture School I.D. Card or, (b) a
current paycheck stub with an alternative picture I.D. (drivers license, etc.).
Schools may purchase by faxing a valid school purchase order. For more details,
please call us 800-679-7007.<br>
<br>
All software sold by CPE is authentic original software from the manufacturer.
THESE ARE NOT PIRATED COPIES. ALL SOFTWARE COMES IN ORIGINAL MANUFACTURERS
BOXES AND INCLUDES A VALID LICENSE.<br>
<br>
CPE is an Authorized Education Reseller for Microsoft, Adobe, Corel, Symantec
and many other major software manufacturers. CPE is the only national software
distributor committed to providing the lowest prices EXCLUSIVELY to the
Education community with the best customer service.<br>
<br>
All prices and availability are subject to change without notice.</td>
    </tr>
  </table>
  </center>
</div>
<p>
<u><b>EASY REMOVAL:</b></u><br>
We hope you find this message valuable. If you do not wish to receive special
offers and updates from us and you would like to REMOVE your email from our list, please 
click below:
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click He<b>re</b></font></a><b>&nbsp;
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%6C%75%72%2E%68%74%6D%6C">
TO REMOVE CLICK HERE</a>&nbsp;</b>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">
ick Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
__________________<br>
<br>
<b><font size="6">THANK YOU!<br>
</font></b>
<br>
</p>

</body>

</html>




From education_saver1@yahoo.com Sat, 14 Sep 2002 01:04:03 -0400
Date: Sat, 14 Sep 2002 01:04:03 -0400
From: Cheryl Aslam education_saver1@yahoo.com
Subject: [concurrency-interest] Deep Software Discounts for Student, Teachers, Staff, Schools

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Office XP Standard at 70</title>
</head>

<body>

<div align="center">
  <center>
  <table border="0" width="60%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
        <p align="center">Office XP Standard at <font color="#FF0000"><b>70%</b></font>
        OFF,<br>
        Adobe Photoshop at <font color="#FF0000"><b>52%</b></font> OFF,&nbsp;<br>
        Microsoft Visual Studio.NET at <font color="#FF0000"><b>91%</b></font>
        OFF,<br>
        Macromedia Studio MX at <font color="#FF0000"><b>76%</b></font>
        OFF,&nbsp;<br>
        Adobe Design Collection at <font color="#FF0000"><b>62%</b></font> OFF
        <p align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%">
<p>
<b>Dear <font color="#000080">Students</font>, <font color="#008000">Teachers</font>, 
<font color="#800000">Faculty</font>, <font color="#000080">Staff</font> and 
<font color="#008000">Schools</font>:</b><br>
<br>
COMPUTER PRODUCTS FOR EDUCATION is pleased to offer to you the best prices on
<b><font color="#000080">ACADEMIC EDITION SOFTWARE</font></b> from 
<font color="#0000FF"><b>MICROSOFT</b></font>, <b><font color="#800000">ADOBE</font></b>, 
<b><font color="#000080">MACROMEDIA</font></b>, <b><font color="#008000">COREL</font></b>, and others -
AT UP TO <b><font color="#FF0000">91% OFF </font></b>STANDARD COMMERCIAL RETAIL PRICES. If you are a 
<b>Qualified
Education Buyer</b> (defined below) you can purchase software products from CPE at
HUGE DISCOUNTS during our BACK-TO-SCHOOL SALE!<br>
<br>
Qualified Education Buyers include K-12 and HIGHER EDUCATION STUDENTS, TEACHERS,
FACULTY, STAFF, and SCHOOLS.</p>
<p>&nbsp;</p>
      </td>
    </tr>
  </table>
  </center>
</div>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0" height="457">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4" height="19">
        <p align="center"><font color="#FFFFFF"><b>ADOBE (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">
        <p align="center">Description</td>
      <td width="21%" align="center" height="19">Education Price&nbsp;</td>
      <td width="15%" align="center" height="19">Standard Retail</td>
      <td width="17%" align="center" height="19">You Save</td>
    </tr>
    <tr>
      <td width="47%" height="19">Acrobat 5.0</td>
      <td width="21%" align="center" height="19">$57.95</td>
      <td width="15%" align="center" height="19">$249</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">After Effects 5.5</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$649</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>55%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">GoLive 6.0/LiveMotion 2.0</td>
      <td width="21%" align="center" height="19">$84.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>79%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Illustrator 10.0</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">$399</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>77%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">InDesign 2.0</td>
      <td width="21%" align="center" height="19">$189.95</td>
      <td width="15%" align="center" height="19">$699</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>73%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0</td>
      <td width="21%" align="center" height="19">$279.95</td>
      <td width="15%" align="center" height="19">$499</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>44%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">PageMaker 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$89.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0</td>
      <td width="21%" align="center" height="19">$289.95</td>
      <td width="15%" align="center" height="19">$609</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>52%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Photoshop 7.0 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5</td>
      <td width="21%" align="center" height="19">$224.95</td>
      <td width="15%" align="center" height="19">$549</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19">Premiere 6.5 Upgrade</td>
      <td width="21%" align="center" height="19">$149.95</td>
      <td width="15%" align="center" height="19">-</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>-</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" bgcolor="#800000" height="19">
      <p align="center"><font color="#FFFFFF"><b>*******Adobe Collections*******</b></font></td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Design Collection 6.0 BTS PROMO</b></td>
      <td width="21%" align="center" height="19"><b>$379.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>62%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(InDesign 2/Photoshop 7/Illustrator 10/Acrobat 5/GoLive 
        6/Live Mo 2)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Digital Video Collection 8.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$1199</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="14">
        <p align="center">(Premiere 6.5/AfterEffects 5.5/Photoshop 7/Illustrator 10)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Publishing Collection 12.0</b></td>
      <td width="21%" align="center" height="19"><b>$489.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>51%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(PageMaker 7/Photoshop 7/Illustrator 10/Acrobat 5)</td>
    </tr>
    <tr>
      <td width="47%" height="19"><b>Web Collection 5.0</b></td>
      <td width="21%" align="center" height="19"><b>$339.95</b></td>
      <td width="15%" align="center" height="19">$999</td>
      <td width="17%" align="center" height="19"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" height="19">
        <p align="center">(Photoshop 7/Illustrator 10/GoLive 6/LiveMotion 2)</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#000080" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MACROMEDIA (Windows &amp; Mac):</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Commercial Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">Authorware 6.0 E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$2699</td>
      <td width="17%" align="center"><font color="#FF0000"><b>87%</b></font></td>
    </tr>
    <tr>
      <td width="47%">ColdFusion MX Server Pro</td>
      <td width="21%" align="center">$529.95</td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>34%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Director 8.5 Shockwave Std E-Doc</td>
      <td width="21%" align="center">$349.95</td>
      <td width="15%" align="center">$1199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>71%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Dreamweaver MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>67%</b></font></td>
    </tr>
    <tr>
      <td width="47%">eLearning Studio (Authorware 6.0/Flash MX/DreamwvMX)</td>
      <td width="21%" align="center">$489.95</td>
      <td width="15%" align="center">$2999</td>
      <td width="17%" align="center"><font color="#FF0000"><b>84%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Fireworks MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>50%</b></font></td>
    </tr>
    <tr>
      <td width="47%">Flash MX</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%">FreeHand 10</td>
      <td width="21%" align="center">$98.95</td>
      <td width="15%" align="center">$399</td>
      <td width="17%" align="center"><font color="#FF0000"><b>75%</b></font></td>
    </tr>
    <tr>
      <td width="47%"><b>STUDIO MX </b>(Dreamweaver MX/Fireworks MX/Flash MX/Freehand 10/ColdFusion MX)</td>
      <td width="21%" align="center"><b>$189.95</b></td>
      <td width="15%" align="center">$799</td>
      <td width="17%" align="center"><font color="#FF0000"><b>76%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4" align="center">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#008000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>MICROSOFT</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Standard</td>
      <td width="21%" align="center">$148.95</td>
      <td width="15%" align="center">$479</td>
      <td width="17%" align="center"><font color="#FF0000"><b>70%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office XP Professional</td>
      <td width="21%" align="center">$199.95</td>
      <td width="15%" align="center">$579</td>
      <td width="17%" align="center"><font color="#FF0000"><b>66%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office 2001 Macintosh</td>
      <td width="21%" align="center">$209.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Office Mac v.X for Mac OS X</td>
      <td width="21%" align="center">$215.95</td>
      <td width="15%" align="center">$459</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        FrontPage 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$169</td>
      <td width="17%" align="center"><font color="#FF0000"><b>53%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Publisher 2002</td>
      <td width="21%" align="center">$79.95</td>
      <td width="15%" align="center">$129</td>
      <td width="17%" align="center"><font color="#FF0000"><b>38%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Standard 2002&nbsp;</td>
      <td width="21%" align="center">$69.95</td>
      <td width="15%" align="center">$199</td>
      <td width="17%" align="center"><font color="#FF0000"><b>65%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visio Professional 2002</td>
      <td width="21%" align="center">$159.95</td>
      <td width="15%" align="center">$499</td>
      <td width="17%" align="center"><font color="#FF0000"><b>69%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Basic.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C++.Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual C#(sharp).Net Standard</td>
      <td width="21%" align="center">$59.95</td>
      <td width="15%" align="center">$109</td>
      <td width="17%" align="center"><font color="#FF0000"><b>45%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Visual Studio.Net Professional</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$1079</td>
      <td width="17%" align="center"><font color="#FF0000"><b>91%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows XP Professional Upg*</td>
      <td width="21%" align="center">$ 94.95</td>
      <td width="15%" align="center">$299</td>
      <td width="17%" align="center"><font color="#FF0000"><b>68%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Windows 2000 Professional Upg*</td>
      <td width="21%" align="center">$129.95</td>
      <td width="15%" align="center">$319</td>
      <td width="17%" align="center"><font color="#FF0000"><b>59%</b></font></td>
    </tr>
    <tr>
      <td width="100%" colspan="4">
        <p align="center">* Windows XP/2000 Pro Upgrade will install on a blank hard drive.</td>
    </tr>
  </table>
  </center>
</div>
<p align="center">&nbsp;</p>
<div align="center">
  <center>
  <table border="1" width="80%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%" bgcolor="#800000" colspan="4">
        <p align="center"><font color="#FFFFFF"><b>Corel</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        <p align="center">Description</td>
      <td width="21%" align="center">Education             Price&nbsp;</td>
      <td width="15%" align="center">Standard Retail</td>
      <td width="17%" align="center">You Save</td>
    </tr>
    <tr>
      <td width="47%">
        Wordperfect Office 2002 w/Voice</td>
      <td width="21%" align="center">$99.95</td>
      <td width="15%" align="center">$389</td>
      <td width="17%" align="center"><font color="#FF0000"><b>74%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Corel Draw 11.0</td>
      <td width="21%" align="center">$142.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>72%</b></font></td>
    </tr>
    <tr>
      <td width="47%">
        Procreate Painter 7.0</td>
      <td width="21%" align="center">$229.95</td>
      <td width="15%" align="center">$549</td>
      <td width="17%" align="center"><font color="#FF0000"><b>60%</b></font></td>
    </tr>
  </table>
  </center>
</div>
<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="6" color="#FF0000"><b>To Order&nbsp;</b></font> 
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a>&nbsp;<font size="4">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%69%6E%64%65%78%2E%68%74%6D%6C">Click Here</a>&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><br>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75">
<font size="6" color="#FFFFFF">Click Here</font></a><font size="6">&nbsp; </font><b> 
<font size="6" color="#FF0000">or call us at: </font> 
<font size="6" color="#000080">800-679-7007</font></b><font size="6">&nbsp;
</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C">
<font size="6" color="#FFFFFF">Click Here</font></a></p>
<div align="center">
  <center>
  <table border="0" width="90%" cellspacing="0" cellpadding="0">
    <tr>
      <td width="100%"><b><u>
LICENSING:</u></b><br>
For school purchases of five to ten (5-10) or more units, depending on the
product, please call 800-679-7007 for even deeper discounts on license packs. <br>
        <br>
For hundreds of other software products available from CPE at similar discounts,
visit our website or call us at 800-679-7007. <br>
      <br>
Academic Edition software is exactly the same as the Full-Retail version except
that it has been deeply discounted for Qualified Education Buyers. <br>
<br>
      Purchasers must provide fax-verification of status as
being a current faculty, staff, or student. After placing your order, you simply
fax to CPE either: (a) a copy of a current picture School I.D. Card or, (b) a
current paycheck stub with an alternative picture I.D. (drivers license, etc.).
Schools may purchase by faxing a valid school purchase order. For more details,
please call us 800-679-7007.<br>
<br>
All software sold by CPE is authentic original software from the manufacturer.
THESE ARE NOT PIRATED COPIES. ALL SOFTWARE COMES IN ORIGINAL MANUFACTURERS
BOXES AND INCLUDES A VALID LICENSE.<br>
<br>
CPE is an Authorized Education Reseller for Microsoft, Adobe, Corel, Symantec
and many other major software manufacturers. CPE is the only national software
distributor committed to providing the lowest prices EXCLUSIVELY to the
Education community with the best customer service.<br>
<br>
All prices and availability are subject to change without notice.</td>
    </tr>
  </table>
  </center>
</div>
<p>
<u><b>EASY REMOVAL:</b></u><br>
We hope you find this message valuable. If you do not wish to receive special
offers and updates from us and you would like to REMOVE your email from our list, please 
click below:
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%62%6C%75%65%73%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click He<b>re</b></font></a><b>&nbsp;
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%63%79%62%65%72%74%75%72%66%2E%63%6F%6D/%6B%69%6E%64%68%61%76%61%6E%61/%6C%75%72%2E%68%74%6D%6C">
TO REMOVE CLICK HERE</a>&nbsp;</b>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a></p><p align="center">
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">
ick Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01010110101101101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%73%6F%63%63%6F%6D%68%6B%2E%69%6E%32%30%30%30%2E%63%6F%6D"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010110111011110101010101110101010101010101011010101010101010101101011010101010101010101010110101010101010101100010110111010101010100011010101101010101101010101010101010101010101@%77%77%77%2E%73%61%6F%2E%72%75"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://1010101001011010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%68%6B%2E%67%65%6F%63%69%74%69%65%73%2E%63%6F%6D/%6C%6F%76%65%67%69%6C%6C%67%69%6C%6C"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://01011011010001010101010101101011010110101010101101101101010101010101010101010101110101010110101010101010101010101010101010110@%77%77%77%2E%6E%6F%74%75%6E%67%2E%6F%72%67"><font color="#FFFFFF">Click Here</font></a><font color="#FFFFFF">&nbsp;</font>
<a href="http://10100101010010101001010100101010010101010010101010010101001010101010100101010001010101010001011110100100101001010010010100100101001010101010100101@%77%77%77%2E%68%61%79%77%69%72%65%64%2E%63%6F%6D/%73%73%61%61%6C%6C/%69%6E%64%65%78%2E%68%74%6D%6C"><font color="#FFFFFF">Click Here</font></a></p>

<p align="center">
__________________<br>
<br>
<b><font size="6">THANK YOU!<br>
</font></b>
<br>
</p>

</body>

</html>




From crahen@cse.Buffalo.EDU Sat, 14 Sep 2002 05:12:54 -0400 (EDT)
Date: Sat, 14 Sep 2002 05:12:54 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor

On Fri, 13 Sep 2002, Paul Haahr wrote:

> That seems more problematic than just not letting the queue change.  If
> you really want that, shutdown the executor, start a new one with a new
> queue, and, optionally, drain the old queue and use its contents to fill
> the new one.

Seems that way to me as well.


- Eric
http://www.cse.buffalo.edu/~crahen





From dl@cs.oswego.edu Sat, 14 Sep 2002 07:27:48 -0400
Date: Sat, 14 Sep 2002 07:27:48 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] member-only posting

Now that spammers seem to have found this list, I set mailman 
options to posting by list members only. Sigh.

-Doug




From dl@cs.oswego.edu Sat, 14 Sep 2002 07:34:43 -0400
Date: Sat, 14 Sep 2002 07:34:43 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API - ThreadExecutor

Gary Gregory wrote:

> The constructor for ThreadExecutor allows for a
> java.util.concurrent.BlockingQueue workQueue parameter but there is no
> setQueue() API. There is a setter method for all other items passed in
> though. Is this a simple omission?

No, entirely intentional. As others have noted, there is no reasonable
way to do this safely/unsurprisingly, and any time you'd be tempted to
do it, you are probably better off making a new ThreadExecutor instead.

> 
> The setMinimumPoolSize/setMaximumPoolSize APIs do not specify if or when or
> how the pool is grown or shrunk to meet the new size. A little more details
> in these comments would be appreciated.

Right.  More details on all methods are forthcoming.  Please bear with
us as we first ensure that all APIs are stable enough to thoroughly
specify/document/implement.

-Doug




From dl@cs.oswego.edu Sat, 14 Sep 2002 10:37:17 -0400
Date: Sat, 14 Sep 2002 10:37:17 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Futures, callbacks, callables, runnables, and executors once again

Dawid Kurzyniec wrote:

> I don't think that the points I made in my previous mail have
> been discussed in public yet.

Here's a still-brief but better explanation: The main reason to prefer
current design is that it better separates the responsibilities of
tasks (FutureTasks etc) and Executors.  In part because many more
people will create custom task classes than custom executor classes,
we need to eliminate dependencies of Executors on the details of
tasks.  Most other efficiency and usablilty arguments in favor of
either of the two approaches seem to be a wash. Also, if you prefer
callee-constructs conventions, you can layer this is a simple way on
top of Executors, but the converse case wouldn't work.

(Note: the currently accessible version of ScheduledExecutor is just a
place-holder, and doesn't yet reflect adapations for delayed and
periodic tasks. Pretend it isn't there. :-)

>  However, I believe that
> in this case (and actually in any other case when you might be tempted
> to use resettable futures) callbacks are better alternative

But is an interface contract requiring immutability valuable enough to
you to annoy people who for some reason want to design using a custom
resettable future class that will probably ignore the (unenforceable)
contract anyway?

-Doug




From jozart@csi.com Sun, 15 Sep 2002 23:05:28 -0700
Date: Sun, 15 Sep 2002 23:05:28 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: Futures, callbacks, callables, runnables, and executors once again

Concerning the removal of the execute method that returns a Future, Dawid
Kurzyniec writes:

> Well, without an example I am not quite sure in what
> context it really matters.

My contention was that an execute method that created a task internally and
returned a Future "handle" would permit the creation of "mystery" tasks that
could not be completely identified until after they'd completed.

I think it's useful to compare FutureTask with Thread and TimerTask.  A
thread instance is created and then it is started; a TimerTask is created
and then it is scheduled.

To see why this separation can be essential, search your favorite concurrent
source code for places where thread instance variables are used.  The
simplest example that comes to mind is:

  while (Thread.currentThread() == thread) { /* work */ }

If the thread can run before the thread variable is set, then no work will
be done.

In the case of tasks, the task instance can indicate whether there's already
an active agent on the job -- to avoid the needless creation of a new task.
It can also be used to associate a task with the errors it produces (for
logging), the privileges it has, its progress, its events, and so on.  In
many cases these associations need to be established before the task starts
to execute.

(Of course, the task's Runnable could be rigged to wait for a signal before
it proceeds, but why make this so complicated?)

--
Joe Bowbeer






From dawidk@mathcs.emory.edu Wed, 18 Sep 2002 19:44:38 -0400
Date: Wed, 18 Sep 2002 19:44:38 -0400
From: Dawid Kurzyniec dawidk@mathcs.emory.edu
Subject: [concurrency-interest] Re: Futures, callbacks, callables, runnables, and executors once again

Let me address Doug's and Joseph's comments together.


Joseph Bowbeer wrote:
> 
> My contention was that an execute method that created a task 
> internally and returned a Future "handle" would permit the 
> creation of "mystery" tasks that could not be completely 
> identified until after they'd completed.

Well, I would not think of an executor as returning _tasks_, but simple
cancellation and wait-to-complete (synchronization) handles. I consider
tasks to be higher level programming constructs that may intercept those
handles if they need to. I don't think there is much mistery about that
:)

> 
> I think it's useful to compare FutureTask with Thread and 
> TimerTask.  A thread instance is created and then it is 
> started; a TimerTask is created and then it is scheduled.

Good point.

> 
> To see why this separation can be essential, search your 
> favorite concurrent source code for places where thread 
> instance variables are used.  The simplest example that comes 
> to mind is:
> 
>   while (Thread.currentThread() == thread) { /* work */ }
> 
> If the thread can run before the thread variable is set, then 
> no work will be done.

Another good point.

> 
> In the case of tasks, the task instance can indicate whether 
> there's already an active agent on the job -- to avoid the 
> needless creation of a new task. It can also be used to 
> associate a task with the errors it produces (for logging), 
> the privileges it has, its progress, its events, and so on.  
> In many cases these associations need to be established 
> before the task starts to execute.
> 
> (Of course, the task's Runnable could be rigged to wait for a 
> signal before it proceeds, but why make this so complicated?)

All of those are good examples showing how useful the abstraction of a
task is. And I did not at any point postulate its removal from the API.
The only way my proposal would affect the API of the FutureTask was that
you would start tasks with task.execute(Executor) rather than
executor.execute(task). You should like it even better, since it
resembles the Thread even more :) 

My point was that an abstraction of a task may not always be appropriate
(I feel it may sometimes be too heavy), and a callee-constructs
convention is more natural as an atomic, low-level one to me. Also, I
have some cancellation concerns that will follow.

Doug Lea wrote:
 
> Here's a still-brief but better explanation: The main reason 
> to prefer current design is that it better separates the 
> responsibilities of tasks (FutureTasks etc) and Executors.

Well, but you do use executor to start up the task. Executor is a
controller of the task, master of its "life and death". So why do you
think it is inappropriate to logically associate lifetime
management-related operations other than start (cancellation and
wait-to-complete) with the executor? And if you move them to the task,
is it not better to move all of them together rather than leaving the
"start" operation in the executor? 

In fact, let me dig that Thread analogy little deeper. I agree that
Thread is much like FutureTask. When you first creates it, nothing
happens - just a bunch of fields get initialized. Things start rolling
when you do start(), which is just like execute(). But what is the
executor of a thread? Does it have any? Yes - the operating system. Deep
down in the guts of a JVM there is a fork() call. And it returns the
child's PID to the caller! The PID is nothing but cancellation and
synchronization point for underlying process, and it gets associated
with the thread object much in the same way as the future returned from
executor gets associated with a FutureTask in my proposal. For instance,
I can imagine Thread.join() pseudocode as: { if (pid == null) return;
else OS.wait(pid) }. The bottom line is: task-like threads are
themselves implemented on top of something that looks more like Future
execute().

Also, let me bring some example from the actual Java API: Process
Runtime.exec(command). Command is your callable (it even returns a
value!), Runtime.exec - your executor, and Process is your
synchronization handle. (There is no cancellation, but it would have
been in the Process as well).

> In part because many more people will create custom task 
> classes than custom executor classes, we need to eliminate 
> dependencies of Executors on the details of tasks.  

The way I see it, most custom task classes will simply extend
FutureTask, and it will work either way, whether the task is a
lower-level, mandatory construct (as you propose it) or a higher-level,
optional construct (as I propose it).

> Most 
> other efficiency and usablilty arguments in favor of either 
> of the two approaches seem to be a wash. Also, if you prefer 
> callee-constructs conventions, you can layer this is a simple 
> way on top of Executors, but the converse case wouldn't work.

Why not? You disregard returned future and use Callables.wrap(Runnable)
to pass an argument. Well, it is true that the scheme requires executors
to create return handles even if they are not used, but it is not such a
big deal if you have solid base class like BasicFuture (did you possibly
have any discouraging implementation experiences with that?). The only
problem seems to me to be how to cope with cancellation, but I believe
that this is executor-specific anyway.

Regarding callee-constructs conventions, indeed - first thing I did when
adopting dl.u.c was writing a static method Future execute(Executor,
Callable). But the difference is, dl.u.c.FutureResult was not
cancellable. So, again: how are you going to implement cancellation
independently of an executor? For instance, you have some kind of
QueuedExecutor. You cancel the task before it has been dequeued. How do
you remove it from the queue so it is not started at all? I guess you
can cook the "run" method in the task itself to check the cancellation
status at the beginning, but it is quite late at that point from the
resource allocation point of view.

Also, I would like to be able to implement remote executors. That is, I
would submit tasks (callables) that were serializable, and the executor
would send them for execution to remote slaves. In this scenario, the
runnable object on which the "run" method is invoked is a remote copy of
an object that has been submitted, and none of task-based cancellation
strategies will work.


Now, regarding immutability of Futures:

> >  However, I believe that
> > in this case (and actually in any other case when you might 
> > be tempted 
> > to use resettable futures) callbacks are better alternative

Doug Lea wrote:

> But is an interface contract requiring immutability valuable 
> enough to you to annoy people who for some reason want to 
> design using a custom resettable future class that will 
> probably ignore the (unenforceable) contract anyway?

My answer would be yes, for two reasons. #1 is that I just can't imagine
the application where it would make sense to do something like this
actually using j.u.c.Future. Could you think of any example? If your
application needs such reusable async handles, why bother to make them
futures? You probably do not want to give those handles away anyway,
because then you would loose control over when you could reset them. So,
any use of those is inherently implementation-specific.

Reason #2 is simplicity of client codes. In you write all the code
yourself, any interface contracts may seem annoying. But then you can
disobey them anyway - they are unenforceable by definition, and nobody
else will be hurt. But if you depend on the code that somebody else
wrote according to some interface specification, you have nothing but
interface contracts to depend on. Everything that is not an interface
contract is an implementation detail.

Let me bring java.io.InputStream.read(byte[], int, int) as an example.
Interface contract specifies that the method blocks if there is no data
in the stream. It is somewhat restrictive for implementors - sometimes
it would possibly be easier to just return 0. But if this contract
wasn't there, it would be much harder to write correct programs working
with opaque input streams.

Now I think that it is reasonable and natural to expect immutability
from opaque Futures in much the same way it is reasonable to expect that
read() blocks on empty stream. For instance, it seems natural to me to
expect that isCompleted() always returns true after get() returned, and
that subsequent gets would return the same value. And just like streams,
futures are first-class objects and they can make long journey from
creation to the final client. I think that it will often be the case
that client waiting on the future will not know (or care) who created
the future. If you make immutability an implementation detail, you
invalidate some useful and natural assertions that clients could
otherwise assume.

And finally, just one another example: threads are not restartible, why
would tasks be? :)

Regards,
Dawid





From jozart@csi.com Fri, 20 Sep 2002 07:05:16 -0700
Date: Fri, 20 Sep 2002 07:05:16 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest] Re: Futures, callbacks, callables, runnables, and executors once again

Dawid,

Here are a couple of comments.  Unfortunately not a comprehensive response,
but all I have time for at present.

Dawid Kurzyniec writes:

> The only way my proposal would affect the API of the
> FutureTask was that you would start tasks with
> task.execute(Executor) rather than executor.execute(task).

If FutureTask were tied to Executor in this way, then FutureTasks could no
longer be executed directly or run indirectly by threads.

However, custom tasks that require this coupling can provide a
setExecutor(e) method.

Note that FutureTask is not only a basic task implementation, it is also a
basic Future implementation.  If we tied FutureTask to Executor, we'd also
need to add a BasicFuture implementation.  (Perhaps FutureTask could extend
BasicFuture...)

> So, again: how are you going to implement cancellation
> independently of an executor? For instance, you have
> some kind of QueuedExecutor. You cancel the task before
> it has been dequeued. How do you remove it from the queue
> so it is not started at all? I guess you can cook the "run"
> method in the task itself to check the cancellation status
> at the beginning

Yes, the FutureTask implementation of run() bails out if the task has been
cancelled.



----- Original Message -----
From: "Dawid Kurzyniec" <dawidk@mathcs.emory.edu>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Wednesday, September 18, 2002 4:44 PM
Subject: RE: [concurrency-interest] Re: Futures, callbacks, callables,
runnables, and executors once again

Let me address Doug's and Joseph's comments together.

Joseph Bowbeer wrote:
>
> My contention was that an execute method that created a task
> internally and returned a Future "handle" would permit the
> creation of "mystery" tasks that could not be completely
> identified until after they'd completed.

Well, I would not think of an executor as returning _tasks_, but simple
cancellation and wait-to-complete (synchronization) handles. I consider
tasks to be higher level programming constructs that may intercept those
handles if they need to. I don't think there is much mistery about that
:)

>
> I think it's useful to compare FutureTask with Thread and
> TimerTask.  A thread instance is created and then it is
> started; a TimerTask is created and then it is scheduled.

Good point.

>
> To see why this separation can be essential, search your
> favorite concurrent source code for places where thread
> instance variables are used.  The simplest example that comes
> to mind is:
>
>   while (Thread.currentThread() == thread) { /* work */ }
>
> If the thread can run before the thread variable is set, then
> no work will be done.

Another good point.

>
> In the case of tasks, the task instance can indicate whether
> there's already an active agent on the job -- to avoid the
> needless creation of a new task. It can also be used to
> associate a task with the errors it produces (for logging),
> the privileges it has, its progress, its events, and so on.
> In many cases these associations need to be established
> before the task starts to execute.
>
> (Of course, the task's Runnable could be rigged to wait for a
> signal before it proceeds, but why make this so complicated?)

All of those are good examples showing how useful the abstraction of a
task is. And I did not at any point postulate its removal from the API.
The only way my proposal would affect the API of the FutureTask was that
you would start tasks with task.execute(Executor) rather than
executor.execute(task). You should like it even better, since it
resembles the Thread even more :)

My point was that an abstraction of a task may not always be appropriate
(I feel it may sometimes be too heavy), and a callee-constructs
convention is more natural as an atomic, low-level one to me. Also, I
have some cancellation concerns that will follow.

Doug Lea wrote:

> Here's a still-brief but better explanation: The main reason
> to prefer current design is that it better separates the
> responsibilities of tasks (FutureTasks etc) and Executors.

Well, but you do use executor to start up the task. Executor is a
controller of the task, master of its "life and death". So why do you
think it is inappropriate to logically associate lifetime
management-related operations other than start (cancellation and
wait-to-complete) with the executor? And if you move them to the task,
is it not better to move all of them together rather than leaving the
"start" operation in the executor?

In fact, let me dig that Thread analogy little deeper. I agree that
Thread is much like FutureTask. When you first creates it, nothing
happens - just a bunch of fields get initialized. Things start rolling
when you do start(), which is just like execute(). But what is the
executor of a thread? Does it have any? Yes - the operating system. Deep
down in the guts of a JVM there is a fork() call. And it returns the
child's PID to the caller! The PID is nothing but cancellation and
synchronization point for underlying process, and it gets associated
with the thread object much in the same way as the future returned from
executor gets associated with a FutureTask in my proposal. For instance,
I can imagine Thread.join() pseudocode as: { if (pid == null) return;
else OS.wait(pid) }. The bottom line is: task-like threads are
themselves implemented on top of something that looks more like Future
execute().

Also, let me bring some example from the actual Java API: Process
Runtime.exec(command). Command is your callable (it even returns a
value!), Runtime.exec - your executor, and Process is your
synchronization handle. (There is no cancellation, but it would have
been in the Process as well).

> In part because many more people will create custom task
> classes than custom executor classes, we need to eliminate
> dependencies of Executors on the details of tasks.

The way I see it, most custom task classes will simply extend
FutureTask, and it will work either way, whether the task is a
lower-level, mandatory construct (as you propose it) or a higher-level,
optional construct (as I propose it).

> Most
> other efficiency and usablilty arguments in favor of either
> of the two approaches seem to be a wash. Also, if you prefer
> callee-constructs conventions, you can layer this is a simple
> way on top of Executors, but the converse case wouldn't work.

Why not? You disregard returned future and use Callables.wrap(Runnable)
to pass an argument. Well, it is true that the scheme requires executors
to create return handles even if they are not used, but it is not such a
big deal if you have solid base class like BasicFuture (did you possibly
have any discouraging implementation experiences with that?). The only
problem seems to me to be how to cope with cancellation, but I believe
that this is executor-specific anyway.

Regarding callee-constructs conventions, indeed - first thing I did when
adopting dl.u.c was writing a static method Future execute(Executor,
Callable). But the difference is, dl.u.c.FutureResult was not
cancellable. So, again: how are you going to implement cancellation
independently of an executor? For instance, you have some kind of
QueuedExecutor. You cancel the task before it has been dequeued. How do
you remove it from the queue so it is not started at all? I guess you
can cook the "run" method in the task itself to check the cancellation
status at the beginning, but it is quite late at that point from the
resource allocation point of view.

Also, I would like to be able to implement remote executors. That is, I
would submit tasks (callables) that were serializable, and the executor
would send them for execution to remote slaves. In this scenario, the
runnable object on which the "run" method is invoked is a remote copy of
an object that has been submitted, and none of task-based cancellation
strategies will work.

Now, regarding immutability of Futures:

> >  However, I believe that
> > in this case (and actually in any other case when you might
> > be tempted
> > to use resettable futures) callbacks are better alternative

Doug Lea wrote:

> But is an interface contract requiring immutability valuable
> enough to you to annoy people who for some reason want to
> design using a custom resettable future class that will
> probably ignore the (unenforceable) contract anyway?

My answer would be yes, for two reasons. #1 is that I just can't imagine
the application where it would make sense to do something like this
actually using j.u.c.Future. Could you think of any example? If your
application needs such reusable async handles, why bother to make them
futures? You probably do not want to give those handles away anyway,
because then you would loose control over when you could reset them. So,
any use of those is inherently implementation-specific.

Reason #2 is simplicity of client codes. In you write all the code
yourself, any interface contracts may seem annoying. But then you can
disobey them anyway - they are unenforceable by definition, and nobody
else will be hurt. But if you depend on the code that somebody else
wrote according to some interface specification, you have nothing but
interface contracts to depend on. Everything that is not an interface
contract is an implementation detail.

Let me bring java.io.InputStream.read(byte[], int, int) as an example.
Interface contract specifies that the method blocks if there is no data
in the stream. It is somewhat restrictive for implementors - sometimes
it would possibly be easier to just return 0. But if this contract
wasn't there, it would be much harder to write correct programs working
with opaque input streams.

Now I think that it is reasonable and natural to expect immutability
from opaque Futures in much the same way it is reasonable to expect that
read() blocks on empty stream. For instance, it seems natural to me to
expect that isCompleted() always returns true after get() returned, and
that subsequent gets would return the same value. And just like streams,
futures are first-class objects and they can make long journey from
creation to the final client. I think that it will often be the case
that client waiting on the future will not know (or care) who created
the future. If you make immutability an implementation detail, you
invalidate some useful and natural assertions that clients could
otherwise assume.

And finally, just one another example: threads are not restartible, why
would tasks be? :)

Regards,
Dawid






From dawidk@mathcs.emory.edu Fri, 20 Sep 2002 23:36:27 -0400
Date: Fri, 20 Sep 2002 23:36:27 -0400
From: Dawid Kurzyniec dawidk@mathcs.emory.edu
Subject: [concurrency-interest] Re: Futures, callbacks, callables, runnables, and executors once again

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Joseph Bowbeer
> Sent: Friday, September 20, 2002 10:05 AM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Re: Futures, callbacks, 
> callables, runnables, and executors once again
> 
> 
> Dawid,
> 
> Here are a couple of comments.  Unfortunately not a 
> comprehensive response, but all I have time for at present.
> 
> Dawid Kurzyniec writes:
> 
> > The only way my proposal would affect the API of the FutureTask was 
> > that you would start tasks with
> > task.execute(Executor) rather than executor.execute(task).
> 
> If FutureTask were tied to Executor in this way, then 
> FutureTasks could no longer be executed directly or run 
> indirectly by threads.

Oh yes, thanks, that's one more benefit :) You avoid risks of executing
a task concurrently by many threads :)

Seriously: 
Of course you _can_ have tasks executed by threads - you only need to
wrap threads in Executors. For instance, use dl.u.c.DirectExecutor (BTW
how to obtain this in the new API): 

new Runnable() { public void run() { task.execute(new DirectExecutor());
} }

I think that a good reason for FutureTask NOT to implement Runnable is
that the task can be executed only once whereas (at least public)
runnables are usually stateless in respect to the execution context. If
the task implemented Runnable, users could get dangerous impression that
it was actually OK to run it more than once. Also, if you use
task.execute(...), you can detect and signal erronous subsequent start
as soon as in the task.execute(...). Otherwise, invoker stays unnotified
of a problem.

Also, if you REALLY want to have it, you can easily tweak my solution so
it supports run() in addition to execute(Executor) - e.g. having run()
exactly as the one in the example above. So I don't really see the point
here.



> Note that FutureTask is not only a basic task implementation, 
> it is also a basic Future implementation.  If we tied 
> FutureTask to Executor, we'd also need to add a BasicFuture 
> implementation.  (Perhaps FutureTask could extend
> BasicFuture...)

Why not?... Sure it could :)

Yes, I do believe that task is a heavier abstraction than a basic
(abstract?) future, and that everybody should not be forced/encouraged
to use it where they do not need it.

> 
> > So, again: how are you going to implement cancellation 
> independently 
> > of an executor? For instance, you have some kind of QueuedExecutor. 
> > You cancel the task before it has been dequeued. How do you 
> remove it 
> > from the queue so it is not started at all? I guess you can 
> cook the 
> > "run" method in the task itself to check the cancellation status
> > at the beginning
> 
> Yes, the FutureTask implementation of run() bails out if the 
> task has been cancelled.

And what about my remote executors?

Actually, I guess I will wait for that more comprehensive reply that is
still pending :) Or, for some clear message like: "We won't change it.
Stop bothering us" :P
Well, I understand that timing for this discussion is a little bad. But
I am afraid it won't get any better, and I was quiet for a long time
since the API was the way I liked it :)

PS. Perhaps I should change my tactics and start sending more smaller
messages rather than fewer bigger ones :)

Regards,
Dawid





From tim@peierls.net Sat, 21 Sep 2002 01:11:55 -0400
Date: Sat, 21 Sep 2002 01:11:55 -0400
From: Tim Peierls tim@peierls.net
Subject: [concurrency-interest] Re: Futures, callbacks,
 callables,runnables, and executors once again

Dawid Kurzyniec wrote:
> > > The only way my proposal would affect the API of the FutureTask was
> > > that you would start tasks with task.execute(Executor) rather than
> > > executor.execute(task).

What is nice about the latter is that executors and tasks are completely
decoupled, they aren't aware of each other as types. In fact, there is no 
canonical task interface, only interfaces describing services that task 
implementations might provide, e.g., Future, Cancellable. The only common 
point is that they both know about Runnable, tasks by implementing Runnable 
and executors by being able to run Runnables.

This decoupling is desirable because now 1) Executor implementations need 
only concentrate on running Runnables without worrying about how future 
results are returned or how cancellation is achieved, and 2) the task 
implementations need not worry about how an Executor will run them, 
and they can in fact be run by things other than Executors.

The problem with task.executeOn(executor) is that it unnecessarily couples 
both types together, making them both unusable outside of this context. It
implies a canonical task type to hold the executeOn method, which we didn't 
need before, and it forces these tasks to be used only with Executors, 
whereas a Runnable-based task, for example, can be handed to a Thread just 
as easily as to an Executor. And Executors need to know something about this 
task type in order to execute tasks, otherwise how would you implement 
Task.executeOn(Executor executor)?


> And what about my remote executors? ... I would submit tasks (callables) 
> that were serializable, and the executor would send them for execution to 
> remote slaves. In this scenario, the runnable object on which the "run" 
> method is invoked is a remote copy of an object that has been submitted, 
> and none of task-based cancellation strategies will work.

I think Executor.executable(runnable) was intended more as a flexible 
replacement for "new Thread(runnable).start()" than as a way to run tasks 
in a different JVM, though there's nothing explicitly ruling out remote 
execution in the javadocs for dl.u.c or the current draft.

If you really wanted to shoehorn remote execution on top of j.u.c, you
could have your local RemoteExecutor wrap your Callables to give them
one end of a channel for remote cancellation while it sends the marshalled 
original Callables to servers that in turn wrap the unmarshalled Callables 
to provide the other end of the channel and hand them off to their 
executors.

    interface FutureCancellable extends Future, Cancellable {}

    class RemoteExecutor implements Executor {
        FutureCancellable wrap (Callable callable) {...}
    }

    ... then use it so: ...
    Callable callMe = ...;
    RemoteExecutor re = ...;
    FutureCancellable fc = executor.wrap(callMe);
    re.execute(fc);
    ... later ...
    fc.cancel(true);

It would only work if you used the Executor-specific wrapping behavior,
but that's a reasonable limitation.


> Actually, I guess I will wait for that more comprehensive reply that is
> still pending :) Or, for some clear message like: "We won't change it.
> Stop bothering us" :P

I think a lot of folks are convinced that the current decoupled design
is the right design, so if you're still not swayed by my eloquence :-)
you need to demonstrate how the current design makes what you want to
do difficult (apart from remote executors).

--tim





From dawidk@mathcs.emory.edu Sat, 21 Sep 2002 11:59:14 -0400
Date: Sat, 21 Sep 2002 11:59:14 -0400
From: Dawid Kurzyniec dawidk@mathcs.emory.edu
Subject: [concurrency-interest] Re: Futures, callbacks, callables,runnables, and executors once again


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf
> Of Tim Peierls
> Sent: Saturday, September 21, 2002 1:12 AM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Re: Futures, callbacks, 
> callables,runnables, and executors once again
> 
> 
> Dawid Kurzyniec wrote:
> > > > The only way my proposal would affect the API of the FutureTask 
> > > > was that you would start tasks with
> task.execute(Executor) rather
> > > > than executor.execute(task).
> 
> What is nice about the latter is that executors and tasks are 
> completely decoupled, they aren't aware of each other as types. In 
> fact, there is no canonical task interface, only interfaces describing

> services that task
> implementations might provide, e.g., Future, Cancellable. 

And that's exactly why I believe task should not play such a central
role in the API which is otherwise founded on interfaces. Take java.util
- if you remove all the classes and leave only the interfaces, it will
still be consistent, and you cannot question placement of any single
interface. But if you remove FutureTask from j.u.c, suddenly three
important interfaces get orphaned or at least weakened: Callable,
Cancellable and Future. That's why I like Future
Executor.execute(Callable) - it binds the API together at the interface
level.

> The only common
> point is that they both know about Runnable, tasks by
> implementing Runnable 
> and executors by being able to run Runnables.
> 
> This decoupling is desirable because now 1) Executor implementations 
> need only concentrate on running Runnables without worrying about
> how future 
> results are returned or how cancellation is achieved
> (...)

The point I was trying to make was that the cancellation is
executor-specific anyway (at least up to the moment the task is handed
off to a thread for an actual execution), and future results are no big
deal if you have BasicFuture class. Executor knows when jobs start, it
knows when they end, it knows what they return - it already has all the
knowledge to furnish you with a future, and there is little to "worry
about". Requiring executors to return futures is the only complication I
could imagine my proposal introduces, but it is maybe five lines of code
per executor, and in exchange you get more efficient cancellation and
more error resistance.

> and 2) the task
> implementations need not worry about how an Executor will run them,

This holds in my proposal.

> and they can in fact be run by things other than Executors.

This holds too, if you use simple adapters as I shown in my previous
message.

> 
> The problem with task.executeOn(executor) is that it unnecessarily 
> couples both types together, making them both unusable outside of
> this context. 
> (...)

This statement is not true. In no way my proposal makes executors
dependent on tasks. Please refer to my proposed implementation of
task.execute() from my first mail. 

The other way around: yes, by default my proposal binds tasks to
executors. It does so 1) for the sake of error resistance, 2) because
the j.u.c recommends use of executors in preference to anything else,
threads in particular, 3) because you anyway can use adapters to run
tasks on anywhere you want if you don't like executors (but if you
don't, why would you like anything from j.u.c anyway) and 4) because for
me tasks are higher-level programming construct and I don't see their
dependence on base j.u.c API as anything wrong.

> > And what about my remote executors? ... I would submit tasks
> > (callables)
> > that were serializable, and the executor would send them
> for execution to
> > remote slaves. In this scenario, the runnable object on
> which the "run"
> > method is invoked is a remote copy of an object that has
> been submitted,
> > and none of task-based cancellation strategies will work.
> 
> I think Executor.executable(runnable) was intended more as a flexible 
> replacement for "new Thread(runnable).start()" than as a way to run 
> tasks in a different JVM, though there's nothing explicitly ruling
> out remote 
> execution in the javadocs for dl.u.c or the current draft.
> 
> If you really wanted to shoehorn remote execution on top of j.u.c, you

> could have your local RemoteExecutor wrap your Callables to give them 
> one end of a channel for remote cancellation while it sends the 
> marshalled original Callables to servers that in turn wrap the
> unmarshalled Callables 
> to provide the other end of the channel and hand them off to their 
> executors.
> 
>     interface FutureCancellable extends Future, Cancellable {}
> 
>     class RemoteExecutor implements Executor {
>         FutureCancellable wrap (Callable callable) {...}
>     }
> 
>     ... then use it so: ...
>     Callable callMe = ...;
>     RemoteExecutor re = ...;
>     FutureCancellable fc = executor.wrap(callMe);
>     re.execute(fc);
>     ... later ...
>     fc.cancel(true);

Well, you could always tie your shoes with spaghetti if there is nothing
better around. The wrap() method in the example returns nothing but a
custom version of FutureTask that is strictly bound to my particular
executor. I would probably have to define this class from scratch, since
FutureTask may be too heavy and I don't have any simpler alternative
base class. Next time I invent another custom executor (e.g. the one
that has so high cancellation rate that I would REALLY like to have
efficient "cancellation before started" and avoid unneccessary thread
spawns) and you will propose that I create another, similar class with
its own wrap() method. And, honestly, do you like how this solution look
like? Doesn't it resemble to you the spaghetti in a shoe? 

My point is: why don't we ADMIT that cancellation IS executor-dependent,
and do the wrapping ALWAYS, supporting this with a lightweight
BasicFuture, and so that the Future is returned from execute() rather
than a magic wrap(), and so that this future _may_ be cancellable if
executor supports that?

> I think a lot of folks are convinced that the current decoupled design

> is the right design, so if you're still not swayed by my eloquence :-)

> you need to demonstrate how the current design makes what you want to 
> do difficult (apart from remote executors).

Well, I will be able to do my job anyway, partially keeping my own
solutions instead of fully relying on j.u.c. My arguments were rather
related to: 1) design elegance 2) error resistance and 3) flat learning
curve. Most of the answers I got addressed 1) only, which is mostly a
matter of taste, but actually none of my concerns related to 2) and 3)
were addressed.

Anyway, I am close to giving up - I apprieciate the expertise of you
guys, I explained my points the best I could, nobody seems to share my
concerns - it's time to shut up, I meant to contribute, not to be
disruptive. But I am not convinced at all. I was hoping that if I am
missing the point somebody would enlight me but it did not happen - as I
said, most of my concerns has not been answered at all.

Well, at least I would really like to hear the answer to the problem of
erronous start of the task that has already been started. It stroke me
today again:

In my proposal, you 1) may avoid using tasks and the problem disappears,
since there is nothing wrong with resubmitting callables, and you always
get unique future associated with that submission, and 2) if you use
tasks, and if you invoke FutureTask.execute(Executor) on a task that has
already been started, the method immediately throws an
IllegalStateException - so it is fail-fast. 

In the current API, not only that the "create then submit" model is
recommended so that problem is much more likely to occur, and not only
it is not fail-fast, but in fact, I can't see _ANY_ place where it could
be reported at the run-time:

* executor.execute(task) will complete successfully, since executor
knows nothing about the task and the fact that the task has already been
started.
* at some undetermined point in the future, new thread will start
executing task.run(). This thread will immediately conclude that
"running" flag has already been set by somebody else. And what now?
* throw runtime exception? But nobody cares! The exception will be
catched by the executor and ignored.
* set the abrupt completion status on the task? But it will affect the
"legitimate" activity that may be still running, or even be already
done.

It looks to me that user may have serious bug in his program that is
relatively easy to make, and he gets absolutely NO FEEDBACK that
anything went wrong.

And there is some associated thing: how executor should react to the
run() method throwing a runtime exception? Ignore it? Dump to the
System.err? Well, ignoring runtime exceptions does not seem right, but
there is nobody to report the problem to at that point. In my proposal,
the responsibility is clear, because this is an executor to set
completion status of a future when call() completes.

Thanks, 
Dawid





From dholmes@dltech.com.au Mon, 23 Sep 2002 09:24:28 +1000
Date: Mon, 23 Sep 2002 09:24:28 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Re: Futures, callbacks, callables,runnables, and executors once again

Dawid,

I will try and give my quick (well this has now taken around an hour!)
2c on things. I think that the timing of your posts has been
unfortunate in one sense - because we are too close to releasing for
community review (and so we need to stabilise the API's and fill in
the details). On the other hand we could consider your comments the
first of the community review and be able to look at them in more
depth during that, and the public review phase.

Much of what you have written is focused on the role of Futures. To
you Futures seem a, if not the, key element. To me a Future brings to
mind wait-by-necessity - which is not part of multi-threaded
programming but a tool for "active object" style concurrent
programming. You wrote at one stage that "every computation yields a
result", which is true, but yielding a result does not always equate
to returning a value. I've never used a Future with an executor
because the result was sending back data on a network socket, or
updating a database or updating a GUI. So I don't put as big an
emphasis on Future in the executor context. I do however advocate the
existence of Future for those who want to do things using that style
of programming - and I like to broaden the education of all
multi-threaded programmers by introducing them to the idea if they
haven't seen it before. :)

I view Executor primarily as a replacement for "new
Thread(..).start();" - this is where thread pools evolve from. If
thread creation and management had zero cost we wouldn't need thread
pools - so a threaded executor is a tool for helping to minimise
thread costs while getting as much of the effect of thread-per-call as
is practical - in my view. It doesn't try to do much else - eg.
protecting the programmers from passing the same Runnable multiple
times (which you can do with a Thread too).

Taking ThreadedExecutor and abstracting out the Executor interface, we
can consider other forms of executor - such as those that introduce
specific threading models/styles that would be useful regardless of
cost issues - such as SingleThreaded or Queued Executor.

As we push on the Executor abstraction we find a range of alternative
styles where the functionality increases, there is more
sophistication, and the programming model changes somewhat. In fact we
can keep pushing and pushing on this abstraction. But the scope of
this JSR has to be bounded somewhere. Futures played a part in Doug
Lea's original util.concurrent toolkit and we considered them
appropriate to address here as well. The earlier design tied the
Future implementation with the Executor, but that didn't meet the
needs of everyone. In particular the coupling had to be broken and we
wanted to separate task creation from task submission/execution. So we
moved to the present design.

Much of what you have requested could be added to this design. We
could add extension interfaces for executors that wanted to work
directly with Futures, we could define all the appropriate control
interfaces and we could have interesting discussions about the
division of responsibility between the FutureTask and the Executor -
particularly in interesting areas like Cancellation. *But* we have
limited time and scope and from my perspective all of this has been
put on the other side of the line. The line might well move as we
progress through the review process, but we can't try to provide
everything that anyone might need.

Your comments and thoughts are appreciated, though as I said the
timing has been unfortunate.

Finally:

> And there is some associated thing: how executor should react to
> the run() method throwing a runtime exception? Ignore it? Dump to
> the System.err?

It is precisely because the executor can not know how to respond to
exceptions that the Runnable/task must account for them itself. If you
pass a Runnable to new Thread(..) you are implicitly saying that
you're okay with the default exception handling of threads - if you're
not then you code your Runnable with a try/catch. With the extensions
to exception handling that are proposed you will be able to change the
Thread default; similarly you can use ExecutorIntercepts to change the
Executor default. In both cases you still customise on a per-Runnable
basis by using try/catch in the Runnable.

David Holmes





From dl@cs.oswego.edu Wed, 25 Sep 2002 08:41:25 -0400
Date: Wed, 25 Sep 2002 08:41:25 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Re: Futures, callbacks, callables,runnables, and executors once again

Hi Dawid,

Thanks for all the arguments!. Critical comments are the best kind to
get at this point in this JSR.  As indicated by others, we have benn
considering various alternative factorings of Executor etc. Here's my
current story and rationale.

Despite your arguments otherwise, we still want to keep as separate as
possible the construction and execution of various task and executor
types. There are a bunch of reasons, but among them is the frequent
need to construct a task in one part of a system, but to arrange for
its execution in another.

Still, sometimes, task types and executor types will be intrinsically
coupled. For one example, imagine a special kind of based
PrioritizedExecutor, that maintains "lanes" of threads running at
various priorities, and needs to match requested task priority with
available threads. This would require both a customized executor and
customized task type (for representing desired priority
etc). Similarly even for our ScheduledExecutor class, which also
entails some coupling between tasks holding requested delays and the
executor processing them.

There are a number of design patterns available to address the
resulting "parallel subclassing" problem (i.e., here, subclassing both
tasks and executors). The one that seems to work best is to nest
task classes within executor classes. So all of these special forms
would look like:

public class SpecialExecutor implements Executor { // ...
  public abstract class SpecialTask implements Cancellable, Runnable { ... }
  public SpecialTask newSpecialTask(Runnable r, specialArgs);
  public void specialExecute(SpecialTask t);
}

This allows you to encapsulate any special mechanics (as nonpublic
methods of SpecialTask) needed to communicate between tasks and executors.

We took this approach in the revamped ScheduledExecutor class.

One slightly controversial aspect of this approach is that
SpecialExecutor must still support a "void execute(Runnable t)" method
-- that is it must be able to give a reasonable interpretation to a
request to run a "plain" Runnable. Usually there is something sensible
to do here.  (In ScheduledExecutor, it means to run with zero delay.)
When there isn't, you'd either want to give up on claiming that you
implement Executor or maybe throw UnsupportedOperationExceptions.

Note that the swiss-army-knife ThreadExecutor class doesn't require
specialy nested Task types -- it can work using the "universal"
Runnable type because it doesn't need any special per-Task
information. Doing it this way is a bit of a tradeoff. Failing to
require special-purpose task types keeps it very flexible and
lightweight, but it cannot automate things like killing cancelled
unprocessed Cancellable tasks from queues.  (It merely doesn't run
main runnable when they are dequeued.) If you need to do this, you'd
probably end up making a custom executor with the above
form. (Although in many cases you could get by using ExecutorIntercept
hooks to clean out queues at interception points.)

A disadvantage of the whole approach is that sometimes people might
find that SpecialTask becomes TOO coupled to SpecialExecutor -- the
task type might be perfectly suitable for running in
AnotherSpecialExecutor, but the implementation is inaccessible to
it. I don't think this will arise very often though.  

One other follow-up:

> Well, at least I would really like to hear the answer to the problem of
> erronous start of the task that has already been started. 

You can do this in a customized SpecialExecutor/SpecialTask (e.g., set
some bit in SpecialTask upon specialExecute). But requiring it again
runs against the primary design goals of keeping the framework
amenable to lightweight, "universal" implementations. As I wrote in
CPJ book, if you do not give up some capabilities of Threads, a
lightweight execution framework won't be any faster than just using
Threads.

-Doug




