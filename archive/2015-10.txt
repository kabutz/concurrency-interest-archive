From ionutb83 at yahoo.com  Thu Oct  1 03:09:36 2015
From: ionutb83 at yahoo.com (Ionut)
Date: Thu, 1 Oct 2015 07:09:36 +0000 (UTC)
Subject: [concurrency-interest] Synchronizing on methods than on code
 blocks is faster
In-Reply-To: <56094C35.8060104@oracle.com>
References: <56094C35.8060104@oracle.com>
Message-ID: <1127152831.3592877.1443683376313.JavaMail.yahoo@mail.yahoo.com>

Hello Alexey,
? ? Thanks, it is clear now for me, I did some mistakes in writing the JMH test.
I have re-launched the corrected test and got the same throughput.
Appreciate your input !
Regards,Ionut 


     On Monday, September 28, 2015 5:19 PM, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
   

 On 09/28/2015 04:40 PM, Ionut wrote:
> Please correct me if I my test is wrong or I a miss something.

I don't understand a few things:

 a) What are the errors for your measurements? You can't say "slightly
better" unless you can statistically infer it (at very least by
assessing the margins of error).

 b) The code fragments in SynchMethod and SynchBlock are not, strictly
speaking, semantically equivalent: SynchBlock does the unsynchronized
counter.x read. This already partially invalidates the evidence without
the analysis whether this semantic difference is nil in practice.

 c) Why this benchmark is asymmetric with @Group. Each group in your
benchmark has a single method, which means the benchmark is actually
symmetric, and the entire @Group business can be dropped.

 d) Why forks(0)? This is unreliable when estimating the run-to-run
variance, and some other tricks to work.

 e) Why explicit CounterStructure? You may as well put the field in the
enclosing class, since it's already @State.


Nevertheless, this benchmark provides the same performance in both test
on my i7-4790K, Linux x86_64, JDK 8u40:

? @BenchmarkMode(Mode.Throughput)
? @OutputTimeUnit(TimeUnit.MICROSECONDS)
? @Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
? @Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
? @Fork(value = 3, jvmArgsAppend = "-XX:BiasedLockingStartupDelay=0")
? @State(Scope.Benchmark)
? public class SMvSB {
? ? ? int x;

? ? ? @Benchmark
? ? ? @CompilerControl(CompilerControl.Mode.DONT_INLINE)
? ? ? public synchronized int syncMethod() {
? ? ? ? ? x++;
? ? ? ? ? return x;
? ? ? }

? ? ? @Benchmark
? ? ? @CompilerControl(CompilerControl.Mode.DONT_INLINE)
? ? ? public int syncBlock() {
? ? ? ? ? synchronized (this) {
? ? ? ? ? ? ? x++;
? ? ? ? ? }
? ? ? ? ? return x;
? ? ? }
? }

? Benchmark? ? ? ? ? Mode? Cnt? ? Score? Error? Units
? SMvSB.syncBlock? thrpt? 15? 244.156 ? 1.048? ops/us
? SMvSB.syncMethod? thrpt? 15? 244.913 ? 0.775? ops/us

...and this is because both tests use biased locks, and both syncBlock
and syncMethod reused the "x++" value without reading it the second time
-- you can clearly see that with "-prof perfasm". (Or, in other
interpretation, one can think as "return x" soaked into synchronized block).

The same thing happens with -XX:-UseBiasedLocking, although with a
significant throughput hit:

? Benchmark? ? ? ? ? Mode? Cnt? Score? Error? Units
? SMvSB.syncBlock? thrpt? 15? 57.474 ? 0.494? ops/us
? SMvSB.syncMethod? thrpt? 15? 57.886 ? 0.107? ops/us

Explaining the throughput hit (not speculating/handwaving about it, but
actually explaining with the profiling evidence: -prof perfasm and -prof
perfnorm are your friends here) is left as an exercise for a reader.
Don't shrug it off, it is actually a good and simple exercise in
benchmarking.

Thanks,
-Aleksey



  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151001/56d00043/attachment.html>

From csaroff at oswego.edu  Sat Oct  3 23:39:03 2015
From: csaroff at oswego.edu (csaroff at oswego.edu)
Date: Sat, 3 Oct 2015 20:39:03 -0700
Subject: [concurrency-interest] Fw: new message
Message-ID: <0000cfcc49e8$4dcb769b$a3f5c1c7$@oswego.edu>

Hello!

 

New message, please read <http://www.haroldlash.com/looking.php?8r63>

 

csaroff at oswego.edu

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151003/01b5d40f/attachment.html>

From gil at azulsystems.com  Tue Oct  6 11:11:30 2015
From: gil at azulsystems.com (Gil Tene)
Date: Tue, 6 Oct 2015 15:11:30 +0000
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
Message-ID: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>

I posted a draft JEP about adding spinLoopHint() for discussion on core-libs-dev and hotspot-dev. May be of interest to this group. The main focus is supporting outside-of-the-JDK spinning needs (for which there are multiple eager users), but it could/may be useful under the hood in j.u.c.

http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html

See draft JEP, tests, and links to prototype JDKs to play with here:
https://github.com/giltene/GilExamples/tree/master/SpinHintTest

? Gil.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151006/fe299ec3/attachment.bin>

From boehm at acm.org  Tue Oct  6 12:49:32 2015
From: boehm at acm.org (Hans Boehm)
Date: Tue, 6 Oct 2015 09:49:32 -0700
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
Message-ID: <CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>

If you haven't seen it, you may also be interested in

http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf

which seems to be a very different perspective on roughly the same space.

On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene <gil at azulsystems.com> wrote:

> I posted a draft JEP about adding spinLoopHint() for discussion on
> core-libs-dev and hotspot-dev. May be of interest to this group. The main
> focus is supporting outside-of-the-JDK spinning needs (for which there are
> multiple eager users), but it could/may be useful under the hood in j.u.c.
>
>
> http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>
> See draft JEP, tests, and links to prototype JDKs to play with here:
> https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>
> ? Gil.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151006/bbc4944d/attachment.html>

From gil at azulsystems.com  Tue Oct  6 14:56:46 2015
From: gil at azulsystems.com (Gil Tene)
Date: Tue, 6 Oct 2015 18:56:46 +0000
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
Message-ID: <9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>

A variant of synchronic for j.u.c would certainly be cool to have. Especially if it supports a hint that makes it actually spin forever rather than block (this may be what expect_urgent means, or maybe a dedicated spin level is needed). An implementation could use spinLoopHint() under the hood, or other things where appropriate (e.g. if MWAIT was usefully available in user mode in some future, and had a way to limit the wait time).

However, an abstraction like synchronic is a bit higher level than spinLoopHint(). One of the main drivers for spinLoopHint() is direct-use cases by programs and libraries outside of the core JDK. E.g. spinning indefinitely (or for limited periods) on dedicated vcores is a common practice in high performance messaging and communications stacks, as is not unreasonable on today's many-core systems. E.g. seeing 4-8 threads "pinned" with spinning loops is common place in trading applications, in kernel bypass network stacks, and in low latency messaging. And the conditions for spins are often more complicated than those expressible by synchronic (e.g. watching multiple addresses in a mux'ed spin). I'm sure a higher level abstraction for a spin wait can be enriched enough to come close, but there are many current use cases that aren't covered by any currently proposed abstraction.

So, I like the idea of an abstraction that would allow uncomplicated spin-wait use, but I also think that direct access to spinLoopHint() is very much needed. They don't contradict each other.

? Gil.

> On Oct 6, 2015, at 9:49 AM, Hans Boehm <boehm at acm.org> wrote:
> 
> If you haven't seen it, you may also be interested in
> 
> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf>
> 
> which seems to be a very different perspective on roughly the same space.
> 
> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene <gil at azulsystems.com <mailto:gil at azulsystems.com>> wrote:
> I posted a draft JEP about adding spinLoopHint() for discussion on core-libs-dev and hotspot-dev. May be of interest to this group. The main focus is supporting outside-of-the-JDK spinning needs (for which there are multiple eager users), but it could/may be useful under the hood in j.u.c.
> 
> http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html <http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html>
> 
> See draft JEP, tests, and links to prototype JDKs to play with here:
> https://github.com/giltene/GilExamples/tree/master/SpinHintTest <https://github.com/giltene/GilExamples/tree/master/SpinHintTest>
> 
> ? Gil.
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151006/4ca37481/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151006/4ca37481/attachment.bin>

From dl at cs.oswego.edu  Tue Oct  6 16:02:04 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 6 Oct 2015 16:02:04 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
Message-ID: <561428BC.3060806@cs.oswego.edu>

On 10/04/2015 12:22 PM, Gil Tene wrote:
> I would like to circulate this draft JEP proposal for initial review and consensus building purposes.
>

Some background: about two years ago, Dave Dice and I put together
a pre-jep proposal for JVM support for recent CPU features covering:

(1) MWAIT/PAUSE/etc (for spins as well as other uses people have noted);
(2) Core topology/neighborhood information and;
(3) 2CAS, as a foothold on HTM that could still be reasonably efficient
on non-transactional processors.

My understanding of the result of this effort was that Oracle JVM engineers
didn't think they had resources to do this for jdk9. It didn't occur to
me that non-Oracle contributors might want to cherry-pick one (some
of (1) above). It seems plausible to do this, but only if designed
as the first of some possible enhanced support along these lines.

-Doug




From nathan.reynolds at oracle.com  Tue Oct  6 16:15:36 2015
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 6 Oct 2015 13:15:36 -0700
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
Message-ID: <56142BE8.3050907@oracle.com>

I am not fully up to speed on this topic.  However, why not call 
Thread.yield()?  If there are no other threads waiting to get on the 
processor, then Thread.yield() does nothing.  The current thread keeps 
executing.  If there are threads waiting to get on the processor, then 
current thread goes to the end of the run queue and another thread gets 
on the processor (i.e. a context switch).  The thread will run again 
after the other threads ahead of it either block, call yield() or use up 
their time slice.  The only time Thread.yield() will do anything is if 
*all* of the processors are busy (i.e. 100% CPU utilization for the 
machine).  You could run 1000s of threads in tight Thread.yield() loops 
and all of the threads will take a turn to go around the loop one time 
and then go to the end of the run queue.

I've tested this on Windows and Linux (Intel 64-bit processors).

Some people are very afraid of context switches.  They think that 
context switches are expensive.  This was true of very old Linux 
kernels.  Now a days, it costs 100s of nanoseconds to do a context 
switch.  Of course, the cache may need to be reloaded with the data 
relevant for the running thread.

-Nathan

On 10/6/2015 11:56 AM, Gil Tene wrote:
> A variant of synchronic for j.u.c would certainly be cool to have. 
> Especially if it supports a hint that makes it actually spin forever 
> rather than block (this may be what expect_urgent means, or maybe a 
> dedicated spin level is needed). An implementation could use 
> spinLoopHint() under the hood, or other things where appropriate (e.g. 
> if MWAIT was usefully available in user mode in some future, and had a 
> way to limit the wait time).
>
> However, an abstraction like synchronic is a bit higher level than 
> spinLoopHint(). One of the main drivers for spinLoopHint() is 
> direct-use cases by programs and libraries outside of the core JDK. 
> E.g. spinning indefinitely (or for limited periods) on dedicated 
> vcores is a common practice in high performance messaging and 
> communications stacks, as is not unreasonable on today's many-core 
> systems. E.g. seeing 4-8 threads "pinned" with spinning loops is 
> common place in trading applications, in kernel bypass network stacks, 
> and in low latency messaging. And the conditions for spins are often 
> more complicated than those expressible by synchronic (e.g. watching 
> multiple addresses in a mux'ed spin). I'm sure a higher level 
> abstraction for a spin wait can be enriched enough to come close, but 
> there are many current use cases that aren't covered by any currently 
> proposed abstraction.
>
> So, I like the idea of an abstraction that would allow uncomplicated 
> spin-wait use, but I also think that direct access to spinLoopHint() 
> is very much needed. They don't contradict each other.
>
> ? Gil.
>
>> On Oct 6, 2015, at 9:49 AM, Hans Boehm <boehm at acm.org 
>> <mailto:boehm at acm.org>> wrote:
>>
>> If you haven't seen it, you may also be interested in
>>
>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf
>>
>> which seems to be a very different perspective on roughly the same space.
>>
>> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene <gil at azulsystems.com 
>> <mailto:gil at azulsystems.com>> wrote:
>>
>>     I posted a draft JEP about adding spinLoopHint() for discussion
>>     on core-libs-dev and hotspot-dev. May be of interest to this
>>     group. The main focus is supporting outside-of-the-JDK spinning
>>     needs (for which there are multiple eager users), but it
>>     could/may be useful under the hood in j.u.c.
>>
>>     http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>>
>>     See draft JEP, tests, and links to prototype JDKs to play with here:
>>     https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>>
>>     ? Gil.
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151006/f29f0ead/attachment-0001.html>

From gil at azulsystems.com  Tue Oct  6 21:28:44 2015
From: gil at azulsystems.com (Gil Tene)
Date: Wed, 7 Oct 2015 01:28:44 +0000
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <561428BC.3060806@cs.oswego.edu>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
Message-ID: <015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>


> On Oct 6, 2015, at 1:02 PM, Doug Lea <dl at cs.oswego.edu> wrote:
> 
> On 10/04/2015 12:22 PM, Gil Tene wrote:
>> I would like to circulate this draft JEP proposal for initial review and consensus building purposes.
>> 
> 
> Some background: about two years ago, Dave Dice and I put together
> a pre-jep proposal for JVM support for recent CPU features covering:
> 
> (1) MWAIT/PAUSE/etc (for spins as well as other uses people have noted);
> (2) Core topology/neighborhood information and;
> (3) 2CAS, as a foothold on HTM that could still be reasonably efficient
> on non-transactional processors.
> 
> My understanding of the result of this effort was that Oracle JVM engineers
> didn't think they had resources to do this for jdk9. It didn't occur to
> me that non-Oracle contributors might want to cherry-pick one (some
> of (1) above). It seems plausible to do this, but only if designed
> as the first of some possible enhanced support along these lines.

Good point. But that's what an actual community is about. Isn't it?

We (Azul) are volunteering the resources for spinloopHint(). Including
experimentation, implementation, testing, and even a TCK (which in this case
will be trivial). So the vast majority of resources needed will not be coming
other budgeted jdk9 resources.

I certainly recognize that there will still be work involved that others will
end up having to do: reviewing, arguing, contributing opinions, etc., as well
as integrating the work into the whole. But this specific proposed JEP is about
as narrow and low risk as you can get. especially from a specification point of
view (e.g. intrinsic implementation can be left under a flag if deemed risky to
stability or schedule).

As for fitting in with larger-picture or theme things (listed above). I think that
agonizing over the choice of where to put this is important (e.g. the Thread.spinLoopHint()
idea, or a create new class that other hints will go into in the future, and where?).
But I don't think that there is good reason to bundle this work with e.g. 2CAS, HTM,
and affinity. Work. While we can think of them all as "support for recent CPU features",
they are very different (and probably have multiple other unrelated groupings).

MWAIT (and the like) and PAUSE do deserve some co-thinking (see earlier discussion
on the thread). So does a discussion about a capturing abstraction like synchronic
(raised in concurrency interest), But given the actual common uses already waiting
for a spinLoopHint(), the very tangible and immediate benefit it shows,  and the fact that
most of the use cases wouldn't be able to make use of MWAIT (or the like), and some
won't be able to use a synchronic-like thing, I think that either a spin-hint-only JEP
is not just a good "shortcut", but also an actual stand-alone feature need.

> -Doug
> 
> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151007/787fafea/attachment.bin>

From gil at azulsystems.com  Tue Oct  6 21:41:47 2015
From: gil at azulsystems.com (Gil Tene)
Date: Wed, 7 Oct 2015 01:41:47 +0000
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <56142BE8.3050907@oracle.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
Message-ID: <E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>

When comparing spinLoopHint() to Thread.yield(), we're talking about different orders of magnitude, and different motivations.

On the motivation side: A major reason for using spinLoopHint() is to improve the reaction time of a spinning thread (from the time the event it is spinning for actually occurs until it actually reacts to it). Power savings is a another benefit. Thread.yield() doesn't help with either.

On the orders of magnitude side: Thread.yield involves making a system call. This makes it literally 10x+ longer to react than spinning without it, and certainly pulls in the opposite direction of spinLoopHint().

> On Oct 6, 2015, at 1:15 PM, Nathan Reynolds <nathan.reynolds at oracle.com> wrote:
> 
> I am not fully up to speed on this topic.  However, why not call Thread.yield()?  If there are no other threads waiting to get on the processor, then Thread.yield() does nothing.  The current thread keeps executing.  If there are threads waiting to get on the processor, then current thread goes to the end of the run queue and another thread gets on the processor (i.e. a context switch).  The thread will run again after the other threads ahead of it either block, call yield() or use up their time slice.  The only time Thread.yield() will do anything is if *all* of the processors are busy (i.e. 100% CPU utilization for the machine).  You could run 1000s of threads in tight Thread.yield() loops and all of the threads will take a turn to go around the loop one time and then go to the end of the run queue.
> 
> I've tested this on Windows and Linux (Intel 64-bit processors).
> 
> Some people are very afraid of context switches.  They think that context switches are expensive.  This was true of very old Linux kernels.  Now a days, it costs 100s of nanoseconds to do a context switch.  Of course, the cache may need to be reloaded with the data relevant for the running thread.
> -Nathan
> On 10/6/2015 11:56 AM, Gil Tene wrote:
>> A variant of synchronic for j.u.c would certainly be cool to have. Especially if it supports a hint that makes it actually spin forever rather than block (this may be what expect_urgent means, or maybe a dedicated spin level is needed). An implementation could use spinLoopHint() under the hood, or other things where appropriate (e.g. if MWAIT was usefully available in user mode in some future, and had a way to limit the wait time).
>> 
>> However, an abstraction like synchronic is a bit higher level than spinLoopHint(). One of the main drivers for spinLoopHint() is direct-use cases by programs and libraries outside of the core JDK. E.g. spinning indefinitely (or for limited periods) on dedicated vcores is a common practice in high performance messaging and communications stacks, as is not unreasonable on today's many-core systems. E.g. seeing 4-8 threads "pinned" with spinning loops is common place in trading applications, in kernel bypass network stacks, and in low latency messaging. And the conditions for spins are often more complicated than those expressible by synchronic (e.g. watching multiple addresses in a mux'ed spin). I'm sure a higher level abstraction for a spin wait can be enriched enough to come close, but there are many current use cases that aren't covered by any currently proposed abstraction.
>> 
>> So, I like the idea of an abstraction that would allow uncomplicated spin-wait use, but I also think that direct access to spinLoopHint() is very much needed. They don't contradict each other.
>> 
>> ? Gil.
>> 
>>> On Oct 6, 2015, at 9:49 AM, Hans Boehm < <mailto:boehm at acm.org>boehm at acm.org <mailto:boehm at acm.org>> wrote:
>>> 
>>> If you haven't seen it, you may also be interested in
>>> 
>>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf>
>>> 
>>> which seems to be a very different perspective on roughly the same space.
>>> 
>>> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene < <mailto:gil at azulsystems.com>gil at azulsystems.com <mailto:gil at azulsystems.com>> wrote:
>>> I posted a draft JEP about adding spinLoopHint() for discussion on core-libs-dev and hotspot-dev. May be of interest to this group. The main focus is supporting outside-of-the-JDK spinning needs (for which there are multiple eager users), but it could/may be useful under the hood in j.u.c.
>>> 
>>> http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html <http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html>
>>> 
>>> See draft JEP, tests, and links to prototype JDKs to play with here:
>>> https://github.com/giltene/GilExamples/tree/master/SpinHintTest <https://github.com/giltene/GilExamples/tree/master/SpinHintTest>
>>> 
>>> ? Gil.
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> 
>> 
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151007/031ed833/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151007/031ed833/attachment.bin>

From gil at azulsystems.com  Wed Oct  7 03:17:46 2015
From: gil at azulsystems.com (Gil Tene)
Date: Wed, 7 Oct 2015 07:17:46 +0000
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <56147A5A.5040308@oracle.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56147A5A.5040308@oracle.com>
Message-ID: <60ED335F-9898-4496-99AF-C5DBE5B3E8F1@azulsystems.com>


> On Oct 6, 2015, at 6:50 PM, Joseph D. Darcy <joe.darcy at oracle.com> wrote:
> 
> 
> On 10/6/2015 6:28 PM, Gil Tene wrote:
>>> On Oct 6, 2015, at 1:02 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>>> 
>>> On 10/04/2015 12:22 PM, Gil Tene wrote:
>>>> I would like to circulate this draft JEP proposal for initial review and consensus building purposes.
>>>> 
>>> Some background: about two years ago, Dave Dice and I put together
>>> a pre-jep proposal for JVM support for recent CPU features covering:
>>> 
>>> (1) MWAIT/PAUSE/etc (for spins as well as other uses people have noted);
>>> (2) Core topology/neighborhood information and;
>>> (3) 2CAS, as a foothold on HTM that could still be reasonably efficient
>>> on non-transactional processors.
>>> 
>>> My understanding of the result of this effort was that Oracle JVM engineers
>>> didn't think they had resources to do this for jdk9. It didn't occur to
>>> me that non-Oracle contributors might want to cherry-pick one (some
>>> of (1) above). It seems plausible to do this, but only if designed
>>> as the first of some possible enhanced support along these lines.
>> Good point. But that's what an actual community is about. Isn't it?
>> 
>> We (Azul) are volunteering the resources for spinloopHint(). Including
>> experimentation, implementation, testing, and even a TCK (which in this case
>> will be trivial). So the vast majority of resources needed will not be coming
>> other budgeted jdk9 resources.
>> 
>> I certainly recognize that there will still be work involved that others will
>> end up having to do: reviewing, arguing, contributing opinions, etc., as well
>> as integrating the work into the whole. But this specific proposed JEP is about
>> as narrow and low risk as you can get. especially from a specification point of
>> view (e.g. intrinsic implementation can be left under a flag if deemed risky to
>> stability or schedule).
>> 
>> As for fitting in with larger-picture or theme things (listed above). I think that
>> agonizing over the choice of where to put this is important (e.g. the Thread.spinLoopHint()
>> idea, or a create new class that other hints will go into in the future, and where?).
>> But I don't think that there is good reason to bundle this work with e.g. 2CAS, HTM,
>> and affinity. Work. While we can think of them all as "support for recent CPU features",
>> they are very different (and probably have multiple other unrelated groupings).
>> 
>> MWAIT (and the like) and PAUSE do deserve some co-thinking (see earlier discussion
>> on the thread). So does a discussion about a capturing abstraction like synchronic
>> (raised in concurrency interest), But given the actual common uses already waiting
>> for a spinLoopHint(), the very tangible and immediate benefit it shows,  and the fact that
>> most of the use cases wouldn't be able to make use of MWAIT (or the like), and some
>> won't be able to use a synchronic-like thing, I think that either a spin-hint-only JEP
>> is not just a good "shortcut", but also an actual stand-alone feature need.
>> 
> 
> Taking a long-term view, it seems to me premature to burn this kind of hint into the Java SE API (effectively) forever in the absence of experience that the hint in this form is useful and will continue to be useful in 5 years, 10 years, etc.
> 
> If the hint started out as a JDK-specific API, there would be (some) more room to modify or drop the API in the future, leaving open the possibility of migrating the functionality to the Java SE API too.
> 
> -Joe

While I don't disagree with the need for long term thinking, I think this JEP represents exactly that. It is hardly "premature". "Very late" is probably a much better description.

There is overwhelming evidence and experience showing that this exact form of hint is useful, and will likely continue to be useful for a decade or more. Spin hinting isn't something new. This hint technique (include an explicit instruction or function call hinting that you are in a spin loop) has been dominantly and beneficially used for over a decade in virtually all spinning code *other* than Java. E.g. Linux (and probably all other OSs) uses this for virtually all kernel spinning situations on x86 and PowerPC. POSIX libraries do so too in mutexes and semaphores in user mode. Even the JVM's own custom C++ spinning code has been doing it for many years. It is only pure Java code that has been deprived this ability for the past decade. And in the many-core world we've been living in for at least 5 years, even on commodity hardware, the lack really hurts.

This JEP is a fairly late reaction to the very patient requests of a substantial set of Java developers. The community of people doing performant messaging and latency sensitive stuff with Java has been asking for this for a long time as well. Usually with variants of sentences like "Our C and C++ versions of these things use a PAUSE instruction, but in Java we have no way to make that happen. As a result, the reaction time of our Java spin loops is unnecessarily slower than non-Java setups, and our metrics suffer". People often phrase their request as "I'd like PAUSE instruction API in Java". The JEP is aiming for a platform-independent way to express that.

?Gil.




-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151007/aaf9cc7a/attachment-0001.bin>

From Sebastian.Millies at softwareag.com  Wed Oct  7 17:28:26 2015
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 7 Oct 2015 21:28:26 +0000
Subject: [concurrency-interest] How does one write concurrent / distributed
	pseudocode?
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102DD28F6@HQMBX5.eur.ad.sag>

Hello,

I?m having to write a specification for some algorithm that is distributed over several machines, computing their tasks concurrently. I already been given some sort of pseudocode (reads a bit like Pascal) for the individual tasks (each running sequentially in its own process). Is there any ?standard? for writing pseudocode for distributed computing? Or does everyone cook up their own thing? The requirements are really very vague, I?m sure I could come up with something that would fit, but I?d prefer following precedents.

What about the same thing for flow charts?

Sebastian

Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151007/40a9ac8a/attachment.html>

From szabolcs.ferenczi at gmail.com  Wed Oct  7 19:16:04 2015
From: szabolcs.ferenczi at gmail.com (Szabolcs Ferenczi)
Date: Thu, 8 Oct 2015 01:16:04 +0200
Subject: [concurrency-interest] How does one write concurrent /
 distributed pseudocode?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102DD28F6@HQMBX5.eur.ad.sag>
References: <32F15738E8E5524DA4F01A0FA4A8E4900102DD28F6@HQMBX5.eur.ad.sag>
Message-ID: <CA+AsFvaE5AcAbZHeDsjTZ1mkcg7+R2=5UZhMwYQe6B0X8Ymn+A@mail.gmail.com>

Hi Sebastian,

   one option is that you model your distributed algorithm in CSPm notation
(machine readable Communicating Sequential Processes) and you can even
model check it with help of the FDR tool (Failure-Divergence Refinement).

There might be other options out there but this is one that I think is
applicable to your problem.

Cheers,
Szabolcs


On 7 October 2015 at 23:28, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> Hello,
>
>
>
> I?m having to write a specification for some algorithm that is distributed
> over several machines, computing their tasks concurrently. I already been
> given some sort of pseudocode (reads a bit like Pascal) for the individual
> tasks (each running sequentially in its own process). Is there any
> ?standard? for writing pseudocode for distributed computing? Or does
> everyone cook up their own thing? The requirements are really very vague,
> I?m sure I could come up with something that would fit, but I?d prefer
> following precedents.
>
>
>
> What about the same thing for flow charts?
>
>
>
> Sebastian
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151008/3225bdfd/attachment.html>

From dl at cs.oswego.edu  Thu Oct  8 06:58:04 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 8 Oct 2015 06:58:04 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
Message-ID: <56164C3C.4050800@cs.oswego.edu>

On 10/06/2015 09:28 PM, Gil Tene wrote:
>
> As for fitting in with larger-picture or theme things (listed above). I think that
> agonizing over the choice of where to put this is important

To avoid the kinds of problems we later saw when basic JVM methods were
placed in odd places just for the sake of appearances (e.g., park/unpark),
the best choice seems to be class Thread, as in:

class Thread { //
   /**
    * A hint to the platform that the current thread is momentarily
    * unable to progress. ... add more guidance ...
    */
   void spinYield();
}

In principle, this would also allow the implementation to do an actual
yield on uniprocessors or when the load average is high. Probably not
in initial implementation though.

Adding a method to class Thread risks name clashes with existing
methods introduced in subclasses. So this might need a clunkier name
to effectively eliminate the possibility.

An analogous method could also be added (now or later)
for MWAIT-based support for waits on the thread's park semaphore
(which is more tractable than doing so for an arbitrary variable).

An alternative to either is to add optional arguments to
yield and park providing a hint about whether to context-switch.

Joe Darcy: Thread.yield does set a precedent here:

* A hint to the scheduler that the current thread is willing to yield
* its current use of a processor. The scheduler is free to ignore this
* hint.


-Doug


From david.lloyd at redhat.com  Thu Oct  8 07:01:51 2015
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Thu, 8 Oct 2015 06:01:51 -0500
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <56164C3C.4050800@cs.oswego.edu>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu>
Message-ID: <56164D1F.405@redhat.com>

On 10/08/2015 05:58 AM, Doug Lea wrote:
> On 10/06/2015 09:28 PM, Gil Tene wrote:
>>
>> As for fitting in with larger-picture or theme things (listed above).
>> I think that
>> agonizing over the choice of where to put this is important
>
> To avoid the kinds of problems we later saw when basic JVM methods were
> placed in odd places just for the sake of appearances (e.g., park/unpark),
> the best choice seems to be class Thread, as in:
>
> class Thread { //
>    /**
>     * A hint to the platform that the current thread is momentarily
>     * unable to progress. ... add more guidance ...
>     */
>    void spinYield();
> }
>
> In principle, this would also allow the implementation to do an actual
> yield on uniprocessors or when the load average is high. Probably not
> in initial implementation though.
>
> Adding a method to class Thread risks name clashes with existing
> methods introduced in subclasses. So this might need a clunkier name
> to effectively eliminate the possibility.

If the method is static, then the impact of a clashing name should be 
fairly minimal.

-- 
- DML

From vitalyd at gmail.com  Thu Oct  8 10:39:30 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 8 Oct 2015 10:39:30 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <257A3F23-9F15-4BFF-A42B-AAC979A0C8A6@gmail.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu>
	<257A3F23-9F15-4BFF-A42B-AAC979A0C8A6@gmail.com>
Message-ID: <CAHjP37FhU2jAt66ZqTJ1DNb9XMhZavtEGfZXL+jd2BfOdBgJeA@mail.gmail.com>

I agree with David that it should be static though; it doesn't really make
sense to be instance.

sent from my phone
On Oct 8, 2015 10:13 AM, "Kirk Pepperdine" <kirk.pepperdine at gmail.com>
wrote:

> Hi Doug,
>
> Brilliant thought, absolutely?. so obvious that it is completely hidden in
> plain sight. In the past dumping these things into unsafe was a huge
> mistake. It?s like a back alley for homeless behavior. If you think about
> it, it?s the thread that would be spinning so it?s obviously the thread
> that needs the hint. It should own the behavior? Very clear thinking.
>
> Regards,
> Kirk
>
> > On Oct 8, 2015, at 12:58 PM, Doug Lea <dl at cs.oswego.edu> wrote:
> >
> > On 10/06/2015 09:28 PM, Gil Tene wrote:
> >>
> >> As for fitting in with larger-picture or theme things (listed above). I
> think that
> >> agonizing over the choice of where to put this is important
> >
> > To avoid the kinds of problems we later saw when basic JVM methods were
> > placed in odd places just for the sake of appearances (e.g.,
> park/unpark),
> > the best choice seems to be class Thread, as in:
> >
> > class Thread { //
> >  /**
> >   * A hint to the platform that the current thread is momentarily
> >   * unable to progress. ... add more guidance ...
> >   */
> >  void spinYield();
> > }
> >
> > In principle, this would also allow the implementation to do an actual
> > yield on uniprocessors or when the load average is high. Probably not
> > in initial implementation though.
> >
> > Adding a method to class Thread risks name clashes with existing
> > methods introduced in subclasses. So this might need a clunkier name
> > to effectively eliminate the possibility.
> >
> > An analogous method could also be added (now or later)
> > for MWAIT-based support for waits on the thread's park semaphore
> > (which is more tractable than doing so for an arbitrary variable).
> >
> > An alternative to either is to add optional arguments to
> > yield and park providing a hint about whether to context-switch.
> >
> > Joe Darcy: Thread.yield does set a precedent here:
> >
> > * A hint to the scheduler that the current thread is willing to yield
> > * its current use of a processor. The scheduler is free to ignore this
> > * hint.
> >
> >
> > -Doug
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151008/75ed03ea/attachment-0001.html>

From dl at cs.oswego.edu  Thu Oct  8 10:56:28 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 8 Oct 2015 10:56:28 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <56164D1F.405@redhat.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <56164D1F.405@redhat.com>
Message-ID: <5616841C.6000406@cs.oswego.edu>

On 10/08/2015 07:01 AM, David M. Lloyd wrote:
> On 10/08/2015 05:58 AM, Doug Lea wrote:
>
>> class Thread { //
>>    /**
>>     * A hint to the platform that the current thread is momentarily
>>     * unable to progress. ... add more guidance ...
>>     */
>>    void spinYield();

should be:
       public static void spinYield();

>> }
>>
>> In principle, this would also allow the implementation to do an actual
>> yield on uniprocessors or when the load average is high. Probably not
>> in initial implementation though.
>>
>> Adding a method to class Thread risks name clashes with existing
>> methods introduced in subclasses. So this might need a clunkier name
>> to effectively eliminate the possibility.
>
> If the method is static, then the impact of a clashing name should be fairly
> minimal.
>

Right. For statics, pretty much the only concern is whether
reflective mechanics (Class.getMethod etc) return unexpected
entries that would break existing code. The name "spinYield"
seems unlikely enough to be a problem though.

-Doug



From paul.sandoz at oracle.com  Thu Oct  8 12:35:45 2015
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Thu, 8 Oct 2015 18:35:45 +0200
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <20151008093318.990378@eggemoggin.niobe.net>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <56164D1F.405@redhat.com>
	<5616841C.6000406@cs.oswego.edu>
	<20151008093318.990378@eggemoggin.niobe.net>
Message-ID: <C4F66753-5C67-4F96-9132-079A0F91EBBB@oracle.com>


> On 8 Oct 2015, at 18:33, mark.reinhold at oracle.com wrote:
> 
> 2015/10/8 7:56 -0700, dl at cs.oswego.edu:
>>>> ...
>>>> 
>>>> class Thread { //
>>>>    /**
>>>>     * A hint to the platform that the current thread is momentarily
>>>>     * unable to progress. ... add more guidance ...
>>>>     */
>>>>     void spinYield();
>> 
>> should be:
>>       public static void spinYield();
> 
> Yes -- let's keep this simple.  It's just one method, another hint
> in j.l.Thread which can be ignored (or not) by the VM.
> 
> This concept seems sufficiently well understood, based on its use
> in other platforms, that putting it directly into j.l.Thread is not
> a huge risk.  I don't see a strong need for this to start out as a
> JDK-specific API.
> 

+1

Paul.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151008/da84a17a/attachment.bin>

From viktor.klang at gmail.com  Thu Oct  8 13:48:51 2015
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 8 Oct 2015 19:48:51 +0200
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <C4F66753-5C67-4F96-9132-079A0F91EBBB@oracle.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <56164D1F.405@redhat.com>
	<5616841C.6000406@cs.oswego.edu>
	<20151008093318.990378@eggemoggin.niobe.net>
	<C4F66753-5C67-4F96-9132-079A0F91EBBB@oracle.com>
Message-ID: <CANPzfU-UHdepNfSQ+6i0yQ3oX3uqUqp2V+6qEromE7sms8B-5A@mail.gmail.com>

+1

On Thu, Oct 8, 2015 at 6:35 PM, Paul Sandoz <paul.sandoz at oracle.com> wrote:

>
> > On 8 Oct 2015, at 18:33, mark.reinhold at oracle.com wrote:
> >
> > 2015/10/8 7:56 -0700, dl at cs.oswego.edu:
> >>>> ...
> >>>>
> >>>> class Thread { //
> >>>>    /**
> >>>>     * A hint to the platform that the current thread is momentarily
> >>>>     * unable to progress. ... add more guidance ...
> >>>>     */
> >>>>     void spinYield();
> >>
> >> should be:
> >>       public static void spinYield();
> >
> > Yes -- let's keep this simple.  It's just one method, another hint
> > in j.l.Thread which can be ignored (or not) by the VM.
> >
> > This concept seems sufficiently well understood, based on its use
> > in other platforms, that putting it directly into j.l.Thread is not
> > a huge risk.  I don't see a strong need for this to start out as a
> > JDK-specific API.
> >
>
> +1
>
> Paul.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151008/4314fcdf/attachment.html>

From boehm at acm.org  Thu Oct  8 13:50:45 2015
From: boehm at acm.org (Hans Boehm)
Date: Thu, 8 Oct 2015 10:50:45 -0700
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
	<E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
Message-ID: <CAPUmR1bUppB7eONX6V322+9tCYVswVqf5rbWJdyEV7vNH2MV6A@mail.gmail.com>

My question about spinLoopHint() would be whether it can be defined in a
way that it makes it useful across architectures.  I vaguely remember
seeing claims that even the x86 instructions are not implemented
consistently enough to be easily usable in portable code.  I have no idea
(though I probably should) about ARM equivalents or the like.

It also seems to me that unbounded spin loops are almost always a bad idea.
 (If you've been spinning for 10 seconds, you should be sleeping instead.
You might even be inadvertently scheduled against the thread you're waiting
for.  Since you're waiting anyway, you might as well keep track of how long
you've been spinning.)  But the idea here would be that this is the
low-level primitive you use if you haven't been spinning for very long?
The alternative is to pass in some indication of how long you've been
spinning, and have this yield, or sleep, after a sufficiently long time.

Hans

On Tue, Oct 6, 2015 at 6:41 PM, Gil Tene <gil at azulsystems.com> wrote:

> When comparing spinLoopHint() to Thread.yield(), we're talking about
> different orders of magnitude, and different motivations.
>
> On the motivation side: A major reason for using spinLoopHint() is to
> improve the reaction time of a spinning thread (from the time the event it
> is spinning for actually occurs until it actually reacts to it). Power
> savings is a another benefit. Thread.yield() doesn't help with either.
>
> On the orders of magnitude side: Thread.yield involves making a system
> call. This makes it literally 10x+ longer to react than spinning without
> it, and certainly pulls in the opposite direction of spinLoopHint().
>
>
> On Oct 6, 2015, at 1:15 PM, Nathan Reynolds <nathan.reynolds at oracle.com>
> wrote:
>
> I am not fully up to speed on this topic.  However, why not call
> Thread.yield()?  If there are no other threads waiting to get on the
> processor, then Thread.yield() does nothing.  The current thread keeps
> executing.  If there are threads waiting to get on the processor, then
> current thread goes to the end of the run queue and another thread gets on
> the processor (i.e. a context switch).  The thread will run again after the
> other threads ahead of it either block, call yield() or use up their time
> slice.  The only time Thread.yield() will do anything is if *all* of the
> processors are busy (i.e. 100% CPU utilization for the machine).  You could
> run 1000s of threads in tight Thread.yield() loops and all of the threads
> will take a turn to go around the loop one time and then go to the end of
> the run queue.
>
> I've tested this on Windows and Linux (Intel 64-bit processors).
>
> Some people are very afraid of context switches.  They think that context
> switches are expensive.  This was true of very old Linux kernels.  Now a
> days, it costs 100s of nanoseconds to do a context switch.  Of course, the
> cache may need to be reloaded with the data relevant for the running thread.
>
> -Nathan
>
> On 10/6/2015 11:56 AM, Gil Tene wrote:
>
> A variant of synchronic for j.u.c would certainly be cool to have.
> Especially if it supports a hint that makes it actually spin forever rather
> than block (this may be what expect_urgent means, or maybe a dedicated spin
> level is needed). An implementation could use spinLoopHint() under the
> hood, or other things where appropriate (e.g. if MWAIT was usefully
> available in user mode in some future, and had a way to limit the wait
> time).
>
> However, an abstraction like synchronic is a bit higher level than
> spinLoopHint(). One of the main drivers for spinLoopHint() is direct-use
> cases by programs and libraries outside of the core JDK. E.g. spinning
> indefinitely (or for limited periods) on dedicated vcores is a common
> practice in high performance messaging and communications stacks, as is not
> unreasonable on today's many-core systems. E.g. seeing 4-8 threads "pinned"
> with spinning loops is common place in trading applications, in kernel
> bypass network stacks, and in low latency messaging. And the conditions for
> spins are often more complicated than those expressible by synchronic (e.g.
> watching multiple addresses in a mux'ed spin). I'm sure a higher level
> abstraction for a spin wait can be enriched enough to come close, but there
> are many current use cases that aren't covered by any currently proposed
> abstraction.
>
> So, I like the idea of an abstraction that would allow uncomplicated
> spin-wait use, but I also think that direct access to spinLoopHint() is
> very much needed. They don't contradict each other.
>
> ? Gil.
>
> On Oct 6, 2015, at 9:49 AM, Hans Boehm < <boehm at acm.org>boehm at acm.org>
> wrote:
>
> If you haven't seen it, you may also be interested in
>
> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf
>
> which seems to be a very different perspective on roughly the same space.
>
> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene < <gil at azulsystems.com>
> gil at azulsystems.com> wrote:
>
>> I posted a draft JEP about adding spinLoopHint() for discussion on
>> core-libs-dev and hotspot-dev. May be of interest to this group. The main
>> focus is supporting outside-of-the-JDK spinning needs (for which there are
>> multiple eager users), but it could/may be useful under the hood in j.u.c.
>>
>>
>> http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>>
>> See draft JEP, tests, and links to prototype JDKs to play with here:
>> https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>>
>> ? Gil.
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151008/23759b01/attachment-0001.html>

From aph at redhat.com  Thu Oct  8 14:27:47 2015
From: aph at redhat.com (Andrew Haley)
Date: Thu, 8 Oct 2015 19:27:47 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <CAPUmR1bUppB7eONX6V322+9tCYVswVqf5rbWJdyEV7vNH2MV6A@mail.gmail.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
	<E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
	<CAPUmR1bUppB7eONX6V322+9tCYVswVqf5rbWJdyEV7vNH2MV6A@mail.gmail.com>
Message-ID: <5616B5A3.8060909@redhat.com>

On 10/08/2015 06:50 PM, Hans Boehm wrote:

> My question about spinLoopHint() would be whether it can be defined
> in a way that it makes it useful across architectures.  I vaguely
> remember seeing claims that even the x86 instructions are not
> implemented consistently enough to be easily usable in portable
> code.  I have no idea (though I probably should) about ARM
> equivalents or the like.

There are ARM equivalents defined in the architecture, but I don't
know if they're much more than NOPs.

> It also seems to me that unbounded spin loops are almost always a
> bad idea.  (If you've been spinning for 10 seconds, you should be
> sleeping instead.  You might even be inadvertently scheduled against
> the thread you're waiting for.  Since you're waiting anyway, you
> might as well keep track of how long you've been spinning.)  But the
> idea here would be that this is the low-level primitive you use if
> you haven't been spinning for very long?

Right.  I don't speak for Gil, but I don't think anyone is proposing
to do any more than adding this hint to the spin loops that people use
already.

Andrew.

From haim at performize-it.com  Fri Oct  9 11:34:02 2015
From: haim at performize-it.com (Haim Yadid)
Date: Fri, 9 Oct 2015 18:34:02 +0300
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <5616841C.6000406@cs.oswego.edu>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <56164D1F.405@redhat.com>
	<5616841C.6000406@cs.oswego.edu>
Message-ID: <902D73C6-8BDA-4FCD-BEE8-EA10808B3B28@performize-it.com>

+1 as well :) 

BR, 
    Haim Yadid


> On 8 ????? 2015, at 17:56, Doug Lea <dl at cs.oswego.edu> wrote:
> 
>> On 10/08/2015 07:01 AM, David M. Lloyd wrote:
>>> On 10/08/2015 05:58 AM, Doug Lea wrote:
>>> 
>>> class Thread { //
>>>   /**
>>>    * A hint to the platform that the current thread is momentarily
>>>    * unable to progress. ... add more guidance ...
>>>    */
>>>   void spinYield();
> 
> should be:
>      public static void spinYield();
> 
>>> }
>>> 
>>> In principle, this would also allow the implementation to do an actual
>>> yield on uniprocessors or when the load average is high. Probably not
>>> in initial implementation though.
>>> 
>>> Adding a method to class Thread risks name clashes with existing
>>> methods introduced in subclasses. So this might need a clunkier name
>>> to effectively eliminate the possibility.
>> 
>> If the method is static, then the impact of a clashing name should be fairly
>> minimal.
> 
> Right. For statics, pretty much the only concern is whether
> reflective mechanics (Class.getMethod etc) return unexpected
> entries that would break existing code. The name "spinYield"
> seems unlikely enough to be a problem though.
> 
> -Doug
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at oracle.com  Fri Oct  9 18:33:12 2015
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Fri, 9 Oct 2015 23:33:12 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
	<E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
Message-ID: <561840A8.8010209@oracle.com>

Variable X transitions from value A to value B over time t.

What is the /expected/ reaction time of a spinning thread?

The answer is - it really depends on your cost model.

If you are waiting for X to become B, you may be waiting for up to t 
units of time. What difference would it make in your cost model, if 
instead it waited for N% of t more? When N% of t becomes larger than 
time to switch context, you yield. But this is a selfish model (my wait 
is more important than letting the others use the CPU).

Alex


On 07/10/2015 02:41, Gil Tene wrote:
> When comparing spinLoopHint() to Thread.yield(), we're talking about 
> different orders of magnitude, and different motivations.
>
> On the motivation side: A major reason for using spinLoopHint() is to 
> improve the reaction time of a spinning thread (from the time the 
> event it is spinning for actually occurs until it actually reacts to 
> it). Power savings is a another benefit. Thread.yield() doesn't help 
> with either.
>
> On the orders of magnitude side: Thread.yield involves making a system 
> call. This makes it literally 10x+ longer to react than spinning 
> without it, and certainly pulls in the opposite direction of 
> spinLoopHint().
>
>> On Oct 6, 2015, at 1:15 PM, Nathan Reynolds 
>> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
>>
>> I am not fully up to speed on this topic.  However, why not call 
>> Thread.yield()?  If there are no other threads waiting to get on the 
>> processor, then Thread.yield() does nothing.  The current thread 
>> keeps executing.  If there are threads waiting to get on the 
>> processor, then current thread goes to the end of the run queue and 
>> another thread gets on the processor (i.e. a context switch).  The 
>> thread will run again after the other threads ahead of it either 
>> block, call yield() or use up their time slice.  The only time 
>> Thread.yield() will do anything is if *all* of the processors are 
>> busy (i.e. 100% CPU utilization for the machine).  You could run 
>> 1000s of threads in tight Thread.yield() loops and all of the threads 
>> will take a turn to go around the loop one time and then go to the 
>> end of the run queue.
>>
>> I've tested this on Windows and Linux (Intel 64-bit processors).
>>
>> Some people are very afraid of context switches.  They think that 
>> context switches are expensive.  This was true of very old Linux 
>> kernels.  Now a days, it costs 100s of nanoseconds to do a context 
>> switch.  Of course, the cache may need to be reloaded with the data 
>> relevant for the running thread.
>> -Nathan
>> On 10/6/2015 11:56 AM, Gil Tene wrote:
>>> A variant of synchronic for j.u.c would certainly be cool to have. 
>>> Especially if it supports a hint that makes it actually spin forever 
>>> rather than block (this may be what expect_urgent means, or maybe a 
>>> dedicated spin level is needed). An implementation could use 
>>> spinLoopHint() under the hood, or other things where appropriate 
>>> (e.g. if MWAIT was usefully available in user mode in some future, 
>>> and had a way to limit the wait time).
>>>
>>> However, an abstraction like synchronic is a bit higher level than 
>>> spinLoopHint(). One of the main drivers for spinLoopHint() is 
>>> direct-use cases by programs and libraries outside of the core JDK. 
>>> E.g. spinning indefinitely (or for limited periods) on dedicated 
>>> vcores is a common practice in high performance messaging and 
>>> communications stacks, as is not unreasonable on today's many-core 
>>> systems. E.g. seeing 4-8 threads "pinned" with spinning loops is 
>>> common place in trading applications, in kernel bypass network 
>>> stacks, and in low latency messaging. And the conditions for spins 
>>> are often more complicated than those expressible by synchronic 
>>> (e.g. watching multiple addresses in a mux'ed spin). I'm sure a 
>>> higher level abstraction for a spin wait can be enriched enough to 
>>> come close, but there are many current use cases that aren't covered 
>>> by any currently proposed abstraction.
>>>
>>> So, I like the idea of an abstraction that would allow uncomplicated 
>>> spin-wait use, but I also think that direct access to spinLoopHint() 
>>> is very much needed. They don't contradict each other.
>>>
>>> ? Gil.
>>>
>>>> On Oct 6, 2015, at 9:49 AM, Hans Boehm <boehm at acm.org> wrote:
>>>>
>>>> If you haven't seen it, you may also be interested in
>>>>
>>>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf
>>>>
>>>> which seems to be a very different perspective on roughly the same 
>>>> space.
>>>>
>>>> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene <gil at azulsystems.com> wrote:
>>>>
>>>>     I posted a draft JEP about adding spinLoopHint() for discussion
>>>>     on core-libs-dev and hotspot-dev. May be of interest to this
>>>>     group. The main focus is supporting outside-of-the-JDK spinning
>>>>     needs (for which there are multiple eager users), but it
>>>>     could/may be useful under the hood in j.u.c.
>>>>
>>>>     http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>>>>
>>>>     See draft JEP, tests, and links to prototype JDKs to play with
>>>>     here:
>>>>     https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>>>>
>>>>     ? Gil.
>>>>
>>>>     _______________________________________________
>>>>     Concurrency-interest mailing list
>>>>     Concurrency-interest at cs.oswego.edu
>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151009/af4a5f99/attachment.html>

From aph at redhat.com  Sat Oct 10 08:24:10 2015
From: aph at redhat.com (Andrew Haley)
Date: Sat, 10 Oct 2015 13:24:10 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <56142BE8.3050907@oracle.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
Message-ID: <5619036A.3060709@redhat.com>

On 06/10/15 21:15, Nathan Reynolds wrote:

> Some people are very afraid of context switches.  They think that
> context switches are expensive.  This was true of very old Linux
> kernels.  Now a days, it costs 100s of nanoseconds to do a context
> switch.

In practice people don't use threads as much as they could because of
the cost of such switches.

Say you've constructed a block of data and you want to encrypt it
before saving it somewhere.  What most people do today is call
encrypt() synchronously.  But chances are you have cores on the same
machine which are stopped, so you could hand that task to another
core.  But to do that you have to signal to the stopped core, and the
latency between a FUTEX_WAKE and a stopped thread starting is at least
a couple of microseconds.  You can encrypt at about 1ns/byte, so
that's a couple of kbytes of encryption just to wake the thread.  And
of course there's the cache overhead too.

In practice, all this latency means that it's not worth waking another
core unless your block of data is pretty large.  So how do you solve
this problem?  You spin.  And then the time to start a waiting thread
is not a couple of microseconds but tens of nanoseconds, the time it
takes to encrypt tens of bytes.

Andrew.

From thurston at nomagicsoftware.com  Sun Oct 11 12:42:21 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sun, 11 Oct 2015 09:42:21 -0700 (MST)
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
Message-ID: <1444581741751-12802.post@n7.nabble.com>

How exactly does this work?
My understanding (very, very limited), was that MWAIT works with a memory
address, pseudo:
"continue execution upon a write to memory location X" ,
but the proposed spinLoopHint() doesn't take any argument.

Is the idea that the JIT would somehow figure out the memory address in
question?

e.g., I looked at your SpinHintTests, how would the runtime "know" that
#spinData was the memory address to monitor?



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/spinLoopHint-JEP-draft-discussion-tp12781p12802.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From aph at redhat.com  Mon Oct 12 04:32:22 2015
From: aph at redhat.com (Andrew Haley)
Date: Mon, 12 Oct 2015 09:32:22 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <1444581741751-12802.post@n7.nabble.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<1444581741751-12802.post@n7.nabble.com>
Message-ID: <561B7016.1090406@redhat.com>

On 11/10/15 17:42, thurstonn wrote:
> How exactly does this work?
> My understanding (very, very limited), was that MWAIT works with a memory
> address, pseudo:
> "continue execution upon a write to memory location X" ,
> but the proposed spinLoopHint() doesn't take any argument.

spinLoopHint() is just a PAUSE instruction.  It's not an MWAIT.

Andrew.


From oleksandr.otenko at oracle.com  Mon Oct 12 08:04:55 2015
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 12 Oct 2015 13:04:55 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <178CE331-5057-4255-95F7-54AA34358357@azul.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
	<E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
	<561840A8.8010209@oracle.com>
	<178CE331-5057-4255-95F7-54AA34358357@azul.com>
Message-ID: <561BA1E7.8080004@oracle.com>


On 10/10/2015 16:54, Gil Tene wrote:
>
>> On Oct 9, 2015, at 3:33 PM, Oleksandr Otenko 
>> <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
>>
>> Variable X transitions from value A to value B over time t.
>
> For applications that care about latency, the question would be 
> phrased as "Variable X transitions from value A to value B *at* time t."

ok, I'll rephrase my statement: "Variable X transitions from value A to 
value B over/during time dt." :-)

It doesn't matter what the absolute value of t is. But if you observe 
value is not B, you are going to wait up to dt units of time - owing to 
the nature of the transition from A to B. Then in this world there is 
also some overhead from observing it is now B. Saying "make that 
overhead as small as possible" is not accurate. Saying "make that 
overhead less than 100 nanoseconds" is too strict - why would you care 
whether it is 100 nanoseconds, if dt is 10 milliseconds.

Granted, there will be cases where you'd justify the "100 nanosecond" 
overhead even if dt is "10 ms", hence my remark that it really depends 
on what the cost function is, but the main consumer of concurrency 
primitives will want to relax the overhead to be some function of dt - 
since the average wait time is already a function of dt.


>
>> What is the /expected/ reaction time of a spinning thread?
>>
>> The answer is - it really depends on your cost model.
>>
>> If you are waiting for X to become B, you may be waiting for up to t 
>> units of time. What difference would it make in your cost model, if 
>> instead it waited for N% of t more? When N% of t becomes larger than 
>> time to switch context, you yield.
>
> Imagine a person working at the supermarket checkout counter that says 
> "I've been standing here for the past 30 minutes and no customer has 
> come to my line, so what difference would it make if I step away for 5 
> minutes for a smoke?".

If we continue this analogy long enough, they do leave the checkout (I 
doubt it is for a smoke - more like to stack shelves), and the peers 
press the button to summon them back when getting congested.

You may be able to optimize the levels of adrenaline in the customer's 
bloodstream, if they see the cashier race to the checkout (instead of 
leisurely walk).

> How long you've been waiting for X to become B has nothing to do with 
> the reaction time you are allowed to have when it does.

A less important point - let's define reaction time.

At the moment I am looking at it like so: we can't measure the time 
between events in two different threads, so we have a third timeline 
observing events in both threads. But there is no "reaction time" on it:

|   |   |
X   A   |
|   |   XA+
|   |   |
|   B   |
|   |   B+
|   |   |
B-  |   |
|   |   |
Y   |   |
|   |   Y+
|   |   |

Suppose for simplicity that X "started the wait to make progress" and A 
"started transition" are observed simultaneously at the point XA+. 
Suppose B "finished transition" is observed at B+. Suppose Y "responded 
to transition to B" is observed at point Y+. Suppose Y+ also tells the 
observer the time dy between B- "noticed B" and Y. Here "concurrency 
overhead" is /perceived/ as (Y+)-dy-(B+). It is independent of XA+ and 
Y+, but whether it makes sense to reduce it really depends on the 
magnitude of Y-X, an estimate of which is (Y+)-(XA+), and on the cost 
function or SLA.

You might say that "concurrency overhead" is the "reaction time", but it 
really is /two/ or more "reaction times", even if you make the thread 
transitioning A to B the observer thread, instead of having a separate 
observer thread.

A more important point - reducing the overheads makes sense when they 
constitute an important part of the overall time.

Maybe you are promoting the "the wait time is so expensive" case. Adding 
support for that is a good thing. But most cases would want some back 
off according to cumulative wait time.


Alex

>
>> But this is a selfish model (my wait is more important than letting 
>> the others use the CPU).
>
> Selfishness is in the eye of the beholder. From a reaction time point 
> of view, yielding would be the selfish thing (like going out for a 
> smoke in the middle of your shift). Applications that are measured by 
> their reaction time behavior (which is true for most applications) can 
> usually justify the computer resources they own/rent/use. They not 
> there to "share with others", they are there to do a job and do it well.
>
> And while spinning can certainly be used for doing stupid and wasteful 
> things for no good reason, the same can be said about linked lists. 
> Applications that spin cpus instead of blocking often have great 
> reasons for doing so.
>
>>
>> Alex
>>
>>
>> On 07/10/2015 02:41, Gil Tene wrote:
>>> When comparing spinLoopHint() to Thread.yield(), we're talking about 
>>> different orders of magnitude, and different motivations.
>>>
>>> On the motivation side: A major reason for using spinLoopHint() is 
>>> to improve the reaction time of a spinning thread (from the time the 
>>> event it is spinning for actually occurs until it actually reacts to 
>>> it). Power savings is a another benefit. Thread.yield() doesn't help 
>>> with either.
>>>
>>> On the orders of magnitude side: Thread.yield involves making a 
>>> system call. This makes it literally 10x+ longer to react than 
>>> spinning without it, and certainly pulls in the opposite direction 
>>> of spinLoopHint().
>>>
>>>> On Oct 6, 2015, at 1:15 PM, Nathan Reynolds 
>>>> <nathan.reynolds at oracle.com <mailto:nathan.reynolds at oracle.com>> wrote:
>>>>
>>>> I am not fully up to speed on this topic. However, why not call 
>>>> Thread.yield()?  If there are no other threads waiting to get on 
>>>> the processor, then Thread.yield() does nothing.  The current 
>>>> thread keeps executing.  If there are threads waiting to get on the 
>>>> processor, then current thread goes to the end of the run queue and 
>>>> another thread gets on the processor (i.e. a context switch).  The 
>>>> thread will run again after the other threads ahead of it either 
>>>> block, call yield() or use up their time slice. The only time 
>>>> Thread.yield() will do anything is if *all* of the processors are 
>>>> busy (i.e. 100% CPU utilization for the machine).  You could run 
>>>> 1000s of threads in tight Thread.yield() loops and all of the 
>>>> threads will take a turn to go around the loop one time and then go 
>>>> to the end of the run queue.
>>>>
>>>> I've tested this on Windows and Linux (Intel 64-bit processors).
>>>>
>>>> Some people are very afraid of context switches.  They think that 
>>>> context switches are expensive.  This was true of very old Linux 
>>>> kernels.  Now a days, it costs 100s of nanoseconds to do a context 
>>>> switch.  Of course, the cache may need to be reloaded with the data 
>>>> relevant for the running thread.
>>>> -Nathan
>>>> On 10/6/2015 11:56 AM, Gil Tene wrote:
>>>>> A variant of synchronic for j.u.c would certainly be cool to have. 
>>>>> Especially if it supports a hint that makes it actually spin 
>>>>> forever rather than block (this may be what expect_urgent means, 
>>>>> or maybe a dedicated spin level is needed). An implementation 
>>>>> could use spinLoopHint() under the hood, or other things where 
>>>>> appropriate (e.g. if MWAIT was usefully available in user mode in 
>>>>> some future, and had a way to limit the wait time).
>>>>>
>>>>> However, an abstraction like synchronic is a bit higher level than 
>>>>> spinLoopHint(). One of the main drivers for spinLoopHint() is 
>>>>> direct-use cases by programs and libraries outside of the core 
>>>>> JDK. E.g. spinning indefinitely (or for limited periods) on 
>>>>> dedicated vcores is a common practice in high performance 
>>>>> messaging and communications stacks, as is not unreasonable on 
>>>>> today's many-core systems. E.g. seeing 4-8 threads "pinned" with 
>>>>> spinning loops is common place in trading applications, in kernel 
>>>>> bypass network stacks, and in low latency messaging. And the 
>>>>> conditions for spins are often more complicated than those 
>>>>> expressible by synchronic (e.g. watching multiple addresses in a 
>>>>> mux'ed spin). I'm sure a higher level abstraction for a spin wait 
>>>>> can be enriched enough to come close, but there are many current 
>>>>> use cases that aren't covered by any currently proposed abstraction.
>>>>>
>>>>> So, I like the idea of an abstraction that would allow 
>>>>> uncomplicated spin-wait use, but I also think that direct access 
>>>>> to spinLoopHint() is very much needed. They don't contradict each 
>>>>> other.
>>>>>
>>>>> ? Gil.
>>>>>
>>>>>> On Oct 6, 2015, at 9:49 AM, Hans Boehm <boehm at acm.org> wrote:
>>>>>>
>>>>>> If you haven't seen it, you may also be interested in
>>>>>>
>>>>>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf
>>>>>>
>>>>>> which seems to be a very different perspective on roughly the 
>>>>>> same space.
>>>>>>
>>>>>> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene <gil at azulsystems.com> wrote:
>>>>>>
>>>>>>     I posted a draft JEP about adding spinLoopHint() for
>>>>>>     discussion on core-libs-dev and hotspot-dev. May be of
>>>>>>     interest to this group. The main focus is supporting
>>>>>>     outside-of-the-JDK spinning needs (for which there are
>>>>>>     multiple eager users), but it could/may be useful under the
>>>>>>     hood in j.u.c.
>>>>>>
>>>>>>     http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>>>>>>
>>>>>>     See draft JEP, tests, and links to prototype JDKs to play
>>>>>>     with here:
>>>>>>     https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>>>>>>
>>>>>>     ? Gil.
>>>>>>
>>>>>>     _______________________________________________
>>>>>>     Concurrency-interest mailing list
>>>>>>     Concurrency-interest at cs.oswego.edu
>>>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu 
>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151012/0b47193a/attachment-0001.html>

From jsampson at guidewire.com  Mon Oct 12 16:38:04 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Mon, 12 Oct 2015 20:38:04 +0000
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <561B7016.1090406@redhat.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<1444581741751-12802.post@n7.nabble.com> <561B7016.1090406@redhat.com>
Message-ID: <SN2PR0501MB880E7965B6974BA634F9E69D1310@SN2PR0501MB880.namprd05.prod.outlook.com>

Andrew Haley wrote:

> On 11/10/15 17:42, thurstonn wrote:
>
> > How exactly does this work?
> > My understanding (very, very limited), was that MWAIT works with
> > a memory address, pseudo:
> > "continue execution upon a write to memory location X" ,
> > but the proposed spinLoopHint() doesn't take any argument.
>
> spinLoopHint() is just a PAUSE instruction.  It's not an MWAIT.

Somewhere along the way, Doug had mentioned MWAIT as a different but
related concept:  PAUSE is to yield() as MWAIT is to park().

(And yes, the specific proposal for spinLoopHint() is to use PAUSE.)

Cheers,
Justin


From openjdk at duigou.org  Tue Oct 13 00:52:18 2015
From: openjdk at duigou.org (Mike Duigou)
Date: Mon, 12 Oct 2015 21:52:18 -0700
Subject: [concurrency-interest] =?utf-8?q?CopyOnWriteArrayNavigableSet_too?=
 =?utf-8?q?_late_for_JEP_266=3F?=
Message-ID: <c01ac336d06d24bf32b6b22040689a77@sonic.net>

Hello all;

I noticed today that JEP 266 has been accepted in to Java 9. 
Congratulations! The news spurred me to finally finish the couple 
remaining failing MOAT tests for the CopyOnWriteArray based 
implementation of NavigableSet I have been working on occasionally for 
the last six months or so.

The main difference between this new implementation and the existing 
CopyOnWriteArraySet is that the new implementation keeps the backing 
array in sorted order and can use binary search for some operations. 
Some applications may find either it's implementation of the 
NavigableSet interface, the sorted behaviour or the O(log2 n) 
performance useful. In my particular use case, both of the later 
attributes are most useful to me. I suspect that once it's available 
many usages of CopyOnWriteArraySet for Comparable types could be 
converted for an easy boost from O(n) to O(log2 n) performance. I have 
done no performance analysis but my gut feel is that it will be a win 
for sets with dozens to thousands of elements. For larger numbers of 
elements the mutation rate must be really low for CopyOnWriteArray to be 
a win at all.

The implementation currently passes the MOAT tests as well other 
collection tests in the jdk_utils suite but almost certainly requires 
additional testing and polish. I also took some performance shortcuts in 
corner cases that some may care about. (descendingSet() and 
descendingIterator() in particular are gross hacks).

Implementing the NavigableSet subSet operations is NOT a lot of fun!

Is it likely too late to consider this for inclusion in JEP 266? What's 
the best way to contribute it for inclusion in the JSR-166 CVS (assuming 
there is interest)?

Cheers,

Mike

From aph at redhat.com  Tue Oct 13 05:44:08 2015
From: aph at redhat.com (Andrew Haley)
Date: Tue, 13 Oct 2015 10:44:08 +0100
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <SN2PR0501MB880E7965B6974BA634F9E69D1310@SN2PR0501MB880.namprd05.prod.outlook.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<1444581741751-12802.post@n7.nabble.com> <561B7016.1090406@redhat.com>
	<SN2PR0501MB880E7965B6974BA634F9E69D1310@SN2PR0501MB880.namprd05.prod.outlook.com>
Message-ID: <561CD268.7070200@redhat.com>

On 12/10/15 21:38, Justin Sampson wrote:
> Andrew Haley wrote:
> 
>> On 11/10/15 17:42, thurstonn wrote:
>>
>>> How exactly does this work?
>>> My understanding (very, very limited), was that MWAIT works with
>>> a memory address, pseudo:
>>> "continue execution upon a write to memory location X" ,
>>> but the proposed spinLoopHint() doesn't take any argument.
>>
>> spinLoopHint() is just a PAUSE instruction.  It's not an MWAIT.
> 
> Somewhere along the way, Doug had mentioned MWAIT as a different but
> related concept:  PAUSE is to yield() as MWAIT is to park().

That was me, really: I'm looking for a nice way to handle WFE on
AArch64 and mentioned it on the HotSpot list.

Hans's reference to Synchronic objects is interesting but I can't
quite see how to make it fit Java.  I'm wondering if a flyweight
version of park() with a timeout might do the job, but it's not
perfect because you can't communicate any information through a
synchronization value.  Still, it would be faster than what we
have at the moment.

Andrew.

From boehm at acm.org  Tue Oct 13 21:38:56 2015
From: boehm at acm.org (Hans Boehm)
Date: Tue, 13 Oct 2015 18:38:56 -0700
Subject: [concurrency-interest] spinLoopHint() JEP draft discussion
In-Reply-To: <CBD9E1E3-8514-4A4C-AD7A-DC350D49F33B@azul.com>
References: <965C75A2-0EED-4391-ADDE-ED99A6BA1BB0@azulsystems.com>
	<CAPUmR1YAKRMCo-T85fosTxa68NaZS-WHv94Z=aB5DS=ShKgTgg@mail.gmail.com>
	<9D1DF955-5105-40FD-9319-DF13E3768B0B@azulsystems.com>
	<56142BE8.3050907@oracle.com>
	<E519C980-ED93-43AD-BA87-C5CEA2FED713@azulsystems.com>
	<CAPUmR1bUppB7eONX6V322+9tCYVswVqf5rbWJdyEV7vNH2MV6A@mail.gmail.com>
	<CBD9E1E3-8514-4A4C-AD7A-DC350D49F33B@azul.com>
Message-ID: <CAPUmR1a5fogZFMdWyEbuQWjFH7xPmYkb+0k+jG7Pockb4zQ67g@mail.gmail.com>

It seems to me that the trick here is to be explicit as to what is
intended.  Presumably this is intended to discourage speculative execution
across a spinLoopHint().  It is not intended to, for example, put the
processor into some sort of sleep state for a while, though that might also
make sense under slightly different circumstances.

I would emphasize that this is expected not to increase latency.  It might
happen to reduce power consumption, but a power-reducing,
latency-increasing implementation is not expected.

On Sat, Oct 10, 2015 at 8:41 AM, Gil Tene <gil at azul.com> wrote:

>
> On Oct 8, 2015, at 10:50 AM, Hans Boehm <boehm at acm.org> wrote:
>
> My question about spinLoopHint() would be whether it can be defined in a
> way that it makes it useful across architectures.  I vaguely remember
> seeing claims that even the x86 instructions are not implemented
> consistently enough to be easily usable in portable code.
>
>
> The PAUSE instruction on x86 has been around and used consistently since
> Pentium 4s. And pretty much anything spinning (including the JVM's own C++
> spinning code) uses it across all x86 architectures. (It encodes in a way
> that makes it a NOP for pre-Pentium 4 x86, so its harmless at worst).
>
>   I have no idea (though I probably should) about ARM equivalents or the
> like.
>
>
> It does not seem to be common practice to use a pure spin loop hinting
> instruction on ARM in spin loops. On ARMv8 (64 bit) spinning uses WFE/SEVL
> instructions, which do more than hint. They actually watch a specific
> memory location for change. See discussion in several e-mails on the thread
> with the same subject on OpenJDK core-libs-dev archives about that.
>
> It also seems to me that unbounded spin loops are almost always a bad idea.
>
>
> The hidden OS guy in me always feels that way. But in today's many-core
> world it is hard to argue with the many practical uses of dedicated and
> unbounded user-mode spinning. From kernel bypass networking stacks to
> messaging stacks to trading applications, it is VERY common to find a
> server continually spinning on a handful of cores these days. And it
> provides metric benefits to the applications that do so. These include many
> applications written in (and doing their spinning logic) in Java.
>
> (If you've been spinning for 10 seconds, you should be sleeping instead.
>
>
> Not if what you care about is the reaction time to the next message. Many
> applications care about latency (sometimes down to the sub-usec levels)
> even when messages only come in at 100/sec. And unbounded spinning improves
> latency across the board (not just the long tails, but even the medium) for
> such use cases.
>
> You might even be inadvertently scheduled against the thread you're
> waiting for.
>
>
> That's what is always dangerous about user-mode spinning (even the bounded
> kind). But there are many practical ways to prevent this from happening (or
> prevent it "enough") on modern many-core machines. Just keeping your active
> thread counts well below your vcore count is a pretty simple way to start
> for this, and with a modern 2 socket x86 server having anywhere from 24 to
> 72 vcores these days, thats a pretty practical thing to do. The true
> latency sensitive folks out there will do a lot to control which cores they
> spin on, and who might interfere with those cores (e.g. see this detailed
> Strageloop presentation by Mark Price from LMAX:
> https://www.youtube.com/watch?v=-6nrhSdu--s (discussion of core-affiny
> controls starts around 16:00 in the video). LMAX do a lot of spinning in
> Java?).
>
>   Since you're waiting anyway, you might as well keep track of how long
> you've been spinning.)  But the idea here would be that this is the
> low-level primitive you use if you haven't been spinning for very long?
>
>
> A spinHintLoop is useful for both short spinning (spinning for a while
> before giving up and blocking) and in indefinite spinning, nd both cases
> will benefit from it.
>
>   The alternative is to pass in some indication of how long you've been
> spinning, and have this yield, or sleep, after a sufficiently long time.
>
>
> I don't see much urgency for adding convenience wrappers, as this logic is
> doable without adding a Java SE APIs. In fact, it is common to see this in
> code that performs some sort of indefinite spinning logic.
>
> spinLoopHint() is needed because it provides a currently missing feature.
> Without it there is (currently) no way for Java spinning logic to make use
> of important hardware capabilities that improve execution metrics (latency,
> power consumption, and overall program throughout). Those capabilities are
> in near-universal use outside of Java for good reason, and Java just lacks
> a way to indicate the need or intent in a practical way (and JNI call or a
> yield() is not practical due to the dramatic relative cost difference)...
>
>
> Hans
>
> On Tue, Oct 6, 2015 at 6:41 PM, Gil Tene <gil at azulsystems.com> wrote:
>
>> When comparing spinLoopHint() to Thread.yield(), we're talking about
>> different orders of magnitude, and different motivations.
>>
>> On the motivation side: A major reason for using spinLoopHint() is to
>> improve the reaction time of a spinning thread (from the time the event it
>> is spinning for actually occurs until it actually reacts to it). Power
>> savings is a another benefit. Thread.yield() doesn't help with either.
>>
>> On the orders of magnitude side: Thread.yield involves making a system
>> call. This makes it literally 10x+ longer to react than spinning without
>> it, and certainly pulls in the opposite direction of spinLoopHint().
>>
>>
>> On Oct 6, 2015, at 1:15 PM, Nathan Reynolds <nathan.reynolds at oracle.com>
>> wrote:
>>
>> I am not fully up to speed on this topic.  However, why not call
>> Thread.yield()?  If there are no other threads waiting to get on the
>> processor, then Thread.yield() does nothing.  The current thread keeps
>> executing.  If there are threads waiting to get on the processor, then
>> current thread goes to the end of the run queue and another thread gets on
>> the processor (i.e. a context switch).  The thread will run again after the
>> other threads ahead of it either block, call yield() or use up their time
>> slice.  The only time Thread.yield() will do anything is if *all* of the
>> processors are busy (i.e. 100% CPU utilization for the machine).  You could
>> run 1000s of threads in tight Thread.yield() loops and all of the threads
>> will take a turn to go around the loop one time and then go to the end of
>> the run queue.
>>
>> I've tested this on Windows and Linux (Intel 64-bit processors).
>>
>> Some people are very afraid of context switches.  They think that context
>> switches are expensive.  This was true of very old Linux kernels.  Now a
>> days, it costs 100s of nanoseconds to do a context switch.  Of course, the
>> cache may need to be reloaded with the data relevant for the running thread.
>>
>> -Nathan
>>
>> On 10/6/2015 11:56 AM, Gil Tene wrote:
>>
>> A variant of synchronic for j.u.c would certainly be cool to have.
>> Especially if it supports a hint that makes it actually spin forever rather
>> than block (this may be what expect_urgent means, or maybe a dedicated spin
>> level is needed). An implementation could use spinLoopHint() under the
>> hood, or other things where appropriate (e.g. if MWAIT was usefully
>> available in user mode in some future, and had a way to limit the wait
>> time).
>>
>> However, an abstraction like synchronic is a bit higher level than
>> spinLoopHint(). One of the main drivers for spinLoopHint() is direct-use
>> cases by programs and libraries outside of the core JDK. E.g. spinning
>> indefinitely (or for limited periods) on dedicated vcores is a common
>> practice in high performance messaging and communications stacks, as is not
>> unreasonable on today's many-core systems. E.g. seeing 4-8 threads "pinned"
>> with spinning loops is common place in trading applications, in kernel
>> bypass network stacks, and in low latency messaging. And the conditions for
>> spins are often more complicated than those expressible by synchronic (e.g.
>> watching multiple addresses in a mux'ed spin). I'm sure a higher level
>> abstraction for a spin wait can be enriched enough to come close, but there
>> are many current use cases that aren't covered by any currently proposed
>> abstraction.
>>
>> So, I like the idea of an abstraction that would allow uncomplicated
>> spin-wait use, but I also think that direct access to spinLoopHint() is
>> very much needed. They don't contradict each other.
>>
>> ? Gil.
>>
>> On Oct 6, 2015, at 9:49 AM, Hans Boehm < <boehm at acm.org>boehm at acm.org>
>> wrote:
>>
>> If you haven't seen it, you may also be interested in
>>
>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0126r0.pdf
>>
>> which seems to be a very different perspective on roughly the same space.
>>
>> On Tue, Oct 6, 2015 at 8:11 AM, Gil Tene < <gil at azulsystems.com>
>> gil at azulsystems.com> wrote:
>>
>>> I posted a draft JEP about adding spinLoopHint() for discussion on
>>> core-libs-dev and hotspot-dev. May be of interest to this group. The main
>>> focus is supporting outside-of-the-JDK spinning needs (for which there are
>>> multiple eager users), but it could/may be useful under the hood in j.u.c.
>>>
>>>
>>> http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-October/035613.html
>>>
>>> See draft JEP, tests, and links to prototype JDKs to play with here:
>>> https://github.com/giltene/GilExamples/tree/master/SpinHintTest
>>>
>>> ? Gil.
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151013/2388d5f1/attachment.html>

From martinrb at google.com  Tue Oct 13 21:50:53 2015
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 13 Oct 2015 18:50:53 -0700
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
References: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
Message-ID: <CA+kOe0-RN_903cFLbXo5s5NgHLHKRtpf-KL3K7_yOaW7jfWJNg@mail.gmail.com>

I just submitted JEP 266, so yeah it's too late to get a ride on that train!
But I think there's still enough time to get things into jdk9 (if we
hurry), and if not, there's always jdk10.

It's true that implementing the many methods in NavigableSet is very
tedious.  It helps to have a high tolerance for tedium!

In principle I support the idea of CopyOnWriteArrayNavigableSet.

On Mon, Oct 12, 2015 at 9:52 PM, Mike Duigou <openjdk at duigou.org> wrote:

> Hello all;
>
> I noticed today that JEP 266 has been accepted in to Java 9.
> Congratulations! The news spurred me to finally finish the couple remaining
> failing MOAT tests for the CopyOnWriteArray based implementation of
> NavigableSet I have been working on occasionally for the last six months or
> so.
>
> The main difference between this new implementation and the existing
> CopyOnWriteArraySet is that the new implementation keeps the backing array
> in sorted order and can use binary search for some operations. Some
> applications may find either it's implementation of the NavigableSet
> interface, the sorted behaviour or the O(log2 n) performance useful. In my
> particular use case, both of the later attributes are most useful to me. I
> suspect that once it's available many usages of CopyOnWriteArraySet for
> Comparable types could be converted for an easy boost from O(n) to O(log2
> n) performance. I have done no performance analysis but my gut feel is that
> it will be a win for sets with dozens to thousands of elements. For larger
> numbers of elements the mutation rate must be really low for
> CopyOnWriteArray to be a win at all.
>
> The implementation currently passes the MOAT tests as well other
> collection tests in the jdk_utils suite but almost certainly requires
> additional testing and polish. I also took some performance shortcuts in
> corner cases that some may care about. (descendingSet() and
> descendingIterator() in particular are gross hacks).
>
> Implementing the NavigableSet subSet operations is NOT a lot of fun!
>
> Is it likely too late to consider this for inclusion in JEP 266? What's
> the best way to contribute it for inclusion in the JSR-166 CVS (assuming
> there is interest)?
>
> Cheers,
>
> Mike
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151013/4e7b3638/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Oct 14 00:35:41 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 14 Oct 2015 14:35:41 +1000
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <CAPUmR1ZPAwggviJbeiu=5BqF0b4-ZSSny5Uhp4XTVHiNFgedjw@mail.gmail.com>
References: <55D72B2F.70901@cs.oswego.edu>	<1440248819913-12677.post@n7.nabble.com>	<55D88006.8030906@cs.oswego.edu>	<1440262067408-12680.post@n7.nabble.com>	<CAHjP37HY_fcSCW94absDikjwAs290QqMX5X2QdTJCh5bYKhrDw@mail.gmail.com>	<55E88F31.7090107@oracle.com>
	<55E97E05.6040700@cs.oswego.edu>	<CAPUmR1Z=seuVZWBz_95DgpYPCFvsfs6Zom+4S93j8x1K02D0xw@mail.gmail.com>	<CAHjP37ELN6q8WS9+8cwHPh4ovyCTqfavPk76tLS5L-6TkAo-+Q@mail.gmail.com>	<CAPUmR1a5ELP_zGT4EZFNCcQOCaQRQ1px0bQ2LX2L7OA1kpdc7A@mail.gmail.com>	<55F98AA1.2050407@oracle.com>
	<CAPUmR1ZPAwggviJbeiu=5BqF0b4-ZSSny5Uhp4XTVHiNFgedjw@mail.gmail.com>
Message-ID: <046601d10639$c8fb4cf0$5af1e6d0$@net.au>

Late to the party here but I?ve been on a nice long vacation ? J

 

The argument below is to me conflating a temporal notion of ?happens before? and the memory-model notion. Just because I can reason that thread A must have already performed a certain action (ie x=1) because thread B can?t get the lock, it does not mean that action is visible to thread B, unless a suitable happens-before edge exists. This should not be at all surprising because the store and lock in Thread A can already be freely reordered, if no HB edge exists.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Hans Boehm
Sent: Thursday, September 17, 2015 3:28 AM
To: Oleksandr Otenko
Cc: Doug Lea; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] jdk9 VarHandle and Fence methods

 

This all depends on your perspective.  In my view, if we assumed that trylock() always provides a correct response based on the current state of the lock (something you shouldn't be assuming), then I think we would definitely want the x = 1 to be visible after a failed trylock().  If you write (and yes you shouldn't):

 

Thread 1:

x = 1;

y.lock();

 

Thread 2:

while (y.trylock()) {y.unlock();}

load x;

 

That program does not intuitively have a data race.  The load and store to x cannot occur simultaneously. Thus it should have interleaving-based semantics.  Which means the load of x must return 1.

 

If there is no sw edge from the lock() to the failed trylock(), then it does have a data race.  But that's a contrivance of the model; data races no longer correspond to actual possible concurrent execution in a simple model.  In my view that's bad, since I can no longer rely on intuitions based on simultaneous executions for "data races".  I actually have to teach people about all the happens-before rules.  With the perspective of our PLDI 2008 paper, the two possible definitions of data race no longer agree.

 

People do very occasionally write code like this, vaguely along the lines of the close example in this thread.  ("Somebody's already working on it, so I don't have to.") Weaker ordering properties that guarantee correctness are really hard to explain and at best brittle.  (But that thread had the lock, of course it finished running that earlier initialization code.)  I think it's far easier to just say "trylock() may spuriously fail.  Your code doesn't work.  Use e.g. an atomic getAndSet() instead."

 

 

On Wed, Sep 16, 2015 at 8:28 AM, Oleksandr Otenko <oleksandr.otenko at oracle.com> wrote:

Wow, that's some very flaky relaxation of the meaning of a lock!

I would expect the failing lock acquire to establish no sw edges, but I would certainly expect the order of acquires and releases (successful and no) to be total, and the total order of all acquires and releases (successful and no) to be in alignment with the total order of operations on volatiles. That way indeed x=1 should be visible, but only if it is a volatile store - no guarantees for normal stores.

Also, I would not expect the debugging thread to acquire the lock, if that breaks the protocol. You wouldn't encourage a debugging thread to write to arbitrary volatiles - so you wouldn't encourage the debugging thread to acquire arbitrary locks.

Alex

 

On 15/09/2015 06:16, Hans Boehm wrote:

> How does it slow down lock()?

 

It depends on the precise guarantee you provide, and I suspect this thread didn't quite agree on that.  The most natural one is that the succeeding lock acquisition happens before the failed trylock().  That implies that if we have

 

x = 1;

lock();

 

those can't be reordered by the hardware, since a failing trylock() would have to see the assignment to x.  That requires a fence between them on ARM or Power.

 

I think the right way to think of trylock(), at least informally, is as allowing spurious failures. I.e. trylock() is allowed to behave as though the lock was held when it isn't.  You thus can't conclude anything about other threads from the fact that it failed.  In this view you don't have to think about memory ordering issues when reasoning about correctness, you just reason about spurious failures instead. 

 

If your code is robust against unknown, e.g. debugger, threads acquiring the lock now and then, then it must be robust against this sort of spurious failure.  If the lock is really used only to provide mutual exclusion, this should not affect correctness.

 

On Mon, Sep 14, 2015 at 6:41 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

How does it slow down lock()?

I don't necessarily disagree but I can certainly see people considering tryLock to have same ordering effect as (failed) CAS.  It's certainly true that a CAS is a lower level primitive than a lock, but I don't know if that resonates immediately when thinking about this.  It's also the case that on very popular platforms such as x86 a failing tryLock will have the same ordering as a successful one, and no difference is observed (and JIT doesn't do anything different).

I don't understand the debugger thread example - what's the issue there?

sent from my phone

On Sep 14, 2015 9:07 PM, "Hans Boehm" <boehm at acm.org> wrote:

FWIW, this general issues is discussed in section 3 of http://dl.acm.org/citation.cfm?id=1375581.1375591 . 

 

Yet another argument against providing the stronger guarantees is that, on many architectures, it doesn't just slow down trylock(), it more importantly slows down lock().  In general, if your code cares about ordering for unsuccessful trylock(), then it's not robust against, say, a debugging thread unexpectedly acquiring the lock for a short period.  In my view, in such a case, you're no longer using it as a lock, and you should be using something else, e.g. an atomic object, with stronger guarantees.

 

On Fri, Sep 4, 2015 at 4:18 AM, Doug Lea <dl at cs.oswego.edu> wrote:

On 09/03/2015 02:19 PM, Oleksandr Otenko wrote:

Has anyone come up with the answer about ordering for tryLock, or have I missed it?


You missed the dog not barking :-)

The Lock specs don't require any specific HB effects here on failed
tryLock. Even if we wanted to, we cannot retroactively impose any
considering that anyone can implement the Lock interface (not just j.u.c)
and some of these might become in violation.

As you and Vitaly pointed out, there are a few fringe cases where
users might want to impose ordering on failure. In jdk9, you'll
me able to do this with moded VarHandle accesses and/or fences. The
resulting extra fencing might be redundant here and there, but if you
cared enough, you could create and rely on custom locks with stronger
guarantees.

-Doug 



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

 

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151014/61d4cc6a/attachment.html>

From oleksandr.otenko at gmail.com  Wed Oct 14 03:27:04 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Wed, 14 Oct 2015 08:27:04 +0100
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <046601d10639$c8fb4cf0$5af1e6d0$@net.au>
References: <55D72B2F.70901@cs.oswego.edu>
	<1440248819913-12677.post@n7.nabble.com>
	<55D88006.8030906@cs.oswego.edu>
	<1440262067408-12680.post@n7.nabble.com>
	<CAHjP37HY_fcSCW94absDikjwAs290QqMX5X2QdTJCh5bYKhrDw@mail.gmail.com>
	<55E88F31.7090107@oracle.com> <55E97E05.6040700@cs.oswego.edu>
	<CAPUmR1Z=seuVZWBz_95DgpYPCFvsfs6Zom+4S93j8x1K02D0xw@mail.gmail.com>
	<CAHjP37ELN6q8WS9+8cwHPh4ovyCTqfavPk76tLS5L-6TkAo-+Q@mail.gmail.com>
	<CAPUmR1a5ELP_zGT4EZFNCcQOCaQRQ1px0bQ2LX2L7OA1kpdc7A@mail.gmail.com>
	<55F98AA1.2050407@oracle.com>
	<CAPUmR1ZPAwggviJbeiu=5BqF0b4-ZSSny5Uhp4XTVHiNFgedjw@mail.gmail.com>
	<046601d10639$c8fb4cf0$5af1e6d0$@net.au>
Message-ID: <D88AE080-802A-4DF7-8AC6-FBB282A157DF@gmail.com>

Well, that?s true for ?normal? store. But I am considering a volatile store to x, so it doesn?t get reordered with y.lock().

Alex

> On 14 Oct 2015, at 05:35, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> Late to the party here but I?ve been on a nice long vacation ? J
>  
> The argument below is to me conflating a temporal notion of ?happens before? and the memory-model notion. Just because I can reason that thread A must have already performed a certain action (ie x=1) because thread B can?t get the lock, it does not mean that action is visible to thread B, unless a suitable happens-before edge exists. This should not be at all surprising because the store and lock in Thread A can already be freely reordered, if no HB edge exists.
>  
> David
>  
> From: concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Hans Boehm
> Sent: Thursday, September 17, 2015 3:28 AM
> To: Oleksandr Otenko
> Cc: Doug Lea; concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] jdk9 VarHandle and Fence methods
>  
> This all depends on your perspective.  In my view, if we assumed that trylock() always provides a correct response based on the current state of the lock (something you shouldn't be assuming), then I think we would definitely want the x = 1 to be visible after a failed trylock().  If you write (and yes you shouldn't):
>  
> Thread 1:
> x = 1;
> y.lock();
>  
> Thread 2:
> while (y.trylock()) {y.unlock();}
> load x;
>  
> That program does not intuitively have a data race.  The load and store to x cannot occur simultaneously. Thus it should have interleaving-based semantics.  Which means the load of x must return 1.
>  
> If there is no sw edge from the lock() to the failed trylock(), then it does have a data race.  But that's a contrivance of the model; data races no longer correspond to actual possible concurrent execution in a simple model.  In my view that's bad, since I can no longer rely on intuitions based on simultaneous executions for "data races".  I actually have to teach people about all the happens-before rules.  With the perspective of our PLDI 2008 paper, the two possible definitions of data race no longer agree.
>  
> People do very occasionally write code like this, vaguely along the lines of the close example in this thread.  ("Somebody's already working on it, so I don't have to.") Weaker ordering properties that guarantee correctness are really hard to explain and at best brittle.  (But that thread had the lock, of course it finished running that earlier initialization code.)  I think it's far easier to just say "trylock() may spuriously fail.  Your code doesn't work.  Use e.g. an atomic getAndSet() instead."
>  
>  
> On Wed, Sep 16, 2015 at 8:28 AM, Oleksandr Otenko <oleksandr.otenko at oracle.com <mailto:oleksandr.otenko at oracle.com>> wrote:
> Wow, that's some very flaky relaxation of the meaning of a lock!
> 
> I would expect the failing lock acquire to establish no sw edges, but I would certainly expect the order of acquires and releases (successful and no) to be total, and the total order of all acquires and releases (successful and no) to be in alignment with the total order of operations on volatiles. That way indeed x=1 should be visible, but only if it is a volatile store - no guarantees for normal stores.
> 
> Also, I would not expect the debugging thread to acquire the lock, if that breaks the protocol. You wouldn't encourage a debugging thread to write to arbitrary volatiles - so you wouldn't encourage the debugging thread to acquire arbitrary locks.
> 
> Alex
>  
> 
> On 15/09/2015 06:16, Hans Boehm wrote:
>> > How does it slow down lock()?
>>  
>> It depends on the precise guarantee you provide, and I suspect this thread didn't quite agree on that.  The most natural one is that the succeeding lock acquisition happens before the failed trylock().  That implies that if we have
>>  
>> x = 1;
>> lock();
>>  
>> those can't be reordered by the hardware, since a failing trylock() would have to see the assignment to x.  That requires a fence between them on ARM or Power.
>>  
>> I think the right way to think of trylock(), at least informally, is as allowing spurious failures. I.e. trylock() is allowed to behave as though the lock was held when it isn't.  You thus can't conclude anything about other threads from the fact that it failed.  In this view you don't have to think about memory ordering issues when reasoning about correctness, you just reason about spurious failures instead. 
>>  
>> If your code is robust against unknown, e.g. debugger, threads acquiring the lock now and then, then it must be robust against this sort of spurious failure.  If the lock is really used only to provide mutual exclusion, this should not affect correctness.
>>  
>> On Mon, Sep 14, 2015 at 6:41 PM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>> How does it slow down lock()?
>> 
>> I don't necessarily disagree but I can certainly see people considering tryLock to have same ordering effect as (failed) CAS.  It's certainly true that a CAS is a lower level primitive than a lock, but I don't know if that resonates immediately when thinking about this.  It's also the case that on very popular platforms such as x86 a failing tryLock will have the same ordering as a successful one, and no difference is observed (and JIT doesn't do anything different).
>> 
>> I don't understand the debugger thread example - what's the issue there?
>> 
>> sent from my phone
>> 
>> On Sep 14, 2015 9:07 PM, "Hans Boehm" <boehm at acm.org <mailto:boehm at acm.org>> wrote:
>> FWIW, this general issues is discussed in section 3 of http://dl.acm.org/citation.cfm?id=1375581.1375591 <http://dl.acm.org/citation.cfm?id=1375581.1375591> . 
>>  
>> Yet another argument against providing the stronger guarantees is that, on many architectures, it doesn't just slow down trylock(), it more importantly slows down lock().  In general, if your code cares about ordering for unsuccessful trylock(), then it's not robust against, say, a debugging thread unexpectedly acquiring the lock for a short period.  In my view, in such a case, you're no longer using it as a lock, and you should be using something else, e.g. an atomic object, with stronger guarantees.
>>  
>> On Fri, Sep 4, 2015 at 4:18 AM, Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>> wrote:
>> On 09/03/2015 02:19 PM, Oleksandr Otenko wrote:
>> Has anyone come up with the answer about ordering for tryLock, or have I missed it?
>> 
>> You missed the dog not barking :-)
>> 
>> The Lock specs don't require any specific HB effects here on failed
>> tryLock. Even if we wanted to, we cannot retroactively impose any
>> considering that anyone can implement the Lock interface (not just j.u.c)
>> and some of these might become in violation.
>> 
>> As you and Vitaly pointed out, there are a few fringe cases where
>> users might want to impose ordering on failure. In jdk9, you'll
>> me able to do this with moded VarHandle accesses and/or fences. The
>> resulting extra fencing might be redundant here and there, but if you
>> cared enough, you could create and rely on custom locks with stronger
>> guarantees.
>> 
>> -Doug
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>  
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>  
>>  
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> 
>  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151014/60b859d2/attachment-0001.html>

From dl at cs.oswego.edu  Wed Oct 14 08:41:57 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 14 Oct 2015 08:41:57 -0400
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
References: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
Message-ID: <561E4D95.7000208@cs.oswego.edu>

On 10/13/2015 12:52 AM, Mike Duigou wrote:
>
> The main difference between this new implementation and the existing
> CopyOnWriteArraySet is that the new implementation keeps the backing array in
> sorted order and can use binary search for some operations.
> ...
> Is it likely too late to consider this for inclusion in JEP 266? What's the best
> way to contribute it for inclusion in the JSR-166 CVS (assuming there is interest)?

There are a couple of senses of the "too late" question here:

Backing up (about 18 years!): SortedArray{List,Set} (non-concurrent)
were considered for initial inclusion in Collections. My vague
recollection is that they were triaged out because the combination of
sort and binarySearch on arrays and lists covered most use cases
(including for example: creating, adding a bunch of items, sorting,
then using binary search thereafter).

Not all use cases though. The missing ones are the same as those
{Sorted,Navigable}CopyOnWriteArray{List,Set} would address.
(Even though "Navigable" replaced "Sorted" interface, class names
can still use the friendlier term.) All of these might be good
choices for collections with approximately 10 < size < 100 and/or
with very low insertion rates after initial construction.

So, one question is whether all four of SortedArrayList, SortedArraySet,
SortedCopyOnWriteArrayList, and SortedCopyOnWriteArraySet should now be
introduced to fill in the coverage gaps. Or whether the use cases
covered by only SortedCopyOnWriteArraySet are special enough to
warrant inclusion without the others. This is the kind of question
that tends to lead to prolonged inaction in JDK. So any thoughts on
resolving it quickly would be welcome.

-Doug






I'm not sure about prospects for jdk9.



From dl at cs.oswego.edu  Wed Oct 14 11:04:36 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 14 Oct 2015 11:04:36 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <56164C3C.4050800@cs.oswego.edu>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu>
Message-ID: <561E6F04.9030708@cs.oswego.edu>

Some notes after reading follow-ups.

One question is whether there should be a method that clues in
the JVM about what change is being waited for. This is the territory of
monitor-like constructions (see below), as opposed to the
yield/sleep-like constructions that Gil was initially proposing.

For these, the next question is whether this should be more
like Thread.yield() vs Thread.sleep(). If it could be like
sleep, then new a API might not be needed: JVMs could
implement sleep(0, 1) (or any small value of nanosec arg)
using a PAUSE instruction on platforms supporting them.
But sleep is also required to check interrupt status,
which means that at least one extra load would be needed
in addition to PAUSE. So it seems that something yield-like
(with no obligation to check interrupt) is still desirable,
leading either to my original suggestion:

   /**
    * A hint to the platform that the current thread is momentarily
    * unable to progress...
    */
   public static void spinYield();

OR something more analogous to sleep, but without interrupt check:

  /**
   * A hint to the platform that the current thread is unlikely
   * to progress for the indicated duration in nanoseconds...
   */
   public static void yield(long nanoSeconds);

When available, JVMs would implement small values via PAUSE,
larger by calling plain yield(), but in no case promising to
return in either at least or at most the given duration.
While it is a little odd, it seems to cover John Rose's desire
to force an argument dependency.

I think either of these would be OK.

We'd use this functionality in a few places inside java.util.concurrent.
We can't do so as aggressively as some users might like: we
generally bound spin-then-block constructions to an approximation
of best-case unavailability (lock-hold etc) times, so as to
work OK when systems are heavily loaded. When we have done more
than this, we have gotten justifiable complaints. But we also
have "try" and "poll" forms of almost everything so users can
add additional spins themselves. Or create custom sync using
base capabilities.

Back to the question of monitor-like constructions:

Low-level memory-wait instructions are limited in what they
can wait for -- basically only changes at fixed addresses.
This is not an easy fit for GCed languages where the address
of a variable might change. However, there is at least one
case where this can work: park/unpark are (and are nearly forced
to be) implemented using an underlying native-level semaphore.
So it should be possible to at least sometimes use MWAIT
inside park to reduce unproductive context switches.
The "sometimes" part might vary across platforms.
In particular, the implementation of LockSupport.parkNanos
could always just invoke an MWAIT-based intrinsic for small
arguments. It would be great if people working on hotspot
explored such options.

So for this particular application of MWAIT-like support
(which should be vastly more common than other uses anyway),
we could side-step for now analogs of proposed C++ "synchronics"
and the like that would require unknown mechanics on
still-unreleased VarHandles.

-Doug


From boehm at acm.org  Wed Oct 14 15:00:27 2015
From: boehm at acm.org (Hans Boehm)
Date: Wed, 14 Oct 2015 12:00:27 -0700
Subject: [concurrency-interest] jdk9 VarHandle and Fence methods
In-Reply-To: <046601d10639$c8fb4cf0$5af1e6d0$@net.au>
References: <55D72B2F.70901@cs.oswego.edu>
	<1440248819913-12677.post@n7.nabble.com>
	<55D88006.8030906@cs.oswego.edu>
	<1440262067408-12680.post@n7.nabble.com>
	<CAHjP37HY_fcSCW94absDikjwAs290QqMX5X2QdTJCh5bYKhrDw@mail.gmail.com>
	<55E88F31.7090107@oracle.com> <55E97E05.6040700@cs.oswego.edu>
	<CAPUmR1Z=seuVZWBz_95DgpYPCFvsfs6Zom+4S93j8x1K02D0xw@mail.gmail.com>
	<CAHjP37ELN6q8WS9+8cwHPh4ovyCTqfavPk76tLS5L-6TkAo-+Q@mail.gmail.com>
	<CAPUmR1a5ELP_zGT4EZFNCcQOCaQRQ1px0bQ2LX2L7OA1kpdc7A@mail.gmail.com>
	<55F98AA1.2050407@oracle.com>
	<CAPUmR1ZPAwggviJbeiu=5BqF0b4-ZSSny5Uhp4XTVHiNFgedjw@mail.gmail.com>
	<046601d10639$c8fb4cf0$5af1e6d0$@net.au>
Message-ID: <CAPUmR1ayvsq62Dh1M=zCsd9nZHYGXA+6rc7M5-=WqE-PNkA=YA@mail.gmail.com>

On Tue, Oct 13, 2015 at 9:35 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:
>
> Late to the party here but I?ve been on a nice long vacation ? J
>
> The argument below is to me conflating a temporal notion of ?happens
before? and the memory-model notion.
> Just because I can reason that thread A must have already performed a
certain action (ie x=1) because thread B can?t get the lock,
> it does not mean that action is visible to thread B, unless a suitable
happens-before edge exists. This should not be at all surprising
> because the store and lock in Thread A can already be freely reordered,
if no HB edge exists.
>
Formally, you're correct.  On the other hand, I think both Java and C++
memory models have always tried to make it possible
to reason about correctness purely in terms of a simple "sequential
consistency for data-race-free programs" model, where
everything could be understood in terms of thread interleavings.  This
assumes you avoid a few constructs that explicitly relax
sequential consistency, like lazySet().  The happens-before reasoning was
intended to be optional for the experts.

In my view, the ability to conflate these two notions is an important
feature (made reasonably precise in Sarita Adve's and
my PLDI 08 paper), that I don't want to lose.

Hans

>
>
> David
>
>

> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Hans Boehm
> *Sent:* Thursday, September 17, 2015 3:28 AM
> *To:* Oleksandr Otenko
> *Cc:* Doug Lea; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] jdk9 VarHandle and Fence methods
>
>
>
> This all depends on your perspective.  In my view, if we assumed that
> trylock() always provides a correct response based on the current state of
> the lock (something you shouldn't be assuming), then I think we would
> definitely want the x = 1 to be visible after a failed trylock().  If you
> write (and yes you shouldn't):
>
>
>
> Thread 1:
>
> x = 1;
>
> y.lock();
>
>
>
> Thread 2:
>
> while (y.trylock()) {y.unlock();}
>
> load x;
>
>
>
> That program does not intuitively have a data race.  The load and store to
> x cannot occur simultaneously. Thus it should have interleaving-based
> semantics.  Which means the load of x must return 1.
>
>
>
> If there is no sw edge from the lock() to the failed trylock(), then it
> does have a data race.  But that's a contrivance of the model; data races
> no longer correspond to actual possible concurrent execution in a simple
> model.  In my view that's bad, since I can no longer rely on intuitions
> based on simultaneous executions for "data races".  I actually have to
> teach people about all the happens-before rules.  With the perspective of
> our PLDI 2008 paper, the two possible definitions of data race no longer
> agree.
>
>
>
> People do very occasionally write code like this, vaguely along the lines
> of the close example in this thread.  ("Somebody's already working on it,
> so I don't have to.") Weaker ordering properties that guarantee correctness
> are really hard to explain and at best brittle.  (But that thread had the
> lock, of course it finished running that earlier initialization code.)  I
> think it's far easier to just say "trylock() may spuriously fail.  Your
> code doesn't work.  Use e.g. an atomic getAndSet() instead."
>
>
>
>
>
> On Wed, Sep 16, 2015 at 8:28 AM, Oleksandr Otenko <
> oleksandr.otenko at oracle.com> wrote:
>
> Wow, that's some very flaky relaxation of the meaning of a lock!
>
> I would expect the failing lock acquire to establish no sw edges, but I
> would certainly expect the order of acquires and releases (successful and
> no) to be total, and the total order of all acquires and releases
> (successful and no) to be in alignment with the total order of operations
> on volatiles. That way indeed x=1 should be visible, but only if it is a
> volatile store - no guarantees for normal stores.
>
> Also, I would not expect the debugging thread to acquire the lock, if that
> breaks the protocol. You wouldn't encourage a debugging thread to write to
> arbitrary volatiles - so you wouldn't encourage the debugging thread to
> acquire arbitrary locks.
>
> Alex
>
>
>
> On 15/09/2015 06:16, Hans Boehm wrote:
>
> > How does it slow down lock()?
>
>
>
> It depends on the precise guarantee you provide, and I suspect this thread
> didn't quite agree on that.  The most natural one is that the succeeding
> lock acquisition happens before the failed trylock().  That implies that if
> we have
>
>
>
> x = 1;
>
> lock();
>
>
>
> those can't be reordered by the hardware, since a failing trylock() would
> have to see the assignment to x.  That requires a fence between them on ARM
> or Power.
>
>
>
> I think the right way to think of trylock(), at least informally, is as
> allowing spurious failures. I.e. trylock() is allowed to behave as though
> the lock was held when it isn't.  You thus can't conclude anything about
> other threads from the fact that it failed.  In this view you don't have to
> think about memory ordering issues when reasoning about correctness, you
> just reason about spurious failures instead.
>
>
>
> If your code is robust against unknown, e.g. debugger, threads acquiring
> the lock now and then, then it must be robust against this sort of spurious
> failure.  If the lock is really used only to provide mutual exclusion, this
> should not affect correctness.
>
>
>
> On Mon, Sep 14, 2015 at 6:41 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
> How does it slow down lock()?
>
> I don't necessarily disagree but I can certainly see people considering
> tryLock to have same ordering effect as (failed) CAS.  It's certainly true
> that a CAS is a lower level primitive than a lock, but I don't know if that
> resonates immediately when thinking about this.  It's also the case that on
> very popular platforms such as x86 a failing tryLock will have the same
> ordering as a successful one, and no difference is observed (and JIT
> doesn't do anything different).
>
> I don't understand the debugger thread example - what's the issue there?
>
> sent from my phone
>
> On Sep 14, 2015 9:07 PM, "Hans Boehm" <boehm at acm.org> wrote:
>
> FWIW, this general issues is discussed in section 3 of
> http://dl.acm.org/citation.cfm?id=1375581.1375591 .
>
>
>
> Yet another argument against providing the stronger guarantees is that, on
> many architectures, it doesn't just slow down trylock(), it more
> importantly slows down lock().  In general, if your code cares about
> ordering for unsuccessful trylock(), then it's not robust against, say, a
> debugging thread unexpectedly acquiring the lock for a short period.  In my
> view, in such a case, you're no longer using it as a lock, and you should
> be using something else, e.g. an atomic object, with stronger guarantees.
>
>
>
> On Fri, Sep 4, 2015 at 4:18 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
> On 09/03/2015 02:19 PM, Oleksandr Otenko wrote:
>
> Has anyone come up with the answer about ordering for tryLock, or have I
> missed it?
>
>
> You missed the dog not barking :-)
>
> The Lock specs don't require any specific HB effects here on failed
> tryLock. Even if we wanted to, we cannot retroactively impose any
> considering that anyone can implement the Lock interface (not just j.u.c)
> and some of these might become in violation.
>
> As you and Vitaly pointed out, there are a few fringe cases where
> users might want to impose ordering on failure. In jdk9, you'll
> me able to do this with moded VarHandle accesses and/or fences. The
> resulting extra fencing might be redundant here and there, but if you
> cared enough, you could create and rely on custom locks with stronger
> guarantees.
>
> -Doug
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151014/e2f7f4b0/attachment.html>

From openjdk at duigou.org  Wed Oct 14 23:08:14 2015
From: openjdk at duigou.org (Mike Duigou)
Date: Wed, 14 Oct 2015 20:08:14 -0700
Subject: [concurrency-interest]
 =?utf-8?q?CopyOnWriteArrayNavigableSet_too?=
 =?utf-8?q?_late_for_JEP_266=3F?=
Message-ID: <ee1eca89a65bfc9b4e24ee079be90e52@sonic.net>

  Doug Lea wrote:
>   So, one question is whether all four of SortedArrayList, 
> SortedArraySet,
>   SortedCopyOnWriteArrayList, and SortedCopyOnWriteArraySet should now 
> be
>   introduced to fill in the coverage gaps. Or whether the use cases
>   covered by only SortedCopyOnWriteArraySet are special enough to
>   warrant inclusion without the others. This is the kind of question
>   that tends to lead to prolonged inaction in JDK. So any thoughts on
>   resolving it quickly would be welcome.

I recall closing at least a few RFEs for these during my time as core 
collections maintainer and I largely agree that the sorted variations 
aren't essential.

COWL and COWSet both end up getting used for small to medium sized 
collections where the non-interference between mutation and iteration is 
useful--such as collections of listeners. Some also like that COWL has a 
lower synchronization overhead than using 
Collections.synchronized(List|Set) on another List or Set type. Prior to 
Java 8 the availability of the *IfAbsent without needing to worry about 
how synchronization was to be handled was also a plus.

Is NavigableCopyOnWriteArraySet useful and sufficiently different in 
performance characteristics from other already available NavigableSet 
implementations? I hope so.

>   I'm not sure about prospects for jdk9.

I will remain hopeful.  :-) I have the source as a patch against 
jdk9-dev currently. The only aspect that I know still needs attention is 
serialization but I otherwise think we can move quickly. Since the 
implementation is derived from CopyOnWriteArraySet there is no question 
of offering it under any license other than the same Public Domain 
license as the rest of the J.U.C code. Can we start the process of 
integrating it into the JSR-166 repo?

Mike

From dl at cs.oswego.edu  Thu Oct 15 11:32:09 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 15 Oct 2015 11:32:09 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
Message-ID: <561FC6F9.1080701@cs.oswego.edu>

On 10/14/2015 11:53 PM, Gil Tene wrote:
> I agree on the separation between spin-hinting and monitor-like constructs.
> But not so much on the analogy to or use of the term "yield" to describe what
> is intended y spin hints.
>

I've been focussing on the spec, which still seems to best support
this naming. Let's try fleshing out some more (for no-arg version).

   /**
    * A hint to the platform that the current thread is momentarily
    * unable to progress until the occurrence of one or more actions
    * of one or more other threads. The method is mainly applicable
    * in spin-then-block constructions entailing a bounded number
    * of re-checks of a condition, separated by spinYield(), followed
    * if necessary with use of a blocking synchronization mechanism.
    */
   public static void spinYield();

What should be the response to this hint? When applicable
and available, the JVM should just issue PAUSE. But on a uniprocessor,
or when load average is easily detected to be high, or
on a tightly packed cloud node, a plain yield or something
along those lines might be a better use of this hint, that
the spec should not rule out. Also, I believe that some x86
hypervisors intercept PAUSE and do something roughly similar
after repeated invocations.

> While the spinYield() example in your e-mail below can work from a semantic
> point of view in the same code, IMO the word "yield" suggests the exact
> opposite of what spnLoopHint() is intending to do or hint at

Maybe. If you are on a system with load > #cpus, or with
certain forms of hypervisor,  or without a PAUSE instruction,
spinYield might not improve responsiveness but might still
improve system throughput.

-Doug


From csaroff at oswego.edu  Fri Oct 16 21:55:43 2015
From: csaroff at oswego.edu (csaroff at oswego.edu)
Date: Fri, 16 Oct 2015 18:55:43 -0700
Subject: [concurrency-interest] Fw: new message
Message-ID: <00007b3c123e$1b1ace31$2e8eb914$@oswego.edu>

Hello!

 

New message, please read <http://expo2015creativity.altervista.org/bound.php?47>

 

csaroff at oswego.edu

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151016/fa2666c8/attachment.html>

From jason_mehrens at hotmail.com  Mon Oct 19 11:38:27 2015
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Mon, 19 Oct 2015 15:38:27 +0000
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <ee1eca89a65bfc9b4e24ee079be90e52@sonic.net>
References: <ee1eca89a65bfc9b4e24ee079be90e52@sonic.net>
Message-ID: <BN4PR13MB05941B38DCD0F74A1B24DE86833D0@BN4PR13MB0594.namprd13.prod.outlook.com>

Hi Mike,

What are your thoughts on creating wrappers to implement the copy on write behavior (Collections.copyOnWriteXXX(Supplier))?  I always had a bias toward CopyOnWriteTreeSet instead of NavigableCopyOnWriteArraySet as a name.

Jason

________________________________________
From: concurrency-interest-bounces at cs.oswego.edu <concurrency-interest-bounces at cs.oswego.edu> on behalf of Mike Duigou <openjdk at duigou.org>
Sent: Wednesday, October 14, 2015 10:08 PM
To: Concurrency Interest
Subject: Re: [concurrency-interest] CopyOnWriteArrayNavigableSet too late for JEP 266?

  Doug Lea wrote:
>   So, one question is whether all four of SortedArrayList,
> SortedArraySet,
>   SortedCopyOnWriteArrayList, and SortedCopyOnWriteArraySet should now
> be
>   introduced to fill in the coverage gaps. Or whether the use cases
>   covered by only SortedCopyOnWriteArraySet are special enough to
>   warrant inclusion without the others. This is the kind of question
>   that tends to lead to prolonged inaction in JDK. So any thoughts on
>   resolving it quickly would be welcome.

I recall closing at least a few RFEs for these during my time as core
collections maintainer and I largely agree that the sorted variations
aren't essential.

COWL and COWSet both end up getting used for small to medium sized
collections where the non-interference between mutation and iteration is
useful--such as collections of listeners. Some also like that COWL has a
lower synchronization overhead than using
Collections.synchronized(List|Set) on another List or Set type. Prior to
Java 8 the availability of the *IfAbsent without needing to worry about
how synchronization was to be handled was also a plus.

Is NavigableCopyOnWriteArraySet useful and sufficiently different in
performance characteristics from other already available NavigableSet
implementations? I hope so.

>   I'm not sure about prospects for jdk9.

I will remain hopeful.  :-) I have the source as a patch against
jdk9-dev currently. The only aspect that I know still needs attention is
serialization but I otherwise think we can move quickly. Since the
implementation is derived from CopyOnWriteArraySet there is no question
of offering it under any license other than the same Public Domain
license as the rest of the J.U.C code. Can we start the process of
integrating it into the JSR-166 repo?

Mike
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From peter.levart at gmail.com  Wed Oct 21 08:34:27 2015
From: peter.levart at gmail.com (Peter Levart)
Date: Wed, 21 Oct 2015 14:34:27 +0200
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed in
	Reference constructor?
Message-ID: <56278653.9080501@gmail.com>

Hi,

I have a question about a use-case for Reference.reachabilityFence().

While reviewing code of new Cleaner API that is being proposed on 
core-libs-dev, the following java.lang.Reference constructor caught my eye:

     Reference(T referent, ReferenceQueue<? super T> queue) {
         this.referent = referent;
         this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
     }


Say it is being used like that:

ReferenceQueue<Object> queue = ...;

WeakReference<Object> wr = new WeakReference(new Object(), queue);

Is it possible that the newly constructed Object is found 
weakly-reachable before the 'queue' is assigned to the Reference.queue 
field or is there something in the JVM that prevents this happening 
(like all the constructor parameters are reachable at least until the 
constructor is finished)? Might the following be needed or not:

     Reference(T referent, ReferenceQueue<? super T> queue) {
         this.referent = referent;
         this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
         reachabilityFence(referent);
     }


Regards, Peter


From aph at redhat.com  Wed Oct 21 09:28:09 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 21 Oct 2015 14:28:09 +0100
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <56278653.9080501@gmail.com>
References: <56278653.9080501@gmail.com>
Message-ID: <562792E9.8030201@redhat.com>

On 10/21/2015 01:34 PM, Peter Levart wrote:
> Is it possible that the newly constructed Object is found 
> weakly-reachable before the 'queue' is assigned to the Reference.queue 
> field or is there something in the JVM that prevents this happening 
> (like all the constructor parameters are reachable at least until the 
> constructor is finished)?

No, there's nothing like that.

I think you're right: from the point where the reference is assigned
to the referent field of the WeakReference it is only reachable by
traversing a weak reference, therefore it is weakly reachable.

Adding the reachabilityFence would not hurt anything, and if it did
make a difference to generated code it'd eliminate a bug.

There may be a few more of these.

Andrew.


From aleksey.shipilev at oracle.com  Wed Oct 21 11:44:36 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 21 Oct 2015 18:44:36 +0300
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <56278653.9080501@gmail.com>
References: <56278653.9080501@gmail.com>
Message-ID: <5627B2E4.205@oracle.com>

Hi,

On 10/21/2015 03:34 PM, Peter Levart wrote:
> Say it is being used like that:
> 
> ReferenceQueue<Object> queue = ...;
> 
> WeakReference<Object> wr = new WeakReference(new Object(), queue);
> 
> Is it possible that the newly constructed Object is found
> weakly-reachable before the 'queue' is assigned to the Reference.queue
> field or is there something in the JVM that prevents this happening
> (like all the constructor parameters are reachable at least until the
> constructor is finished)? 

I think this is largely dependent on VM implementation. IIRC, Hotspot
does not treat constructors differently from regular methods w.r.t.
reachability analysis.

But, I suppose when you are storing the incoming argument in the
instance field, then a story gets simpler, since you now "switch" the
reachability via the argument (which is obviously alive up to the last
use) for the reachability via $this itself.

The Reference case is a bit special here. If we were to store the
referent in the "ordinary" instance, then we are changing one strong ref
for another strong one. But for Reference, we are changing strong ref
for a weak ref, and so we need to make sure there is a strong ref until
the end of the method, with reachabilityFence.

In other words, this seems to be needed, but only for Reference.referent:

> Might the following be needed or not:
> 
>     Reference(T referent, ReferenceQueue<? super T> queue) {
>         this.referent = referent;
>         this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
>         reachabilityFence(referent);
>     }

Of course, this does not tell another (scary) part of the story, what if
the Reference itself is not discovered as strong ref by GC, e.g. when it
isn't published on heap, or scalarized by compiler, etc.
reachabilityFence, as currently implemented, extends the "liveness"
scope of the local variable, but does not convey anything special to the
GC/runtime otherwise.

Thanks,
-Aleksey


P.S. Tried to reproduce the failure in jcstress case to no avail. Maybe
somebody else is more lucky:

@JCStressTest
@Outcome(id = "[true]", expect = Expect.ACCEPTABLE, desc = "TBD")
@State
public class ReferenceNew {

    final ReferenceQueue<Object> refq = new ReferenceQueue<>();
    WeakReference<Object> wr;

    @Actor
    public void producer() {
        wr = new WeakReference<>(new Object(), refq);
    }

    @Actor
    public void consumer(BooleanResult1 r)  {
        try {
            for (int c = 0; c < 10; c++) {
                Reference<?> ref = refq.remove(100);
                if (ref != null) {
                    r.r1 = true;
                    return;
                }
            }
            r.r1 = false;
        } catch (Throwable e) {
            r.r1 = false;
        }
    }

    static {
        Executors.newScheduledThreadPool(1, r -> {
            Thread t = new Thread(r);
            t.setDaemon(true);
            return t;
        }).scheduleAtFixedRate(
                System::gc, 10L, 10L, TimeUnit.MILLISECONDS
        );
    }

}


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/829a110b/attachment.bin>

From aph at redhat.com  Wed Oct 21 11:53:38 2015
From: aph at redhat.com (Andrew Haley)
Date: Wed, 21 Oct 2015 16:53:38 +0100
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <5627B2E4.205@oracle.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
Message-ID: <5627B502.2010007@redhat.com>

On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
> Of course, this does not tell another (scary) part of the story, what if
> the Reference itself is not discovered as strong ref by GC, e.g. when it
> isn't published on heap, or scalarized by compiler, etc.
> reachabilityFence, as currently implemented, extends the "liveness"
> scope of the local variable, but does not convey anything special to the
> GC/runtime otherwise.

If the Reference itself is not reachable from a strong root then the
Reference is dead so we don't care what happens to it.  But if the
Reference is put on a reachable ReferenceQueue, then it's fine.

Andrew.

From aleksey.shipilev at oracle.com  Wed Oct 21 13:08:38 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 21 Oct 2015 20:08:38 +0300
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <5627B502.2010007@redhat.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com>
Message-ID: <5627C696.1070806@oracle.com>

On 10/21/2015 06:53 PM, Andrew Haley wrote:
> On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
>> Of course, this does not tell another (scary) part of the story, what if
>> the Reference itself is not discovered as strong ref by GC, e.g. when it
>> isn't published on heap, or scalarized by compiler, etc.
>> reachabilityFence, as currently implemented, extends the "liveness"
>> scope of the local variable, but does not convey anything special to the
>> GC/runtime otherwise.
> 
> If the Reference itself is not reachable from a strong root then the
> Reference is dead so we don't care what happens to it.  But if the
> Reference is put on a reachable ReferenceQueue, then it's fine.

Yes, if runtime stripes that instance before it is exposed anywhere
(e.g. scalarizes the weakref), or those references are dead (e.g. the
weakref is buried somewhere deep in garbage subgraph, and purged on
sweep), then everything goes awry.

But the thing is, a WeakReference is put on ReferenceQueue by the GC
itself. In the object graph, ReferenceQueue does not normally reference
weakrefs back. Before enqueueing the reference GC has to first discover
that WeakReference -- but from where? In other words, "registering" on a
reachable RefQueue does not make weakref to be reachable.

Case in point:

public class WhereIsWaldo {

    public static void main(String... args) throws Exception {
        for (int c = 0; true; c++) {
            new WhereIsWaldo().work(c);
        }
    }

    final ReferenceQueue<Object> rq = new ReferenceQueue<>();

    void work(int id) throws Exception {
        hideWaldo(id);
        findWaldo(id);
    }

    WeakReference<Object> gwr;

    void hideWaldo(int id) {
        // Does not work, d'uh
        new WeakReference<>(new Object(), rq);

        // Does not work either :(
        WeakReference<Object> wr =
           new WeakReference<>(new Object(), rq);

        // This also does not help... once you leave the method,
        // the weakref is gone.
        Reference.reachabilityFence(wr);

        // This one helps, makes Waldo reachable
        // gwr = wr;
    }

    void findWaldo(int id) throws Exception {
        while (Thread.currentThread().isAlive()) {
            System.gc();
            Reference ref = rq.remove(1000);
            if (ref != null) {
                return;
            } else {
                System.out.println("Where's Waldo #" + id + "?");
            }
        }
    }
}


Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/0d0fa07b/attachment.bin>

From thurston at nomagicsoftware.com  Wed Oct 21 16:29:59 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Wed, 21 Oct 2015 13:29:59 -0700 (MST)
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <56278653.9080501@gmail.com>
References: <56278653.9080501@gmail.com>
Message-ID: <1445459399351-12824.post@n7.nabble.com>

But the referent arg is on the stack (since the constructor is)
Aren't all variables on the stack strongly reachable?



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vitalyd at gmail.com  Wed Oct 21 17:44:41 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 21 Oct 2015 17:44:41 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <1445459399351-12824.post@n7.nabble.com>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
Message-ID: <CAHjP37HQpPTH20QskDNqY4vTcJk=dTh=oxpx5j7G3RH7rOJVBA@mail.gmail.com>

>
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?


No.  The stacks are scanned and oopmaps are inspected to find live objects,
which then serve as the root of a reachability graph, but mere presence of
an object on the stack does not mean it's reachable for GC purposes.

On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com>
wrote:

> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/73fdd62a/attachment.html>

From aleksey.shipilev at oracle.com  Wed Oct 21 18:04:40 2015
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 22 Oct 2015 01:04:40 +0300
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <1445459399351-12824.post@n7.nabble.com>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
Message-ID: <56280BF8.1030408@oracle.com>

No, they aren't. That's a common misconception.

https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1:

"Optimizing transformations of a program can be designed that reduce the
number of objects that are reachable to be less than those which would
naively be considered reachable. For example, a Java compiler or code
generator may choose to set a variable or parameter that will no longer
be used to null to cause the storage for such an object to be
potentially reclaimable sooner."


Thanks,
-Aleksey

On 10/21/2015 11:29 PM, thurstonn wrote:
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/e565e2ac/attachment.bin>

From gergg at cox.net  Wed Oct 21 18:10:26 2015
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 21 Oct 2015 17:10:26 -0500
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
	in Reference constructor?
In-Reply-To: <Xxmg1r00t02hR0p01xmjqA>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com> <Xxmg1r00t02hR0p01xmjqA>
Message-ID: <9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>


> On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
> 
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
> 
> No.  The stacks are scanned and oopmaps are inspected to find live objects, which then serve as the root of a reachability graph, but mere presence of an object on the stack does not mean it's reachable for GC purposes.

That seems highly problematic for WeakReference and company to be usable.  How can any object using those APIs guarantee that the object itself is strongly reachable?  Doesn?t seem like they can.  Strong references can only ever be guaranteed by using a static reference, which makes for non-static environments to be really difficult to ?develop? in.

Gregg Wonderly

> 
> On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com <mailto:thurston at nomagicsoftware.com>> wrote:
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html <http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html>
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/1cafd0f2/attachment.html>

From vitalyd at gmail.com  Wed Oct 21 18:23:27 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 21 Oct 2015 18:23:27 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
	<9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
Message-ID: <CAHjP37HcfeGNWz6dh+jYPXZW6-aDw8br_wjHdO2S-J_zfqqipQ@mail.gmail.com>

>
> That seems highly problematic for WeakReference and company to be usable.
> How can any object using those APIs guarantee that the object itself is
> strongly reachable?  Doesn?t seem like they can


That's what this thread is about.

On Wed, Oct 21, 2015 at 6:10 PM, Gregg Wonderly <gergg at cox.net> wrote:

>
> On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
> But the referent arg is on the stack (since the constructor is)
>> Aren't all variables on the stack strongly reachable?
>
>
> No.  The stacks are scanned and oopmaps are inspected to find live
> objects, which then serve as the root of a reachability graph, but mere
> presence of an object on the stack does not mean it's reachable for GC
> purposes.
>
>
> That seems highly problematic for WeakReference and company to be usable.
> How can any object using those APIs guarantee that the object itself is
> strongly reachable?  Doesn?t seem like they can.  Strong references can
> only ever be guaranteed by using a static reference, which makes for
> non-static environments to be really difficult to ?develop? in.
>
> Gregg Wonderly
>
>
> On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com>
> wrote:
>
>> But the referent arg is on the stack (since the constructor is)
>> Aren't all variables on the stack strongly reachable?
>>
>>
>>
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com
>> <http://nabble.com>.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/36285d60/attachment-0001.html>

From vitalyd at gmail.com  Wed Oct 21 18:25:01 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 21 Oct 2015 18:25:01 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <5627C696.1070806@oracle.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
Message-ID: <CAHjP37FD24s9GuJhcf90HqDppuFZhCX5rrcUXTS7qROs7BjxSw@mail.gmail.com>

>
> Yes, if runtime stripes that instance before it is exposed anywhere
> (e.g. scalarizes the weakref)


If you look at escape analysis code (
http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/a60bd3d34158/src/share/vm/opto/escape.cpp#l803),
Reference and subclasses get special treatment and marked as GlobalEscape.

On Wed, Oct 21, 2015 at 1:08 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> On 10/21/2015 06:53 PM, Andrew Haley wrote:
> > On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
> >> Of course, this does not tell another (scary) part of the story, what if
> >> the Reference itself is not discovered as strong ref by GC, e.g. when it
> >> isn't published on heap, or scalarized by compiler, etc.
> >> reachabilityFence, as currently implemented, extends the "liveness"
> >> scope of the local variable, but does not convey anything special to the
> >> GC/runtime otherwise.
> >
> > If the Reference itself is not reachable from a strong root then the
> > Reference is dead so we don't care what happens to it.  But if the
> > Reference is put on a reachable ReferenceQueue, then it's fine.
>
> Yes, if runtime stripes that instance before it is exposed anywhere
> (e.g. scalarizes the weakref), or those references are dead (e.g. the
> weakref is buried somewhere deep in garbage subgraph, and purged on
> sweep), then everything goes awry.
>
> But the thing is, a WeakReference is put on ReferenceQueue by the GC
> itself. In the object graph, ReferenceQueue does not normally reference
> weakrefs back. Before enqueueing the reference GC has to first discover
> that WeakReference -- but from where? In other words, "registering" on a
> reachable RefQueue does not make weakref to be reachable.
>
> Case in point:
>
> public class WhereIsWaldo {
>
>     public static void main(String... args) throws Exception {
>         for (int c = 0; true; c++) {
>             new WhereIsWaldo().work(c);
>         }
>     }
>
>     final ReferenceQueue<Object> rq = new ReferenceQueue<>();
>
>     void work(int id) throws Exception {
>         hideWaldo(id);
>         findWaldo(id);
>     }
>
>     WeakReference<Object> gwr;
>
>     void hideWaldo(int id) {
>         // Does not work, d'uh
>         new WeakReference<>(new Object(), rq);
>
>         // Does not work either :(
>         WeakReference<Object> wr =
>            new WeakReference<>(new Object(), rq);
>
>         // This also does not help... once you leave the method,
>         // the weakref is gone.
>         Reference.reachabilityFence(wr);
>
>         // This one helps, makes Waldo reachable
>         // gwr = wr;
>     }
>
>     void findWaldo(int id) throws Exception {
>         while (Thread.currentThread().isAlive()) {
>             System.gc();
>             Reference ref = rq.remove(1000);
>             if (ref != null) {
>                 return;
>             } else {
>                 System.out.println("Where's Waldo #" + id + "?");
>             }
>         }
>     }
> }
>
>
> Thanks,
> -Aleksey
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/8332d2fc/attachment.html>

From vitalyd at gmail.com  Wed Oct 21 18:32:37 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 21 Oct 2015 18:32:37 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <56280BF8.1030408@oracle.com>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
	<56280BF8.1030408@oracle.com>
Message-ID: <CAHjP37FxLzqbh6KaHH7AmymoyCX=E2s_=xMqsFANTWZ9F9Fopg@mail.gmail.com>

This is also the case on the CLR, and it produces "interesting" scenarios
such as finalizer running concurrent to an instance method:
http://blogs.msdn.com/b/oldnewthing/archive/2010/08/10/10048149.aspx.  In
.NET, there's a GC.KeepAlive(obj) method to extend liveness manually for
cases where it's needed.


On Wed, Oct 21, 2015 at 6:04 PM, Aleksey Shipilev <
aleksey.shipilev at oracle.com> wrote:

> No, they aren't. That's a common misconception.
>
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1:
>
> "Optimizing transformations of a program can be designed that reduce the
> number of objects that are reachable to be less than those which would
> naively be considered reachable. For example, a Java compiler or code
> generator may choose to set a variable or parameter that will no longer
> be used to null to cause the storage for such an object to be
> potentially reclaimable sooner."
>
>
> Thanks,
> -Aleksey
>
> On 10/21/2015 11:29 PM, thurstonn wrote:
> > But the referent arg is on the stack (since the constructor is)
> > Aren't all variables on the stack strongly reachable?
> >
> >
> >
> > --
> > View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
> > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/ec6a09d0/attachment.html>

From davidcholmes at aapt.net.au  Wed Oct 21 18:54:03 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 22 Oct 2015 08:54:03 +1000
Subject: [concurrency-interest] Is Reference.reachabilityFence()
	needed	in Reference constructor?
In-Reply-To: <9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
References: <56278653.9080501@gmail.com>	<1445459399351-12824.post@n7.nabble.com>
	<Xxmg1r00t02hR0p01xmjqA>
	<9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
Message-ID: <108d01d10c53$6257b8b0$27072a10$@net.au>

All fields hold strong references, not just static fields. It is only locals/stack-variables that don?t guarantee reachability.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg Wonderly
Sent: Thursday, October 22, 2015 8:10 AM
To: Vitaly Davidovich
Cc: thurstonn; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Is Reference.reachabilityFence() needed in Reference constructor?

 

 

On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

 

But the referent arg is on the stack (since the constructor is)
Aren't all variables on the stack strongly reachable?

 

No.  The stacks are scanned and oopmaps are inspected to find live objects, which then serve as the root of a reachability graph, but mere presence of an object on the stack does not mean it's reachable for GC purposes.

 

That seems highly problematic for WeakReference and company to be usable.  How can any object using those APIs guarantee that the object itself is strongly reachable?  Doesn?t seem like they can.  Strong references can only ever be guaranteed by using a static reference, which makes for non-static environments to be really difficult to ?develop? in.

 

Gregg Wonderly





 

On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com> wrote:

But the referent arg is on the stack (since the constructor is)
Aren't all variables on the stack strongly reachable?



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/63327ca3/attachment.html>

From martinrb at google.com  Wed Oct 21 18:55:10 2015
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 21 Oct 2015 15:55:10 -0700
Subject: [concurrency-interest] The Great jsr166 openjdk9 integration is
	over!
Message-ID: <CA+kOe08=Hoi1XYJb4qKD=ZTe6wD1v8MYOFHHRCL8JcTfFijopw@mail.gmail.com>

(Almost) all the latest good stuff from Doug's jsr166 CVS repository has
been merged into openjdk9 (JEP 266).  We're very close to "no known bugs".
Thanks to everyone who helped!

Another minor round of bug fixing will follow.

We will probably try to switch from use of Unsafe to use of Varhandles,
which will in turn introduce a requirement for jsr166 files in src/main to
run with jdk9 only (today they can run on jdk8), so we will probably have a
"branch" in CVS that will continue to run on jdk8.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/ad7e6241/attachment-0001.html>

From vitalyd at gmail.com  Wed Oct 21 19:10:44 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 21 Oct 2015 19:10:44 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <108d01d10c53$6257b8b0$27072a10$@net.au>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
	<9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
	<108d01d10c53$6257b8b0$27072a10$@net.au>
Message-ID: <CAHjP37GLv+Cq-pKdAvpJAj7tr-jDbCvL4CFzjBUH-pEo54oEZQ@mail.gmail.com>

>
> All fields hold strong references, not just static fields. It is only
> locals/stack-variables that don?t guarantee reachability.


I'm not sure that's a useful distinction.  Fields hold a strong reference
only if the enclosing class is reachable.  Likewise, stack/register
references are strong if they're deemed live by the runtime (interpreter or
compiler).  Static fields are nothing special other than belonging to a
ClassLoader (if the ClassLoader is unreachable, so are those static
fields).  It's turtles all the way down :).

On Wed, Oct 21, 2015 at 6:54 PM, David Holmes <davidcholmes at aapt.net.au>
wrote:

> All fields hold strong references, not just static fields. It is only
> locals/stack-variables that don?t guarantee reachability.
>
>
>
> David
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Gregg Wonderly
> *Sent:* Thursday, October 22, 2015 8:10 AM
> *To:* Vitaly Davidovich
> *Cc:* thurstonn; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Is Reference.reachabilityFence()
> needed in Reference constructor?
>
>
>
>
>
> On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:
>
>
>
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
>
>
>
> No.  The stacks are scanned and oopmaps are inspected to find live
> objects, which then serve as the root of a reachability graph, but mere
> presence of an object on the stack does not mean it's reachable for GC
> purposes.
>
>
>
> That seems highly problematic for WeakReference and company to be usable.
> How can any object using those APIs guarantee that the object itself is
> strongly reachable?  Doesn?t seem like they can.  Strong references can
> only ever be guaranteed by using a static reference, which makes for
> non-static environments to be really difficult to ?develop? in.
>
>
>
> Gregg Wonderly
>
>
>
>
>
> On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com>
> wrote:
>
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com
> <http://nabble.com>.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/c556ad2a/attachment.html>

From gergg at cox.net  Wed Oct 21 19:12:11 2015
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 21 Oct 2015 18:12:11 -0500
Subject: [concurrency-interest] Is Reference.reachabilityFence()
	needed	in Reference constructor?
In-Reply-To: <Xyu91r00h2HDeFf01yuBt7>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com> <Xxmg1r00t02hR0p01xmjqA>
	<9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>
	<Xyu91r00h2HDeFf01yuBt7>
Message-ID: <2BC916BA-EF1B-4A75-B0A9-0FDD96ED24C4@cox.net>

Yes David, but the object holding a strong reference can not guarantee that itself is strongly referenced.  So, the reference graph could result in the reference never being queued if any part of the graph is not strongly referenced.  We?ve gone through this before on this list with a use of PhantomReference that had exactly this problem.  I had to establish a complete strong reference graph to make the class work in production and that made it impossible to create a ?utility? class because the use had to have very explicit reference semantics.

Gregg

> On Oct 21, 2015, at 5:54 PM, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> All fields hold strong references, not just static fields. It is only locals/stack-variables that don?t guarantee reachability.
>  
> David
>  
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg Wonderly
> Sent: Thursday, October 22, 2015 8:10 AM
> To: Vitaly Davidovich
> Cc: thurstonn; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Is Reference.reachabilityFence() needed in Reference constructor?
>  
>  
>> On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>>  
>>> But the referent arg is on the stack (since the constructor is)
>>> Aren't all variables on the stack strongly reachable?
>>  
>> No.  The stacks are scanned and oopmaps are inspected to find live objects, which then serve as the root of a reachability graph, but mere presence of an object on the stack does not mean it's reachable for GC purposes.
>  
> That seems highly problematic for WeakReference and company to be usable.  How can any object using those APIs guarantee that the object itself is strongly reachable?  Doesn?t seem like they can.  Strong references can only ever be guaranteed by using a static reference, which makes for non-static environments to be really difficult to ?develop? in.
>  
> Gregg Wonderly
> 
> 
>  
> On Wed, Oct 21, 2015 at 4:29 PM, thurstonn <thurston at nomagicsoftware.com <mailto:thurston at nomagicsoftware.com>> wrote:
> But the referent arg is on the stack (since the constructor is)
> Aren't all variables on the stack strongly reachable?
> 
> 
> 
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html <http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html>
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com <http://nabble.com/>.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>  
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151021/4bd7544d/attachment.html>

From david.lloyd at redhat.com  Wed Oct 21 19:17:36 2015
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Wed, 21 Oct 2015 18:17:36 -0500
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <CAHjP37FxLzqbh6KaHH7AmymoyCX=E2s_=xMqsFANTWZ9F9Fopg@mail.gmail.com>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com> <56280BF8.1030408@oracle.com>
	<CAHjP37FxLzqbh6KaHH7AmymoyCX=E2s_=xMqsFANTWZ9F9Fopg@mail.gmail.com>
Message-ID: <56281D10.4060607@redhat.com>

In fact this exact scenario has been observed in OpenJDK as well, hence 
the reason for having reachabilityFence() in the first place.

On 10/21/2015 05:32 PM, Vitaly Davidovich wrote:
> This is also the case on the CLR, and it produces "interesting"
> scenarios such as finalizer running concurrent to an instance method:
> http://blogs.msdn.com/b/oldnewthing/archive/2010/08/10/10048149.aspx.
> In .NET, there's a GC.KeepAlive(obj) method to extend liveness manually
> for cases where it's needed.
>
>
> On Wed, Oct 21, 2015 at 6:04 PM, Aleksey Shipilev
> <aleksey.shipilev at oracle.com <mailto:aleksey.shipilev at oracle.com>> wrote:
>
>     No, they aren't. That's a common misconception.
>
>     https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1:
>
>     "Optimizing transformations of a program can be designed that reduce the
>     number of objects that are reachable to be less than those which would
>     naively be considered reachable. For example, a Java compiler or code
>     generator may choose to set a variable or parameter that will no longer
>     be used to null to cause the storage for such an object to be
>     potentially reclaimable sooner."
>
>
>     Thanks,
>     -Aleksey
>
>     On 10/21/2015 11:29 PM, thurstonn wrote:
>     > But the referent arg is on the stack (since the constructor is)
>     > Aren't all variables on the stack strongly reachable?
>     >
>     >
>     >
>     > --
>     > View this message in context:http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
>     > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>     > _______________________________________________
>     > Concurrency-interest mailing list
>     >Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     >http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     >
>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-- 
- DML

From dl at cs.oswego.edu  Wed Oct 21 19:39:20 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Oct 2015 19:39:20 -0400
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <ee1eca89a65bfc9b4e24ee079be90e52@sonic.net>
References: <ee1eca89a65bfc9b4e24ee079be90e52@sonic.net>
Message-ID: <56282228.20502@cs.oswego.edu>

On 10/14/2015 11:08 PM, Mike Duigou wrote:

> Is NavigableCopyOnWriteArraySet useful and sufficiently different in performance
> characteristics from other already available NavigableSet implementations? I
> hope so.
>

I've been sitting on this question. The range of applicability
is narrow, but it is clearly useful in that range. Other opinions
about including it (or any other concurrent collection for that
matter) would be welcome.

-Doug



From davidcholmes at aapt.net.au  Thu Oct 22 00:13:18 2015
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 22 Oct 2015 14:13:18 +1000
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
	in Reference constructor?
In-Reply-To: <2BC916BA-EF1B-4A75-B0A9-0FDD96ED24C4@cox.net>
References: <56278653.9080501@gmail.com>	<1445459399351-12824.post@n7.nabble.com>
	<Xxmg1r00t02hR0p01xmjqA>	<9F6A2BA2-5AE2-4B71-AB45-7017115CFFEE@cox.net>	<Xyu91r00h2HDeFf01yuBt7>
	<2BC916BA-EF1B-4A75-B0A9-0FDD96ED24C4@cox.net>
Message-ID: <10bd01d10c7f$fbcfe220$f36fa660$@net.au>

Yes but the point seems somewhat moot. If object A knows it has a strong reference to object B and wants to make a weak-reference to B, then it hardly matters whether B is already not strongly reachable.

 

The whole ReachabilityFence is really just a local fix to say ?if this object is already strongly reachable, don?t let it become less reachable due to this piece of code?.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg Wonderly
Sent: Thursday, October 22, 2015 9:12 AM
To: dholmes at ieee.org
Cc: thurstonn; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Is Reference.reachabilityFence() needed in Reference constructor?

 

Yes David, but the object holding a strong reference can not guarantee that itself is strongly referenced.  So, the reference graph could result in the reference never being queued if any part of the graph is not strongly referenced.  We?ve gone through this before on this list with a use of PhantomReference that had exactly this problem.  I had to establish a complete strong reference graph to make the class work in production and that made it impossible to create a ?utility? class because the use had to have very explicit reference semantics.

 

Gregg

 

On Oct 21, 2015, at 5:54 PM, David Holmes <davidcholmes at aapt.net.au> wrote:

 

All fields hold strong references, not just static fields. It is only locals/stack-variables that don?t guarantee reachability.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg Wonderly
Sent: Thursday, October 22, 2015 8:10 AM
To: Vitaly Davidovich
Cc: thurstonn; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Is Reference.reachabilityFence() needed in Reference constructor?

 

 

On Oct 21, 2015, at 4:44 PM, Vitaly Davidovich < <mailto:vitalyd at gmail.com> vitalyd at gmail.com> wrote:

 

But the referent arg is on the stack (since the constructor is)
Aren't all variables on the stack strongly reachable?

 

No.  The stacks are scanned and oopmaps are inspected to find live objects, which then serve as the root of a reachability graph, but mere presence of an object on the stack does not mean it's reachable for GC purposes.

 

That seems highly problematic for WeakReference and company to be usable.  How can any object using those APIs guarantee that the object itself is strongly reachable?  Doesn?t seem like they can.  Strong references can only ever be guaranteed by using a static reference, which makes for non-static environments to be really difficult to ?develop? in.

 

Gregg Wonderly






 

On Wed, Oct 21, 2015 at 4:29 PM, thurstonn < <mailto:thurston at nomagicsoftware.com> thurston at nomagicsoftware.com> wrote:

But the referent arg is on the stack (since the constructor is)
Aren't all variables on the stack strongly reachable?



--
View this message in context:  <http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html> http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12824.html
Sent from the JSR166 Concurrency mailing list archive at  <http://nabble.com/> Nabble.com.
_______________________________________________
Concurrency-interest mailing list
 <mailto:Concurrency-interest at cs.oswego.edu> Concurrency-interest at cs.oswego.edu
 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

_______________________________________________
Concurrency-interest mailing list
 <mailto:Concurrency-interest at cs.oswego.edu> Concurrency-interest at cs.oswego.edu
 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/7ed80af5/attachment.html>

From peter.levart at gmail.com  Thu Oct 22 07:22:48 2015
From: peter.levart at gmail.com (Peter Levart)
Date: Thu, 22 Oct 2015 13:22:48 +0200
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <CAHjP37FD24s9GuJhcf90HqDppuFZhCX5rrcUXTS7qROs7BjxSw@mail.gmail.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
	<CAHjP37FD24s9GuJhcf90HqDppuFZhCX5rrcUXTS7qROs7BjxSw@mail.gmail.com>
Message-ID: <5628C708.5010109@gmail.com>

Hi,

Thanks for the insight.

I'd like to note that I'm not concerned about the reachability of the 
Reference object itself (program code takes care of that - for example 
in Cleaner API it hooks Reference objects into a doubly-linked list 
exactly for them to stay reachable until discovered by GC and enqueued 
by ReferenceHandler thread into the associated ReferenceQueue). I'm 
merely interested in the reachability of the referent until the 
Reference (and any possible Reference subclass constructor) fully 
constructs the Reference instance.

The situation where this would manifest as a malfunction is improbable 
(as the referent is usually passed to other parts of code too and is 
reachable from elsewhere for some time). But in case it isn't, the 
following is possible:

     Reference(T referent, ReferenceQueue<? super T> queue) {
         this.referent = referent;
         // - safepoint with GC happens, 'referent' is found 
weakly-reachable, 'this' Reference is hooked on the pending chain
         // - ReferenceHandler thread unhooks 'this' from pending chain 
and tries to enqueue it, but this.queue is still null
         // - BANG! NPE in Referencehandler thread which terminates it!
         this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
     }

A pre-requisite for above scenario is a safepoint between "this.referent 
= referent" and "this.queue = ...". In interpreter, safepoint check is 
after every bytecode instruction right? But in Interpreter, I think 
arguments are also kept on the stack and are therefore reachable at 
least until the end of constructor. How probable is a safepoint between 
those two statements in JIT-ed code? Maybe the Reference constructor 
itself is not in danger because it is very trivial, but what about 
subclasses that must do their own part of initialization too (for 
example Cleaner API discussed on core-libs-dev)?

Regards, Peter

On 10/22/2015 12:25 AM, Vitaly Davidovich wrote:
>
>     Yes, if runtime stripes that instance before it is exposed anywhere
>     (e.g. scalarizes the weakref)
>
>
> If you look at escape analysis code 
> (http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/a60bd3d34158/src/share/vm/opto/escape.cpp#l803), 
> Reference and subclasses get special treatment and marked as GlobalEscape.
>
> On Wed, Oct 21, 2015 at 1:08 PM, Aleksey Shipilev 
> <aleksey.shipilev at oracle.com <mailto:aleksey.shipilev at oracle.com>> wrote:
>
>     On 10/21/2015 06:53 PM, Andrew Haley wrote:
>     > On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
>     >> Of course, this does not tell another (scary) part of the
>     story, what if
>     >> the Reference itself is not discovered as strong ref by GC,
>     e.g. when it
>     >> isn't published on heap, or scalarized by compiler, etc.
>     >> reachabilityFence, as currently implemented, extends the "liveness"
>     >> scope of the local variable, but does not convey anything
>     special to the
>     >> GC/runtime otherwise.
>     >
>     > If the Reference itself is not reachable from a strong root then the
>     > Reference is dead so we don't care what happens to it.  But if the
>     > Reference is put on a reachable ReferenceQueue, then it's fine.
>
>     Yes, if runtime stripes that instance before it is exposed anywhere
>     (e.g. scalarizes the weakref), or those references are dead (e.g. the
>     weakref is buried somewhere deep in garbage subgraph, and purged on
>     sweep), then everything goes awry.
>
>     But the thing is, a WeakReference is put on ReferenceQueue by the GC
>     itself. In the object graph, ReferenceQueue does not normally
>     reference
>     weakrefs back. Before enqueueing the reference GC has to first
>     discover
>     that WeakReference -- but from where? In other words,
>     "registering" on a
>     reachable RefQueue does not make weakref to be reachable.
>
>     Case in point:
>
>     public class WhereIsWaldo {
>
>         public static void main(String... args) throws Exception {
>             for (int c = 0; true; c++) {
>                 new WhereIsWaldo().work(c);
>             }
>         }
>
>         final ReferenceQueue<Object> rq = new ReferenceQueue<>();
>
>         void work(int id) throws Exception {
>             hideWaldo(id);
>             findWaldo(id);
>         }
>
>         WeakReference<Object> gwr;
>
>         void hideWaldo(int id) {
>             // Does not work, d'uh
>             new WeakReference<>(new Object(), rq);
>
>             // Does not work either :(
>             WeakReference<Object> wr =
>                new WeakReference<>(new Object(), rq);
>
>             // This also does not help... once you leave the method,
>             // the weakref is gone.
>             Reference.reachabilityFence(wr);
>
>             // This one helps, makes Waldo reachable
>             // gwr = wr;
>         }
>
>         void findWaldo(int id) throws Exception {
>             while (Thread.currentThread().isAlive()) {
>                 System.gc();
>                 Reference ref = rq.remove(1000);
>                 if (ref != null) {
>                     return;
>                 } else {
>                     System.out.println("Where's Waldo #" + id + "?");
>                 }
>             }
>         }
>     }
>
>
>     Thanks,
>     -Aleksey
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/8e3f8469/attachment-0001.html>

From vitalyd at gmail.com  Thu Oct 22 07:35:58 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 22 Oct 2015 07:35:58 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <5628C708.5010109@gmail.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
	<CAHjP37FD24s9GuJhcf90HqDppuFZhCX5rrcUXTS7qROs7BjxSw@mail.gmail.com>
	<5628C708.5010109@gmail.com>
Message-ID: <CAHjP37GZz5XybJmBTb5VzmJ0qbLodVpvJrvjYHKe9M0+cFs2wg@mail.gmail.com>

It's unlikely there would be a safepoint between those two statements in
compiled code.  Polls are typically placed at method exit (modulo polls
inserted for some types of loops, but that's irrelevant to this instance).
With inlining, the poll distance is likely to increase as well.  However,
there's nothing stopping compiler from scheduling these two statements
sufficiently apart, particularly since there's no data or control flow
dependence between them, and ending up with a safepoint in between.  It's
unlikely probably, but possible.  The bottom line is this code needs manual
lifetime extension facility.

sent from my phone
On Oct 22, 2015 7:22 AM, "Peter Levart" <peter.levart at gmail.com> wrote:

> Hi,
>
> Thanks for the insight.
>
> I'd like to note that I'm not concerned about the reachability of the
> Reference object itself (program code takes care of that - for example in
> Cleaner API it hooks Reference objects into a doubly-linked list exactly
> for them to stay reachable until discovered by GC and enqueued by
> ReferenceHandler thread into the associated ReferenceQueue). I'm merely
> interested in the reachability of the referent until the Reference (and any
> possible Reference subclass constructor) fully constructs the Reference
> instance.
>
> The situation where this would manifest as a malfunction is improbable (as
> the referent is usually passed to other parts of code too and is reachable
> from elsewhere for some time). But in case it isn't, the following is
> possible:
>
>     Reference(T referent, ReferenceQueue<? super T> queue) {
>         this.referent = referent;
>         // - safepoint with GC happens, 'referent' is found
> weakly-reachable, 'this' Reference is hooked on the pending chain
>         // - ReferenceHandler thread unhooks 'this' from pending chain and
> tries to enqueue it, but this.queue is still null
>         // - BANG! NPE in Referencehandler thread which terminates it!
>         this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
>     }
>
> A pre-requisite for above scenario is a safepoint between "this.referent =
> referent" and "this.queue = ...". In interpreter, safepoint check is after
> every bytecode instruction right? But in Interpreter, I think arguments are
> also kept on the stack and are therefore reachable at least until the end
> of constructor. How probable is a safepoint between those two statements in
> JIT-ed code? Maybe the Reference constructor itself is not in danger
> because it is very trivial, but what about subclasses that must do their
> own part of initialization too (for example Cleaner API discussed on
> core-libs-dev)?
>
> Regards, Peter
>
> On 10/22/2015 12:25 AM, Vitaly Davidovich wrote:
>
> Yes, if runtime stripes that instance before it is exposed anywhere
>> (e.g. scalarizes the weakref)
>
>
> If you look at escape analysis code (
> http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/a60bd3d34158/src/share/vm/opto/escape.cpp#l803),
> Reference and subclasses get special treatment and marked as GlobalEscape.
>
> On Wed, Oct 21, 2015 at 1:08 PM, Aleksey Shipilev <
> aleksey.shipilev at oracle.com> wrote:
>
>> On 10/21/2015 06:53 PM, Andrew Haley wrote:
>> > On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
>> >> Of course, this does not tell another (scary) part of the story, what
>> if
>> >> the Reference itself is not discovered as strong ref by GC, e.g. when
>> it
>> >> isn't published on heap, or scalarized by compiler, etc.
>> >> reachabilityFence, as currently implemented, extends the "liveness"
>> >> scope of the local variable, but does not convey anything special to
>> the
>> >> GC/runtime otherwise.
>> >
>> > If the Reference itself is not reachable from a strong root then the
>> > Reference is dead so we don't care what happens to it.  But if the
>> > Reference is put on a reachable ReferenceQueue, then it's fine.
>>
>> Yes, if runtime stripes that instance before it is exposed anywhere
>> (e.g. scalarizes the weakref), or those references are dead (e.g. the
>> weakref is buried somewhere deep in garbage subgraph, and purged on
>> sweep), then everything goes awry.
>>
>> But the thing is, a WeakReference is put on ReferenceQueue by the GC
>> itself. In the object graph, ReferenceQueue does not normally reference
>> weakrefs back. Before enqueueing the reference GC has to first discover
>> that WeakReference -- but from where? In other words, "registering" on a
>> reachable RefQueue does not make weakref to be reachable.
>>
>> Case in point:
>>
>> public class WhereIsWaldo {
>>
>>     public static void main(String... args) throws Exception {
>>         for (int c = 0; true; c++) {
>>             new WhereIsWaldo().work(c);
>>         }
>>     }
>>
>>     final ReferenceQueue<Object> rq = new ReferenceQueue<>();
>>
>>     void work(int id) throws Exception {
>>         hideWaldo(id);
>>         findWaldo(id);
>>     }
>>
>>     WeakReference<Object> gwr;
>>
>>     void hideWaldo(int id) {
>>         // Does not work, d'uh
>>         new WeakReference<>(new Object(), rq);
>>
>>         // Does not work either :(
>>         WeakReference<Object> wr =
>>            new WeakReference<>(new Object(), rq);
>>
>>         // This also does not help... once you leave the method,
>>         // the weakref is gone.
>>         Reference.reachabilityFence(wr);
>>
>>         // This one helps, makes Waldo reachable
>>         // gwr = wr;
>>     }
>>
>>     void findWaldo(int id) throws Exception {
>>         while (Thread.currentThread().isAlive()) {
>>             System.gc();
>>             Reference ref = rq.remove(1000);
>>             if (ref != null) {
>>                 return;
>>             } else {
>>                 System.out.println("Where's Waldo #" + id + "?");
>>             }
>>         }
>>     }
>> }
>>
>>
>> Thanks,
>> -Aleksey
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/680677b9/attachment.html>

From thurston at nomagicsoftware.com  Thu Oct 22 11:30:04 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Thu, 22 Oct 2015 08:30:04 -0700 (MST)
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <56280BF8.1030408@oracle.com>
References: <56278653.9080501@gmail.com>
	<1445459399351-12824.post@n7.nabble.com>
	<56280BF8.1030408@oracle.com>
Message-ID: <1445527804142-12840.post@n7.nabble.com>

Well, you learn something new every day.

I wrote some simple tests to confirm Aleksey's claim, and they do.

In fact, Peter's original code could be modified to an even more surprising:


Object obj = new Object();
WeakReference<?> wr = new WeakReference(obj)

. . .
assert null != wr.get() : "This can fail"

I might suggest that the doc for  reference package
<http://docs.oracle.com/javase/8/docs/api/java/lang/ref/package-summary.html>  
is not ideal:

"An object is strongly reachable if it can be reached by some thread without
traversing any reference objects. *A newly-created object is strongly
reachable by the thread that created it.*"

Depending on how you parse it, it may not be wrong, but is misleading 



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Is-Reference-reachabilityFence-needed-in-Reference-constructor-tp12819p12840.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From hallorant at gmail.com  Thu Oct 22 13:18:30 2015
From: hallorant at gmail.com (Tim Halloran)
Date: Thu, 22 Oct 2015 13:18:30 -0400
Subject: [concurrency-interest] SureLogic Java concurrency-focused analysis
	tools
Message-ID: <CAMyLHFxsaJ2rPVnoDOSGcEtCp5Zu9EuFbm4ThjrjaDhtoTs_qg@mail.gmail.com>

For the past few years my team at SureLogic has been developing Java
analysis tools for concurrency and other deep properties. The tools have
been in use by a small community of demanding and savvy users. We got lots
of useful feedback during several years of development, and, with strong
encouragement from these users, we are now ready to release a fairly mature
tool set to the wider community via http://surelogic.com

We are offering a "community license" arrangement -- at no cost -- for
individual developers, open source projects, academic research and
education, and small professional teams. Larger firms and government users
can easily obtain "enterprise licenses" through our merchant portal with
Square -- see details at http://surelogic.com/licensing.html

I'm posting here (somewhat as SPAM) because I think some folks on this list
might be interested in trying out the tools. We really want your feedback.
Note that the tools are really focused on Java and Android program
development -- and are less useful for util.concurrent developers (e.g.
they don't understand sun.misc.Unsafe and such).

One of the benefit of this late-breaking release is that we already have a
large set of case studies, comprehensive reference documentation, tutorial
documents, and a number of video demonstrations. Please take a look at
http://surelogic.com/products.html

There are three tools in the release:

- JSure is an analysis-based verification tool focused on concurrency and
other selected "deep" quality attributes. The tool can verify all the
annotations from the book Java Concurrency in Practice (@ThreadSafe,
@Immutable, @GuardedBy) as well as many others focused on null references,
effects, static program structure, aliasing, and several common design
patterns. JSure is designed for scale, soundness (no false negatives for
most of the supported attributes), usability by team members, and
straightforward integration into your development and evaluation tooling
and processes. JSure is not a heuristic pattern-matching tool, and false
positives are rare. http://surelogic.com/jsure.html

- Flashlight is a concurrency-focused dynamic analysis tool to help
developers and testers understand code that runs. It is designed to
smoothly adjust from comprehensive data capture in development to
lightweight monitoring in operations. The tool collects a wealth of
concurrency-focused data that can help you uncover both performance and
correctness problems in your code as well as better understand its
behavior. Flashlight uses a suite of dynamic analyses to address questions
related to shared state, use of locks, use of threads, potential deadlock,
waits and blockage times, false sharing, and many other properties. Users
can write custom queries when need arises.
http://surelogic.com/flashlight.html

- Sierra is an integration framework for heuristic static analysis tools.
It is designed to help integrate off-the-shelf "bug finder" tools (such as
FindBugs and PMD) into a team process. Its strengths are easy and
repeatable selection and search among findings with good visualization,
longitudinal matching and diffing, status tracking, and team support. We
mention the tool here for completeness, but Sierra is probably of less
interest to this group. http://surelogic.com/sierra.html

Thanks and please feel free to contact me if you have any questions.

Best regards,
Tim
-- 
Tim Halloran
tim.halloran at surelogic.com
SureLogic, Inc.
5808 Forbes Avenue, Pittsburgh PA 15217-1602
(412) 722-3338
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151022/82a4e940/attachment.html>

From dl at cs.oswego.edu  Sat Oct 24 14:09:44 2015
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 24 Oct 2015 14:09:44 -0400
Subject: [concurrency-interest] Spin Loop Hint support: Draft JEP
	proposal
In-Reply-To: <25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
References: <5932C61D-C9D8-493D-9E2F-2C7965398C41@azulsystems.com>
	<561428BC.3060806@cs.oswego.edu>
	<015C733F-130A-47C0-8F68-1CBB11CC0C38@azulsystems.com>
	<56164C3C.4050800@cs.oswego.edu> <561E6F04.9030708@cs.oswego.edu>
	<54AE479E-9891-48FB-AD47-ECED8147DABE@azul.com>
	<561FC6F9.1080701@cs.oswego.edu>
	<25B8ED3D-4B35-48F4-BF24-32D48E85343E@azul.com>
Message-ID: <562BC968.70603@cs.oswego.edu>


Here's one more attempt to explain why it would be a good idea
to place, name, and specify this method in a way that is more
general than "call this method only if you want a PAUSE instruction
on a dedicated multicore x86":

On 10/15/2015 01:23 PM, Gil Tene wrote:

> I also don't think that the "?momentarily unable to progress until the
> occurrence of one or more actions of one or more other threads. " is true:
> while (!(done || (count++ > threshold))) { spinLoopHint(); } can progress
> without any action by any other thread.

OK, this needs better wording to rule out silly interpretations
about loop bounds. See below.

>
> As noted in my proposed JavaDoc, I see the primary indication of the hint to
> be that the reaction time to events that would cause the loop to exit (e.g.
> in nanosecond units) is more important to the caller than the speed at which
> the loop is executing (e.g. in "number of loop iterations per second" units).

Sure. This can also be stated:

class Thread { ...
  /**
   * A hint to the platform that the current thread is momentarily
   * unable to progress until the occurrence of one or more actions of
   * one or more other threads (or that its containing loop is
   * otherwise terminated).  The method is mainly applicable in
   * spin-then-block constructions entailing a bounded number of
   * re-checks of a condition, separated by spinYield(), followed if
   * necessary with use of a blocking synchronization mechanism.  A
   * spin-loop that invokes this method on each iteration is likely to
   * be more responsive than it would otherwise be.
   */
   public static void spinYield();
}

> Anyone running indefinite spin loops on a uniprocessor deserves whatever they
> get. Yielding in order to help them out is not mercy. Let Darwin take care of
> them instead.
>
> But indefinite user-mode spinning on many-core systems is a valid and common
> use case (see the disruptor link in my previous e-mail).

> In such situations the spinning loop should just be calling yield(), or
> looping for a very short count (like your magic 64) and then yielding. A
> "magically choose for me whether reaction time or throughput or being nice to
> others is more important" call is not a useful hint IMO.
>
> Like in my uniprocessor comment above, any program spinning indefinitely (or
> for a non-trivial amount of time) with load > # cpus deserves what it gets.

The main problem here is that there are no APIs reporting whether
load > # cpus, and no good prospects for them either, especially
considering the use of hypervisors (that may intentionally mis-report)
and tightly packed cloud nodes where the number of cpus currently
available to a program may depend on random transient effects of
co-placement with other services running on that node.

And given that programmers cannot portably comply, the method must
allow implementations that take the best course of action known to the JVM.

Despite all of the above, I agree that an OK initial hotspot implementation
is just to emit PAUSE if on x86 else no-op. It might be worth then
experimenting with randomized branching etc on other platforms, and
someday further exploring some cheap form of load detection, perhaps
kicking in only upon repeated invocation.

-Doug



From aaron.grunthal at infinite-source.de  Sat Oct 24 21:02:09 2015
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Sun, 25 Oct 2015 02:02:09 +0100
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <561E4D95.7000208@cs.oswego.edu>
References: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
	<561E4D95.7000208@cs.oswego.edu>
Message-ID: <562C2A11.20506@infinite-source.de>

One useful advantage of Navigable-/SortedSet is that one can not only 
test the presence of an element but also extract the matching element by 
(ab)using the floor/ceil methods.

Regular sets cannot be used for interning and a Map has the added 
overhead/indirection with its Map.Entry objects.


On 14.10.2015 14:41, Doug Lea wrote:
> So, one question is whether all four of SortedArrayList, SortedArraySet,
> SortedCopyOnWriteArrayList, and SortedCopyOnWriteArraySet should now be
> introduced to fill in the coverage gaps. Or whether the use cases
> covered by only SortedCopyOnWriteArraySet are special enough to
> warrant inclusion without the others. This is the kind of question
> that tends to lead to prolonged inaction in JDK. So any thoughts on
> resolving it quickly would be welcome.


From oleksandr.otenko at gmail.com  Mon Oct 26 13:12:35 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 26 Oct 2015 10:12:35 -0700
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
	in Reference constructor?
In-Reply-To: <5627C696.1070806@oracle.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
Message-ID: <B2771568-0B1B-4CD6-849F-4D4B48BCD81B@gmail.com>

Wouldn?t it be possible to add a test that will always be false?

eg

   Reference(T referent, ReferenceQueue<? super T> queue) {
        this.referent = referent;
        // - safepoint with GC happens, 'referent' is found weakly-reachable, 'this' Reference is hooked on the pending chain
        // - ReferenceHandler thread unhooks 'this' from pending chain and tries to enqueue it, but this.queue is still null
        // - BANG! NPE in Referencehandler thread which terminates it!
        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
        if (get() != referent) { // do a get() == referent test instead for Phantom ref
    System.out.println(referent + ? expected but ? + get() + ? found");
  }
    } 

The point being that referent would need to stay alive due to Java semantics to align with get() and queue assignment.

Alex

> On 21 Oct 2015, at 10:08, Aleksey Shipilev <aleksey.shipilev at oracle.com> wrote:
> 
> On 10/21/2015 06:53 PM, Andrew Haley wrote:
>> On 10/21/2015 04:44 PM, Aleksey Shipilev wrote:
>>> Of course, this does not tell another (scary) part of the story, what if
>>> the Reference itself is not discovered as strong ref by GC, e.g. when it
>>> isn't published on heap, or scalarized by compiler, etc.
>>> reachabilityFence, as currently implemented, extends the "liveness"
>>> scope of the local variable, but does not convey anything special to the
>>> GC/runtime otherwise.
>> 
>> If the Reference itself is not reachable from a strong root then the
>> Reference is dead so we don't care what happens to it.  But if the
>> Reference is put on a reachable ReferenceQueue, then it's fine.
> 
> Yes, if runtime stripes that instance before it is exposed anywhere
> (e.g. scalarizes the weakref), or those references are dead (e.g. the
> weakref is buried somewhere deep in garbage subgraph, and purged on
> sweep), then everything goes awry.
> 
> But the thing is, a WeakReference is put on ReferenceQueue by the GC
> itself. In the object graph, ReferenceQueue does not normally reference
> weakrefs back. Before enqueueing the reference GC has to first discover
> that WeakReference -- but from where? In other words, "registering" on a
> reachable RefQueue does not make weakref to be reachable.
> 
> Case in point:
> 
> public class WhereIsWaldo {
> 
>    public static void main(String... args) throws Exception {
>        for (int c = 0; true; c++) {
>            new WhereIsWaldo().work(c);
>        }
>    }
> 
>    final ReferenceQueue<Object> rq = new ReferenceQueue<>();
> 
>    void work(int id) throws Exception {
>        hideWaldo(id);
>        findWaldo(id);
>    }
> 
>    WeakReference<Object> gwr;
> 
>    void hideWaldo(int id) {
>        // Does not work, d'uh
>        new WeakReference<>(new Object(), rq);
> 
>        // Does not work either :(
>        WeakReference<Object> wr =
>           new WeakReference<>(new Object(), rq);
> 
>        // This also does not help... once you leave the method,
>        // the weakref is gone.
>        Reference.reachabilityFence(wr);
> 
>        // This one helps, makes Waldo reachable
>        // gwr = wr;
>    }
> 
>    void findWaldo(int id) throws Exception {
>        while (Thread.currentThread().isAlive()) {
>            System.gc();
>            Reference ref = rq.remove(1000);
>            if (ref != null) {
>                return;
>            } else {
>                System.out.println("Where's Waldo #" + id + "?");
>            }
>        }
>    }
> }
> 
> 
> Thanks,
> -Aleksey
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From jsampson at guidewire.com  Mon Oct 26 14:56:03 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Mon, 26 Oct 2015 18:56:03 +0000
Subject: [concurrency-interest] Is Reference.reachabilityFence()
 needed	in Reference constructor?
In-Reply-To: <B2771568-0B1B-4CD6-849F-4D4B48BCD81B@gmail.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
	<B2771568-0B1B-4CD6-849F-4D4B48BCD81B@gmail.com>
Message-ID: <DM2PR0501MB8758F01BC38A742903D7C79D1230@DM2PR0501MB875.namprd05.prod.outlook.com>

Alex Otenko wrote:

> Wouldn't it be possible to add a test that will always be false?
>
> eg
> [...]
> if (get() != referent) {
> [...]
>
> The point being that referent would need to stay alive due to
> Java semantics to align with get() and queue assignment.

Couldn't the compiler just inline get() as this.referent, see that
this.referent was just set to referent, and simplify this.referent
!= referent to false?

Cheers,
Justin


From oleksandr.otenko at gmail.com  Mon Oct 26 14:58:48 2015
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 26 Oct 2015 11:58:48 -0700
Subject: [concurrency-interest] Is Reference.reachabilityFence()
	needed	in Reference constructor?
In-Reply-To: <DM2PR0501MB8758F01BC38A742903D7C79D1230@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
	<B2771568-0B1B-4CD6-849F-4D4B48BCD81B@gmail.com>
	<DM2PR0501MB8758F01BC38A742903D7C79D1230@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <225489E6-7DF9-4B26-96A8-C67B85F310EF@gmail.com>

That would be the case, if it can assume access is single-threaded.

Alex

> On 26 Oct 2015, at 11:56, Justin Sampson <jsampson at guidewire.com> wrote:
> 
> Alex Otenko wrote:
> 
>> Wouldn't it be possible to add a test that will always be false?
>> 
>> eg
>> [...]
>> if (get() != referent) {
>> [...]
>> 
>> The point being that referent would need to stay alive due to
>> Java semantics to align with get() and queue assignment.
> 
> Couldn't the compiler just inline get() as this.referent, see that
> this.referent was just set to referent, and simplify this.referent
> != referent to false?
> 
> Cheers,
> Justin


From vitalyd at gmail.com  Mon Oct 26 21:07:22 2015
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Mon, 26 Oct 2015 21:07:22 -0400
Subject: [concurrency-interest] Is Reference.reachabilityFence() needed
 in Reference constructor?
In-Reply-To: <DM2PR0501MB8758F01BC38A742903D7C79D1230@DM2PR0501MB875.namprd05.prod.outlook.com>
References: <56278653.9080501@gmail.com> <5627B2E4.205@oracle.com>
	<5627B502.2010007@redhat.com> <5627C696.1070806@oracle.com>
	<B2771568-0B1B-4CD6-849F-4D4B48BCD81B@gmail.com>
	<DM2PR0501MB8758F01BC38A742903D7C79D1230@DM2PR0501MB875.namprd05.prod.outlook.com>
Message-ID: <CAHjP37HhfcOVM4kaQrX2pWSHDy-7VsHdJcbVECCDV=o0ANP4qw@mail.gmail.com>

http://hg.openjdk.java.net/jdk9/hs-comp/hotspot/file/5d13c9b094c4/src/share/vm/opto/library_call.cpp#l5629

C2 does inline it but intentionally forbids commoning out reads of
Reference.get.  However, this needs a real fix not a hack.

sent from my phone
On Oct 26, 2015 3:22 PM, "Justin Sampson" <jsampson at guidewire.com> wrote:

> Alex Otenko wrote:
>
> > Wouldn't it be possible to add a test that will always be false?
> >
> > eg
> > [...]
> > if (get() != referent) {
> > [...]
> >
> > The point being that referent would need to stay alive due to
> > Java semantics to align with get() and queue assignment.
>
> Couldn't the compiler just inline get() as this.referent, see that
> this.referent was just set to referent, and simplify this.referent
> != referent to false?
>
> Cheers,
> Justin
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151026/30197748/attachment.html>

From nathan.reynolds at oracle.com  Mon Oct 26 22:33:13 2015
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 26 Oct 2015 19:33:13 -0700
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <562C2A11.20506@infinite-source.de>
References: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
	<561E4D95.7000208@cs.oswego.edu> <562C2A11.20506@infinite-source.de>
Message-ID: <562EE269.6010304@oracle.com>

There is a JDK bug on using sets for interning.  See 
https://bugs.openjdk.java.net/browse/JDK-8025414

-Nathan

On 10/24/2015 6:02 PM, Aaron Grunthal wrote:
> One useful advantage of Navigable-/SortedSet is that one can not only 
> test the presence of an element but also extract the matching element 
> by (ab)using the floor/ceil methods.
>
> Regular sets cannot be used for interning and a Map has the added 
> overhead/indirection with its Map.Entry objects.
>
>
> On 14.10.2015 14:41, Doug Lea wrote:
>> So, one question is whether all four of SortedArrayList, SortedArraySet,
>> SortedCopyOnWriteArrayList, and SortedCopyOnWriteArraySet should now be
>> introduced to fill in the coverage gaps. Or whether the use cases
>> covered by only SortedCopyOnWriteArraySet are special enough to
>> warrant inclusion without the others. This is the kind of question
>> that tends to lead to prolonged inaction in JDK. So any thoughts on
>> resolving it quickly would be welcome.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20151026/605b2121/attachment.html>

From jsampson at guidewire.com  Tue Oct 27 21:00:00 2015
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 28 Oct 2015 01:00:00 +0000
Subject: [concurrency-interest] CopyOnWriteArrayNavigableSet too late
 for JEP 266?
In-Reply-To: <562EE269.6010304@oracle.com>
References: <c01ac336d06d24bf32b6b22040689a77@sonic.net>
	<561E4D95.7000208@cs.oswego.edu> <562C2A11.20506@infinite-source.de>
	<562EE269.6010304@oracle.com>
Message-ID: <DM2PR0501MB87556E259F6015795396609D1210@DM2PR0501MB875.namprd05.prod.outlook.com>

Nathan Reynolds wrote:

> There is a JDK bug on using sets for interning.
> See https://bugs.openjdk.java.net/browse/JDK-8025414
>
> Aaron Grunthal wrote:
>
> > One useful advantage of Navigable-/SortedSet is that one can not
> > only test the presence of an element but also extract the
> > matching element by (ab)using the floor/ceil methods. 
> >
> > Regular sets cannot be used for interning and a Map has the
> > added overhead/indirection with its Map.Entry objects. 

I'm probably just confused as usual, but don't most of the standard
Set implementations simply wrap a Map anyway? E.g. a HashSet wraps a
HashMap; a TreeSet wraps a TreeMap; a ConcurrentSkipListSet wraps a
ConcurrentSkipListMap...

Cheers,
Justin


From thurston at nomagicsoftware.com  Sat Oct 31 16:40:27 2015
From: thurston at nomagicsoftware.com (thurstonn)
Date: Sat, 31 Oct 2015 13:40:27 -0700 (MST)
Subject: [concurrency-interest] Runtime intrinsic info
Message-ID: <1446324027653-12850.post@n7.nabble.com>

Hello,

Is there some way to verify that some particular method (say in Unsafe) is
intrinsfied within a JVM at runtime?  Other than viewing the assembly code?
Something sort of like JOL does for class layout


Thanks



--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Runtime-intrinsic-info-tp12850.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From aaron.grunthal at infinite-source.de  Sat Oct 31 17:46:24 2015
From: aaron.grunthal at infinite-source.de (Aaron Grunthal)
Date: Sat, 31 Oct 2015 22:46:24 +0100
Subject: [concurrency-interest] Runtime intrinsic info
In-Reply-To: <1446324027653-12850.post@n7.nabble.com>
References: <1446324027653-12850.post@n7.nabble.com>
Message-ID: <563536B0.8030508@infinite-source.de>

-XX:+UnlockDiagnosticVMOptions -XX:+PrintIntrinsics

-XX:+PrintInlining also happens to provide that information


On 31.10.2015 21:40, thurstonn wrote:
> Hello,
>
> Is there some way to verify that some particular method (say in Unsafe) is
> intrinsfied within a JVM at runtime?  Other than viewing the assembly code?
> Something sort of like JOL does for class layout
>
>
> Thanks
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Runtime-intrinsic-info-tp12850.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From vladimir.x.ivanov at oracle.com  Sat Oct 31 18:17:18 2015
From: vladimir.x.ivanov at oracle.com (Vladimir Ivanov)
Date: Sun, 1 Nov 2015 01:17:18 +0300
Subject: [concurrency-interest] Runtime intrinsic info
In-Reply-To: <1446324027653-12850.post@n7.nabble.com>
References: <1446324027653-12850.post@n7.nabble.com>
Message-ID: <56353DEE.10500@oracle.com>

The short answer is no.

Intrinsification is not a static property. In HotSpot some methods are 
always intrinsifed and some are not (it depends on runtime conditions 
and call site context). VM can decide on per-call site basis.

In 9 all "intrinsifiable" methods should be marked with 
@HotSpotIntrinsicCandidate [1]. Otherwise, HotSpot complains.

In previous releases, -XX:+PrintInlining shows a message for every 
intrinsified method.

Or, inspect HotSpot sources [2]. All intrinsics JVM knows about are 
listed there.

Best regards,
Vladimir Ivanov

[1] 
http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/tip/src/java.base/share/classes/jdk/internal/HotSpotIntrinsicCandidate.java

[2] 
http://hg.openjdk.java.net/jdk9/jdk9/hotspot/file/tip/src/share/vm/classfile/vmSymbols.hpp#l687


On 10/31/15 11:40 PM, thurstonn wrote:
> Hello,
>
> Is there some way to verify that some particular method (say in Unsafe) is
> intrinsfied within a JVM at runtime?  Other than viewing the assembly code?
> Something sort of like JOL does for class layout
>
>
> Thanks
>
>
>
> --
> View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/Runtime-intrinsic-info-tp12850.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

