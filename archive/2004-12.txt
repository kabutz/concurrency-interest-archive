From jasper@jasperpotts.com  Wed Dec  1 19:02:12 2004
From: jasper@jasperpotts.com (Jasper Potts)
Date: Wed, 01 Dec 2004 19:02:12 +0000
Subject: [concurrency-interest] LinkedBlockingQueue.clear() broken?
Message-ID: <41AE1534.7050308@jasperpotts.com>

Heres a simple example

LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
queue.add("A");
queue.add("B");
System.out.println("poll() = " + queue.poll());
queue.clear();
queue.add("C");
System.out.println("poll() = " + queue.poll());

I get :

poll() = A
Exception in thread "main" java.lang.NullPointerException
    at 
java.util.concurrent.LinkedBlockingQueue.extract(LinkedBlockingQueue.java:139)
    at 
java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:420)

but would have expected:

poll() = A
poll() = C

Looking at the source it looks like the clear method changes the "head" 
but not the "last" for the linked list. So "last" is left pointing at 
the old node. "add()" or "offer()" append to the "last" not touching the 
"head". So the queue thinks it has elements but none are connected to 
the head.

Am I being stupid or should I report this as a bug to Sun?

Many Thanks

Jasper Potts

From dl@cs.oswego.edu  Wed Dec  1 19:09:55 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 1 Dec 2004 14:09:55 -0500
Subject: [concurrency-interest] LinkedBlockingQueue.clear() broken?
In-Reply-To: <41AE1534.7050308@jasperpotts.com>
References: <41AE1534.7050308@jasperpotts.com>
Message-ID: <16814.5891.827543.943929@altair.cs.oswego.edu>

> Am I being stupid or should I report this as a bug to Sun?


Neither. See:
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

Pasting...

 The current version of the main JSR166 APIs can be found at
 http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html. They
 include the following updates to the final approved version that will
 someday be changed in J2SE releases:

    * ConcurrentLinkedList.isEmpty failed to override inherited javadoc.
    * ThreadLocal.remove did not state that the value could also be reinitialized using ThreadLocal.set.
    * A bug in LinkedBlockingQueue.clear and LinkedBlockingQueue.drainTo caused subsequently added elements not to be accessible. 

  You can use corrected versions now, without waiting for J2SE
  updates, by obtaining the jsr166 jar and running java using the
  option -Xbootclasspath/p:jsr166.jar (You may need to precede
  "jsr166.jar" with its full file path.)


-Doug

From dawidk@mathcs.emory.edu  Wed Dec  1 19:53:26 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 01 Dec 2004 14:53:26 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of JSR166 to Java 1.4 available
Message-ID: <41AE2136.5010409@mathcs.emory.edu>

http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/

Regards,
Dawid


From ggregory@seagullsoftware.com  Wed Dec  1 21:25:34 2004
From: ggregory@seagullsoftware.com (Gary Gregory)
Date: Wed, 1 Dec 2004 16:25:34 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of JSR166 to Java 1.4 available
Message-ID: <2B64219028BBFF48B3CC957EF10B58FE45F3FB@ns1018.SSSI.seagull.nl>

Hi,

Anything for us poor saps (am I the only one ;-) still stuck on 1.3.1?

Thanks,
Gary

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
Kurzyniec
Sent: Wednesday, December 01, 2004 11:53 AM
To: concurrency-interest@altair.cs.oswego.edu
Subject: [concurrency-interest] Announcing: release 1.0 of backport of
JSR166 to Java 1.4 available


http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/

Regards,
Dawid

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dawidk@mathcs.emory.edu  Wed Dec  1 23:06:27 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 01 Dec 2004 18:06:27 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of
 JSR166 to Java 1.4 available
In-Reply-To: <2B64219028BBFF48B3CC957EF10B58FE45F3FB@ns1018.SSSI.seagull.nl>
References: <2B64219028BBFF48B3CC957EF10B58FE45F3FB@ns1018.SSSI.seagull.nl>
Message-ID: <41AE4E73.3020903@mathcs.emory.edu>

Gary Gregory wrote:

>Hi,
>
>Anything for us poor saps (am I the only one ;-) still stuck on 1.3.1?
>
>Thanks,
>Gary
>
>-----Original Message-----
>From: concurrency-interest-admin@cs.oswego.edu
>[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
>Kurzyniec
>Sent: Wednesday, December 01, 2004 11:53 AM
>To: concurrency-interest@altair.cs.oswego.edu
>Subject: [concurrency-interest] Announcing: release 1.0 of backport of
>JSR166 to Java 1.4 available
>
>
>http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/
>
>  
>
I haven't actually tried it yet, but I think that there is a very good 
chance that the backport works and compiles with older JREs, too, maybe 
even starting with Java 1.2. In the worst case, it may require minor 
changes in some files. Why don't you try it out and share your experiences?

Regards,
Dawid


From jmorissette666@hotmail.com  Thu Dec  2 04:50:39 2004
From: jmorissette666@hotmail.com (Jean Morissette)
Date: Wed, 01 Dec 2004 23:50:39 -0500
Subject: [concurrency-interest] dl.util.concurrent.BoundedBuffer.offer
Message-ID: <BAY102-F34E453A10D0AF611D587828AB00@phx.gbl>

Hi,
Is there a reason to have the line
long waitTime = msecs;
in EDU.oswego.cs.dl.util.concurrent.BoundedBuffer.offer?
Why don't use 'msecs' directly?
Thanks

public boolean offer(Object x, long msecs) throws InterruptedException {
    if (x == null) throw new IllegalArgumentException();
    if (Thread.interrupted()) throw new InterruptedException();

    synchronized (putMonitor_) {
      long start = (msecs <= 0) ? 0 : System.currentTimeMillis();
      long waitTime = msecs;   //////////// Why ???
      while (emptySlots_ <= 0) {
        if (waitTime <= 0) return false;
        try {
          putMonitor_.wait(waitTime);
        } catch (InterruptedException ex) {
          putMonitor_.notify();
          throw ex;
        }
        waitTime = msecs - (System.currentTimeMillis() - start);
      }
      insert(x);
    }
    incUsedSlots();
    return true;
  }



From dl@cs.oswego.edu  Thu Dec  2 11:36:07 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 2 Dec 2004 06:36:07 -0500
Subject: [concurrency-interest] dl.util.concurrent.BoundedBuffer.offer
In-Reply-To: <BAY102-F34E453A10D0AF611D587828AB00@phx.gbl>
References: <BAY102-F34E453A10D0AF611D587828AB00@phx.gbl>
Message-ID: <16814.65063.446551.594383@altair.cs.oswego.edu>

> Is there a reason to have the line
> long waitTime = msecs;
> in EDU.oswego.cs.dl.util.concurrent.BoundedBuffer.offer?
> Why don't use 'msecs' directly?

Because of the line in the loop:

        waitTime = msecs - (System.currentTimeMillis() - start);

-Doug

From nnn6-twfe@spamex.com  Sun Dec  5 00:42:37 2004
From: nnn6-twfe@spamex.com (nnn6-twfe@spamex.com)
Date: Sat, 04 Dec 2004 19:42:37 -0500
Subject: [concurrency-interest] ConcurrentReaderHashMap kudos!
Message-ID: <200412050046.iB50kEfK021995@altair.cs.oswego.edu>

Recently, I have successfully incorporated ConcurrentReaderHashMap in a 
large enterprise software which has a J2EE web portal user interface.

The problem
------------
We have lots of data which is cached inside the J2EE server for
performance reasons. (Other data is loaded directly from database on
demand.)  The data cache can have many reader threads accessing the data
and only rarely will there be a writer thread updating the data, something
like 99.999% of the access is read only. The majority of the readers
threads are accessing the data to construct HTML pages.

Before using concurrent libraries, we were using the standard 1.4 java
collection classes like Hashtable, Vector, etc. plus some of our methods
needed to be synchronized, e.g. when the data structure is an aggregate
like a hash of a hash. This worked fine as far as data integrity, but the
reader threads would get bit by those ConcurrentModificationExceptions (
CCMEs) it they were iterating when an update happened at the same time.

Solution before ConcurrentReaderHashMap
--------------------------------------
We either had to synchronize the readers with the writers, or catch the
ConcurrentModificationExceptions when they happen and just repeat the
operation.  Since we wanted to have maximum performance and minimum
contention between the pool of reader threads,  we opted to just repeat
the operation when the CCMEs happened.

ConcurrentReaderHashMap
-----------------------
We have changed many of the data structures to use ConcurrentReaderHashMap
(1.3.4 version because we aren't on JDK 1.5) instead of Hashtable.  After
running tests we didn't notice any performance impact from the switch.  We
removed all the exception handling for CCMEs, and then performed a stress
test on our application where we have several writer threads making
nonstop modifications in the cache while many reader threads are accessing
it, and all those CCMEs were gone.  Our code is now simplified because we
don't have that restart logic in there to handle the CCMEs.

Feeedback
----------
So far, the ConcurrentReaderHashMap is the ideal data structure for our
usage scenario of many readers and occassional writers.

I would really like to have a ConcurrentReaderSortedMap and/or
ConcurrentReaderSortedSet.  Some of our cache data structures need to
maintain the most commmon sort order for performance reasons.  It really
improves performance to maintain the data in sorted order in our case
because there are 10000 readers for every writer, and most of the readers
need the data in the same sorted order.  Currently we are using
Collections.synchronizedSortedMap(new TreeMap())  or Collections.
synchronizedSortedSet(new TreeSet()).  We have thought about using a
ConcurrentReaderHashMap as the main data structure and then have different
sorted views of the data, but we are uneasy about possible synchronization
issues between the two.

-Alex

From eross@m-Qube.com  Sun Dec  5 05:20:20 2004
From: eross@m-Qube.com (Elias Ross)
Date: Sat, 04 Dec 2004 21:20:20 -0800
Subject: [concurrency-interest] ConcurrentReaderHashMap kudos!
In-Reply-To: <200412050046.iB50kEfK021995@altair.cs.oswego.edu>
References: <200412050046.iB50kEfK021995@altair.cs.oswego.edu>
Message-ID: <1102224020.2324.263.camel@localhost>

On Sat, 2004-12-04 at 16:42, nnn6-twfe@spamex.com wrote:

> I would really like to have a ConcurrentReaderSortedMap and/or
> ConcurrentReaderSortedSet.  Some of our cache data structures need to
> maintain the most commmon sort order for performance reasons.  It really
> improves performance to maintain the data in sorted order in our case
> because there are 10000 readers for every writer, and most of the readers
> need the data in the same sorted order.  

The class SyncSortedMap will work, except in cases when you are
iterating.  Take a look at SyncCollection:  If you want to iterate for
several operations, I would create closures.  For example,

public abstract SyncMapOperation {
  public SyncMapOperation(SyncMap sm) {
    try {
      sm.readerSync().acquire();
      for (Iterator i = ssm.entryMap().iterator(); i.hasNext(); )
         operate((Map.Entry)i.next());
    } finally {
      sm.readerSync().release();
    }
  }
  public abstract void operate(Map.Entry me);
}

and then, if you want to print the list, for example, you would do this:

new SyncOperation(ssm) {
  public void operate(Map.Entry me) {
    System.out.println(me);
  }
};

It's fairly bug-proof and relatively clear when reading.  You'll
probably find this is the cleanest, compared to locking/unlocking for
each operation.  However, it will create a lot of interference if a
writer is waiting for a lock and the size of the data is large.

Alternatively, I would create a copy-on-write SortedMap if the data set
is fairly small.  (Around 1000-10000 or less entries.)

Or, you could save yourself some trouble and download
ConcurrentSkipListMap:

http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166x.jar
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166xdocs/

You'd have to remove the 1.5 generics stuff and compile it for 1.3.  (I
sort of forgot this was around, but it's 1.5 so no free lunch for
you...)



From A.Solofnenko@mdl.com  Sun Dec  5 06:44:20 2004
From: A.Solofnenko@mdl.com (Alexey N. Solofnenko)
Date: Sat, 04 Dec 2004 22:44:20 -0800
Subject: [concurrency-interest] ConcurrentReaderHashMap kudos!
In-Reply-To: <1102224020.2324.263.camel@localhost>
References: <200412050046.iB50kEfK021995@altair.cs.oswego.edu> <1102224020.2324.263.camel@localhost>
Message-ID: <41B2AE44.6070406@mdl.com>

I do not think it is a good idea to call a virtual (even abstract) 
method from a constructor. At least in C++ it was a deadly sin.

- Alexey.

Elias Ross wrote:

>public abstract SyncMapOperation {
>  public SyncMapOperation(SyncMap sm) {
>    try {
>      sm.readerSync().acquire();
>      for (Iterator i = ssm.entryMap().iterator(); i.hasNext(); )
>         operate((Map.Entry)i.next());
>    } finally {
>      sm.readerSync().release();
>    }
>  }
>  public abstract void operate(Map.Entry me);
>}
>
>and then, if you want to print the list, for example, you would do this:
>
>new SyncOperation(ssm) {
>  public void operate(Map.Entry me) {
>    System.out.println(me);
>  }
>};
>
>  
>


From leou@us.ibm.com  Sun Dec  5 18:32:38 2004
From: leou@us.ibm.com (Leo Uzcategui)
Date: Sun, 5 Dec 2004 11:32:38 -0700
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OF28B95462.6E0F1BB6-ON87256F61.0065DD85-87256F61.0065DD86@us.ibm.com>

--0__=08BBE5F2DFF65B158f9e8a93df938690918c08BBE5F2DFF65B15
Content-type: text/plain; charset=US-ASCII





I will be out of the office starting  12/04/2004 and will not return until
12/13/2004.

For assistance, please contact Robin Redden at (512) 838-1542.
--0__=08BBE5F2DFF65B158f9e8a93df938690918c08BBE5F2DFF65B15
Content-type: text/html; charset=US-ASCII
Content-Disposition: inline

<html><body>
<p>I will be out of the office starting  12/04/2004 and will not return until 12/13/2004.<br>
<br>
For assistance, please contact Robin Redden at (512) 838-1542.<br>
</body></html>
--0__=08BBE5F2DFF65B158f9e8a93df938690918c08BBE5F2DFF65B15--


From dl@cs.oswego.edu  Sun Dec  5 22:18:01 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 5 Dec 2004 17:18:01 -0500
Subject: [concurrency-interest] BlockingDeque and revised Deque
In-Reply-To: <16807.18572.932848.214817@altair.cs.oswego.edu>
References: <16807.18572.932848.214817@altair.cs.oswego.edu>
Message-ID: <16819.35097.475177.461494@altair.cs.oswego.edu>

The revised Deque, and new BlockingDeque interfaces, as well
as the new ArrayDeque and LinkedBlockingQueue implementations
are now available in package jsr166x.
    * API specs:  http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166xdocs/
    * jar file: http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166x.jar
    * Browsable CVS sources: http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166x/ 

As mentioned before, the ArrayDeque (mainly written by Josh Bloch) is
targetted to go into java.util, not java.util.concurrent. It is a
simple and fast non-thread-safe non-blocking deque that should become
the implementation of choice for most non-concurrent stacks and
queues. Please try it out!

We haven't checked yet in the little adaptor factory methods
asLifoQueue and asLifoBlockingQueue. It's likely that these will just
go into java.util.Collections when jsr166x becomes merged into J2SE.
If you'd like them before then, ask.

-Doug




From dl@cs.oswego.edu  Sun Dec  5 22:34:34 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 5 Dec 2004 17:34:34 -0500
Subject: [concurrency-interest] ConcurrentReaderHashMap kudos!
In-Reply-To: <1102224020.2324.263.camel@localhost>
References: <200412050046.iB50kEfK021995@altair.cs.oswego.edu>
 <1102224020.2324.263.camel@localhost>
Message-ID: <16819.36090.551996.915772@altair.cs.oswego.edu>

Thanks Alex for the nice example confirming that there are only two
good kinds of iterators: Fail-fast for non-thread-safe collections,
and weakly-consistent for thread-safe ones!

> > I would really like to have a ConcurrentReaderSortedMap and/or
> > ConcurrentReaderSortedSet. 
> ...
> Or, you could save yourself some trouble and download
> ConcurrentSkipListMap:
> 
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166x.jar
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166xdocs/
> 
> You'd have to remove the 1.5 generics stuff and compile it for 1.3.  (I
> sort of forgot this was around, but it's 1.5 so no free lunch for
> you...)

Sorry, this relies heavily on J2SE 5 (1.5) atomics support, so would
be just about impossible to back-port.

Alex might want to give these a try on a J2SE 5 pilot system, if
only to avoid investing a lot of time coming up with alternatives that
you will end up throwing away anyway when you can switch.  Like
ConcurrentHashMap, ConcurrentSkipListMap allows concurrent iterators
without any locking or throwing CCME, so ought to solve the same kinds
of problems.


-Doug

From jean.morissette666@videotron.ca  Mon Dec  6 05:55:44 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Mon, 06 Dec 2004 00:55:44 -0500
Subject: [concurrency-interest] BlockingQueue.drainTo
Message-ID: <41B3F460.7020104@videotron.ca>

Hi,
Could you tell me why method drainTo is in BlockingQueue instead of Queue?

Thanks,
Jean

From puff@darksleep.com  Mon Dec  6 10:00:39 2004
From: puff@darksleep.com (Steven J. Owens)
Date: Mon, 6 Dec 2004 05:00:39 -0500
Subject: [concurrency-interest] Hello, Stability of the Backport, Database-backed Queue?
Message-ID: <20041206100039.GB9613@darksleep.com>

Hi guys,

     I have a couple of questions.  I need to add a job queue and
worker thread pool to my application.  

     Any opinions on the stability/reliability of the backport?  We're
still on jdk 1.4x and will be for a fair bit longer.  I was going to
go with concurrent.util and upgrade to 1.5 concurrency later, but then
I heard about the backport.  

     Is there any sort of known/accepted database-backed queue?  My
current plan of attack is to basically grab a couple hundred rows out
of a database table and dump them into the queue.  Each worker would
then do the processing, and when complete mark each row as done.  But
it feels like I should have the queue be backed by the table, instead
of dumping them into the table.

     For background, my application needs to make 300-500 HTTP
requests to an external system.  Each request has to stay open for
20-60 seconds, and the whole set of requests has to be done inside a 2
hour time window (which is doable now, but as the number grows...).
Right now it all happens in one thread kicked off from a browser
click.  I want to make it multithreaded to fit inside the necessary
time window.  I also want to make it more automated, durable and
schedulable by using a database table with one row per scheduled
request.

-- 
Steven J. Owens
puff@darksleep.com

"I'm going to make broad, sweeping generalizations and strong,
 declarative statements, because otherwise I'll be here all night and
 this document will be four times longer and much less fun to read.
 Take it all with a grain of salt." - http://darksleep.com/notablog


From dl@cs.oswego.edu  Mon Dec  6 12:56:50 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 6 Dec 2004 07:56:50 -0500
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <16820.22290.616784.858727@altair.cs.oswego.edu>

I'm starting to wonder why there's so much resistance out there to
changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
J2SE5 release managers and engineers were with back-compatibility, and
the huge numbers of regression tests run, and the very large number of
bug-fixes and performance improvements in J2SE5, I honestly don't know
of a good technical reason not to switch over to it, even (or
especially?) if people don't need new functionality. I suppose some of
it might be just be fear of any x.0 release (to be addressed soon, I
think, with the first "underscore" release, "1.5_01" or somesuch
name). And maybe it takes time to install/deploy new JVMs across all
machines etc. But is there some more fundamental reason that I'm
overlooking?

-Doug




From paul@kungfoocoder.org  Mon Dec  6 13:17:20 2004
From: paul@kungfoocoder.org (Paul Wagland)
Date: Mon, 6 Dec 2004 14:17:20 +0100
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org>

--Apple-Mail-2--522210695
Content-Transfer-Encoding: 7bit
Content-Type: text/plain; charset=US-ASCII; format=flowed

Hi Doug,

On Dec 6, 2004, at 13:56, Doug Lea wrote:

>
> I'm starting to wonder why there's so much resistance out there to
> changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> J2SE5 release managers and engineers were with back-compatibility, and
> the huge numbers of regression tests run, and the very large number of
> bug-fixes and performance improvements in J2SE5, I honestly don't know
> of a good technical reason not to switch over to it, even (or
> especially?) if people don't need new functionality. I suppose some of
> it might be just be fear of any x.0 release (to be addressed soon, I
> think, with the first "underscore" release, "1.5_01" or somesuch
> name). And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?


Yes, there is. (unfortunately)

One of the reasons that the company that I am currently working for is 
using Java 1.5, is because it is cross-platform. At the moment, the 
list of supported platforms for 1.5 is:
Windows
Linux
Solaris

A partial list of platforms that currently have 1.4:
Apple OSX
AIX
z/OS
HP/UX

Note that those last three are required platforms for support (for us 
at least).

Add to that, we need to run inside of an application server, last I 
checked, half of those were still based around Java 1.3

Your mileage may vary, but for many people, that cross platform ability 
really is important, for the reasons stated above, we will be staying 
with Java 1.3 as our target platform, and trying to ensure that we also 
work with newer JDKs where available. Ultimately, for us, that means we 
will be trying the backport of JSR166, and if that does not work, then 
we will continue on with our internally developed classes for this 
functionality.

On the other hand, we also have a client application, that only needs 
to run on windows and linux. That is allowed to use JDK 1.5.

Food for thought,
Cheers,
Paul

--Apple-Mail-2--522210695
content-type: application/pgp-signature; x-mac-type=70674453;
	name=PGP.sig
content-description: This is a digitally signed message part
content-disposition: inline; filename=PGP.sig
content-transfer-encoding: 7bit

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.4 (Darwin)

iD8DBQFBtFvk0TbiIEYGWeURAiA1AJ9ZuphjxAaAT/riG8O1h2IHNP2yMgCfRWzQ
FOEUx3IGrZmyNwiHE+WsECc=
=fNCt
-----END PGP SIGNATURE-----

--Apple-Mail-2--522210695--


From bjornoh@mi.uib.no  Mon Dec  6 13:22:21 2004
From: bjornoh@mi.uib.no (=?ISO-8859-1?Q?Bj=F8rn-Ove_Heimsund?=)
Date: Mon, 6 Dec 2004 14:22:21 +0100 (CET)
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <Pine.LNX.4.58.0412061420490.10416@thomas.mi.uib.no>

On Mon, 6 Dec 2004, Doug Lea wrote:

> I'm starting to wonder why there's so much resistance out there to
> changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> J2SE5 release managers and engineers were with back-compatibility, and
> the huge numbers of regression tests run, and the very large number of
> bug-fixes and performance improvements in J2SE5, I honestly don't know
> of a good technical reason not to switch over to it, even (or
> especially?) if people don't need new functionality. I suppose some of
> it might be just be fear of any x.0 release (to be addressed soon, I
> think, with the first "underscore" release, "1.5_01" or somesuch
> name). And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?

Two things come to mind:

 - 1.5 isn't available at other platforms than those Sun support

 - Development tools still lag behind, but that's primarily an issue if 
   you want to use the new features

-- 
Bjørn-Ove Heimsund
Centre for Integrated Petroleum Research
University of Bergen, Norway

Bjorn-Ove.Heimsund@uib.no
(+47) 555 83691


From Hanson Char <hanson.char@gmail.com>  Mon Dec  6 13:45:58 2004
From: Hanson Char <hanson.char@gmail.com> (Hanson Char)
Date: Tue, 7 Dec 2004 00:45:58 +1100
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
 <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org>
Message-ID: <ca53c8f8041206054547541745@mail.gmail.com>

I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
code.  So even though production systems still need to stay with 1.4,
development can start moving to 1.5.

Hanson


On Mon, 6 Dec 2004 14:17:20 +0100, Paul Wagland <paul@kungfoocoder.org> wrote:
> Hi Doug,
> 
> 
> 
> On Dec 6, 2004, at 13:56, Doug Lea wrote:
> 
> >
> > I'm starting to wonder why there's so much resistance out there to
> > changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> > J2SE5 release managers and engineers were with back-compatibility, and
> > the huge numbers of regression tests run, and the very large number of
> > bug-fixes and performance improvements in J2SE5, I honestly don't know
> > of a good technical reason not to switch over to it, even (or
> > especially?) if people don't need new functionality. I suppose some of
> > it might be just be fear of any x.0 release (to be addressed soon, I
> > think, with the first "underscore" release, "1.5_01" or somesuch
> > name). And maybe it takes time to install/deploy new JVMs across all
> > machines etc. But is there some more fundamental reason that I'm
> > overlooking?
> 
> 
> Yes, there is. (unfortunately)
> 
> One of the reasons that the company that I am currently working for is
> using Java 1.5, is because it is cross-platform. At the moment, the
> list of supported platforms for 1.5 is:
> Windows
> Linux
> Solaris
> 
> A partial list of platforms that currently have 1.4:
> Apple OSX
> AIX
> z/OS
> HP/UX
> 
> Note that those last three are required platforms for support (for us
> at least).
> 
> Add to that, we need to run inside of an application server, last I
> checked, half of those were still based around Java 1.3
> 
> Your mileage may vary, but for many people, that cross platform ability
> really is important, for the reasons stated above, we will be staying
> with Java 1.3 as our target platform, and trying to ensure that we also
> work with newer JDKs where available. Ultimately, for us, that means we
> will be trying the backport of JSR166, and if that does not work, then
> we will continue on with our internally developed classes for this
> functionality.
> 
> On the other hand, we also have a client application, that only needs
> to run on windows and linux. That is allowed to use JDK 1.5.
> 
> Food for thought,
> Cheers,
> Paul
> 
> 
>

From dholmes@dltech.com.au  Mon Dec  6 13:59:28 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Mon, 6 Dec 2004 23:59:28 +1000
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <ca53c8f8041206054547541745@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au>

> I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
> code.  So even though production systems still need to stay with 1.4,
> development can start moving to 1.5.

It does! Use the -source and -target options on javac eg:

javac -target 1.4 -source 1.4 Foo.java

David Holmes

From jozart@blarg.net  Mon Dec  6 14:03:33 2004
From: jozart@blarg.net (Joe Bowbeer)
Date: Mon, 6 Dec 2004 06:03:33 -0800
Subject: [concurrency-interest] Why not J2SE 5?
References: <16820.22290.616784.858727@altair.cs.oswego.edu> <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org> <ca53c8f8041206054547541745@mail.gmail.com>
Message-ID: <04cd01c4db9c$5f964040$0200a8c0@REPLICANT2>

I'm running my J2ME development tools in Sun's 1.5 VM and I've had to make a 
few changes to some of the Ant build scripts and Ant extensions (tasks); 
otherwise, javac 1.5 balks with: "target release 1.x conflicts with default 
source release 1.5".

The solution is to pass -source and -target on the command line:

javac -source 1.2 -target 1.2 ...


I wish there were a way to do this without having to change all the javac 
command lines.


----- Original Message ----- 
From: "Hanson Char" <hanson.char@gmail.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Monday, December 06, 2004 5:45 AM
Subject: Re: [concurrency-interest] Why not J2SE 5?


I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
code.  So even though production systems still need to stay with 1.4,
development can start moving to 1.5.

Hanson



From ogg@valaran.com  Mon Dec  6 14:17:03 2004
From: ogg@valaran.com (Michael Ogg)
Date: Mon, 06 Dec 2004 09:17:03 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <41B469DF.2020605@valaran.com>

I was personally quite happy to jump to 1.5 and found no problems. In 
fact, having used dl.u.c for a while, it was nice to see that j.u.c has 
several design improvements. But I got a big "whoa there" from my 
engineers when I tried to move quickly to 1.5. It all comes down to QA. 
Notwithstanding all the regression tests run by Sun, noone was prepared 
to move to 1.5 without some QA process. And given that even with zero 
code changes, doing full QA will take time that noone has, it wasn't an 
option to do a dotted release. So unfortunately, moving to 1.5 has to 
fit into the product release schedule.

Having said that, and with all due respect to the backporters, given 
that either moving to 1.5 or using j.u.c with the backport under 1.4 
will require QA, it seems a no-brainer to me which is preferable.

Michael

Doug Lea wrote:

> I'm starting to wonder why there's so much resistance out there to
> changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> J2SE5 release managers and engineers were with back-compatibility, and
> the huge numbers of regression tests run, and the very large number of
> bug-fixes and performance improvements in J2SE5, I honestly don't know
> of a good technical reason not to switch over to it, even (or
> especially?) if people don't need new functionality. I suppose some of
> it might be just be fear of any x.0 release (to be addressed soon, I
> think, with the first "underscore" release, "1.5_01" or somesuch
> name). And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?
> 
> -Doug
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 

From ggagne@westminstercollege.edu  Mon Dec  6 14:28:42 2004
From: ggagne@westminstercollege.edu (Greg Gagne)
Date: Mon, 06 Dec 2004 07:28:42 -0700
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <s1b40a49.037@MAIL.westminstercollege.edu>

Coming from higher ed, I do see alot of interest in coursework covering
the features in 1.5. The 2004 SIGSCE conference had at least 1 workshop
that I'm aware of covering generics, autoboxing, etc. It is my
understanding that the 2005 SIGCSE in March will have much more coverage
as well. I'm starting to see more edu texts with 1.5 features. Overall,
I'd say that many educators are pleased to see these changes,esp.
considering that many educators are coming from C++ backgrounds and are
likely to appreciate features such as generics.

Our CS1/2 1-year intro programming sequence will begin working with 1.5
features beginning in the Fall 05. I teach operating systems which
includes a fair amount of concurrent programming. It is my intention to
cover some of the java.util.concurrent package in my Fall 05 OS class
:-)  - It is in fact a nice API to have students implement some of the
features.

Personally, I do all my work using OS X (our school has a mixture of
Linux and Win machines for student use.) I have been frustrated at how
long it takes Apple to get a release of the latest VM. Apple's 1.4
lagged about a year behind 1.4 production releases for Solaris, Win,
Linux, etc. I expect it will take a similar period of time for a 1.5
release for OS X.

//greg

>>> Doug Lea <dl@cs.oswego.edu> 12/06/04 5:56 AM >>>

I'm starting to wonder why there's so much resistance out there to
changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
J2SE5 release managers and engineers were with back-compatibility, and
the huge numbers of regression tests run, and the very large number of
bug-fixes and performance improvements in J2SE5, I honestly don't know
of a good technical reason not to switch over to it, even (or
especially?) if people don't need new functionality. I suppose some of
it might be just be fear of any x.0 release (to be addressed soon, I
think, with the first "underscore" release, "1.5_01" or somesuch
name). And maybe it takes time to install/deploy new JVMs across all
machines etc. But is there some more fundamental reason that I'm
overlooking?

-Doug



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

From ogg@valaran.com  Mon Dec  6 14:41:29 2004
From: ogg@valaran.com (Michael Ogg)
Date: Mon, 06 Dec 2004 09:41:29 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <ca53c8f8041206054547541745@mail.gmail.com>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>	 <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org> <ca53c8f8041206054547541745@mail.gmail.com>
Message-ID: <41B46F99.1010002@valaran.com>

but it does:
javac -target x.y
will do just what you want.

Michael

Hanson Char wrote:

> I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
> code.  So even though production systems still need to stay with 1.4,
> development can start moving to 1.5.
> 
> Hanson
> 
> 
> On Mon, 6 Dec 2004 14:17:20 +0100, Paul Wagland <paul@kungfoocoder.org> wrote:
> 
>>Hi Doug,
>>
>>
>>
>>On Dec 6, 2004, at 13:56, Doug Lea wrote:
>>
>>
>>>I'm starting to wonder why there's so much resistance out there to
>>>changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
>>>J2SE5 release managers and engineers were with back-compatibility, and
>>>the huge numbers of regression tests run, and the very large number of
>>>bug-fixes and performance improvements in J2SE5, I honestly don't know
>>>of a good technical reason not to switch over to it, even (or
>>>especially?) if people don't need new functionality. I suppose some of
>>>it might be just be fear of any x.0 release (to be addressed soon, I
>>>think, with the first "underscore" release, "1.5_01" or somesuch
>>>name). And maybe it takes time to install/deploy new JVMs across all
>>>machines etc. But is there some more fundamental reason that I'm
>>>overlooking?
>>
>>
>>Yes, there is. (unfortunately)
>>
>>One of the reasons that the company that I am currently working for is
>>using Java 1.5, is because it is cross-platform. At the moment, the
>>list of supported platforms for 1.5 is:
>>Windows
>>Linux
>>Solaris
>>
>>A partial list of platforms that currently have 1.4:
>>Apple OSX
>>AIX
>>z/OS
>>HP/UX
>>
>>Note that those last three are required platforms for support (for us
>>at least).
>>
>>Add to that, we need to run inside of an application server, last I
>>checked, half of those were still based around Java 1.3
>>
>>Your mileage may vary, but for many people, that cross platform ability
>>really is important, for the reasons stated above, we will be staying
>>with Java 1.3 as our target platform, and trying to ensure that we also
>>work with newer JDKs where available. Ultimately, for us, that means we
>>will be trying the backport of JSR166, and if that does not work, then
>>we will continue on with our internally developed classes for this
>>functionality.
>>
>>On the other hand, we also have a client application, that only needs
>>to run on windows and linux. That is allowed to use JDK 1.5.
>>
>>Food for thought,
>>Cheers,
>>Paul
>>
>>
>>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 

From dholmes@dltech.com.au  Mon Dec  6 14:43:10 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 7 Dec 2004 00:43:10 +1000
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <s1b40a49.037@MAIL.westminstercollege.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCEELJFBAA.dholmes@dltech.com.au>

Greg Gagne writes:
> I'd say that many educators are pleased to see these changes,esp.
> considering that many educators are coming from C++ backgrounds and are
> likely to appreciate features such as generics.

I don't think anyone coming from a C++ background is going to appreciate
Java's generics. ;-)

David Holmes


From brian@quiotix.com  Mon Dec  6 14:50:51 2004
From: brian@quiotix.com (Brian Goetz)
Date: Mon, 06 Dec 2004 09:50:51 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <ca53c8f8041206054547541745@mail.gmail.com>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>	 <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org> <ca53c8f8041206054547541745@mail.gmail.com>
Message-ID: <41B471CB.2050304@quiotix.com>

> I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
> code.  So even though production systems still need to stay with 1.4,
> development can start moving to 1.5.

You might check out retroweaver, which can turn 1.5 bytecode back into 
something that executes on 1.4 (within limits.)



From Peter.Booth@gs.com  Mon Dec  6 15:03:29 2004
From: Peter.Booth@gs.com (Booth, Peter)
Date: Mon, 6 Dec 2004 10:03:29 -0500
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <B649D06566185B459613184B8B87794D02817AC7@gsnmp17es.ny.fw.gs.com>

Because J2SE 1.4.2 is too good. Pain is a great motivator. 

The level of pain felt by users of J2SE 1.4.2 is much, much lower than
I recall when struggling with 1.1 (poor Swing support), 1.2 (poor Security),
1.3.x (lots of VM / Weblogic / GC issues.)



-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Bjørn-Ove
Heimsund
Sent: Monday, December 06, 2004 8:22 AM
To: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Why not J2SE 5?

On Mon, 6 Dec 2004, Doug Lea wrote:

> I'm starting to wonder why there's so much resistance out there to
> changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> J2SE5 release managers and engineers were with back-compatibility, and
> the huge numbers of regression tests run, and the very large number of
> bug-fixes and performance improvements in J2SE5, I honestly don't know
> of a good technical reason not to switch over to it, even (or
> especially?) if people don't need new functionality. I suppose some of
> it might be just be fear of any x.0 release (to be addressed soon, I
> think, with the first "underscore" release, "1.5_01" or somesuch
> name). And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?

Two things come to mind:

 - 1.5 isn't available at other platforms than those Sun support

 - Development tools still lag behind, but that's primarily an issue if 
   you want to use the new features

-- 
Bjørn-Ove Heimsund
Centre for Integrated Petroleum Research
University of Bergen, Norway

Bjorn-Ove.Heimsund@uib.no
(+47) 555 83691

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From kris@dotech.com  Mon Dec  6 15:15:19 2004
From: kris@dotech.com (Kris Schneider)
Date: Mon,  6 Dec 2004 10:15:19 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41B46F99.1010002@valaran.com>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>  <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org> <ca53c8f8041206054547541745@mail.gmail.com> <41B46F99.1010002@valaran.com>
Message-ID: <1102346119.41b477872afb4@webmail.dotech.com>

That should actually result in an error because of a conflict with the default
source release: 1.5. If you want to cross-compile, I'd suggest using something
like:

javac -source 1.4 -target 1.4 -bootclasspath $JDK142/jre/lib/rt.jar -extdirs
$JDK142/jre/lib/ext -endorseddirs $JDK142/jre/lib/endorsed ...

Which I guess is nice if you want to make use of the J2SE 5.0 *compiler*, but it
won't allow developers to make use of new language features and classes while
magically running on a 1.4 JVM.

Quoting Michael Ogg <ogg@valaran.com>:

> but it does:
> javac -target x.y
> will do just what you want.
> 
> Michael
> 
> Hanson Char wrote:
> 
> > I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
> > code.  So even though production systems still need to stay with 1.4,
> > development can start moving to 1.5.
> > 
> > Hanson
> > 
> > 
> > On Mon, 6 Dec 2004 14:17:20 +0100, Paul Wagland <paul@kungfoocoder.org>
> wrote:
> > 
> >>Hi Doug,
> >>
> >>
> >>
> >>On Dec 6, 2004, at 13:56, Doug Lea wrote:
> >>
> >>
> >>>I'm starting to wonder why there's so much resistance out there to
> >>>changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> >>>J2SE5 release managers and engineers were with back-compatibility, and
> >>>the huge numbers of regression tests run, and the very large number of
> >>>bug-fixes and performance improvements in J2SE5, I honestly don't know
> >>>of a good technical reason not to switch over to it, even (or
> >>>especially?) if people don't need new functionality. I suppose some of
> >>>it might be just be fear of any x.0 release (to be addressed soon, I
> >>>think, with the first "underscore" release, "1.5_01" or somesuch
> >>>name). And maybe it takes time to install/deploy new JVMs across all
> >>>machines etc. But is there some more fundamental reason that I'm
> >>>overlooking?
> >>
> >>
> >>Yes, there is. (unfortunately)
> >>
> >>One of the reasons that the company that I am currently working for is
> >>using Java 1.5, is because it is cross-platform. At the moment, the
> >>list of supported platforms for 1.5 is:
> >>Windows
> >>Linux
> >>Solaris
> >>
> >>A partial list of platforms that currently have 1.4:
> >>Apple OSX
> >>AIX
> >>z/OS
> >>HP/UX
> >>
> >>Note that those last three are required platforms for support (for us
> >>at least).
> >>
> >>Add to that, we need to run inside of an application server, last I
> >>checked, half of those were still based around Java 1.3
> >>
> >>Your mileage may vary, but for many people, that cross platform ability
> >>really is important, for the reasons stated above, we will be staying
> >>with Java 1.3 as our target platform, and trying to ensure that we also
> >>work with newer JDKs where available. Ultimately, for us, that means we
> >>will be trying the backport of JSR166, and if that does not work, then
> >>we will continue on with our internally developed classes for this
> >>functionality.
> >>
> >>On the other hand, we also have a client application, that only needs
> >>to run on windows and linux. That is allowed to use JDK 1.5.
> >>
> >>Food for thought,
> >>Cheers,
> >>Paul

-- 
Kris Schneider <mailto:kris@dotech.com>
D.O.Tech       <http://www.dotech.com/>

From gregg.wonderly@pobox.com  Mon Dec  6 15:19:16 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 06 Dec 2004 09:19:16 -0600
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <41B47874.3010408@cytetech.com>

Doug Lea wrote:
> And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?

I am trying to move to J2SE5.0 on linux.  One of the problems that we 
say up front was that it was still possible to crash the JVM in native 
code.  There are numerous bug reports about this type of problem in the 
bug parade.  My application is large, consisting of over 1000 class 
files, and when it crashes, bug reports are met with a request for a 
sample test case that reproduces the problem.  This is a fine question 
to ask, but in my case, I can't see the real problem due to the way the 
JVM expresses the problem.  The GC logging and the general interfaces to 
the GC activity still don't tell you near what they should with explicit 
information about the situation at death.

So, in our case, we are deploying the same software into a new 
application where we have no compatibility issues to deal with (if they 
actually exist).  But, because of the crashes, we can't tell whether its 
the JVM that has problem, or our GC configuration parameters.  So, I get 
pressure from my management to go back to 1.4.2.  Because of the 
difference in JVMs and GCs, it's possible that just this change alone 
will eliminate border cases for GC configuration parameters.

I believe that what the GC should do instead, by default is grow any 
area that it needs, and use a WARNING level log entry to indicate it is 
changing configuration, and output the 'current' set of parameters that 
would be needed to configure the GC to operate in that configuration. 
Then a -XX:nogcautoconfig parameter should be available to shut this 
down, if I really have an environment where code is randomly injected 
and I do need to keep the JVM from taking over the machine.

I'm not a GC configuration expert, so maybe this is possible and I've 
missed that documentation.  But, memory use and crashing JVMs because of 
misconfigured GC parameters is the biggest pain that I have to deal with 
on a regular basis, and the obscurity of these crashes is problematic.

And a related issue is the fact that there is not a built in JVMDI 
module that will trace the number of allocations of each and every type 
of Object in the JVM.  The forsale tools that do this already are too 
pricey because there is no competition in this area.  I also need 
operational interfaces to such tools that use either JMX or Jini (I 
prefer an RMI interface that I can plug JERI into for real security) so 
that I can perform remote, automated inspection and control to the 
application.

Gregg

From osvaldo@visionnaire.com.br  Mon Dec  6 15:51:08 2004
From: osvaldo@visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Mon, 06 Dec 2004 12:51:08 -0300
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <41B47FEC.8040404@visionnaire.com.br>

Hi Doug,

Doug Lea wrote:
> I'm starting to wonder why there's so much resistance out there to
> changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
> J2SE5 release managers and engineers were with back-compatibility, and
> the huge numbers of regression tests run, and the very large number of
> bug-fixes and performance improvements in J2SE5, I honestly don't know
> of a good technical reason not to switch over to it, even (or
> especially?) if people don't need new functionality. I suppose some of
> it might be just be fear of any x.0 release (to be addressed soon, I
> think, with the first "underscore" release, "1.5_01" or somesuch
> name). And maybe it takes time to install/deploy new JVMs across all
> machines etc. But is there some more fundamental reason that I'm
> overlooking?

I have already moved to 5.0 in two production apps and it's better than
any previous runtime in every way -- performance, stability, management
-- even before using any new API or language improvement. Kudos to Sun.
Nevertheless, I can't yet depend on J2SE5 for most of my work because:

1) J2EE platform support:  I have clients using servers like WebSphere,
which ships its own JRE which is still prehistoric (J2SE 1.3), and it's
not a old version of WAS.  IBM supports 1.4 only in their very latest
WAS (6.0 -- just released AFAIK), and while I guess I could configure
WAS5 to run on IBM JDK 1.4.2, there's 0,00% chance that I would have
the sysadmins allowing any update that's not an official WAS PTF.

2) Branching: Even in newer projects or projects with "softer" infra-
structure management in the client's network (a.k.a. "I telnet to their
server and install whatever I want" -- my favourite conditions !!!),
I often avoid new APIs because most code going to one client is shared
due to forking from a single application that's customized for several
clients, or reusable components that are used in independent projects.
Using new stuff that cannot be merged back to the root code and then
to other branches would increase a lot my maintenance overheads wrt
bugfixes, etc. (we are a small ISV, and every man-hour of work that's
not explicitly planned and paid by some client, is a problem).

3) Most people are not technologists that track Java closely.  The J2SE
platform does have some history of bad "dot-zero" releases.  Not too far
in the past, J2SE 1.4.0 had a lot of problems not only in new APIs (like
the barely-usable java.nio) but also existing APIs: Swing's new focus
subsystem broke code for most people doing complex focus programming.
We could argue that some of that code worked on 1.3.x out of sheer luck
-- relying on unspecified behaviors, side effects of bugs, or using ugly
workarounds for previously-missing functionality.  But these excuses are
"academic" for developers, users and managers hit by incompatibilities.
Fortunately, Sun's Q&A processes improved by leaps and bounds since 2001
and I no longer fear regressions or even big problems in all-new APIs.
But J2SE 5.0 is too recent, it's the very first Major Release achieving
such very high standards of backwards compatibility and robustness, and
it may take another major release or two with the same quality until
most people start trusting major updates.

4) In Tiger, the presence of extensive new language syntax features
makes this update suspicious for many developers.  It's common that
developers equate the language with the system's internals, and big
changes in the language should require big changes in the compilers
and other rocket-science components, right?  This is the rule for C++
and other traditional languages, but it's different in Java, where
javac is litte more than a parser, and the interesting and dangerous
work is performed by the VM (JIT compiler, GC, etc.).  Unfortunately,
it's not good marketing to describe all the language improvements as
"cosmetic -- nothing changed under the hood" so people feel safer.
This trend is made stronger in Java due to excessive conservadorism
in the past: Java, the language, is 99% unchanged from 1.0 to 1.4.2.
Once again, it may take another release or two, with significant
language improvements, to educate many developers to the fact that
evolving the language is reasonably safe in Java... and notice that
it's not perfectly safe, see the curious bug with ternary operator
(?:) and final fields, in J2SE 5.0's javac.  This bug is minimal in
proportion to the javac changes for 5.0, and there were much worse
javac bugs in past releases *without* language changes, but still,
the general perception is that changing the language is dangerous.

Finally, all these reasons are very often masking laziness -- there's
a huge number of Java developers who haven't yet found enough time to
master the new language features, let alone new APIs.  So they say to
themselves that Tiger is still too new and it should be buggy... ;)

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Informática S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223



From osvaldo@visionnaire.com.br  Mon Dec  6 16:27:26 2004
From: osvaldo@visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Mon, 06 Dec 2004 13:27:26 -0300
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au>
Message-ID: <41B4886E.3070806@visionnaire.com.br>

David Holmes wrote:
>>I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
>>code.  So even though production systems still need to stay with 1.4,
>>development can start moving to 1.5.
> 
> It does! Use the -source and -target options on javac eg:
> javac -target 1.4 -source 1.4 Foo.java

No it doesn't work.  This produces the following output:
"javac: source release 1.5 requires target release 1.5"

This is a feature I tried (I and many others I'm sure) to lobby Sun to
have in Tiger.  Early alpha builds accepted this combination of flags,
even if not perfectly, for example autoboxing would be compiled with
dependencies on new 5.0 APIs; I reported this as a bug (4975921) only
to learn that Tiger wasn't planned to support this at all.  I guess
Sun didn't want to create a dialect somewhere btw 1.4 and 1.5, because
it's impossible to compile all of the new language features to bytecode
compatible with 1.4 VMs (some features, like enums and annotations,
depend on new core APIs and some changes in the VM and runtime libs,
like the serialization changes to support enums).

There's a guy who created a weaver, http://retroweaver.sourceforge.net/,
that translates bytecode compiled with "-target 1.5" to 1.4-compatible
bytecode (that may depend on an extension library), but it's not a 100%
compatible and seamless; you will get in trouble with those hard issues
like on-the-wire serialized enum interoperability or reflection details.

But wait.  javac supports "-source 1.5 -target jsr14" where "jsr14" is
unsupported, I thought this would enables supports only for generics and
related features (like covariance), like JSR14's Early Access compilers.
But I tested this now, and it seems to support all of the new language
(even fixes bug 4975921, which Sun marked "Closed, will not be fixed"!
it compiles "Object x = 10" to "Integer x = new Integer(10)", using the
Integer(int) constructor, not the 5.0-specific Integer.valueOf(int)!!)
I wonder if this works well enough (at least for features not demanding
core changes) so I don't need tools like RetroWeaver.  Too bad it's not
supported, anyway.  It doesn't attempt to solve these problems, e.g. it
accept enums and produces code that won't work in J2SE1.4 due to the
missing java.lang.Enum class.  I wish "-target jsr14" would work in
these cases, but emit a warning about compiler-introduced dependencies
on classes and methods available only on 5.0.

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Informática S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223


From dholmes@dltech.com.au  Mon Dec  6 15:35:23 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 7 Dec 2004 01:35:23 +1000
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41B4886E.3070806@visionnaire.com.br>
Message-ID: <NFBBKALFDCPFIDBNKAPCEELMFBAA.dholmes@dltech.com.au>

Osvaldo writes:
> No it doesn't work.  This produces the following output:
> "javac: source release 1.5 requires target release 1.5"

Think about this a bit. You have to have compatible source and target
options. If you want source 1.5 you must have target 1.5 ! But you can use
source 1.4 and target 1.4 to produce a 1.4 version.

There is no magic way to use 1.5 language features and have them work on the
1.4 VM - which is not what the original poster was talking about anyway.
They wanted to update their development environment to 1.5 while running the
production on 1.4 and you CAN do that.

David Holmes


From dl@cs.oswego.edu  Mon Dec  6 16:06:44 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 6 Dec 2004 11:06:44 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
 <2901779F-4789-11D9-A36D-000A95CD704C@kungfoocoder.org>
Message-ID: <16820.33684.377082.525382@altair.cs.oswego.edu>

Thanks for all the replies! While I don't want to touch any of the
non-technical issues (at least not on concurrency-interest list), it
would be good to at least have a listing of what the technical ones
are for those who ask. As far as I can tell, they are:

1. No J2SE 5 JVMs on some platforms
   Does anyone know the details of upcoming support on
    * Eclipse 
    * IBM J9 JVM (that comes with Eclipse on most platforms)
    * Apple OSX
    * HP: pa-risc and/or ia64 on HP/UX
    * Other IBM platforms: AIX, z/OS
    * Other Blackdown linux ports
    * BSD

   (We've had a standing invitation to JVM developers to help in any way
    we can with JSR166 support. Only Sun and BEA/JRockit have taken us
    up on it.)

2. Incompatibilies
   * GC settings may need to be changed
   * Different responses to broken JNI code?
   * Requires(?) different monitoring and management tools

Have I left anything out?

(I did leave out "lack of certified support for certain app servers
etc.". Certification is a process issue. A known incompatibity
is a technical issue.)

My aim here is not to start a discussion of any of this, but only to
be able to answer people's questions about whether there are any
obstacles that apply in any particular case, so I can recycle this
mail when I get asked about it. (Every few days lately!)

-Doug

From jnielsen@sungardsct.com  Mon Dec  6 15:59:48 2004
From: jnielsen@sungardsct.com (Jan Nielsen)
Date: Mon, 06 Dec 2004 08:59:48 -0700
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
References: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <6.1.2.0.0.20041206084027.05bb3008@slcnot1.sct.com>

Doug,

Our product runs in a third-party Web container on four different platforms 
(Windows, HPUX, RedHat, and Solaris). Our JVM support is determined by the 
third-party vendor's JVM support in the subset of their product line that 
we use, and they have only recently started to support the 1.4 JVM in that 
set. We are therefore stuck until the third-party vendor fully supports the 
upgraded JVM. And the third-party vendor is Sun. :-|


-Jan

At 05:56 AM 12/6/2004, Doug Lea wrote:

>I'm starting to wonder why there's so much resistance out there to
>changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
>J2SE5 release managers and engineers were with back-compatibility, and
>the huge numbers of regression tests run, and the very large number of
>bug-fixes and performance improvements in J2SE5, I honestly don't know
>of a good technical reason not to switch over to it, even (or
>especially?) if people don't need new functionality. I suppose some of
>it might be just be fear of any x.0 release (to be addressed soon, I
>think, with the first "underscore" release, "1.5_01" or somesuch
>name). And maybe it takes time to install/deploy new JVMs across all
>machines etc. But is there some more fundamental reason that I'm
>overlooking?
>
>-Doug
>
>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




Jan Nielsen
System Architect
Luminis Solutions
SunGard SCT

jnielsen@sungardsct.com
http://www.sungardsct.com

+1 801 257 4155 (voice)
+1 801 485 6606 (facsimile)

90 South 400 West
Salt Lake City, UT 84101


From osvaldo@visionnaire.com.br  Mon Dec  6 17:17:33 2004
From: osvaldo@visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Mon, 06 Dec 2004 14:17:33 -0300
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEELMFBAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCEELMFBAA.dholmes@dltech.com.au>
Message-ID: <41B4942D.1010106@visionnaire.com.br>

David Holmes wrote:
> Osvaldo writes:
> 
>>No it doesn't work.  This produces the following output:
>>"javac: source release 1.5 requires target release 1.5"
> 
> Think about this a bit. You have to have compatible source and target
> options. If you want source 1.5 you must have target 1.5 ! But you can use
> source 1.4 and target 1.4 to produce a 1.4 version.

Then why two switches, sourge & target?  A single switch would do it.

Historically, in older JDKs we could always use -target with a lesser
version that -source.  That was useful because most previous language
enhancements didn't depend on new JVMs, e.g. inner classes.  Even the
strictfp feature could be easily compiled to old JVMs because in older
JVMs all maths was strict (so the new atribute would be redundant).
J2SE1.4 was first (with assert) to introduce language enhancements that
really required a new JVM.  And with 1.4, "-source 1.4 -target 1.3" is
supported and it makes a lot of sense (doesn't allow using "assert" as
an identifier, which is a good measure before you could move to 1.4).

> There is no magic way to use 1.5 language features and have them work on the
> 1.4 VM - which is not what the original poster was talking about anyway.
> They wanted to update their development environment to 1.5 while running the
> production on 1.4 and you CAN do that.

Sorry, you are right, I misunderstand that post.  It seems I jumped
on this due to my gripe with "-source 1.5/-target 1.4"

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Informática S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223


From dholmes@dltech.com.au  Mon Dec  6 16:46:24 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 7 Dec 2004 02:46:24 +1000
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41B4942D.1010106@visionnaire.com.br>
Message-ID: <NFBBKALFDCPFIDBNKAPCGELOFBAA.dholmes@dltech.com.au>

Osvaldo writes:
> Then why two switches, sourge & target?  A single switch would do it.

Historically the target and source values have not been tied - in
fact -source came much later than -target. With the later releases you are
forced to keep them upwardly compatible:

  -source 1.4 requires -target 1.4+
  -source 1.5 requires -target 1.5+

but source 1.3 does not require -target 1.3+

Considering the different values:

-source:
   1.1 - not supported but would have added inner classes and blank finals
   1.2 - added strictfp
   1.3 - nothing new
   1.4 - assert keyword
   1.5 - lots of stuff :)

- target:
   1.1 - old static resolution process/constant-pool encoding
   1.2 - new static resolution process/constant-pool encoding
   1.3 - ?? no actual change
   1.4 - ??
   1.5 - lots of changes

I work on a system which requires -target 1.1 hence we can't use new source
features from 1.4 or 1.5.

Other people who haven't migrated to asserts yet might use source 1.3 but
allow the default target 1.5

David Holmes


From Dave.Dice@Sun.COM  Mon Dec  6 17:11:12 2004
From: Dave.Dice@Sun.COM (Dave Dice)
Date: Mon, 06 Dec 2004 12:11:12 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <16820.22290.616784.858727@altair.cs.oswego.edu>
Message-ID: <004301c4dbb6$968e1040$3800000a@foxboro>

| 
| 
| I'm starting to wonder why there's so much resistance out 
| there to changing from 1.x to J2SE5 (1.5). Having seen how 
| obsessed the Sun J2SE5 release managers and engineers were 
| with back-compatibility, and the huge numbers of regression 
| tests run, and the very large number of bug-fixes and 
| performance improvements in J2SE5, I honestly don't know of a 
| good technical reason not to switch over to it, even (or
| especially?) if people don't need new functionality. I 
| suppose some of it might be just be fear of any x.0 release 
| (to be addressed soon, I think, with the first "underscore" 
| release, "1.5_01" or somesuch name). And maybe it takes time 
| to install/deploy new JVMs across all machines etc. But is 
| there some more fundamental reason that I'm overlooking?
| 
| -Doug
| 


I think folks on this list have iterated over the major reasons that 1.5
adoption might be a bit slower than we'd prefer.  In particular, Michael
Ogg hit the nail directly on the head with his comments about QA costs.
Say you're in a corporate IT shop.  If the old JVM isn't giving you
problems it's extremely difficult to justify changing JVM versions.
There's risk and considerable QA + deployment expense, so you have to be
able to identify some advantage to using the new JVM.  It's very common
to see enterprise customers lock down on a specific configuration (JVM
version, hardware, OS), put that configuration through rigorous
qualification, and then standardize on the configuration for large
fractions of a decade.  Often, the only thing that'll precipitate a
change is if one of the components slips outside a vendors support
window.  Typically, a corporate-wide hardware upgrade will cause a
shift.  At that point he apps, OS, JVM and hardware will be re-tested
and upgraded in unison.   The upgrade cycles are quite long.  

Like it or not, there are still quite a few 1.2.2s and 1.3.0s out there.


Regards,
Dave







 



From gregg.wonderly@pobox.com  Mon Dec  6 17:18:21 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 06 Dec 2004 11:18:21 -0600
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41B4886E.3070806@visionnaire.com.br>
References: <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au> <41B4886E.3070806@visionnaire.com.br>
Message-ID: <41B4945D.9020009@cytetech.com>

Osvaldo Pinali Doederlein wrote:
> I guess
> Sun didn't want to create a dialect somewhere btw 1.4 and 1.5, because
> it's impossible to compile all of the new language features to bytecode
> compatible with 1.4 VMs (some features, like enums and annotations,
> depend on new core APIs and some changes in the VM and runtime libs,
> like the serialization changes to support enums).

The standing issue is that a specification would have to exist for this 
version of Java, or Sun would be breaking the rules in a way similar to 
what Microsoft went to court over.  So, the reality is that it can't be 
done "easily", and the benefits, while seemingly strong, would only, in 
the end, slow adoption.

We do not use J2EE for anything. We use our own container architecture 
that we created before J2EE existed.  We have augmented this platform 
with Jini for SOA.  So, we depend on a minimum of external vendor code 
from a JVM perspective.  Jini does have some JVM version restrictions, 
but they are minimum JVM requirements for newer language features in 
1.4.  It is not dependent on a JVM augmented with vendor performance 
enhancements or other tricks that can create compatibility issues.

And, the best thing is that the community was able to vote to keep 1.4 
as the backward compatibility point for the next iteration of Sun's 
development so that we can all prepare for 1.5 and become experienced 
with it before it becomes dependent on the 1.4 JVM.  And some of the 
community members stated the issues of J2EE compatibility brought up here.

Gregg

From puff@darksleep.com  Mon Dec  6 19:11:46 2004
From: puff@darksleep.com (Steven J. Owens)
Date: Mon, 6 Dec 2004 14:11:46 -0500
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <004301c4dbb6$968e1040$3800000a@foxboro>
References: <16820.22290.616784.858727@altair.cs.oswego.edu> <004301c4dbb6$968e1040$3800000a@foxboro>
Message-ID: <20041206191146.GC9613@darksleep.com>

On Mon, Dec 06, 2004 at 12:11:12PM -0500, Dave Dice wrote:
> | I'm starting to wonder why there's so much resistance out 
> | there to changing from 1.x to J2SE5 (1.5). [...] I honestly
> | don't know of a  good technical reason not to switch over [...]

     I can't help but wonder if my post has something to do with this
topic coming up :-).

> I think folks on this list have iterated over the major reasons that
> 1.5 adoption might be a bit slower than we'd prefer.  In particular,
> Michael Ogg hit the nail directly on the head with his comments
> about QA costs.  Say you're in a corporate IT shop.  If the old JVM
> isn't giving you problems it's extremely difficult to justify
> changing JVM versions.

     Yup, the old "if it ain't broke, don't fix it" argument.  In my
case it's a little easier in some ways - I'm the top technical guy at
our small software company (8 people, 4 of them technical).  So the
decision is pretty much in my lap.  On the other hand, we have a tiny
staff and we only have so much time to go around.  If I could wave my
magic wand and have us running on JDK 1.5 and tomcat 5.x and *know*,
know with the same certainty we have from running our app in
production use on JDK 1.4 and tomcat 4.3x for eighteen months, that
it'll all work smoothly, we would.

     As it is, it's not that I'm resisting upgrading, it's just that
it hasn't percolated through our strategic to-do list yet.  We do have
one of our team using tomcat 5.x in his development environment, and
I'd like to get us using JDK 1.5 soon, even though we'll almost
certainly stay inside the JDK 1.4 feature envelope for the foreseeable
future (except, perhaps for the use of concurrency).

     There's also the issue of minimizing the variables in each
major change, and since development is an ongoing process...

> There's risk and considerable QA + deployment expense, so you have
> to be able to identify some advantage to using the new JVM.  It's
> very common to see enterprise customers lock down on a specific
> configuration (JVM version, hardware, OS), put that configuration
> through rigorous qualification, and then standardize on the
> configuration for large fractions of a decade.

     I agree, except for the part about "rigorous qualifications" :-).
I know of a large financial institution that standardized on JDK 1.6
when that was mainstream.  They were still using it in 2000.  I
believe they're a little bit beyond 1.6 now, but I wouldn't bet money
on it.

     Large organizations tend to sink a lot of time into risk
brokering strategies.  Note, I don't say necessarily risk _avoidance_
strategies :-).  As an example, say they need to solve a problem.
Somebody will see that problem as an opportunity (to expand their
kingdom) and will tackle it.  But they'll set up a committee, have a
lot of meetings, and get a lot of buy-in from other people at their
level in the organization.  This spreads the risk around.

     At some point they may decide that it's a technical risk (pretty
much at any point where it becomes apparent that the project isn't a
no-brainer).  Then they decide they need to go get an outside
consulting organization, say Sun's consulting arm.  This is a great
risk-brokering strategy - not because the consulting team is any less
risky than their own staff, but because the process of bringing the
consulting team in involves a lot of meetings, an approved vendor
list, a lot of higher-level buy-in.  In the end, a lot more people are
implicated in the decision - people who might otherwise be the ones
pointing the finger if anything goes wrong.

     Worst case scenario, it also gives them a convenient external
target to deflect blame onto, "Hey, I hired Sun consulting guys to do
the java stuff, what more could I do?"  (add to which the implied:
After all, you guys approved them as a vendor...)

     Now, if this sort of dance goes on at the managerial level, how
readily do you think they'll take major steps at the technical level?

> Often, the only thing that'll precipitate a change is if one of the
> components slips outside a vendors support window.  Typically, a
> corporate-wide hardware upgrade will cause a shift.  At that point
> he apps, OS, JVM and hardware will be re-tested and upgraded in
> unison.  The upgrade cycles are quite long.  Like it or not, there
> are still quite a few 1.2.2s and 1.3.0s out there.

     Case in point, the financial organization I spoke of above.  Most
likely they upgraded when they moved to using EJB servers, which I
think they did in mid-late 2000.

-- 
Steven J. Owens
puff@darksleep.com

"I'm going to make broad, sweeping generalizations and strong,
 declarative statements, because otherwise I'll be here all night and
 this document will be four times longer and much less fun to read.
 Take it all with a grain of salt." - http://darksleep.com/notablog


From ggregory@seagullsoftware.com  Mon Dec  6 19:59:30 2004
From: ggregory@seagullsoftware.com (Gary Gregory)
Date: Mon, 6 Dec 2004 14:59:30 -0500
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <2B64219028BBFF48B3CC957EF10B58FE45F7A8@ns1018.SSSI.seagull.nl>

For us, the reason that we are "stuck" on 1.3.1 is that we have some
customers that are themselves "stuck", for whatever reasons, on a
version of IBM WebSphere that is bound to 1.3.1. So if we move beyond
1.3.1, we would not be able to support these customers.

Gary

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Doug Lea
Sent: Monday, December 06, 2004 4:57 AM
To: concurrency-interest@altair.cs.oswego.edu
Subject: [concurrency-interest] Why not J2SE 5?


I'm starting to wonder why there's so much resistance out there to
changing from 1.x to J2SE5 (1.5). Having seen how obsessed the Sun
J2SE5 release managers and engineers were with back-compatibility, and
the huge numbers of regression tests run, and the very large number of
bug-fixes and performance improvements in J2SE5, I honestly don't know
of a good technical reason not to switch over to it, even (or
especially?) if people don't need new functionality. I suppose some of
it might be just be fear of any x.0 release (to be addressed soon, I
think, with the first "underscore" release, "1.5_01" or somesuch
name). And maybe it takes time to install/deploy new JVMs across all
machines etc. But is there some more fundamental reason that I'm
overlooking?

-Doug



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From ggregory@seagullsoftware.com  Mon Dec  6 20:05:13 2004
From: ggregory@seagullsoftware.com (Gary Gregory)
Date: Mon, 6 Dec 2004 15:05:13 -0500
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <2B64219028BBFF48B3CC957EF10B58FE45F7AE@ns1018.SSSI.seagull.nl>

Doung wrote: "1. No J2SE 5 JVMs on some platforms
   Does anyone know the details of upcoming support on
    * Eclipse"

AFAIK, 1.5 support is slated for Eclipse version 3.1. In the current
milestone release, 3.1M3, 1.5 support is only partial.

Gary


From Hanson Char <hanson.char@gmail.com>  Mon Dec  6 20:40:47 2004
From: Hanson Char <hanson.char@gmail.com> (Hanson Char)
Date: Tue, 7 Dec 2004 07:40:47 +1100
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au>
References: <ca53c8f8041206054547541745@mail.gmail.com>
 <NFBBKALFDCPFIDBNKAPCKELGFBAA.dholmes@dltech.com.au>
Message-ID: <ca53c8f804120612406dff2157@mail.gmail.com>

Using -source 1.4 doesn't make sense for development to move to 1.5 as
there is no or littel benefit of doing so.  What I wish is:

javac -target 1.4 -source 1.5 Foo.java

Hanson

On Mon, 6 Dec 2004 23:59:28 +1000, David Holmes <dholmes@dltech.com.au> wrote:
> > I wish jdk1.5 had the option of compiling into at least jdk1.4 byte
> > code.  So even though production systems still need to stay with 1.4,
> > development can start moving to 1.5.
> 
> It does! Use the -source and -target options on javac eg:
> 
> javac -target 1.4 -source 1.4 Foo.java
> 
> David Holmes
>

From dholmes@dltech.com.au  Mon Dec  6 21:25:55 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 7 Dec 2004 07:25:55 +1000
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <ca53c8f804120612406dff2157@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEMHFBAA.dholmes@dltech.com.au>

Hanson char wrote:
> Using -source 1.4 doesn't make sense for development to move to 1.5 as
> there is no or littel benefit of doing so.  What I wish is:
>
> javac -target 1.4 -source 1.5 Foo.java

But most 1.5 features require 1.5 bytecode and or classes. So what would
this gain you?

I had assumed the intent was to have a single 5.0 development environment
where you could build your 1.4 production system and at the same time
experiment with 5.0 features seperately.

David Holmes


From dholmes@dltech.com.au  Mon Dec  6 21:35:49 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 7 Dec 2004 07:35:49 +1000
Subject: [concurrency-interest] BlockingQueue.drainTo
In-Reply-To: <41B3F460.7020104@videotron.ca>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEMIFBAA.dholmes@dltech.com.au>

Jean Morissette wrote:
> Could you tell me why method drainTo is in BlockingQueue instead of Queue?

drainTo provides the capability for a "bulk poll" operation which is only
needed in a concurrently accessed queue. Queue is not specified for
concurrent use while BlockingQueue is.

It would be possible to have a concurrent implementation of Queue that
chooses not to also be a BlockingQueue, and which might also want a drainTo
method.

David Holmes


From A.Solofnenko@mdl.com  Mon Dec  6 22:07:12 2004
From: A.Solofnenko@mdl.com (Alexey N. Solofnenko)
Date: Mon, 06 Dec 2004 14:07:12 -0800
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEMHFBAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCOEMHFBAA.dholmes@dltech.com.au>
Message-ID: <41B4D810.8060402@mdl.com>

Generics do not seem to require any JVM changes. This is one of the 
features I would want to use with JDK 1.4 too.

- Alexey.

David Holmes wrote:

>Hanson char wrote:
>  
>
>>Using -source 1.4 doesn't make sense for development to move to 1.5 as
>>there is no or littel benefit of doing so.  What I wish is:
>>
>>javac -target 1.4 -source 1.5 Foo.java
>>    
>>
>
>But most 1.5 features require 1.5 bytecode and or classes. So what would
>this gain you?
>
>I had assumed the intent was to have a single 5.0 development environment
>where you could build your 1.4 production system and at the same time
>experiment with 5.0 features seperately.
>
>David Holmes
>
>  
>


From osvaldo@visionnaire.com.br  Tue Dec  7 13:02:01 2004
From: osvaldo@visionnaire.com.br (Osvaldo Pinali Doederlein)
Date: Tue, 07 Dec 2004 10:02:01 -0300
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGELOFBAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCGELOFBAA.dholmes@dltech.com.au>
Message-ID: <41B5A9C9.3080008@visionnaire.com.br>

David Holmes wrote:
> Osvaldo writes:
>>Then why two switches, sourge & target?  A single switch would do it.
> Historically the target and source values have not been tied - in
> fact -source came much later than -target. With the later releases you are
> forced to keep them upwardly compatible:
>   -source 1.4 requires -target 1.4+
>   -source 1.5 requires -target 1.5+
> but source 1.3 does not require -target 1.3+

I haven't noticed this recent change... perhaps because I've been using
only Eclipse since 1.0, and its compiler is much more flexible on this:
I can easily setup a project for J2SE1.4 compliance, but with source
compatibility at 1.3 and classfile compatibility to 1.1, and independent
of this, chose whether identifiers named 'assert' (and now, 'enum') are
flagged as errors, warnings or ignored... not to mention other details,
like inlining finally blocks to avoid JSR (mandatory only in J2SE 5.0).
Only under J2SE5.0 compliance, I see that not even Eclipse allows me to
output 1.4-compatible classfiles; but I hope this may change (people
behind projects like RetroWeaver could certainly "fix" this...).

> I work on a system which requires -target 1.1 hence we can't use new source
> features from 1.4 or 1.5.

Try Eclipse's compiler.  Even if you prefer another IDE, you can just
use its compiler.  There's no stand-alone distribution (yet), but it's
easy to extract it from the SDK; for example, the latest Tomcat (5.5.x)
bundles Eclipse's compiler (a 900Kb common/lib/jasper-compiler-jdt.jar).
Check also ftp://sources.redhat.com/pub/rhug/ecj, that's the stand-alone
Eclipse compiler that was compiled to native code (Linux/x86) with gcj,
but unfortunately this is not updated since July 2003.  So you probably
want to follow these instructions:

http://dev.eclipse.org/viewcvs/index.cgi/~checkout~/jdt-core-home/howto/batch%20compile/batchCompile.html

Except for Eclipse-specific options like its multitude of line-style
warnings, the switches are similar to javac, so it should be easy to
update your ant buildfiles or similar.

Another option: http://www-124.ibm.com/developerworks/opensource/jikes/
This compiler is also more flexible than javac, in -source/-target.
It happily accepts -source 1.4 -target 1.3, for example.

> Other people who haven't migrated to asserts yet might use source 1.3 but
> allow the default target 1.5

That was a huge problem for me a few years ago, when I really wanted to
use asserts in a critical software component that must be compatible
down to J2SE1.2 at that time (and 1.3 still today).  I had to resort to
a complicated Ant script that would create a copy of the source code,
filtering out all lines of code containing assert statements, and then
compile that code with lesser -source/-target options.  Only recently I
discovered that jikes offers a wonderful switch ("--assert" or "+a")
that makes the compiler discard completely the assert statements, so
I can compile that unmodifiable source to older J2SE's.  WAY cool...
Essential feature if you ask me.  I only wish Eclipse could do the same.

It's clear that there's a huge demand from developers for a smoother
compatibility path between versions of the J2SE.  Eclipse and Jikes are
the only alternative compilers that I have investigated, and both of
them are nicer than javac in this respect -- I wonder if others, like
gcj, have similar compatibility features.

Gregg Wonderly wrote:
 > The standing issue is that a specification would have to exist for
 > this version of Java, or Sun would be breaking the rules in a way
 > similar to what Microsoft went to court over.  So, the reality is
 > that it can't be done "easily", and the benefits, while seemingly
 > strong, would only, in the end, slow adoption.

I don't think the specification is a big issue, as long a Sun doesn't
make these features default.  Use extended ("-X...") switches to enable
these options, and declare them unsupported, and all is well. Microsoft
was wrong here because they enbled extensions by default, not to mention
other very incompatible practices like removing entire APIs, or adding
new public methods to standard APIs.  And Sun wouldn't be inventing new
language features, they would just be making available some features of
modern J2SEs (all blessed by JCP specs) in non-standard circumstances
(supporting older JREs, and in some cases supported partially, e.g. if
assert statements are accepted but handled as no-ops, or if enums are
compiled in a way that requires an extension jar in the bootclasspath
and lacks on-the-wire serialization compatiblity with J2SE5.0). The only
important thing is passing the JCK -- and Eclipse's compiler does it,
so the JCK for javac does not forbid these careful extensions.

A+
Osvaldo

-- 
-----------------------------------------------------------------------
Osvaldo Pinali Doederlein                   Visionnaire Informática S/A
osvaldo@visionnaire.com.br                http://www.visionnaire.com.br
Arquiteto de Tecnologia                          +55 (41) 337-1000 #223


From a.solofnenko@mdli.com  Tue Dec  7 15:06:40 2004
From: a.solofnenko@mdli.com (Alexey N. Solofnenko)
Date: Tue, 07 Dec 2004 07:06:40 -0800
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <007e01c4dc22$4e1256c0$0200a8c0@REPLICANT2>
References: <NFBBKALFDCPFIDBNKAPCOEMHFBAA.dholmes@dltech.com.au> <41B4D810.8060402@mdl.com> <007e01c4dc22$4e1256c0$0200a8c0@REPLICANT2>
Message-ID: <41B5C700.3000901@mdli.com>

That is true, but the whole point of erasure is backward compatibility 
so the generics could be used with any JVM. Compiler does most of the 
work. I would not get extended reflection, but I do not use it too often.

- Alexey.

Joe Bowbeer wrote:

>The JVM was changed to use the additional generic info added to the class 
>format, right?
>
>See  java.lang.reflect.GenericSignatureFormatError, for example.
>
>
>----- Original Message ----- 
>From: "Alexey N. Solofnenko" <A.Solofnenko@mdl.com>
>To: <concurrency-interest@altair.cs.oswego.edu>
>Sent: Monday, December 06, 2004 2:07 PM
>Subject: Re: [concurrency-interest] Why not J2SE 5?
>
>
>Generics do not seem to require any JVM changes. This is one of the
>features I would want to use with JDK 1.4 too.
>
>- Alexey.
>
>David Holmes wrote:
>
>  
>
>>Hanson char wrote:
>>
>>
>>    
>>
>>>Using -source 1.4 doesn't make sense for development to move to 1.5 as
>>>there is no or littel benefit of doing so.  What I wish is:
>>>
>>>javac -target 1.4 -source 1.5 Foo.java
>>>
>>>
>>>      
>>>
>>But most 1.5 features require 1.5 bytecode and or classes. So what would
>>this gain you?
>>
>>I had assumed the intent was to have a single 5.0 development environment
>>where you could build your 1.4 production system and at the same time
>>experiment with 5.0 features seperately.
>>
>>David Holmes
>>
>>
>>
>>    
>>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>  
>

From ggregory@seagullsoftware.com  Tue Dec  7 19:19:57 2004
From: ggregory@seagullsoftware.com (Gary Gregory)
Date: Tue, 7 Dec 2004 14:19:57 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of JSR166 to Java 1.4 available
Message-ID: <2B64219028BBFF48B3CC957EF10B58FE45F89E@ns1018.SSSI.seagull.nl>

Hello,

The distribution does not contain PooledExecutor [1], but the site seems
to say it should be included in the backport:

    "All JSR 166 executors, utilities, and everything related (thread
pools, FutureTask, scheduled tasks and executors, etc)"

?

Gary

[1]
http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/Poo
ledExecutor.html


-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
Kurzyniec
Sent: Wednesday, December 01, 2004 3:06 PM
To: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Announcing: release 1.0 of backport
of JSR166 to Java 1.4 available

Gary Gregory wrote:

>Hi,
>
>Anything for us poor saps (am I the only one ;-) still stuck on 1.3.1?
>
>Thanks,
>Gary
>
>-----Original Message-----
>From: concurrency-interest-admin@cs.oswego.edu
>[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
>Kurzyniec
>Sent: Wednesday, December 01, 2004 11:53 AM
>To: concurrency-interest@altair.cs.oswego.edu
>Subject: [concurrency-interest] Announcing: release 1.0 of backport of
>JSR166 to Java 1.4 available
>
>
>http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/
>
>  
>
I haven't actually tried it yet, but I think that there is a very good 
chance that the backport works and compiles with older JREs, too, maybe 
even starting with Java 1.2. In the worst case, it may require minor 
changes in some files. Why don't you try it out and share your
experiences?

Regards,
Dawid

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From ggregory@seagullsoftware.com  Tue Dec  7 19:25:06 2004
From: ggregory@seagullsoftware.com (Gary Gregory)
Date: Tue, 7 Dec 2004 14:25:06 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of JSR166 to Java 1.4 available
Message-ID: <2B64219028BBFF48B3CC957EF10B58FE45F8A1@ns1018.SSSI.seagull.nl>

Oops, my bad, the class name was changed for 1.5.

BTW, is there a proper build.xml available to jar and test this? I did
not see it in the distro.

Thanks,
Gary

-----Original Message-----
From: Gary Gregory 
Sent: Tuesday, December 07, 2004 11:14 AM
To: 'Dawid Kurzyniec'; concurrency-interest@altair.cs.oswego.edu
Subject: RE: [concurrency-interest] Announcing: release 1.0 of backport
of JSR166 to Java 1.4 available

Hello,

The distribution does not contain PooledExecutor [1], but the site seems
to say it should be included in the backport:

    "All JSR 166 executors, utilities, and everything related (thread
pools, FutureTask, scheduled tasks and executors, etc)"

?

Gary

[1]
http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/Poo
ledExecutor.html


-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
Kurzyniec
Sent: Wednesday, December 01, 2004 3:06 PM
To: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Announcing: release 1.0 of backport
of JSR166 to Java 1.4 available

Gary Gregory wrote:

>Hi,
>
>Anything for us poor saps (am I the only one ;-) still stuck on 1.3.1?
>
>Thanks,
>Gary
>
>-----Original Message-----
>From: concurrency-interest-admin@cs.oswego.edu
>[mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf Of Dawid
>Kurzyniec
>Sent: Wednesday, December 01, 2004 11:53 AM
>To: concurrency-interest@altair.cs.oswego.edu
>Subject: [concurrency-interest] Announcing: release 1.0 of backport of
>JSR166 to Java 1.4 available
>
>
>http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/
>
>  
>
I haven't actually tried it yet, but I think that there is a very good 
chance that the backport works and compiles with older JREs, too, maybe 
even starting with Java 1.2. In the worst case, it may require minor 
changes in some files. Why don't you try it out and share your
experiences?

Regards,
Dawid

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dawidk@mathcs.emory.edu  Wed Dec  8 00:59:27 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 07 Dec 2004 19:59:27 -0500
Subject: [concurrency-interest] Announcing: release 1.0 of backport of
 JSR166 to Java 1.4 available
In-Reply-To: <2B64219028BBFF48B3CC957EF10B58FE45F8A1@ns1018.SSSI.seagull.nl>
References: <2B64219028BBFF48B3CC957EF10B58FE45F8A1@ns1018.SSSI.seagull.nl>
Message-ID: <41B651EF.1040004@mathcs.emory.edu>

Gary Gregory wrote:

> BTW, is there a proper build.xml available to jar and test this? I did
> not see it in the distro.
>  
>
Not in the distro, but you can download tarball from the CVS:

http://dcl.mathcs.emory.edu/cgi-bin/viewcvs.cgi/software/util/backport-util-concurrent/backport-util-concurrent.tar.gz?tarball=1 


I just noticed that some source file names are truncated in the tarball, 
most likely because they are too long. I must look into this. 
Nevertheless, test classes are OK, so by merging with the sources from 
the distribution you will be able to get what you need.

Or, you can get the rest of sources correctly via
http://dcl.mathcs.emory.edu/cgi-bin/viewcvs.cgi/software/util/backport-util-concurrent/src/edu/emory/mathcs/backport/java/util/util.tar.gz?tarball=1 


(no ant script yet, I am working on that; but tests should be easy to 
figure out)

Regards,
Dawid




From jean.morissette666@videotron.ca  Wed Dec  8 06:07:30 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 08 Dec 2004 01:07:30 -0500
Subject: [concurrency-interest] Queue Predicate
Message-ID: <41B69A22.6030209@videotron.ca>

Hi,
I actually contribute to the development of Sandstorm, a Staged 
Event-Driven Architecture (SEDA) based high-performance platform for 
services http://www.eecs.harvard.edu/~mdw/proj/seda/

Presently, each services (stage) has its own queue and a queue can be 
associated with a predicate.  The enqueue operation succeed only if the 
predicate accept the element that we want to enqueue.  There are 
actually two type of predicates: QueueThresholdPredicate and 
RateLimitingPredicate.

But now, I want to add blocking enqueue operations and I don't know how 
to integrate the predicate with the blocking queues implementations.  I 
also want to unify the two types of predicate.

Here is an example of a method enqueue that don't use the predicate API:

public boolean enqueue_lossy(QueueElementIF x, int msecs)
     throws InterruptedException {
   if (x == null) throw new IllegalArgumentException();
   if (Thread.interrupted()) throw new InterruptedException();
   synchronized (putMonitor) {
     long start = (msecs <= 0) ? 0 : System.currentTimeMillis();
     long waitTime = msecs;
     while (emptySlots <= 0) {
       if (waitTime <= 0) return false;
       ++waitingPuts;
       try {
         putMonitor.wait(waitTime);
       } catch (InterruptedException ex) {
         putMonitor.notify();
         throw ex;
       } finally {
         --waitingPuts;
       }
       waitTime = msecs - (System.currentTimeMillis() - start);
     }
     insert(x);
   }
   incUsedSlots();
   return true;
}


Should be something maybe like:

public boolean enqueue_lossy(QueueElementIF x, int msecs)
     throws InterruptedException {
   if (x == null) throw new IllegalArgumentException();
   if (Thread.interrupted()) throw new InterruptedException();
   predicate.blockingAcceptAcquire(x, msecs);
   insert(x);
   predicate.blockingAcceptRelease();
   incUsedSlots();
   return true;
}


So, I'm wondering if we could implement, in a elegant way, the 
predicates like a Semaphore?

Thanks for your advices

Jean




From jean.morissette666@videotron.ca  Mon Dec 13 03:44:14 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Sun, 12 Dec 2004 22:44:14 -0500
Subject: [concurrency-interest] Queue Predicate
In-Reply-To: <41B69A22.6030209@videotron.ca>
References: <41B69A22.6030209@videotron.ca>
Message-ID: <41BD100E.40009@videotron.ca>

I am wondering if it's possible to create a queue that can be 
parameterized with a strategy object to configure its locking behaviour.

By exemple, could it be possible to have a _reusable_ strategy object 
(maybe something like a semaphore) that can handle the queue capacity 
for _different_ queue implementations?

Thanks,
Jean


From f.spinazzi@masterhouse.it  Mon Dec 13 13:25:41 2004
From: f.spinazzi@masterhouse.it (Federico Spinazzi)
Date: Mon, 13 Dec 2004 14:25:41 +0100
Subject: [concurrency-interest] [OT]: test cases for a .NET port
In-Reply-To: <41BD100E.40009@videotron.ca>
References: <41B69A22.6030209@videotron.ca> <41BD100E.40009@videotron.ca>
Message-ID: <41BD9855.6060406@masterhouse.it>

Well,
a little embarassed to ask here, but as I've ported a good number of 
classes of 1.3.4 to c# (the package is so cool) I'd like to ask if there 
are any tests cases available.
Many many thanks.
Federico Spinazzi


From dl@cs.oswego.edu  Mon Dec 13 13:33:33 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 13 Dec 2004 08:33:33 -0500
Subject: [concurrency-interest] Queue Predicate
In-Reply-To: <41BD100E.40009@videotron.ca>
References: <41B69A22.6030209@videotron.ca>
 <41BD100E.40009@videotron.ca>
Message-ID: <16829.39469.244538.112078@altair.cs.oswego.edu>

> I am wondering if it's possible to create a queue that can be 
> parameterized with a strategy object to configure its locking behaviour.
> 

The short answer is that most ways of going about this don't work out.
Several academic researchers explored this and related topics in the
1990s, leading to a bunch of papers, mainly on the "inheritance
anomaly".  A brief summary is in my CPJ book. David Holmes's PhD
thesis ("Synchronization Rings Composable Synchronization for
Object-Oriented Systems") has a very good discussion, but I don't see
it available online. You'd want to read these and related papers
before getting too far into this.

-Doug


From jean.morissette666@videotron.ca  Mon Dec 13 16:30:26 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Mon, 13 Dec 2004 11:30:26 -0500
Subject: [concurrency-interest] Strange behaviour with LinkedBlockingQueue JDK 1.4 backport
Message-ID: <41BDC3A2.4070706@videotron.ca>

Hi,
Running this test on 
edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue cause 
the Producer and Consumer threads to block indefinitely.  Am I missing 
something?

public class QueueTest {

   private static final int CAPACITY = 10;
   static LinkedBlockingQueue q = new LinkedBlockingQueue(CAPACITY);

   static class Producer implements Runnable {
     public void run() {
       while (true) {
         try {
           q.put(new Object());
         } catch (Exception e) {
           e.printStackTrace();
         }
       }
     }
   }

   static class Consumer implements Runnable {
     int i;
     public void run() {
       List list = new ArrayList();
       int size = 0;
       long t1 = System.currentTimeMillis();
       while (true) {
         try {
           q.drainTo(list);
           size = list.size();
           i += size;
           list.clear();
           if (i >= 5) break;
         } catch (Exception e) {
           e.printStackTrace();
         }
       }
       long t2 = System.currentTimeMillis();
       System.out.println("time = " + (t2 -t1));
     }
   }

   public static void main(String[] args) throws InterruptedException {
     new Thread(new Consumer()).start();;
     new Thread(new Producer()).start();;

     while (true) {
       Thread.sleep(10000000);
     }
   }

}


From dawidk@mathcs.emory.edu  Mon Dec 13 17:16:44 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 13 Dec 2004 12:16:44 -0500
Subject: [concurrency-interest] Strange behaviour with LinkedBlockingQueue
 JDK 1.4 backport
In-Reply-To: <41BDC3A2.4070706@videotron.ca>
References: <41BDC3A2.4070706@videotron.ca>
Message-ID: <41BDCE7C.8020109@mathcs.emory.edu>

Jean Morissette wrote:

> Hi,
> Running this test on 
> edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue 
> cause the Producer and Consumer threads to block indefinitely.  Am I 
> missing something?

Hello Jean,

There is a bug in LinkedBlockingQueue that causes this code to deadlock. 
Also the clear() method is affected. I have fixed it (hopefully I got it 
right this time) and put in CVS; it will be a couple more days before I 
prepare new distribution but meanwhile, the new source file is available at:

http://dcl.mathcs.emory.edu/cgi-bin/viewcvs.cgi/software/util/backport-util-concurrent/src/edu/emory/mathcs/backport/java/util/concurrent/LinkedBlockingQueue.java

Thanks for reporting this.

Regards,
Dawid


From kris@dotech.com  Mon Dec 13 17:46:24 2004
From: kris@dotech.com (Kris Schneider)
Date: Mon, 13 Dec 2004 12:46:24 -0500
Subject: [concurrency-interest] Strange behaviour with LinkedBlockingQueue JDK 1.4 backport
In-Reply-To: <41BDC3A2.4070706@videotron.ca>
References: <41BDC3A2.4070706@videotron.ca>
Message-ID: <1102959984.41bdd5703fae2@webmail.dotech.com>

This seems to work fine on my single-CPU WinXP laptop:

import edu.emory.mathcs.backport.java.util.concurrent.*;
import java.util.*;

public class QueueTest {

    private static final int CAPACITY = 10;
    private static final LinkedBlockingQueue Q = new
LinkedBlockingQueue(CAPACITY);

    private static class Producer implements Runnable {
        public void run() {
            while (true) {
                try {
                    Q.put(new Object());
                    Thread.yield();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private static class Consumer implements Runnable {
        private static final int MAX = 50000;
        public void run() {
            long t1 = System.currentTimeMillis();
            List list = new ArrayList();
            int i = 0;
            while (i < MAX) {
                i += Q.drainTo(list);
                list.clear();
                Thread.yield();
            }
            long t2 = System.currentTimeMillis();
            System.out.println("time = " + (t2 - t1) + "ms");
        }
    }

    public static void main(String[] args) {
        Thread c = new Thread(new Consumer());
        c.start();

        Thread p = new Thread(new Producer());
        p.setDaemon(true);
        p.start();
    }
}

Quoting Jean Morissette <jean.morissette666@videotron.ca>:

> Hi,
> Running this test on 
> edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue cause 
> the Producer and Consumer threads to block indefinitely.  Am I missing 
> something?

8< snip >8

-- 
Kris Schneider <mailto:kris@dotech.com>
D.O.Tech       <http://www.dotech.com/>

From jean.morissette666@videotron.ca  Mon Dec 13 18:05:42 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Mon, 13 Dec 2004 13:05:42 -0500
Subject: [concurrency-interest] Strange behaviour with LinkedBlockingQueue
 JDK 1.4 backport
In-Reply-To: <1102959984.41bdd5703fae2@webmail.dotech.com>
References: <41BDC3A2.4070706@videotron.ca>
 <1102959984.41bdd5703fae2@webmail.dotech.com>
Message-ID: <41BDD9F6.4060303@videotron.ca>

Kris Schneider wrote:
> This seems to work fine on my single-CPU WinXP laptop:

You can remove the 'Thread.yield()' statements to increase the chance to 
see the bug.


From kris@dotech.com  Mon Dec 13 18:09:33 2004
From: kris@dotech.com (Kris Schneider)
Date: Mon, 13 Dec 2004 13:09:33 -0500
Subject: [concurrency-interest] Strange behaviour with LinkedBlockingQueue JDK 1.4 backport
In-Reply-To: <41BDD9F6.4060303@videotron.ca>
References: <41BDC3A2.4070706@videotron.ca> <1102959984.41bdd5703fae2@webmail.dotech.com> <41BDD9F6.4060303@videotron.ca>
Message-ID: <1102961373.41bddadda5ed4@webmail.dotech.com>

Agreed. I thought you were interested in a possible work-around...

Quoting Jean Morissette <jean.morissette666@videotron.ca>:

> Kris Schneider wrote:
> > This seems to work fine on my single-CPU WinXP laptop:
> 
> You can remove the 'Thread.yield()' statements to increase the chance to 
> see the bug.

-- 
Kris Schneider <mailto:kris@dotech.com>
D.O.Tech       <http://www.dotech.com/>

From puff@darksleep.com  Tue Dec 14 07:55:48 2004
From: puff@darksleep.com (Steven J. Owens)
Date: Tue, 14 Dec 2004 02:55:48 -0500
Subject: [concurrency-interest] Why not J2SE 5?
Message-ID: <20041214075548.GB3435@darksleep.com>

     Third time's the charm... hopefully this time my post'll get
through.  Looks like something odd happened to the first two, they
somehow got routed to "concurrenct-interest" instead of
"concurrency-interest".

     I'm reposting with minor corrections (mainly
changing my typo of "1.6" to "1.1.6").

On Mon, Dec 06, 2004 at 12:11:12PM -0500, Dave Dice wrote:
> | I'm starting to wonder why there's so much resistance out 
> | there to changing from 1.x to J2SE5 (1.5). [...] I honestly
> | don't know of a  good technical reason not to switch over [...]

     I can't help but wonder if my post had something to do with this
topic coming up :-).

> I think folks on this list have iterated over the major reasons that
> 1.5 adoption might be a bit slower than we'd prefer.  In particular,
> Michael Ogg hit the nail directly on the head with his comments
> about QA costs.  Say you're in a corporate IT shop.  If the old JVM
> isn't giving you problems it's extremely difficult to justify
> changing JVM versions.

     Yup, the old "if it ain't broke, don't fix it" argument.  In my
case it's a little easier in some ways - I'm the top technical guy at
our small software company (8 people, 4 of them technical).  So the
decision is pretty much in my lap.  On the other hand, we have a tiny
staff and we only have so much time to go around.  If I could wave my
magic wand and have us running on JDK 1.5 and tomcat 5.x and *know*,
know with the same certainty we have from running our app in
production use on JDK 1.4 and tomcat 4.3x for eighteen months, that
it'll all work smoothly, we would.

     As it is, it's not that I'm resisting upgrading, it's just that
it hasn't percolated through our strategic to-do list yet.  We do have
one of our team using tomcat 5.x in his development environment, and
I'd like to get us using JDK 1.5 soon, even though we'll almost
certainly stay inside the JDK 1.4 feature envelope for the foreseeable
future (except, perhaps for the use of concurrency).

     There's also the issue of minimizing the variables in each
major change, and since development is an ongoing process... 

     In fact, looking at this in retrospect,  I'd say this is
probably the biggest issue.  It's not so much that I think 1.5
will break anything, as that I don't have the time to make just
this one major change, not change anything else, and watch for
a while.

> There's risk and considerable QA + deployment expense, so you have
> to be able to identify some advantage to using the new JVM.  It's
> very common to see enterprise customers lock down on a specific
> configuration (JVM version, hardware, OS), put that configuration
> through rigorous qualification, and then standardize on the
> configuration for large fractions of a decade.

     I agree, except for the part about "rigorous qualifications" :-).
I know of a large financial institution that standardized on JDK 1.1.6
when that was mainstream.  They were still using it in 2000.  I
believe they're a little bit beyond 1.1.6 now, but I wouldn't bet
money on it.

     Large organizations tend to sink a lot of time into risk
brokering strategies.  Note, I don't say necessarily risk _avoidance_
strategies :-).  As an example, say they need to solve a problem.
Somebody will see that problem as an opportunity (to expand their
kingdom) and will tackle it.  But they'll set up a committee, have a
lot of meetings, and get a lot of buy-in from other people at their
level in the organization.  This spreads the risk around.

     At some point they may decide that it's a technical risk (pretty
much at any point where it becomes apparent that the project isn't a
no-brainer).  Then they decide they need to go get an outside
consulting organization, say Sun's consulting arm.  This is a great
risk-brokering strategy - not because the consulting team is any less
risky than their own staff, but because the process of bringing the
consulting team in involves a lot of meetings, an approved vendor
list, a lot of higher-level buy-in.  In the end, a lot more people are
implicated in the decision - people who might otherwise be the ones
pointing the finger if anything goes wrong.

     Worst case scenario, it also gives them a convenient external
target to deflect blame onto, "Hey, I hired Sun consulting guys to do
the java stuff, what more could I do?"  (add to which the implied:
"After all, you guys approved them as a vendor...")

     Now, if this sort of dance goes on at the managerial level, how
readily do you think they'll take major steps at the technical level?

> Often, the only thing that'll precipitate a change is if one of the
> components slips outside a vendors support window.  Typically, a
> corporate-wide hardware upgrade will cause a shift.  At that point
> he apps, OS, JVM and hardware will be re-tested and upgraded in
> unison.  The upgrade cycles are quite long.  Like it or not, there
> are still quite a few 1.2.2s and 1.3.0s out there.

     Case in point, the financial organization I spoke of above.  Most
likely they upgraded when they moved to using EJB servers, which I
think they did in mid-late 2000.

-- 
Steven J. Owens
puff@darksleep.com

"I'm going to make broad, sweeping generalizations and strong,
 declarative statements, because otherwise I'll be here all night and
 this document will be four times longer and much less fun to read.
 Take it all with a grain of salt." - http://darksleep.com/notablog


From bnewport@us.ibm.com  Tue Dec 14 17:53:42 2004
From: bnewport@us.ibm.com (Billy Newport)
Date: Tue, 14 Dec 2004 11:53:42 -0600
Subject: [concurrency-interest] Billy Newport/Rochester/IBM is out of the office.
Message-ID: <OF84247527.8F6C5EBC-ON86256F6A.00624CDC-86256F6A.00624CDD@us.ibm.com>

I will be out of the office starting  12/14/2004 and will not return until
12/15/2004.



From eqmel@comcast.net  Wed Dec 15 00:33:50 2004
From: eqmel@comcast.net (Ron Bense)
Date: Tue, 14 Dec 2004 18:33:50 -0600
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <20041214075548.GB3435@darksleep.com>
References: <20041214075548.GB3435@darksleep.com>
Message-ID: <41BF866E.5040108@comcast.net>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
</head>
<body bgcolor="#ffffff" text="#000000">
Steven J. Owens wrote:
<blockquote cite="mid20041214075548.GB3435@darksleep.com" type="cite">
  <pre wrap=""> </pre>
  <blockquote type="cite">
    <pre wrap="">I think folks on this list have iterated over the major reasons that
1.5 adoption might be a bit slower than we'd prefer.  In particular,
Michael Ogg hit the nail directly on the head with his comments
about QA costs.  Say you're in a corporate IT shop.  If the old JVM
isn't giving you problems it's extremely difficult to justify
changing JVM versions.
    </pre>
  </blockquote>
  <pre wrap=""><!---->
     Yup, the old "if it ain't broke, don't fix it" argument.  In my
case it's a little easier in some ways - I'm the top technical guy at
our small software company (8 people, 4 of them technical).  So the
decision is pretty much in my lap.  On the other hand, we have a tiny
staff and we only have so much time to go around.  If I could wave my
magic wand and have us running on JDK 1.5 and tomcat 5.x and *know*,
know with the same certainty we have from running our app in
production use on JDK 1.4 and tomcat 4.3x for eighteen months, that
it'll all work smoothly, we would.
  </pre>
</blockquote>
I'll add to the old "if it ain't broke, don't fix it" argument. There
may be something broken, and there may be a work around, so it's not a
major push although it's a performance hit. <br>
<br>
However, when your main product, say an appserver, doesn't migrate
until much much later, and you use a lot of parts of that appservers
proprietary services (old system) and it takes you almost a year to
migrate your current code base to the new version of the appserver...
you'll be happy just running 1.4.x now, as just happened at my
workplace - we migrated to 1.4.x just a couple of months ago, and it
was rather painful. <br>
<br>
It's not a perfect scenario, but the current solution works and drives
significant business, so there's lots of risk involved in upgrades, and
they're done very slowly. Part of that risk involves the work of
outside consultants who tied things together that maybe shouldn't have
been tied. Other risks are driven by that pre-mentioned proprietary
services (we all know how well those migrate within a single vendors
upgrades....) <br>
<br>
Anyways, when you're wondering about the "resistance" of migration,
rest assured that people like me would love to develop on the new JVM,
but reality puts a major brake on our desires. This leaves those of us
in my situation to tinker with it off-hours, which is a slow-go at best.<br>
<br>
Ron<br>
<br>
</body>
</html>

From eqmel@comcast.net  Wed Dec 15 04:37:48 2004
From: eqmel@comcast.net (Ron Bense)
Date: Tue, 14 Dec 2004 22:37:48 -0600
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41BFAF4D.5010604@cytetech.com>
References: <20041214075548.GB3435@darksleep.com> <41BF866E.5040108@comcast.net> <41BFAF4D.5010604@cytetech.com>
Message-ID: <41BFBF9C.8000706@comcast.net>

Gregg Wonderly wrote:

> <soapbox>
> And this is why the J2EE container architecture is not really a 
> solution.  It might provide some conveniences and some packaging that 
> seems to enable solutions, but in the end it creates such a huge 
> amount of dependency on the container that all forward progress 
> stops.  Jini on the other hand constantly suggests that you can 
> separate things and make them independent of each other and use 
> functional interfaces that free you from data binding translations and 
> other amazingly obtuse programming practices.
> </soapbox>
>
> There, I said it, now on to the subject of this list...

Before we return to our regularly scheduled concurrency discussion....

I agree with most of your soapbox, but I think you're too narrowly 
focused. I'd extend your argument to any non-transparent proprietary 
container service. Portal servers, or appserver proprietary layers for 
additional functionality, for example, assuming that you have capable 
developers on hand to design and construct what's needed.

Shortened to not stray too far off topic.

Ron

From gregg.wonderly@pobox.com  Wed Dec 15 03:28:13 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 14 Dec 2004 21:28:13 -0600
Subject: [concurrency-interest] Why not J2SE 5?
In-Reply-To: <41BF866E.5040108@comcast.net>
References: <20041214075548.GB3435@darksleep.com> <41BF866E.5040108@comcast.net>
Message-ID: <41BFAF4D.5010604@cytetech.com>

Ron Bense wrote:
> However, when your main product, say an appserver, doesn't migrate until 
> much much later, and you use a lot of parts of that appservers 
> proprietary services (old system) and it takes you almost a year to 
> migrate your current code base to the new version of the appserver... 
> you'll be happy just running 1.4.x now, as just happened at my workplace 
> - we migrated to 1.4.x just a couple of months ago, and it was rather 
> painful.

<soapbox>
And this is why the J2EE container architecture is not really a 
solution.  It might provide some conveniences and some packaging that 
seems to enable solutions, but in the end it creates such a huge amount 
of dependency on the container that all forward progress stops.  Jini on 
the other hand constantly suggests that you can separate things and make 
them independent of each other and use functional interfaces that free 
you from data binding translations and other amazingly obtuse 
programming practices.
</soapbox>

There, I said it, now on to the subject of this list...

Gregg

From jean.morissette666@videotron.ca  Fri Dec 17 04:51:10 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Thu, 16 Dec 2004 23:51:10 -0500
Subject: [concurrency-interest] Bulk queue operations
Message-ID: <41C265BE.7@videotron.ca>

Hi,
Could you tell me why Queue or BlockingQueue don't provide atomic bulk 
operations like offerMany, putMany and takeMany?

Thanks,
Jean

From dholmes@dltech.com.au  Fri Dec 17 05:25:00 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 17 Dec 2004 15:25:00 +1000
Subject: [concurrency-interest] Bulk queue operations
In-Reply-To: <41C265BE.7@videotron.ca>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEHEFCAA.dholmes@dltech.com.au>

> Could you tell me why Queue or BlockingQueue don't provide atomic bulk
> operations like offerMany, putMany and takeMany?

If the intent of these bulk operations is to offer/put/take the next n
elements - ensuring no other producers/consumers get to touch the queue in
between - then only certain types of implementation can easily support such
semantics ie lock-based implementations. Such operations would have to be
defined in a seperate interface to avoid burdening all Queue and
BlockingQueue implementations. Such an interface wasn't defined because
there was no real requirement for it at the time.

If the intent is not to enforce ordering, then looping on the existing
offer/put/take methods achieves the same thing.

David Holmes


From kav@itu.dk  Fri Dec 17 15:57:36 2004
From: kav@itu.dk (kav@itu.dk)
Date: Fri, 17 Dec 2004 16:57:36 +0100 (CET)
Subject: [concurrency-interest] Simple addition for 6.0
Message-ID: <11355.212.242.66.254.1103299056.squirrel@212.242.66.254>

Hi there,

A nice _little_ thing for 6.0 would be a simple extension to TimeUnit:
TimeUnit.Minute, TimeUnit.Hour and TimeUnit.Day

Because its just much safer (and easier) then writing
.scheduleAtFixedRate(...,60*60*24, TimeUnit.Seconds)

- Kasper



From dl@cs.oswego.edu  Sat Dec 18 15:07:43 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 18 Dec 2004 10:07:43 -0500
Subject: [concurrency-interest] Simple addition for 6.0
In-Reply-To: <11355.212.242.66.254.1103299056.squirrel@212.242.66.254>
References: <11355.212.242.66.254.1103299056.squirrel@212.242.66.254>
Message-ID: <16836.18367.865662.477103@altair.cs.oswego.edu>

> A nice _little_ thing for 6.0 would be a simple extension to TimeUnit:
> TimeUnit.Minute, TimeUnit.Hour and TimeUnit.Day
> 
> Because its just much safer (and easier) then writing
> .scheduleAtFixedRate(...,60*60*24, TimeUnit.Seconds)

Thanks for the suggestion. There is also a Sun RFE posted for this.
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5057341

I/We had resisted this sort of thing because it seemed to open up a
never-ending stream of requests for further units (week?, fortnight?,
lunar-month?  tropical-year? Swatch-internet-beat-time?). I just
noticed though that SI (the International System of Units:
http://physics.nist.gov/cuu/Units/units.html) also permits only these
three (minutes, hours, and days) time units outside of milli-, micro-
etc. And I suppose that if this is good enough for SI, it's good
enough for java.util.concurrent :-) So we'll look into it for Mustang.

-Doug


From jean.morissette666@videotron.ca  Tue Dec 21 22:29:22 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Tue, 21 Dec 2004 17:29:22 -0500
Subject: [concurrency-interest] Bulk queue operations
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEHEFCAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCMEHEFCAA.dholmes@dltech.com.au>
Message-ID: <41C8A3C2.3080003@videotron.ca>

David Holmes wrote:
>>Could you tell me why Queue or BlockingQueue don't provide atomic bulk
>>operations like offerMany, putMany and takeMany?
> 
> 
> If the intent of these bulk operations is to offer/put/take the next n
> elements - ensuring no other producers/consumers get to touch the queue in
> between - then only certain types of implementation can easily support such
> semantics ie lock-based implementations. Such operations would have to be
> defined in a seperate interface to avoid burdening all Queue and
> BlockingQueue implementations. Such an interface wasn't defined because
> there was no real requirement for it at the time.
>
> If the intent is not to enforce ordering, then looping on the existing
> offer/put/take methods achieves the same thing.


Personnaly, I don't need to enforce ordering because my consumers can
reorder taken items.  But it could be useful for other applications.

I would be happy to have Bulk-Queue stuff in jsr166x/JDK6 because I have
the impression that a 'putMany' with a 'takeMany' operations could be
more efficient than many 'put' with many 'take'.  Also, we could want to
offer many objects atomically.



From dholmes@dltech.com.au  Tue Dec 21 23:33:08 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 22 Dec 2004 09:33:08 +1000
Subject: [concurrency-interest] Bulk queue operations
In-Reply-To: <41C8A3C2.3080003@videotron.ca>
Message-ID: <NFBBKALFDCPFIDBNKAPCEELDFCAA.dholmes@dltech.com.au>

Jean,

> I would be happy to have Bulk-Queue stuff in jsr166x/JDK6 because I have
> the impression that a 'putMany' with a 'takeMany' operations could be
> more efficient than many 'put' with many 'take'.  Also, we could want to
> offer many objects atomically.

Without atomicity, these methods would simply save you from writing a loop.
I don't think there is much to be gained by internalising that loop.

You would need to propose an interface to hold these methods, and define
their semantics. The interface would have to specify atomicity for these
methods, otherwise the interface would serve no purpose.

David Holmes


From gregg.wonderly@pobox.com  Wed Dec 22 14:42:57 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Wed, 22 Dec 2004 08:42:57 -0600
Subject: [concurrency-interest] Bulk queue operations
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEELDFCAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCEELDFCAA.dholmes@dltech.com.au>
Message-ID: <41C987F1.2050101@cytetech.com>

David Holmes wrote:
>>I would be happy to have Bulk-Queue stuff in jsr166x/JDK6 because I have
>>the impression that a 'putMany' with a 'takeMany' operations could be
>>more efficient than many 'put' with many 'take'.  Also, we could want to
>>offer many objects atomically.
> 
> 
> Without atomicity, these methods would simply save you from writing a loop.
> I don't think there is much to be gained by internalising that loop.

The multiple put/take operations actually helps the system manage thread 
concurrency better.  The total latency through the system would really 
not change by internalizing the loop.  A different algorithm, or more 
parallelism might improve the system throughput though.  In the end, the 
small amount of total work that each of these operations take, with 
multiple threads running really can't be extract from the system by 
other algorithms without dealing with some of the other considerations 
regarding thread isolation and interaction.

My experience has shown me that if these points of thread interaction 
are in fact the longest running operations in the system, then the 
system is inherently bound by these operations, and you have to remove 
them, or reorganize them to remove the interactions.

Gregg

From donnie@haleonline.net  Thu Dec 23 16:12:05 2004
From: donnie@haleonline.net (Donnie Hale)
Date: Thu, 23 Dec 2004 11:12:05 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
Message-ID: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>

I've searched the list history (I have most all of it locally :) and read
the API docs, but I'm not sure if ConcurrentHashMap directly supports this
or not. I want to check if a key is present in the map and, if not, proceed
to perform a lengthy operation to generate the value for the key then put it
in the map. However, I don't want another thread coming along and, not
finding that same key in the map, starting the same lengthy operation to
generate the value.

Something like:

Object myvalue = mymap.get(mykey);
if (myvalue == null)
{
  // lengthy operation to generate myvalue
  mymap.put(mykey, myvalue);
}

With past JDK capabilities, I'd synchronize on mymap for the duration of
that operation. With certain flavors of ReadWrite locks, I'd get a readlock
before the whole operation and promote to writelock if I had to do the
lengthy operation and put.

Assuming what I want to do is clear, is this possible with a
ConcurrentHashMap?

Thanks,

Donnie


From dl@cs.oswego.edu  Thu Dec 23 16:50:40 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 23 Dec 2004 11:50:40 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
In-Reply-To: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
References: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
Message-ID: <16842.63328.460670.923143@altair.cs.oswego.edu>

> I've searched the list history (I have most all of it locally :) and read
> the API docs, but I'm not sure if ConcurrentHashMap directly supports this
> or not. I want to check if a key is present in the map and, if not, proceed
> to perform a lengthy operation to generate the value for the key then put it
> in the map. However, I don't want another thread coming along and, not
> finding that same key in the map, starting the same lengthy operation to
> generate the value.

Usually, The best way to get the effect you want here is to create a
cheap proxy class for your value objects, that only computes them
on-demand. Then you can do a quick put of the proxy, and force the
first caller to compute the value.  This is a variant of a Future.  If
you like, you could structure your proxy as a Future.

The reason for not supporting this directly in any ConcurrentMap
method is that implementations can't and/or shouldn't maintain
atomicity across a lengthy callback, or deal with possible exceptions
it might throw.

-Doug


From tim@peierls.net  Thu Dec 23 16:50:37 2004
From: tim@peierls.net (Tim Peierls)
Date: Thu, 23 Dec 2004 11:50:37 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
In-Reply-To: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
References: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
Message-ID: <41CAF75D.8060606@peierls.net>

Donnie Hale wrote:
> Assuming what I want to do is clear, is this possible with a
> ConcurrentHashMap?

Here's a general solution that uses ConcurrentHashMap that you
can adapt for your purposes. This is code that Joe Bowbeer wrote
and presented at a JavaOne talk; I don't think there are any
limitations on its use. (Joe, speak up if you think there might be.)

public interface Computable<A, V> {
     V compute(A arg) throws Exception;
}

public class Memoize<A, V> implements Computable<A, V> {
     public Memoize(Computable<A, V> c) {
         this.c = c;
     }
     public V compute(final A arg) throws Exception {
         Future<V> f = cache.get(arg);
         if (f == null) {
             Callable<V> eval = new Callable<V>() {
                 public V call() throws Exception {
                     return c.compute(arg);
                 }
             };
             FutureTask<V> ft = new FutureTask<V>(eval);
             f = cache.putIfAbsent(arg, ft);
             if (f == null) { f = ft; ft.run(); }
         }
         return f.get();
     }
     private final ConcurrentMap<A, Future<V>> cache =
         new ConcurrentHashMap<A, Future<V>>();
     private final Computable<A, V> c;
}

You would use this as follows:

   class MyLengthyOperation implements Computable<Key, Value> {
       public Value compute(Key key) {
           // Lengthy operation here, takes key and returns
           // a value.
       }
   }

   // instead of map:
   Computable<Key, Value> map =
       new Memoize<Key, Value>(new MyLengthyOperation());

   // and then you can get values:

   for (Key key : interestingKeys) {
       Value value = map.compute(key);
       // do something with value
   }

--tim


From brian@quiotix.com  Thu Dec 23 17:19:53 2004
From: brian@quiotix.com (Brian Goetz)
Date: Thu, 23 Dec 2004 12:19:53 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap
 ?
In-Reply-To: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
References: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
Message-ID: <41CAFE39.2050408@quiotix.com>

No.  There is no way to lock a CHM for exclusive access.  However, you 
might be able to bootstrap the functionality you want using the atomic 
putIfAbsent and Future, depending on your requirements.

Map<K, Future<V>> myMap = new ConcurrenHashMap<K, Future<V>>();
FutureTask t = new FutureTask(runnable which calculates value);
if (myMap.putIfAbsent(k, t)) {
   t.run();
}

And, if you want to retrieve the value associated with key k, do
   myMap.get(k).get()

> I've searched the list history (I have most all of it locally :) and read
> the API docs, but I'm not sure if ConcurrentHashMap directly supports this
> or not. I want to check if a key is present in the map and, if not, proceed
> to perform a lengthy operation to generate the value for the key then put it
> in the map. However, I don't want another thread coming along and, not
> finding that same key in the map, starting the same lengthy operation to
> generate the value.
> 
> Something like:
> 
> Object myvalue = mymap.get(mykey);
> if (myvalue == null)
> {
>   // lengthy operation to generate myvalue
>   mymap.put(mykey, myvalue);
> }
> 
> With past JDK capabilities, I'd synchronize on mymap for the duration of
> that operation. With certain flavors of ReadWrite locks, I'd get a readlock
> before the whole operation and promote to writelock if I had to do the
> lengthy operation and put.
> 
> Assuming what I want to do is clear, is this possible with a
> ConcurrentHashMap?
> 
> Thanks,
> 
> Donnie
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From brian@quiotix.com  Thu Dec 23 18:19:22 2004
From: brian@quiotix.com (Brian Goetz)
Date: Thu, 23 Dec 2004 13:19:22 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap
 ?
In-Reply-To: <41CAFE39.2050408@quiotix.com>
References: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu> <41CAFE39.2050408@quiotix.com>
Message-ID: <41CB0C2A.3040405@quiotix.com>

Donnie Hale wrote:

 >> Assuming what I want to do is clear, is this possible with a
 >> ConcurrentHashMap?

Brian Goetz wrote:

> No.  There is no way to lock a CHM for exclusive access.  However, you 
> might be able to bootstrap the functionality you want using the atomic 
> putIfAbsent and Future, depending on your requirements.

Doug Lea wrote:

 > Usually, The best way to get the effect you want here is to create a



Tim Peierls wrote:
 >
 > Here's a general solution that uses ConcurrentHashMap that you
 > can adapt for your purposes. This is code that Joe Bowbeer wrote
 > and presented at a JavaOne talk; I don't think there are any
 > limitations on its use. (Joe, speak up if you think there might be.)


Ironically, this list has just illustrated Donnie's problem nicely.  Due 
to propagation delay, Doug, Tim, and I all looked at the list, saw no 
one had replied yet, and replied.



From tim@peierls.net  Thu Dec 23 18:49:14 2004
From: tim@peierls.net (Tim Peierls)
Date: Thu, 23 Dec 2004 13:49:14 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
In-Reply-To: <41CB0C2A.3040405@quiotix.com>
References: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
 <41CAFE39.2050408@quiotix.com> <41CB0C2A.3040405@quiotix.com>
Message-ID: <41CB132A.2070003@peierls.net>

Brian Goetz wrote:
> Ironically, this list has just illustrated Donnie's problem nicely.  Due 
> to propagation delay, Doug, Tim, and I all looked at the list, saw no 
> one had replied yet, and replied.

Good thing we didn't disagree! :-)

--tim


From larryr@saturn.sdsu.edu  Thu Dec 23 19:53:57 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 23 Dec 2004 19:53:57 -0000
Subject: [concurrency-interest] Re: Can this be done with ConcurrentHashMap ?
In-Reply-To: <200412231610.iBNGAlfK018718@altair.cs.oswego.edu>
Message-ID: <20041223195357.547.qmail@home19.riedel.org>

> I want to check if a key is present in the map and, if not,
> proceed to perform a lengthy operation to generate the value for
> the key then put it in the map. However, I don't want another
> thread coming along and, not finding that same key in the map,
> starting the same lengthy operation to generate the value.

I would be inclined to use a sentinel value (distinguished
invalid value) for each entry whose valid value is not ready
yet, and provide a wrapper which hides entries whose value is
the sentinel, and has "prepare(key)" and "commit(key,value)"
methods exposed to those classes whose methods generate values,
so those classes can can "prepare" an entry for a key, and if
that succeeds, generate the valid value and "commit" it.

Classes/methods not involved in the two phase generation of
entries would only be given plain "ConcurrentMap" references to
the wrapper, and would not be aware of the existence of entries
whose values are not ready yet... as long as they do not try to
put an entry whose key already has a corresponding "prepare"d
but not "commit"ted entry; if such a situation could occur for
that application, maybe that class/method should have been using
the "prepare" and "commit" approach in the first place.


Larry


From donnie@haleonline.net  Fri Dec 24 00:20:25 2004
From: donnie@haleonline.net (Donnie Hale)
Date: Thu, 23 Dec 2004 19:20:25 -0500
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
In-Reply-To: <41CAF75D.8060606@peierls.net>
Message-ID: <200412240019.iBO0J5fK023575@altair.cs.oswego.edu>

Tim, Doug, Brian, & Larry - I appreciate the prompt and on-point responses.
Two follow-ups:

1) In the code below, I want to make sure I understand what is supposed to
happen in Memoize.compute, within the outermost "if (f == null)" block. It
would seem that two threads could both get into this block if
"cache.get(arg)" returns null. Assuming I've got that right, then we have 2
threads instantiating a FutureTask and attempting to put it in the map via
"cache.putIfAbsent". However, only one of those threads will win; and the
other will be returned the winning thread's FutureTask. Only the winning
thread will run the FutureTask. Not being up-to-speed on Futures and
FutureTasks, I'm guessing that even if the losing thread executes the line
"return f.get()" first, it will not return until "ft.run()" completes in the
winning thread?

2) I'll admit to being a little disappointed. A host of wonderful new
concurrency utilities have been released, and, the first time I go to use
them, I come up against this. I believe based on the similarity of responses
that what I've presented is a recurring pattern. Yet a direct solution isn't
provided so I have to do some cut-and-paste of the (obviously useful) code
that's been provided. It would seem that if in fact this is a common pattern
that the solution would be provided more directly.

Thanks again for the responses,

Donnie


-----Original Message-----
From: Tim Peierls [mailto:tim@peierls.net] 
Sent: Thursday, December 23, 2004 11:51 AM
To: Donnie Hale
Cc: concurrency-interest@altair.cs.oswego.edu; Joseph Bowbeer
Subject: Re: [concurrency-interest] Can this be done with ConcurrentHashMap
?

Donnie Hale wrote:
> Assuming what I want to do is clear, is this possible with a 
> ConcurrentHashMap?

Here's a general solution that uses ConcurrentHashMap that you can adapt for
your purposes. This is code that Joe Bowbeer wrote and presented at a
JavaOne talk; I don't think there are any limitations on its use. (Joe,
speak up if you think there might be.)

public interface Computable<A, V> {
     V compute(A arg) throws Exception;
}

public class Memoize<A, V> implements Computable<A, V> {
     public Memoize(Computable<A, V> c) {
         this.c = c;
     }
     public V compute(final A arg) throws Exception {
         Future<V> f = cache.get(arg);
         if (f == null) {
             Callable<V> eval = new Callable<V>() {
                 public V call() throws Exception {
                     return c.compute(arg);
                 }
             };
             FutureTask<V> ft = new FutureTask<V>(eval);
             f = cache.putIfAbsent(arg, ft);
             if (f == null) { f = ft; ft.run(); }
         }
         return f.get();
     }
     private final ConcurrentMap<A, Future<V>> cache =
         new ConcurrentHashMap<A, Future<V>>();
     private final Computable<A, V> c;
}

You would use this as follows:

   class MyLengthyOperation implements Computable<Key, Value> {
       public Value compute(Key key) {
           // Lengthy operation here, takes key and returns
           // a value.
       }
   }

   // instead of map:
   Computable<Key, Value> map =
       new Memoize<Key, Value>(new MyLengthyOperation());

   // and then you can get values:

   for (Key key : interestingKeys) {
       Value value = map.compute(key);
       // do something with value
   }

--tim



From jozart@blarg.net  Fri Dec 24 00:40:47 2004
From: jozart@blarg.net (Joe Bowbeer)
Date: Thu, 23 Dec 2004 16:40:47 -0800
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
Message-ID: <351e013353a503c3b73aa5e9a85906b9@www.blargmail.com>

--b1_351e013353a503c3b73aa5e9a85906b9
Content-Type: text/plain; charset = "iso-8859-1"
Content-Transfer-Encoding: 8bit

Donnie Hale <donnie@haleonline.net> wrote:
> Two follow-ups:
> 
> 1) In the code below, I want to make sure I understand what is supposed
> to happen in Memoize.compute, within the outermost "if (f == null)"
> block. It would seem that two threads could both get into this block
> if "cache.get(arg)" returns null. Assuming I've got that right, then we
> have 2 threads instantiating a FutureTask and attempting to put it in
> the map via "cache.putIfAbsent". However, only one of those threads
> will win; and the other will be returned the winning thread's
> FutureTask.

Right.

> Only the winning thread will run the FutureTask. Not being up-to-speed
> on Futures and FutureTasks, I'm guessing that even if the losing thread
> executes the line "return f.get()" first, it will not return until
> "ft.run()" completes in the winning thread?
> 

Right.


FWIW, The Memoizer was presented at JavaOne 2004 in TS-2136.

Also see MemoTest.java at 

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/javaone/



--b1_351e013353a503c3b73aa5e9a85906b9
Content-Type: text/html; charset = "iso-8859-1"
Content-Transfer-Encoding: 8bit

Donnie Hale <donnie@haleonline.net> wrote:<br>> Two follow-ups:<br>> <br>> 1) In the code below, I want to make sure I understand what is supposed<br>> to happen in Memoize.compute, within the outermost "if (f == null)"<br>> block. It would seem that two threads could both get into this block<br>> if "cache.get(arg)" returns null. Assuming I've got that right, then we<br>> have 2 threads instantiating a FutureTask and attempting to put it in<br>> the map via "cache.putIfAbsent". However, only one of those threads<br>> will win; and the other will be returned the winning thread's<br>> FutureTask.<br><br>Right.<br><br>> Only the winning thread will run the FutureTask. Not being up-to-speed<br>> on Futures and FutureTasks, I'm guessing that even if the losing thread<br>> executes the line "return f.get()" first, it will not return until<br>> "ft.run()" completes in the winning thread?<br>> <br><br>Right.<br><br><br>FWIW, The Memoizer was presented at JavaOne 2004 in
TS-2136.<br><br>Also see MemoTest.java at <br><br>http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/javaone/<br><br>



--b1_351e013353a503c3b73aa5e9a85906b9--



From dholmes@dltech.com.au  Fri Dec 24 00:44:36 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 24 Dec 2004 10:44:36 +1000
Subject: [concurrency-interest] Can this be done with ConcurrentHashMap ?
In-Reply-To: <200412240019.iBO0J5fK023575@altair.cs.oswego.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCAENJFCAA.dholmes@dltech.com.au>

> Donnie Hale writes:
> 2) I'll admit to being a little disappointed. A host of wonderful new
> concurrency utilities have been released, and, the first time I go to use
> them, I come up against this.

When you use ConcurrentHashMap you get high-throughput concurrent access
with no locking. The downside is that you cannot get exclusive use of the
map by any simple means, to do a lengthy atomic operation. You can't have
both high-throughput concurrent access and arbitrary atomic actions. So the
choice is yours: go for ConcurrentHashMap and do atomic stuff the harder
way; or go with a synchronizedHashMap and lose the throughput.

Your original problem can also be solved by locking something other than the
hashmap - depending on how different keys may be generated. For example:

Object myvalue = mymap.get(mykey);
if (myvalue == null) {
  synchronized(keyGenerationLock) {
     myvalue = mymap.get(mykey);
     if (myvalue = null) {
       // lengthy operation to generate myvalue
       mymap.put(mykey, myvalue);
     }
  }
}

This solution only blocks the threads actually interested in the same key,
and doesn't lock the entire map at any stage.

David Holmes


From dl@cs.oswego.edu  Mon Dec 27 16:15:28 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 27 Dec 2004 11:15:28 -0500
Subject: [concurrency-interest] Concurrency Property Checklist
Message-ID: <16848.13600.655293.130360@altair.cs.oswego.edu>

In the course of categorizing the considerations that arise when
reviewing and documenting concurrency, I put together a draft
checklist at
  http://gee.cs.oswego.edu/dl/cpj/prop.html

This presents a set of properties along with questions you might ask
about them, plus related usage notes.  The descriptions of each are
very terse, and probably only useful to people who have read my CPJ
book. It isn't meant to be exhaustive, but is meant to be complete
enough to be a useful guide when reviewing and documenting code.  I'd
appreciate any feedback about missing properties and questions you've
encountered when trying to use concurrent code.

This is NOT intended to be useful as a set of (JSR175) Annotations.
The issues and sub-issues are too varied to be useful as embedded
class or method annotations. However, we (JSR166 expert group) have
also been looking into defining a small set of annotations that
capture some basic concurrency properties, possibly based on those in
Josh Bloch's Effective Java book item 52. More on that if it goes
anywhere.

-Doug


From ozeigermann@apache.org  Tue Dec 28 21:13:18 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Tue, 28 Dec 2004 22:13:18 +0100
Subject: [concurrency-interest] Is there something like a ordered or counting barrier
Message-ID: <9da4f45204122813132ddc1525@mail.gmail.com>

Folks,

I was struggeling to make some multi threaded test scenarios
deterministic and was looking for something that lets me determine the
sequence of steps distributed over the threads. My idea was not to let
step n be executed before step n-1.

I know CountDownLatch and CyclicBarrier, but they both do not seem to
help me in that scenario.

Because of that I made up a tiny class that does this for me

http://cvs.apache.org/viewcvs.cgi/jakarta-commons/transaction/src/java/org/apache/commons/transaction/util/SequenceBarrier.java?view=markup

and wanted to know if there are more elegant ways to do so and if this
makes sense in the first place.

Thanks for any hints and comments,

Oliver

From dawidk@mathcs.emory.edu  Tue Dec 28 21:46:24 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 28 Dec 2004 16:46:24 -0500
Subject: [concurrency-interest] Announcing: new release of backport-util-concurrent
Message-ID: <41D1D430.8010206@mathcs.emory.edu>

Hello everybody,

I am happy to announce availability of backport-util-concurrent, release 
1.0_01:

http://www.mathcs.emory.edu/dcl/util/backport-util-concurrent/

A few bugs have been fixed since 1.0, and some new functionality was 
added. Development source bundles are now available for building and 
unit testing. See the Web page for more information.

I would like to thank Jean Morissette and Gabriel Wolosin for reporting 
bugs.

Kind regards,
Dawid Kurzyniec


From ozeigermann@apache.org  Wed Dec 29 00:09:05 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Wed, 29 Dec 2004 01:09:05 +0100
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
Message-ID: <9da4f45204122816092c76522e@mail.gmail.com>

Folks,

I was struggeling to make some multi threaded test scenarios
deterministic and was looking for something that lets me determine the
sequence of steps distributed over the threads. My idea was not to let
step n be executed before step n-1.

I know CountDownLatch and CyclicBarrier, but they both do not seem to
help me in that scenario.

Because of that I made up a tiny class that does this for me

http://cvs.apache.org/viewcvs.cgi/jakarta-commons/transaction/src/java/org/apache/commons/transaction/util/SequenceBarrier.java?view=markup

and wanted to know if there are more elegant ways to do so and if this
makes sense in the first place.

Thanks for any hints and comments,

Oliver

From dholmes@dltech.com.au  Wed Dec 29 00:57:35 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 29 Dec 2004 10:57:35 +1000
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <9da4f45204122816092c76522e@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEAGFDAA.dholmes@dltech.com.au>

Oliver,

> Because of that I made up a tiny class that does this for me
>
> http://cvs.apache.org/viewcvs.cgi/jakarta-commons/transaction/src/
java/org/apache/commons/transaction/util/SequenceBarrier.java?view=markup
>
> and wanted to know if there are more elegant ways to do so and if this
> makes sense in the first place.

The class as depicted is relatively simple - though I would not have called
the method "count". Basically you are providing a "barrier" that lets
threads through in turn, where turn is indicated by the integer argument
presented to the barrier. The timeout aspect is curious because you will
proceed as if it were your turn on a timeout, even though it is not - that
doesn't seem good.

However, this barrier only controls the order in which threads pass the
barrier, not the order in which they perform their actual tasks. For
example, if a threads with arguments 1,2 and 3 are waiting when thread 0
comes along, then all four threads could pass the barrier before any thread
gets to do anything after the barrier. If the work itself were needed to be
performed "in turn" then I would expect a different approach:

   waitForMyTurn();
   doWork();
   signalNextTurn();

So while the class does something, I'm not sure it does what you actually
want it to do.

David Holmes


From dl@cs.oswego.edu  Wed Dec 29 12:58:27 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 29 Dec 2004 07:58:27 -0500
Subject: [concurrency-interest] Deque and skip list integration
Message-ID: <16850.43507.833085.465745@altair.cs.oswego.edu>

As a sign that we believe that APIs and code are stable, we've placed
the interfaces and implementations of deques and skip lists (that
we've long had as RFEs) into our main reference repository:

APIs:   http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
Jar:    http://gee.cs.oswego.edu/dl/concurrent/dist/jsr166.jar
Source: http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/
TCK:    http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/

We're not sure when these will be integrated into early-access Mustang
builds. Probably within a month or so.  As usual, you can use these
now in 1.5.0 by running java with -Xbootclasspath/p:jsr166.jar .  (You
may need to precede "jsr166.jar" with its full file path.) Also, we
will keep the "jsr166x" versions of classes around so you can always
run them that way.

Now would be a very good time to take a look at these and tell us if
you have any complaints or suggestions. We rely on you, the members of
the concurrency-interest list, to help ensure that APIs are sensible,
performance is good, and so on.  We would also be thrilled to receive
code reviews.  The new and updated classes are:

  java.util interfaces
    Deque
    NavigableMap
    NavigableSet
  java.util.concurrent interfaces
    BlockingDeque
    ConcurrentNavigableMap
  java.util implementations:
    ArrayDeque
    LinkedList  (updated to support Deque)
    TreeMap     (updated to support NavigableMap)
    TreeSet     (updated to support NavigableSet)
    Collections (updated with new adaptor/view methods)
  java.util.concurrent implementations
    ConcurrentSkipListMap
    ConcurrentSkipListSet
    LinkedBlockingDeque
    Concurrent  (a new class to hold static factories and adaptors)


Sources for updated LinkedList, TreeMap, TreeSet, and Collections are
under Sun license. All others are under our usual public domain
release.

Aside: The fact that so many things had to be changed or introduced
merely to support deques and skip lists explains why we postponed this
to after 1.5.0.

We are still contemplating and/or working on a few other minor
RFEs, for example additional TimeUnit values.

-Doug

From ozeigermann@apache.org  Wed Dec 29 15:51:26 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Wed, 29 Dec 2004 16:51:26 +0100
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEAGFDAA.dholmes@dltech.com.au>
References: <9da4f45204122816092c76522e@mail.gmail.com>
 <NFBBKALFDCPFIDBNKAPCCEAGFDAA.dholmes@dltech.com.au>
Message-ID: <9da4f452041229075119883d23@mail.gmail.com>

Hi David,

thanks a lot. This is exactly the kind of feedback I was hoping to get. :) 

Details inline...

On Wed, 29 Dec 2004 10:57:35 +1000, David Holmes <dholmes@dltech.com.au> wrote:
> Oliver,
> 
> > Because of that I made up a tiny class that does this for me
> >
> > http://cvs.apache.org/viewcvs.cgi/jakarta-commons/transaction/src/
> java/org/apache/commons/transaction/util/SequenceBarrier.java?view=markup
> >
> > and wanted to know if there are more elegant ways to do so and if this
> > makes sense in the first place.
> 
> The class as depicted is relatively simple - though I would not have called

Yes, it is simple. That's good, isn't it ;)

> the method "count". Basically you are providing a "barrier" that lets
> threads through in turn, where turn is indicated by the integer argument
> presented to the barrier. The timeout aspect is curious because you will
> proceed as if it were your turn on a timeout, even though it is not - that
> doesn't seem good.

Yes, right. Maybe throwing an exception would be better?!

> However, this barrier only controls the order in which threads pass the
> barrier, not the order in which they perform their actual tasks. For
> example, if a threads with arguments 1,2 and 3 are waiting when thread 0
> comes along, then all four threads could pass the barrier before any thread
> gets to do anything after the barrier. If the work itself were needed to be
> performed "in turn" then I would expect a different approach:
> 
>    waitForMyTurn();
>    doWork();
>    signalNextTurn();
> 
> So while the class does something, I'm not sure it does what you actually
> want it to do.

Very good observation! My solution looks like

count(0);
doWork();
count(1);

count(4);
doWork();
count(5);

and another thread may look like

count(2);
doWork();
count(3);

But

waitForTurn(0);
doWork();
signalNextTurn(0);

would indeed be better.

Sometimes stuff is even more complicated. Consider you want to signal
the next turn, but are blocked by a lock before doing so. The thread
that will release your block however needs your next signal to
proceede. My solution looks like

waitForTurn(0);
synchronized (lock) {
  signalNextTurn(0);
  lock.acquireSomething();  
}

and the other thread may look like

waitForTurn(1);
synchronized (lock) {
  signalNextTurn(1);
  lock.releaseSomething();  
}

I thought all this was a very common problem. How are others dealing
with it? Is this an absurd approach?

Oliver

From jean.morissette666@videotron.ca  Wed Dec 29 21:14:38 2004
From: jean.morissette666@videotron.ca (Jean Morissette)
Date: Wed, 29 Dec 2004 16:14:38 -0500
Subject: [concurrency-interest] Fine grained ThreadPoolExecutor
Message-ID: <41D31E3E.6050505@videotron.ca>

Hi,
Could it be possible to create an efficient fine grained 
ThreadPoolExecutor based on thread priority?

From dawidk@mathcs.emory.edu  Wed Dec 29 22:29:54 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 29 Dec 2004 17:29:54 -0500
Subject: [concurrency-interest] ThreadPoolExecutor question
Message-ID: <41D32FE2.3010107@mathcs.emory.edu>

Hello,

I would like to use a thread pool that is 1) bounded, but 2) does NOT 
keep any threads (and JVM) alive if there are no requests for 
sufficiently long time (e.g. 30s). When the pool gets contended (i.e. 
maximum number of used worker threads is reached), I would like it to 
start enqueuing subsequent tasks rather than rejecting them. The most 
intuitive approach - set core size to 0, maximum pool size to the 
bounding value, and the queue to some kind of LinkedQueue or ArrayQueue 
- fails: no tasks get executed at all (consistently with Javadoc but - 
IMHO - a little bit counterintuitively).

Another way to look at this: I want something like fixed thread pool 
(Executors.newFixedThreadPool()) but with threads dying off when they 
are idle for too long, and re-created when they are needed again.

Is there a simple way to achieve this, one might think, quite reasonable 
behavior? Or is it not so reasonable and should I abandon it, relying 
instead on unbounded pools or giving up on queuing?

Regards,
Dawid Kurzyniec


From dholmes@dltech.com.au  Wed Dec 29 22:45:55 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 30 Dec 2004 08:45:55 +1000
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <9da4f452041229075119883d23@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEBBFDAA.dholmes@dltech.com.au>

Oliver,


> Sometimes stuff is even more complicated. Consider you want to signal
> the next turn, but are blocked by a lock before doing so. The thread
> that will release your block however needs your next signal to
> proceede. My solution looks like
>
> waitForTurn(0);
> synchronized (lock) {
>   signalNextTurn(0);
>   lock.acquireSomething();
> }
>
> and the other thread may look like
>
> waitForTurn(1);
> synchronized (lock) {
>   signalNextTurn(1);
>   lock.releaseSomething();
> }
>
> I thought all this was a very common problem. How are others dealing
> with it? Is this an absurd approach?

Basically you don't code things with such dependencies because of the
deadlocks involved. One solution if these dependencies exist is to release
the lock before doing the signal.

In your code above, however, I don't know what lock.acquireSomething and
lock.releaseSomething actually represent. Also you don't synchronize on lock
before waitingForTurn, so a deadlock should not exist.

You mentioned in the original post that this was to support testing of your
multi-threaded code. But this ad-hoc scheduling protocol you are trying to
construct is probably more susceptible to errors than the code you are
testing. And the resulting code will not execute in the same way as the
original anyway.

I would take a step back and consider what it is that you really want to do.

David Holmes


From dholmes@dltech.com.au  Wed Dec 29 23:00:20 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 30 Dec 2004 09:00:20 +1000
Subject: [concurrency-interest] Fine grained ThreadPoolExecutor
In-Reply-To: <41D31E3E.6050505@videotron.ca>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEBDFDAA.dholmes@dltech.com.au>

Jean Morissette wrote:
>
> Could it be possible to create an efficient fine grained
> ThreadPoolExecutor based on thread priority?

I don't know what you mean by this.

Thread priorities are not particularly reliable in JVM's - see the JDK
release documentation:
http://java.sun.com/j2se/1.5.0/docs/guide/vm/thread-priorities.html


David Holmes


From ozeigermann@apache.org  Wed Dec 29 23:06:25 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Thu, 30 Dec 2004 00:06:25 +0100
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEBBFDAA.dholmes@dltech.com.au>
References: <9da4f452041229075119883d23@mail.gmail.com>
 <NFBBKALFDCPFIDBNKAPCOEBBFDAA.dholmes@dltech.com.au>
Message-ID: <9da4f4520412291506303a153f@mail.gmail.com>

Hi David,

thanks again for your input :)

On Thu, 30 Dec 2004 08:45:55 +1000, David Holmes <dholmes@dltech.com.au> wrote:
> > Sometimes stuff is even more complicated. Consider you want to signal
> > the next turn, but are blocked by a lock before doing so. The thread
> > that will release your block however needs your next signal to
> > proceede. My solution looks like
> >
> > waitForTurn(0);
> > synchronized (lock) {
> >   signalNextTurn(0);
> >   lock.acquireSomething();
> > }
> >
> > and the other thread may look like
> >
> > waitForTurn(1);
> > synchronized (lock) {
> >   signalNextTurn(1);
> >   lock.releaseSomething();
> > }
> >
> > I thought all this was a very common problem. How are others dealing
> > with it? Is this an absurd approach?
> 
> Basically you don't code things with such dependencies because of the
> deadlocks involved. One solution if these dependencies exist is to release
> the lock before doing the signal.
> 
> In your code above, however, I don't know what lock.acquireSomething and
> lock.releaseSomething actually represent. Also you don't synchronize on lock
> before waitingForTurn, so a deadlock should not exist.

OK, I have confused you now. Sorry for that. The above code is for
checking if acquiring and releasing of a blocking lock works. All this
is a Junit test.

> You mentioned in the original post that this was to support testing of your
> multi-threaded code. But this ad-hoc scheduling protocol you are trying to
> construct is probably more susceptible to errors than the code you are
> testing. And the resulting code will not execute in the same way as the
> original anyway.

Of course you have to be careful with the construction of such a test
case, but - and this is what I am asking - what is the alternative?
How do others test their lock classes? You need multiple threads, but
then you need them to execute in a deterministic way to reproduce the
test scenarios you want to check.

How has java.util.concurrent been tested? OK, I will ask this in
another thread...

> I would take a step back and consider what it is that you really want to do.

Either the stuff I described above or I am totally mad ;)

Oliver

From ozeigermann@apache.org  Wed Dec 29 23:19:26 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Thu, 30 Dec 2004 00:19:26 +0100
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
Message-ID: <9da4f4520412291519343012f6@mail.gmail.com>

Have there been automated tests with multiple threads for the locks in
java.util.concurrent.lock? JUnit test? If so are they available
somewhere?

In 

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/

I have found tests for the other classes, but not for the locks.
Additionally, I was a bit confused as in e.g. ConcurrentHashMapTest
there are no multi-threaded tests as well.

Isn't it common practice to test multi-threaded scenarios? Am I
getting it all wrong again?

Oliver

From dl@cs.oswego.edu  Wed Dec 29 23:51:19 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 29 Dec 2004 18:51:19 -0500
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
In-Reply-To: <9da4f4520412291519343012f6@mail.gmail.com>
References: <9da4f4520412291519343012f6@mail.gmail.com>
Message-ID: <16851.17143.992671.814759@altair.cs.oswego.edu>

> 
> http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/
> 
> I have found tests for the other classes, but not for the locks.

Well, there's ReentrantLockTest?

> Additionally, I was a bit confused as in e.g. ConcurrentHashMapTest
> there are no multi-threaded tests as well.

TCK tests are pure conformance tests, so only use as many threads
as minimally needed (usually one) to check basic postconditions.

> Isn't it common practice to test multi-threaded scenarios? 

Yes, we have a lot of them. Someday, they should be made presentable
and posted. In general the key to good multithreaded tests is to find
some way of detecting bad states (deadlock, bad field values, etc),
and then run lots of threads on multiprocessors (to generate more
interleavings), and with enough randomization to avoid getting stuck
in unintersting patterns, and run for a while seeing if you hit any
bad states.

-Doug




From ozeigermann@apache.org  Thu Dec 30 00:03:19 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Thu, 30 Dec 2004 01:03:19 +0100
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
In-Reply-To: <16851.17143.992671.814759@altair.cs.oswego.edu>
References: <9da4f4520412291519343012f6@mail.gmail.com>
 <16851.17143.992671.814759@altair.cs.oswego.edu>
Message-ID: <9da4f452041229160370e4146c@mail.gmail.com>

On Wed, 29 Dec 2004 18:51:19 -0500, Doug Lea <dl@cs.oswego.edu> wrote:
> >
> > http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/
> >
> > I have found tests for the other classes, but not for the locks.
> 
> Well, there's ReentrantLockTest?

Ooops, sorry. Thanks for pointing at it. 

E.g. in testhasQueuedThreads I have found

Thread.sleep(SHORT_DELAY_MS);

which - I suppose - does what I was trying to do with my sequence
barrier. Especially when  you debug your code this is likely to fail,
isn't it?
 
> > Isn't it common practice to test multi-threaded scenarios?
> 
> Yes, we have a lot of them. Someday, they should be made presentable
> and posted. In general the key to good multithreaded tests is to find
> some way of detecting bad states (deadlock, bad field values, etc),
> and then run lots of threads on multiprocessors (to generate more
> interleavings), and with enough randomization to avoid getting stuck
> in unintersting patterns, and run for a while seeing if you hit any
> bad states.

Yes, of course, but once found shouldn't there be tests that
deterministically reproduce those bad states. At least for regression
testing?

If so this leads me back to my initial question: How to make
multi-threaded tests deterministic?

Oliver

From dl@cs.oswego.edu  Thu Dec 30 00:09:22 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 29 Dec 2004 19:09:22 -0500
Subject: [concurrency-interest] ThreadPoolExecutor question
In-Reply-To: <41D32FE2.3010107@mathcs.emory.edu>
References: <41D32FE2.3010107@mathcs.emory.edu>
Message-ID: <16851.18226.839826.18203@altair.cs.oswego.edu>

> Another way to look at this: I want something like fixed thread pool 
> (Executors.newFixedThreadPool()) but with threads dying off when they 
> are idle for too long, and re-created when they are needed again.

One way to get this effect is to make a subclass of ThreadPoolExecutor
in which you use a short keep-alive, but override execute as

public void execute(Runnable r) {
   prestartCoreThread(); // does nothing if already at core
   super.execute(r);
}


-Doug

From dl@cs.oswego.edu  Thu Dec 30 00:19:43 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 29 Dec 2004 19:19:43 -0500
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
In-Reply-To: <9da4f452041229160370e4146c@mail.gmail.com>
References: <9da4f4520412291519343012f6@mail.gmail.com>
 <16851.17143.992671.814759@altair.cs.oswego.edu>
 <9da4f452041229160370e4146c@mail.gmail.com>
Message-ID: <16851.18847.932767.557650@altair.cs.oswego.edu>

> E.g. in testhasQueuedThreads I have found
> 
> Thread.sleep(SHORT_DELAY_MS);
> 
> which - I suppose - does what I was trying to do with my sequence
> barrier. 

Since ReentrantLockTest etc are tests of basic blocking/locking
facilities, we can't use locks themselves to block threads, so must
use the rule that implementations pass if there exists some value for
SHORT_DELAY_MS that succeeds. It is not a bad convention in some other
kinds of tests as well, since it avoids needing intricate synch to set
up tests.

> Especially when  you debug your code this is likely to fail,
> isn't it?

Yes, but these TCK tests aren't especially good for debugging anyway.

-Doug

From blanshlu@netscape.net  Thu Dec 30 00:32:34 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Wed, 29 Dec 2004 18:32:34 -0600
Subject: [concurrency-interest] Deque and skip list integration
In-Reply-To: <16850.43507.833085.465745@altair.cs.oswego.edu>
References: <16850.43507.833085.465745@altair.cs.oswego.edu>
Message-ID: <41D34CA2.3080000@netscape.net>

Here's a complaint AND a suggestion.  You didn't update LinkedHashSet 
and LinkedHashMap with any of these useful new methods you've put in to 
the Navigable interfaces.  In fact, you've gone and made the Navigable 
interfaces require sortedness.  As a frequent user of the LinkedHash 
classes, I'd sure like to see the Navigable interfaces depend only on a 
defined order, and if need be add NavigableSortedSet and 
NavigableSortedMap that unifies the Navigable and Sorted interfaces.

Luke

dl@cs.oswego.edu wrote:

>As a sign that we believe that APIs and code are stable, we've placed
>the interfaces and implementations of deques and skip lists (that
>we've long had as RFEs) into our main reference repository:
>
>APIs:   http://gee.cs.oswego.edu/dl/concurrent/dist/docs/index.html
>Jar:    http://gee.cs.oswego.edu/dl/concurrent/dist/jsr166.jar
>Source: http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/
>TCK:    http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/
>
>We're not sure when these will be integrated into early-access Mustang
>builds. Probably within a month or so.  As usual, you can use these
>now in 1.5.0 by running java with -Xbootclasspath/p:jsr166.jar .  (You
>may need to precede "jsr166.jar" with its full file path.) Also, we
>will keep the "jsr166x" versions of classes around so you can always
>run them that way.
>
>Now would be a very good time to take a look at these and tell us if
>you have any complaints or suggestions. We rely on you, the members of
>the concurrency-interest list, to help ensure that APIs are sensible,
>performance is good, and so on.  We would also be thrilled to receive
>code reviews.  The new and updated classes are:
>
>  java.util interfaces
>    Deque
>    NavigableMap
>    NavigableSet
>  java.util.concurrent interfaces
>    BlockingDeque
>    ConcurrentNavigableMap
>  java.util implementations:
>    ArrayDeque
>    LinkedList  (updated to support Deque)
>    TreeMap     (updated to support NavigableMap)
>    TreeSet     (updated to support NavigableSet)
>    Collections (updated with new adaptor/view methods)
>  java.util.concurrent implementations
>    ConcurrentSkipListMap
>    ConcurrentSkipListSet
>    LinkedBlockingDeque
>    Concurrent  (a new class to hold static factories and adaptors)
>
>
>Sources for updated LinkedList, TreeMap, TreeSet, and Collections are
>under Sun license. All others are under our usual public domain
>release.
>
>Aside: The fact that so many things had to be changed or introduced
>merely to support deques and skip lists explains why we postponed this
>to after 1.5.0.
>
>We are still contemplating and/or working on a few other minor
>RFEs, for example additional TimeUnit values.
>
>-Doug
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  
>

From dawidk@mathcs.emory.edu  Thu Dec 30 01:51:06 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 29 Dec 2004 20:51:06 -0500
Subject: [concurrency-interest] ThreadPoolExecutor question
In-Reply-To: <16851.18226.839826.18203@altair.cs.oswego.edu>
References: <41D32FE2.3010107@mathcs.emory.edu> <16851.18226.839826.18203@altair.cs.oswego.edu>
Message-ID: <41D35F0A.1000408@mathcs.emory.edu>

Doug Lea wrote:

>>Another way to look at this: I want something like fixed thread pool 
>>(Executors.newFixedThreadPool()) but with threads dying off when they 
>>are idle for too long, and re-created when they are needed again.
>>    
>>
>
>One way to get this effect is to make a subclass of ThreadPoolExecutor
>in which you use a short keep-alive, but override execute as
>
>public void execute(Runnable r) {
>   prestartCoreThread(); // does nothing if already at core
>   super.execute(r);
>}
>
>  
>
Hmmm... But if I set core size to 0, the above will have no effect; and 
when I set core size to max, the workers will not die out, isn't that 
right? It seems to me that using "addIfUnderMaximumPoolSize" would maybe 
work, but this method is private...

Regards,
Dawid


From gregg.wonderly@pobox.com  Thu Dec 30 04:06:15 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Wed, 29 Dec 2004 22:06:15 -0600
Subject: [concurrency-interest] ThreadPoolExecutor question
In-Reply-To: <41D32FE2.3010107@mathcs.emory.edu>
References: <41D32FE2.3010107@mathcs.emory.edu>
Message-ID: <41D37EB7.5090109@cytetech.com>

Dawid Kurzyniec wrote:
> I would like to use a thread pool that is 1) bounded, but 2) does NOT 
> keep any threads (and JVM) alive if there are no requests for 
> sufficiently long time (e.g. 30s). When the pool gets contended (i.e. 
> maximum number of used worker threads is reached), I would like it to 
> start enqueuing subsequent tasks rather than rejecting them. The most 
> intuitive approach - set core size to 0, maximum pool size to the 
> bounding value, and the queue to some kind of LinkedQueue or ArrayQueue 
> - fails: no tasks get executed at all (consistently with Javadoc but - 
> IMHO - a little bit counterintuitively).

Aside from whether the tools can be convinced to work this way, the 
primary issue with disallowing threads to execute is that you can create 
distributed deadlock.  A thread that you are not allowing to run might 
be the one needed to allow the running threads to finish.  With this in 
mind, threaded designs should try not to allow threads that depend on 
each other run in the same pool where thread count throttling is used. 
There are many subtle issues that you need to consider when partioning 
an application in to threads and when using thread pools to control the 
total load on a system.

Gregg Wonderly

From ozeigermann@apache.org  Thu Dec 30 13:01:04 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Thu, 30 Dec 2004 14:01:04 +0100
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
In-Reply-To: <16851.18847.932767.557650@altair.cs.oswego.edu>
References: <9da4f4520412291519343012f6@mail.gmail.com>
 <16851.17143.992671.814759@altair.cs.oswego.edu>
 <9da4f452041229160370e4146c@mail.gmail.com>
 <16851.18847.932767.557650@altair.cs.oswego.edu>
Message-ID: <9da4f45204123005012934a946@mail.gmail.com>

On Wed, 29 Dec 2004 19:19:43 -0500, Doug Lea <dl@cs.oswego.edu> wrote:
> > E.g. in testhasQueuedThreads I have found
> >
> > Thread.sleep(SHORT_DELAY_MS);
> >
> > which - I suppose - does what I was trying to do with my sequence
> > barrier.
> 
> Since ReentrantLockTest etc are tests of basic blocking/locking
> facilities, we can't use locks themselves to block threads, so must
> use the rule that implementations pass if there exists some value for
> SHORT_DELAY_MS that succeeds. It is not a bad convention in some other
> kinds of tests as well, since it avoids needing intricate synch to set
> up tests.

Certainly not ReentrantLock's, but why not using others based on
ordinardy synchronized/wait/nodify stuff?

> > Especially when  you debug your code this is likely to fail,
> > isn't it?
> 
> Yes, but these TCK tests aren't especially good for debugging anyway.

Did not want to criticize the TCK tests in any way. I am just trying
to find out what would be the best way to test concurrent stuff apart
from the stress tests you mentioned.

Any chance to see the code of your other tests?

Thanks,

Oliver

From dl@cs.oswego.edu  Thu Dec 30 13:20:46 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 30 Dec 2004 08:20:46 -0500
Subject: [concurrency-interest] Deque and skip list integration
In-Reply-To: <41D34CA2.3080000@netscape.net>
References: <16850.43507.833085.465745@altair.cs.oswego.edu>
 <41D34CA2.3080000@netscape.net>
Message-ID: <16852.174.52454.818705@altair.cs.oswego.edu>

> Here's a complaint AND a suggestion.  You didn't update LinkedHashSet 
> and LinkedHashMap with any of these useful new methods you've put in to 
> the Navigable interfaces.  In fact, you've gone and made the Navigable 
> interfaces require sortedness.  As a frequent user of the LinkedHash 
> classes, I'd sure like to see the Navigable interfaces depend only on a 
> defined order, and if need be add NavigableSortedSet and 
> NavigableSortedMap that unifies the Navigable and Sorted interfaces.

Sorry, I don't think Navigable can be made to apply when ordering is
only implicit, not key-based. For example, what should ceilingEntry
return in a LinkedHashMap, especially for a key that isn't present?

What would you like to do with a LinkedHashMap that you now cannot?

-Doug

From dl@cs.oswego.edu  Thu Dec 30 13:50:11 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 30 Dec 2004 08:50:11 -0500
Subject: [concurrency-interest] ThreadPoolExecutor question
In-Reply-To: <41D35F0A.1000408@mathcs.emory.edu>
References: <41D32FE2.3010107@mathcs.emory.edu>
 <16851.18226.839826.18203@altair.cs.oswego.edu>
 <41D35F0A.1000408@mathcs.emory.edu>
Message-ID: <16852.1939.528176.990194@altair.cs.oswego.edu>

> Hmmm... But if I set core size to 0, the above will have no effect; and 
> when I set core size to max, the workers will not die out, isn't that 
> right? 

Right, sorry. And all the ways I can think of to get the desired
effect are awful. (For example using get/setCorePoolSize in execute
and afterExecute.)

As Gregg implied, the reason for promising to keep core threads alive
is to guarantee some minimal concurrency level that may be needed to
preserve application liveness. But we could have provided some means to
allow dynamic idle timeouts and re-creation of these core threads
for people who are otherwise sure it is OK in a given application.
We'll consider adding method allowIdleTimeoutsForCoreThreads or somesuch.

-Doug



From blanshlu@netscape.net  Thu Dec 30 13:49:19 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Thu, 30 Dec 2004 07:49:19 -0600
Subject: [concurrency-interest] Deque and skip list integration
In-Reply-To: <16852.174.52454.818705@altair.cs.oswego.edu>
References: <16850.43507.833085.465745@altair.cs.oswego.edu>	<41D34CA2.3080000@netscape.net> <16852.174.52454.818705@altair.cs.oswego.edu>
Message-ID: <41D4075F.2050701@netscape.net>

--------------040706060602040502040902
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

I'd like to be able to look at or poll for the first entry.  I'd like to 
be able to construct views that begin, end, or are bounded by particular 
keys.  Or that yield the same collection in reverse order.  Obviously 
not all the methods currently in the Navigable interfaces apply to 
unsorted-but-ordered collections, but just as obviously a good and 
useful subset of them do.  The ones that require sortedness should be 
split into their own interfaces that also inherit from the Sorted and 
unsorted Navigable interfaces.

Luke

dl@cs.oswego.edu wrote:

>>Here's a complaint AND a suggestion.  You didn't update LinkedHashSet 
>>and LinkedHashMap with any of these useful new methods you've put in to 
>>the Navigable interfaces.  In fact, you've gone and made the Navigable 
>>interfaces require sortedness.  As a frequent user of the LinkedHash 
>>classes, I'd sure like to see the Navigable interfaces depend only on a 
>>defined order, and if need be add NavigableSortedSet and 
>>NavigableSortedMap that unifies the Navigable and Sorted interfaces.
>>    
>>
>
>Sorry, I don't think Navigable can be made to apply when ordering is
>only implicit, not key-based. For example, what should ceilingEntry
>return in a LinkedHashMap, especially for a key that isn't present?
>
>What would you like to do with a LinkedHashMap that you now cannot?
>
>-Doug
>  
>

--------------040706060602040502040902
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title></title>
</head>
<body bgcolor="#ffffff" text="#000000">
I'd like to be able to look at or poll for the first entry.&nbsp; I'd like
to be able to construct views that begin, end, or are bounded by
particular keys.&nbsp; Or that yield the same collection in reverse order.&nbsp;
Obviously not all the methods currently in the Navigable interfaces
apply to unsorted-but-ordered collections, but just as obviously a good
and useful subset of them do.&nbsp; The ones that require sortedness should
be split into their own interfaces that also inherit from the Sorted
and unsorted Navigable interfaces.<br>
<br>
Luke<br>
<br>
<a class="moz-txt-link-abbreviated" href="mailto:dl@cs.oswego.edu">dl@cs.oswego.edu</a> wrote:<br>
<blockquote cite="mid16852.174.52454.818705@altair.cs.oswego.edu"  type="cite">
  <blockquote type="cite">
    <pre wrap="">Here's a complaint AND a suggestion.  You didn't update LinkedHashSet 
and LinkedHashMap with any of these useful new methods you've put in to 
the Navigable interfaces.  In fact, you've gone and made the Navigable 
interfaces require sortedness.  As a frequent user of the LinkedHash 
classes, I'd sure like to see the Navigable interfaces depend only on a 
defined order, and if need be add NavigableSortedSet and 
NavigableSortedMap that unifies the Navigable and Sorted interfaces.
    </pre>
  </blockquote>
  <pre wrap=""><!---->
Sorry, I don't think Navigable can be made to apply when ordering is
only implicit, not key-based. For example, what should ceilingEntry
return in a LinkedHashMap, especially for a key that isn't present?

What would you like to do with a LinkedHashMap that you now cannot?

-Doug
  </pre>
</blockquote>
</body>
</html>

--------------040706060602040502040902--

From dl@cs.oswego.edu  Thu Dec 30 14:21:52 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 30 Dec 2004 09:21:52 -0500
Subject: [concurrency-interest] Deque and skip list integration
In-Reply-To: <41D4075F.2050701@netscape.net>
References: <16850.43507.833085.465745@altair.cs.oswego.edu>
 <41D34CA2.3080000@netscape.net>
 <16852.174.52454.818705@altair.cs.oswego.edu>
 <41D4075F.2050701@netscape.net>
Message-ID: <16852.3840.858136.392373@altair.cs.oswego.edu>

> I'd like to be able to look at or poll for the first entry.  I'd like to 
> be able to construct views that begin, end, or are bounded by particular 
> keys.  Or that yield the same collection in reverse order.  

I think what you want here is an IndexedList: a List (with associated
ListIterators and SubLists) with elements indexed by a hash
table. This is more than LinkedHashMap can do without adding a lot of
overhead.  It would make nearly all users of LinkedhashMap unhappy to
have slower performance if this functionality wer added anyway, so it
would need to be a new java.util class and interface.  This is not
officially in scope of JSR166 unless we also added
ConcurrentIndexedList, for which there is probably not enough
demand/need.  But the expert group just so happens to include the
people who wrote most of java.util collections, who will discuss it as
an unrelated RFE :-)

> I'd like to be able to look at or poll for the first entry. 

While probably not as efficient as it might be if built-in, you can do:

<T> getFirst(LinkedHashSet<T> s) { return s.iterator().next(); }

<T> pollFirst(LinkedHashSet<T> s) { 
  Iterator<T> i = s.iterator();
  if (!i.hasNext() return null;
  T x = i.next();
  i.remove();
  return x;
}


-Doug

From dl@cs.oswego.edu  Thu Dec 30 15:04:03 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 30 Dec 2004 10:04:03 -0500
Subject: [concurrency-interest] How has java.util.concurrent.locks been tested?
In-Reply-To: <9da4f45204123005012934a946@mail.gmail.com>
References: <9da4f4520412291519343012f6@mail.gmail.com>
 <16851.17143.992671.814759@altair.cs.oswego.edu>
 <9da4f452041229160370e4146c@mail.gmail.com>
 <16851.18847.932767.557650@altair.cs.oswego.edu>
 <9da4f45204123005012934a946@mail.gmail.com>
Message-ID: <16852.6371.913120.465692@altair.cs.oswego.edu>

> Certainly not ReentrantLock's, but why not using others based on
> ordinardy synchronized/wait/nodify stuff?

Some do. Some others could, but just happen not to.

> I am just trying
> to find out what would be the best way to test concurrent stuff apart
> from the stress tests you mentioned.

Most concurrency errors tend to either be simple enough to be caught
by simple unit tests, or so rare as to require stress testing.  The
enormous effort it takes to pre-wire other fixed interleavings doesn't
usually pay off.

> Any chance to see the code of your other tests?

I'll send some to you separately. Most take quirky undocumented
program arguments and don't explain what they are testing, so need
some minor cleanup before posting more widely.

-Doug



From blanshlu@netscape.net  Thu Dec 30 17:00:52 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Thu, 30 Dec 2004 11:00:52 -0600
Subject: [concurrency-interest] Deque and skip list integration
In-Reply-To: <16852.3840.858136.392373@altair.cs.oswego.edu>
References: <16850.43507.833085.465745@altair.cs.oswego.edu>	<41D34CA2.3080000@netscape.net>	<16852.174.52454.818705@altair.cs.oswego.edu>	<41D4075F.2050701@netscape.net> <16852.3840.858136.392373@altair.cs.oswego.edu>
Message-ID: <41D43444.6050308@netscape.net>

--------------030601060101040204060804
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

dl@cs.oswego.edu wrote:

>>I'd like to be able to look at or poll for the first entry.  I'd like to 
>>be able to construct views that begin, end, or are bounded by particular 
>>keys.  Or that yield the same collection in reverse order.  
>>    
>>
>I think what you want here is an IndexedList: a List (with associated
>ListIterators and SubLists) with elements indexed by a hash
>table...
>
While that would be nice, it's not what I'm really looking for.  I would 
like to be able to make better use of the links that the LinkedHashMap 
maintains -- more than just for iteration.  I'd like to be able to jump 
into the map at a particular point and continue from there, in either 
direction.  The methods you've defined in NavigableMap do just this, and 
it would be no particular difficulty or extra overhead to provide this 
functionality in LinkedHashMap (AFAICT), so thus my complaint/proposal.

In fact, I'd be happy to have this functionality available on the 
LinkedHash classes regardless of whether you included the methods in 
separate interfaces.  But it seems to me so close to the intent of the 
Navigable interfaces that it looks like an oversight.  It is true that 
the methods would have slightly different semantics in the LinkedHash 
setting than in the Sorted setting because the order is not independent 
of the current contents of the collection.  But that could be finessed.

>...  But the expert group just so happens to include the
>people who wrote most of java.util collections, who will discuss it as
>an unrelated RFE :-)
>  
>
Thanks -- that's all I ask!

>>I'd like to be able to look at or poll for the first entry. 
>>    
>>
>While probably not as efficient as it might be if built-in, you can do:
>
><T> getFirst(LinkedHashSet<T> s) { return s.iterator().next(); }
>
><T> pollFirst(LinkedHashSet<T> s) { 
>  Iterator<T> i = s.iterator();
>  if (!i.hasNext() return null;
>  T x = i.next();
>  i.remove();
>  return x;
>}
>  
>
Yeah, that's what I do now.  It works, and it keeps the garbage 
collector busy.

Luke

--------------030601060101040204060804
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title></title>
</head>
<body bgcolor="#ffffff" text="#000000">
<a class="moz-txt-link-abbreviated" href="mailto:dl@cs.oswego.edu">dl@cs.oswego.edu</a> wrote:<br>
<blockquote cite="mid16852.3840.858136.392373@altair.cs.oswego.edu"  type="cite">
  <blockquote type="cite">
    <pre wrap="">I'd like to be able to look at or poll for the first entry.  I'd like to 
be able to construct views that begin, end, or are bounded by particular 
keys.  Or that yield the same collection in reverse order.  
    </pre>
  </blockquote>
  <pre wrap=""><!---->I think what you want here is an IndexedList: a List (with associated
ListIterators and SubLists) with elements indexed by a hash
table...</pre>
</blockquote>
While that would be nice, it's not what I'm really looking for.&nbsp; I
would like to be able to make better use of the links that the
LinkedHashMap maintains -- more than just for iteration.&nbsp; I'd like to
be able to jump into the map at a particular point and continue from
there, in either direction.&nbsp; The methods you've defined in NavigableMap
do just this, and it would be no particular difficulty or extra
overhead to provide this functionality in LinkedHashMap (AFAICT), so
thus my complaint/proposal.<br>
<br>
In fact, I'd be happy to have this functionality available on the
LinkedHash classes regardless of whether you included the methods in
separate interfaces.&nbsp; But it seems to me so close to the intent of the
Navigable interfaces that it looks like an oversight.&nbsp; It is true that
the methods would have slightly different semantics in the LinkedHash
setting than in the Sorted setting because the order is not independent
of the current contents of the collection.&nbsp; But that could be finessed.<br>
<blockquote cite="mid16852.3840.858136.392373@altair.cs.oswego.edu"  type="cite">
  <pre wrap="">...  But the expert group just so happens to include the
people who wrote most of java.util collections, who will discuss it as
an unrelated RFE :-)
  </pre>
</blockquote>
Thanks -- that's all I ask!<br>
<blockquote cite="mid16852.3840.858136.392373@altair.cs.oswego.edu"  type="cite">
  <blockquote type="cite">
    <pre wrap="">I'd like to be able to look at or poll for the first entry. 
    </pre>
  </blockquote>
  <pre wrap=""><!---->While probably not as efficient as it might be if built-in, you can do:

&lt;T&gt; getFirst(LinkedHashSet&lt;T&gt; s) { return s.iterator().next(); }

&lt;T&gt; pollFirst(LinkedHashSet&lt;T&gt; s) { 
  Iterator&lt;T&gt; i = s.iterator();
  if (!i.hasNext() return null;
  T x = i.next();
  i.remove();
  return x;
}
  </pre>
</blockquote>
Yeah, that's what I do now.&nbsp; It works, and it keeps the garbage
collector busy.<br>
<br>
Luke<br>
</body>
</html>

--------------030601060101040204060804--

From dl@cs.oswego.edu  Thu Dec 30 17:44:50 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 30 Dec 2004 12:44:50 -0500
Subject: [concurrency-interest] Simple addition for 6.0
In-Reply-To: <16836.18367.865662.477103@altair.cs.oswego.edu>
References: <11355.212.242.66.254.1103299056.squirrel@212.242.66.254>
 <16836.18367.865662.477103@altair.cs.oswego.edu>
Message-ID: <16852.16018.318519.705048@altair.cs.oswego.edu>

> A nice _little_ thing for 6.0 would be a simple extension to TimeUnit:
> TimeUnit.Minute, TimeUnit.Hour and TimeUnit.Day

The updated version of TimeUnit is now in the list of changes we
intend to integrate into Mustang. See
  http://gee.cs.oswego.edu/dl/concurrent/dist/docs/java/util/concurrent/TimeUnit.html

-Doug

From dholmes@dltech.com.au  Fri Dec 31 06:21:10 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Fri, 31 Dec 2004 16:21:10 +1000
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <9da4f4520412291506303a153f@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIECFFDAA.dholmes@dltech.com.au>

Oliver,

> Of course you have to be careful with the construction of such a test
> case, but - and this is what I am asking - what is the alternative?
> How do others test their lock classes? You need multiple threads, but
> then you need them to execute in a deterministic way to reproduce the
> test scenarios you want to check.

Like any class testing MT code ranges from basic black-box testing through
to complex white-box testing. Simple black-box tests can be used that
involve positioning threads at the right place eg. acquire a lock in one
thread then assert the lock reports that thread as the owner; that a tryLock
in another thread fails; that a Condition await/signal from another thread
fails etc.

Simple positioning can be done using synchronized sections, wait/notify or
things like semaphores and barriers - it all depends what conditions you are
trying to establish.

For white-box testing, the ability to setup the system state so that you can
test the code path you want to test, can prove to be prohibitive rather
quickly. And even if you can test a given code path, testing all possible
interleavings is impractical. Rather than try to perform such intricate
tests, people tend to move to the other end of the spectrum and look at the
stress tests that Doug mentioned. You check all the pre- and post-conditions
and all the invariants that you can - both in the "application" part of the
test and the lock class itself, then throw numerous threads at it from
different angles. Add in random sleeps etc to force rescheduling to occur at
different times (even inside your Lock class code) and make sure you get to
test of a true MP system. The tests should be designed so that success is
inferred from the fact no assertions failed, and the test ran to completion,
and each thread did the work assigned.

David Holmes


From ozeigermann@apache.org  Fri Dec 31 12:30:12 2004
From: ozeigermann@apache.org (Oliver Zeigermann)
Date: Fri, 31 Dec 2004 13:30:12 +0100
Subject: [concurrency-interest] Is there something like an ordered or counting barrier
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIECFFDAA.dholmes@dltech.com.au>
References: <9da4f4520412291506303a153f@mail.gmail.com>
 <NFBBKALFDCPFIDBNKAPCIECFFDAA.dholmes@dltech.com.au>
Message-ID: <9da4f452041231043055c8bf8c@mail.gmail.com>

On Fri, 31 Dec 2004 16:21:10 +1000, David Holmes <dholmes@dltech.com.au> wrote:
> > Of course you have to be careful with the construction of such a test
> > case, but - and this is what I am asking - what is the alternative?
> > How do others test their lock classes? You need multiple threads, but
> > then you need them to execute in a deterministic way to reproduce the
> > test scenarios you want to check.
> 
> Like any class testing MT code ranges from basic black-box testing through
> to complex white-box testing. Simple black-box tests can be used that
> involve positioning threads at the right place eg. acquire a lock in one
> thread then assert the lock reports that thread as the owner; that a tryLock
> in another thread fails; that a Condition await/signal from another thread
> fails etc.
> 
> Simple positioning can be done using synchronized sections, wait/notify or
> things like semaphores and barriers - it all depends what conditions you are
> trying to establish.

Well, this - simple positioning - is what I was trying to achieve with
the sequence barrier. I was using something like a CyclicBarrier or
pure synchronized blocks, but this let the code get soooo complicated.

Anyway, thanks for your suggestions for the sequence barrier (the
waitForTurn, signalNextTurn thing), I will incorporate it...

Oliver

From dl@cs.oswego.edu  Fri Dec 31 14:54:53 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 31 Dec 2004 09:54:53 -0500
Subject: [concurrency-interest] ThreadPoolExecutor question
In-Reply-To: <41D32FE2.3010107@mathcs.emory.edu>
References: <41D32FE2.3010107@mathcs.emory.edu>
Message-ID: <16853.26685.885683.440156@altair.cs.oswego.edu>

> Another way to look at this: I want something like fixed thread pool 
> (Executors.newFixedThreadPool()) but with threads dying off when they 
> are idle for too long, and re-created when they are needed again.
> 

New method ThreadPoolExecutor.allowCoreThreadTimeOut is now in the
list of changes we hope to integrate into Mustang.

-Doug


