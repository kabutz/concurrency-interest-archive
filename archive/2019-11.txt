From nathanila at gmail.com  Thu Nov  7 13:39:00 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 7 Nov 2019 11:39:00 -0700
Subject: [concurrency-interest] CompletableStage.whenComplete(): Completes
 the stage after calling the BiConsumer
Message-ID: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>

For CompletableStage.whenComplete(), the Javadoc says "The returned 
stage is completed when the action returns."  What is the reasoning for 
completing the future after action returns?  How do I run action after 
the future completes?

-Nathan


From martinrb at google.com  Thu Nov  7 16:41:53 2019
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 7 Nov 2019 13:41:53 -0800
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
Message-ID: <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>

https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)

On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:

> For CompletableStage.whenComplete(), the Javadoc says "The returned
> stage is completed when the action returns."  What is the reasoning for
> completing the future after action returns?


The result of the returned stage depends on whether the action failed or
not.


> How do I run action after
> the future completes?
>

Why can't you just attach a completion action to either the stage returned
by whenComplete or its source?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191107/b4237c86/attachment.html>

From oleksandr.otenko at gmail.com  Thu Nov  7 16:53:45 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 7 Nov 2019 21:53:45 +0000
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
Message-ID: <CANkgWKjHoWNR5=RioYoCGV+9GEk-9VqAoRYeDbcA5V6jbDqvHA@mail.gmail.com>

It may be better to say "the action return happens before completion". I
would expect this to be the case - that is, no additional efforts
are needed to make the effects of the action to be visible to any
subsequent handler.

Alex

On Thu, 7 Nov 2019, 21:43 Martin Buchholz via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

>
> https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>
> On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>
>> For CompletableStage.whenComplete(), the Javadoc says "The returned
>> stage is completed when the action returns."  What is the reasoning for
>> completing the future after action returns?
>
>
> The result of the returned stage depends on whether the action failed or
> not.
>
>
>> How do I run action after
>> the future completes?
>>
>
> Why can't you just attach a completion action to either the stage returned
> by whenComplete or its source?
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191107/8370210d/attachment.html>

From nathanila at gmail.com  Thu Nov  7 18:42:09 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 7 Nov 2019 16:42:09 -0700
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
Message-ID: <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>

UnableToParseQuestionException  ;)

Let's use the following simplified code.

CompletableFuture<String> future;

public void startSomething()
{
    CompletableFuture<String> async;

    async  = CompletableFuture.supplyAsync(() -> produce());
    future = async.whenComplete((value, throwable) -> doSomething1());
}

public String produce()
{
    Thread.sleep(1000);  // A long operation
    return("Hello");
}

public void doSomething1()
{
    doSomething2();
}

public void doSomething2()
{
    doSomething3();
}

public void doSomething3()
{
    doSomething4();
}

public void doSomething4()
{
    if (future.getNow(null) == null)
       throw new IllegalStateException("I wanted \"Hello\"");
}

Here are my questions now more refined...

Why does "future" not complete until after the action in whenComplete() 
returns?  How do I exploit this behavior?

How do I get the value from "future" in doSomething4()?


I could pass the "Hello" value through the doSomething#(), but that will 
require creating duplicate methods because other code uses the 
doSomething#() as they are.  I could pass null or value depending on the 
use case but that makes the methods complicated.

I cannot access "async" since that is long gone from the stack of 
probably another thread.  I could save "async" in a separate field but 
that wastes heap space.

I could change startSomething() to the following.  If I understand 
correctly, "unused" could be GCed and whenComplete() will never execute.

public void startSomething()
{
    CompletableFuture<String> unused;

    future = CompletableFuture.supplyAsync(() -> produce());
    unused = future.whenComplete((value, throwable) -> doSomething1());
}

-Nathan

On 11/7/2019 2:41 PM, Martin Buchholz wrote:
> https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>
> On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via 
> Concurrency-interest <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>
>     For CompletableStage.whenComplete(), the Javadoc says "The returned
>     stage is completed when the action returns."  What is the
>     reasoning for
>     completing the future after action returns? 
>
>
> The result of the returned stage depends on whether the action failed 
> or not.
>
>     How do I run action after
>     the future completes?
>
>
> Why can't you just attach a completion action to either the stage 
> returned by whenComplete or its source?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191107/1fddf080/attachment.html>

From oleksandr.otenko at gmail.com  Thu Nov  7 19:30:44 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 8 Nov 2019 00:30:44 +0000
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
 <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>
Message-ID: <CANkgWKhn06=of2D=FK+G0LFpnCOUgUTEjEQAyPYpXHMXnX+iKw@mail.gmail.com>

UnableToInferImplicitsException

You need to start with happens before edges. Some of them are program order.

What do you want to happen before future can be seen completed, and what do
you want to happen after it? Sounds tautological, but that's where you need
to split the execution into two stages.

Otherwise the simplified example doesn't make it clear why you do not
assign async to future.

Alex

On Thu, 7 Nov 2019, 23:44 Nathan and Ila Reynolds via Concurrency-interest,
<concurrency-interest at cs.oswego.edu> wrote:

> UnableToParseQuestionException  ;)
>
> Let's use the following simplified code.
> CompletableFuture<String> future;
>
> public void startSomething()
> {
>    CompletableFuture<String> async;
>
>    async  = CompletableFuture.supplyAsync(() -> produce());
>    future = async.whenComplete((value, throwable) -> doSomething1());
> }
>
> public String produce()
> {
>    Thread.sleep(1000);  // A long operation
>    return("Hello");
> }
>
> public void doSomething1()
> {
>    doSomething2();
> }
>
> public void doSomething2()
> {
>    doSomething3();
> }
>
> public void doSomething3()
> {
>    doSomething4();
> }
>
> public void doSomething4()
> {
>    if (future.getNow(null) == null)
>       throw new IllegalStateException("I wanted \"Hello\"");
> }
>
> Here are my questions now more refined...
>
> Why does "future" not complete until after the action in whenComplete()
> returns?  How do I exploit this behavior?
>
> How do I get the value from "future" in doSomething4()?
>
>
> I could pass the "Hello" value through the doSomething#(), but that will
> require creating duplicate methods because other code uses the
> doSomething#() as they are.  I could pass null or value depending on the
> use case but that makes the methods complicated.
>
> I cannot access "async" since that is long gone from the stack of probably
> another thread.  I could save "async" in a separate field but that wastes
> heap space.
>
> I could change startSomething() to the following.  If I understand
> correctly, "unused" could be GCed and whenComplete() will never execute.
>
> public void startSomething()
> {
>    CompletableFuture<String> unused;
>
>    future = CompletableFuture.supplyAsync(() -> produce());
>    unused = future.whenComplete((value, throwable) -> doSomething1());
> }
>
> -Nathan
>
> On 11/7/2019 2:41 PM, Martin Buchholz wrote:
>
>
> https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>
> On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>
>> For CompletableStage.whenComplete(), the Javadoc says "The returned
>> stage is completed when the action returns."  What is the reasoning for
>> completing the future after action returns?
>
>
> The result of the returned stage depends on whether the action failed or
> not.
>
>
>> How do I run action after
>> the future completes?
>>
>
> Why can't you just attach a completion action to either the stage returned
> by whenComplete or its source?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191108/341f6319/attachment-0001.html>

From nathanila at gmail.com  Thu Nov  7 19:39:42 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 7 Nov 2019 17:39:42 -0700
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <CANkgWKhn06=of2D=FK+G0LFpnCOUgUTEjEQAyPYpXHMXnX+iKw@mail.gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
 <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>
 <CANkgWKhn06=of2D=FK+G0LFpnCOUgUTEjEQAyPYpXHMXnX+iKw@mail.gmail.com>
Message-ID: <b6407c93-d2e1-63e4-f2d8-1249fb5fc900@gmail.com>

Hmm... I just now recognize that there is a happens before edge for 
whenComplete()'s action returns and when "future" completes.  How does 
having that happens-before edge help write code?  I suppose it allows me 
to carry out actions that must be visible before "future" completes and 
actions that must execute after "future" completes. Are there other 
abstract or concrete reasons?

 > Otherwise the simplified example doesn't make it clear why you do not 
assign async to future.

I could store "async" in a separate field but that wastes heap space 
when I figure I only need 1 field.

I could change startSomething() to the following.  I assume that 
"unused" could be GCed and whenComplete() will never execute.  Is this 
assumption correct?

public void startSomething()
{
    CompletableFuture<String> unused;

    future = CompletableFuture.supplyAsync(() -> produce());
    unused = future.whenComplete((value, throwable) -> doSomething1());
}

-Nathan

On 11/7/2019 5:30 PM, Alex Otenko wrote:
> UnableToInferImplicitsException
>
> You need to start with happens before edges. Some of them are program 
> order.
>
> What do you want to happen before future can be seen completed, and 
> what do you want to happen after it? Sounds tautological, but that's 
> where you need to split the execution into two stages.
>
> Otherwise the simplified example doesn't make it clear why you do not 
> assign async to future.
>
> Alex
>
> On Thu, 7 Nov 2019, 23:44 Nathan and Ila Reynolds via 
> Concurrency-interest, <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>
>     UnableToParseQuestionException  ;)
>
>     Let's use the following simplified code.
>
>     CompletableFuture<String> future;
>
>     public void startSomething()
>     {
>        CompletableFuture<String> async;
>
>        async  = CompletableFuture.supplyAsync(() -> produce());
>        future = async.whenComplete((value, throwable) -> doSomething1());
>     }
>
>     public String produce()
>     {
>        Thread.sleep(1000);  // A long operation
>        return("Hello");
>     }
>
>     public void doSomething1()
>     {
>        doSomething2();
>     }
>
>     public void doSomething2()
>     {
>        doSomething3();
>     }
>
>     public void doSomething3()
>     {
>        doSomething4();
>     }
>
>     public void doSomething4()
>     {
>        if (future.getNow(null) == null)
>           throw new IllegalStateException("I wanted \"Hello\"");
>     }
>
>     Here are my questions now more refined...
>
>     Why does "future" not complete until after the action in
>     whenComplete() returns?  How do I exploit this behavior?
>
>     How do I get the value from "future" in doSomething4()?
>
>
>     I could pass the "Hello" value through the doSomething#(), but
>     that will require creating duplicate methods because other code
>     uses the doSomething#() as they are.  I could pass null or value
>     depending on the use case but that makes the methods complicated.
>
>     I cannot access "async" since that is long gone from the stack of
>     probably another thread.  I could save "async" in a separate field
>     but that wastes heap space.
>
>     I could change startSomething() to the following.  If I understand
>     correctly, "unused" could be GCed and whenComplete() will never
>     execute.
>
>     public void startSomething()
>     {
>        CompletableFuture<String> unused;
>
>        future = CompletableFuture.supplyAsync(() -> produce());
>        unused = future.whenComplete((value, throwable) -> doSomething1());
>     }
>
>     -Nathan
>
>     On 11/7/2019 2:41 PM, Martin Buchholz wrote:
>>     https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>>
>>     On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
>>     Concurrency-interest <concurrency-interest at cs.oswego.edu
>>     <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>>
>>         For CompletableStage.whenComplete(), the Javadoc says "The
>>         returned
>>         stage is completed when the action returns."  What is the
>>         reasoning for
>>         completing the future after action returns? 
>>
>>
>>     The result of the returned stage depends on whether the action
>>     failed or not.
>>
>>         How do I run action after
>>         the future completes?
>>
>>
>>     Why can't you just attach a completion action to either the stage
>>     returned by whenComplete or its source?
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191107/99d6a704/attachment.html>

From oleksandr.otenko at gmail.com  Thu Nov  7 19:55:46 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 8 Nov 2019 00:55:46 +0000
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <b6407c93-d2e1-63e4-f2d8-1249fb5fc900@gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
 <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>
 <CANkgWKhn06=of2D=FK+G0LFpnCOUgUTEjEQAyPYpXHMXnX+iKw@mail.gmail.com>
 <b6407c93-d2e1-63e4-f2d8-1249fb5fc900@gmail.com>
Message-ID: <CANkgWKjsoEb5UDrKokgf8BJTa9qzMbqtH8-3rH=uBu=fQt0OLQ@mail.gmail.com>

The existence of happens before means you write BiConsumer like
single-threaded.

The BiConsumer is attached to this, and a new CompletionStage is retained
until BiConsumer completes, at which stage it is completed. If you drop the
reference to the stage returned by whenComplete, you just won't know when
it completes, and how. But you can't stop its execution by dropping the
reference.

Alex

On Fri, 8 Nov 2019, 00:39 Nathan and Ila Reynolds, <nathanila at gmail.com>
wrote:

> Hmm... I just now recognize that there is a happens before edge for
> whenComplete()'s action returns and when "future" completes.  How does
> having that happens-before edge help write code?  I suppose it allows me to
> carry out actions that must be visible before "future" completes and
> actions that must execute after "future" completes.  Are there other
> abstract or concrete reasons?
>
> > Otherwise the simplified example doesn't make it clear why you do not
> assign async to future.
>
> I could store "async" in a separate field but that wastes heap space when
> I figure I only need 1 field.
>
> I could change startSomething() to the following.  I assume that "unused"
> could be GCed and whenComplete() will never execute.  Is this assumption
> correct?
>
> public void startSomething()
> {
>    CompletableFuture<String> unused;
>
>    future = CompletableFuture.supplyAsync(() -> produce());
>    unused = future.whenComplete((value, throwable) -> doSomething1());
> }
>
> -Nathan
>
> On 11/7/2019 5:30 PM, Alex Otenko wrote:
>
> UnableToInferImplicitsException
>
> You need to start with happens before edges. Some of them are program
> order.
>
> What do you want to happen before future can be seen completed, and what
> do you want to happen after it? Sounds tautological, but that's where you
> need to split the execution into two stages.
>
> Otherwise the simplified example doesn't make it clear why you do not
> assign async to future.
>
> Alex
>
> On Thu, 7 Nov 2019, 23:44 Nathan and Ila Reynolds via
> Concurrency-interest, <concurrency-interest at cs.oswego.edu> wrote:
>
>> UnableToParseQuestionException  ;)
>>
>> Let's use the following simplified code.
>> CompletableFuture<String> future;
>>
>> public void startSomething()
>> {
>>    CompletableFuture<String> async;
>>
>>    async  = CompletableFuture.supplyAsync(() -> produce());
>>    future = async.whenComplete((value, throwable) -> doSomething1());
>> }
>>
>> public String produce()
>> {
>>    Thread.sleep(1000);  // A long operation
>>    return("Hello");
>> }
>>
>> public void doSomething1()
>> {
>>    doSomething2();
>> }
>>
>> public void doSomething2()
>> {
>>    doSomething3();
>> }
>>
>> public void doSomething3()
>> {
>>    doSomething4();
>> }
>>
>> public void doSomething4()
>> {
>>    if (future.getNow(null) == null)
>>       throw new IllegalStateException("I wanted \"Hello\"");
>> }
>>
>> Here are my questions now more refined...
>>
>> Why does "future" not complete until after the action in whenComplete()
>> returns?  How do I exploit this behavior?
>>
>> How do I get the value from "future" in doSomething4()?
>>
>>
>> I could pass the "Hello" value through the doSomething#(), but that will
>> require creating duplicate methods because other code uses the
>> doSomething#() as they are.  I could pass null or value depending on the
>> use case but that makes the methods complicated.
>>
>> I cannot access "async" since that is long gone from the stack of
>> probably another thread.  I could save "async" in a separate field but that
>> wastes heap space.
>>
>> I could change startSomething() to the following.  If I understand
>> correctly, "unused" could be GCed and whenComplete() will never execute.
>>
>> public void startSomething()
>> {
>>    CompletableFuture<String> unused;
>>
>>    future = CompletableFuture.supplyAsync(() -> produce());
>>    unused = future.whenComplete((value, throwable) -> doSomething1());
>> }
>>
>> -Nathan
>>
>> On 11/7/2019 2:41 PM, Martin Buchholz wrote:
>>
>>
>> https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>>
>> On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
>> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>
>>> For CompletableStage.whenComplete(), the Javadoc says "The returned
>>> stage is completed when the action returns."  What is the reasoning for
>>> completing the future after action returns?
>>
>>
>> The result of the returned stage depends on whether the action failed or
>> not.
>>
>>
>>> How do I run action after
>>> the future completes?
>>>
>>
>> Why can't you just attach a completion action to either the stage
>> returned by whenComplete or its source?
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191108/410f5bba/attachment-0001.html>

From nathanila at gmail.com  Thu Nov  7 20:25:06 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 7 Nov 2019 18:25:06 -0700
Subject: [concurrency-interest] CompletableStage.whenComplete():
 Completes the stage after calling the BiConsumer
In-Reply-To: <CANkgWKjsoEb5UDrKokgf8BJTa9qzMbqtH8-3rH=uBu=fQt0OLQ@mail.gmail.com>
References: <53d6f483-9e9e-85af-224b-508cb7f636b0@gmail.com>
 <CA+kOe08th+XTUwhOn4euFmE8aQYdoZm-jRZe+4T4H=+nyZw-xA@mail.gmail.com>
 <cb7adfdd-482b-d992-a5a5-30323161bc13@gmail.com>
 <CANkgWKhn06=of2D=FK+G0LFpnCOUgUTEjEQAyPYpXHMXnX+iKw@mail.gmail.com>
 <b6407c93-d2e1-63e4-f2d8-1249fb5fc900@gmail.com>
 <CANkgWKjsoEb5UDrKokgf8BJTa9qzMbqtH8-3rH=uBu=fQt0OLQ@mail.gmail.com>
Message-ID: <CAG7qthBd72LY6UNv0JtUY0EqOOcnV_YAV6T3aVP6a3mW-Nomtw@mail.gmail.com>

Ah!  Thank you!  That makes working with CompletableFutures much easier!  I
can attach all sorts of things without having to worry about keeping a
reference to the returned CompletableFuture.

On Thu, Nov 7, 2019 at 5:55 PM Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> The existence of happens before means you write BiConsumer like
> single-threaded.
>
> The BiConsumer is attached to this, and a new CompletionStage is retained
> until BiConsumer completes, at which stage it is completed. If you drop the
> reference to the stage returned by whenComplete, you just won't know when
> it completes, and how. But you can't stop its execution by dropping the
> reference.
>
> Alex
>
> On Fri, 8 Nov 2019, 00:39 Nathan and Ila Reynolds, <nathanila at gmail.com>
> wrote:
>
>> Hmm... I just now recognize that there is a happens before edge for
>> whenComplete()'s action returns and when "future" completes.  How does
>> having that happens-before edge help write code?  I suppose it allows me to
>> carry out actions that must be visible before "future" completes and
>> actions that must execute after "future" completes.  Are there other
>> abstract or concrete reasons?
>>
>> > Otherwise the simplified example doesn't make it clear why you do not
>> assign async to future.
>>
>> I could store "async" in a separate field but that wastes heap space when
>> I figure I only need 1 field.
>>
>> I could change startSomething() to the following.  I assume that "unused"
>> could be GCed and whenComplete() will never execute.  Is this assumption
>> correct?
>>
>> public void startSomething()
>> {
>>    CompletableFuture<String> unused;
>>
>>    future = CompletableFuture.supplyAsync(() -> produce());
>>    unused = future.whenComplete((value, throwable) -> doSomething1());
>> }
>>
>> -Nathan
>>
>> On 11/7/2019 5:30 PM, Alex Otenko wrote:
>>
>> UnableToInferImplicitsException
>>
>> You need to start with happens before edges. Some of them are program
>> order.
>>
>> What do you want to happen before future can be seen completed, and what
>> do you want to happen after it? Sounds tautological, but that's where you
>> need to split the execution into two stages.
>>
>> Otherwise the simplified example doesn't make it clear why you do not
>> assign async to future.
>>
>> Alex
>>
>> On Thu, 7 Nov 2019, 23:44 Nathan and Ila Reynolds via
>> Concurrency-interest, <concurrency-interest at cs.oswego.edu> wrote:
>>
>>> UnableToParseQuestionException  ;)
>>>
>>> Let's use the following simplified code.
>>> CompletableFuture<String> future;
>>>
>>> public void startSomething()
>>> {
>>>    CompletableFuture<String> async;
>>>
>>>    async  = CompletableFuture.supplyAsync(() -> produce());
>>>    future = async.whenComplete((value, throwable) -> doSomething1());
>>> }
>>>
>>> public String produce()
>>> {
>>>    Thread.sleep(1000);  // A long operation
>>>    return("Hello");
>>> }
>>>
>>> public void doSomething1()
>>> {
>>>    doSomething2();
>>> }
>>>
>>> public void doSomething2()
>>> {
>>>    doSomething3();
>>> }
>>>
>>> public void doSomething3()
>>> {
>>>    doSomething4();
>>> }
>>>
>>> public void doSomething4()
>>> {
>>>    if (future.getNow(null) == null)
>>>       throw new IllegalStateException("I wanted \"Hello\"");
>>> }
>>>
>>> Here are my questions now more refined...
>>>
>>> Why does "future" not complete until after the action in whenComplete()
>>> returns?  How do I exploit this behavior?
>>>
>>> How do I get the value from "future" in doSomething4()?
>>>
>>>
>>> I could pass the "Hello" value through the doSomething#(), but that will
>>> require creating duplicate methods because other code uses the
>>> doSomething#() as they are.  I could pass null or value depending on the
>>> use case but that makes the methods complicated.
>>>
>>> I cannot access "async" since that is long gone from the stack of
>>> probably another thread.  I could save "async" in a separate field but that
>>> wastes heap space.
>>>
>>> I could change startSomething() to the following.  If I understand
>>> correctly, "unused" could be GCed and whenComplete() will never execute.
>>>
>>> public void startSomething()
>>> {
>>>    CompletableFuture<String> unused;
>>>
>>>    future = CompletableFuture.supplyAsync(() -> produce());
>>>    unused = future.whenComplete((value, throwable) -> doSomething1());
>>> }
>>>
>>> -Nathan
>>>
>>> On 11/7/2019 2:41 PM, Martin Buchholz wrote:
>>>
>>>
>>> https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/concurrent/CompletionStage.html#whenComplete(java.util.function.BiConsumer)
>>>
>>> On Thu, Nov 7, 2019 at 10:49 AM Nathan and Ila Reynolds via
>>> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>>
>>>> For CompletableStage.whenComplete(), the Javadoc says "The returned
>>>> stage is completed when the action returns."  What is the reasoning for
>>>> completing the future after action returns?
>>>
>>>
>>> The result of the returned stage depends on whether the action failed or
>>> not.
>>>
>>>
>>>> How do I run action after
>>>> the future completes?
>>>>
>>>
>>> Why can't you just attach a completion action to either the stage
>>> returned by whenComplete or its source?
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>

-- 
-Nathan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191107/e7ec2706/attachment.html>

From nigro.fra at gmail.com  Mon Nov 11 15:11:00 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Mon, 11 Nov 2019 21:11:00 +0100
Subject: [concurrency-interest] ExecutorService JMH benchmarks
Message-ID: <CAKxGtTX3Nh9fPdym_aV1Q7Z0_z-GPeQG+uCxm_+xZpcfE_imww@mail.gmail.com>

Hi gents,

in the last days I'm trying to evaluate the performance of an mpmc
unbounded queue I've developed for JCTools (here MpmcUnboundedXaddArrayQueue
<https://github.com/JCTools/JCTools/blob/3322e9fd6488da35db4f39eae4af4a0cb17db4b5/jctools-core/src/main/java/org/jctools/queues/MpmcUnboundedXaddArrayQueue.java>)
if used as a BlockingQueue in an ThreadPoolExecutor (by using a
McParkTakeStrategy
<https://github.com/JCTools/JCTools/blob/master/jctools-experimental/src/main/java/org/jctools/queues/blocking/McParkTakeStrategy.java>
on
consumer-side): there is a reliable JMH benchmark (or not, if makes sense)
used to measure the performance (different aspects too) of the executor
service implementations we have on j.u.c?

thanks,
Franz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191111/e50cfafe/attachment.html>

From leventov.ru at gmail.com  Thu Nov 14 09:46:14 2019
From: leventov.ru at gmail.com (Roman Leventov)
Date: Thu, 14 Nov 2019 17:46:14 +0300
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
Message-ID: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>

Thread.onSpinWait()'s Javadoc has the following code example:

     class EventHandler {
         volatile boolean eventNotificationNotReceived;
         void waitForEventAndHandleIt() {
             while ( eventNotificationNotReceived ) {
                 java.lang.Thread.onSpinWait();
             }
             readAndProcessEvent();
         }

         void readAndProcessEvent() {
             // Read event from some source and process it
              . . .
         }
     }

Which doesn't seem to me as the best practice of using Thread.onSpinWait().

Thread.onSpinWait() is used in a very few classes in JDK itself, even
compared to other low-level mechanisms such as LockSupport.park/unpark.
It's hard to use it right. Cf. a recent thread "Low-latency pause in JDK"
in this mailing list.

Maybe, in this case, it's better to not provide any usage example than to
provide such half-baked/"context and caveats" example, to prevent users
from copying this pattern from the highly visible Thread class's Javadocs?

Expert users, the target audience for this method, unlikely benefit from
the present example either.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/0b192a53/attachment.html>

From nathanila at gmail.com  Thu Nov 14 10:17:02 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 14 Nov 2019 08:17:02 -0700
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
Message-ID: <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>

I suppose this begs the question for the community.  What would be the
perfect example?

On Thu, Nov 14, 2019 at 7:48 AM Roman Leventov via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Thread.onSpinWait()'s Javadoc has the following code example:
>
>      class EventHandler {
>          volatile boolean eventNotificationNotReceived;
>          void waitForEventAndHandleIt() {
>              while ( eventNotificationNotReceived ) {
>                  java.lang.Thread.onSpinWait();
>              }
>              readAndProcessEvent();
>          }
>
>          void readAndProcessEvent() {
>              // Read event from some source and process it
>               . . .
>          }
>      }
>
> Which doesn't seem to me as the best practice of using Thread.onSpinWait().
>
> Thread.onSpinWait() is used in a very few classes in JDK itself, even
> compared to other low-level mechanisms such as LockSupport.park/unpark.
> It's hard to use it right. Cf. a recent thread "Low-latency pause in JDK"
> in this mailing list.
>
> Maybe, in this case, it's better to not provide any usage example than to
> provide such half-baked/"context and caveats" example, to prevent users
> from copying this pattern from the highly visible Thread class's Javadocs?
>
> Expert users, the target audience for this method, unlikely benefit from
> the present example either.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
-Nathan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/6bac63f4/attachment.html>

From david.lloyd at redhat.com  Thu Nov 14 10:19:35 2019
From: david.lloyd at redhat.com (David Lloyd)
Date: Thu, 14 Nov 2019 09:19:35 -0600
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
Message-ID: <CANghgrQKjskK5eKxurexBkDtJKjKZaZZM52E4_V5m5MPAWs0ZA@mail.gmail.com>

A trivial spin lock?

On Thu, Nov 14, 2019 at 9:18 AM Nathan and Ila Reynolds via
Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>
> I suppose this begs the question for the community.  What would be the perfect example?
>
> On Thu, Nov 14, 2019 at 7:48 AM Roman Leventov via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>
>> Thread.onSpinWait()'s Javadoc has the following code example:
>>
>>      class EventHandler {
>>          volatile boolean eventNotificationNotReceived;
>>          void waitForEventAndHandleIt() {
>>              while ( eventNotificationNotReceived ) {
>>                  java.lang.Thread.onSpinWait();
>>              }
>>              readAndProcessEvent();
>>          }
>>
>>          void readAndProcessEvent() {
>>              // Read event from some source and process it
>>               . . .
>>          }
>>      }
>>
>> Which doesn't seem to me as the best practice of using Thread.onSpinWait().
>>
>> Thread.onSpinWait() is used in a very few classes in JDK itself, even compared to other low-level mechanisms such as LockSupport.park/unpark. It's hard to use it right. Cf. a recent thread "Low-latency pause in JDK" in this mailing list.
>>
>> Maybe, in this case, it's better to not provide any usage example than to provide such half-baked/"context and caveats" example, to prevent users from copying this pattern from the highly visible Thread class's Javadocs?
>>
>> Expert users, the target audience for this method, unlikely benefit from the present example either.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> --
> -Nathan
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-- 
- DML


From nigro.fra at gmail.com  Thu Nov 14 10:31:01 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 16:31:01 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
Message-ID: <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>

I would expect it on ConcurrentLinkedQueue::poll spin loop, but cannot say
if is "that better" :)
It doesn seem so weird to me, but  maybe:

given:

volatile E obj = null;
volatile boolean done = false;

publisher thread:

this.obj = //a valid non null value
this.done = true;

receiver thread:

E poll() {
    E o = this.obj;
    if (o == null && !done) {
        return null;
     }
     //o will be !null at some point
     do {
         if (o != null)
            return o;
         java.lang.Thread.onSpinWait();
     } while(true);
}

In case like this is more appropriate, maybe, but much less intuitive
probably.


Il giorno gio 14 nov 2019 alle ore 16:18 Nathan and Ila Reynolds via
Concurrency-interest <concurrency-interest at cs.oswego.edu> ha scritto:

> I suppose this begs the question for the community.  What would be the
> perfect example?
>
> On Thu, Nov 14, 2019 at 7:48 AM Roman Leventov via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Thread.onSpinWait()'s Javadoc has the following code example:
>>
>>      class EventHandler {
>>          volatile boolean eventNotificationNotReceived;
>>          void waitForEventAndHandleIt() {
>>              while ( eventNotificationNotReceived ) {
>>                  java.lang.Thread.onSpinWait();
>>              }
>>              readAndProcessEvent();
>>          }
>>
>>          void readAndProcessEvent() {
>>              // Read event from some source and process it
>>               . . .
>>          }
>>      }
>>
>> Which doesn't seem to me as the best practice of using
>> Thread.onSpinWait().
>>
>> Thread.onSpinWait() is used in a very few classes in JDK itself, even
>> compared to other low-level mechanisms such as LockSupport.park/unpark.
>> It's hard to use it right. Cf. a recent thread "Low-latency pause in JDK"
>> in this mailing list.
>>
>> Maybe, in this case, it's better to not provide any usage example than to
>> provide such half-baked/"context and caveats" example, to prevent users
>> from copying this pattern from the highly visible Thread class's Javadocs?
>>
>> Expert users, the target audience for this method, unlikely benefit from
>> the present example either.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> --
> -Nathan
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/9d1d9be5/attachment-0001.html>

From aph at redhat.com  Thu Nov 14 10:43:45 2019
From: aph at redhat.com (Andrew Haley)
Date: Thu, 14 Nov 2019 15:43:45 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
Message-ID: <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>

On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>     E o = this.obj;
>     if (o == null && !done) {
>         return null;
>      }
>      //o will be !null at some point
>      do {
>          if (o != null)
>             return o;
>          java.lang.Thread.onSpinWait();
>      } while(true);
> }
> 
> In case like this is more appropriate, maybe, but much less intuitive
> probably.

Umm, what? o is a local. This loop spins forever.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From nigro.fra at gmail.com  Thu Nov 14 10:54:57 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 16:54:57 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
Message-ID: <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>

Sorry I've written on the email text, I forgot an important part, let me
write it properly:

   volatile E obj = null;
   volatile boolean done = false;

   public void offerOnce(E o) {
      Objects.checkNonNull(o);
      this.done = true;
      this.obj = o;
   }

  public boolean isDone() {
       return done;
  }

   public E poll() {
      E o = this.obj;
      if (o == null && !this.done) {
         return null;
      }
      //o will be !null at some point
      do {
         if (o != null)
            return o;
         java.lang.Thread.onSpinWait();
         this.obj = o;
      } while(true);
   }

Similarly to the queue API: poll should return null iff !done, but offer
update first done and then this.obj:
poll need to read obj, but has to stay consistent to the ordering, so at
some point, obj will be visible if done == true.
On JCtools we have some queues with a similar behaviour (producer sequence
is advanced before writing the actual element in the queue)
and we need to spin wait the element apprearence to stay consistent with
the isEmpty behaviour: that's a good use case for onSpinWait (when it works
:P).



Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com> ha
scritto:

> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
> >     E o = this.obj;
> >     if (o == null && !done) {
> >         return null;
> >      }
> >      //o will be !null at some point
> >      do {
> >          if (o != null)
> >             return o;
> >          java.lang.Thread.onSpinWait();
> >      } while(true);
> > }
> >
> > In case like this is more appropriate, maybe, but much less intuitive
> > probably.
>
> Umm, what? o is a local. This loop spins forever.
>
> --
> Andrew Haley  (he/him)
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> https://keybase.io/andrewhaley
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/a2b47f39/attachment.html>

From nathanila at gmail.com  Thu Nov 14 11:18:38 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 14 Nov 2019 09:18:38 -0700
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
Message-ID: <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>

In poll(), should "this.obj = o" be "o = this.obj"?  Without this 
change, it seems poll() could spin forever.

Should "poll" be renamed to "take" since the method could block until a 
value is available?

Can we get rid of "done"?  Since offerOnce() does not allow null, then 
having the done flag does not seem to help anything.

Is the compiler and execution engine in my head misinterpreting and 
mis-executing the code?

Here is the code with my suggested changes.

    volatile E obj = null;

    public void offerOnce(E o) {
       Objects.checkNonNull(o);
       this.obj = o;
    }
   public boolean isDone() {
        return obj != null;
   }

    public E take() {
       E o;

       while (true) {
          o = obj;

          if (o != null)
             return o;

          java.lang.Thread.onSpinWait();
       }
    }

-Nathan

On 11/14/2019 8:54 AM, Francesco Nigro wrote:
> Sorry I've written on the email text, I forgot an important part, let 
> me write it properly:
>
>    volatile E obj = null;
>    volatile boolean done = false;
>
>    public void offerOnce(E o) {
>       Objects.checkNonNull(o);
>       this.done = true;
>       this.obj = o;
>    }
>   public boolean isDone() {
>        return done;
>   }
>
>    public E poll() {
>       E o = this.obj;
>       if (o == null && !this.done) {
>          return null;
>       }
>       //o will be !null at some point
>       do {
>          if (o != null)
>             return o;
>          java.lang.Thread.onSpinWait();
>          this.obj = o;
>       } while(true);
>    }
>
> Similarly to the queue API: poll should return null iff !done, but 
> offer update first done and then this.obj:
> poll need to read obj, but has to stay consistent to the ordering, so 
> at some point, obj will be visible if done == true.
> On JCtools we have some queues with a similar behaviour (producer 
> sequence is advanced before writing the actual element in the queue)
> and we need to spin wait the element apprearence to stay consistent 
> with the isEmpty behaviour: that's a good use case for onSpinWait 
> (when it works :P).
>
>
>
> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com 
> <mailto:aph at redhat.com>> ha scritto:
>
>     On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>     >     E o = this.obj;
>     >     if (o == null && !done) {
>     >         return null;
>     >      }
>     >      //o will be !null at some point
>     >      do {
>     >          if (o != null)
>     >             return o;
>     >          java.lang.Thread.onSpinWait();
>     >      } while(true);
>     > }
>     >
>     > In case like this is more appropriate, maybe, but much less
>     intuitive
>     > probably.
>
>     Umm, what? o is a local. This loop spins forever.
>
>     -- 
>     Andrew Haley  (he/him)
>     Java Platform Lead Engineer
>     Red Hat UK Ltd. <https://www.redhat.com>
>     https://keybase.io/andrewhaley
>     EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/a065798a/attachment.html>

From nigro.fra at gmail.com  Thu Nov 14 11:28:19 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 17:28:19 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
Message-ID: <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>

Totally right, sorry again (writing by phone is a terrible idea :( ):
yes , poll should  use  "o = this.obj".

> Can we get rid of "done"?  Since offerOnce() does not allow null, then
having the done flag does not seem to help anything.
Absolutely yes: I've prepared this as a "simplified" (and wrong due to the
hurry, sorry for that) version of what we do on many queues in JCtools,
that's why it contains some unnecessary bits as you've rightly pointed out.
Code that is spin awaiting on a condition, sure that it will happen at some
point in the future, is something that could help to understand the rare
cases
where using onSpinWait could be beneficial IMO.



Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
nathanila at gmail.com> ha scritto:

> In poll(), should "this.obj = o" be "o = this.obj"?  Without this change,
> it seems poll() could spin forever.
>
> Should "poll" be renamed to "take" since the method could block until a
> value is available?
>
> Can we get rid of "done"?  Since offerOnce() does not allow null, then
> having the done flag does not seem to help anything.
>
> Is the compiler and execution engine in my head misinterpreting and
> mis-executing the code?
>
> Here is the code with my suggested changes.
>    volatile E obj = null;
>
>    public void offerOnce(E o) {
>       Objects.checkNonNull(o);
>       this.obj = o;
>    }
>
>   public boolean isDone() {
>        return obj != null;
>   }
>
>    public E take() {
>       E o;
>
>       while (true) {
>          o = obj;
>
>          if (o != null)
>             return o;
>
>          java.lang.Thread.onSpinWait();
>       }
>    }
>
> -Nathan
>
> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>
> Sorry I've written on the email text, I forgot an important part, let me
> write it properly:
>
>    volatile E obj = null;
>    volatile boolean done = false;
>
>    public void offerOnce(E o) {
>       Objects.checkNonNull(o);
>       this.done = true;
>       this.obj = o;
>    }
>
>   public boolean isDone() {
>        return done;
>   }
>
>    public E poll() {
>       E o = this.obj;
>       if (o == null && !this.done) {
>          return null;
>       }
>       //o will be !null at some point
>       do {
>          if (o != null)
>             return o;
>          java.lang.Thread.onSpinWait();
>          this.obj = o;
>       } while(true);
>    }
>
> Similarly to the queue API: poll should return null iff !done, but offer
> update first done and then this.obj:
> poll need to read obj, but has to stay consistent to the ordering, so at
> some point, obj will be visible if done == true.
> On JCtools we have some queues with a similar behaviour (producer sequence
> is advanced before writing the actual element in the queue)
> and we need to spin wait the element apprearence to stay consistent with
> the isEmpty behaviour: that's a good use case for onSpinWait (when it works
> :P).
>
>
>
> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com> ha
> scritto:
>
>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>> >     E o = this.obj;
>> >     if (o == null && !done) {
>> >         return null;
>> >      }
>> >      //o will be !null at some point
>> >      do {
>> >          if (o != null)
>> >             return o;
>> >          java.lang.Thread.onSpinWait();
>> >      } while(true);
>> > }
>> >
>> > In case like this is more appropriate, maybe, but much less intuitive
>> > probably.
>>
>> Umm, what? o is a local. This loop spins forever.
>>
>> --
>> Andrew Haley  (he/him)
>> Java Platform Lead Engineer
>> Red Hat UK Ltd. <https://www.redhat.com>
>> https://keybase.io/andrewhaley
>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/88701bcf/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Nov 14 16:51:43 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 14 Nov 2019 21:51:43 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
Message-ID: <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>

What's the difference between this example and what's in javadocs?

Alex

On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

> Totally right, sorry again (writing by phone is a terrible idea :( ):
> yes , poll should  use  "o = this.obj".
>
> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
> having the done flag does not seem to help anything.
> Absolutely yes: I've prepared this as a "simplified" (and wrong due to the
> hurry, sorry for that) version of what we do on many queues in JCtools,
> that's why it contains some unnecessary bits as you've rightly pointed
> out.
> Code that is spin awaiting on a condition, sure that it will happen at
> some point in the future, is something that could help to understand the
> rare cases
> where using onSpinWait could be beneficial IMO.
>
>
>
> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
> nathanila at gmail.com> ha scritto:
>
>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this change,
>> it seems poll() could spin forever.
>>
>> Should "poll" be renamed to "take" since the method could block until a
>> value is available?
>>
>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>> having the done flag does not seem to help anything.
>>
>> Is the compiler and execution engine in my head misinterpreting and
>> mis-executing the code?
>>
>> Here is the code with my suggested changes.
>>    volatile E obj = null;
>>
>>    public void offerOnce(E o) {
>>       Objects.checkNonNull(o);
>>       this.obj = o;
>>    }
>>
>>   public boolean isDone() {
>>        return obj != null;
>>   }
>>
>>    public E take() {
>>       E o;
>>
>>       while (true) {
>>          o = obj;
>>
>>          if (o != null)
>>             return o;
>>
>>          java.lang.Thread.onSpinWait();
>>       }
>>    }
>>
>> -Nathan
>>
>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>
>> Sorry I've written on the email text, I forgot an important part, let me
>> write it properly:
>>
>>    volatile E obj = null;
>>    volatile boolean done = false;
>>
>>    public void offerOnce(E o) {
>>       Objects.checkNonNull(o);
>>       this.done = true;
>>       this.obj = o;
>>    }
>>
>>   public boolean isDone() {
>>        return done;
>>   }
>>
>>    public E poll() {
>>       E o = this.obj;
>>       if (o == null && !this.done) {
>>          return null;
>>       }
>>       //o will be !null at some point
>>       do {
>>          if (o != null)
>>             return o;
>>          java.lang.Thread.onSpinWait();
>>          this.obj = o;
>>       } while(true);
>>    }
>>
>> Similarly to the queue API: poll should return null iff !done, but offer
>> update first done and then this.obj:
>> poll need to read obj, but has to stay consistent to the ordering, so at
>> some point, obj will be visible if done == true.
>> On JCtools we have some queues with a similar behaviour (producer
>> sequence is advanced before writing the actual element in the queue)
>> and we need to spin wait the element apprearence to stay consistent with
>> the isEmpty behaviour: that's a good use case for onSpinWait (when it works
>> :P).
>>
>>
>>
>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>> ha scritto:
>>
>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>> >     E o = this.obj;
>>> >     if (o == null && !done) {
>>> >         return null;
>>> >      }
>>> >      //o will be !null at some point
>>> >      do {
>>> >          if (o != null)
>>> >             return o;
>>> >          java.lang.Thread.onSpinWait();
>>> >      } while(true);
>>> > }
>>> >
>>> > In case like this is more appropriate, maybe, but much less intuitive
>>> > probably.
>>>
>>> Umm, what? o is a local. This loop spins forever.
>>>
>>> --
>>> Andrew Haley  (he/him)
>>> Java Platform Lead Engineer
>>> Red Hat UK Ltd. <https://www.redhat.com>
>>> https://keybase.io/andrewhaley
>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>
>>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/1d5cb619/attachment.html>

From nigro.fra at gmail.com  Thu Nov 14 17:22:21 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 23:22:21 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
Message-ID: <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>

Beside being more complex?
Not much I admit :)
But IMO awaiting with no algorithmical indication of the duration of the
wait (like in the javadoc) and awaiting for a finite amount of "time" a
condition that will be true at some point, is a better example where to
apply onSpinWait, although is not technically incorrect to use it for
"blind" spin loop as well.
Maybe is just a subtle difference, but I won't encourage users to blindly
spin loop on conditions and just use onSpinWait to save the day.. probably
I'm worried too much for something very simple and unavoidable; as @roman
has suggested, probably no example is better then one that is a superclass
of all the possible best cases.


Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
scritto:

> What's the difference between this example and what's in javadocs?
>
> Alex
>
> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Totally right, sorry again (writing by phone is a terrible idea :( ):
>> yes , poll should  use  "o = this.obj".
>>
>> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
>> having the done flag does not seem to help anything.
>> Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>> that's why it contains some unnecessary bits as you've rightly pointed
>> out.
>> Code that is spin awaiting on a condition, sure that it will happen at
>> some point in the future, is something that could help to understand the
>> rare cases
>> where using onSpinWait could be beneficial IMO.
>>
>>
>>
>> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>> nathanila at gmail.com> ha scritto:
>>
>>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>> change, it seems poll() could spin forever.
>>>
>>> Should "poll" be renamed to "take" since the method could block until a
>>> value is available?
>>>
>>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>> having the done flag does not seem to help anything.
>>>
>>> Is the compiler and execution engine in my head misinterpreting and
>>> mis-executing the code?
>>>
>>> Here is the code with my suggested changes.
>>>    volatile E obj = null;
>>>
>>>    public void offerOnce(E o) {
>>>       Objects.checkNonNull(o);
>>>       this.obj = o;
>>>    }
>>>
>>>   public boolean isDone() {
>>>        return obj != null;
>>>   }
>>>
>>>    public E take() {
>>>       E o;
>>>
>>>       while (true) {
>>>          o = obj;
>>>
>>>          if (o != null)
>>>             return o;
>>>
>>>          java.lang.Thread.onSpinWait();
>>>       }
>>>    }
>>>
>>> -Nathan
>>>
>>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>
>>> Sorry I've written on the email text, I forgot an important part, let me
>>> write it properly:
>>>
>>>    volatile E obj = null;
>>>    volatile boolean done = false;
>>>
>>>    public void offerOnce(E o) {
>>>       Objects.checkNonNull(o);
>>>       this.done = true;
>>>       this.obj = o;
>>>    }
>>>
>>>   public boolean isDone() {
>>>        return done;
>>>   }
>>>
>>>    public E poll() {
>>>       E o = this.obj;
>>>       if (o == null && !this.done) {
>>>          return null;
>>>       }
>>>       //o will be !null at some point
>>>       do {
>>>          if (o != null)
>>>             return o;
>>>          java.lang.Thread.onSpinWait();
>>>          this.obj = o;
>>>       } while(true);
>>>    }
>>>
>>> Similarly to the queue API: poll should return null iff !done, but offer
>>> update first done and then this.obj:
>>> poll need to read obj, but has to stay consistent to the ordering, so at
>>> some point, obj will be visible if done == true.
>>> On JCtools we have some queues with a similar behaviour (producer
>>> sequence is advanced before writing the actual element in the queue)
>>> and we need to spin wait the element apprearence to stay consistent with
>>> the isEmpty behaviour: that's a good use case for onSpinWait (when it works
>>> :P).
>>>
>>>
>>>
>>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>> ha scritto:
>>>
>>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>> >     E o = this.obj;
>>>> >     if (o == null && !done) {
>>>> >         return null;
>>>> >      }
>>>> >      //o will be !null at some point
>>>> >      do {
>>>> >          if (o != null)
>>>> >             return o;
>>>> >          java.lang.Thread.onSpinWait();
>>>> >      } while(true);
>>>> > }
>>>> >
>>>> > In case like this is more appropriate, maybe, but much less intuitive
>>>> > probably.
>>>>
>>>> Umm, what? o is a local. This loop spins forever.
>>>>
>>>> --
>>>> Andrew Haley  (he/him)
>>>> Java Platform Lead Engineer
>>>> Red Hat UK Ltd. <https://www.redhat.com>
>>>> https://keybase.io/andrewhaley
>>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>
>>>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/ccf2690c/attachment-0001.html>

From nigro.fra at gmail.com  Thu Nov 14 17:28:19 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 23:28:19 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
Message-ID: <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>

I would like to hear the opinion of Gil Gene about it too: AFAIK he was the
one (or one of many?) that has proposed it to be included in
http://openjdk.java.net/jeps/285

Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha scritto:

> Beside being more complex?
> Not much I admit :)
> But IMO awaiting with no algorithmical indication of the duration of the
> wait (like in the javadoc) and awaiting for a finite amount of "time" a
> condition that will be true at some point, is a better example where to
> apply onSpinWait, although is not technically incorrect to use it for
> "blind" spin loop as well.
> Maybe is just a subtle difference, but I won't encourage users to blindly
> spin loop on conditions and just use onSpinWait to save the day.. probably
> I'm worried too much for something very simple and unavoidable; as @roman
> has suggested, probably no example is better then one that is a superclass
> of all the possible best cases.
>
>
> Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
> scritto:
>
>> What's the difference between this example and what's in javadocs?
>>
>> Alex
>>
>> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>>> Totally right, sorry again (writing by phone is a terrible idea :( ):
>>> yes , poll should  use  "o = this.obj".
>>>
>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>> then having the done flag does not seem to help anything.
>>> Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>> that's why it contains some unnecessary bits as you've rightly pointed
>>> out.
>>> Code that is spin awaiting on a condition, sure that it will happen at
>>> some point in the future, is something that could help to understand the
>>> rare cases
>>> where using onSpinWait could be beneficial IMO.
>>>
>>>
>>>
>>> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>> nathanila at gmail.com> ha scritto:
>>>
>>>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>> change, it seems poll() could spin forever.
>>>>
>>>> Should "poll" be renamed to "take" since the method could block until a
>>>> value is available?
>>>>
>>>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>>> having the done flag does not seem to help anything.
>>>>
>>>> Is the compiler and execution engine in my head misinterpreting and
>>>> mis-executing the code?
>>>>
>>>> Here is the code with my suggested changes.
>>>>    volatile E obj = null;
>>>>
>>>>    public void offerOnce(E o) {
>>>>       Objects.checkNonNull(o);
>>>>       this.obj = o;
>>>>    }
>>>>
>>>>   public boolean isDone() {
>>>>        return obj != null;
>>>>   }
>>>>
>>>>    public E take() {
>>>>       E o;
>>>>
>>>>       while (true) {
>>>>          o = obj;
>>>>
>>>>          if (o != null)
>>>>             return o;
>>>>
>>>>          java.lang.Thread.onSpinWait();
>>>>       }
>>>>    }
>>>>
>>>> -Nathan
>>>>
>>>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>
>>>> Sorry I've written on the email text, I forgot an important part, let
>>>> me write it properly:
>>>>
>>>>    volatile E obj = null;
>>>>    volatile boolean done = false;
>>>>
>>>>    public void offerOnce(E o) {
>>>>       Objects.checkNonNull(o);
>>>>       this.done = true;
>>>>       this.obj = o;
>>>>    }
>>>>
>>>>   public boolean isDone() {
>>>>        return done;
>>>>   }
>>>>
>>>>    public E poll() {
>>>>       E o = this.obj;
>>>>       if (o == null && !this.done) {
>>>>          return null;
>>>>       }
>>>>       //o will be !null at some point
>>>>       do {
>>>>          if (o != null)
>>>>             return o;
>>>>          java.lang.Thread.onSpinWait();
>>>>          this.obj = o;
>>>>       } while(true);
>>>>    }
>>>>
>>>> Similarly to the queue API: poll should return null iff !done, but
>>>> offer update first done and then this.obj:
>>>> poll need to read obj, but has to stay consistent to the ordering, so
>>>> at some point, obj will be visible if done == true.
>>>> On JCtools we have some queues with a similar behaviour (producer
>>>> sequence is advanced before writing the actual element in the queue)
>>>> and we need to spin wait the element apprearence to stay consistent
>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>> works :P).
>>>>
>>>>
>>>>
>>>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>>> ha scritto:
>>>>
>>>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>>> >     E o = this.obj;
>>>>> >     if (o == null && !done) {
>>>>> >         return null;
>>>>> >      }
>>>>> >      //o will be !null at some point
>>>>> >      do {
>>>>> >          if (o != null)
>>>>> >             return o;
>>>>> >          java.lang.Thread.onSpinWait();
>>>>> >      } while(true);
>>>>> > }
>>>>> >
>>>>> > In case like this is more appropriate, maybe, but much less intuitive
>>>>> > probably.
>>>>>
>>>>> Umm, what? o is a local. This loop spins forever.
>>>>>
>>>>> --
>>>>> Andrew Haley  (he/him)
>>>>> Java Platform Lead Engineer
>>>>> Red Hat UK Ltd. <https://www.redhat.com>
>>>>> https://keybase.io/andrewhaley
>>>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>>
>>>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/f0175b57/attachment.html>

From nigro.fra at gmail.com  Thu Nov 14 17:28:54 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Thu, 14 Nov 2019 23:28:54 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
Message-ID: <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>

Gil Tene* Android typo error

Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha scritto:

> I would like to hear the opinion of Gil Gene about it too: AFAIK he was
> the one (or one of many?) that has proposed it to be included in
> http://openjdk.java.net/jeps/285
>
> Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
> scritto:
>
>> Beside being more complex?
>> Not much I admit :)
>> But IMO awaiting with no algorithmical indication of the duration of the
>> wait (like in the javadoc) and awaiting for a finite amount of "time" a
>> condition that will be true at some point, is a better example where to
>> apply onSpinWait, although is not technically incorrect to use it for
>> "blind" spin loop as well.
>> Maybe is just a subtle difference, but I won't encourage users to blindly
>> spin loop on conditions and just use onSpinWait to save the day.. probably
>> I'm worried too much for something very simple and unavoidable; as @roman
>> has suggested, probably no example is better then one that is a superclass
>> of all the possible best cases.
>>
>>
>> Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
>> scritto:
>>
>>> What's the difference between this example and what's in javadocs?
>>>
>>> Alex
>>>
>>> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>>
>>>> Totally right, sorry again (writing by phone is a terrible idea :( ):
>>>> yes , poll should  use  "o = this.obj".
>>>>
>>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>> then having the done flag does not seem to help anything.
>>>> Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>>> that's why it contains some unnecessary bits as you've rightly pointed
>>>> out.
>>>> Code that is spin awaiting on a condition, sure that it will happen at
>>>> some point in the future, is something that could help to understand the
>>>> rare cases
>>>> where using onSpinWait could be beneficial IMO.
>>>>
>>>>
>>>>
>>>> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>>> nathanila at gmail.com> ha scritto:
>>>>
>>>>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>>> change, it seems poll() could spin forever.
>>>>>
>>>>> Should "poll" be renamed to "take" since the method could block until
>>>>> a value is available?
>>>>>
>>>>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>>>> having the done flag does not seem to help anything.
>>>>>
>>>>> Is the compiler and execution engine in my head misinterpreting and
>>>>> mis-executing the code?
>>>>>
>>>>> Here is the code with my suggested changes.
>>>>>    volatile E obj = null;
>>>>>
>>>>>    public void offerOnce(E o) {
>>>>>       Objects.checkNonNull(o);
>>>>>       this.obj = o;
>>>>>    }
>>>>>
>>>>>   public boolean isDone() {
>>>>>        return obj != null;
>>>>>   }
>>>>>
>>>>>    public E take() {
>>>>>       E o;
>>>>>
>>>>>       while (true) {
>>>>>          o = obj;
>>>>>
>>>>>          if (o != null)
>>>>>             return o;
>>>>>
>>>>>          java.lang.Thread.onSpinWait();
>>>>>       }
>>>>>    }
>>>>>
>>>>> -Nathan
>>>>>
>>>>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>>
>>>>> Sorry I've written on the email text, I forgot an important part, let
>>>>> me write it properly:
>>>>>
>>>>>    volatile E obj = null;
>>>>>    volatile boolean done = false;
>>>>>
>>>>>    public void offerOnce(E o) {
>>>>>       Objects.checkNonNull(o);
>>>>>       this.done = true;
>>>>>       this.obj = o;
>>>>>    }
>>>>>
>>>>>   public boolean isDone() {
>>>>>        return done;
>>>>>   }
>>>>>
>>>>>    public E poll() {
>>>>>       E o = this.obj;
>>>>>       if (o == null && !this.done) {
>>>>>          return null;
>>>>>       }
>>>>>       //o will be !null at some point
>>>>>       do {
>>>>>          if (o != null)
>>>>>             return o;
>>>>>          java.lang.Thread.onSpinWait();
>>>>>          this.obj = o;
>>>>>       } while(true);
>>>>>    }
>>>>>
>>>>> Similarly to the queue API: poll should return null iff !done, but
>>>>> offer update first done and then this.obj:
>>>>> poll need to read obj, but has to stay consistent to the ordering, so
>>>>> at some point, obj will be visible if done == true.
>>>>> On JCtools we have some queues with a similar behaviour (producer
>>>>> sequence is advanced before writing the actual element in the queue)
>>>>> and we need to spin wait the element apprearence to stay consistent
>>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>>> works :P).
>>>>>
>>>>>
>>>>>
>>>>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>>>> ha scritto:
>>>>>
>>>>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>>>> >     E o = this.obj;
>>>>>> >     if (o == null && !done) {
>>>>>> >         return null;
>>>>>> >      }
>>>>>> >      //o will be !null at some point
>>>>>> >      do {
>>>>>> >          if (o != null)
>>>>>> >             return o;
>>>>>> >          java.lang.Thread.onSpinWait();
>>>>>> >      } while(true);
>>>>>> > }
>>>>>> >
>>>>>> > In case like this is more appropriate, maybe, but much less
>>>>>> intuitive
>>>>>> > probably.
>>>>>>
>>>>>> Umm, what? o is a local. This loop spins forever.
>>>>>>
>>>>>> --
>>>>>> Andrew Haley  (he/him)
>>>>>> Java Platform Lead Engineer
>>>>>> Red Hat UK Ltd. <https://www.redhat.com>
>>>>>> https://keybase.io/andrewhaley
>>>>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>>>
>>>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/c345ec90/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Nov 14 18:10:49 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 14 Nov 2019 23:10:49 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
Message-ID: <CANkgWKi65MFdm_HEdBFkcU36zRL5K2dKVvWMztt+RTFjRe4E9g@mail.gmail.com>

That's the thing, I don't see what is more complex or more instructive
about the differently written loop that breaks on observing a 1-bit state
change.

When I hear "time" pronounced in the context of wait, I shudder. Strict
time bound makes no sense in a non real time OS. You can only formulate a
termination condition in terms of happens before. So you can only say "10ms
elapses before I will break out of the wait loop". But you don't need
onSpinWait to know that. In fact, you just can't implement it without a
computation model with arbitrary suspension points.

Alex


On Thu, 14 Nov 2019, 22:22 Francesco Nigro, <nigro.fra at gmail.com> wrote:

> Beside being more complex?
> Not much I admit :)
> But IMO awaiting with no algorithmical indication of the duration of the
> wait (like in the javadoc) and awaiting for a finite amount of "time" a
> condition that will be true at some point, is a better example where to
> apply onSpinWait, although is not technically incorrect to use it for
> "blind" spin loop as well.
> Maybe is just a subtle difference, but I won't encourage users to blindly
> spin loop on conditions and just use onSpinWait to save the day.. probably
> I'm worried too much for something very simple and unavoidable; as @roman
> has suggested, probably no example is better then one that is a superclass
> of all the possible best cases.
>
>
> Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
> scritto:
>
>> What's the difference between this example and what's in javadocs?
>>
>> Alex
>>
>> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>>> Totally right, sorry again (writing by phone is a terrible idea :( ):
>>> yes , poll should  use  "o = this.obj".
>>>
>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>> then having the done flag does not seem to help anything.
>>> Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>> that's why it contains some unnecessary bits as you've rightly pointed
>>> out.
>>> Code that is spin awaiting on a condition, sure that it will happen at
>>> some point in the future, is something that could help to understand the
>>> rare cases
>>> where using onSpinWait could be beneficial IMO.
>>>
>>>
>>>
>>> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>> nathanila at gmail.com> ha scritto:
>>>
>>>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>> change, it seems poll() could spin forever.
>>>>
>>>> Should "poll" be renamed to "take" since the method could block until a
>>>> value is available?
>>>>
>>>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>>> having the done flag does not seem to help anything.
>>>>
>>>> Is the compiler and execution engine in my head misinterpreting and
>>>> mis-executing the code?
>>>>
>>>> Here is the code with my suggested changes.
>>>>    volatile E obj = null;
>>>>
>>>>    public void offerOnce(E o) {
>>>>       Objects.checkNonNull(o);
>>>>       this.obj = o;
>>>>    }
>>>>
>>>>   public boolean isDone() {
>>>>        return obj != null;
>>>>   }
>>>>
>>>>    public E take() {
>>>>       E o;
>>>>
>>>>       while (true) {
>>>>          o = obj;
>>>>
>>>>          if (o != null)
>>>>             return o;
>>>>
>>>>          java.lang.Thread.onSpinWait();
>>>>       }
>>>>    }
>>>>
>>>> -Nathan
>>>>
>>>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>
>>>> Sorry I've written on the email text, I forgot an important part, let
>>>> me write it properly:
>>>>
>>>>    volatile E obj = null;
>>>>    volatile boolean done = false;
>>>>
>>>>    public void offerOnce(E o) {
>>>>       Objects.checkNonNull(o);
>>>>       this.done = true;
>>>>       this.obj = o;
>>>>    }
>>>>
>>>>   public boolean isDone() {
>>>>        return done;
>>>>   }
>>>>
>>>>    public E poll() {
>>>>       E o = this.obj;
>>>>       if (o == null && !this.done) {
>>>>          return null;
>>>>       }
>>>>       //o will be !null at some point
>>>>       do {
>>>>          if (o != null)
>>>>             return o;
>>>>          java.lang.Thread.onSpinWait();
>>>>          this.obj = o;
>>>>       } while(true);
>>>>    }
>>>>
>>>> Similarly to the queue API: poll should return null iff !done, but
>>>> offer update first done and then this.obj:
>>>> poll need to read obj, but has to stay consistent to the ordering, so
>>>> at some point, obj will be visible if done == true.
>>>> On JCtools we have some queues with a similar behaviour (producer
>>>> sequence is advanced before writing the actual element in the queue)
>>>> and we need to spin wait the element apprearence to stay consistent
>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>> works :P).
>>>>
>>>>
>>>>
>>>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>>> ha scritto:
>>>>
>>>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>>> >     E o = this.obj;
>>>>> >     if (o == null && !done) {
>>>>> >         return null;
>>>>> >      }
>>>>> >      //o will be !null at some point
>>>>> >      do {
>>>>> >          if (o != null)
>>>>> >             return o;
>>>>> >          java.lang.Thread.onSpinWait();
>>>>> >      } while(true);
>>>>> > }
>>>>> >
>>>>> > In case like this is more appropriate, maybe, but much less intuitive
>>>>> > probably.
>>>>>
>>>>> Umm, what? o is a local. This loop spins forever.
>>>>>
>>>>> --
>>>>> Andrew Haley  (he/him)
>>>>> Java Platform Lead Engineer
>>>>> Red Hat UK Ltd. <https://www.redhat.com>
>>>>> https://keybase.io/andrewhaley
>>>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>>
>>>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191114/52ddf3b1/attachment.html>

From nigro.fra at gmail.com  Thu Nov 14 23:41:26 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Fri, 15 Nov 2019 05:41:26 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANkgWKi65MFdm_HEdBFkcU36zRL5K2dKVvWMztt+RTFjRe4E9g@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CANkgWKi65MFdm_HEdBFkcU36zRL5K2dKVvWMztt+RTFjRe4E9g@mail.gmail.com>
Message-ID: <CAKxGtTXPUmgPpOZOJsa+7i008gaM3wxRtuhnwW8-_-5wJyuR1g@mail.gmail.com>

Agree on all your points, just hope you won't shudder too much of my
inappropriate use of "time" word  :) (with double quotes on purpose), but
let me try to improve it: on my goofy attempt to show a better example,
there was a properly established happens before relationship ensuring that
the condition awaited on the spin wait loop would hold after a finite
amount of iterations, in theory, but infinite in practice, due to OS
scheduling decisions. Turning a possibly nice wait free algorithm into a
lock-free one for the sake of making it faster in the common path is a
frequent choice for many data-structures and using onSpinWait in similar
scenarios really improve the worst case latency ie is a proper use case for
it.
I believe that *at least* providing some context to the user would be
better, although I understand that is outside the scope of the doc to tech
concurrent programming to the reader.




Il ven 15 nov 2019, 00:11 Alex Otenko <oleksandr.otenko at gmail.com> ha
scritto:

> That's the thing, I don't see what is more complex or more instructive
> about the differently written loop that breaks on observing a 1-bit state
> change.
>
> When I hear "time" pronounced in the context of wait, I shudder. Strict
> time bound makes no sense in a non real time OS. You can only formulate a
> termination condition in terms of happens before. So you can only say "10ms
> elapses before I will break out of the wait loop". But you don't need
> onSpinWait to know that. In fact, you just can't implement it without a
> computation model with arbitrary suspension points.
>
> Alex
>
>
> On Thu, 14 Nov 2019, 22:22 Francesco Nigro, <nigro.fra at gmail.com> wrote:
>
>> Beside being more complex?
>> Not much I admit :)
>> But IMO awaiting with no algorithmical indication of the duration of the
>> wait (like in the javadoc) and awaiting for a finite amount of "time" a
>> condition that will be true at some point, is a better example where to
>> apply onSpinWait, although is not technically incorrect to use it for
>> "blind" spin loop as well.
>> Maybe is just a subtle difference, but I won't encourage users to blindly
>> spin loop on conditions and just use onSpinWait to save the day.. probably
>> I'm worried too much for something very simple and unavoidable; as @roman
>> has suggested, probably no example is better then one that is a superclass
>> of all the possible best cases.
>>
>>
>> Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
>> scritto:
>>
>>> What's the difference between this example and what's in javadocs?
>>>
>>> Alex
>>>
>>> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>>
>>>> Totally right, sorry again (writing by phone is a terrible idea :( ):
>>>> yes , poll should  use  "o = this.obj".
>>>>
>>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>> then having the done flag does not seem to help anything.
>>>> Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>>> that's why it contains some unnecessary bits as you've rightly pointed
>>>> out.
>>>> Code that is spin awaiting on a condition, sure that it will happen at
>>>> some point in the future, is something that could help to understand the
>>>> rare cases
>>>> where using onSpinWait could be beneficial IMO.
>>>>
>>>>
>>>>
>>>> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>>> nathanila at gmail.com> ha scritto:
>>>>
>>>>> In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>>> change, it seems poll() could spin forever.
>>>>>
>>>>> Should "poll" be renamed to "take" since the method could block until
>>>>> a value is available?
>>>>>
>>>>> Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>>>> having the done flag does not seem to help anything.
>>>>>
>>>>> Is the compiler and execution engine in my head misinterpreting and
>>>>> mis-executing the code?
>>>>>
>>>>> Here is the code with my suggested changes.
>>>>>    volatile E obj = null;
>>>>>
>>>>>    public void offerOnce(E o) {
>>>>>       Objects.checkNonNull(o);
>>>>>       this.obj = o;
>>>>>    }
>>>>>
>>>>>   public boolean isDone() {
>>>>>        return obj != null;
>>>>>   }
>>>>>
>>>>>    public E take() {
>>>>>       E o;
>>>>>
>>>>>       while (true) {
>>>>>          o = obj;
>>>>>
>>>>>          if (o != null)
>>>>>             return o;
>>>>>
>>>>>          java.lang.Thread.onSpinWait();
>>>>>       }
>>>>>    }
>>>>>
>>>>> -Nathan
>>>>>
>>>>> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>>
>>>>> Sorry I've written on the email text, I forgot an important part, let
>>>>> me write it properly:
>>>>>
>>>>>    volatile E obj = null;
>>>>>    volatile boolean done = false;
>>>>>
>>>>>    public void offerOnce(E o) {
>>>>>       Objects.checkNonNull(o);
>>>>>       this.done = true;
>>>>>       this.obj = o;
>>>>>    }
>>>>>
>>>>>   public boolean isDone() {
>>>>>        return done;
>>>>>   }
>>>>>
>>>>>    public E poll() {
>>>>>       E o = this.obj;
>>>>>       if (o == null && !this.done) {
>>>>>          return null;
>>>>>       }
>>>>>       //o will be !null at some point
>>>>>       do {
>>>>>          if (o != null)
>>>>>             return o;
>>>>>          java.lang.Thread.onSpinWait();
>>>>>          this.obj = o;
>>>>>       } while(true);
>>>>>    }
>>>>>
>>>>> Similarly to the queue API: poll should return null iff !done, but
>>>>> offer update first done and then this.obj:
>>>>> poll need to read obj, but has to stay consistent to the ordering, so
>>>>> at some point, obj will be visible if done == true.
>>>>> On JCtools we have some queues with a similar behaviour (producer
>>>>> sequence is advanced before writing the actual element in the queue)
>>>>> and we need to spin wait the element apprearence to stay consistent
>>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>>> works :P).
>>>>>
>>>>>
>>>>>
>>>>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>>>> ha scritto:
>>>>>
>>>>>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>>>> >     E o = this.obj;
>>>>>> >     if (o == null && !done) {
>>>>>> >         return null;
>>>>>> >      }
>>>>>> >      //o will be !null at some point
>>>>>> >      do {
>>>>>> >          if (o != null)
>>>>>> >             return o;
>>>>>> >          java.lang.Thread.onSpinWait();
>>>>>> >      } while(true);
>>>>>> > }
>>>>>> >
>>>>>> > In case like this is more appropriate, maybe, but much less
>>>>>> intuitive
>>>>>> > probably.
>>>>>>
>>>>>> Umm, what? o is a local. This loop spins forever.
>>>>>>
>>>>>> --
>>>>>> Andrew Haley  (he/him)
>>>>>> Java Platform Lead Engineer
>>>>>> Red Hat UK Ltd. <https://www.redhat.com>
>>>>>> https://keybase.io/andrewhaley
>>>>>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>>>
>>>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/7583604e/attachment-0001.html>

From gil at azul.com  Fri Nov 15 00:38:48 2019
From: gil at azul.com (Gil Tene)
Date: Fri, 15 Nov 2019 05:38:48 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
Message-ID: <7682E436-54AE-4026-B514-320C76E805A6@azul.com>

I guess I'm missing something about the starting point in this thread. What do you find "half baked"
about the actual example in the Javadoc? It's one of the common use cases (with no time-based
backoffs) in various applications (ones that e.g. dedicate a spinning thread on a dedicated core).

E.g. https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java

There are obviously additional common variants, some of which include backoff mechanisms
(time based, count based, phase of moon based, etc.), but IMO there is no "right way" to do this,
and a no-backoff use case is just as valid (and maybe even common) as one that includes a
backoff. The code carefully avoids spelling out how "eventNotificationNotReceived" is determined.
Hey, the event may even be a backoff timeout...

Would a more detailed/complicated/opinionated example of a specific backoff flavor would help
make the meaning and use of the method more clear, or help point out caveats or pitfalls better?

> On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> Gil Tene* Android typo error
> 
> Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha scritto:
> I would like to hear the opinion of Gil Gene about it too: AFAIK he was the one (or one of many?) that has proposed it to be included in http://openjdk.java.net/jeps/285
> 
> Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha scritto:
> Beside being more complex?
> Not much I admit :)
> But IMO awaiting with no algorithmical indication of the duration of the wait (like in the javadoc) and awaiting for a finite amount of "time" a condition that will be true at some point, is a better example where to apply onSpinWait, although is not technically incorrect to use it for "blind" spin loop as well.
> Maybe is just a subtle difference, but I won't encourage users to blindly spin loop on conditions and just use onSpinWait to save the day.. probably I'm worried too much for something very simple and unavoidable; as @roman has suggested, probably no example is better then one that is a superclass of all the possible best cases.
> 
> 
> Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha scritto:
> What's the difference between this example and what's in javadocs?
> 
> Alex
> 
> On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <concurrency-interest at cs.oswego.edu> wrote:
> Totally right, sorry again (writing by phone is a terrible idea :( ):
> yes , poll should  use  "o = this.obj".
> 
> > Can we get rid of "done"?  Since offerOnce() does not allow null, then having the done flag does not seem to help anything.
> Absolutely yes: I've prepared this as a "simplified" (and wrong due to the hurry, sorry for that) version of what we do on many queues in JCtools,
> that's why it contains some unnecessary bits as you've rightly pointed out.
> Code that is spin awaiting on a condition, sure that it will happen at some point in the future, is something that could help to understand the rare cases
> where using onSpinWait could be beneficial IMO.
> 
> 
> 
> Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <nathanila at gmail.com> ha scritto:
> In poll(), should "this.obj = o" be "o = this.obj"?  Without this change, it seems poll() could spin forever.
> 
> Should "poll" be renamed to "take" since the method could block until a value is available?
> 
> Can we get rid of "done"?  Since offerOnce() does not allow null, then having the done flag does not seem to help anything.
> 
> Is the compiler and execution engine in my head misinterpreting and mis-executing the code?
> 
> Here is the code with my suggested changes.
> 
>    volatile E obj = null;
> 
>    public void offerOnce(E o) {
>       Objects.checkNonNull(o);
>       this.obj = o;
>    }
> 
>   public boolean isDone() {
>        return obj != null;
>   }
> 
>    public E take() {
>       E o;
> 
>       while (true) {
>          o = obj;
> 
>          if (o != null)
>             return o;
> 
>          java.lang.Thread.onSpinWait();
>       }
>    }
> -Nathan
> On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>> Sorry I've written on the email text, I forgot an important part, let me write it properly:
>> 
>>    volatile E obj = null;
>>    volatile boolean done = false;
>> 
>>    public void offerOnce(E o) {
>>       Objects.checkNonNull(o);
>>       this.done = true;
>>       this.obj = o;
>>    }
>> 
>>   public boolean isDone() {
>>        return done;
>>   }
>> 
>>    public E poll() {
>>       E o = this.obj;
>>       if (o == null && !this.done) {
>>          return null;
>>       }
>>       //o will be !null at some point
>>       do {
>>          if (o != null)
>>             return o;
>>          java.lang.Thread.onSpinWait();
>>          this.obj = o;
>>       } while(true);
>>    }
>> 
>> Similarly to the queue API: poll should return null iff !done, but offer update first done and then this.obj:
>> poll need to read obj, but has to stay consistent to the ordering, so at some point, obj will be visible if done == true.
>> On JCtools we have some queues with a similar behaviour (producer sequence is advanced before writing the actual element in the queue)
>> and we need to spin wait the element apprearence to stay consistent with the isEmpty behaviour: that's a good use case for onSpinWait (when it works :P).
>> 
>> 
>> 
>> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com> ha scritto:
>> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>> >     E o = this.obj;
>> >     if (o == null && !done) {
>> >         return null;
>> >      }
>> >      //o will be !null at some point
>> >      do {
>> >          if (o != null)
>> >             return o;
>> >          java.lang.Thread.onSpinWait();
>> >      } while(true);
>> > }
>> >
>> > In case like this is more appropriate, maybe, but much less intuitive
>> > probably.
>> 
>> Umm, what? o is a local. This loop spins forever.
>> 
>> --
>> Andrew Haley  (he/him)
>> Java Platform Lead Engineer
>> Red Hat UK Ltd. <https://www.redhat.com>
>> https://keybase.io/andrewhaley
>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/ea49c644/attachment.sig>

From nigro.fra at gmail.com  Fri Nov 15 03:03:05 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Fri, 15 Nov 2019 09:03:05 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
Message-ID: <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>

Hi Gil,

It's one of the common use cases

:) Although I can say the same I'm not quite sure that is that common and
your example re LMAX makes it even more clear (not that mine on JCTools is
better eh!)
On the other hand, onSpinWait itself is equally uncommon on j.u.c., so I
take all your points re the existing doc.

Would a more detailed/complicated/opinionated example of a specific backoff
> flavor would help
> make the meaning and use of the method more clear, or help point out
> caveats or pitfalls better?

My (personal) fear is that users will recognize the general busy spin loop
pattern, thinking that given that the JVM "is able to optmize it" (thanks
to help of unicorns and rainbows too) and
making it a much more attractive pairs of scissors to play with then before
:)


Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha scritto:

> I guess I'm missing something about the starting point in this thread.
> What do you find "half baked"
> about the actual example in the Javadoc? It's one of the common use cases
> (with no time-based
> backoffs) in various applications (ones that e.g. dedicate a spinning
> thread on a dedicated core).
>
> E.g.
> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>
> There are obviously additional common variants, some of which include
> backoff mechanisms
> (time based, count based, phase of moon based, etc.), but IMO there is no
> "right way" to do this,
> and a no-backoff use case is just as valid (and maybe even common) as one
> that includes a
> backoff. The code carefully avoids spelling out how
> "eventNotificationNotReceived" is determined.
> Hey, the event may even be a backoff timeout...
>
> Would a more detailed/complicated/opinionated example of a specific
> backoff flavor would help
> make the meaning and use of the method more clear, or help point out
> caveats or pitfalls better?
>
> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
> >
> > Gil Tene* Android typo error
> >
> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
> scritto:
> > I would like to hear the opinion of Gil Gene about it too: AFAIK he was
> the one (or one of many?) that has proposed it to be included in
> http://openjdk.java.net/jeps/285
> >
> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
> scritto:
> > Beside being more complex?
> > Not much I admit :)
> > But IMO awaiting with no algorithmical indication of the duration of the
> wait (like in the javadoc) and awaiting for a finite amount of "time" a
> condition that will be true at some point, is a better example where to
> apply onSpinWait, although is not technically incorrect to use it for
> "blind" spin loop as well.
> > Maybe is just a subtle difference, but I won't encourage users to
> blindly spin loop on conditions and just use onSpinWait to save the day..
> probably I'm worried too much for something very simple and unavoidable; as
> @roman has suggested, probably no example is better then one that is a
> superclass of all the possible best cases.
> >
> >
> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
> scritto:
> > What's the difference between this example and what's in javadocs?
> >
> > Alex
> >
> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
> concurrency-interest at cs.oswego.edu> wrote:
> > Totally right, sorry again (writing by phone is a terrible idea :( ):
> > yes , poll should  use  "o = this.obj".
> >
> > > Can we get rid of "done"?  Since offerOnce() does not allow null, then
> having the done flag does not seem to help anything.
> > Absolutely yes: I've prepared this as a "simplified" (and wrong due to
> the hurry, sorry for that) version of what we do on many queues in JCtools,
> > that's why it contains some unnecessary bits as you've rightly pointed
> out.
> > Code that is spin awaiting on a condition, sure that it will happen at
> some point in the future, is something that could help to understand the
> rare cases
> > where using onSpinWait could be beneficial IMO.
> >
> >
> >
> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
> nathanila at gmail.com> ha scritto:
> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
> change, it seems poll() could spin forever.
> >
> > Should "poll" be renamed to "take" since the method could block until a
> value is available?
> >
> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
> having the done flag does not seem to help anything.
> >
> > Is the compiler and execution engine in my head misinterpreting and
> mis-executing the code?
> >
> > Here is the code with my suggested changes.
> >
> >    volatile E obj = null;
> >
> >    public void offerOnce(E o) {
> >       Objects.checkNonNull(o);
> >       this.obj = o;
> >    }
> >
> >   public boolean isDone() {
> >        return obj != null;
> >   }
> >
> >    public E take() {
> >       E o;
> >
> >       while (true) {
> >          o = obj;
> >
> >          if (o != null)
> >             return o;
> >
> >          java.lang.Thread.onSpinWait();
> >       }
> >    }
> > -Nathan
> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
> >> Sorry I've written on the email text, I forgot an important part, let
> me write it properly:
> >>
> >>    volatile E obj = null;
> >>    volatile boolean done = false;
> >>
> >>    public void offerOnce(E o) {
> >>       Objects.checkNonNull(o);
> >>       this.done = true;
> >>       this.obj = o;
> >>    }
> >>
> >>   public boolean isDone() {
> >>        return done;
> >>   }
> >>
> >>    public E poll() {
> >>       E o = this.obj;
> >>       if (o == null && !this.done) {
> >>          return null;
> >>       }
> >>       //o will be !null at some point
> >>       do {
> >>          if (o != null)
> >>             return o;
> >>          java.lang.Thread.onSpinWait();
> >>          this.obj = o;
> >>       } while(true);
> >>    }
> >>
> >> Similarly to the queue API: poll should return null iff !done, but
> offer update first done and then this.obj:
> >> poll need to read obj, but has to stay consistent to the ordering, so
> at some point, obj will be visible if done == true.
> >> On JCtools we have some queues with a similar behaviour (producer
> sequence is advanced before writing the actual element in the queue)
> >> and we need to spin wait the element apprearence to stay consistent
> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
> works :P).
> >>
> >>
> >>
> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
> ha scritto:
> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
> >> >     E o = this.obj;
> >> >     if (o == null && !done) {
> >> >         return null;
> >> >      }
> >> >      //o will be !null at some point
> >> >      do {
> >> >          if (o != null)
> >> >             return o;
> >> >          java.lang.Thread.onSpinWait();
> >> >      } while(true);
> >> > }
> >> >
> >> > In case like this is more appropriate, maybe, but much less intuitive
> >> > probably.
> >>
> >> Umm, what? o is a local. This loop spins forever.
> >>
> >> --
> >> Andrew Haley  (he/him)
> >> Java Platform Lead Engineer
> >> Red Hat UK Ltd. <https://www.redhat.com>
> >> https://keybase.io/andrewhaley
> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/c967d8ed/attachment-0001.html>

From leventov.ru at gmail.com  Fri Nov 15 05:04:34 2019
From: leventov.ru at gmail.com (Roman Leventov)
Date: Fri, 15 Nov 2019 13:04:34 +0300
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
Message-ID: <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>

By "half-baked" I meant specifically that the example could be valid but
only under specific conditions, such as core-pinned thread, or backoff
timeout event, etc. However, the "mundane" class and method names which are
chosen ("EventHandler") may mislead users into thinking that spin-loop is a
good go-to strategy to waiting for some conditions/logic executed, instead
of using a synchronization primitive or attaching a listener to a
CompletableFuture/ListeanableFuture if one is involved.

I like Francesco's example because it is self-contained and doesn't need
any backoff, so the complicated discussion of the tradeoffs involved and
conditions which should be accounted for (typical wait time, GC algorithm,
busyness of the system, etc.) could be blissfully omitted.

On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Hi Gil,
>
> It's one of the common use cases
>
> :) Although I can say the same I'm not quite sure that is that common and
> your example re LMAX makes it even more clear (not that mine on JCTools is
> better eh!)
> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so I
> take all your points re the existing doc.
>
> Would a more detailed/complicated/opinionated example of a specific
>> backoff flavor would help
>> make the meaning and use of the method more clear, or help point out
>> caveats or pitfalls better?
>
> My (personal) fear is that users will recognize the general busy spin loop
> pattern, thinking that given that the JVM "is able to optmize it" (thanks
> to help of unicorns and rainbows too) and
> making it a much more attractive pairs of scissors to play with then
> before :)
>
>
> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
> scritto:
>
>> I guess I'm missing something about the starting point in this thread.
>> What do you find "half baked"
>> about the actual example in the Javadoc? It's one of the common use cases
>> (with no time-based
>> backoffs) in various applications (ones that e.g. dedicate a spinning
>> thread on a dedicated core).
>>
>> E.g.
>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>
>> There are obviously additional common variants, some of which include
>> backoff mechanisms
>> (time based, count based, phase of moon based, etc.), but IMO there is no
>> "right way" to do this,
>> and a no-backoff use case is just as valid (and maybe even common) as one
>> that includes a
>> backoff. The code carefully avoids spelling out how
>> "eventNotificationNotReceived" is determined.
>> Hey, the event may even be a backoff timeout...
>>
>> Would a more detailed/complicated/opinionated example of a specific
>> backoff flavor would help
>> make the meaning and use of the method more clear, or help point out
>> caveats or pitfalls better?
>>
>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> wrote:
>> >
>> > Gil Tene* Android typo error
>> >
>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>> scritto:
>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he was
>> the one (or one of many?) that has proposed it to be included in
>> http://openjdk.java.net/jeps/285
>> >
>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>> scritto:
>> > Beside being more complex?
>> > Not much I admit :)
>> > But IMO awaiting with no algorithmical indication of the duration of
>> the wait (like in the javadoc) and awaiting for a finite amount of "time" a
>> condition that will be true at some point, is a better example where to
>> apply onSpinWait, although is not technically incorrect to use it for
>> "blind" spin loop as well.
>> > Maybe is just a subtle difference, but I won't encourage users to
>> blindly spin loop on conditions and just use onSpinWait to save the day..
>> probably I'm worried too much for something very simple and unavoidable; as
>> @roman has suggested, probably no example is better then one that is a
>> superclass of all the possible best cases.
>> >
>> >
>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
>> scritto:
>> > What's the difference between this example and what's in javadocs?
>> >
>> > Alex
>> >
>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>> concurrency-interest at cs.oswego.edu> wrote:
>> > Totally right, sorry again (writing by phone is a terrible idea :( ):
>> > yes , poll should  use  "o = this.obj".
>> >
>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>> then having the done flag does not seem to help anything.
>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>> > that's why it contains some unnecessary bits as you've rightly pointed
>> out.
>> > Code that is spin awaiting on a condition, sure that it will happen at
>> some point in the future, is something that could help to understand the
>> rare cases
>> > where using onSpinWait could be beneficial IMO.
>> >
>> >
>> >
>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>> nathanila at gmail.com> ha scritto:
>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>> change, it seems poll() could spin forever.
>> >
>> > Should "poll" be renamed to "take" since the method could block until a
>> value is available?
>> >
>> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
>> having the done flag does not seem to help anything.
>> >
>> > Is the compiler and execution engine in my head misinterpreting and
>> mis-executing the code?
>> >
>> > Here is the code with my suggested changes.
>> >
>> >    volatile E obj = null;
>> >
>> >    public void offerOnce(E o) {
>> >       Objects.checkNonNull(o);
>> >       this.obj = o;
>> >    }
>> >
>> >   public boolean isDone() {
>> >        return obj != null;
>> >   }
>> >
>> >    public E take() {
>> >       E o;
>> >
>> >       while (true) {
>> >          o = obj;
>> >
>> >          if (o != null)
>> >             return o;
>> >
>> >          java.lang.Thread.onSpinWait();
>> >       }
>> >    }
>> > -Nathan
>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>> >> Sorry I've written on the email text, I forgot an important part, let
>> me write it properly:
>> >>
>> >>    volatile E obj = null;
>> >>    volatile boolean done = false;
>> >>
>> >>    public void offerOnce(E o) {
>> >>       Objects.checkNonNull(o);
>> >>       this.done = true;
>> >>       this.obj = o;
>> >>    }
>> >>
>> >>   public boolean isDone() {
>> >>        return done;
>> >>   }
>> >>
>> >>    public E poll() {
>> >>       E o = this.obj;
>> >>       if (o == null && !this.done) {
>> >>          return null;
>> >>       }
>> >>       //o will be !null at some point
>> >>       do {
>> >>          if (o != null)
>> >>             return o;
>> >>          java.lang.Thread.onSpinWait();
>> >>          this.obj = o;
>> >>       } while(true);
>> >>    }
>> >>
>> >> Similarly to the queue API: poll should return null iff !done, but
>> offer update first done and then this.obj:
>> >> poll need to read obj, but has to stay consistent to the ordering, so
>> at some point, obj will be visible if done == true.
>> >> On JCtools we have some queues with a similar behaviour (producer
>> sequence is advanced before writing the actual element in the queue)
>> >> and we need to spin wait the element apprearence to stay consistent
>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>> works :P).
>> >>
>> >>
>> >>
>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>> ha scritto:
>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>> >> >     E o = this.obj;
>> >> >     if (o == null && !done) {
>> >> >         return null;
>> >> >      }
>> >> >      //o will be !null at some point
>> >> >      do {
>> >> >          if (o != null)
>> >> >             return o;
>> >> >          java.lang.Thread.onSpinWait();
>> >> >      } while(true);
>> >> > }
>> >> >
>> >> > In case like this is more appropriate, maybe, but much less intuitive
>> >> > probably.
>> >>
>> >> Umm, what? o is a local. This loop spins forever.
>> >>
>> >> --
>> >> Andrew Haley  (he/him)
>> >> Java Platform Lead Engineer
>> >> Red Hat UK Ltd. <https://www.redhat.com>
>> >> https://keybase.io/andrewhaley
>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>> >>
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/2a6a9bf9/attachment.html>

From viktor.klang at gmail.com  Fri Nov 15 05:24:06 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 15 Nov 2019 12:24:06 +0200
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
Message-ID: <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>

It would be interesting to have an onSpinWait(long nanos) version ehich can
be intrinsified if need be to provide the most accurate delay based on the
underlying system.

Talking about time being meaningless in a non-RT OS is rather meaningless
in itself—we’re relying on getting CPU timeslices before the end of the
universe anyway ;)

On Fri, 15 Nov 2019 at 12:06, Roman Leventov via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> By "half-baked" I meant specifically that the example could be valid but
> only under specific conditions, such as core-pinned thread, or backoff
> timeout event, etc. However, the "mundane" class and method names which are
> chosen ("EventHandler") may mislead users into thinking that spin-loop is a
> good go-to strategy to waiting for some conditions/logic executed, instead
> of using a synchronization primitive or attaching a listener to a
> CompletableFuture/ListeanableFuture if one is involved.
>
> I like Francesco's example because it is self-contained and doesn't need
> any backoff, so the complicated discussion of the tradeoffs involved and
> conditions which should be accounted for (typical wait time, GC algorithm,
> busyness of the system, etc.) could be blissfully omitted.
>
> On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Hi Gil,
>>
>> It's one of the common use cases
>>
>> :) Although I can say the same I'm not quite sure that is that common and
>> your example re LMAX makes it even more clear (not that mine on JCTools is
>> better eh!)
>> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so I
>> take all your points re the existing doc.
>>
>> Would a more detailed/complicated/opinionated example of a specific
>>> backoff flavor would help
>>> make the meaning and use of the method more clear, or help point out
>>> caveats or pitfalls better?
>>
>> My (personal) fear is that users will recognize the general busy spin
>> loop pattern, thinking that given that the JVM "is able to optmize it"
>> (thanks to help of unicorns and rainbows too) and
>> making it a much more attractive pairs of scissors to play with then
>> before :)
>>
>>
>> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
>> scritto:
>>
>>> I guess I'm missing something about the starting point in this thread.
>>> What do you find "half baked"
>>> about the actual example in the Javadoc? It's one of the common use
>>> cases (with no time-based
>>> backoffs) in various applications (ones that e.g. dedicate a spinning
>>> thread on a dedicated core).
>>>
>>> E.g.
>>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>>
>>> There are obviously additional common variants, some of which include
>>> backoff mechanisms
>>> (time based, count based, phase of moon based, etc.), but IMO there is
>>> no "right way" to do this,
>>> and a no-backoff use case is just as valid (and maybe even common) as
>>> one that includes a
>>> backoff. The code carefully avoids spelling out how
>>> "eventNotificationNotReceived" is determined.
>>> Hey, the event may even be a backoff timeout...
>>>
>>> Would a more detailed/complicated/opinionated example of a specific
>>> backoff flavor would help
>>> make the meaning and use of the method more clear, or help point out
>>> caveats or pitfalls better?
>>>
>>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>> >
>>> > Gil Tene* Android typo error
>>> >
>>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>>> scritto:
>>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he
>>> was the one (or one of many?) that has proposed it to be included in
>>> http://openjdk.java.net/jeps/285
>>> >
>>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>>> scritto:
>>> > Beside being more complex?
>>> > Not much I admit :)
>>> > But IMO awaiting with no algorithmical indication of the duration of
>>> the wait (like in the javadoc) and awaiting for a finite amount of "time" a
>>> condition that will be true at some point, is a better example where to
>>> apply onSpinWait, although is not technically incorrect to use it for
>>> "blind" spin loop as well.
>>> > Maybe is just a subtle difference, but I won't encourage users to
>>> blindly spin loop on conditions and just use onSpinWait to save the day..
>>> probably I'm worried too much for something very simple and unavoidable; as
>>> @roman has suggested, probably no example is better then one that is a
>>> superclass of all the possible best cases.
>>> >
>>> >
>>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
>>> scritto:
>>> > What's the difference between this example and what's in javadocs?
>>> >
>>> > Alex
>>> >
>>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>> > Totally right, sorry again (writing by phone is a terrible idea :( ):
>>> > yes , poll should  use  "o = this.obj".
>>> >
>>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>> then having the done flag does not seem to help anything.
>>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>> > that's why it contains some unnecessary bits as you've rightly pointed
>>> out.
>>> > Code that is spin awaiting on a condition, sure that it will happen at
>>> some point in the future, is something that could help to understand the
>>> rare cases
>>> > where using onSpinWait could be beneficial IMO.
>>> >
>>> >
>>> >
>>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>> nathanila at gmail.com> ha scritto:
>>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>> change, it seems poll() could spin forever.
>>> >
>>> > Should "poll" be renamed to "take" since the method could block until
>>> a value is available?
>>> >
>>> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>> having the done flag does not seem to help anything.
>>> >
>>> > Is the compiler and execution engine in my head misinterpreting and
>>> mis-executing the code?
>>> >
>>> > Here is the code with my suggested changes.
>>> >
>>> >    volatile E obj = null;
>>> >
>>> >    public void offerOnce(E o) {
>>> >       Objects.checkNonNull(o);
>>> >       this.obj = o;
>>> >    }
>>> >
>>> >   public boolean isDone() {
>>> >        return obj != null;
>>> >   }
>>> >
>>> >    public E take() {
>>> >       E o;
>>> >
>>> >       while (true) {
>>> >          o = obj;
>>> >
>>> >          if (o != null)
>>> >             return o;
>>> >
>>> >          java.lang.Thread.onSpinWait();
>>> >       }
>>> >    }
>>> > -Nathan
>>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>> >> Sorry I've written on the email text, I forgot an important part, let
>>> me write it properly:
>>> >>
>>> >>    volatile E obj = null;
>>> >>    volatile boolean done = false;
>>> >>
>>> >>    public void offerOnce(E o) {
>>> >>       Objects.checkNonNull(o);
>>> >>       this.done = true;
>>> >>       this.obj = o;
>>> >>    }
>>> >>
>>> >>   public boolean isDone() {
>>> >>        return done;
>>> >>   }
>>> >>
>>> >>    public E poll() {
>>> >>       E o = this.obj;
>>> >>       if (o == null && !this.done) {
>>> >>          return null;
>>> >>       }
>>> >>       //o will be !null at some point
>>> >>       do {
>>> >>          if (o != null)
>>> >>             return o;
>>> >>          java.lang.Thread.onSpinWait();
>>> >>          this.obj = o;
>>> >>       } while(true);
>>> >>    }
>>> >>
>>> >> Similarly to the queue API: poll should return null iff !done, but
>>> offer update first done and then this.obj:
>>> >> poll need to read obj, but has to stay consistent to the ordering, so
>>> at some point, obj will be visible if done == true.
>>> >> On JCtools we have some queues with a similar behaviour (producer
>>> sequence is advanced before writing the actual element in the queue)
>>> >> and we need to spin wait the element apprearence to stay consistent
>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>> works :P).
>>> >>
>>> >>
>>> >>
>>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>> ha scritto:
>>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>> >> >     E o = this.obj;
>>> >> >     if (o == null && !done) {
>>> >> >         return null;
>>> >> >      }
>>> >> >      //o will be !null at some point
>>> >> >      do {
>>> >> >          if (o != null)
>>> >> >             return o;
>>> >> >          java.lang.Thread.onSpinWait();
>>> >> >      } while(true);
>>> >> > }
>>> >> >
>>> >> > In case like this is more appropriate, maybe, but much less
>>> intuitive
>>> >> > probably.
>>> >>
>>> >> Umm, what? o is a local. This loop spins forever.
>>> >>
>>> >> --
>>> >> Andrew Haley  (he/him)
>>> >> Java Platform Lead Engineer
>>> >> Red Hat UK Ltd. <https://www.redhat.com>
>>> >> https://keybase.io/andrewhaley
>>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>> >>
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/529dc6ba/attachment-0001.html>

From leventov.ru at gmail.com  Fri Nov 15 05:35:26 2019
From: leventov.ru at gmail.com (Roman Leventov)
Date: Fri, 15 Nov 2019 13:35:26 +0300
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
Message-ID: <CAAMLo=aVGfmwPAZPGMh8T2BaaQ0TF==R66sEvgR-8MYf4UqELg@mail.gmail.com>

I also think that providing an example of a SpinLock, as per David's
suggestion, would be better than the current example because it would
implicitly communicate (explicit communication could be added as well) that
onSpinWait() is a low-level tool mostly for implementors of concurrency
utilities rather than typical concurrent code. While the discussion for
when it would be appropriate to use the resulting SpinLock class could be
omitted. Or implied that it's a simplified version of ReentrantLock, not
intended for actual use (similarly to Mutex example in the documentation
for AbstractQueuedSynchronizer).

On Fri, 15 Nov 2019 at 13:04, Roman Leventov <leventov.ru at gmail.com> wrote:

> By "half-baked" I meant specifically that the example could be valid but
> only under specific conditions, such as core-pinned thread, or backoff
> timeout event, etc. However, the "mundane" class and method names which are
> chosen ("EventHandler") may mislead users into thinking that spin-loop is a
> good go-to strategy to waiting for some conditions/logic executed, instead
> of using a synchronization primitive or attaching a listener to a
> CompletableFuture/ListeanableFuture if one is involved.
>
> I like Francesco's example because it is self-contained and doesn't need
> any backoff, so the complicated discussion of the tradeoffs involved and
> conditions which should be accounted for (typical wait time, GC algorithm,
> busyness of the system, etc.) could be blissfully omitted.
>
> On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Hi Gil,
>>
>> It's one of the common use cases
>>
>> :) Although I can say the same I'm not quite sure that is that common and
>> your example re LMAX makes it even more clear (not that mine on JCTools is
>> better eh!)
>> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so I
>> take all your points re the existing doc.
>>
>> Would a more detailed/complicated/opinionated example of a specific
>>> backoff flavor would help
>>> make the meaning and use of the method more clear, or help point out
>>> caveats or pitfalls better?
>>
>> My (personal) fear is that users will recognize the general busy spin
>> loop pattern, thinking that given that the JVM "is able to optmize it"
>> (thanks to help of unicorns and rainbows too) and
>> making it a much more attractive pairs of scissors to play with then
>> before :)
>>
>>
>> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
>> scritto:
>>
>>> I guess I'm missing something about the starting point in this thread.
>>> What do you find "half baked"
>>> about the actual example in the Javadoc? It's one of the common use
>>> cases (with no time-based
>>> backoffs) in various applications (ones that e.g. dedicate a spinning
>>> thread on a dedicated core).
>>>
>>> E.g.
>>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>>
>>> There are obviously additional common variants, some of which include
>>> backoff mechanisms
>>> (time based, count based, phase of moon based, etc.), but IMO there is
>>> no "right way" to do this,
>>> and a no-backoff use case is just as valid (and maybe even common) as
>>> one that includes a
>>> backoff. The code carefully avoids spelling out how
>>> "eventNotificationNotReceived" is determined.
>>> Hey, the event may even be a backoff timeout...
>>>
>>> Would a more detailed/complicated/opinionated example of a specific
>>> backoff flavor would help
>>> make the meaning and use of the method more clear, or help point out
>>> caveats or pitfalls better?
>>>
>>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>> >
>>> > Gil Tene* Android typo error
>>> >
>>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>>> scritto:
>>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he
>>> was the one (or one of many?) that has proposed it to be included in
>>> http://openjdk.java.net/jeps/285
>>> >
>>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>>> scritto:
>>> > Beside being more complex?
>>> > Not much I admit :)
>>> > But IMO awaiting with no algorithmical indication of the duration of
>>> the wait (like in the javadoc) and awaiting for a finite amount of "time" a
>>> condition that will be true at some point, is a better example where to
>>> apply onSpinWait, although is not technically incorrect to use it for
>>> "blind" spin loop as well.
>>> > Maybe is just a subtle difference, but I won't encourage users to
>>> blindly spin loop on conditions and just use onSpinWait to save the day..
>>> probably I'm worried too much for something very simple and unavoidable; as
>>> @roman has suggested, probably no example is better then one that is a
>>> superclass of all the possible best cases.
>>> >
>>> >
>>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com> ha
>>> scritto:
>>> > What's the difference between this example and what's in javadocs?
>>> >
>>> > Alex
>>> >
>>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>> > Totally right, sorry again (writing by phone is a terrible idea :( ):
>>> > yes , poll should  use  "o = this.obj".
>>> >
>>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>> then having the done flag does not seem to help anything.
>>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due to
>>> the hurry, sorry for that) version of what we do on many queues in JCtools,
>>> > that's why it contains some unnecessary bits as you've rightly pointed
>>> out.
>>> > Code that is spin awaiting on a condition, sure that it will happen at
>>> some point in the future, is something that could help to understand the
>>> rare cases
>>> > where using onSpinWait could be beneficial IMO.
>>> >
>>> >
>>> >
>>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>> nathanila at gmail.com> ha scritto:
>>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>> change, it seems poll() could spin forever.
>>> >
>>> > Should "poll" be renamed to "take" since the method could block until
>>> a value is available?
>>> >
>>> > Can we get rid of "done"?  Since offerOnce() does not allow null, then
>>> having the done flag does not seem to help anything.
>>> >
>>> > Is the compiler and execution engine in my head misinterpreting and
>>> mis-executing the code?
>>> >
>>> > Here is the code with my suggested changes.
>>> >
>>> >    volatile E obj = null;
>>> >
>>> >    public void offerOnce(E o) {
>>> >       Objects.checkNonNull(o);
>>> >       this.obj = o;
>>> >    }
>>> >
>>> >   public boolean isDone() {
>>> >        return obj != null;
>>> >   }
>>> >
>>> >    public E take() {
>>> >       E o;
>>> >
>>> >       while (true) {
>>> >          o = obj;
>>> >
>>> >          if (o != null)
>>> >             return o;
>>> >
>>> >          java.lang.Thread.onSpinWait();
>>> >       }
>>> >    }
>>> > -Nathan
>>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>> >> Sorry I've written on the email text, I forgot an important part, let
>>> me write it properly:
>>> >>
>>> >>    volatile E obj = null;
>>> >>    volatile boolean done = false;
>>> >>
>>> >>    public void offerOnce(E o) {
>>> >>       Objects.checkNonNull(o);
>>> >>       this.done = true;
>>> >>       this.obj = o;
>>> >>    }
>>> >>
>>> >>   public boolean isDone() {
>>> >>        return done;
>>> >>   }
>>> >>
>>> >>    public E poll() {
>>> >>       E o = this.obj;
>>> >>       if (o == null && !this.done) {
>>> >>          return null;
>>> >>       }
>>> >>       //o will be !null at some point
>>> >>       do {
>>> >>          if (o != null)
>>> >>             return o;
>>> >>          java.lang.Thread.onSpinWait();
>>> >>          this.obj = o;
>>> >>       } while(true);
>>> >>    }
>>> >>
>>> >> Similarly to the queue API: poll should return null iff !done, but
>>> offer update first done and then this.obj:
>>> >> poll need to read obj, but has to stay consistent to the ordering, so
>>> at some point, obj will be visible if done == true.
>>> >> On JCtools we have some queues with a similar behaviour (producer
>>> sequence is advanced before writing the actual element in the queue)
>>> >> and we need to spin wait the element apprearence to stay consistent
>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>> works :P).
>>> >>
>>> >>
>>> >>
>>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <aph at redhat.com>
>>> ha scritto:
>>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>> >> >     E o = this.obj;
>>> >> >     if (o == null && !done) {
>>> >> >         return null;
>>> >> >      }
>>> >> >      //o will be !null at some point
>>> >> >      do {
>>> >> >          if (o != null)
>>> >> >             return o;
>>> >> >          java.lang.Thread.onSpinWait();
>>> >> >      } while(true);
>>> >> > }
>>> >> >
>>> >> > In case like this is more appropriate, maybe, but much less
>>> intuitive
>>> >> > probably.
>>> >>
>>> >> Umm, what? o is a local. This loop spins forever.
>>> >>
>>> >> --
>>> >> Andrew Haley  (he/him)
>>> >> Java Platform Lead Engineer
>>> >> Red Hat UK Ltd. <https://www.redhat.com>
>>> >> https://keybase.io/andrewhaley
>>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>> >>
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/f318df46/attachment.html>

From oleksandr.otenko at gmail.com  Fri Nov 15 05:38:45 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 15 Nov 2019 10:38:45 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
Message-ID: <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>

Let's start with why you wouldn't just park nanos. Because you want the CPU
to do something useful instead of idling.

For a time limit to be implementable for arbitrary useful things, the
computation done by onSpinWait must know how much time that computation
will take - maybe to choose the computation of the right size. Gödel says
hello.

Or you should be able to suspend that computation at arbitrary points.
Well, not in Java.

Alex

On Fri, 15 Nov 2019, 10:25 Viktor Klang via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

> It would be interesting to have an onSpinWait(long nanos) version ehich
> can be intrinsified if need be to provide the most accurate delay based on
> the underlying system.
>
> Talking about time being meaningless in a non-RT OS is rather meaningless
> in itself—we’re relying on getting CPU timeslices before the end of the
> universe anyway ;)
>
> On Fri, 15 Nov 2019 at 12:06, Roman Leventov via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> By "half-baked" I meant specifically that the example could be valid but
>> only under specific conditions, such as core-pinned thread, or backoff
>> timeout event, etc. However, the "mundane" class and method names which are
>> chosen ("EventHandler") may mislead users into thinking that spin-loop is a
>> good go-to strategy to waiting for some conditions/logic executed, instead
>> of using a synchronization primitive or attaching a listener to a
>> CompletableFuture/ListeanableFuture if one is involved.
>>
>> I like Francesco's example because it is self-contained and doesn't need
>> any backoff, so the complicated discussion of the tradeoffs involved and
>> conditions which should be accounted for (typical wait time, GC algorithm,
>> busyness of the system, etc.) could be blissfully omitted.
>>
>> On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>>> Hi Gil,
>>>
>>> It's one of the common use cases
>>>
>>> :) Although I can say the same I'm not quite sure that is that common
>>> and your example re LMAX makes it even more clear (not that mine on JCTools
>>> is better eh!)
>>> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so I
>>> take all your points re the existing doc.
>>>
>>> Would a more detailed/complicated/opinionated example of a specific
>>>> backoff flavor would help
>>>> make the meaning and use of the method more clear, or help point out
>>>> caveats or pitfalls better?
>>>
>>> My (personal) fear is that users will recognize the general busy spin
>>> loop pattern, thinking that given that the JVM "is able to optmize it"
>>> (thanks to help of unicorns and rainbows too) and
>>> making it a much more attractive pairs of scissors to play with then
>>> before :)
>>>
>>>
>>> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
>>> scritto:
>>>
>>>> I guess I'm missing something about the starting point in this thread.
>>>> What do you find "half baked"
>>>> about the actual example in the Javadoc? It's one of the common use
>>>> cases (with no time-based
>>>> backoffs) in various applications (ones that e.g. dedicate a spinning
>>>> thread on a dedicated core).
>>>>
>>>> E.g.
>>>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>>>
>>>> There are obviously additional common variants, some of which include
>>>> backoff mechanisms
>>>> (time based, count based, phase of moon based, etc.), but IMO there is
>>>> no "right way" to do this,
>>>> and a no-backoff use case is just as valid (and maybe even common) as
>>>> one that includes a
>>>> backoff. The code carefully avoids spelling out how
>>>> "eventNotificationNotReceived" is determined.
>>>> Hey, the event may even be a backoff timeout...
>>>>
>>>> Would a more detailed/complicated/opinionated example of a specific
>>>> backoff flavor would help
>>>> make the meaning and use of the method more clear, or help point out
>>>> caveats or pitfalls better?
>>>>
>>>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via Concurrency-interest
>>>> <concurrency-interest at cs.oswego.edu> wrote:
>>>> >
>>>> > Gil Tene* Android typo error
>>>> >
>>>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>>>> scritto:
>>>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he
>>>> was the one (or one of many?) that has proposed it to be included in
>>>> http://openjdk.java.net/jeps/285
>>>> >
>>>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>>>> scritto:
>>>> > Beside being more complex?
>>>> > Not much I admit :)
>>>> > But IMO awaiting with no algorithmical indication of the duration of
>>>> the wait (like in the javadoc) and awaiting for a finite amount of "time" a
>>>> condition that will be true at some point, is a better example where to
>>>> apply onSpinWait, although is not technically incorrect to use it for
>>>> "blind" spin loop as well.
>>>> > Maybe is just a subtle difference, but I won't encourage users to
>>>> blindly spin loop on conditions and just use onSpinWait to save the day..
>>>> probably I'm worried too much for something very simple and unavoidable; as
>>>> @roman has suggested, probably no example is better then one that is a
>>>> superclass of all the possible best cases.
>>>> >
>>>> >
>>>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com>
>>>> ha scritto:
>>>> > What's the difference between this example and what's in javadocs?
>>>> >
>>>> > Alex
>>>> >
>>>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest, <
>>>> concurrency-interest at cs.oswego.edu> wrote:
>>>> > Totally right, sorry again (writing by phone is a terrible idea :( ):
>>>> > yes , poll should  use  "o = this.obj".
>>>> >
>>>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>> then having the done flag does not seem to help anything.
>>>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due
>>>> to the hurry, sorry for that) version of what we do on many queues in
>>>> JCtools,
>>>> > that's why it contains some unnecessary bits as you've rightly
>>>> pointed out.
>>>> > Code that is spin awaiting on a condition, sure that it will happen
>>>> at some point in the future, is something that could help to understand the
>>>> rare cases
>>>> > where using onSpinWait could be beneficial IMO.
>>>> >
>>>> >
>>>> >
>>>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>>> nathanila at gmail.com> ha scritto:
>>>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>> change, it seems poll() could spin forever.
>>>> >
>>>> > Should "poll" be renamed to "take" since the method could block until
>>>> a value is available?
>>>> >
>>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>> then having the done flag does not seem to help anything.
>>>> >
>>>> > Is the compiler and execution engine in my head misinterpreting and
>>>> mis-executing the code?
>>>> >
>>>> > Here is the code with my suggested changes.
>>>> >
>>>> >    volatile E obj = null;
>>>> >
>>>> >    public void offerOnce(E o) {
>>>> >       Objects.checkNonNull(o);
>>>> >       this.obj = o;
>>>> >    }
>>>> >
>>>> >   public boolean isDone() {
>>>> >        return obj != null;
>>>> >   }
>>>> >
>>>> >    public E take() {
>>>> >       E o;
>>>> >
>>>> >       while (true) {
>>>> >          o = obj;
>>>> >
>>>> >          if (o != null)
>>>> >             return o;
>>>> >
>>>> >          java.lang.Thread.onSpinWait();
>>>> >       }
>>>> >    }
>>>> > -Nathan
>>>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>> >> Sorry I've written on the email text, I forgot an important part,
>>>> let me write it properly:
>>>> >>
>>>> >>    volatile E obj = null;
>>>> >>    volatile boolean done = false;
>>>> >>
>>>> >>    public void offerOnce(E o) {
>>>> >>       Objects.checkNonNull(o);
>>>> >>       this.done = true;
>>>> >>       this.obj = o;
>>>> >>    }
>>>> >>
>>>> >>   public boolean isDone() {
>>>> >>        return done;
>>>> >>   }
>>>> >>
>>>> >>    public E poll() {
>>>> >>       E o = this.obj;
>>>> >>       if (o == null && !this.done) {
>>>> >>          return null;
>>>> >>       }
>>>> >>       //o will be !null at some point
>>>> >>       do {
>>>> >>          if (o != null)
>>>> >>             return o;
>>>> >>          java.lang.Thread.onSpinWait();
>>>> >>          this.obj = o;
>>>> >>       } while(true);
>>>> >>    }
>>>> >>
>>>> >> Similarly to the queue API: poll should return null iff !done, but
>>>> offer update first done and then this.obj:
>>>> >> poll need to read obj, but has to stay consistent to the ordering,
>>>> so at some point, obj will be visible if done == true.
>>>> >> On JCtools we have some queues with a similar behaviour (producer
>>>> sequence is advanced before writing the actual element in the queue)
>>>> >> and we need to spin wait the element apprearence to stay consistent
>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>> works :P).
>>>> >>
>>>> >>
>>>> >>
>>>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <
>>>> aph at redhat.com> ha scritto:
>>>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>> >> >     E o = this.obj;
>>>> >> >     if (o == null && !done) {
>>>> >> >         return null;
>>>> >> >      }
>>>> >> >      //o will be !null at some point
>>>> >> >      do {
>>>> >> >          if (o != null)
>>>> >> >             return o;
>>>> >> >          java.lang.Thread.onSpinWait();
>>>> >> >      } while(true);
>>>> >> > }
>>>> >> >
>>>> >> > In case like this is more appropriate, maybe, but much less
>>>> intuitive
>>>> >> > probably.
>>>> >>
>>>> >> Umm, what? o is a local. This loop spins forever.
>>>> >>
>>>> >> --
>>>> >> Andrew Haley  (he/him)
>>>> >> Java Platform Lead Engineer
>>>> >> Red Hat UK Ltd. <https://www.redhat.com>
>>>> >> https://keybase.io/andrewhaley
>>>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>> >>
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> --
> Cheers,
> √
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/ac9f639a/attachment-0001.html>

From viktor.klang at gmail.com  Fri Nov 15 06:14:38 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 15 Nov 2019 13:14:38 +0200
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
Message-ID: <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>

On Fri, 15 Nov 2019 at 12:38, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> Let's start with why you wouldn't just park nanos. Because you want the
> CPU to do something useful instead of idling.
>

I hope you trust that I know this. :-)


> For a time limit to be implementable for arbitrary useful things, the
> computation done by onSpinWait must know how much time that computation
> will take - maybe to choose the computation of the right size. Gödel says
> hello
>

Are you arguing for the removal of all polling-style API:s in Java?

.
>
> Or you should be able to suspend that computation at arbitrary points.
> Well, not in Java.
>

That’d be nice, but yeah, not really until Fibers.
But something crucial to factor in is wakeup delay.


> Alex
>
> On Fri, 15 Nov 2019, 10:25 Viktor Klang via Concurrency-interest, <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> It would be interesting to have an onSpinWait(long nanos) version ehich
>> can be intrinsified if need be to provide the most accurate delay based on
>> the underlying system.
>>
>> Talking about time being meaningless in a non-RT OS is rather meaningless
>> in itself—we’re relying on getting CPU timeslices before the end of the
>> universe anyway ;)
>>
>> On Fri, 15 Nov 2019 at 12:06, Roman Leventov via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>>> By "half-baked" I meant specifically that the example could be valid but
>>> only under specific conditions, such as core-pinned thread, or backoff
>>> timeout event, etc. However, the "mundane" class and method names which are
>>> chosen ("EventHandler") may mislead users into thinking that spin-loop is a
>>> good go-to strategy to waiting for some conditions/logic executed, instead
>>> of using a synchronization primitive or attaching a listener to a
>>> CompletableFuture/ListeanableFuture if one is involved.
>>>
>>> I like Francesco's example because it is self-contained and doesn't need
>>> any backoff, so the complicated discussion of the tradeoffs involved and
>>> conditions which should be accounted for (typical wait time, GC algorithm,
>>> busyness of the system, etc.) could be blissfully omitted.
>>>
>>> On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>>
>>>> Hi Gil,
>>>>
>>>> It's one of the common use cases
>>>>
>>>> :) Although I can say the same I'm not quite sure that is that common
>>>> and your example re LMAX makes it even more clear (not that mine on JCTools
>>>> is better eh!)
>>>> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so
>>>> I take all your points re the existing doc.
>>>>
>>>> Would a more detailed/complicated/opinionated example of a specific
>>>>> backoff flavor would help
>>>>> make the meaning and use of the method more clear, or help point out
>>>>> caveats or pitfalls better?
>>>>
>>>> My (personal) fear is that users will recognize the general busy spin
>>>> loop pattern, thinking that given that the JVM "is able to optmize it"
>>>> (thanks to help of unicorns and rainbows too) and
>>>> making it a much more attractive pairs of scissors to play with then
>>>> before :)
>>>>
>>>>
>>>> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
>>>> scritto:
>>>>
>>>>> I guess I'm missing something about the starting point in this thread.
>>>>> What do you find "half baked"
>>>>> about the actual example in the Javadoc? It's one of the common use
>>>>> cases (with no time-based
>>>>> backoffs) in various applications (ones that e.g. dedicate a spinning
>>>>> thread on a dedicated core).
>>>>>
>>>>> E.g.
>>>>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>>>>
>>>>> There are obviously additional common variants, some of which include
>>>>> backoff mechanisms
>>>>> (time based, count based, phase of moon based, etc.), but IMO there is
>>>>> no "right way" to do this,
>>>>> and a no-backoff use case is just as valid (and maybe even common) as
>>>>> one that includes a
>>>>> backoff. The code carefully avoids spelling out how
>>>>> "eventNotificationNotReceived" is determined.
>>>>> Hey, the event may even be a backoff timeout...
>>>>>
>>>>> Would a more detailed/complicated/opinionated example of a specific
>>>>> backoff flavor would help
>>>>> make the meaning and use of the method more clear, or help point out
>>>>> caveats or pitfalls better?
>>>>>
>>>>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via
>>>>> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>>>> >
>>>>> > Gil Tene* Android typo error
>>>>> >
>>>>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>>>>> scritto:
>>>>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he
>>>>> was the one (or one of many?) that has proposed it to be included in
>>>>> http://openjdk.java.net/jeps/285
>>>>> >
>>>>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>>>>> scritto:
>>>>> > Beside being more complex?
>>>>> > Not much I admit :)
>>>>> > But IMO awaiting with no algorithmical indication of the duration of
>>>>> the wait (like in the javadoc) and awaiting for a finite amount of "time" a
>>>>> condition that will be true at some point, is a better example where to
>>>>> apply onSpinWait, although is not technically incorrect to use it for
>>>>> "blind" spin loop as well.
>>>>> > Maybe is just a subtle difference, but I won't encourage users to
>>>>> blindly spin loop on conditions and just use onSpinWait to save the day..
>>>>> probably I'm worried too much for something very simple and unavoidable; as
>>>>> @roman has suggested, probably no example is better then one that is a
>>>>> superclass of all the possible best cases.
>>>>> >
>>>>> >
>>>>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com>
>>>>> ha scritto:
>>>>> > What's the difference between this example and what's in javadocs?
>>>>> >
>>>>> > Alex
>>>>> >
>>>>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via Concurrency-interest,
>>>>> <concurrency-interest at cs.oswego.edu> wrote:
>>>>> > Totally right, sorry again (writing by phone is a terrible idea :( ):
>>>>> > yes , poll should  use  "o = this.obj".
>>>>> >
>>>>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>>> then having the done flag does not seem to help anything.
>>>>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due
>>>>> to the hurry, sorry for that) version of what we do on many queues in
>>>>> JCtools,
>>>>> > that's why it contains some unnecessary bits as you've rightly
>>>>> pointed out.
>>>>> > Code that is spin awaiting on a condition, sure that it will happen
>>>>> at some point in the future, is something that could help to understand the
>>>>> rare cases
>>>>> > where using onSpinWait could be beneficial IMO.
>>>>> >
>>>>> >
>>>>> >
>>>>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>>>> nathanila at gmail.com> ha scritto:
>>>>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>>> change, it seems poll() could spin forever.
>>>>> >
>>>>> > Should "poll" be renamed to "take" since the method could block
>>>>> until a value is available?
>>>>> >
>>>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>>> then having the done flag does not seem to help anything.
>>>>> >
>>>>> > Is the compiler and execution engine in my head misinterpreting and
>>>>> mis-executing the code?
>>>>> >
>>>>> > Here is the code with my suggested changes.
>>>>> >
>>>>> >    volatile E obj = null;
>>>>> >
>>>>> >    public void offerOnce(E o) {
>>>>> >       Objects.checkNonNull(o);
>>>>> >       this.obj = o;
>>>>> >    }
>>>>> >
>>>>> >   public boolean isDone() {
>>>>> >        return obj != null;
>>>>> >   }
>>>>> >
>>>>> >    public E take() {
>>>>> >       E o;
>>>>> >
>>>>> >       while (true) {
>>>>> >          o = obj;
>>>>> >
>>>>> >          if (o != null)
>>>>> >             return o;
>>>>> >
>>>>> >          java.lang.Thread.onSpinWait();
>>>>> >       }
>>>>> >    }
>>>>> > -Nathan
>>>>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>> >> Sorry I've written on the email text, I forgot an important part,
>>>>> let me write it properly:
>>>>> >>
>>>>> >>    volatile E obj = null;
>>>>> >>    volatile boolean done = false;
>>>>> >>
>>>>> >>    public void offerOnce(E o) {
>>>>> >>       Objects.checkNonNull(o);
>>>>> >>       this.done = true;
>>>>> >>       this.obj = o;
>>>>> >>    }
>>>>> >>
>>>>> >>   public boolean isDone() {
>>>>> >>        return done;
>>>>> >>   }
>>>>> >>
>>>>> >>    public E poll() {
>>>>> >>       E o = this.obj;
>>>>> >>       if (o == null && !this.done) {
>>>>> >>          return null;
>>>>> >>       }
>>>>> >>       //o will be !null at some point
>>>>> >>       do {
>>>>> >>          if (o != null)
>>>>> >>             return o;
>>>>> >>          java.lang.Thread.onSpinWait();
>>>>> >>          this.obj = o;
>>>>> >>       } while(true);
>>>>> >>    }
>>>>> >>
>>>>> >> Similarly to the queue API: poll should return null iff !done, but
>>>>> offer update first done and then this.obj:
>>>>> >> poll need to read obj, but has to stay consistent to the ordering,
>>>>> so at some point, obj will be visible if done == true.
>>>>> >> On JCtools we have some queues with a similar behaviour (producer
>>>>> sequence is advanced before writing the actual element in the queue)
>>>>> >> and we need to spin wait the element apprearence to stay consistent
>>>>> with the isEmpty behaviour: that's a good use case for onSpinWait (when it
>>>>> works :P).
>>>>> >>
>>>>> >>
>>>>> >>
>>>>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <
>>>>> aph at redhat.com> ha scritto:
>>>>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest wrote:
>>>>> >> >     E o = this.obj;
>>>>> >> >     if (o == null && !done) {
>>>>> >> >         return null;
>>>>> >> >      }
>>>>> >> >      //o will be !null at some point
>>>>> >> >      do {
>>>>> >> >          if (o != null)
>>>>> >> >             return o;
>>>>> >> >          java.lang.Thread.onSpinWait();
>>>>> >> >      } while(true);
>>>>> >> > }
>>>>> >> >
>>>>> >> > In case like this is more appropriate, maybe, but much less
>>>>> intuitive
>>>>> >> > probably.
>>>>> >>
>>>>> >> Umm, what? o is a local. This loop spins forever.
>>>>> >>
>>>>> >> --
>>>>> >> Andrew Haley  (he/him)
>>>>> >> Java Platform Lead Engineer
>>>>> >> Red Hat UK Ltd. <https://www.redhat.com>
>>>>> >> https://keybase.io/andrewhaley
>>>>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>> >>
>>>>> > _______________________________________________
>>>>> > Concurrency-interest mailing list
>>>>> > Concurrency-interest at cs.oswego.edu
>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> > _______________________________________________
>>>>> > Concurrency-interest mailing list
>>>>> > Concurrency-interest at cs.oswego.edu
>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> --
>> Cheers,
>> √
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> --
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/5dc75007/attachment-0001.html>

From oleksandr.otenko at gmail.com  Fri Nov 15 08:31:12 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 15 Nov 2019 13:31:12 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAG7qthB09ZN8Mnhz-sS2ECsX149VY5Tm7mVHnS98Z1v3--_bYA@mail.gmail.com>
 <CAKxGtTXkFfck1K=o3-x2e4KNL0tG0-_RUrzVRnP1afc2z=OTcg@mail.gmail.com>
 <74f72b37-b3e9-19d2-a3b9-77840fa0eb4e@redhat.com>
 <CAKxGtTVGKvQd3KT3f8ROuzZpNKNS4XEeKZeRfAppwYFATZKPfQ@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
Message-ID: <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>

I am not arguing. I want to see justification for wanting something that
looks like a solution to an intractable problem.

I see onSpinWait as an indicator to the JVM that it can do something
useful, like possibly help FJP make some progress. I can't see how a time
bound can be enforced there.

Now, if you want a better timed wait, use park nanos. If you don't want to
do that, how is onSpinWait meant to work? With a constraint that it isn't
the same as would be suitable for a timed parking?

Alex

On Fri, 15 Nov 2019, 11:14 Viktor Klang, <viktor.klang at gmail.com> wrote:

>
>
> On Fri, 15 Nov 2019 at 12:38, Alex Otenko <oleksandr.otenko at gmail.com>
> wrote:
>
>> Let's start with why you wouldn't just park nanos. Because you want the
>> CPU to do something useful instead of idling.
>>
>
> I hope you trust that I know this. :-)
>
>
>> For a time limit to be implementable for arbitrary useful things, the
>> computation done by onSpinWait must know how much time that computation
>> will take - maybe to choose the computation of the right size. Gödel says
>> hello
>>
>
> Are you arguing for the removal of all polling-style API:s in Java?
>
> .
>>
>> Or you should be able to suspend that computation at arbitrary points.
>> Well, not in Java.
>>
>
> That’d be nice, but yeah, not really until Fibers.
> But something crucial to factor in is wakeup delay.
>
>
>> Alex
>>
>> On Fri, 15 Nov 2019, 10:25 Viktor Klang via Concurrency-interest, <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>>> It would be interesting to have an onSpinWait(long nanos) version ehich
>>> can be intrinsified if need be to provide the most accurate delay based on
>>> the underlying system.
>>>
>>> Talking about time being meaningless in a non-RT OS is rather
>>> meaningless in itself—we’re relying on getting CPU timeslices before the
>>> end of the universe anyway ;)
>>>
>>> On Fri, 15 Nov 2019 at 12:06, Roman Leventov via Concurrency-interest <
>>> concurrency-interest at cs.oswego.edu> wrote:
>>>
>>>> By "half-baked" I meant specifically that the example could be valid
>>>> but only under specific conditions, such as core-pinned thread, or backoff
>>>> timeout event, etc. However, the "mundane" class and method names which are
>>>> chosen ("EventHandler") may mislead users into thinking that spin-loop is a
>>>> good go-to strategy to waiting for some conditions/logic executed, instead
>>>> of using a synchronization primitive or attaching a listener to a
>>>> CompletableFuture/ListeanableFuture if one is involved.
>>>>
>>>> I like Francesco's example because it is self-contained and doesn't
>>>> need any backoff, so the complicated discussion of the tradeoffs involved
>>>> and conditions which should be accounted for (typical wait time, GC
>>>> algorithm, busyness of the system, etc.) could be blissfully omitted.
>>>>
>>>> On Fri, 15 Nov 2019 at 11:05, Francesco Nigro via Concurrency-interest <
>>>> concurrency-interest at cs.oswego.edu> wrote:
>>>>
>>>>> Hi Gil,
>>>>>
>>>>> It's one of the common use cases
>>>>>
>>>>> :) Although I can say the same I'm not quite sure that is that common
>>>>> and your example re LMAX makes it even more clear (not that mine on JCTools
>>>>> is better eh!)
>>>>> On the other hand, onSpinWait itself is equally uncommon on j.u.c., so
>>>>> I take all your points re the existing doc.
>>>>>
>>>>> Would a more detailed/complicated/opinionated example of a specific
>>>>>> backoff flavor would help
>>>>>> make the meaning and use of the method more clear, or help point out
>>>>>> caveats or pitfalls better?
>>>>>
>>>>> My (personal) fear is that users will recognize the general busy spin
>>>>> loop pattern, thinking that given that the JVM "is able to optmize it"
>>>>> (thanks to help of unicorns and rainbows too) and
>>>>> making it a much more attractive pairs of scissors to play with then
>>>>> before :)
>>>>>
>>>>>
>>>>> Il giorno ven 15 nov 2019 alle ore 06:38 Gil Tene <gil at azul.com> ha
>>>>> scritto:
>>>>>
>>>>>> I guess I'm missing something about the starting point in this
>>>>>> thread. What do you find "half baked"
>>>>>> about the actual example in the Javadoc? It's one of the common use
>>>>>> cases (with no time-based
>>>>>> backoffs) in various applications (ones that e.g. dedicate a spinning
>>>>>> thread on a dedicated core).
>>>>>>
>>>>>> E.g.
>>>>>> https://github.com/LMAX-Exchange/disruptor/blob/5764f3b01faab603322c61cede957b7e79f58c8b/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java
>>>>>>
>>>>>> There are obviously additional common variants, some of which include
>>>>>> backoff mechanisms
>>>>>> (time based, count based, phase of moon based, etc.), but IMO there
>>>>>> is no "right way" to do this,
>>>>>> and a no-backoff use case is just as valid (and maybe even common) as
>>>>>> one that includes a
>>>>>> backoff. The code carefully avoids spelling out how
>>>>>> "eventNotificationNotReceived" is determined.
>>>>>> Hey, the event may even be a backoff timeout...
>>>>>>
>>>>>> Would a more detailed/complicated/opinionated example of a specific
>>>>>> backoff flavor would help
>>>>>> make the meaning and use of the method more clear, or help point out
>>>>>> caveats or pitfalls better?
>>>>>>
>>>>>> > On Nov 14, 2019, at 2:28 PM, Francesco Nigro via
>>>>>> Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>>>>> >
>>>>>> > Gil Tene* Android typo error
>>>>>> >
>>>>>> > Il gio 14 nov 2019, 23:28 Francesco Nigro <nigro.fra at gmail.com> ha
>>>>>> scritto:
>>>>>> > I would like to hear the opinion of Gil Gene about it too: AFAIK he
>>>>>> was the one (or one of many?) that has proposed it to be included in
>>>>>> http://openjdk.java.net/jeps/285
>>>>>> >
>>>>>> > Il gio 14 nov 2019, 23:22 Francesco Nigro <nigro.fra at gmail.com> ha
>>>>>> scritto:
>>>>>> > Beside being more complex?
>>>>>> > Not much I admit :)
>>>>>> > But IMO awaiting with no algorithmical indication of the duration
>>>>>> of the wait (like in the javadoc) and awaiting for a finite amount of
>>>>>> "time" a condition that will be true at some point, is a better example
>>>>>> where to apply onSpinWait, although is not technically incorrect to use it
>>>>>> for "blind" spin loop as well.
>>>>>> > Maybe is just a subtle difference, but I won't encourage users to
>>>>>> blindly spin loop on conditions and just use onSpinWait to save the day..
>>>>>> probably I'm worried too much for something very simple and unavoidable; as
>>>>>> @roman has suggested, probably no example is better then one that is a
>>>>>> superclass of all the possible best cases.
>>>>>> >
>>>>>> >
>>>>>> > Il gio 14 nov 2019, 22:51 Alex Otenko <oleksandr.otenko at gmail.com>
>>>>>> ha scritto:
>>>>>> > What's the difference between this example and what's in javadocs?
>>>>>> >
>>>>>> > Alex
>>>>>> >
>>>>>> > On Thu, 14 Nov 2019, 16:29 Francesco Nigro via
>>>>>> Concurrency-interest, <concurrency-interest at cs.oswego.edu> wrote:
>>>>>> > Totally right, sorry again (writing by phone is a terrible idea :(
>>>>>> ):
>>>>>> > yes , poll should  use  "o = this.obj".
>>>>>> >
>>>>>> > > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>>>> then having the done flag does not seem to help anything.
>>>>>> > Absolutely yes: I've prepared this as a "simplified" (and wrong due
>>>>>> to the hurry, sorry for that) version of what we do on many queues in
>>>>>> JCtools,
>>>>>> > that's why it contains some unnecessary bits as you've rightly
>>>>>> pointed out.
>>>>>> > Code that is spin awaiting on a condition, sure that it will happen
>>>>>> at some point in the future, is something that could help to understand the
>>>>>> rare cases
>>>>>> > where using onSpinWait could be beneficial IMO.
>>>>>> >
>>>>>> >
>>>>>> >
>>>>>> > Il giorno gio 14 nov 2019 alle ore 17:18 Nathan and Ila Reynolds <
>>>>>> nathanila at gmail.com> ha scritto:
>>>>>> > In poll(), should "this.obj = o" be "o = this.obj"?  Without this
>>>>>> change, it seems poll() could spin forever.
>>>>>> >
>>>>>> > Should "poll" be renamed to "take" since the method could block
>>>>>> until a value is available?
>>>>>> >
>>>>>> > Can we get rid of "done"?  Since offerOnce() does not allow null,
>>>>>> then having the done flag does not seem to help anything.
>>>>>> >
>>>>>> > Is the compiler and execution engine in my head misinterpreting and
>>>>>> mis-executing the code?
>>>>>> >
>>>>>> > Here is the code with my suggested changes.
>>>>>> >
>>>>>> >    volatile E obj = null;
>>>>>> >
>>>>>> >    public void offerOnce(E o) {
>>>>>> >       Objects.checkNonNull(o);
>>>>>> >       this.obj = o;
>>>>>> >    }
>>>>>> >
>>>>>> >   public boolean isDone() {
>>>>>> >        return obj != null;
>>>>>> >   }
>>>>>> >
>>>>>> >    public E take() {
>>>>>> >       E o;
>>>>>> >
>>>>>> >       while (true) {
>>>>>> >          o = obj;
>>>>>> >
>>>>>> >          if (o != null)
>>>>>> >             return o;
>>>>>> >
>>>>>> >          java.lang.Thread.onSpinWait();
>>>>>> >       }
>>>>>> >    }
>>>>>> > -Nathan
>>>>>> > On 11/14/2019 8:54 AM, Francesco Nigro wrote:
>>>>>> >> Sorry I've written on the email text, I forgot an important part,
>>>>>> let me write it properly:
>>>>>> >>
>>>>>> >>    volatile E obj = null;
>>>>>> >>    volatile boolean done = false;
>>>>>> >>
>>>>>> >>    public void offerOnce(E o) {
>>>>>> >>       Objects.checkNonNull(o);
>>>>>> >>       this.done = true;
>>>>>> >>       this.obj = o;
>>>>>> >>    }
>>>>>> >>
>>>>>> >>   public boolean isDone() {
>>>>>> >>        return done;
>>>>>> >>   }
>>>>>> >>
>>>>>> >>    public E poll() {
>>>>>> >>       E o = this.obj;
>>>>>> >>       if (o == null && !this.done) {
>>>>>> >>          return null;
>>>>>> >>       }
>>>>>> >>       //o will be !null at some point
>>>>>> >>       do {
>>>>>> >>          if (o != null)
>>>>>> >>             return o;
>>>>>> >>          java.lang.Thread.onSpinWait();
>>>>>> >>          this.obj = o;
>>>>>> >>       } while(true);
>>>>>> >>    }
>>>>>> >>
>>>>>> >> Similarly to the queue API: poll should return null iff !done, but
>>>>>> offer update first done and then this.obj:
>>>>>> >> poll need to read obj, but has to stay consistent to the ordering,
>>>>>> so at some point, obj will be visible if done == true.
>>>>>> >> On JCtools we have some queues with a similar behaviour (producer
>>>>>> sequence is advanced before writing the actual element in the queue)
>>>>>> >> and we need to spin wait the element apprearence to stay
>>>>>> consistent with the isEmpty behaviour: that's a good use case for
>>>>>> onSpinWait (when it works :P).
>>>>>> >>
>>>>>> >>
>>>>>> >>
>>>>>> >> Il giorno gio 14 nov 2019 alle ore 16:43 Andrew Haley <
>>>>>> aph at redhat.com> ha scritto:
>>>>>> >> On 11/14/19 3:31 PM, Francesco Nigro via Concurrency-interest
>>>>>> wrote:
>>>>>> >> >     E o = this.obj;
>>>>>> >> >     if (o == null && !done) {
>>>>>> >> >         return null;
>>>>>> >> >      }
>>>>>> >> >      //o will be !null at some point
>>>>>> >> >      do {
>>>>>> >> >          if (o != null)
>>>>>> >> >             return o;
>>>>>> >> >          java.lang.Thread.onSpinWait();
>>>>>> >> >      } while(true);
>>>>>> >> > }
>>>>>> >> >
>>>>>> >> > In case like this is more appropriate, maybe, but much less
>>>>>> intuitive
>>>>>> >> > probably.
>>>>>> >>
>>>>>> >> Umm, what? o is a local. This loop spins forever.
>>>>>> >>
>>>>>> >> --
>>>>>> >> Andrew Haley  (he/him)
>>>>>> >> Java Platform Lead Engineer
>>>>>> >> Red Hat UK Ltd. <https://www.redhat.com>
>>>>>> >> https://keybase.io/andrewhaley
>>>>>> >> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>>>>>> >>
>>>>>> > _______________________________________________
>>>>>> > Concurrency-interest mailing list
>>>>>> > Concurrency-interest at cs.oswego.edu
>>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>> > _______________________________________________
>>>>>> > Concurrency-interest mailing list
>>>>>> > Concurrency-interest at cs.oswego.edu
>>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>> --
>>> Cheers,
>>> √
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> --
> Cheers,
> √
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/e0565791/attachment-0001.html>

From aph at redhat.com  Fri Nov 15 10:02:35 2019
From: aph at redhat.com (Andrew Haley)
Date: Fri, 15 Nov 2019 15:02:35 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
Message-ID: <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>

On 11/15/19 1:31 PM, Alex Otenko via Concurrency-interest wrote:
> I am not arguing. I want to see justification for wanting something that
> looks like a solution to an intractable problem.
> 
> I see onSpinWait as an indicator to the JVM that it can do something
> useful, like possibly help FJP make some progress. I can't see how a time
> bound can be enforced there.

But that is not what "onSpinWait" means, that is what "yield" means.
The idea of "onSpinWait" is to reduce latency in spin loops, where
latency is measured in tens of nanoseconds. "onSpinWait" is not
supposed to free the processor to do something else.

I don't think there's anything much wrong with the example in the Javadoc,
and the Javadoc is not supposed to be a tutorial.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From leventov.ru at gmail.com  Fri Nov 15 10:55:07 2019
From: leventov.ru at gmail.com (Roman Leventov)
Date: Fri, 15 Nov 2019 18:55:07 +0300
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <83d25bf3-5f9e-4148-b720-4043546d1d96@gmail.com>
 <CAKxGtTX8onmZLi9sBacgoX+LfB=-rXs9mWJBKjAWnBHfqHJTCg@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
 <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
Message-ID: <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>

I agree that Javadoc code shouldn't be a tutorial - that is why I also
proposed to delete the example completely. But I think the current example
is a little bit of anti-tutorial. To cite Josh Bloch - "Example code should
be exemplary. If an API is used widely, its examples will be the archetypes
for thousands of programs. Any mistakes will come back to haunt you a
thousand fold."

On Fri, 15 Nov 2019 at 18:04, Andrew Haley via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> On 11/15/19 1:31 PM, Alex Otenko via Concurrency-interest wrote:
> > I am not arguing. I want to see justification for wanting something that
> > looks like a solution to an intractable problem.
> >
> > I see onSpinWait as an indicator to the JVM that it can do something
> > useful, like possibly help FJP make some progress. I can't see how a time
> > bound can be enforced there.
>
> But that is not what "onSpinWait" means, that is what "yield" means.
> The idea of "onSpinWait" is to reduce latency in spin loops, where
> latency is measured in tens of nanoseconds. "onSpinWait" is not
> supposed to free the processor to do something else.
>
> I don't think there's anything much wrong with the example in the Javadoc,
> and the Javadoc is not supposed to be a tutorial.
>
> --
> Andrew Haley  (he/him)
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> https://keybase.io/andrewhaley
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191115/26a75581/attachment.html>

From aph at redhat.com  Sat Nov 16 04:15:53 2019
From: aph at redhat.com (Andrew Haley)
Date: Sat, 16 Nov 2019 09:15:53 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
 <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
 <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>
Message-ID: <be815ecc-613c-7b3d-d1e0-d1586e530659@redhat.com>

On 11/15/19 3:55 PM, Roman Leventov wrote:
> I agree that Javadoc code shouldn't be a tutorial - that is why I also
> proposed to delete the example completely. But I think the current example
> is a little bit of anti-tutorial. To cite Josh Bloch - "Example code should
> be exemplary. If an API is used widely, its examples will be the archetypes
> for thousands of programs. Any mistakes will come back to haunt you a
> thousand fold."

So far all that you have done is assert that there is something wrong
with the example. I have seen nothing remotely convincing about what
is wrong with it. The example, as posted, shows exactly how the
intrinsic should be used in a spin loop.

Here you say:

> By "half-baked" I meant specifically that the example could be valid but
> only under specific conditions, such as core-pinned thread, or backoff
> timeout event, etc.

All code is only valid under specific conditions. This specific
condition is spinning, which should only be done for a short while
when you know that a lock is only held for a short while. Anybody who
wants to know the advantages and disadvantages of spinning can go to
the Wikipedia page https://en.wikipedia.org/wiki/Spinlock.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From dl at cs.oswego.edu  Sun Nov 17 18:46:08 2019
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 17 Nov 2019 18:46:08 -0500
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <be815ecc-613c-7b3d-d1e0-d1586e530659@redhat.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CANkgWKj6b--q1E-hsR9ojugDSYGvoEG-YXPfORTJRcyt+Op2aA@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
 <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
 <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>
 <be815ecc-613c-7b3d-d1e0-d1586e530659@redhat.com>
Message-ID: <43d36cf0-86dd-e6e9-b68d-4de0ebfc785d@cs.oswego.edu>

On 11/16/19 4:15 AM, Andrew Haley via Concurrency-interest wrote:
> On 11/15/19 3:55 PM, Roman Leventov wrote:
>> I agree that Javadoc code shouldn't be a tutorial - that is why I also
>> proposed to delete the example completely. But I think the current example
>> is a little bit of anti-tutorial. To cite Josh Bloch - "Example code should
>> be exemplary. If an API is used widely, its examples will be the archetypes
>> for thousands of programs. Any mistakes will come back to haunt you a
>> thousand fold."
> 
> So far all that you have done is assert that there is something wrong
> with the example. I have seen nothing remotely convincing about what
> is wrong with it. The example, as posted, shows exactly how the
> intrinsic should be used in a spin loop.
> 
> Here you say:
> 
>> By "half-baked" I meant specifically that the example could be valid but
>> only under specific conditions, such as core-pinned thread, or backoff
>> timeout event, etc.
> 
> All code is only valid under specific conditions. This specific
> condition is spinning, which should only be done for a short while
> when you know that a lock is only held for a short while. Anybody who
> wants to know the advantages and disadvantages of spinning can go to
> the Wikipedia page https://en.wikipedia.org/wiki/Spinlock.
> 

I agree with all of this. I think the underlying concern is that we
don't include anything discussing the tradeoffs about when to use
spin-loops. Which we don't mainly because it is less straightforward
than in C. Usage may interact with GC, reference handling, and
safepoints: in some contexts "a short while" isn't usually short, but we
don't have a way of portably discussing such issues in javadocs. It's
also one of the reasons we don't include a spinlock utility -- we cannot
easily guess how best to write one that works well across enough usage
contexts. (But we do make it easy to write them via tryLock.)

-Doug


From pmhsfelix at gmail.com  Mon Nov 18 05:21:56 2019
From: pmhsfelix at gmail.com (Pedro Felix)
Date: Mon, 18 Nov 2019 10:21:56 +0000
Subject: [concurrency-interest] "happens-before" on NIO2 between read/write
 operation and CompletionHandler call
Message-ID: <CAD+AFDs-wfZoKTv8dpf1BHSc_4N3bhfiBOtd9EYij2-as+fyyQ@mail.gmail.com>

Hi,

Does NIO2 ensures a "happens-before" relation between an
AsynchronousByteChannel (ASB) read/write action and the first action in the
CompletionHandler "completed" method?
I've looked in the javadoc documentation and didn't found any mention of
"happens-before" being ensured.

Since NIO2 (presumably) needs to ensure that all writes into the read
ByteBuffer are visible to the first first action on the handler "completed"
method, I would assume all writes before the ASB.read call operation are
also visible.

Thanks,
Pedro
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191118/d622f990/attachment.html>

From Alan.Bateman at oracle.com  Mon Nov 18 05:34:10 2019
From: Alan.Bateman at oracle.com (Alan Bateman)
Date: Mon, 18 Nov 2019 10:34:10 +0000
Subject: [concurrency-interest] "happens-before" on NIO2 between
 read/write operation and CompletionHandler call
In-Reply-To: <CAD+AFDs-wfZoKTv8dpf1BHSc_4N3bhfiBOtd9EYij2-as+fyyQ@mail.gmail.com>
References: <CAD+AFDs-wfZoKTv8dpf1BHSc_4N3bhfiBOtd9EYij2-as+fyyQ@mail.gmail.com>
Message-ID: <56b330ed-fc53-298d-4dd7-11cb34507232@oracle.com>

On 18/11/2019 10:21, Pedro Felix via Concurrency-interest wrote:
> Hi,
>
> Does NIO2 ensures a "happens-before" relation between an 
> AsynchronousByteChannel (ASB) read/write action and the first action 
> in the CompletionHandler "completed" method?
> I've looked in the javadoc documentation and didn't found any mention 
> of "happens-before" being ensured.
>
We should update the javadoc. Can you create an issue in JBS for this or 
bring it to the OpenJDK nio-dev mailing lists for discussion?

-Alan

From aph at redhat.com  Mon Nov 18 05:36:30 2019
From: aph at redhat.com (Andrew Haley)
Date: Mon, 18 Nov 2019 10:36:30 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <43d36cf0-86dd-e6e9-b68d-4de0ebfc785d@cs.oswego.edu>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
 <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
 <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>
 <be815ecc-613c-7b3d-d1e0-d1586e530659@redhat.com>
 <43d36cf0-86dd-e6e9-b68d-4de0ebfc785d@cs.oswego.edu>
Message-ID: <bd787780-4b5b-eb76-bc73-06ca05fef451@redhat.com>

On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:

> Usage may interact with GC, reference handling, and safepoints: in
> some contexts "a short while" isn't usually short, but we don't have
> a way of portably discussing such issues in javadocs. It's also one
> of the reasons we don't include a spinlock utility -- we cannot
> easily guess how best to write one that works well across enough
> usage contexts. (But we do make it easy to write them via tryLock.)

Sure, these ideas are hard to express if we restrict ourselves to
the mythical "write once, run anywhere" Java, but by the time we're
talking about writing our own spinlocks we're a long way from that.

"Everybody" ;-) knows that you should only spin for about (half?) the
same time as a simple system call, and that this is about 1000
iterations of a trivial loop. Intuitively this makes sense: you don't
want to make an (expensive) system call rather than just waiting for a
little while.

-- 
Andrew Haley  (he/him)
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
https://keybase.io/andrewhaley
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From david.lloyd at redhat.com  Mon Nov 18 08:27:26 2019
From: david.lloyd at redhat.com (David Lloyd)
Date: Mon, 18 Nov 2019 07:27:26 -0600
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <bd787780-4b5b-eb76-bc73-06ca05fef451@redhat.com>
References: <CAAMLo=a80CmwcWuz3ZWmwRD-1V2u3-KA63kiWDyqReyyWJBV-w@mail.gmail.com>
 <CAKxGtTU-2TCHz+Omsi8rzRwJkDajODbOXhQqNagTh+oTUDwxVg@mail.gmail.com>
 <CAKxGtTVjgHMV+xATTFOKwh_y7c1G4GaHnjER+jJhqZt4_k9_aw@mail.gmail.com>
 <CAKxGtTWAGkedRV6gMYan-rfr57rx9AVErsJsSC_B-WEorL1LEw@mail.gmail.com>
 <7682E436-54AE-4026-B514-320C76E805A6@azul.com>
 <CAKxGtTUS4hL7ru7qv-rPWFG2ZA-_9Mb1gKqDhAZeAnqDV8fs9Q@mail.gmail.com>
 <CAAMLo=bjbMj-DTsOejAuz9n7gxA+VAGPdoYvUrm607acGE505Q@mail.gmail.com>
 <CANPzfU870wvNkFgxWbJy6_Wxj9XkY+R1v+B92XtyjCs6aM9fXA@mail.gmail.com>
 <CANkgWKgRsL9HDXJv2proZ-RKHT8XLLyqmHEhMZpTfAmBJGHOVw@mail.gmail.com>
 <CANPzfU-C=7-VdheMybvoy3YOMv_Qz=2O484SQFKjEYxsx-QURQ@mail.gmail.com>
 <CANkgWKiLxd=XK3NDTRP=FyHeT81Luu8wTjwg-myTJF3P_zUMOw@mail.gmail.com>
 <b469afdc-043a-c575-55ec-c10ae9f085d5@redhat.com>
 <CAAMLo=YdfH=oVmKM1YbME-o6zNrJbi8j+BNosPmZ9sM6WSkdKQ@mail.gmail.com>
 <be815ecc-613c-7b3d-d1e0-d1586e530659@redhat.com>
 <43d36cf0-86dd-e6e9-b68d-4de0ebfc785d@cs.oswego.edu>
 <bd787780-4b5b-eb76-bc73-06ca05fef451@redhat.com>
Message-ID: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>

On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
<concurrency-interest at cs.oswego.edu> wrote:
>
> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
>
> > Usage may interact with GC, reference handling, and safepoints: in
> > some contexts "a short while" isn't usually short, but we don't have
> > a way of portably discussing such issues in javadocs. It's also one
> > of the reasons we don't include a spinlock utility -- we cannot
> > easily guess how best to write one that works well across enough
> > usage contexts. (But we do make it easy to write them via tryLock.)
>
> Sure, these ideas are hard to express if we restrict ourselves to
> the mythical "write once, run anywhere" Java, but by the time we're
> talking about writing our own spinlocks we're a long way from that.
>
> "Everybody" ;-) knows that you should only spin for about (half?) the
> same time as a simple system call, and that this is about 1000
> iterations of a trivial loop. Intuitively this makes sense: you don't
> want to make an (expensive) system call rather than just waiting for a
> little while.

Should we not express this sentiment in the documentation somehow even
if it is not perfectly applicable to every operating environment,
since it's clearly not widely understood?

-- 
- DML


From gil at azul.com  Mon Nov 18 10:48:41 2019
From: gil at azul.com (Gil Tene)
Date: Mon, 18 Nov 2019 15:48:41 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
Message-ID: <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>



Sent from my iPad

> On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
> <concurrency-interest at cs.oswego.edu> wrote:
>> 
>>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
>>> 
>>> Usage may interact with GC, reference handling, and safepoints: in
>>> some contexts "a short while" isn't usually short, but we don't have
>>> a way of portably discussing such issues in javadocs. It's also one
>>> of the reasons we don't include a spinlock utility -- we cannot
>>> easily guess how best to write one that works well across enough
>>> usage contexts. (But we do make it easy to write them via tryLock.)
>> 
>> Sure, these ideas are hard to express if we restrict ourselves to
>> the mythical "write once, run anywhere" Java, but by the time we're
>> talking about writing our own spinlocks we're a long way from that.
>> 
>> "Everybody" ;-) knows that you should only spin for about (half?) the
>> same time as a simple system call, and that this is about 1000
>> iterations of a trivial loop. Intuitively this makes sense: you don't
>> want to make an (expensive) system call rather than just waiting for a
>> little while.
> 
> Should we not express this sentiment in the documentation somehow even
> if it is not perfectly applicable to every operating environment,
> since it's clearly not widely understood?

The sentiment is “common wisdom” for spinning ahead of a system call
that may be avoided by the spin succeeding (e.g. when waiting for a
condition variable that might soon be released). But it is far from universal
for spinning. And more importantly, should not be confused with “spinning
in user mode is common wisdom”.

For one, when spinning for net work reduction, the thing you are hoping to
be able to avoid by spinning for may not involve a system call, but something
else that is much more expensive (like creating some additional resource,
resizing and rehashing a data structure, or zeroing megabytes of memory),
so the “how long is it worth spinning for?” math is closely dependent on
why you are spinning.

But even more generally, spinning is used for much more than net work
reduction. It is (quite) often used for optimizing behavior in conjunction
with specific knowledge about e.g.  “what is more important”, “what is the
real bottleneck”, and “what thread can afford to spin forever if needed”
(e.g. because it is running on a dedicated isolcpu’ed vcore).

Spinning in user mode is *always* running with scissors. Blindfolded.
There is no form of user mode spinning that I know of that is generally
“good advise” or should be “common practice”. They are all quite
dangerous. And IMO The short backoff ones are actually much more
dangerous (as in can cause tremendous harm when not coded by
experts, and can be very fragile under load) than the ones that just
spin forever. The ones that spin forever have much more apparent
behavior that is easy to detect  in testing and say “well, that was was
a silly thing to do” about. The ones that spin “only a little bit” can seem
to be a good thing for quite a while, and through much testing in nice
stable lab environments, especially to people who don’t already have
scars from falling down the massive cliffs that exist when slightly 
prolonged resource holding starts making user-mode spinners start
delaying the threads holding the thing they spin for from releasing It.

Kernels prevent context switches when holding a spin lock for a reason.

> -- 
> - DML
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nathanila at gmail.com  Mon Nov 18 11:03:01 2019
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Mon, 18 Nov 2019 09:03:01 -0700
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
 <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
Message-ID: <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>

Another difficulty will be introduced with Project Loom and fibers.  
Will it be faster or better to switch to another fiber or spin?  This is 
highly dependent on the use case.

-Nathan

On 11/18/2019 8:48 AM, Gil Tene via Concurrency-interest wrote:
>
> Sent from my iPad
>
>> On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
>>
>> ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
>> <concurrency-interest at cs.oswego.edu> wrote:
>>>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
>>>>
>>>> Usage may interact with GC, reference handling, and safepoints: in
>>>> some contexts "a short while" isn't usually short, but we don't have
>>>> a way of portably discussing such issues in javadocs. It's also one
>>>> of the reasons we don't include a spinlock utility -- we cannot
>>>> easily guess how best to write one that works well across enough
>>>> usage contexts. (But we do make it easy to write them via tryLock.)
>>> Sure, these ideas are hard to express if we restrict ourselves to
>>> the mythical "write once, run anywhere" Java, but by the time we're
>>> talking about writing our own spinlocks we're a long way from that.
>>>
>>> "Everybody" ;-) knows that you should only spin for about (half?) the
>>> same time as a simple system call, and that this is about 1000
>>> iterations of a trivial loop. Intuitively this makes sense: you don't
>>> want to make an (expensive) system call rather than just waiting for a
>>> little while.
>> Should we not express this sentiment in the documentation somehow even
>> if it is not perfectly applicable to every operating environment,
>> since it's clearly not widely understood?
> The sentiment is “common wisdom” for spinning ahead of a system call
> that may be avoided by the spin succeeding (e.g. when waiting for a
> condition variable that might soon be released). But it is far from universal
> for spinning. And more importantly, should not be confused with “spinning
> in user mode is common wisdom”.
>
> For one, when spinning for net work reduction, the thing you are hoping to
> be able to avoid by spinning for may not involve a system call, but something
> else that is much more expensive (like creating some additional resource,
> resizing and rehashing a data structure, or zeroing megabytes of memory),
> so the “how long is it worth spinning for?” math is closely dependent on
> why you are spinning.
>
> But even more generally, spinning is used for much more than net work
> reduction. It is (quite) often used for optimizing behavior in conjunction
> with specific knowledge about e.g.  “what is more important”, “what is the
> real bottleneck”, and “what thread can afford to spin forever if needed”
> (e.g. because it is running on a dedicated isolcpu’ed vcore).
>
> Spinning in user mode is *always* running with scissors. Blindfolded.
> There is no form of user mode spinning that I know of that is generally
> “good advise” or should be “common practice”. They are all quite
> dangerous. And IMO The short backoff ones are actually much more
> dangerous (as in can cause tremendous harm when not coded by
> experts, and can be very fragile under load) than the ones that just
> spin forever. The ones that spin forever have much more apparent
> behavior that is easy to detect  in testing and say “well, that was was
> a silly thing to do” about. The ones that spin “only a little bit” can seem
> to be a good thing for quite a while, and through much testing in nice
> stable lab environments, especially to people who don’t already have
> scars from falling down the massive cliffs that exist when slightly
> prolonged resource holding starts making user-mode spinners start
> delaying the threads holding the thing they spin for from releasing It.
>
> Kernels prevent context switches when holding a spin lock for a reason.
>
>> -- 
>> - DML
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From nigro.fra at gmail.com  Mon Nov 18 11:07:50 2019
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Mon, 18 Nov 2019 17:07:50 +0100
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
 <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
 <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
Message-ID: <CAKxGtTVo27cQSjrHpJnab-CaKrL9bcvLyFk7WMLDWGW_1PU9Zw@mail.gmail.com>

I can't speak about what users can expected, but onSpinWait should
"improve" from a pure spin loop, hence I expect no fiber-switch to happen
on it...

Il lun 18 nov 2019, 17:03 Nathan and Ila Reynolds via Concurrency-interest <
concurrency-interest at cs.oswego.edu> ha scritto:

> Another difficulty will be introduced with Project Loom and fibers.
> Will it be faster or better to switch to another fiber or spin?  This is
> highly dependent on the use case.
>
> -Nathan
>
> On 11/18/2019 8:48 AM, Gil Tene via Concurrency-interest wrote:
> >
> > Sent from my iPad
> >
> >> On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
> >>
> >> ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
> >> <concurrency-interest at cs.oswego.edu> wrote:
> >>>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
> >>>>
> >>>> Usage may interact with GC, reference handling, and safepoints: in
> >>>> some contexts "a short while" isn't usually short, but we don't have
> >>>> a way of portably discussing such issues in javadocs. It's also one
> >>>> of the reasons we don't include a spinlock utility -- we cannot
> >>>> easily guess how best to write one that works well across enough
> >>>> usage contexts. (But we do make it easy to write them via tryLock.)
> >>> Sure, these ideas are hard to express if we restrict ourselves to
> >>> the mythical "write once, run anywhere" Java, but by the time we're
> >>> talking about writing our own spinlocks we're a long way from that.
> >>>
> >>> "Everybody" ;-) knows that you should only spin for about (half?) the
> >>> same time as a simple system call, and that this is about 1000
> >>> iterations of a trivial loop. Intuitively this makes sense: you don't
> >>> want to make an (expensive) system call rather than just waiting for a
> >>> little while.
> >> Should we not express this sentiment in the documentation somehow even
> >> if it is not perfectly applicable to every operating environment,
> >> since it's clearly not widely understood?
> > The sentiment is “common wisdom” for spinning ahead of a system call
> > that may be avoided by the spin succeeding (e.g. when waiting for a
> > condition variable that might soon be released). But it is far from
> universal
> > for spinning. And more importantly, should not be confused with “spinning
> > in user mode is common wisdom”.
> >
> > For one, when spinning for net work reduction, the thing you are hoping
> to
> > be able to avoid by spinning for may not involve a system call, but
> something
> > else that is much more expensive (like creating some additional resource,
> > resizing and rehashing a data structure, or zeroing megabytes of memory),
> > so the “how long is it worth spinning for?” math is closely dependent on
> > why you are spinning.
> >
> > But even more generally, spinning is used for much more than net work
> > reduction. It is (quite) often used for optimizing behavior in
> conjunction
> > with specific knowledge about e.g.  “what is more important”, “what is
> the
> > real bottleneck”, and “what thread can afford to spin forever if needed”
> > (e.g. because it is running on a dedicated isolcpu’ed vcore).
> >
> > Spinning in user mode is *always* running with scissors. Blindfolded.
> > There is no form of user mode spinning that I know of that is generally
> > “good advise” or should be “common practice”. They are all quite
> > dangerous. And IMO The short backoff ones are actually much more
> > dangerous (as in can cause tremendous harm when not coded by
> > experts, and can be very fragile under load) than the ones that just
> > spin forever. The ones that spin forever have much more apparent
> > behavior that is easy to detect  in testing and say “well, that was was
> > a silly thing to do” about. The ones that spin “only a little bit” can
> seem
> > to be a good thing for quite a while, and through much testing in nice
> > stable lab environments, especially to people who don’t already have
> > scars from falling down the massive cliffs that exist when slightly
> > prolonged resource holding starts making user-mode spinners start
> > delaying the threads holding the thing they spin for from releasing It.
> >
> > Kernels prevent context switches when holding a spin lock for a reason.
> >
> >> --
> >> - DML
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191118/ec286d96/attachment.html>

From viktor.klang at gmail.com  Mon Nov 18 11:08:25 2019
From: viktor.klang at gmail.com (Viktor Klang)
Date: Mon, 18 Nov 2019 16:08:25 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
 <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
 <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
Message-ID: <CANPzfU8jLphTEb+1XTYdQMUBQWQhkU6g+BMaRRY25Ysn98YaFg@mail.gmail.com>

That's a great point, Nathan!

On Mon, Nov 18, 2019 at 4:03 PM Nathan and Ila Reynolds via
Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:

> Another difficulty will be introduced with Project Loom and fibers.
> Will it be faster or better to switch to another fiber or spin?  This is
> highly dependent on the use case.
>
> -Nathan
>
> On 11/18/2019 8:48 AM, Gil Tene via Concurrency-interest wrote:
> >
> > Sent from my iPad
> >
> >> On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
> >>
> >> ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
> >> <concurrency-interest at cs.oswego.edu> wrote:
> >>>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
> >>>>
> >>>> Usage may interact with GC, reference handling, and safepoints: in
> >>>> some contexts "a short while" isn't usually short, but we don't have
> >>>> a way of portably discussing such issues in javadocs. It's also one
> >>>> of the reasons we don't include a spinlock utility -- we cannot
> >>>> easily guess how best to write one that works well across enough
> >>>> usage contexts. (But we do make it easy to write them via tryLock.)
> >>> Sure, these ideas are hard to express if we restrict ourselves to
> >>> the mythical "write once, run anywhere" Java, but by the time we're
> >>> talking about writing our own spinlocks we're a long way from that.
> >>>
> >>> "Everybody" ;-) knows that you should only spin for about (half?) the
> >>> same time as a simple system call, and that this is about 1000
> >>> iterations of a trivial loop. Intuitively this makes sense: you don't
> >>> want to make an (expensive) system call rather than just waiting for a
> >>> little while.
> >> Should we not express this sentiment in the documentation somehow even
> >> if it is not perfectly applicable to every operating environment,
> >> since it's clearly not widely understood?
> > The sentiment is “common wisdom” for spinning ahead of a system call
> > that may be avoided by the spin succeeding (e.g. when waiting for a
> > condition variable that might soon be released). But it is far from
> universal
> > for spinning. And more importantly, should not be confused with “spinning
> > in user mode is common wisdom”.
> >
> > For one, when spinning for net work reduction, the thing you are hoping
> to
> > be able to avoid by spinning for may not involve a system call, but
> something
> > else that is much more expensive (like creating some additional resource,
> > resizing and rehashing a data structure, or zeroing megabytes of memory),
> > so the “how long is it worth spinning for?” math is closely dependent on
> > why you are spinning.
> >
> > But even more generally, spinning is used for much more than net work
> > reduction. It is (quite) often used for optimizing behavior in
> conjunction
> > with specific knowledge about e.g.  “what is more important”, “what is
> the
> > real bottleneck”, and “what thread can afford to spin forever if needed”
> > (e.g. because it is running on a dedicated isolcpu’ed vcore).
> >
> > Spinning in user mode is *always* running with scissors. Blindfolded.
> > There is no form of user mode spinning that I know of that is generally
> > “good advise” or should be “common practice”. They are all quite
> > dangerous. And IMO The short backoff ones are actually much more
> > dangerous (as in can cause tremendous harm when not coded by
> > experts, and can be very fragile under load) than the ones that just
> > spin forever. The ones that spin forever have much more apparent
> > behavior that is easy to detect  in testing and say “well, that was was
> > a silly thing to do” about. The ones that spin “only a little bit” can
> seem
> > to be a good thing for quite a while, and through much testing in nice
> > stable lab environments, especially to people who don’t already have
> > scars from falling down the massive cliffs that exist when slightly
> > prolonged resource holding starts making user-mode spinners start
> > delaying the threads holding the thing they spin for from releasing It.
> >
> > Kernels prevent context switches when holding a spin lock for a reason.
> >
> >> --
> >> - DML
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191118/d881c32c/attachment-0001.html>

From oleksandr.otenko at gmail.com  Mon Nov 18 14:12:11 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 18 Nov 2019 19:12:11 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
 <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
Message-ID: <CANkgWKh-Sd6vZjq8vgcMuox7y5K3uUT6-bHg8DxwpTgGMM=f7A@mail.gmail.com>

Exactly. How do you optimize the cost of spinning, if you don't have a cost
function?

Alex

On Mon, 18 Nov 2019, 15:50 Gil Tene via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

>
>
> Sent from my iPad
>
> > On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
> >
> > ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
> > <concurrency-interest at cs.oswego.edu> wrote:
> >>
> >>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
> >>>
> >>> Usage may interact with GC, reference handling, and safepoints: in
> >>> some contexts "a short while" isn't usually short, but we don't have
> >>> a way of portably discussing such issues in javadocs. It's also one
> >>> of the reasons we don't include a spinlock utility -- we cannot
> >>> easily guess how best to write one that works well across enough
> >>> usage contexts. (But we do make it easy to write them via tryLock.)
> >>
> >> Sure, these ideas are hard to express if we restrict ourselves to
> >> the mythical "write once, run anywhere" Java, but by the time we're
> >> talking about writing our own spinlocks we're a long way from that.
> >>
> >> "Everybody" ;-) knows that you should only spin for about (half?) the
> >> same time as a simple system call, and that this is about 1000
> >> iterations of a trivial loop. Intuitively this makes sense: you don't
> >> want to make an (expensive) system call rather than just waiting for a
> >> little while.
> >
> > Should we not express this sentiment in the documentation somehow even
> > if it is not perfectly applicable to every operating environment,
> > since it's clearly not widely understood?
>
> The sentiment is “common wisdom” for spinning ahead of a system call
> that may be avoided by the spin succeeding (e.g. when waiting for a
> condition variable that might soon be released). But it is far from
> universal
> for spinning. And more importantly, should not be confused with “spinning
> in user mode is common wisdom”.
>
> For one, when spinning for net work reduction, the thing you are hoping to
> be able to avoid by spinning for may not involve a system call, but
> something
> else that is much more expensive (like creating some additional resource,
> resizing and rehashing a data structure, or zeroing megabytes of memory),
> so the “how long is it worth spinning for?” math is closely dependent on
> why you are spinning.
>
> But even more generally, spinning is used for much more than net work
> reduction. It is (quite) often used for optimizing behavior in conjunction
> with specific knowledge about e.g.  “what is more important”, “what is the
> real bottleneck”, and “what thread can afford to spin forever if needed”
> (e.g. because it is running on a dedicated isolcpu’ed vcore).
>
> Spinning in user mode is *always* running with scissors. Blindfolded.
> There is no form of user mode spinning that I know of that is generally
> “good advise” or should be “common practice”. They are all quite
> dangerous. And IMO The short backoff ones are actually much more
> dangerous (as in can cause tremendous harm when not coded by
> experts, and can be very fragile under load) than the ones that just
> spin forever. The ones that spin forever have much more apparent
> behavior that is easy to detect  in testing and say “well, that was was
> a silly thing to do” about. The ones that spin “only a little bit” can seem
> to be a good thing for quite a while, and through much testing in nice
> stable lab environments, especially to people who don’t already have
> scars from falling down the massive cliffs that exist when slightly
> prolonged resource holding starts making user-mode spinners start
> delaying the threads holding the thing they spin for from releasing It.
>
> Kernels prevent context switches when holding a spin lock for a reason.
>
> > --
> > - DML
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191118/01c940bb/attachment.html>

From oleksandr.otenko at gmail.com  Mon Nov 18 14:20:02 2019
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 18 Nov 2019 19:20:02 +0000
Subject: [concurrency-interest] The code example in onSpinWait() Javadoc
In-Reply-To: <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
References: <CANghgrTeBuxb0FRPpMtc41_JwxEDV2v03TG8gynFvXGO-JL=VA@mail.gmail.com>
 <888A048B-8F61-43AC-B5D4-9A3F65A7F5B6@azul.com>
 <97ae66e8-0a7e-858a-845f-f54d4061c121@gmail.com>
Message-ID: <CANkgWKid_+wQJZHreX-D=xDuaxPtBrh7S7+BhNharq3NpqCBng@mail.gmail.com>

As Andrew pointed out in another comment, that'd be yield. So Fibers just
change the cost of yield, not a net new decision. (Although maybe you'll
get to choose between two yields)

Alex

On Mon, 18 Nov 2019, 16:03 Nathan and Ila Reynolds via
Concurrency-interest, <concurrency-interest at cs.oswego.edu> wrote:

> Another difficulty will be introduced with Project Loom and fibers.
> Will it be faster or better to switch to another fiber or spin?  This is
> highly dependent on the use case.
>
> -Nathan
>
> On 11/18/2019 8:48 AM, Gil Tene via Concurrency-interest wrote:
> >
> > Sent from my iPad
> >
> >> On Nov 18, 2019, at 5:30 AM, David Lloyd via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
> >>
> >> ﻿On Mon, Nov 18, 2019 at 4:37 AM Andrew Haley via Concurrency-interest
> >> <concurrency-interest at cs.oswego.edu> wrote:
> >>>> On 11/17/19 11:46 PM, Doug Lea via Concurrency-interest wrote:
> >>>>
> >>>> Usage may interact with GC, reference handling, and safepoints: in
> >>>> some contexts "a short while" isn't usually short, but we don't have
> >>>> a way of portably discussing such issues in javadocs. It's also one
> >>>> of the reasons we don't include a spinlock utility -- we cannot
> >>>> easily guess how best to write one that works well across enough
> >>>> usage contexts. (But we do make it easy to write them via tryLock.)
> >>> Sure, these ideas are hard to express if we restrict ourselves to
> >>> the mythical "write once, run anywhere" Java, but by the time we're
> >>> talking about writing our own spinlocks we're a long way from that.
> >>>
> >>> "Everybody" ;-) knows that you should only spin for about (half?) the
> >>> same time as a simple system call, and that this is about 1000
> >>> iterations of a trivial loop. Intuitively this makes sense: you don't
> >>> want to make an (expensive) system call rather than just waiting for a
> >>> little while.
> >> Should we not express this sentiment in the documentation somehow even
> >> if it is not perfectly applicable to every operating environment,
> >> since it's clearly not widely understood?
> > The sentiment is “common wisdom” for spinning ahead of a system call
> > that may be avoided by the spin succeeding (e.g. when waiting for a
> > condition variable that might soon be released). But it is far from
> universal
> > for spinning. And more importantly, should not be confused with “spinning
> > in user mode is common wisdom”.
> >
> > For one, when spinning for net work reduction, the thing you are hoping
> to
> > be able to avoid by spinning for may not involve a system call, but
> something
> > else that is much more expensive (like creating some additional resource,
> > resizing and rehashing a data structure, or zeroing megabytes of memory),
> > so the “how long is it worth spinning for?” math is closely dependent on
> > why you are spinning.
> >
> > But even more generally, spinning is used for much more than net work
> > reduction. It is (quite) often used for optimizing behavior in
> conjunction
> > with specific knowledge about e.g.  “what is more important”, “what is
> the
> > real bottleneck”, and “what thread can afford to spin forever if needed”
> > (e.g. because it is running on a dedicated isolcpu’ed vcore).
> >
> > Spinning in user mode is *always* running with scissors. Blindfolded.
> > There is no form of user mode spinning that I know of that is generally
> > “good advise” or should be “common practice”. They are all quite
> > dangerous. And IMO The short backoff ones are actually much more
> > dangerous (as in can cause tremendous harm when not coded by
> > experts, and can be very fragile under load) than the ones that just
> > spin forever. The ones that spin forever have much more apparent
> > behavior that is easy to detect  in testing and say “well, that was was
> > a silly thing to do” about. The ones that spin “only a little bit” can
> seem
> > to be a good thing for quite a while, and through much testing in nice
> > stable lab environments, especially to people who don’t already have
> > scars from falling down the massive cliffs that exist when slightly
> > prolonged resource holding starts making user-mode spinners start
> > delaying the threads holding the thing they spin for from releasing It.
> >
> > Kernels prevent context switches when holding a spin lock for a reason.
> >
> >> --
> >> - DML
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191118/7f46f04d/attachment.html>

From radhakrishnan.mohan at gmail.com  Thu Nov 21 07:38:42 2019
From: radhakrishnan.mohan at gmail.com (Mohan Radhakrishnan)
Date: Thu, 21 Nov 2019 18:08:42 +0530
Subject: [concurrency-interest] ScheduledFuture to CompletableFuture.
Message-ID: <CAOoXFP9_XUgULYbZsWrw_DtBTBnE8jExTjkzzEnbStTeE8oyOg@mail.gmail.com>

Hello,

I have looked at some suggestions to work with existing ScheduledFuture code
and convert it into a CompletableFuture. This is needed so that a dependent
task
can follow the main task. Is this a proper way to investigate this problem ?

I can't change the existing code due to some reasons here but I have to
track
the next task based on the first basically to stop execution of the second
if the first
one has exceptions.

Thanks,
Mohan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20191121/46d68a78/attachment.html>

