From larryr@saturn.sdsu.edu 1 Aug 2002 01:16:47 -0000
Date: 1 Aug 2002 01:16:47 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Spinlock

Sorry if this is a dumb question.  I am wondering
if there might be something like a spinlock in
java.util.concurrent, where by a "spinlock" I mean
a lock that without contention can be acquired and
released extremely quickly, where a busy wait loop is
a reasonable implementation, because the lock will
only be used in a situation where it is held by any
one thread for very short time, and it is acquired
and released often enough to make it worth saving the
overhead of a normal wait/notify kind of implementation.

If using spinlocks is considered a bad enough idea
in Java code to make it undesirable to have such a
thing, then never mind. :-)


Larry





From dholmes@dltech.com.au Thu, 1 Aug 2002 11:45:57 +1000
Date: Thu, 1 Aug 2002 11:45:57 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Spinlock

> Sorry if this is a dumb question.  I am wondering
> if there might be something like a spinlock in
> java.util.concurrent

There may not be an actual spinlock class but the atomic compareAndSwap
operation will make it trivial to implement one:

class SpinLock {

  static final int LOCKED = 1;
  static final int UNLOCKED = 0;
  AtomicInteger lock = new AtomicInteger(UNLOCKED);

  public void acquire() {
      while (lock.compareAndSwap(UNLOCKED, LOCKED) == LOCKED)
          ; // spin
  }

  public void release() {
      lock.set(UNLOCKED);
  }

}

Gee I hope I got that right :-)

Under a "quality" implementation the above will reduce to what you would
expect/hope.

David Holmes





From tringuyen99@yahoo.com Wed, 31 Jul 2002 22:06:01 -0700 (PDT)
Date: Wed, 31 Jul 2002 22:06:01 -0700 (PDT)
From: Tri Nguyen tringuyen99@yahoo.com
Subject: [concurrency-interest]multithread libraries

Hi,

I am looking for multithread libraries.  

Does anyone know of any good ones, either commercial
or not?  In particular, I'm looking for a multithread
library that has functionality such as threadpool
management.

What companies provide these libraries?  Any other
groups provide these libraries?

Thank You.

Tri

__________________________________________________
Do You Yahoo!?
Yahoo! Health - Feel better, live better
http://health.yahoo.com




From dholmes@dltech.com.au Thu, 1 Aug 2002 15:35:28 +1000
Date: Thu, 1 Aug 2002 15:35:28 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]multithread libraries

Hello Tri,

> Does anyone know of any good ones, either commercial
> or not?  In particular, I'm looking for a multithread
> library that has functionality such as threadpool
> management.

If you managed to find this list I'm surprised that you didn't also find a
reference to Doug Lea's util.concurrent package:

http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.h
tml

PooledExecutor is an extensible, tunable thread pool class.


David





From TEREKHOV@de.ibm.com Thu, 1 Aug 2002 14:23:52 +0200
Date: Thu, 1 Aug 2002 14:23:52 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest]Spinlock

Larry Riedel  wrote:

> Sorry if this is a dumb question.  I am wondering
> if there might be something like a spinlock in
> java.util.concurrent, where by a "spinlock" I mean
> a lock that without contention can be acquired and
> released extremely quickly, where a busy wait loop is
> a reasonable implementation, because the lock will
> only be used in a situation where it is held by any
> one thread for very short time, and it is acquired
> and released often enough to make it worth saving the
> overhead of a normal wait/notify kind of implementation.
>
> If using spinlocks is considered a bad enough idea
> in Java code to make it undesirable to have such a
> thing, then never mind. :-)

< Butenhof, comp.programming.threads >

---

"A spinlock is a machine-specific "optimized" form of mutex
 ("MUTual EXclusion" device). However, you should never use
 a spinlock unless you know that you have multiple threads
 and that you're running on a multiprocessor. Otherwise, at
 best you're wasting a lot of time. A spinlock is great for
 "highly parallel" algorithms like matrix decompositions,
 where the application (or runtime) "knows" (or at least goes
 to lengths to ensure) that the threads participating are all
 running at the same time. Unless you know that, (and, if your
 code doesn't create threads, you CAN'T know that), don't even
 think of using a spinlock."

---

"But pthread_mutex_lock MAY, legally, and reasonably, be a
 spinlock. POSIX does not require that the calling thread be
 de-scheduled, either immediately or at all, to wait for the
 mutex to become available. An implementation that simply
 spins is perfectly reasonable, though really only practical
 for a multiprocessor realtime embedded system. More
 realistically, "mainstream" implementations often do spin
 for a short time before de-scheduling the waiter. This follows
 directly from the design and intended use of a mutex. A mutex
 should be held over a small portion of code, for a short time.
 Any other use risks severe performance and concurrency reduction
 due to inherent conflicts with the design of the synchronization
 function.

 Is is LEGAL to use a mutex for a long wait? Sure. It's not a
 good design, though, and may perform poorly, (ironically), on
 implementations optimized for high performance multiprocessor
 mutex synchronization.

 > However, note that pthread_mutex_lock() is not a cancellation point.
 > This means that it's clearly inappropriate for *indefinite* waiting,
 > since then rude, crude techniques are required to unblock the thread
 > to precipitate a shutdown.

 This is a really big point to remember. For any unbounded wait,
 your thread should be cancellable. Of course, if you know that
 only you can create a thread that might run the routine doing the
 wait, and you know that you'll never cancel it, that's irrelevant.
 But if you're writing a library routine that might be called in
 "someone else's" thread, you should write it to be cancellable,
 and cancel-safe."

---

regards,
alexander.






From larryr@saturn.sdsu.edu 2 Aug 2002 00:05:11 -0000
Date: 2 Aug 2002 00:05:11 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Lease?

I think it would be neat if java.util.concurrent
includes something like a "lease" mechanism for
acquiring a lock in such a way that if if the lock
is not released within a specified amount of time,
then an acquire for the lock will succeed even
though the lock was never explicitly released.
Unless maybe the holder of the lock "renews" it.

This seems like something which might fit into the
"Synchronization Attributes".  I did not notice
anything that seemed quite like it below
http://gee.cs.oswego.edu/dl/concurrent/index.html

I can see that it might be considered an inelegant
way to do things, and anyway better implemented on
top of the more fundamental java.util.concurrent,
rather than as part of it.


Larry





From brian@quiotix.com Thu, 1 Aug 2002 17:17:02 -0700
Date: Thu, 1 Aug 2002 17:17:02 -0700
From: Brian Goetz brian@quiotix.com
Subject: [concurrency-interest]Lease?

> I think it would be neat if java.util.concurrent
> includes something like a "lease" mechanism for
> acquiring a lock in such a way that if if the lock
> is not released within a specified amount of time,
> then an acquire for the lock will succeed even
> though the lock was never explicitly released.
> Unless maybe the holder of the lock "renews" it.

This is a pretty useful concept; it shows up in things like connection
pool management, and also for resource reservations systems where a
user is notified that a resource is avialable and he has two minutes
to claim it.  In fact, I have an application for this sort of thing in
two projects I'm working on now, and can think of a bunch of projects
in the past that would have benefited.  I like it. 

The idea would be that a process acquires a lock, and has a certain
amount of time to renew the lock or release it.  If it is released by
the timer, a lockReleased() method is called on a provided
notification object.





From dholmes@dltech.com.au Fri, 2 Aug 2002 10:22:49 +1000
Date: Fri, 2 Aug 2002 10:22:49 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Lease?

> I think it would be neat if java.util.concurrent
> includes something like a "lease" mechanism for
> acquiring a lock in such a way that if if the lock
> is not released within a specified amount of time,
> then an acquire for the lock will succeed even
> though the lock was never explicitly released.
> Unless maybe the holder of the lock "renews" it.

While I understand the role of leasing in general distributed contexts I
don't see a good reason to obtain a lock under a lease. You would never want
to leave a thread executing in a critical section when their lease was
revoked. Lease revocation can only be done at safe points and I don't see
how you could determine that such a safe point existed.

In distributed contexts the lease gives you the right to do something and
while you are doing it - eg a remote operation - expiration of the lease
does not affect you. The next time you try a remote op the lease expiration
will cause a failure. Have more than one party own a lease for the same
thing is generally not a problem. That is not true if the "thing" is a lock.

Can you clarify why you think such a facility might be useful.

David Holmes





From dholmes@dltech.com.au Fri, 2 Aug 2002 10:31:11 +1000
Date: Fri, 2 Aug 2002 10:31:11 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Lease?

Brian wrote:
> The idea would be that a process acquires a lock, and has a certain
> amount of time to renew the lock or release it.  If it is released by
> the timer, a lockReleased() method is called on a provided
> notification object.

I agree that that idea of being given a certain amount of time to claim a
resource is useful. But putting a time limit of releasing a lock is not. You
can't just give some other a thread a lock and allow them to enter a
critical section that the first thread has not completed. I just don't see
this as a viable technique for locks.

I can see a use for the "use it or lose it" approach. When you want to
acquire multiple locks you request them and they are reserved for you to
use. If you don't acquire them in the time given then your reservation is
released and you'll get an error on the acquire.

But reservation schemes are quite different to leasing schemes. I don't see
any reasonable interpretation for giving a second thread a lock that was
still protecting a critical section.

David Holmes





From tom.may@infospace.com 01 Aug 2002 17:46:37 -0700
Date: 01 Aug 2002 17:46:37 -0700
From: Tom May tom.may@infospace.com
Subject: [concurrency-interest]Lease?

Brian Goetz <brian@quiotix.com> writes:

> > I think it would be neat if java.util.concurrent
> > includes something like a "lease" mechanism for
> > acquiring a lock in such a way that if if the lock
> > is not released within a specified amount of time,
> > then an acquire for the lock will succeed even
> > though the lock was never explicitly released.
> > Unless maybe the holder of the lock "renews" it.
> 
> This is a pretty useful concept; it shows up in things like connection
> pool management, and also for resource reservations systems where a
> user is notified that a resource is avialable and he has two minutes
> to claim it.  In fact, I have an application for this sort of thing in
> two projects I'm working on now, and can think of a bunch of projects
> in the past that would have benefited.  I like it. 
> 
> The idea would be that a process acquires a lock, and has a certain
> amount of time to renew the lock or release it.  If it is released by
> the timer, a lockReleased() method is called on a provided
> notification object.

I've only used leases in situations where both of the following are
true: 1) it can't be guaranteed that the lock will ever be released,
and 2) it is ok for two or more entities to both think they have the
lease.  Although if you require the thread to use some sort of lease
token when doing lease-related activity then #2 isn't necessary since
you can fail the action when a stale lease token is used.

So, I've never used them within a single Java program since it's
always been possible to use "finally" to guarantee lock release.  I've
used them across processes and machines which could crash, lose
network connectivity, etc., but that's required some sort of external
lease manager, which could be a database table or whatever, and is
probably outside the scope of java.util.concurrent.

But, perhaps I'm just not aware of good uses for them within a single
process.

Tom.




From larryr@saturn.sdsu.edu 2 Aug 2002 01:29:27 -0000
Date: 2 Aug 2002 01:29:27 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Lease?

> > I think it would be neat if java.util.concurrent
> > includes something like a "lease" mechanism for
> > acquiring a lock in such a way that if if the lock is
> > not released within a specified amount of time [...]


> In distributed contexts the lease gives you the right
> to do something and while you are doing it - eg a
> remote operation - expiration of the lease does not
> affect you. The next time you try a remote op the lease
> expiration will cause a failure. Have more than one
> party own a lease for the same thing is generally not a
> problem. That is not true if the "thing" is a lock.

My perspective, which does not necessarily have much merit
or foundation, is that a lease or a lock grants an entity
authorization to exclude other entities from performing
operations on the subject of the lease/lock, maybe including
querying it about (parts of) its state.

As I meant to use the word "lease", I mean that the
permission is revocable based merely on the passage of time,
rather than, say, explicit revocation by another suitably
authorized entity.


> You would never want to leave a thread executing in a
> critical section when their lease was revoked.

My use of terminology is often not precise or accurate, but
in my mind "critical section" tends to connote a section of
code which is relatively simple and short and not likely
to block, etc.  I would not think to apply a lease to a
situation like that, especially since I think of lease times
more in terms of milliseconds than microseconds.

In the context of a lease, I would be thinking more about
something along the lines of acquiring a lock for using a
certain resource like, maybe, a "connection".

Say for a particular application it is known that unless
something strange happened, the connection will never be
used for more than 5 seconds at a time.  So the lease is
acquired with a (conservative) expiration of 10 seconds.

If whoever acquired the lock managed to get hung up or got
some sort of exception that it failed to handle, the lease
expires, some sort of soft reset is done on the connection,
and the rest of the system is not as dramatically impacted
by the failure of the one part.

A situation where a lease is desirable might come up where
it was not considered the best overall approach to try
to do all the interaction with the connection inside one
try/finally block.


> Lease revocation can only be done at safe points and I
> don't see how you could determine that such a safe point
> existed.

It would by definition be an attribute of the system as a
whole that it can deal with the partial failures associated
with the expiration the leases it employs.


I do not mean to be claiming this should be part of
java.util.concurrent, or that it is the right way, or even
a good way, to design or implement a system.  It is just
something I would use and seems like in some form it could
pretty easily be hooked in as part of java.util.concurrent.


Larry





From jozart@csi.com Thu, 1 Aug 2002 18:52:58 -0700
Date: Thu, 1 Aug 2002 18:52:58 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest]Lease?

FWIW, the leased transactions in JavaSpaces, which are based on the leased
transactions in Jini come to mind.

In these cases, I believe it is the transaction that is leased, and the
transaction may lock resources.


----- Original Message -----
From: "Larry Riedel" <larryr@saturn.sdsu.edu>
To: <concurrency-interest@altair.cs.oswego.edu>
Cc: "David Holmes" <dholmes@dltech.com.au>
Sent: Thursday, August 01, 2002 6:29 PM
Subject: RE: [concurrency-interest]Lease?



> > I think it would be neat if java.util.concurrent
> > includes something like a "lease" mechanism for
> > acquiring a lock in such a way that if if the lock is
> > not released within a specified amount of time [...]


> In distributed contexts the lease gives you the right
> to do something and while you are doing it - eg a
> remote operation - expiration of the lease does not
> affect you. The next time you try a remote op the lease
> expiration will cause a failure. Have more than one
> party own a lease for the same thing is generally not a
> problem. That is not true if the "thing" is a lock.

My perspective, which does not necessarily have much merit
or foundation, is that a lease or a lock grants an entity
authorization to exclude other entities from performing
operations on the subject of the lease/lock, maybe including
querying it about (parts of) its state.

As I meant to use the word "lease", I mean that the
permission is revocable based merely on the passage of time,
rather than, say, explicit revocation by another suitably
authorized entity.


> You would never want to leave a thread executing in a
> critical section when their lease was revoked.

My use of terminology is often not precise or accurate, but
in my mind "critical section" tends to connote a section of
code which is relatively simple and short and not likely
to block, etc.  I would not think to apply a lease to a
situation like that, especially since I think of lease times
more in terms of milliseconds than microseconds.

In the context of a lease, I would be thinking more about
something along the lines of acquiring a lock for using a
certain resource like, maybe, a "connection".

Say for a particular application it is known that unless
something strange happened, the connection will never be
used for more than 5 seconds at a time.  So the lease is
acquired with a (conservative) expiration of 10 seconds.

If whoever acquired the lock managed to get hung up or got
some sort of exception that it failed to handle, the lease
expires, some sort of soft reset is done on the connection,
and the rest of the system is not as dramatically impacted
by the failure of the one part.

A situation where a lease is desirable might come up where
it was not considered the best overall approach to try
to do all the interaction with the connection inside one
try/finally block.


> Lease revocation can only be done at safe points and I
> don't see how you could determine that such a safe point
> existed.

It would by definition be an attribute of the system as a
whole that it can deal with the partial failures associated
with the expiration the leases it employs.


I do not mean to be claiming this should be part of
java.util.concurrent, or that it is the right way, or even
a good way, to design or implement a system.  It is just
something I would use and seems like in some form it could
pretty easily be hooked in as part of java.util.concurrent.


Larry


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From dholmes@dltech.com.au Fri, 2 Aug 2002 11:55:18 +1000
Date: Fri, 2 Aug 2002 11:55:18 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Lease?

> My use of terminology is often not precise or accurate, but
> in my mind "critical section" tends to connote a section of
> code which is relatively simple and short and not likely
> to block, etc.  I would not think to apply a lease to a
> situation like that, especially since I think of lease times
> more in terms of milliseconds than microseconds.

I use the term critical section for any sequence of actions that have some
form of atomicity requirement and thus might employ a lock. In short by (my)
definition if you need to hold a lock when executing some piece of code that
code constitutes a critical section. The duration is immaterial in this
context.

> In the context of a lease, I would be thinking more about
> something along the lines of acquiring a lock for using a
> certain resource like, maybe, a "connection".

What you describe sounds more like general resource management than lock
management to me. I understand the ideas behind leases and reservations in
terms of general resource management. I also see that use of locks to gain
access to a resource is a form of resource management. And that by analogy,
any mechanism that grants you exclusive use of a resource (or even
controlled shared use) is a form of locking. But that doesn't imply, to me
at least, the resource management and locking are synonymous and fully
interchangeable :)

So I think the conflict we have is in the use of the term "lock". In the
util.concurrent context I think of locks in terms of synchronized blocks or
methods, mutex style locks, read/write locks and things of that ilk. The
ability to revoke a lock while it is being held is something that could only
be done in a very narrow set of circumstances and is not something that I
think any general locking mechanism (of the type discussed) would, or
should, support. It is also something I'd prefer to see performed via a
resource management API than a locking API.

> If whoever acquired the lock managed to get hung up or got
> some sort of exception that it failed to handle, the lease
> expires, some sort of soft reset is done on the connection,
> and the rest of the system is not as dramatically impacted
> by the failure of the one part.

Given the current proposals for util.concurrent I'd probably turn this
around and have the thread trying to acquire the lock perform a timed
tryLock. If the timeout expires then the holder of the lock must have "hung
up" somehow, so we either "reset" the connection to free the holding thread,
or interrupt the holding thread, or something along those lines. Either way
everything must be written to account for the possibility of failure and the
means by which recovery will be attempted.

Cheers,
David Holmes





From larryr@saturn.sdsu.edu 2 Aug 2002 02:07:11 -0000
Date: 2 Aug 2002 02:07:11 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Lease?

> FWIW, the leased transactions in JavaSpaces,
> which are based on the leased transactions
> in Jini come to mind.

But I am trying to steer away from "leases
are not useful inside a single JVM"!  :-)


Larry





From larryr@saturn.sdsu.edu 2 Aug 2002 02:29:59 -0000
Date: 2 Aug 2002 02:29:59 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Lease?

> What you describe sounds more like general resource management
> than lock management to me. I understand the ideas behind leases
> and reservations in terms of general resource management. I
> also see that use of locks to gain access to a resource is a
> form of resource management. And that by analogy, any mechanism
> that grants you exclusive use of a resource (or even controlled
> shared use) is a form of locking. But that doesn't imply, to me
> at least, the resource management and locking are synonymous and
> fully interchangeable :)

Yes, so there may be a question of where in the gray
area to draw the lines which will leave developers using
java.util.concurrent needing to build their own solutions
because their requirements have been deemed to lie too far
to the side of general resource management.  I do not feel
I am in a position to say where those lines should be,
and I have confidence in the people making the decisions.


> Given the current proposals for util.concurrent I'd probably
> turn this around and have the thread trying to acquire the
> lock perform a timed tryLock. If the timeout expires then
> the holder of the lock must have "hung up" somehow, so we
> either "reset" the connection to free the holding thread,
> or interrupt the holding thread, or something along those
> lines. Either way everything must be written to account for
> the possibility of failure and the means by which recovery
> will be attempted.

What appeals to me is the idea of a convenient mechanism
where instead of the entity which is trying to acquire the
lease for the resource having to deal with the failure, it
is the manager of the leases (if one is needed) who has been
hooked into the API so that it can be notified about lease
expirations and/or that an entity is trying to acquire a lease
for a resource whose lease has expired, and the manager can
try to transparently recover from the partial failure, if any
recovery is necessary; I am only thinking about simple use
cases, not some sort of transaction manager which is clearly
outside the scope of java.util.concurrent.


Larry





From joshua.bloch@sun.com Thu, 1 Aug 2002 21:10:06 -0700
Date: Thu, 1 Aug 2002 21:10:06 -0700
From: Joshua Bloch joshua.bloch@sun.com
Subject: [concurrency-interest]Lease?

   I am not a fan of this construct.  I see it as dangerous and difficult
(or impossible) to use safely.  It is a poor approximation to a "transaction
timeout."  The big difference is that a transaction timeout rolls back any
actions already undertaken by the transaction before it drops the lock.

           Regards,

           Josh






From paul@paulhaahr.com Fri,  2 Aug 2002 05:53:12 -0700 (PDT)
Date: Fri,  2 Aug 2002 05:53:12 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest]Lease?

I agree with Josh and David Holmes, who I think are saying basically the
same thing.  A lease implies that state may be mutated while it's held,
and that's not what you want in the absence of transaction-style rollback.

Instead, an interface for pre-reserving locks might very well be
interesting, as a building block for transaction-like objects.  For
example,

  interface ReservableLock extends Lock {
    void reserve(long millis) throws InterruptedException;
    void reserveUninterruptibly(long millis);
    void attemptReserve(long millis);
    void attemptReserve(long time, Clock clock);
    void releaseReservation();
    // acquire() could also throw ReservationExpired or ReservationMissing
  }

  exception ReservationExpired extends RuntimeException { ... }
  exception ReservationMissing extends RuntimeException { ... }

To other threads, a reservation appears similar to holding the lock, but
the thread itself would need to do something like:

  lock.reserve(1000);
  // ... prepare ...
  try {
    lock.acquire();
    // ... commit ...
    lock.release();
  }
  catch (ReservationExpired e) {
    // ... rollback external effects ...
  }
  finally {
    // ... release external resources ...
  }

Note that the prepare and rollback probably involve making changes to
structures which are held by *other* locks.

On the downside, if reserving a lock does prevent other threads from
acquiring the lock, a thread could act as if it owned the lock and
bugs would only show up if the reservation expired.

Would this interface satisfy the people who want leases?  Is the general
utility high enough to make it worth including?

--p




From joshua.bloch@sun.com Sat, 3 Aug 2002 09:52:07 -0700
Date: Sat, 3 Aug 2002 09:52:07 -0700
From: Joshua Bloch joshua.bloch@sun.com
Subject: [concurrency-interest]Lease?

Paul,

    Hi.  I don't exactly understand the semantics of your ReservableLock.  I
do believe that such a construct is possible, but a bit "researchy."  I
think we'd run into some tricky design decisions as we attempted to tighten
up the specs.  I'd want a year's experience with it before comitting to it
as part of a Java platform API.  One of the nice things about
util.concurrent is that everything in it is already battle-tested.

               Regards,

               Josh






From brian@quiotix.com Sun, 04 Aug 2002 22:27:03 -0700
Date: Sun, 04 Aug 2002 22:27:03 -0700
From: Brian Goetz brian@quiotix.com
Subject: [concurrency-interest]Lease?

>I agree that that idea of being given a certain amount of time to claim a
>resource is useful. But putting a time limit of releasing a lock is not.

Right, I skipped over the part that said "lock".

Still, there is a significant concurrency aspect to reservation 
schemes.  One thread may send another a message, that it has N seconds to 
claim this resource, and want to be notified if the other thread doesn't 
claim the resource within the time window.

Something like this:

public interface LeaseCompletionHandler {
   public static int COMPLETED = 1;
   public static int CANCELLED = 2;
   public static int EXPIRED = 3;

   public void leaseCompleted(int dispositionCode);
}

public class Lease {
   public Lease(int expirationTime, LeaseCompletionHandler handler);

   // Release the lease normally
   public void release();

   // Cancel the lease
   public void cancel();

   // Is the lease still active?
   public boolean isActive();
}



--
Brian Goetz
Quiotix Corporation
brian@quiotix.com           Tel: 650-843-1300            Fax: 650-324-8032

http://www.quiotix.com





From dholmes@dltech.com.au Mon, 5 Aug 2002 15:47:11 +1000
Date: Mon, 5 Aug 2002 15:47:11 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Lease?

> Still, there is a significant concurrency aspect to reservation
> schemes.

Sure - leasing/reservations are inherently concurrent protocols. If multiple
parties weren't involved you wouldn't need a lease or reservation. I tend to
see these protocols as being more associated with distributed concurrency
than multi-threading though. Either way these types of higher-level
coordination protocols are beyond the scope of the current util.concurrent
aims and the basic locking mechanisms that are being looked at - IMHO.

FWIW I once implemented a (research) system that allowed reservation of
service objects either at the object or individual method level. Error
recovery was left up to the application - though yanking a reservation
before it gets claimed is much easier than yanking a lease while it's in
use.

David Holmes





From larryr@saturn.sdsu.edu 5 Aug 2002 20:48:29 -0000
Date: 5 Aug 2002 20:48:29 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Lease?

David Holmes wrote:
> [...] these types of higher-level coordination protocols are
> beyond the scope of the current util.concurrent aims and the
> basic locking mechanisms that are being looked at - IMHO.

To me a simple Lease mechanism does not seem more high level or
less basic than PriorityBlockingQueue and CopyOnWriteArraySet.

I personally would be happy with a Lease class which essentially
implements Lock, except it returns an ID from acquire(), and
takes that ID for release(), and has a constructor which takes a
lease length and a LeaseManager reference.

LeaseManager could be an interface with a boolean
onLeaseExpiration() operation which is invoked when an attempt
is made to acquire() a Lease which has expired (the Lease has
been acquire()d but not release()d and the time since the most
recent acquire() is greater than the lease length).

The LeaseManager could say whether or not it has successfully
prepared the protected resource to be leased again, and the new
acquire() would succeed or fail accordingly.  The assumption
behind using a Lease in the first place would be that for the
particular use case, it will in some significant number of cases
be possible for the LeaseManager to have that acquire() succeed.

Sort of a trivial form of JavaBeans constrained properties, or a
hook for a trigger in a database.  To me the basic functionality
and semantics seem relatively simple and fundamental.  But I do not
mean to claim that Lease style functionality is valuable enough to
be in java.util.concurrent; I have no idea if it is or not.


Larry





From dl@cs.oswego.edu Mon, 5 Aug 2002 19:24:03 -0400
Date: Mon, 5 Aug 2002 19:24:03 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Dear concurrency-interest list subscribers,

We in the JSR 166 expert group have reached a point of tentative
agreement (modulo a few issues) on APIs.  We invite you to take a look
at them and tell us what you think. (In fact, we DEMAND that you do
so. Otherwise you have no reason to be on this mailing list :-)

The APIs are not yet anywhere near fully specified. Our next step is
to nail these down rigorously, but we want to check general reaction
before doing so (without yet going through the formalities of JCP JSR
reviews).  At the moment, javadocs include only enough details for us
in the EG to figure out what they mean. Hopefully you will too. Most
planned implementations are based on those in my dl.util.concurrent
package, most of which have better documentation than we currently
have for JSR 166 versions.

We are looking for any kind of constructive critiques: Notes about
missing, superfluous, misguided, or confusing functionality, bad
names, failures to meet practical programming needs, and so on.
You can post them to the list, or just mail them to me if you like.

A brief introduction to JSR 166 features (that also serves as the draft
java.util.concurrent package documentation) is at
  http://gee.cs.oswego.edu/dl/concurrent/intro.html
The Javadocs are at:
  http://gee.cs.oswego.edu/dl/concurrent/index.html
You might also find (barely) useful some UML diagrams automatically
generated by TogetherJ. For java.util.concurrent:
  http://gee.cs.oswego.edu/dl/concurrent/concurrent.gif
Also for the added/changed parts of java.util:
  http://gee.cs.oswego.edu/dl/concurrent/util.gif

Thanks very much for helping us out!

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  




From lfarkas@mindmaker.hu Tue, 06 Aug 2002 10:35:09 +0200
Date: Tue, 06 Aug 2002 10:35:09 +0200
From: Levente Farkas lfarkas@mindmaker.hu
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:
> 
> Dear concurrency-interest list subscribers,
> 
> We in the JSR 166 expert group have reached a point of tentative
> agreement (modulo a few issues) on APIs.  We invite you to take a look
> at them and tell us what you think. (In fact, we DEMAND that you do
> so. Otherwise you have no reason to be on this mailing list :-)
> 
> The APIs are not yet anywhere near fully specified. Our next step is
> to nail these down rigorously, but we want to check general reaction
> before doing so (without yet going through the formalities of JCP JSR
> reviews).  At the moment, javadocs include only enough details for us
> in the EG to figure out what they mean. Hopefully you will too. Most
> planned implementations are based on those in my dl.util.concurrent
> package, most of which have better documentation than we currently
> have for JSR 166 versions.

I just repeat my previous comment I always prefere symmethric names (so I
prefere unix naming convension over windows one's waitforsingleobject...):
Lock.lock, Lock.unlock, Lock.trylock
and similar for other functions. another think I always prefer shorter names
(if not loose the meaning) since there is not any non-reentrant version
ReentrantLock and ReentrantReadWriteLock can be shorter, 
eg: Locker and ReadWriteLocker.
and if we call ConcurrentHashMap why we call LinkedBlockingQueue and 
SynchronousQueue? I know this is just a naming convension, but it always
good to keep one simple naming schame.

just my 2c.

-- 
  Levente                               "Si vis pacem para bellum!"




From miles@milessabin.com Tue, 6 Aug 2002 10:00:57 +0100
Date: Tue, 6 Aug 2002 10:00:57 +0100
From: Miles Sabin miles@milessabin.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote,
> We are looking for any kind of constructive critiques: Notes about
> missing, superfluous, misguided, or confusing functionality, bad
> names, failures to meet practical programming needs, and so on.
> You can post them to the list, or just mail them to me if you like.

One quick comment: where's DCAS?

Cheers,


Miles




From dl@cs.oswego.edu Tue, 6 Aug 2002 06:53:19 -0400
Date: Tue, 6 Aug 2002 06:53:19 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Miles wrote:

> One quick comment: where's DCAS?

We backed down from including the Atomic Pair classes because (1)
among the best implementions, described in recent work by Tim Harris
(http://www.cl.cam.ac.uk/~tlh20/) can be layered over regular CAS.
(2) Even for these, it is not clear when we'd recommend using them --
they typically impose greater overhead than using briefly held locks,
so are worthwhile only when you really need the wait-freedom.

Generally, we took a "when in doubt, leave it out" philosophy.  So,
for example, there is also not a non-reentrant Mutex Lock
implementation, because we think that ReentrantLock is nearly
always a better choice for routine use in Java. 


-Doug






From miles@milessabin.com Tue, 6 Aug 2002 12:13:02 +0100
Date: Tue, 6 Aug 2002 12:13:02 +0100
From: Miles Sabin miles@milessabin.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote,
> Miles wrote:
> > One quick comment: where's DCAS?
>
> We backed down from including the Atomic Pair classes because (1)
> among the best implementions, described in recent work by Tim Harris
> (http://www.cl.cam.ac.uk/~tlh20/) can be layered over regular CAS.
> (2) Even for these, it is not clear when we'd recommend using them --
> they typically impose greater overhead than using briefly held locks,
> so are worthwhile only when you really need the wait-freedom.

OK, I'm convinced ... and thanks for the pointer.

Cheers,


Miles




From Tim.Harris@cl.cam.ac.uk Tue, 06 Aug 2002 14:43:36 +0100
Date: Tue, 06 Aug 2002 14:43:36 +0100
From: Tim Harris Tim.Harris@cl.cam.ac.uk
Subject: [concurrency-interest] JSR 166 draft API

> We backed down from including the Atomic Pair classes because (1)
> among the best implementions, described in recent work by Tim Harris
> (http://www.cl.cam.ac.uk/~tlh20/) can be layered over regular CAS.
> (2) Even for these, it is not clear when we'd recommend using them --
> they typically impose greater overhead than using briefly held locks,
> so are worthwhile only when you really need the wait-freedom.

If anyone's interested, the paper itself is at

  http://www.cl.cam.ac.uk/~tlh20/papers/casn-final.ps

It describes a CASn operation as a generalization of DCAS that can act
on an arbitrary number of locations.  Of course, the concept of such
an operation is not new in itself; the contribution is a lock-free
design that's built in what I think is a comparatively straightforward
way from CAS.

I agree that this is still work in progress -- in terms of how this or
similar algorithms are best implemented, in terms of how and whether
to expose such operations through higher level interfaces and in terms
of the ultimate consequences to application-wide performance and
programming ease.

In the last few weeks I've put together an initial implementation of a
kind of "AtomicReference.DCAS" operation evaluating various memory
management schemes for the temporary data structures it uses.  Making
the design compatible with Maged Michael's SMR design (or the Repeat
Offender Problem work that Maurice Herlihy, Victor Luchangco and Mark
Moir are presenting at DISC) led to a few subtle changes to the
published design -- e.g. reversing the order of loop in phase 2 of the
algorithm.  I expect further work will lead to more changes.  We've
also got a version that in the un-contended case uses 2n+1 CAS
operations rather than 3n+1 which we've not evaluated in any depth at
all.

It would be interesting to implement a Java-level version over
AtomicReference.compareAndSwap without recourse to some of the
low-level hackery that I've used :-).

Tim





From dl@cs.oswego.edu Tue, 6 Aug 2002 10:59:43 -0400
Date: Tue, 6 Aug 2002 10:59:43 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Thanks! We also think that good names are important, and would like to
continue getting lots of suggestions about them. We might even agree
to some of them :-)

Levente Farkas wrote:

> I always prefere symmethric names (so I
> prefere unix naming convension over windows one's waitforsingleobject...):
> Lock.lock, Lock.unlock, Lock.trylock

It is not always the case in all implementation classes that a given
acquire leads to a mutually exclusive locked state (and similarly for
release). So these shorter names could be misleading when used with
ReadWriteLocks.readlocks, Semaphores, and so on.  (Yet all of these
can/do serve as locks of various kinds.)  In other words, the current
names reflect the level of abstraction of the interface.  We agree
that the Lock naming scheme as a whole could stand improvement
though. Alternatives we considered are:

  * Rename "Lock" interface as "Sync", as in dl.u.c. But "Sync" is too
    bland, (I've received a bunch of mail complaining about this)
    and the better name "SynchronizationObjectUsingAcquireRelease" 
    is too awkward.

  * Reserve the Lock interface for mutually exclusive locks, and
    rename methods. Don't declare that Semaphores, latches,
    read-locks(?), etc are Locks.  Should these others chare a different
    interface?

  * Kill the Lock interface entirely, and just have a bunch of
    unrelated classes.

None of these sound better than current scheme.

Any other suggestions?

> and similar for other functions. another think I always prefer shorter names
> (if not loose the meaning) since there is not any non-reentrant version
> ReentrantLock and ReentrantReadWriteLock can be shorter, 
> eg: Locker and ReadWriteLocker.

We do mainly stick to the convention that implementation classes have
names with a prefix that gives you a basic feel for their
implementation strategies. And we don't want to preclude supplying,
say, non-reentrant mutexes in a subsequent release.

(Note: For consistency, "BlockingPriorityQueue" will probably get a
new name once we decide on the data structure to implement it with.
Not Heaps, since we'd like to guarantee FIFOness within priorities,
which is needed in many applications of blocking priority queues (but
much less so for non-blocking ones) and which is not something that
Heaps support.)

> and if we call ConcurrentHashMap why we call LinkedBlockingQueue and 
> SynchronousQueue? 

I'm the main one to blame about name SynchronousQueue. I think the
more consistent name SymchronousBlockingQueue sounds embarassing --
anyone who knows enough to use it knows that synchronous implies
blocking --  and so worth breaking default conventions for.


-Doug




From miles@milessabin.com Tue, 6 Aug 2002 16:13:02 +0100
Date: Tue, 6 Aug 2002 16:13:02 +0100
From: Miles Sabin miles@milessabin.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote,
> (Note: For consistency, "BlockingPriorityQueue" will probably get a
> new name once we decide on the data structure to implement it with.
> Not Heaps, since we'd like to guarantee FIFOness within priorities,
> which is needed in many applications of blocking priority queues (but
> much less so for non-blocking ones) and which is not something that
> Heaps support.)

Maybe a bit specific to the pending-timed-event problem, but have you 
considered Calendar Queues?

Cheers,


Miles




From ggagne@westminstercollege.edu Tue, 6 Aug 2002 13:30:58 -0600
Date: Tue, 6 Aug 2002 13:30:58 -0600
From: Greg Gagne ggagne@westminstercollege.edu
Subject: [concurrency-interest]Atomic variables

Why not have an AtomicBoolean as well? (I realize an AtomicInteger can 
be used to achieve the same results.)

My thinking comes from the  email snippet (shown below) from David 
Holmes:

 >>>>>>>>>>>>>>
There may not be an actual spinlock class but the atomic compareAndSwap
operation will make it trivial to implement one:

class SpinLock {

   static final int LOCKED = 1;
   static final int UNLOCKED = 0;
   AtomicInteger lock = new AtomicInteger(UNLOCKED);

   public void acquire() {
       while (lock.compareAndSwap(UNLOCKED, LOCKED) == LOCKED)
           ; // spin
   }

   public void release() {
       lock.set(UNLOCKED);
   }

}
<<<<<<<<<<<<<<

The above could now appear as:

class SpinLock
{
AtomicBoolean lock = new AtomicBoolean(false);

	public void acquire() {
		while (lock.getAndSet(true))
			; //spin
	}

	public void release() {
		lock.set(true);
	}
}


My thinking is that an AtomicBoolean resembles the types we see in  Java 
primitives.

cheers -

//greg





From dholmes@dltech.com.au Wed, 7 Aug 2002 09:42:50 +1000
Date: Wed, 7 Aug 2002 09:42:50 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Atomic variables

> Why not have an AtomicBoolean as well? (I realize an AtomicInteger can
> be used to achieve the same results.)

The rationale here was that in practice atomic operations can not be applied
to memory locations smaller than the word size. Hence no atomic byte or
short or char or boolean. Although such things could be mapped onto
AtomicInteger we didn't want to give the false impression that somehow an
AtomicBoolean consumed less memory than an AtomicInteger.

David Holmes





From mario@ifad.dk Wed, 7 Aug 2002 09:49:38 +0200
Date: Wed, 7 Aug 2002 09:49:38 +0200
From: Mario Juric mario@ifad.dk
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:

> ...we don't want to preclude supplying,
> say, non-reentrant mutexes in a subsequent release.

I think its a shame that non-reentrant mutexes are excluded from the first
release, because I really use them in a case where the lock is not released
by the same thread that has acquired it. This might seem a bit strange why
one would want this but it makes perfect sense in my case. However, I would
either have to keep using the current library or just include the parts that
I need or I will have to figure out an alternative solution to my problem
using the "new" library. I think none is really a big issue in my case but I
believe that it shows that there potentially will be others that eventually
will request non-reentrant mutexes. Even though they are less used I believe
they have their application areas, so why not include it from the beginning
when the current library allready provides it?

Best regards
Mario Juric

---
Mario Juric, M.Sc. CS, MUSTER Product Manager
IFAD, Forskerparken 10, DK - 5230 Odense M
Phone: +45 63 15 71 31 Fax: +45 65 93 29 99
www: www.ifad.dk e-mail: mario.juric@ifad.dk
---





From dholmes@dltech.com.au Thu, 8 Aug 2002 08:28:01 +1000
Date: Thu, 8 Aug 2002 08:28:01 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] JSR 166 draft API

Mario Juric wrote:
> I think its a shame that non-reentrant mutexes are excluded from the first
> release, because I really use them in a case where the lock is
> not released by the same thread that has acquired it.

I'm afraid that this has nothing to do with the lock being reentrant or not.

The only reason you can release a mutex from another thread is purely and
simply that the currentThread test was so expensive back then that Doug
omitted the check for ownership of the mutex for performance reasons.

A lock should only ever be released by the thread that owns it - this is the
key distinction between locks/mutexes and semaphores. A semaphore is
designed to have acquire/release (p/v) invoked from different threads - if
you use the convention of only doing acquire/release as a pair within any
given thread then a binary semaphore can be used as a lock. Locks on the
other hand should only be used this way and many systems prevent you from
doing otherwise or leave the results undefined.

My understanding is that the ownership check will be put in place for the
mutex class(es) whether reentrant or not.

If you want to release the "lock" from another thread then use a semaphore.

David Holmes





From crahen@cse.Buffalo.EDU Wed, 7 Aug 2002 19:43:57 -0400 (EDT)
Date: Wed, 7 Aug 2002 19:43:57 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] JSR 166 draft API

Hi, thought I'd give you some feedback. I really like everything in this
package and appriciate the amount of work that gone into it. So thanks to
the JSR 166 people.


Name comments:


I like the naming convention used in the Lock interface. It seems more
natual to use acquire/release if you view locks as a resource & it lines
up nicely with alot of thread literature about acquire/release protocols
for various things.

I think ThreadPool is better off being named PoolExecutor. Executors
are objects designed to decouple tasks from threads, and the way I look at
the ThreadPool class described in the API is as an Executor that uses a
set of threads (or a thread pool) to run submitted tasks. To me it seems
more natural to describe this as a PoolExecutor that has or uses a
ThreadPool; it seems more descriptive of whats really going on.

The Thread class now has clearThreadLocals() and ThreadLocal now has
remove(), it might make sense to name the ThreadLocal method clear()
instead of remove, or maybe name the the Thread method
removeThreadLocals() just to keep it a little more consistent.

The CopyOnWrite classes have the word Array in thier names, but the
CopyOnWriteArraySet really doesn't have indexed access if its a Set right?
It seems like the word Array in there is a little off. The
CopyOnWriteArrayList makes more sense, but its not really directly
related to the ArrayList class (plus its also marked by implementing the
RandomAccess interface which implies it would probably be using some kind
of array internally to provide constant time random access). I realize
these classes use arrays internally, but maybe just CopyOnWriteList &
CopyOnWriteSet are more appropriate given the interfaces the classes
implement.


Interface comments:


In the CyclicBarrier class, is it really useful to know the arrival
index of the thread (the return value of sync())? It seems more like
an implementation detail, rather than something a client might actually
want to know since a barrier is generally for all-or-none. Maybe just
a void would be better, the function would succeed or fail with exception.

Is it possible make the ConcurrentHashMap more of an adapter or wrapper
for existing HashMaps? I'm just thinking that it might be desirable to
have something like this that could be used with the regular HashMap or
with the new LinkedHashMap in the 1.4.0 SDK.


Other comments:


Why not include a couple more Executor classes to help enrich the Executor
hierarchy? I think it would be good to have at least a single threaded
Executor & possibly the Locked or ThreadedExecutor. Fitting that in right
with the ThreadPool.Intercepts class may be why those got left out. This
is the first time I've seen that class, so I have to think about that one
some more to digest it. My first impression of it is that seems somewhat
awkward. Maybe there is a better way to incorporate that some
of that functionality into the API (like beforeExecute, afterExecute, etc)
without tying it to a ThreadPool. It definently seems like that
class describes features all kinds of Executors would want to use.

* On a related note, I wrote about an Executor pattern for VikingPLoP this
  year (inspired by this package). I've almost completed the sheparding
  process, but once I make a few more of the revisions I'll post a link
  to it here - I think it might be interesting for the audience of this
  mailing list, and I might get some good feedback from you guys ;-)

There is an interface for general acquire/release semantics, the Lock
interface (is Lockable better a name? Resources I can acquire and release
might not be locks, but they are Lockable in some sense?). Would it be
useful to have an interface for general wait semantics? For example,
something like,

interface Waitable {

  public void await();

  public boolean await(long time, java.lang.Clock granularity);

  public void awaitUninterruptibly();

}

and Condition's, Barriers & Futures might be the things that implement
this interface. Each of them wait differently for different reasons, but I
don't think its any different than how ReentrantLocks and Semaphores
acquire & release differently.


I might have missed comments about this, I get the digest of this list
and only scanned through it because I wanted to check out the API and
send some feedback, but where did the Mutex class go? I thought there
used to be one, it seems like it should be there, especially there is a
ReentrantLock (Maybe RecursiveMutex would be better if there was a Mutex).



- Eric
http://www.cse.buffalo.edu/~crahen






From dholmes@dltech.com.au Thu, 8 Aug 2002 10:34:31 +1000
Date: Thu, 8 Aug 2002 10:34:31 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] JSR 166 draft API

Hello Eric,

Thanks for the feedback.

I have a couple of immediate responses.

> The Thread class now has clearThreadLocals() and ThreadLocal now has
> remove(), it might make sense to name the ThreadLocal method clear()
> instead of remove, or maybe name the the Thread method
> removeThreadLocals() just to keep it a little more consistent.

There is a distinction here between clear and remove. Clearing a threadlocal
makes the value of that threadlocal null for that thread. Removing a
threadlocal removes it for all threads. These two are quite different so
different terms are used to avoid confusion.

> The CopyOnWrite classes have the word Array in thier names, but the
> CopyOnWriteArraySet really doesn't have indexed access if its a Set right?
> It seems like the word Array in there is a little off.

Part of the naming convention, as with the java.util collections is to
include the implementation type as part of the name. This could give you
some indication regarding the potential performance characteristics of
operations. Further it leaves the way open for other implementations.

> In the CyclicBarrier class, is it really useful to know the arrival
> index of the thread (the return value of sync())? It seems more like
> an implementation detail, rather than something a client might actually
> want to know since a barrier is generally for all-or-none. Maybe just
> a void would be better, the function would succeed or fail with exception.

Often when using a barrier, after the barrier has been tripped you need to
do some special processing. Only one thread needs to do that processing but
all threads are executing the same piece of code. By returning the index you
allow threads to discriminate in their actions. You can then arbitrarily
pick a thread to execute the once-only action based on its index.

> Why not include a couple more Executor classes to help enrich the Executor
> hierarchy? I think it would be good to have at least a single threaded
> Executor & possibly the Locked or ThreadedExecutor. Fitting that in right
> with the ThreadPool.Intercepts class may be why those got left out.

Most of the variants of executors reduce to a threadpool with some specific
properties - the properties fully controllable by the Intercepts class. The
pendulum has swung from having separate classes through to having a single
implementation class and some factory methods, but may be swinging back
again. Feedback like this may help push that pendulum :)

> There is an interface for general acquire/release semantics, the Lock
> interface (is Lockable better a name?)

Adjective based interface names like Comparable, Sortable, Cloneable,
Lockable to me imply a property of the object: it can be compared, it can be
sorted, it can be cloned etc.

Noun based interface names like Lock, Map, List tell me that an object *is*
something. I use this object as a Map, as a List, as a Lock etc.

So I think Lock is the right name here.

> Would it be useful to have an interface for general wait semantics? For
> example, something like,
>
> interface Waitable {
>   public void await();
>   public boolean await(long time, java.lang.Clock granularity);
>   public void awaitUninterruptibly();
> }
>
> and Condition's, Barriers & Futures might be the things that implement
> this interface.

Things that share a common interface should in some way be interchangable
(not completely arbitrarily of course, but there should be some degree of
interchangability). Locks and Read/write locks and semaphores have that
property - conditions and barriers do not. They are so different in
functionality that having a common interface would, I think, be misleading.

> send some feedback, but where did the Mutex class go? I thought there
> used to be one, it seems like it should be there, especially there is a
> ReentrantLock (Maybe RecursiveMutex would be better if there was a Mutex).

Mutex was a non-reentrant lock class. The current thinking is that having a
non-reentrant lock class is needed so very rarely that it is not worth
having. A distinction is being made between needing a non-reentrant lock
versus never exercising the reentrancy portion of a reentrant lock ie. would
your code be broken if a reentrant lock was used instead? The general answer
is no because the only difference between a non-reentrant lock and a
re-entrant lock that is only used non-reentrantly, is in the erroneous
circumstance where you do in fact attempt to use the lock reentrantly.

Of course, there are many that argue that locks should be non-reentrant only
and that any situation that needs a reentrant lock reflects a broken design.
Such people tend to program in C not an OO language. In concurrent OO
languages reentrancy makes live a lot simpler - it's not essential but it
makes things simpler.

David Holmes





From crahen@cse.Buffalo.EDU Wed, 7 Aug 2002 21:57:23 -0400 (EDT)
Date: Wed, 7 Aug 2002 21:57:23 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]RE: RE :RE:  JSR 166 draft API (David Holmes)

Hi Dave,

Thanks for the quick response.

I didn't realize the difference in the clearThreadLocals() & remove()
methods. Thanks for pointing that out.

> Often when using a barrier, after the barrier has been tripped you need
> to do some special processing. Only one thread needs to do that
> processing but all threads are executing the same piece of code. By
> returning the index you allow threads to discriminate in their actions.

To do this right, wouldn't each thread need to know its identity when
going in? I'm just thinking that a task may want to pick up doing the
same thing it was doing when it went in, and if they don't know thier
number going in (or can't assign thier own), coming they might take the
wrong paths and end up switching some context information that may be
stored in thread locals.

It might depend on how you use the Barrier I guess. What I would tend to
do is give two different task objects a reference to the barrier to wait
on if thier chores were different.

> You can then arbitrarily pick a thread to execute the once-only action
> based on its index.

Isn't there a Runnable that can be associated in one of the constructors
for this?

> Things that share a common interface should in some way be
> interchangable (not completely arbitrarily of course, but there should
> be some degree of interchangability). Locks and Read/write locks and
> semaphores have that property - conditions and barriers do not. They are
> so different in functionality that having a common interface would, I
> think, be misleading.

It seems like it could be useful to return Waitable objects (tokens to
wait for values to be calculateed, or for conditions to occur, or other
things), or to build of queue of things that need waiting.
It doesn't seem any less interchangeable than semaphores and recursive
locks, though. They really only share the general usage protocol, and that
seems to be what that Lock interface really reflect best. I think a
Waitable does the same for blocking operations. I do understand your
point of view, though.

> Most of the variants of executors reduce to a threadpool with some
> specific properties - the properties fully controllable by the
> Intercepts class. The pendulum has swung from having separate classes
> through to having a single implementation class and some factory
> methods, but may be swinging back again. Feedback like this may help
> push that pendulum :)

I'll try to finish the revision I was supposed to be making this week on
that pattern, maybe it will be helpful :)

> Mutex was a non-reentrant lock class. The current thinking is that
> having a non-reentrant lock class is needed so very rarely that it is
> not worth having. A distinction is being made between needing a
> non-reentrant lock versus never exercising the reentrancy portion of a
> reentrant lock ie. would your code be broken if a reentrant lock was
> used instead? The general answer is no because the only difference
> between a non-reentrant lock and a re-entrant lock that is only used
> non-reentrantly, is in the erroneous circumstance where you do in fact
> attempt to use the lock reentrantly.

I hadn't thought about it like that; I just was instinctively reaching for
a Mutex. I work with other languages as well, and the first things I
usually look for are the threads & mutexes. What you are saying is
probably simpler.

> Of course, there are many that argue that locks should be non-reentrant
> only and that any situation that needs a reentrant lock reflects a
> broken design. Such people tend to program in C not an OO language. In
> concurrent OO languages reentrancy makes live a lot simpler - it's not
> essential but it makes things simpler.

I'm an OO programmer, but I think there are alot of times that using
non-recursive locks can be helpful in ironing out an cleaner design. Its
not always the case that recursive locks make bad designs, but sometimes
its a good hint that something should be refactored. That's just my
experience though. If the performance is the same for recursive
and non-recursive Locks, then it might be enough to just include
the recursive one.

> Adjective based interface names like Comparable, Sortable, Cloneable,
> Lockable to me imply a property of the object: it can be compared, it
> can be sorted, it can be cloned etc.
>
> Noun based interface names like Lock, Map, List tell me that an object
> *is* something. I use this object as a Map, as a List, as a Lock etc.

This is the same logic I was using except that I looked at it as a thing
that can be locked, rather then as a Lock. Its usually called Lockable in
Doug Schmitts (probably spelled that wrong) papers; thats where I first
began reading about concurrency patterns and might be why I'm looking that
way.


- Eric
http://www.cse.buffalo.edu/~crahen






From dholmes@dltech.com.au Thu, 8 Aug 2002 12:30:22 +1000
Date: Thu, 8 Aug 2002 12:30:22 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]RE: RE :RE:  JSR 166 draft API (David Holmes)

> > Often when using a barrier, after the barrier has been tripped you need
> > to do some special processing. Only one thread needs to do that
> > processing but all threads are executing the same piece of code. By
> > returning the index you allow threads to discriminate in their actions.
>
> To do this right, wouldn't each thread need to know its identity when
> going in?

The usage scenario is much simpler than what you seem to be considering.
Basically you have a whole bunch of worker threads executing the same code
which includes a barrier:

     // phase 1 processing
     barrier.sync();  // wait for everyone to complete phase 1
     // phase 2 processing

But sometimes once the barrier has tripped you want to do something - maybe
log a message - that only one thread should do. You could do this with a
shared flag and a lock but it's much simpler to do:

     // phase 1 processing
     if (barrier.sync() == 0) {
	Logger.log("phase 1 complete"); // only one thread will do this
     }
     // phase 2 processing

The choice of 0 in this case is arbitrary any number would do. But sometimes
you might want to know the actual order that threads got to the barrier.

I hadn't noticed the barrierAction runnable that can be set. I'll have to
defer to Doug as to why both techniques warrant support.

> It seems like it could be useful to return Waitable objects (tokens to
> wait for values to be calculateed, or for conditions to occur, or other
> things), or to build of queue of things that need waiting.

I can see a use of a queue of futures. But a queue of conditions or barriers
or a queue that mixes them together ?? Sorry but I just can't see any
utility in that. Other than potentially needing to wait before they complete
(a socket read may do that too ;-) ), the operations on these things have
nothing in common.

> It doesn't seem any less interchangeable than semaphores and recursive
> locks, though.

A binary semaphore can be used in place of a recursive lock that is not used
recursively. I agree that there is a stretch between semaphores and locks
but just sometimes you might want to use a semaphore as a lock, and so
sharing the same interface makes sense.

> > Adjective based interface names like Comparable, Sortable, Cloneable,
> > Lockable to me imply a property of the object: it can be compared, it
> > can be sorted, it can be cloned etc.
> >
> > Noun based interface names like Lock, Map, List tell me that an object
> > *is* something. I use this object as a Map, as a List, as a Lock etc.
>
> This is the same logic I was using except that I looked at it as a thing
> that can be locked, rather then as a Lock. Its usually called Lockable in
> Doug Schmitts (probably spelled that wrong) papers; thats where I first
> began reading about concurrency patterns and might be why I'm looking that
> way.

Well Doug Schmidt doesn't always get these things right :-) But there is a
difference between a Lock and a Lockable and I'm not sure of the context
Doug uses Lockable. I say that ReentrantLock and ReadWriteLock and Mutex and
Semaphore and ... *are* types of locks - you use them to restrict access to
other things. A Lockable is an object that *can* be locked. Barrel and
deadbolts are Locks - doors and windows are Lockable. You see the
difference? I might declare thread-safe containers as Lockable and they'd
probably provide a getLock() method.

Cheers,
David Holmes





From crahen@cse.Buffalo.EDU Wed, 7 Aug 2002 23:02:24 -0400 (EDT)
Date: Wed, 7 Aug 2002 23:02:24 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]RE: RE :RE:  JSR 166 draft API (David
 Holmes)

On Thu, 8 Aug 2002, David Holmes wrote:

> But there is a difference between a Lock and a Lockable and I'm not sure
> of the context Doug uses Lockable.

Its been a while since I've read his papers, I've probably got a slightly
different interpretation than he does.

> I say that ReentrantLock and ReadWriteLock and Mutex and
> Semaphore and ... *are* types of locks - you use them to restrict access
> to other things.
>
> Barrel and deadbolts are Locks - doors and windows are Lockable. You see
> the difference? I might declare thread-safe containers as Lockable and
> they'd probably provide a getLock() method.

Hmmm, I see what your saying.

I think of a pad lock, like one you'd put on a bike. Its a lock, and I
lock on unlock it. Its lockable because I'm locking and unlock it. My
bike is just a bike, I protect it with a lock, but its not really
lockable [now I protect it by letting it collect dust in the basement :)]
I look at the machine that does the locking & unlocking as the thing that
really is a lockable since thats where the locking is going on. You know
what I mean? Why can I lock and unlock that pad lock? Because its lockable.

I'm not trying to nit-pick or anything, I do see how your view of it
works and I can live with your interpretation :-)

- Eric
http://www.cse.buffalo.edu/~crahen





From crahen@cse.Buffalo.EDU Wed, 7 Aug 2002 23:26:42 -0400 (EDT)
Date: Wed, 7 Aug 2002 23:26:42 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API (David
 Holmes)

Is the Condition class now less like a POSIX condition variable and more
like an abstraction for a monitor? It just adding the ability to wait
uninterruptably or will there be subclasses that sort waiter lists or
something along those lines?


- Eric
http://www.cse.buffalo.edu/~crahen





From dholmes@dltech.com.au Thu, 8 Aug 2002 14:01:38 +1000
Date: Thu, 8 Aug 2002 14:01:38 +1000
From: David Holmes dholmes@dltech.com.au
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API (David Holmes)

> Is the Condition class now less like a POSIX condition variable and more
> like an abstraction for a monitor? It just adding the ability to wait
> uninterruptably or will there be subclasses that sort waiter lists or
> something along those lines?

I'm not sure what you mean by this last part but the Condition class is used
to provide the effect of multiple condition/wait queues per monitor.

To use a classic example of the BoundedBuffer:

  public class BoundedBuffer {
      Condition notFull = new Condition(this);
      Condition notEmpty = new Condition(this);

      int size = 0;
      final int CAPACITY = 10;

      public synchronized void put(Object o) {
          while (size == CAPACITY)
              notFull.await();

          // store o
          size++;
          notEmpty.signalAll();
     }

     public synchronized Object get() {
         while (size ==0)
             notEmpty.await();
         size--;
         Object temp = ... // remove
         notFull.signalAll();
         return temp;
     }
}

Condition also allows uninterruptible waiting and timedwaits that don't
require you to jump through hoops to see if you timed out.

The order in which waiting threads are signalled is not specified - as per
Object.wait().

A Condition class with ordering guarantees would have to use a "specific
notification" style approach.

David Holmes





From jerry.schwarz@oracle.com Wed, 07 Aug 2002 22:45:39 -0700
Date: Wed, 07 Aug 2002 22:45:39 -0700
From: Jerry Schwarz jerry.schwarz@oracle.com
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API
 (David Holmes)

At 09:01 PM 8/7/2002, David Holmes wrote:
> > Is the Condition class now less like a POSIX condition variable and more
> > like an abstraction for a monitor? It just adding the ability to wait
> > uninterruptably or will there be subclasses that sort waiter lists or
> > something along those lines?
>
>I'm not sure what you mean by this last part but the Condition class is used
>to provide the effect of multiple condition/wait queues per monitor.
>
>To use a classic example of the BoundedBuffer:
>
>   public class BoundedBuffer {
>       Condition notFull = new Condition(this);
>       Condition notEmpty = new Condition(this);
>
>       int size = 0;
>       final int CAPACITY = 10;
>
>       public synchronized void put(Object o) {
>           while (size == CAPACITY)
>               notFull.await();
>
>           // store o
>           size++;
>           notEmpty.signalAll();
>      }
>
>      public synchronized Object get() {
>          while (size ==0)
>              notEmpty.await();
>          size--;
>          Object temp = ... // remove
>          notFull.signalAll();
>          return temp;
>      }
>}

Is notFull.await() releasing the synchronization lock on "this"?  If not, 
then no other Thread could execute get, and there would be a deadlock.  And 
you obviously can get rid of the synchronization without creating 
races.  I'm sure you can clean this up, but by the time you do I suspect it 
will be complicated enough that you would be better off using some 
alternative to Condition's.


>Condition also allows uninterruptible waiting and timedwaits that don't
>require you to jump through hoops to see if you timed out.
>
>The order in which waiting threads are signalled is not specified - as per
>Object.wait().
>
>A Condition class with ordering guarantees would have to use a "specific
>notification" style approach.
>
>David Holmes
>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From jerry.schwarz@oracle.com Wed, 07 Aug 2002 23:13:44 -0700
Date: Wed, 07 Aug 2002 23:13:44 -0700
From: Jerry Schwarz jerry.schwarz@oracle.com
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API
 (David Holmes)

At 10:45 PM 8/7/2002, Jerry Schwarz wrote:
>At 09:01 PM 8/7/2002, David Holmes wrote:
>> > Is the Condition class now less like a POSIX condition variable and more
>> > like an abstraction for a monitor? It just adding the ability to wait
>> > uninterruptably or will there be subclasses that sort waiter lists or
>> > something along those lines?
>>
>>I'm not sure what you mean by this last part but the Condition class is used
>>to provide the effect of multiple condition/wait queues per monitor.
>>
>>To use a classic example of the BoundedBuffer:
>>
>>   public class BoundedBuffer {
>>       Condition notFull = new Condition(this);
>>       Condition notEmpty = new Condition(this);
>>
>>       int size = 0;
>>       final int CAPACITY = 10;
>>
>>       public synchronized void put(Object o) {
>>           while (size == CAPACITY)
>>               notFull.await();
>>
>>           // store o
>>           size++;
>>           notEmpty.signalAll();
>>      }
>>
>>      public synchronized Object get() {
>>          while (size ==0)
>>              notEmpty.await();
>>          size--;
>>          Object temp = ... // remove
>>          notFull.signalAll();
>>          return temp;
>>      }
>>}
>
>Is notFull.await() releasing the synchronization lock on "this"?  If not, 
>then no other Thread could execute get, and there would be a 
>deadlock.  And you obviously can get rid of the

I meant "cannot get rid" in the above.

>synchronization without creating races.  I'm sure you can clean this up, 
>but by the time you do I suspect it will be complicated enough that you 
>would be better off using some alternative to Condition's.
>
>
>>Condition also allows uninterruptible waiting and timedwaits that don't
>>require you to jump through hoops to see if you timed out.
>>
>>The order in which waiting threads are signalled is not specified - as per
>>Object.wait().
>>
>>A Condition class with ordering guarantees would have to use a "specific
>>notification" style approach.
>>
>>David Holmes
>>
>>
>>_______________________________________________
>>Concurrency-interest mailing list
>>Concurrency-interest@altair.cs.oswego.edu
>>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From dholmes@dltech.com.au Thu, 8 Aug 2002 16:07:21 +1000
Date: Thu, 8 Aug 2002 16:07:21 +1000
From: David Holmes dholmes@dltech.com.au
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API  (David Holmes)

> Is notFull.await() releasing the synchronization lock on "this"?

Yes it is. That is what Conditions provide. You bind a condition to another
Java object - when you do an await() on the condition it atomically releases
the lock of its bound object and performs a "wait" then requires the bound
objects lock after a signal/signalAll.

> you obviously can get rid of the synchronization without creating
> races.  I'm sure you can clean this up, but by the time you do I
> suspect it
> will be complicated enough that you would be better off using some
> alternative to Condition's.

Sorry Jerry but you've completely lost me there - what are you concerned
about??

David Holmes





From crahen@cse.Buffalo.EDU Thu, 8 Aug 2002 06:46:49 -0400 (EDT)
Date: Thu, 8 Aug 2002 06:46:49 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API (David
 Holmes)

On Thu, 8 Aug 2002, David Holmes wrote:

> I'm not sure what you mean by this last part but the Condition class is
> used to provide the effect of multiple condition/wait queues per
> monitor.

I am far from a POSIX zealot, but I think most people tend to think of
POSIX condition variables (cv) when they think of Conditions (and that was
how the class was originally described, wasn't it?). The majority of
thread APIs (in other languages) also tend to make you use a mutex with
a cv. Alot of texts describe cv's this way too. Since the new Condition
classes doesn't explicity work with Locks, it struck me as a little odd at
first. That's why I asked if it was less POSIX-like. But I see the usage
ends exactly the same as its previous incarnation.

Some people might make the case that you should never use recursive locks
with condition variables, though. This can make code using Conditions less
error prone. This might be subjective though, no matter what interface
you provide, people find ways to use it wrong :)

Does the Condition have suprious wakeups?

> Condition also allows uninterruptible waiting and timedwaits that don't
> require you to jump through hoops to see if you timed out.

I noticed there is a Locks utility class with an uninteruptible acquire;
Would it be good to have some similar utility to do uninteruptible waits
for Conditions, Futures and the rest to for consistency? I think it was
probably done this way for efficency, so would it be more efficent to do
the same for the Lock classes as well (make unteruptible acquires part of
thier interface?)

> The order in which waiting threads are signalled is not specified - as per
> Object.wait().

> A Condition class with ordering guarantees would have to use a "specific
> notification" style approach.

Why not allow Condition to take a Lock object instead of synchronizing on
any object? Minimally, using a Lock would give you the ability to at least
use the RecursiveLock with the Condition. That would definently be useful.

Perhaps a Condition could look at the Lock its given, if its a
RecursiveLock it could delegate to an implementation that uses the faster
Object.wait() ordering, and if its anything else it could delegate to
something that uses a specific notification style?

If making Locks work with Conditions is something that people feel they
would like, its probably worth while to include Mutex as an interface, or
something that would distinguish Locks that can be used with cv's
(ones that have owners & the right semantics) from ones that can't (for
instance, RecursiveLock could be used - but not a Semaphore or a Latch)

In Doug Leas book, he had described some classes (FIFOSempahore I think
was one) that allows you to vary to order of the the waiters. While
FIFOLock might be better for use with a cv, that seemed like a
useful idea, and it seemed like there might be times when it could be good
to have the possibility to use locks that might have priority sensative
waiter lists or other ways to order waiters.

Are there any changes in the new API related to priorities at all?

- Eric
http://www.cse.buffalo.edu/~crahen


BTW, I apologize to everyone for screwing up the threads with the
message titles. My mailreader is mailinglist challanged :)






From crahen@cse.Buffalo.EDU Thu, 8 Aug 2002 09:50:17 -0400 (EDT)
Date: Thu, 8 Aug 2002 09:50:17 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: # [concurrency-interest]RE: RE :RE: JSR 166 draft API (David
 Holmes)

At 10:45 PM 8/7/2002, Jerry Schwarz wrote:
>At 09:01 PM 8/7/2002, David Holmes wrote:
>> > Is the Condition class now less like a POSIX condition variable and
more
>> > like an abstraction for a monitor? It just adding the ability to wait
>> > uninterruptably or will there be subclasses that sort waiter lists or
>> > something along those lines?
>>
>>I'm not sure what you mean by this last part but the Condition class is
used
>>to provide the effect of multiple condition/wait queues per monitor.
>>
>>To use a classic example of the BoundedBuffer:
>>
>>   public class BoundedBuffer {
>>       Condition notFull = new Condition(this);
>>       Condition notEmpty = new Condition(this);
>>
>>       int size = 0;
>>       final int CAPACITY = 10;
>>
>>       public synchronized void put(Object o) {
>>           while (size == CAPACITY)
>>               notFull.await();
>>
>>           // store o
>>           size++;
>>           notEmpty.signalAll();
>>      }
>>
>>      public synchronized Object get() {
>>          while (size ==0)
>>              notEmpty.await();
>>          size--;
>>          Object temp = ... // remove
>>          notFull.signalAll();
>>          return temp;
>>      }
>>}
>
>Is notFull.await() releasing the synchronization lock on "this"?  If not,
>then no other Thread could execute get, and there would be a
>deadlock.

That's what it is supposed to do. It seems wierd when you first look at it
because there is normally no way to release a monitors lock other than leaving
the synchronized block. Now that I think about it, it seems unnatural to
me. The more I think about this, the more it seems to throw me.

How is the Condition implemented? Is the wait performed by waiting on the
monitor of the lock passed to the constructor (that what I initaily thought, which would
make it seem more like a Monitor wrapper)?

Or does it wait on some other object within the condition, releasing and
acquiring the monitor on the lock object. (Maybe the compiler generates
the bytecode that releases & acquires the lock on the lock object, or maybe is
it is done through JNI)

Is there a reference implementation we could see?

- Eric
http://www.cse.buffalo.edu/~crahen





From jerry.schwarz@oracle.com Thu, 08 Aug 2002 09:36:13 -0700
Date: Thu, 08 Aug 2002 09:36:13 -0700
From: Jerry Schwarz jerry.schwarz@oracle.com
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API
 (David Holmes)

At 11:07 PM 8/7/2002, David Holmes wrote:

Sorry. I had misread the description of Condition.

> > Is notFull.await() releasing the synchronization lock on "this"?
>
>Yes it is. That is what Conditions provide. You bind a condition to another
>Java object - when you do an await() on the condition it atomically releases
>the lock of its bound object and performs a "wait" then requires the bound
>objects lock after a signal/signalAll.
>
> > you obviously can get rid of the synchronization without creating
> > races.  I'm sure you can clean this up, but by the time you do I
> > suspect it
> > will be complicated enough that you would be better off using some
> > alternative to Condition's.
>
>Sorry Jerry but you've completely lost me there - what are you concerned
>about??
>
>David Holmes
>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From yuri.gadow@ieee.org 08 Aug 2002 11:54:46 -0600
Date: 08 Aug 2002 11:54:46 -0600
From: Yuri Gadow yuri.gadow@ieee.org
Subject: [concurrency-interest] JSR 166 draft API

I'm curious why an implementation similar to
java.util.Collections.synchronizedXXX (where XXX is one of the varius
Java2 collections interfaces) is not provided to facilitate the use of
collection implementations with java.util.concurrent.Lock and/or
.....ReadWriteLock? 

Doing these sorts of wrappers is simple, but error prone, and a bit
beyond those with limited concurrency or collections experience. The
ConcurrentHashMap is nice, but of little use if some other Map
implementation is needed. 

Granted the inner class approach of Collections.synchronizedXXX is not
optimal, but that's a different debate... 


Thanks, 

Yuri Gadow 

On Mon, 2002-08-05 at 17:24, Doug Lea wrote: 
> 
> Dear concurrency-interest list subscribers,
> 
> We in the JSR 166 expert group have reached a point of tentative
> agreement (modulo a few issues) on APIs.  We invite you to take a look
> at them and tell us what you think. (In fact, we DEMAND that you do
> so. Otherwise you have no reason to be on this mailing list :-)
> 
> The APIs are not yet anywhere near fully specified. Our next step is
> to nail these down rigorously, but we want to check general reaction
> before doing so (without yet going through the formalities of JCP JSR
> reviews).  At the moment, javadocs include only enough details for us
> in the EG to figure out what they mean. Hopefully you will too. Most
> planned implementations are based on those in my dl.util.concurrent
> package, most of which have better documentation than we currently
> have for JSR 166 versions.
> 
> We are looking for any kind of constructive critiques: Notes about
> missing, superfluous, misguided, or confusing functionality, bad
> names, failures to meet practical programming needs, and so on.
> You can post them to the list, or just mail them to me if you like.
> 
> A brief introduction to JSR 166 features (that also serves as the draft
> java.util.concurrent package documentation) is at
>   http://gee.cs.oswego.edu/dl/concurrent/intro.html
> The Javadocs are at:
>   http://gee.cs.oswego.edu/dl/concurrent/index.html
> You might also find (barely) useful some UML diagrams automatically
> generated by TogetherJ. For java.util.concurrent:
>   http://gee.cs.oswego.edu/dl/concurrent/concurrent.gif
> Also for the added/changed parts of java.util:
>   http://gee.cs.oswego.edu/dl/concurrent/util.gif
> 
> Thanks very much for helping us out!
> 
> -- 
> Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
> dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






From davek@wrq.com Thu, 8 Aug 2002 12:44:44 -0700
Date: Thu, 8 Aug 2002 12:44:44 -0700
From: Dave Kriewall davek@wrq.com
Subject: [concurrency-interest]deadlock detection

When the only locking construct I used was Java synchronization, I could
determine from a JVM thread dump if a deadlock situation existed (if the JVM
was in a good mood and produced the monitor cache dump, that is! -- usually
only worked with classic VM, never in production with HotSpot).  

But once I started using the old concurrent package's
WriterPreferenceReadWriteLocks, a deadlock became harder to identify because
locks became "logical" from a VM point of view.  The thread dump would show
a thread waiting to acquire a WriterPreferenceReadWriteLock, but I couldn't
tell what thread owned it as the ActiveWriter.  In order to detect
deadlocks, I had to modify the class to allow me to access the ActiveWriter,
add a weak reference hashmap containing all the ReadWriteLocks, and write
some debugging code to log all the ActiveWriters of all the ReadWriteLocks.

Is there any provision in the new package for determining deadlocks?  (I
didn't see it.)  Is there any plan to integrate information in this package
with the JVM thread dump capability, so that one could inspect the thread
dump and see which threads are waiting to acquire ReadWriteLock objects and
which own ReadWriteLocks?  If not, it would be very helpful to add an
accessor method to the Lock interface that returns the owning thread so we
can do it on our own.

There's a consolidated/new JDC feature request
(http://developer.java.sun.com/developer/bugParade/bugs/4593133.html) that
will allow programmatic access to stack information.  It would be great to
have this also aware of java.lang.concurrent.Lock and treat ownership of the
Lock the same as ownership of a monitor, as far as the monitor cache dump
output is concerned.

-Dave




From larryr@saturn.sdsu.edu 8 Aug 2002 21:57:01 -0000
Date: 8 Aug 2002 21:57:01 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] JSR 166 draft API

> > Why not include a couple more Executor classes to help
> > enrich the Executor hierarchy? I think it would be good to
> > have at least a single threaded Executor & possibly the
> > Locked or ThreadedExecutor. Fitting that in right with the
> > ThreadPool.Intercepts class may be why those got left out.
> 
> Most of the variants of executors reduce to a threadpool with
> some specific properties - the properties fully controllable by
> the Intercepts class. The pendulum has swung from having separate
> classes through to having a single implementation class and some
> factory methods, but may be swinging back again. Feedback like this
> may help push that pendulum :)

Just as a data point, I personally prefer apparent structural
complexity to apparent behavioral complexity, and I think in
this kind of case that may be manifested as a preference for
having 3 classes for 3 different behaviors instead of one
class which I can use 3 ways to (indirectly) get 3 behaviors.


> > Barrel and deadbolts are Locks - doors and windows are Lockable. You
> > see the difference? I might declare thread-safe containers as
> > Lockable and they'd probably provide a getLock() method.
> 
> Hmmm, I see what your saying.
> 
> I think of a pad lock, like one you'd put on a bike. Its a lock, and
> I lock on unlock it. Its lockable because I'm locking and unlock
> it. My bike is just a bike, I protect it with a lock, but its not
> really lockable [now I protect it by letting it collect dust in the
> basement :)] I look at the machine that does the locking & unlocking
> as the thing that really is a lockable since thats where the locking
> is going on. You know what I mean? Why can I lock and unlock that
> pad lock? Because its lockable.

Again, just as a data point, I tend to prefer interfaces in Java
expressed as describing behavior which can be exhibited by an object
rather than a description of the what the object is, so I tend to
prefer interface names like Externalizable, Serializable, Cloneable,
Comparable, Runnable, Throwable, Observable, Scrollable, etc.  I
feel in Java it makes more sense to use abstract (or concrete)
classes to describe what something is, because Java only supports
single inheritance of implementation.

In the specific case of the proposed "java.util.concurrent.Lock",
the operations "acquire" and "release" do not fit with my idea of
locking a door or window or car or bicycle.  I would say "lock the
car", but not "acquire the car", or "acquire the lock for the car".

If the operations were "lock" and "unlock", then it would feel
natural to me to have those in an interface "Lockable", and to have a
class Car implements Lockable, whose methods "lock" and "unlock" are
implemented by using a Lock field, which may be an instance of an
object whose class extends the abstract Lock class.


Larry





From dholmes@dltech.com.au Fri, 9 Aug 2002 09:06:34 +1000
Date: Fri, 9 Aug 2002 09:06:34 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] JSR 166 draft API

This is my own personal opinion and need not reflect the opinion of anyone
else on the EG.

> I'm curious why an implementation similar to
> java.util.Collections.synchronizedXXX (where XXX is one of the varius
> Java2 collections interfaces) is not provided to facilitate the use of
> collection implementations with java.util.concurrent.Lock and/or
> .....ReadWriteLock?

There is a whole area that has not yet been touched upon and that is the use
of generics - which will be in the 1.5 release. Once we have generics then I
can envisage "synchronized" collection implementations that are
parameterised with a Lock to use. Doing something for a ReentrantLock is
quite trivial. Using a readwritelock is less trivial as the collection
implementations in current use may not be that amenable to read/write
locking. I would only use this form of locking if I wanted several
collections to be locked by the same lock.

A question to answer is who has responsibility for providing these classes -
it's a non trivial exercise and the collections have to be modified for
generics before 1.5 in any case.

David Holmes





From dholmes@dltech.com.au Fri, 9 Aug 2002 09:25:19 +1000
Date: Fri, 9 Aug 2002 09:25:19 +1000
From: David Holmes dholmes@dltech.com.au
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API (David Holmes)

Not wanting to debate this too much ... :)

> I am far from a POSIX zealot, but I think most people tend to think of
> POSIX condition variables (cv) when they think of Conditions (and that was
> how the class was originally described, wasn't it?).

pthreads programmers think of pthreads conditions. Monitors had condition
queues long before that.

The intent was always to provide multiple condition queues per monitor. The
question was how to provide that. Java monitors were defined with a single
implicit condition queue, accessed via Object.wait(), Object.notify() and
Object.notifyAll(). In hindsight this was too limiting and perhaps they
should have been defined something like: Object.wait(int queueNo) - but they
weren't.

In a Java level library you can't do anything to change the ways
"synchronized" works so everyone who wanted to solve this problem did the
only thing they could and followed the POSIX style of having a Lock class
(Mutex or whatever) with a Condition object.

In JSR-166 we can go "beneath the covers" which allows us to solve the
original problem - more than one condition queue per monitor - much closer
to the Java way of doing things. Hence the Condition class is currently an
"extension" of Object rather than being a POSIX style condition variable.

> Some people might make the case that you should never use recursive locks
> with condition variables, though. This can make code using Conditions less
> error prone. This might be subjective though, no matter what interface
> you provide, people find ways to use it wrong :)

Been there - debated that. Java has always used "recursive locks" with its
conditions. We are not changing those semantics.

> Does the Condition have suprious wakeups?

Condition builds on the underlying wait() mechanism so it inherits all of
its properties and quirks. The best thing is to pretend that spurious
wakeups are a fact of life - accept them, deal with them and move on. It
would be nice to tighten exactly what is meant by a spurious wakeup - though
even the POSIX folk haven't really dealt with that.

> I noticed there is a Locks utility class with an uninteruptible acquire;
> Would it be good to have some similar utility to do uninteruptible waits
> for Conditions, Futures and the rest to for consistency? I think it was
> probably done this way for efficency, so would it be more efficent to do
> the same for the Lock classes as well (make unteruptible acquires part of
> thier interface?)

An uninterruptible acquire is just a loop with a catch clause - nothing
more. Putting the uninterruptible version in Lock looked ugly and it is not
used that often in practice.

> Perhaps a Condition could look at the Lock its given, if its a
> RecursiveLock it could delegate to an implementation that uses the faster
> Object.wait() ordering, and if its anything else it could delegate to
> something that uses a specific notification style?

A plain Condition would use wait()'s "natural" ordering. Any other type of
ordered condition would have to use a specific notification style approach -
there's no other choice. If this were to be supported then the ordering
would be a property of the Condition not the lock.

> Are there any changes in the new API related to priorities at all?

No.

David Holmes





From dholmes@dltech.com.au Fri, 9 Aug 2002 09:41:20 +1000
Date: Fri, 9 Aug 2002 09:41:20 +1000
From: David Holmes dholmes@dltech.com.au
Subject: # [concurrency-interest]RE: RE :RE: JSR 166 draft API (David Holmes)

> How is the Condition implemented?
> Is there a reference implementation we could see?

There is no RI just yet. But the underlying idea is quite simple:

 class Condition {
     Object lock;

     Condition(Object lock) { this.lock = lock; }

     public synchronized void await() throws InterruptdException {
         SomeMagic.releaseMonitorFor(lock);
         try {
	         wait();
	   finally {
             Somemagic.acquireMonitorFor(lock);
          }
     }

  ...
 }

So in this case you actually wait() on the Condition object itself, but it
could use an internal helper object instead.

David Holmes





From jerry.schwarz@oracle.com Thu, 08 Aug 2002 17:29:25 -0700
Date: Thu, 08 Aug 2002 17:29:25 -0700
From: Jerry Schwarz jerry.schwarz@oracle.com
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API
 (David Holmes)

At 04:25 PM 08/08/2002, David Holmes wrote:
>Not wanting to debate this too much ... :)
>
> > I am far from a POSIX zealot, but I think most people tend to think of
> > POSIX condition variables (cv) when they think of Conditions (and that was
> > how the class was originally described, wasn't it?).
>
>pthreads programmers think of pthreads conditions. Monitors had condition
>queues long before that.
>
>The intent was always to provide multiple condition queues per monitor. The
>question was how to provide that. Java monitors were defined with a single
>implicit condition queue, accessed via Object.wait(), Object.notify() and
>Object.notifyAll(). In hindsight this was too limiting and perhaps they
>should have been defined something like: Object.wait(int queueNo) - but they
>weren't.
>
>In a Java level library you can't do anything to change the ways
>"synchronized" works so everyone who wanted to solve this problem did the
>only thing they could and followed the POSIX style of having a Lock class
>(Mutex or whatever) with a Condition object.
>
>In JSR-166 we can go "beneath the covers" which allows us to solve the
>original problem - more than one condition queue per monitor - much closer
>to the Java way of doing things. Hence the Condition class is currently an
>"extension" of Object rather than being a POSIX style condition variable.

That's what I concluded last night after I looked over Condition more 
closely. But I think everything you're saying in this message would be 
clearer if the class were named something like WaitQueue rather than Condition.

> > Some people might make the case that you should never use recursive locks
> > with condition variables, though. This can make code using Conditions less
> > error prone. This might be subjective though, no matter what interface
> > you provide, people find ways to use it wrong :)
>
>Been there - debated that. Java has always used "recursive locks" with its
>conditions. We are not changing those semantics.
>
> > Does the Condition have suprious wakeups?
>
>Condition builds on the underlying wait() mechanism so it inherits all of
>its properties and quirks. The best thing is to pretend that spurious
>wakeups are a fact of life - accept them, deal with them and move on. It
>would be nice to tighten exactly what is meant by a spurious wakeup - though
>even the POSIX folk haven't really dealt with that.
>
> > I noticed there is a Locks utility class with an uninteruptible acquire;
> > Would it be good to have some similar utility to do uninteruptible waits
> > for Conditions, Futures and the rest to for consistency? I think it was
> > probably done this way for efficency, so would it be more efficent to do
> > the same for the Lock classes as well (make unteruptible acquires part of
> > thier interface?)
>
>An uninterruptible acquire is just a loop with a catch clause - nothing
>more. Putting the uninterruptible version in Lock looked ugly and it is not
>used that often in practice.
>
> > Perhaps a Condition could look at the Lock its given, if its a
> > RecursiveLock it could delegate to an implementation that uses the faster
> > Object.wait() ordering, and if its anything else it could delegate to
> > something that uses a specific notification style?
>
>A plain Condition would use wait()'s "natural" ordering. Any other type of
>ordered condition would have to use a specific notification style approach -
>there's no other choice. If this were to be supported then the ordering
>would be a property of the Condition not the lock.
>
> > Are there any changes in the new API related to priorities at all?
>
>No.
>
>David Holmes
>
>
>_______________________________________________
>Concurrency-interest mailing list
>Concurrency-interest@altair.cs.oswego.edu
>http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From crahen@cse.Buffalo.EDU Thu, 8 Aug 2002 23:01:36 -0400 (EDT)
Date: Thu, 8 Aug 2002 23:01:36 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API (David
 Holmes)

On Fri, 9 Aug 2002, David Holmes wrote:

> Not wanting to debate this too much ... :)

I don't want to debate either, I'm just asking questions. There was just a
flood of them all at once. :)

> In JSR-166 we can go "beneath the covers" which allows us to solve the
> original problem - more than one condition queue per monitor - much closer
> to the Java way of doing things. Hence the Condition class is currently an
> "extension" of Object rather than being a POSIX style condition variable.

I see, this makes more sense to me then. I was trying to relate to how
this worked given the way things work now. That was the source of alot of
my confusion. I didn't realize you were able to change things at a lower
level to support this. It doesn't seem as unnatural to me at all any more.

That's pretty neat, using the monitors lock looks more expressive than
having an extra lock object as a member.

> > Some people might make the case that you should never use recursive locks
> > with condition variables, though.
>
> Been there - debated that. Java has always used "recursive locks" with its
> conditions. We are not changing those semantics.

That makes sense to me too. I misunderstood the intent of this class when
I had said that.

Thanks for clearing that up for me,

- Eric
http://www.cse.buffalo.edu/~crahen








From dl@cs.oswego.edu Fri, 9 Aug 2002 18:57:31 -0400
Date: Fri, 9 Aug 2002 18:57:31 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]Atomic variables

Greg Gagne wrote:

> Why not have an AtomicBoolean as well? 

We decided that you are right; and further that we might as well flesh
this out for all scalar types (thus also adding short and char). Doing
otherwise seems gratuitously inconsistent, and asking for trouble in
some unknown way down the road.

Thanks!

-Doug





From dl@cs.oswego.edu Fri, 9 Aug 2002 19:04:13 -0400
Date: Fri, 9 Aug 2002 19:04:13 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Mario Juric wrote:

> I think its a shame that non-reentrant mutexes are excluded from the first
> release, because I really use them in a case where the lock is not released
> by the same thread that has acquired it.

Sorry for our lack of good documentation about this.  A Semaphore
initialized to 1 is precisely what you want in this case.  Which of
course will be supplied.

-Doug






From crahen@cse.Buffalo.EDU Fri, 9 Aug 2002 20:29:21 -0400 (EDT)
Date: Fri, 9 Aug 2002 20:29:21 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Condition thoughts

I was looking at the Condition class a little bit more today. I
implemented a simplified version (because I didn't want to write Clock
classes too) to expirement with it a little bit to get a better feel for
it; I attached it at the bottom of this message incase anyone want to
play with it. Anyway, these are the thoughts I was having about
the Condition interface.

One of the things I really liked about this version compared to the
previous version was that I felt it helped make things more expressive.
You don't need as many try { } finally { } blocks, so things a less
cluttered; and classes like,

class aClass { // pseduocode

  Condition cond = new Condition(this);

  public synchronized void aMethod() {

     // ...

     while(someConditionNotMet())
       cond.wait();

     // ...

  }

}

seem very clear as well (at least given my current understanding of it).

One of the things I found somewhat awkward about this is that is mixes in
objects that are interacting with the primitve language constructs. It may
just be my personal preference, but I just feel like it's missing some
kind of interaction with the Lock hierachy.

Its a shame that I can't use non-recursive locks, or use locks like
RecursiveLock whose acquire()s can be interrupted with a Condtion.
I know the general consensus seems to be recursive locks are better, but I
still think it would be good leave the choice to user. Doug Lea mentioned
that we can realize non-recursive locks through a Semaphore with the an
intial size of 1 - so it is possible to use them if you'd like. Please
don't think I'm trying to start a debate or anything, I'm just explaining
my thoughts.

Now, after Dave's explaination of how this Condition would work, and after
implementing something concrete to play with today I was looking for a way
to keep the thing I liked, and to resolve the thing I didn't like. This is
what I came up with:

If to accomplish this, something would be added that was allowed to do
unbalanced monitorenter/monitorexits; why not make a Lock wrapper for an
objects monitor. Something like this could be used,

public ObjectLock implements Lock { // pseduocode

  private static MonitorHelper helper = new MonitorHelper();
  private Object lock;

  public ObjectLock(Object lock) {
    this.lock = lock;
  }

  public void acquire()
    throws InterruptedException {

    helper.monitorEnter(lock);

  }

  public void release()
    throws InterruptedException {

    helper.monitorExit(lock);

  }

}

to provide a Lock interface to an objects monitor. The Condition class
then might be revised to work with a Lock instead of an Object,

class Condition { // pseduocode

  private Lock lock;

  public Condition(Lock lock) {
    this.lock = lock;
  }

  public synchronized void await() {
    try {
      lock.release();
      wait();
    } finally {
      lock.acquire();
    }
  }

  // ...
}

So now, the small example could be rewritten like this,

class aClass {

  Lock lock = new ObjectLock(this);
  Condition cond = new Condition(lock);

  public synchronized void aMethod() {

     // ...

     while(someConditionNotMet())
       cond.wait();

     // ...

  }

}

What I think is nice about this is this:

 You can use the synchronized keyword when its appropriate and avoid the
 excessive try {} finally {} block that you used to have to write when
 using Locks only.

 The ObjectLock fits into the Lock hierachy, and for me it just feels a
 little better. It fits better with OO design of the rest of the package.
 Again, this is just my opionion, but maybe some others also would like this.

 The part I like the most is that now the Lock the Condition works with is
 interchangeable with other Locks. I could use a non-recusive lock by
 changing one line [lock = new Semaphore(1)] or, if I wanted to, I could
 use a lock with an interruptible acquire by changing one line [lock = new
 RecursiveLock()]

What do you (anyone) think?

This is the implementation I mentioned earlier. Basically, it creates a
class that will attempt monitorenter & monitorexit when certain methods
are called. Depending on your VM, it may or may not be allowed; it seems
to be an optional restriction. I've been using IBM's 1.3.0 VM today to
make this, and it did not complain. Sun's 1.4.0 VM does check to make sure
monitorenter & monitorexit are balanced in each method, so if you run this
on that VM you'll see an IllegalMonitorStateException. There might be an
option to turn that off, but I couldn't find it.

(It was all done with 100% Java by the way, I used a bytecode toolkit
thats part of the polymorph package on my web page to create the
MonitorHelper)

// The source is also at
// http://www.cse.buffalo.edu/~crahen/jsr166/Condition.java
-----------------------------------------------------------------------------
// Condition.java begin

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * @class Condition
 * @author Eric Crahen
 *
 * Condition implementation to expirement with
 */
public class Condition {

  private static MonitorHelper helper = new MonitorHelper();

  private Object sync = new Object();
  private Object[] param;

  public Condition(Object lock)
    throws InterruptedException {

    if(lock == null)
      throw new IllegalArgumentException();

    param = new Object[]{lock};

  }

  public void await() throws InterruptedException {

    synchronized(sync) {

      try {
        helper.monitorExit(param);
        sync.wait();
      } finally {
        helper.monitorEnter(param);
      }

    }

  }


  public void signal() {

    synchronized(sync) { sync.notify(); }

  }

  public void signalAll() {

    synchronized(sync) { sync.notifyAll(); }

  }

  static class MonitorHelper extends ClassLoader {

  /**
   * package java.util.concurrent;
   * public abstract class Monitor {
   *   protected Monitor();
   *   public static void enterMonitor(Object o);
   *   public static void exitMonitor(Object o);
   * }
   */
  private final static byte[] bytecode = new byte[] {
   	(byte)0xca, (byte)0xfe, (byte)0xba, (byte)0xbe,    0x00, 0x03,
0x00, 0x2d,   0x00, 0x0d, 0x01, 0x00,   	0x1c, 0x6a, 0x61, 0x76,
0x61, 0x2f, 0x75, 0x74,   0x69, 0x6c, 0x2f, 0x63,     0x6f, 0x6e, 0x63,
0x75,   0x72, 0x72, 0x65, 0x6e,   0x74, 0x2f, 0x4d, 0x6f,   	0x6e,
0x69, 0x74, 0x6f,   0x72, 0x07, 0x00, 0x01,   0x01, 0x00, 0x10, 0x6a,
0x61, 0x76, 0x61, 0x2f,   0x6c, 0x61, 0x6e, 0x67,   0x2f, 0x4f, 0x62,
0x6a,   	0x65, 0x63, 0x74, 0x07,   0x00, 0x03, 0x01, 0x00,   0x06,
0x3c, 0x69, 0x6e,   	0x69, 0x74, 0x3e, 0x01,   0x00, 0x03, 0x28, 0x29,
0x56, 0x01, 0x00, 0x04,   	0x43, 0x6f, 0x64, 0x65,   0x0c, 0x00,
0x05, 0x00,   0x06, 0x0a, 0x00, 0x04,   	0x00, 0x08, 0x01, 0x00,
0x0c, 0x6d, 0x6f, 0x6e,   0x69, 0x74, 0x6f, 0x72,   	0x45, 0x6e, 0x74,
0x65,   0x72, 0x01, 0x00, 0x15,   0x28, 0x4c, 0x6a, 0x61,   	0x76,
0x61, 0x2f, 0x6c,   0x61, 0x6e, 0x67, 0x2f,   0x4f, 0x62, 0x6a, 0x65,
0x63, 0x74, 0x3b, 0x29,   0x56, 0x01, 0x00, 0x0b,   0x6d, 0x6f, 0x6e,
0x69,   	0x74, 0x6f, 0x72, 0x45,   0x78, 0x69, 0x74, 0x04,   0x21,
0x00, 0x02, 0x00,   	0x04, 0x00, 0x00, 0x00,   0x00, 0x00, 0x03, 0x00,
0x04, 0x00, 0x05, 0x00,   	0x06, 0x00, 0x01, 0x00,   0x07, 0x00,
0x00, 0x00,   0x11, 0x00, 0x02, 0x00,   	0x01, 0x00, 0x00, 0x00,
0x05, 0x2a, (byte)0xb7, 0x00,   0x09, (byte)0xb1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x09,   0x00, 0x0a, 0x00, 0x0b,   0x00, 0x01, 0x00,
0x07,   	0x00, 0x00, 0x00, 0x0f,   0x00, 0x01, 0x00, 0x01,   0x00,
0x00, 0x00, 0x03,   	0x2a, (byte)0xc2, (byte)0xb1, 0x00,   0x00, 0x00,
0x00, 0x00,   0x09, 0x00, 0x0c, 0x00,   	0x0b, 0x00, 0x01, 0x00,
0x07, 0x00, 0x00, 0x00,   0x0f, 0x00, 0x01, 0x00,   	0x01, 0x00, 0x00,
0x00,   0x03, 0x2a, (byte)0xc3, (byte)0xb1,   0x00, 0x00, 0x00, 0x00,
0x00, 0x00
  };
  private static Method monitorEnter;
  private static Method monitorExit;

  MonitorHelper() {

    try {

      Class clazz = defineClass(null, bytecode, 0, bytecode.length);

      monitorEnter = clazz.getMethod("monitorEnter", new
Class[]{Object.class});
      monitorExit =  clazz.getMethod("monitorExit",  new
Class[]{Object.class});
    } catch(Throwable t) {

      t.printStackTrace();
      System.exit(0);

    }

  }

  void monitorEnter(Object[] o) {

    Error err = null;

    try {
      monitorEnter.invoke(null, o);
    } catch(InvocationTargetException e) {

      Throwable t = e.getTargetException();
      if(t instanceof RuntimeException)
        throw (RuntimeException)t;

      err = new Error(t);

    } catch(Exception e) {
      err = new Error(e);
    }

    if(err != null)
      throw err;

  }

  void monitorExit(Object[] o) {

    Error err = null;

    try {
      monitorEnter.invoke(null, o);
    } catch(InvocationTargetException e) {

      Throwable t = e.getTargetException();
      if(t instanceof RuntimeException)
        throw (RuntimeException)t;

      err = new Error(t);

    } catch(Exception e) {
      err = new Error(e);
    }

    if(err != null)
      throw err;

  }

  }

}

// Condition.java end



- Eric
http://www.cse.buffalo.edu/~crahen






From dl@cs.oswego.edu Fri, 9 Aug 2002 20:54:10 -0400
Date: Fri, 9 Aug 2002 20:54:10 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Some replies not covered in responses by other expert group members
while I was out a few days...

Eric D Crahen wrote:

> 
> I think ThreadPool is better off being named PoolExecutor. Executors
> are objects designed to decouple tasks from threads, and the way I look at
> the ThreadPool class described in the API is as an Executor that uses a
> set of threads (or a thread pool) to run submitted tasks. To me it seems
> more natural to describe this as a PoolExecutor that has or uses a
> ThreadPool; it seems more descriptive of whats really going on.

We want naive users looking for thread pools to immediately use this
class (using one of the no-tuning default factory options!). I think
the name helps get this effect.

> 
> The Thread class now has clearThreadLocals() and ThreadLocal now has
> remove(), it might make sense to name the ThreadLocal method clear()
> instead of remove, or maybe name the the Thread method
> removeThreadLocals() just to keep it a little more consistent.

My intent here was to mirror Collections terminology: "remove" for one,
"clear" for all. MAybe there's something to say in docs to clarify.


> 
> Is it possible make the ConcurrentHashMap more of an adapter or wrapper
> for existing HashMaps? I'm just thinking that it might be desirable to
> have something like this that could be used with the regular HashMap or
> with the new LinkedHashMap in the 1.4.0 SDK.

Well, it might be a good idea, but I literally do not know how to pull
this off. The insides of ConcurrentHashMap bear little resemblance to
HashMap.


> * On a related note, I wrote about an Executor pattern for VikingPLoP this
>   year (inspired by this package). I've almost completed the sheparding
>   process, but once I make a few more of the revisions I'll post a link
>   to it here - I think it might be interesting for the audience of this
>   mailing list, and I might get some good feedback from you guys ;-)

Yes. If you send a URL, all 100+ subscribers to this list could take 
a look at it.

Also be sure to read (166 EG member) Brian Goetz's recent article on
thread pools in:
  http://www-106.ibm.com/developerworks/java/library/j-jtp0730.html?loc=j

> 
> There is an interface for general acquire/release semantics, the Lock
> interface (is Lockable better a name? Resources I can acquire and release
> might not be locks, but they are Lockable in some sense?). Would it be
> useful to have an interface for general wait semantics? For example,
> something like,
> 
> interface Waitable {
> 
>   public void await();
> 
>   public boolean await(long time, java.lang.Clock granularity);
> 
>   public void awaitUninterruptibly();
> 
> }
> 
> and Condition's, Barriers & Futures might be the things that implement
> this interface. Each of them wait differently for different reasons, but I
> don't think its any different than how ReentrantLocks and Semaphores
> acquire & release differently.

Thanks. We might twist this idea around a bit and steal it! :-)

-Doug




From dl@cs.oswego.edu Fri, 9 Aug 2002 21:01:19 -0400
Date: Fri, 9 Aug 2002 21:01:19 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]RE: RE :RE:  JSR 166 draft API (David Holmes)

David Holmes wrote:

> I hadn't noticed the barrierAction runnable that can be set. I'll have to
> defer to Doug as to why both techniques warrant support.

There are a couple of parallel processing algorithms out there 
with lines of the form:
  int i = barrier.sync();
  resultVector.set(i, myResults);

But not many; and the barrierAction Runnable approach is much nicer
when you don't need the index.

-Doug






From crahen@cse.Buffalo.EDU Sat, 10 Aug 2002 06:07:59 -0400 (EDT)
Date: Sat, 10 Aug 2002 06:07:59 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]JSR 166 draft API

Doug Lea wrote:

> There are a couple of parallel processing algorithms out there
> with lines of the form:
>   int i = barrier.sync();
>  resultVector.set(i, myResults);

When using a barrier like this, I'm not sure I see the value in
returning an index. I might just be missing something, but the threads
going into the barrier don't have any influence or clue as to what number
they'd be assigned. They complete thier work and they get an arbitrary
number, if used in a loop it could be different each time or it might be
the same one. So how do you use an unpredictable number effectively?

Is it more useful than this?

barrier.sync();
resultVector.add(result);

If you wanted to do a direct store into an array, maybe an index is
more convient, but you'd be synchronizing that array anyway so you could
just use a synchronized wrapper with an add() method instead. It would be
the same, except that user wouldn't ever need to see an index. Again, I
might just completely be missing something here though. :)

> But not many; and the barrierAction Runnable approach is much nicer
> when you don't need the index.

I like this Runnable solution; That part makes good sense, and is an
elegant way to have a single action execute when the barrier completes
successfully.

- Eric
http://www.cse.buffalo.edu/~crahen





From crahen@cse.Buffalo.EDU Sat, 10 Aug 2002 06:42:00 -0400 (EDT)
Date: Sat, 10 Aug 2002 06:42:00 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]JSR 166 draft API

Doug Lea wrote:

>> I think ThreadPool is better off being named PoolExecutor. Executors
>> are objects designed to decouple tasks from threads, and the way I look
>> at the ThreadPool class described in the API is as an Executor that
>> uses a set of threads (or a thread pool) to run submitted tasks.
>
> We want naive users looking for thread pools to immediately use this
> class (using one of the no-tuning default factory options!). I think
> the name helps get this effect.

I can see how this would be attractive in simplifying things for new users
to help them get up an running quickly. Would a better place for this
possibly be a new Java Trail, or another tutorial?

I read through Brian Goetz's and it looks like he also makes the
distinction between a thread pool and between something driven by a thread
pool. In his article, that something is the WorkQueue class he presents;
this looks very similar in purpose to the ThreadPool thats in the
concurrent.util package.

The ThreadPool in the API docs does some things that aren't typical of
alot of thread pools (like supporting Futures). You could look at this as
a special kind of all-purpose thread pool, but I think naming it as
some kind Executor better reflects everything it offers. I really
like the emaphasis on patterns in general in Java, and I like the
abstraction of Executors and the idea of decoupling a task from the means
of execution. So, thats also a part of why I liked the PoolExecutor name
better.

Larry Riedel wrote:

> Just as a data point, I personally prefer apparent structural
> complexity to apparent behavioral complexity, and I think in
> this kind of case that may be manifested as a preference for
> having 3 classes for 3 different behaviors instead of one
> class which I can use 3 ways to (indirectly) get 3 behaviors.

I think this way as well. Its a nicer design to me. Having a more
structured breakdown into several specialized Executor classes might also
ease a new users introduction to these classes. It would be less to
swallow all at once; I could imagine a tutorial starting off explaining
the Executor idea, and then presenting a series of Executors; possibly a
DirectExecutor, a LockedExecutor, a ConcurrentExecutor and finally a
PoolExecutor. An incremental introduction to that would definently be
easier to explain to a new user compared to saying here is an Executor
with a whole bunch of options for doing everything you could ever want.

(at least, I know it would be easier to explain to most of the students
I've taught here ;)

- Eric
http://www.cse.buffalo.edu/~crahen





From dl@cs.oswego.edu Sat, 10 Aug 2002 08:41:41 -0400
Date: Sat, 10 Aug 2002 08:41:41 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]Condition thoughts

Eric Crahen wrote:

> I was looking at the Condition class a little bit more today. I
> implemented a simplified version (because I didn't want to write Clock
> classes too) to expirement with it a little bit to get a better feel for
> it; I attached it at the bottom of this message incase anyone want to
> play with it. Anyway, these are the thoughts I was having about
> the Condition interface.

Notes on a couple of implementation snags that you alluded to:
 
1. The second edition of JVMS spec allows (but does not require) JVMs
to throw exceptions if monitorenter/exits aren't block-balanced. So
code like this currently only works on those that don't enforce
this. Hotspot DOES enforce, but the Sun "Production release" 1.2.1.x
on Solaris, and the IBM 1.3.x JVMs don't (at least apparently don't on
linux).

2. Your code (and some similar versions I've built for
experimentation) won't work with reentrantly held locks. There is a
way to do it though, using the Thread.holdsLock method
introduced in 1.4, to control enter/exit loops. However, hotspot 1.4.x
can't deal with non-block-structured locks, and the JVMs that do don't
support 1.4 (at least I don't know of any), so you can't currently run
such code.

Together, these problems make it clear why there needs to be
(basically easy) JVM changes to support JSR166.


> to provide a Lock interface to an objects monitor. The Condition class
> then might be revised to work with a Lock instead of an Object,

This was in fact the original plan for JSR166. But it seems wrong to
require use of awkward acquire/release constructions just to get the
effect of condition variables.


The main upshot of these discussions is that I now think we should change
the name of the Condition class. 

-Doug






From dl@cs.oswego.edu Sat, 10 Aug 2002 09:23:56 -0400
Date: Sat, 10 Aug 2002 09:23:56 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Structure and function

Usually, we've been discussing only on the internal expert group list
possible revisions based on comments posted on concurrency-interest
list. (That's not because we don't like you or don't value your
opinion, it is because it is is too hard to make decisions otherwise.)
But for this one, I'd like to more broadly canvas opinion.

There have already been several instances where there is functionality
available in JSR166, but not where people have looked for it.  Two
examples:

* There's no Mutex because the combination of ReentrantLock and
Semaphore(1) hits all the common cases that arise. 

* ThreadPool is the only implementation of Executor we supply.  Even
though there are several other niche Executors that people might want
to build (e.g., one that does remote execution, or one that maintains
multiple queues to manage QoS), all of the "normal" common ones can be
somehow obtained via ThreadPool. For example, you'd always prefer
ThreadPool.fixedThreadPool(1) to something like a suitably revamped
dl.u.c.QueuedExecutor.

The question is whether we ought to somehow make some of these
structurally more obvious. For example, to make a class Mutex
that acts just like Semaphore(1). There are two opposing views:

  1. The view that "any door that needs a 'Push' or 'Pull' label on it 
     is misdesigned". If you cannot immediately see how to get the effect 
     of, say,  a single  background worker thread, then something is wrong.

  2. The view that adding an interface, class or even method to a
     standard JDK package adds to the burden of understanding and
     using it. So it is better to keep a package on the small side,
     and teach people all the things they can do with each feature.

I'm closer to (2) here, but there is room for compromise.  (So, for
example, we supply some convenient factory methods in ThreadPool that
preset common combinations of options.)  Exactly what compromises
would you like to see?

Note that this issue is separate from questions of flexibility or
extensibility. In all appropriate cases, we supply interfaces, so if
you have unusual requirements not handled by "normal" implementations,
you can build your own. Our experience with the basically similar
tactic taken for java.util.Collections is that people do in fact make
their own implementations when they really need to, but that the need
is fairly rare.

-Doug




From crahen@cse.Buffalo.EDU Sat, 10 Aug 2002 10:08:31 -0400 (EDT)
Date: Sat, 10 Aug 2002 10:08:31 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

Doug Lea wrote:

> The question is whether we ought to somehow make some of these
> structurally more obvious. For example, to make a class Mutex
> that acts just like Semaphore(1). There are two opposing views:
>
[snip]
>
> * There's no Mutex because the combination of ReentrantLock and
> Semaphore(1) hits all the common cases that arise.
>
[snip]
>
> Exactly what compromises would you like to see?

I think a Mutex could be a good idea; it would definently be more obvious,
(I didn't even think of using the Semaphore before I asked where that
class went :) but I think that it also might be viewed as a special case.
If you were to use a Semaphore(1) you get the same fundamental
functionality, but if you were to acquire() recurisively you would just
deadlock. If a Mutex were provided separately this, you could easily
throw an exception when that kind of deadlock is detected which would be
very helpful to developers who need that type of Lock. This might be a
very common need for people who are using Semaphore(1).


- Eric
http://www.cse.buffalo.edu/~crahen






From dl@cs.oswego.edu Sat, 10 Aug 2002 10:10:28 -0400
Date: Sat, 10 Aug 2002 10:10:28 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Yuri Gadow wrote:

> I'm curious why an implementation similar to
> java.util.Collections.synchronizedXXX (where XXX is one of the varius
> Java2 collections interfaces) is not provided to facilitate the use of
> collection implementations with java.util.concurrent.Lock and/or
> .....ReadWriteLock?

There are such classes in dl.u.c, but I had enough concerns about them
that I left them (in particular, the ReadWriteLock versions) out of JSR166:

  1. The java.util.collection framework doesn't actually promise that
     any methods are read-only. Even a method like isEmpty() might
     have some internal bookkeeping side effect. (For example,
     WeakHashMap clears out weak ref queues in the course of some
     "read" methods. ) So, while you can separate out the ones that
     don't logically do any writes vs others, the correctness of doing
     so can't be assured for an arbitrary collection.

  2. ReadWriteLocks (of any kind, regardless of how cleverly
     implemented) impose enough additional overhead that you'd only
     rarely want to use them with typical Collection classes of typical
     sizes.

In general, it is a better idea to supply collection classes that are
designed from scratch to maximize reader concurrency. We're still considering
providing some not yet listed.

-Doug




From dl@cs.oswego.edu Sat, 10 Aug 2002 11:03:49 -0400
Date: Sat, 10 Aug 2002 11:03:49 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

[Resending after mailman list mgr complained about addresses.]

Yuri Gadow wrote:

> I'm curious why an implementation similar to
> java.util.Collections.synchronizedXXX (where XXX is one of the varius
> Java2 collections interfaces) is not provided to facilitate the use of
> collection implementations with java.util.concurrent.Lock and/or
> .....ReadWriteLock?

There are such classes in dl.u.c, but I had enough concerns about them
that I left them (in particular, the ReadWriteLock versions) out of JSR166:

  1. The java.util.collection framework doesn't actually promise that
     any methods are read-only. Even a method like isEmpty() might
     have some internal bookkeeping side effect. (For example,
     WeakHashMap clears out weak ref queues in the course of some
     "read" methods. ) So, while you can separate out the ones that
     don't logically do any writes vs others, the correctness of doing
     so can't be assured for an arbitrary collection.

  2. ReadWriteLocks (of any kind, regardless of how cleverly
     implemented) impose enough additional overhead that you'd only
     rarely want to use them with typical Collection classes of typical
     sizes.

In general, it is a better idea to supply collection classes that are
designed from scratch to maximize reader concurrency. We're still considering
providing some not yet listed.

-Doug




From dl@cs.oswego.edu Sat, 10 Aug 2002 11:15:26 -0400
Date: Sat, 10 Aug 2002 11:15:26 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]JSR 166 draft API

Eric Crahen wrote:

> When using a barrier like this, I'm not sure I see the value in
> returning an index. I might just be missing something, but the threads
> going into the barrier don't have any influence or clue as to what number
> they'd be assigned. They complete thier work and they get an arbitrary
> number, if used in a loop it could be different each time or it might be
> the same one. So how do you use an unpredictable number effectively?
> 
> Is it more useful than this?
> 
> barrier.sync();
> resultVector.add(result);

Well, maybe not, but it costs nothing to return an index, and allows
people to more easily code existing algorithms. No sense in frustrating
such people for no good reason.

-Doug




From dl@cs.oswego.edu Sat, 10 Aug 2002 11:46:30 -0400
Date: Sat, 10 Aug 2002 11:46:30 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]deadlock detection

Dave Kreiwell wrote:

> When the only locking construct I used was Java synchronization, I could
> determine from a JVM thread dump if a deadlock situation existed (if the JVM
> was in a good mood and produced the monitor cache dump, that is! -- usually
> only worked with classic VM, never in production with HotSpot).  
> 
> But once I started using the old concurrent package's
> WriterPreferenceReadWriteLocks, a deadlock became harder to identify because
> locks became "logical" from a VM point of view.  The thread dump would show
> a thread waiting to acquire a WriterPreferenceReadWriteLock, but I couldn't
> tell what thread owned it as the ActiveWriter.  In order to detect
> deadlocks, I had to modify the class to allow me to access the ActiveWriter,
> add a weak reference hashmap containing all the ReadWriteLocks, and write
> some debugging code to log all the ActiveWriters of all the ReadWriteLocks.
> 
> Is there any provision in the new package for determining deadlocks?  
> 

The ReentrantLock and ReentrantReadWriteLock classes exist in their
current forms in part to enable (not require) some internal
integration with builtin locks. For example, ReentrantLock.acquire can
be implemented via monitorEnter bytecode, modulo dealing with internal
issues I mentioned in previous mail today.

This means that there is a strong chance that JVMs that detect
deadlock will report problems using at least these two lock types in a
fairly helpful way. That's about as far as I can see JVM-level support
going in the near-term.

-Doug






From ggagne@westminstercollege.edu Sat, 10 Aug 2002 09:52:27 -0600
Date: Sat, 10 Aug 2002 09:52:27 -0600
From: Greg Gagne ggagne@westminstercollege.edu
Subject: [concurrency-interest]Barrier

--Apple-Mail-1--852059825
Content-Transfer-Encoding: 7bit
Content-Type: text/plain;
	charset=US-ASCII;
	format=flowed

I concur with Doug on this. (Admittedly I stumbled upon its return 
value.)

There are many methods/functions that return values that are often 
ignored, but it seems
that it costs nothing and provides an extra degree of functionality.

I assigned a MT matrix mult. assignment but discouraged the use of 
join() and instead
told students to use a synchronization mechanism instead (wanting them 
to figure this part out themselves.) A few students used the
barrier and the thread that received the return value of 0 output the 
product. Yes, this isn't why you'd be using a barrier as the
calc threads aren't doing any work after reaching the synchronization 
point, however I found it a creative use of barriers and it
satisfied a small piece of the discovery process I (we) want students to 
participate in.

//greg


Eric Crahen wrote:

When using a barrier like this, I'm not sure I see the value in
returning an index. I might just be missing something, but the threads
going into the barrier don't have any influence or clue as to what number
they'd be assigned. They complete thier work and they get an arbitrary
number, if used in a loop it could be different each time or it might be
the same one. So how do you use an unpredictable number effectively?

Is it more useful than this?

barrier.sync();
resultVector.add(result);

Well, maybe not, but it costs nothing to return an index, and allows
people to more easily code existing algorithms. No sense in frustrating
such people for no good reason.

--Apple-Mail-1--852059825
Content-Transfer-Encoding: 7bit
Content-Type: text/enriched;
	charset=US-ASCII

I concur with Doug on this. (Admittedly I stumbled upon its return
value.)


There are many methods/functions that return values that are often
ignored, but it seems

that it costs nothing and provides an extra degree of functionality.


I assigned a MT matrix mult. assignment but discouraged the use of
join() and instead

told students to use a synchronization mechanism instead (wanting them
to figure this part out themselves.) A few students used the

barrier and the thread that received the return value of 0 output the
product. Yes, this isn't why you'd be using a barrier as the

calc threads aren't doing any work after reaching the synchronization
point, however I found it a creative use of barriers and it

satisfied a small piece of the discovery process I (we) want students
to participate in.


//greg



Eric Crahen wrote:


<color><param>0000,0000,DEDE</param>When using a barrier like this,
I'm not sure I see the value in

returning an index. I might just be missing something, but the threads

going into the barrier don't have any influence or clue as to what
number

they'd be assigned. They complete thier work and they get an arbitrary

number, if used in a loop it could be different each time or it might
be

the same one. So how do you use an unpredictable number effectively?


Is it more useful than this?


barrier.sync();

resultVector.add(result);

</color>

Well, maybe not, but it costs nothing to return an index, and allows

people to more easily code existing algorithms. No sense in frustrating

such people for no good reason.
--Apple-Mail-1--852059825--





From crahen@cse.Buffalo.EDU Sat, 10 Aug 2002 17:11:16 -0400 (EDT)
Date: Sat, 10 Aug 2002 17:11:16 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:

>> * On a related note, I wrote about an Executor pattern for VikingPLoP
>>   this year (inspired by this package). I've almost completed the
>>   sheparding
>
> Yes. If you send a URL, all 100+ subscribers to this list could take
> a look at it.

This is a link to a draft of the paper I mentioned,

http://www.cse.buffalo.edu/~crahen/papers/Executor.Pattern.pdf

The sheparding process is still going on (I think its almost done) so
I still could be making revisions. If anyone has any questions, or any
constructive feedback just email me! :)


- Eric
http://www.cse.buffalo.edu/~crahen





From crahen@cse.Buffalo.EDU Sat, 10 Aug 2002 17:11:16 -0400 (EDT)
Date: Sat, 10 Aug 2002 17:11:16 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:

>> * On a related note, I wrote about an Executor pattern for VikingPLoP
>>   this year (inspired by this package). I've almost completed the
>>   sheparding
>
> Yes. If you send a URL, all 100+ subscribers to this list could take
> a look at it.

This is a link to a draft of the paper I mentioned,

http://www.cse.buffalo.edu/~crahen/papers/Executor.Pattern.pdf

The sheparding process is still going on (I think its almost done) so
I still could be making revisions. If anyone has any questions, or any
constructive feedback just email me! :)


- Eric
http://www.cse.buffalo.edu/~crahen





From larryr@saturn.sdsu.edu 10 Aug 2002 21:23:05 -0000
Date: 10 Aug 2002 21:23:05 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] Structure and function

Doug Lea wrote:
> There have already been several instances where
> there is functionality available in JSR166, but
> not where people have looked for it.
> [...]
> The question is whether we ought to somehow make
> some of these structurally more obvious.
> [...]
> Exactly what compromises would you like to see?

As a data point, I, as a user of these APIs to build applications,
prefer to get more classes and methods for free that I can use to
do what I want, so I do not have to implement those classes and
methods in my own application and libraries.

I can imagine in theory that for someone who is trying to learn
the concepts by looking at what is offered in the JDK, it might be
nice to have a minimal, orthogonal set of structure and behavior.
But I already have concepts in my mind, and I look to the JDK
hoping to find classes which clearly map to those concepts.

I like the idea of having a minimal, orthogonal set of
fundamental interfaces, along with classes which mix and match
those interfaces to provide all kinds of useful behavior.  I can
imagine the interfaces as providing the theoretical foundation,
and the classes as examples of ways to use the foundation to do
real work, and I can use those classes to do just that.

I love to see classes in the JDK which just sit on other classes
in the JDK to make my life easier, and I love things like the
"remaining()" method in java.nio.Buffer, which is really just
the same as "limit() - position()", but helps make my own code
simpler and easier to read, and I love helper methods like a
"put(byte[] dst)", which is the same "put(dst, 0, dst.length)".

But there are some classes in the proposed java.util.concurrent
which have names I did not personally find an obvious mapping
to concepts in my head from the name of the class.  For example
it was not clear to me what Future and Executor are, but when I
started thinking about a Future as a Job and/or Task, and Executor
as a JobQueue and/or Scheduler, it seemed to make more sense.

If java.util.concurrent was a melange of obscurely named classes,
of which many seem to do almost the same thing, such that
everybody who uses it is going to have to analyze the whole thing
to discern what in the world it is, then I would agree that it
might be preferable to minimize the size of that task.  But I am
confident java.util.concurrent is not going to be such a melange.


Larry





From crahen@cse.Buffalo.EDU Sun, 11 Aug 2002 10:05:15 -0400 (EDT)
Date: Sun, 11 Aug 2002 10:05:15 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

> Doug Lea wrote:
>
> > The question is whether we ought to somehow make some of these
> > structurally more obvious.
> >
> [snip]
> >
> > * ThreadPool is the only implementation of Executor we supply.
> [snip]
> >
> > Exactly what compromises would you like to see?

Including a separate class for a single threaded executor would be a good
idea. Next to using thread pools, the second most common thing people use
is probably a single threaded dispatcher (like AWT's event thread). While
you can get this just by creating a thread pool with a size of 1, it may
not be the first place people would look. If a person isn't planning on
using a thread pool, why would they look at a thread pool for that
functionality? I know its there, it just wouldn't the first place I'd
look. This could very well be implemented just by delegating to
whater ThreadPool.fixedThreadPool(1) is now, but I think the separate
class would be conceptually clearer.

To me it seems as though there is an awful lot of functionality crammed
into the ThreadPool class. Separating out some of that, or moving it into
the AbstractExecutor class or even making parts of it a part of the
Executor interface might help make that particular class clearer. These
are just my suggestions, (I'm sorry if some of these are in the
flexiblity/extensibilty catergory)

For instance,

 - In the Executor interface, you can start tasks and you can stop tasks,
   but you can't wait for tasks. For that you need to know you are using
   the ThreadPool (awaitTermination). That would be useful to all types
   of executors, even ones that weren't neccessarily based on local
   threads (maybe you have a RemoteExecutor and this would wait for some
   indication from the remote system that a task completed)

 - The interrupt() method is only a part of ThreadPool. This would
   convient for a single threaded executor, and maybe its also possible
   that some specialized executors, like the RemoteExecutor, might send
   a message to the remote system. The only executor that this wouldn't
   really be useful for would be an executor that justs runs tasks in the
   current thread; in that kind of situation it could just do nothing
   (it makes sense if there is nothing for interrupt to do) so that
   might also be placed in the Executor interface - or in the
   AbstractExecutor class.

 - Before and After intercepts are part of ThreadPool
   (ThreadPool.Intercepts). This is supposed to allow custom ThreadPools
   to hook various points of Execution.	This is something that I
   think would be good for all Executors, not just ThreadPool based
   ones. The afterExecutor, beforeExecute and cannotExecutor would
   be handy for all kinds of things. If these were part of an interface
   not directly tied to a ThreadPool it would make more sense if an
   Intercepts type class were used with other Executors. If the were
   a separate single threaded executor, and I wanted to customize what
   happened before and after each task, I wouldn't look at the ThreadPool
   class to find that functionality.

   If this behavior is moved out of the ThreadPool, then the factory
   method (newThread) and the terminated method could be moved into the
   ThreadPool class. Actually, maybe associating a Runnable (similar to
   how a barrier associates a task to execute when it comepletes) might
   work a little better.

 - In ThreadPool's consructor, the user can supply a BlockingQueue. But
   they can also supply a ThreadPool.Intercepts that also supplies a
   BlockingQueue to the Executor. Its a little confusing, if these aren't
   referring to the same Queue, I'm not sure what happens.

-  I'm not sure if Intercepts is really the best place for getQueue().
   Its not really an execution point you want to customize. If the queue
   were to change (for QoS sensative implementations) this might be more
   of a common implementation detail which might be better placed in
   AbstractExecutor. If you did factor out the execution hooks (before,
   after, ...) into a separate interface, then this would be a better
   place for it. It could be tied together with the one that
   can be supplied in the constructor. Something like,

   abstract class AbstractExecutor {
     private BlockingQueue queue;
     protected AbstractExecutor(BlockingQueue queue) { this.queue = queue; }
     BlockingQueue getQueue() { return queue; }
   }

   is what I mean.

 - If you were to do that with getQueue(), then moving
   getMaximumQueueCount() & any other queue related stuff to
   AbstractExecutor would make sense - although, if you can getQueue()
   couldn't you use getQueue().size() instead of getQueueCount()?
   Possibly, moving the memory of the maximum number of things queued
   into the Queue?

 - The ThreadPool documents mention something about blocked execution
   under the tuning section, but its not clear to me what the details
   of that are.

You could still backup the implementations of other kinds of Executors
with your ThreadPool. But at least having a different front end for
different behavior makes things stand out better for a user.

I understand that if you only wanted to provide a ThreadPool, that would
lead you down one design path. But I think restructuring this part of the
code could help make the purpose clearer (and it also would help make
things more flexible)


- Eric
http://www.cse.buffalo.edu/~crahen







From dholmes@dltech.com.au Mon, 12 Aug 2002 09:50:30 +1000
Date: Mon, 12 Aug 2002 09:50:30 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

> Including a separate class for a single threaded executor would be a good
> idea. Next to using thread pools, the second most common thing people use
> is probably a single threaded dispatcher (like AWT's event thread). While
> you can get this just by creating a thread pool with a size of 1, it may
> not be the first place people would look. If a person isn't planning on
> using a thread pool, why would they look at a thread pool for that
> functionality?

I don't buy this argument because it assumes that there is some well defined
and well known abstraction for an AWT style event dispatcher. If I were
aware of the AWT and wanted something like that then I'd probably look at
what the AWT does - so maybe we should think about adapting AWT to use a
ThreadPool of size 1 ;-) - but I wouldn't go looking for a class
AWTStyleSingleThreadedEventDispatcher.

I'm not trying to be snide or sarcastic - I appreciate what you are saying
but I think that people will have to browse the library because it is new,
just to get a feel of what is there. And we intend to make the docs so good
that people will really understand what things are and what they can do. If
someone knew what a thread pool was then they would know that it was what
they needed. If they didn't know what a thread pool was they'd have to read
about and learn about it and then they would know that a thread pool of size
1 is just what they need.

I'm now of the opinion, with regard to ThreadPool, that we should be
educating people to realise that a thread pool with a single thread is still
a thread pool - it just has some nice simplifying properties due to there
only being a single thread.

If I were to try and classify Executors then I think my top-level
classiciation would be threaded versus non-threaded. While ThreadPool might
not be the best name for describing ThreadedExecutors I think that the
ThreadPool API is a good API for a ThreadedExecutor.

I think that part of the problem is that Executor is a weak root for this
hierarchy because there is very little on the non-threaded executor side of
things.

Just my opinion.

David Holmes





From dholmes@dltech.com.au Mon, 12 Aug 2002 10:16:50 +1000
Date: Mon, 12 Aug 2002 10:16:50 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Condition thoughts

Eric Crahen wrote:
> Its a shame that I can't use non-recursive locks, or use locks like
> RecursiveLock whose acquire()s can be interrupted with a Condtion.
<snip>
> If to accomplish this, something would be added that was allowed to do
> unbalanced monitorenter/monitorexits; why not make a Lock wrapper for an
> objects monitor. Something like this could be used,
<snip>
> to provide a Lock interface to an objects monitor. The Condition class
> then might be revised to work with a Lock instead of an Object,
<snip>
> What do you (anyone) think?

There have been many discussions on this in the EG.

My own thoughts for this are to extend the capabilities of the Condition
class rather than defining a special ObjectLock class - but the end results
are the same:

  Condition(Object obj) // Binds the condition to use obj's monitor
  Condition(Lock lock)  // Binds the condition to acquire/release lock

It would be an optimisation to be able to map, say, ReentrantLock directly
onto monitor operations. However there are several issues to resolve:

a) monitor entry is not interruptible while Lock acquisition is supposed to
   be

b) Some VM's won't let you unlock/lock arbitrary monitors in this way.
   They must be properly nested within a scope.

Also note that this isn't as common or useful as you might think. While it
looks neat and balanced you rarely need to use conditions when working in
situations that require stand-alone lock classes.

David Holmes





From crahen@cse.Buffalo.EDU Sun, 11 Aug 2002 20:34:19 -0400 (EDT)
Date: Sun, 11 Aug 2002 20:34:19 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] JSR 166 draft API

[mailman bounced my first one]

On Sun, 11 Aug 2002, Eric D Crahen wrote:

> On Mon, 12 Aug 2002, David Holmes wrote:
>
> > The POSA book is full of related concurrency patterns, including the
> > equivalent of "Executor" - active object is the name he gives "decoupl[ing]
> > method execution from method invocation to enhance concurrency".
>
> I am aware of that book (I've got a copy in here somewhere :). This is
> different than the Active Object pattern. Some of it is similar, but the
> Active Object is a bit different. With an Active Object, you are wrapping
> an object with a proxy that ends up creating & scheduling futures for
> each method invocation.
>
> The Executor is complementary to the Command pattern. Its more general in
> its intent to capture the decoupling of tasks from thier method of
> execution. It adds more structure to things scheduling component of the
> Active Object which turn up in other places as well.
>
> You could use an Executor as the backend to support an Active Object.
> The ActiveObject would be focused on creating the proxy that, for each
> method, creats tasks (Commands) and submits them to a scheudler
> (Executor).
>
> > At a minimum you need to reference this stuff.
>
> I didn't reference the Active Object pattern intitally because I felt that
> it was more focused on the wrapper & the futures. But now that you mention
> it, I think it would be a good idea to highlight its role in an Active
> Object and make that reference. Thanks.
>
> And, luckily, its a draft and I still have time to make revisions :)
>
> - Eric
> http://www.cse.buffalo.edu/~crahen





From crahen@cse.Buffalo.EDU Sun, 11 Aug 2002 21:06:00 -0400 (EDT)
Date: Sun, 11 Aug 2002 21:06:00 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

On Mon, 12 Aug 2002, David Holmes wrote:

> I'm not trying to be snide or sarcastic -

Don't worry; I understand :)

> I appreciate what you are saying but I think that people will have to
> browse the library because it is new, just to get a feel of what is
> there. And we intend to make the docs so good that people will really
> understand what things are and what they can do.

The documentation would definently be a huge a help. With a few good
tutorials I think you could really give new user a big boost into getting
started using it. (I'd volunteer to help with that ;-)

> I'm now of the opinion, with regard to ThreadPool, that we should be
> educating people to realise that a thread pool with a single thread is still
> a thread pool - it just has some nice simplifying properties due to there
> only being a single thread.

(This is all just my point of view)

That's true, but if as a user you find a need for a single threaded
executor then there are a few things you wouldn't need any more. The keep
alive times & the ability to adjust the pool size wouldn't be needed any
more.

I think the main difference we seem to have is just over the design. I
recognize that you can reduce every threaded down to a ThreadPool, and if
the goal is to keep things as compact as possible it makes sense to do
that. If on the other hand you prefer to see a more robust hierarchy that
expands each idea into a distict class then having two classes makes sense
(one single and one pooled).

The ThreadPool could be used to create a single threaded one, just like
you might use a Semaphore to create a Mutex. My point of view is that I
see that more of an implementation detail. If I think I need one thread I
don't think pool, just like if I need mutal exclusion, I don't think
semaphore. (Or how if I need a Stack I don't think Vector)

I don't think it would neccessarily be a bad thing to include a separate
class - espcially if you implement it simply by delegating to a
ThreadPool. There would literally be very little to maintain, and the
Executor hierarchy would become more enriched. Again, that's all just the
way I look this.

> I think that part of the problem is that Executor is a weak root for this
> hierarchy because there is very little on the non-threaded executor side of
> things.

I think there are a couple non-threaded Executors that are convinient.
Maybe some are not useful in production, but they can be helpful for
debugging or for starting to refactor code that wasn't initially designed
for multiple threads (you can start with a direct executor and after you
make the rest of the code mt ready move to the threaded version). And
then some remote executors may never need to use threads explcitly at all
(but these are probably on the rarer side of things as others have
mentioned).

Theres at least as many kinds of non thread possibilites as there are
threaded ones. You are creating a concurrency library, so it makes sense
to leave non-threaded ones out; but its still possible to make the
abstraction a little more open so that other kinds of executors can be
created that will fit more naturally into an Executor hierarchy
(espcially if you want to write things like Intercepts classes that might
be used with either variety).


- Eric
http://www.cse.buffalo.edu/~crahen














From crahen@cse.Buffalo.EDU Sun, 11 Aug 2002 21:09:36 -0400 (EDT)
Date: Sun, 11 Aug 2002 21:09:36 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Condition thoughts

On Mon, 12 Aug 2002, David Holmes wrote:

> There have been many discussions on this in the EG.

I'm glad to know some of the people in the EG had the same idea :)

I didn't think of the bugs you & Doug mentioned until after I made
that Condtion class.

- Eric
http://www.cse.buffalo.edu/~crahen






From dholmes@dltech.com.au Mon, 12 Aug 2002 11:40:43 +1000
Date: Mon, 12 Aug 2002 11:40:43 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] Structure and function

> That's true, but if as a user you find a need for a single threaded
> executor then there are a few things you wouldn't need any more. The keep
> alive times & the ability to adjust the pool size wouldn't be needed any
> more.

It is very common to have a class that provides capabilities that are not
exercised by all instances of that class. For example, I've never set a
load-factor on a collection class. I'd also say that in some circumstances
you may want a keep-alive time even on thread pool of size 1.

> I think the main difference we seem to have is just over the design. I
> recognize that you can reduce every threaded down to a ThreadPool, and if
> the goal is to keep things as compact as possible it makes sense to do
> that. If on the other hand you prefer to see a more robust hierarchy that
> expands each idea into a distict class then having two classes makes sense
> (one single and one pooled).

The issue boils down to the properties of a type versus the properties of an
instance of a type. That's an argument that always depends on context and
perspective. I don't see enough defining qualities of a single-thread
executor to make it "big" enough to be a type in its own right.

> I think there are a couple non-threaded Executors that are convinient.

Sure. If I was expanding out the interface hierarchy based on this
discussion I might do:
                              Executor
                                  |
                  |-----------------------------|
           NonThreadedExecutor           ThreadedExecutor
                  |
        |-----------------------|
  DirectExecution        RemoteExecution

But to be honest all of these left-hand "types" really just refine the
detailed semantics of the execute method of Executor. I don't see any
commonality or special behaviour that would really warrant distinct
interfaces - nor can I imagine a range of implementations that would make
having the interface type beneficial. So that leaves us with the unbalanced
hierarchy:

                              Executor
                                  |
                  |-----------------------------|
           <user-define>                 ThreadedExecutor

The programmer is still free to expand Executor in any way that might not be
considered "threaded".

In looking at ThreadedExecutor (aka ThreadPool) I don't see any major
benefit in distinguishing the case for size=1 versus anything else. But
that's just me.

David Holmes





From dl@cs.oswego.edu Mon, 12 Aug 2002 08:15:44 -0400
Date: Mon, 12 Aug 2002 08:15:44 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] Structure and function

Eric Crahen wrote: 

> That's true, but if as a user you find a need for a single threaded
> executor then there are a few things you wouldn't need any more. The keep
> alive times & the ability to adjust the pool size wouldn't be needed any
> more.

... and several things that you might still need, for example to
intercept runnables before or after execution, or to keep counts of
the number of executed tasks. For any given configuration of a
ThreadPool, there will be a few methods that will rarely if ever apply
to it, but similar observations apply to most general-purpose library
classes.

> ... SingleThreadExecutor ...

There are only a few ways to do this off in Java:

 1. Make SingleThreadExecutor a subclass of ThreadPool, basically
    just adding a constructor. Note that in this case, people would
    still need to read ThreadPool javadoc to see how to use most methods.

 2. Make SingleThreadPool an unrelated class, that delegates
    its functionality to an underlying ThreadPool. This entails
    declaring and documenting all applicable ThreadPool methods in
    this new class. Among other problems, this is a maintenance headache.

 3. Same as (2) except introduce yet another interface that includes
    those methods shared by ThreadPool and SingleThreadExecutor so the
    methods can be declared and documented in one place. And other
    similar interfaces for other common subsets of functionality
    shared with other special versions of ThreadPool. 

 4. Define a special factory method or constructor instead of a new
    class. The factory method approach is a little nicer since you can
    give it a special name.

(others?)

Currently, we are doing (4). People who think we shouldn't, please
make a good case for one of the concrete alternatives. 
  
-Doug




From crahen@cse.Buffalo.EDU Mon, 12 Aug 2002 09:46:09 -0400 (EDT)
Date: Mon, 12 Aug 2002 09:46:09 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

Doug Lea wrote:

> > That's true, but if as a user you find a need for a single threaded
> > executor then there are a few things you wouldn't need any more ...
[snip]
> ... and several things that you might still need, for example to
> intercept runnables before or after execution, or to keep counts of
> the number of executed tasks.

I think these are things that would apply to all Executors (non-threaded
as well); it could be better to factor this out into another interface
(maybe Excutor.Intercepts) instead of binding it to ThreadPool.

> 2. Make SingleThreadPool an unrelated class, that delegates
>    its functionality to an underlying ThreadPool. This entails
>    declaring and documenting all applicable ThreadPool methods in
>    this new class. Among other problems, this is a maintenance headache.

I didn't think of the documentation part of this. You're right, no one
wants to do that twice. :)

> 3. Same as (2) except introduce yet another interface that includes
>    those methods shared by ThreadPool and SingleThreadExecutor so the
>    methods can be declared and documented in one place. And other
>    similar interfaces for other common subsets of functionality
>    shared with other special versions of ThreadPool.

> Currently, we are doing (4). People who think we shouldn't, please
> make a good case for one of the concrete alternatives.

I'm going to try to list the pluses & minuses (At least, as I see them)
To borrow Dave's picture, it would look something like this

                   Executor
                      |
        |-----------------------------|
  <user-defined>            << ThreadedExecutor >>
                                      |
                            |--------------------|
                SingleThreadedExecutor  MultiThreadedExecutor


Functionaly these things are very similar, but they are conceptually
different (how different depends on your point of view). But then, I think
thats fitting for a hierarchy like this.

The pluses of something like this are:

+ All the documentation that is common can be left in the threaded
  executor interface.

+ Leaves more room for other user defined variations (for whatever reason
  they need them). Something like that Executor in the old concurrent
  package that launched threads for each task fits more naturally in to
  this kind of hierarchy than one where the classification is threadpool
  based or non-threadpool based. The 4th option doesn't eliminate this
  possibility, but its very likely there would be things other threaded
  executors would share in common (waiting, interrupting or shutting down,
  ...) so it makes sense to me to move that up the hierarchy.

+ ThreadedExecutor would be a good place for common functionality (like
  waiting for tasks to complete). Creates a more generalized
  structure. (If abstract, it might be a good place for setting the keep
  alive time as well). Functioanlity can be better distributed over the
  hierarchy.

- One more class to implement & one more interface/abstract.
  However, I don't think that is a big disatvantage.
  The SingleThreadedExecutor could be implemented more simply than a
  ThreadPool, or it could simply delegate to a ThreadPool. I think the
  major drawback to to this before was really more in duplicating the
  documentation; but adding that ThreadedExecutor interface solves that.

> 4. Define a special factory method or constructor instead of a new
>    class. The factory method approach is a little nicer since you can
>    give it a special name.

The pluses of something like this are:

+ One less class and one less interface/abstract to maintain

+ Fewer things to document

- Adds more responsibility to the ThreadPool, its a ThreadPool factory,
  its a fixed size pool, its a flexible sized pool, (in
  ThreadPool.Intercepts it contains a Thread factory & it contains a
  Thread termination handler).

  Its kind of like a swiss army knife :) It can do everything, but its
  alot for one class to do.


Dave gave the example of the load factor in HashMaps as being one place
where the general purposes classes in the Java library have methods to
adjust themselves to different purposes. I think that adjuting a load
factory would be more like adjusting the keep alive time. It will affect
the algorithm and maybe make things more efficent for you what your doing.

Adjusting the number of thread from 1 to many makes a bigger difference
behaviorally. The order in which tasks get executed changes, and what
those tasks can safely do might change. If you know you have only one
thread, you might not need to synchronize access to a log a file for
instance. I think separate classes emphasize that more. This I think would
be more analogous to HashSet vs TreeSet, they are both Maps but how
they get things get done is different (and one needs compareable items,
where as a multple thread executor needs tasks that actualy are thread
safe).

The 3rd option highlights the functionality of the ThreadPool more
explicity. The 4th option functionaly does the same thing, but its
presented as the subtle detail of using the ThreadPool class. The
separate classes highlight the concepts. The structure itself reflects the
purpose better, in a sense it becomes a part of the documentation; with
only the ThreadPool class, users have to read the documentation to really
understand what everything is for. With the 3rd option the intent jumps
out at them a little more.

(This would be a plus for new users, and from what I've gathered making
the library easy for new users to swallow or adapt to is one of the goals
- I'm just guessing based on some of the answers to various things I've
seen; I apologize in advance if I am wrong)

The third option is the one I prefer, I think it would be more benficial
for the end user. The 4th option would also work, but it seems to favor
an implementor more than a user.


- Eric
http://www.cse.buffalo.edu/~crahen











From crahen@cse.Buffalo.EDU Mon, 12 Aug 2002 09:46:09 -0400 (EDT)
Date: Mon, 12 Aug 2002 09:46:09 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] Structure and function

Doug Lea wrote:

> > That's true, but if as a user you find a need for a single threaded
> > executor then there are a few things you wouldn't need any more ...
[snip]
> ... and several things that you might still need, for example to
> intercept runnables before or after execution, or to keep counts of
> the number of executed tasks.

I think these are things that would apply to all Executors (non-threaded
as well); it could be better to factor this out into another interface
(maybe Excutor.Intercepts) instead of binding it to ThreadPool.

> 2. Make SingleThreadPool an unrelated class, that delegates
>    its functionality to an underlying ThreadPool. This entails
>    declaring and documenting all applicable ThreadPool methods in
>    this new class. Among other problems, this is a maintenance headache.

I didn't think of the documentation part of this. You're right, no one
wants to do that twice. :)

> 3. Same as (2) except introduce yet another interface that includes
>    those methods shared by ThreadPool and SingleThreadExecutor so the
>    methods can be declared and documented in one place. And other
>    similar interfaces for other common subsets of functionality
>    shared with other special versions of ThreadPool.

> Currently, we are doing (4). People who think we shouldn't, please
> make a good case for one of the concrete alternatives.

I'm going to try to list the pluses & minuses (At least, as I see them)
To borrow Dave's picture, it would look something like this

                   Executor
                      |
        |-----------------------------|
  <user-defined>            << ThreadedExecutor >>
                                      |
                            |--------------------|
                SingleThreadedExecutor  MultiThreadedExecutor


Functionaly these things are very similar, but they are conceptually
different (how different depends on your point of view). But then, I think
thats fitting for a hierarchy like this.

The pluses of something like this are:

+ All the documentation that is common can be left in the threaded
  executor interface.

+ Leaves more room for other user defined variations (for whatever reason
  they need them). Something like that Executor in the old concurrent
  package that launched threads for each task fits more naturally in to
  this kind of hierarchy than one where the classification is threadpool
  based or non-threadpool based. The 4th option doesn't eliminate this
  possibility, but its very likely there would be things other threaded
  executors would share in common (waiting, interrupting or shutting down,
  ...) so it makes sense to me to move that up the hierarchy.

+ ThreadedExecutor would be a good place for common functionality (like
  waiting for tasks to complete). Creates a more generalized
  structure. (If abstract, it might be a good place for setting the keep
  alive time as well). Functioanlity can be better distributed over the
  hierarchy.

- One more class to implement & one more interface/abstract.
  However, I don't think that is a big disatvantage.
  The SingleThreadedExecutor could be implemented more simply than a
  ThreadPool, or it could simply delegate to a ThreadPool. I think the
  major drawback to to this before was really more in duplicating the
  documentation; but adding that ThreadedExecutor interface solves that.

> 4. Define a special factory method or constructor instead of a new
>    class. The factory method approach is a little nicer since you can
>    give it a special name.

The pluses of something like this are:

+ One less class and one less interface/abstract to maintain

+ Fewer things to document

- Adds more responsibility to the ThreadPool, its a ThreadPool factory,
  its a fixed size pool, its a flexible sized pool, (in
  ThreadPool.Intercepts it contains a Thread factory & it contains a
  Thread termination handler).

  Its kind of like a swiss army knife :) It can do everything, but its
  alot for one class to do.


Dave gave the example of the load factor in HashMaps as being one place
where the general purposes classes in the Java library have methods to
adjust themselves to different purposes. I think that adjuting a load
factory would be more like adjusting the keep alive time. It will affect
the algorithm and maybe make things more efficent for you what your doing.

Adjusting the number of thread from 1 to many makes a bigger difference
behaviorally. The order in which tasks get executed changes, and what
those tasks can safely do might change. If you know you have only one
thread, you might not need to synchronize access to a log a file for
instance. I think separate classes emphasize that more. This I think would
be more analogous to HashSet vs TreeSet, they are both Maps but how
they get things get done is different (and one needs compareable items,
where as a multple thread executor needs tasks that actualy are thread
safe).

The 3rd option highlights the functionality of the ThreadPool more
explicity. The 4th option functionaly does the same thing, but its
presented as the subtle detail of using the ThreadPool class. The
separate classes highlight the concepts. The structure itself reflects the
purpose better, in a sense it becomes a part of the documentation; with
only the ThreadPool class, users have to read the documentation to really
understand what everything is for. With the 3rd option the intent jumps
out at them a little more.

(This would be a plus for new users, and from what I've gathered making
the library easy for new users to swallow or adapt to is one of the goals
- I'm just guessing based on some of the answers to various things I've
seen; I apologize in advance if I am wrong)

The third option is the one I prefer, I think it would be more benficial
for the end user. The 4th option would also work, but it seems to favor
an implementor more than a user.


- Eric
http://www.cse.buffalo.edu/~crahen











From crahen@cse.Buffalo.EDU Mon, 12 Aug 2002 12:40:54 -0400 (EDT)
Date: Mon, 12 Aug 2002 12:40:54 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] RE: Structure and function

On Mon, 12 Aug 2002, Eric D Crahen wrote:

> Adjusting the number of thread from 1 to many makes a bigger difference
> behaviorally. The order in which tasks get executed changes

I know Queues can order the tasks, but what I meant here is that
with 1 thread you will always maintain that order. With more than one, its
possible for the scheduling of the threads servicing the queue to cause
the actual execution of those tasks to happen in a different order than
the order the tasks were pulled from the queue.

- Eric
http://www.cse.buffalo.edu/~crahen






From crahen@cse.Buffalo.EDU Mon, 12 Aug 2002 12:40:54 -0400 (EDT)
Date: Mon, 12 Aug 2002 12:40:54 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest] RE: Structure and function

On Mon, 12 Aug 2002, Eric D Crahen wrote:

> Adjusting the number of thread from 1 to many makes a bigger difference
> behaviorally. The order in which tasks get executed changes

I know Queues can order the tasks, but what I meant here is that
with 1 thread you will always maintain that order. With more than one, its
possible for the scheduling of the threads servicing the queue to cause
the actual execution of those tasks to happen in a different order than
the order the tasks were pulled from the queue.

- Eric
http://www.cse.buffalo.edu/~crahen






From TEREKHOV@de.ibm.com Mon, 12 Aug 2002 22:31:07 +0200
Date: Mon, 12 Aug 2002 22:31:07 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: # [concurrency-interest]RE: RE :RE: JSR 166 draft API (David Holmes)


David Holmes wrote:
[...]
> To use a classic example of the BoundedBuffer:
>
>   public class BoundedBuffer {
>       Condition notFull = new Condition(this);
>       Condition notEmpty = new Condition(this);
>
>       int size = 0;
>       final int CAPACITY = 10;
>
>       public synchronized void put(Object o) {
>           while (size == CAPACITY)
>               notFull.await();
>
>           // store o
>           size++;
>           notEmpty.signalAll();
>      }
>
>      public synchronized Object get() {
>          while (size ==0)
>              notEmpty.await();
>          size--;
>          Object temp = ... // remove
>          notFull.signalAll();
>          return temp;
>      }
> }

Well, frankly, I'd probably opt for:

  public class BoundedBuffer {

      // non-recursive/non-interruptible PThreads-like "locable" thing
      Mutex      mutex   = new Mutex();
      Condition  notFull = new Condition(mutex);
      Condition  notEmpty = new Condition(mutex);
      SomeCollection buffer = new SomeCollection();

      final int CAPACITY = 10;

      public void put(Object o) {

        apply_lock_unlock_statement( mutex ) {
          while (buffer.size() == CAPACITY)
            notFull.await();
          buffer.push(o);
        }

        notEmpty.signal();

     }

     public Object get() {

       Object o;

       apply_lock_unlock_statement( mutex ) {
         while (buffer.empty())
           notEmpty.await();
         o = buffer.pop();
       }

       notFull.signal();

       return o;
     }
}

regards,
alexander.

P.S. My Butenhof's quote-of-the-day: ;-)

Unfortunately, many implementations don't do "wait morphing",
and as a result signalling while holding the mutex can result
in significant costs.

One of the main reasons for signalling while holding the mutex
is "increased predictability". However, the increase is relatively
small, and doesn't provide any absolute guarantee. (It's based on
the fact that mutex contenders and condition waiters will queue in
priority order on the mutex; but that helps only if they're all
actually waiting concurrently, and you're using realtime priority
threads on a uniprocessor.)

The only real requirements are that:

  1) The condition wait be based on a shared data PREDICATE
     condition, and

  2) The predicate is manipulated while holding the mutex
     specified in the condition wait, BEFORE effecting the
     wakeup via signal or broadcast of the condition waiter(s).

Some may find these more easy to manage when you set the predicate
and immediately signal the waiter while still holding the mutex.
You'll often want to change some value and then conditionally signal
based on the new value... if you are going to unlock first you may
need to remember the decision by copying the predicate into a local
variable to avoid unsynchronized (and hence unreliable) access after
unlocking.

This may increase the chances of spurious ("stolen") wakeups because
some other thread may change the predicate between the time you unlock
and the time the awakened thread starts running. That may argue also
in favor of signalling while you still hold the mutex despite the risk
of inefficiency. (On the other hand, stolen wakeups, and other types
of "spurious wake" can occur anyway, so this again at best somewhat
reduces the risk and cost, but cannot remove it entirely.)

Some have argued for FIFO mutexes that grant ownership in order of
request; applied to condition waiters using the mutex, that would
seem to remove (or at least reduce) the risk of stolen wakeups.
However, FIFO wakeup is relatively expensive, and substantially
reduces concurrency that is, on the whole, far more valuable.
Furthermore, nearly all intended requirements for FIFO are in
any case doomed to failure because they are based on the mistaken
idea that threads can viably COMPETE with each other (e.g., in a
"thread per client" server). Threads are inherently cooperative,
because they share far too many resources to effectively or fairly
compete; the goals of threaded programming are better served by
efficient and simple synchronization on which cooperative
applications can build their own task/data scheduling.

And then, if the thread implementation you use implements wait
morphing, the cost of signalling while you hold the mutex is
inconsequential. So one might argue that, if you have a quality
implementation, it really doesn't matter whether you hold the
mutex. ;-)



"David Holmes" <dholmes@dltech.com.au>@cs.oswego.edu on 08/08/2002 06:01:38
AM

Sent by:    concurrency-interest-admin@cs.oswego.edu


To:    "Eric D Crahen" <crahen@cse.Buffalo.EDU>,
       <concurrency-interest@altair.cs.oswego.edu>
cc:
Subject:    RE: #  [concurrency-interest]RE: RE :RE: JSR 166 draft API
       (David Holmes)


> Is the Condition class now less like a POSIX condition variable and more
> like an abstraction for a monitor? It just adding the ability to wait
> uninterruptably or will there be subclasses that sort waiter lists or
> something along those lines?

I'm not sure what you mean by this last part but the Condition class is
used
to provide the effect of multiple condition/wait queues per monitor.

To use a classic example of the BoundedBuffer:

  public class BoundedBuffer {
      Condition notFull = new Condition(this);
      Condition notEmpty = new Condition(this);

      int size = 0;
      final int CAPACITY = 10;

      public synchronized void put(Object o) {
          while (size == CAPACITY)
              notFull.await();

          // store o
          size++;
          notEmpty.signalAll();
     }

     public synchronized Object get() {
         while (size ==0)
             notEmpty.await();
         size--;
         Object temp = ... // remove
         notFull.signalAll();
         return temp;
     }
}

Condition also allows uninterruptible waiting and timedwaits that don't
require you to jump through hoops to see if you timed out.

The order in which waiting threads are signalled is not specified - as per
Object.wait().

A Condition class with ordering guarantees would have to use a "specific
notification" style approach.

David Holmes


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest








From TEREKHOV@de.ibm.com Mon, 12 Aug 2002 23:01:12 +0200
Date: Mon, 12 Aug 2002 23:01:12 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] JSR 166 draft API


David Holmes wrote:
[...]
> > The Thread class now has clearThreadLocals() and ThreadLocal now has
> > remove(), it might make sense to name the ThreadLocal method clear()
> > instead of remove, or maybe name the the Thread method
> > removeThreadLocals() just to keep it a little more consistent.
>
> There is a distinction here between clear and remove. Clearing a
threadlocal
> makes the value of that threadlocal null for that thread. Removing a
> threadlocal removes it for all threads. These two are quite different so
> different terms are used to avoid confusion.

Well, I'm quickly scanning the whole bunch of "[concurrency-interest]"
messages and maybe I've just missed the correction/clarification...
my {current} understanding is that, actually, there are THREE cases:
("removes it for all threads" aside ;-) )

  1) set( null ) -- initialValue() won't be called on the next get();

  2) remove() -- it's gone from a thread calling remove() and
     initialValue() WILL be called on the next get();

  3) clearThreadLocals -- remove() operation for "all" thread locals
     (all those who had initialValue() called and NOT remove()d).

Is this correct or not?

regards,
alexander.






From dholmes@dltech.com.au Tue, 13 Aug 2002 10:20:44 +1000
Date: Tue, 13 Aug 2002 10:20:44 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest] JSR 166 draft API

Alexander Terekhov wrote:
> Well, I'm quickly scanning the whole bunch of "[concurrency-interest]"
> messages and maybe I've just missed the correction/clarification...
> my {current} understanding is that, actually, there are THREE cases:
> ("removes it for all threads" aside ;-) )
>
>   1) set( null ) -- initialValue() won't be called on the next get();
>
>   2) remove() -- it's gone from a thread calling remove() and
>      initialValue() WILL be called on the next get();
>
>   3) clearThreadLocals -- remove() operation for "all" thread locals
>      (all those who had initialValue() called and NOT remove()d).
>
> Is this correct or not?

Not if I'm reading you right - but I'm unclear as to what you mean in number
3. Here are the details:

1. Setting a threadlocal to null defines the value of the threadlocal for
the thread concerned. It has no affect on the value of the threadlocal for
any other thread, nor does it affect any other threadlocals value for the
given thread. A threadlocal for which set has never been called will return
from a get the value specified by initialValue. (This is normal threadlocal
operation).

2. The threadlocal remove() operation clears the value of the threadlocal
for ALL threads that access that threadlocal. If a get follows a remove then
it is as if the threadlocal had never been accessed before and the value
returned by get will be the value specified by initialValue. This applies to
all threads that use that threadlocal.

3. thread.clearThreadLocals clears all of the threadlocal values that have
been used by that thread such that a subsequent get on any threadlocal will
return the value specified by initialValue.

David Holmes






From larryr@saturn.sdsu.edu 13 Aug 2002 00:41:58 -0000
Date: 13 Aug 2002 00:41:58 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]CopyOnWrite*

Nobody asked me, but since it appears there may
be CopyOnWriteArrayList and CopyOnWriteArraySet in
java.util.concurrent, I thought it might be a good
excuse to say I would love a CopyOnWriteByteBuffer,
or a CopyOnWriteByteArray which is essentially just
a COW wrapper for a byte[].  I have no justification
related to concurrency, but I do not see why those
other classes need to be there either. :-)


Larry





From dholmes@dltech.com.au Tue, 13 Aug 2002 10:40:15 +1000
Date: Tue, 13 Aug 2002 10:40:15 +1000
From: David Holmes dholmes@dltech.com.au
Subject: # [concurrency-interest]RE: RE :RE: JSR 166 draft API (David Holmes)

Alex Terekhov wrote in part:
> Well, frankly, I'd probably opt for:
>
>   public class BoundedBuffer {
>
>       // non-recursive/non-interruptible PThreads-like "locable" thing
>       Mutex      mutex   = new Mutex();
>       Condition  notFull = new Condition(mutex);
>       Condition  notEmpty = new Condition(mutex);
>       SomeCollection buffer = new SomeCollection();
>
>       final int CAPACITY = 10;
>
>       public void put(Object o) {
>
>         apply_lock_unlock_statement( mutex ) {
>           while (buffer.size() == CAPACITY)
>             notFull.await();
>           buffer.push(o);
>         }
>
>         notEmpty.signal();
>
>      }

If we were to go the path that defines a "mutex" class that works with
conditions then the best you would get is:

   public class BoundedBuffer {

       Mutex      mutex   = new Mutex();
       Condition  notFull = new Condition(mutex);
       Condition  notEmpty = new Condition(mutex);
       SomeCollection buffer = new SomeCollection();

       final int CAPACITY = 10;

       public void put(Object o) {
         mutex.acquire();
         try {
           while (buffer.size() == CAPACITY)
             notFull.await();
           buffer.push(o);
           notEmpty.signal();
         }
	  finally {
           mutex.release();
        }
      }
This would probably perform worse than a version that uses synchronized.

Allowing signals without holding the mutex is not on the cards.

> P.S. My Butenhof's quote-of-the-day: ;-)

That's not a quote it's a lecture! :-)

What Dave Butenhof says is perfectly sound for a pthreads implementation -
that is a very low-level system library - and he is the expert on that. We
are not at that level. When you work with different concurrency constructs,
such as monitors, then there are distinct advantages to holding the "lock"
while signalling - the main one being that the lock itself can be used to
protect access to the state of the condition variable (this is not true in
posix because there is not a guarantee that a condition variable is only
used with one mutex). Further, the performance implications really only
arise for naive implementations as a signal becomes a queue transfer
operation only (I guess that is what Dave means by "wait morphing"). From a
programming perspective having to hold the lock while signalling reinforces
that the lock must be held when changing the state that the condition is
guarding. This makes it a much safer programming practice and avoids a very
common error.

Cheers,
David Holmes





From TEREKHOV@de.ibm.com Tue, 13 Aug 2002 11:18:42 +0200
Date: Tue, 13 Aug 2002 11:18:42 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest]thread-local variables

David Holmes wrote:

> 1. Setting a threadlocal to null defines the value of the threadlocal for
> the thread concerned. It has no affect on the value of the threadlocal
for
> any other thread, nor does it affect any other threadlocals value for the
> given thread. A threadlocal for which set has never been called will
return
> from a get the value specified by initialValue.

Yes, but initialValue() is called ``nevertheless'' ["called once
per accessing thread for each thread-local", brand new remove()
and clearThreadLocals() aside for a moment]:

"....
  protected Object initialValue()

    Returns the current thread's initial value for this thread-local
    variable. This method will be called once per accessing thread for
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^

    each thread-local, the first time each thread accesses the variable
    with the get() or set(Object) method.
                      ^^^^^^^^^^^^^^^^^^

 ...."

> 2. The threadlocal remove() operation clears the value of the threadlocal
> for ALL threads that access that threadlocal. If a get follows a remove
then
> it is as if the threadlocal had never been accessed before and the value
> returned by get will be the value specified by initialValue. This applies
to
> all threads that use that threadlocal.

THAT is really interesting... Are you saying that JSR-166-EG decided to
make get() and set() "internally"-*synchronized* operations (w.r.t. other
threads and remove()), to begin with?

> 3. thread.clearThreadLocals clears all of the threadlocal values that
have
> been used by that thread such that a subsequent get on any threadlocal
will
> return the value specified by initialValue.

That's OK. (apart from rather unfortunate [IMO] LACK of some *optional*
interface/DisposableThreadLocal-"hook" for timely "dispose" action(s)
for each non-null thread-local invoked in the context of the terminating
thread... and on brand new clearThreadLocals(), of course. ;-) ;-) )

regards,
alexander.


"David Holmes" <dholmes@dltech.com.au>@cs.oswego.edu on 08/13/2002 02:20:44
AM

Sent by:    concurrency-interest-admin@cs.oswego.edu


To:    <concurrency-interest@altair.cs.oswego.edu>
cc:
Subject:    RE: [concurrency-interest] JSR 166 draft API


Alexander Terekhov wrote:
> Well, I'm quickly scanning the whole bunch of "[concurrency-interest]"
> messages and maybe I've just missed the correction/clarification...
> my {current} understanding is that, actually, there are THREE cases:
> ("removes it for all threads" aside ;-) )
>
>   1) set( null ) -- initialValue() won't be called on the next get();
>
>   2) remove() -- it's gone from a thread calling remove() and
>      initialValue() WILL be called on the next get();
>
>   3) clearThreadLocals -- remove() operation for "all" thread locals
>      (all those who had initialValue() called and NOT remove()d).
>
> Is this correct or not?

Not if I'm reading you right - but I'm unclear as to what you mean in
number
3. Here are the details:

1. Setting a threadlocal to null defines the value of the threadlocal for
the thread concerned. It has no affect on the value of the threadlocal for
any other thread, nor does it affect any other threadlocals value for the
given thread. A threadlocal for which set has never been called will return
from a get the value specified by initialValue. (This is normal threadlocal
operation).

2. The threadlocal remove() operation clears the value of the threadlocal
for ALL threads that access that threadlocal. If a get follows a remove
then
it is as if the threadlocal had never been accessed before and the value
returned by get will be the value specified by initialValue. This applies
to
all threads that use that threadlocal.

3. thread.clearThreadLocals clears all of the threadlocal values that have
been used by that thread such that a subsequent get on any threadlocal will
return the value specified by initialValue.

David Holmes



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






From dholmes@dltech.com.au Wed, 14 Aug 2002 09:27:11 +1000
Date: Wed, 14 Aug 2002 09:27:11 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]thread-local variables

Alexander Terekhov wrote:
> Yes, but initialValue() is called ``nevertheless'' ["called once
> per accessing thread for each thread-local", brand new remove()
> and clearThreadLocals() aside for a moment]:
>
> "....
>   protected Object initialValue()
>
>     Returns the current thread's initial value for this thread-local
>     variable. This method will be called once per accessing thread for
>                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
>
>     each thread-local, the first time each thread accesses the variable
>     with the get() or set(Object) method.
>                       ^^^^^^^^^^^^^^^^^^
>
>  ...."

This looks like a documentation bug. If you look at the implementation of
ThreadLocal.set in the JDK there is no call to initialValue. I can't see
what you could possibly do with initialValue in a call to set.

> > 2. The threadlocal remove() operation clears the value of the
> > threadlocal for ALL threads that access that threadlocal.
>
> THAT is really interesting... Are you saying that JSR-166-EG decided to
> make get() and set() "internally"-*synchronized* operations (w.r.t. other
> threads and remove()), to begin with?

My sincerest apologies. I misunderstood what the intent of the remove
operation was. It does in fact only remove the entry for the calling thread
from the threadlocal's internal table. This means that if the next call on
the threadlocal is get() then initialValue() will be returned for that
thread.

Sorry for the confusion.

> That's OK. (apart from rather unfortunate [IMO] LACK of some *optional*
> interface/DisposableThreadLocal-"hook" for timely "dispose" action(s)
> for each non-null thread-local invoked in the context of the terminating
> thread... and on brand new clearThreadLocals(), of course. ;-) ;-) )

Sounds like a form of finalization to me. ;-)

David Holmes





From TEREKHOV@de.ibm.com Wed, 14 Aug 2002 14:50:42 +0200
Date: Wed, 14 Aug 2002 14:50:42 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest]thread-local variables


David Holmes wrote:
[...]
> >     each thread-local, the first time each thread accesses the variable
> >     with the get() or set(Object) method.
> >                       ^^^^^^^^^^^^^^^^^^
> >
> >  ...."
>
> This looks like a documentation bug. If you look at the implementation of
> ThreadLocal.set in the JDK there is no call to initialValue. I can't see
> what you could possibly do with initialValue in a call to set.

DISPOSE it immediately! (close file(s)/shutdown something, etc. ;-) )

Seriously, I also think that it's a docu-bug and that it needs to be
fixed ASAP.

[...]
> > That's OK. (apart from rather unfortunate [IMO] LACK of some *optional*
> > interface/DisposableThreadLocal-"hook" for timely "dispose" action(s)
> > for each non-null thread-local invoked in the context of the
terminating
> > thread... and on brand new clearThreadLocals(), of course. ;-) ;-) )
>
> Sounds like a form of finalization to me. ;-)
                        ^^^^^^^^^^^^

Please, please, don't get me started on this... ;-) ;-)

regards,
alexander.






From Andreas.Sterbenz@sun.com Wed, 14 Aug 2002 17:04:44 +0100
Date: Wed, 14 Aug 2002 17:04:44 +0100
From: Andreas Sterbenz Andreas.Sterbenz@sun.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:
> 
> The Javadocs are at:
>   http://gee.cs.oswego.edu/dl/concurrent/index.html

A few comments from a different angle:

  . I would prefer to see the new concurrent Collection classes be added 
to java.util rather than j.u.concurrent. Reason is that this is where 
all the general purpose Collection implementations in J2SE live now, 
including the synchronized implementations.

  . Clock does not indicate the time, therefore it is not a clock. It is 
a counter. I am not sure if something like Counter, ClockedCounter, or 
MonotonicCounter would be a much better name, though.

  . lock.attempt(long, Clock) seems a bit inconvenient. Instead of 
something like
   if (lock.attempt(5, Clock.seconds)) ...
I would prefer something like
   private final static Clock fiveSecondClock = Clock.seconds.divide(5);
   ...
   if (lock.attempt(fiveSecondClock)) ...
In other words, the 'time' argument would always be 1 and you pass an 
appropriate Clock object instead. someClock.divide(n) returns a Clock 
object that advances 1 step for every n steps of someClock.

[I speak as Joe programmer, not as a Sun employee]

Andreas.





From joshua.bloch@sun.com Wed, 14 Aug 2002 09:57:21 -0700
Date: Wed, 14 Aug 2002 09:57:21 -0700
From: Joshua Bloch joshua.bloch@sun.com
Subject: [concurrency-interest] JSR 166 draft API

David,

> 2. The threadlocal remove() operation clears the value of the threadlocal
> for ALL threads that access that threadlocal.

  As I understand it, this is not the case! It clears the value only for the
calling thread.  One thread has no right to yank the values out from other
threads!

                                Regards,

                                Josh







From dl@cs.oswego.edu Sat, 17 Aug 2002 10:07:20 -0400
Date: Sat, 17 Aug 2002 10:07:20 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] CopyOnWrite*

Larry Riedel wrote:

> Nobody asked me, but since it appears there may
> be CopyOnWriteArrayList and CopyOnWriteArraySet in
> java.util.concurrent, I thought it might be a good
> excuse to say I would love a CopyOnWriteByteBuffer,
> or a CopyOnWriteByteArray which is essentially just
> a COW wrapper for a byte[].  

I don't see what kind of API you have in mind here.
Could you flesh this out? 

> I have no justification
> related to concurrency, but I do not see why those
> other classes need to be there either. :-)

The intent is for java.util.concurrent to supply classes that are
frequently needed in concurrent programs.  The CopyOnWriteArray*
classes are useful in concurrent programs dealing with event
multicast, observers, etc, but are essentially never useful in
non-concurrent programs.

-Doug





From larryr@saturn.sdsu.edu 17 Aug 2002 18:29:32 -0000
Date: 17 Aug 2002 18:29:32 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest] CopyOnWrite*

Doug Lea wrote:

> Larry Riedel wrote:
>
> > I would love a CopyOnWriteByteBuffer, or a
> > CopyOnWriteByteArray which is essentially just a COW wrapper
> > for a byte[].
>
> I don't see what kind of API you have in mind here.  Could you
> flesh this out?

Essentially java.nio.ByteBuffer with a COW flag to provide
the semantics of MAP_PRIVATE instead of its usual MAP_SHARED,
ideally with a way to specify regions instead of all of it.
The main reasons I would like a ByteArray version are that
ByteBuffer is not really extendable, and it has a lot of state
stuff about a current "position" which I find cumbersome when
I am just using it as a shared array of bytes.


> > I have no justification related to concurrency, but I do not
> > see why those other classes need to be there either. :-)
>
> The intent is for java.util.concurrent to supply classes
> that are frequently needed in concurrent programs.  The
> CopyOnWriteArray* classes are useful in concurrent programs
> dealing with event multicast, observers, etc, but are
> essentially never useful in non-concurrent programs.

Since I think of every Java program as executing in an essentially
concurrent environment, the distinction is not that clear to me, but I
do not disagree with it.  For example I see Observer, Observable, and
EventListener in java.util, and I am comfortable with the idea of
seeing CopyOnWrite* there, but I could appreciate the idea that, for
example, the expert group has more autonomy for java.util.concurrent.

In any case the distinctions between something which is intrinsically
coupled to concurrency (e.g. mutex), and something which may only be
high correlated with concurrency (e.g. CopyOnWriteArrayList) are not
something about which I feel I have much useful/interesting to say.


Larry





From dl@cs.oswego.edu Sat, 17 Aug 2002 19:12:15 -0400
Date: Sat, 17 Aug 2002 19:12:15 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] JSR 166 draft API

Andreas Sterbenz wrote:

> Something like
>    if (lock.attempt(5, Clock.seconds)) ...
> I would prefer something like
>    private final static Clock fiveSecondClock = Clock.seconds.divide(5);
>    ...
>    if (lock.attempt(fiveSecondClock)) ...

The reason we rejected this and other approaches is that people doing
high-precision timing absolutely do not want to construct an Object
every time they invoke a time-based function.

The current solution is only a little inconvenient and only in some
usages, but reads well and doesn't impose any inefficiencies.

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  




From dl@cs.oswego.edu Sat, 17 Aug 2002 20:08:13 -0400
Date: Sat, 17 Aug 2002 20:08:13 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest] CopyOnWrite*

Larry Riedel wrote:

> > I don't see what kind of API you have in mind here.  Could you
> > flesh this out?
> 
> Essentially java.nio.ByteBuffer with a COW flag to provide
> the semantics of MAP_PRIVATE instead of its usual MAP_SHARED,
> ideally with a way to specify regions instead of all of it.
> The main reasons I would like a ByteArray version are that
> ByteBuffer is not really extendable, and it has a lot of state
> stuff about a current "position" which I find cumbersome when
> I am just using it as a shared array of bytes.

This sounds like a job for the nio revision JSR (which I believe
will form one of these days). I'll relay. 

-Doug




From jozart@csi.com Sun, 18 Aug 2002 13:39:50 -0700
Date: Sun, 18 Aug 2002 13:39:50 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest]Condition thoughts

Eric,

I don't have any comment on the gist of your message, unfortunately, but I
noticed a recurring pattern in the code snippets that raised a red flag:

  public synchronized void await() {
    try {
      lock.release();
      wait();
    } finally {
      lock.acquire();
    }
  }

I would code this as follows, moving the code that enters the protected
state *before* the try block:

  public synchronized void await() {
    lock.release(); // enter state
    try {
      wait();
    } finally {
      lock.acquire(); // leave state
    }
  }

This way, if there's a problem entering the state, the await() won't
compound the problem even further trying to leave a state that was never
entered.

Of course, acquire() is usually the method that enters the state and
release() is the one that leaves the state, but I don't think it matters to
try-finally if they are reversed:

  public synchronized void await() {
    lock.acquire(); // enter state
    try {
      work();
    } finally {
      lock.release(); // exit state
    }
  }

Using the try-finally in the way I've demonstrated is particularly important
when using locks that do *not* maintain ownership, such as the reader-lock
we've been kicking around.  For example, if lock.acquire() were moved inside
the try, then a failure in acquire() could release someone else's lock count
in the finally, thereby permitting a writer to acquire the resource even
though a reader is still active.

Note that lock.acquire() can fail if the thread has been interrupted.
(Moving acquire inside the try will teach 'em not to interrupt!)


By the way, both of the monitorEnter(Object[]) and monitorExit(Object[])
implementations call monitorEnter(null, Object[]).  I'm guessing that's a
typo.



----- Original Message -----
From: "Eric D Crahen" <crahen@cse.Buffalo.EDU>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, August 09, 2002 5:29 PM
Subject: [concurrency-interest]Condition thoughts


I was looking at the Condition class a little bit more today. I
implemented a simplified version (because I didn't want to write Clock
classes too) to expirement with it a little bit to get a better feel for
it; I attached it at the bottom of this message incase anyone want to
play with it. Anyway, these are the thoughts I was having about
the Condition interface.

One of the things I really liked about this version compared to the
previous version was that I felt it helped make things more expressive.
You don't need as many try { } finally { } blocks, so things a less
cluttered; and classes like,

class aClass { // pseduocode

  Condition cond = new Condition(this);

  public synchronized void aMethod() {

     // ...

     while(someConditionNotMet())
       cond.wait();

     // ...

  }

}

seem very clear as well (at least given my current understanding of it).

One of the things I found somewhat awkward about this is that is mixes in
objects that are interacting with the primitve language constructs. It may
just be my personal preference, but I just feel like it's missing some
kind of interaction with the Lock hierachy.

Its a shame that I can't use non-recursive locks, or use locks like
RecursiveLock whose acquire()s can be interrupted with a Condtion.
I know the general consensus seems to be recursive locks are better, but I
still think it would be good leave the choice to user. Doug Lea mentioned
that we can realize non-recursive locks through a Semaphore with the an
intial size of 1 - so it is possible to use them if you'd like. Please
don't think I'm trying to start a debate or anything, I'm just explaining
my thoughts.

Now, after Dave's explaination of how this Condition would work, and after
implementing something concrete to play with today I was looking for a way
to keep the thing I liked, and to resolve the thing I didn't like. This is
what I came up with:

If to accomplish this, something would be added that was allowed to do
unbalanced monitorenter/monitorexits; why not make a Lock wrapper for an
objects monitor. Something like this could be used,

public ObjectLock implements Lock { // pseduocode

  private static MonitorHelper helper = new MonitorHelper();
  private Object lock;

  public ObjectLock(Object lock) {
    this.lock = lock;
  }

  public void acquire()
    throws InterruptedException {

    helper.monitorEnter(lock);

  }

  public void release()
    throws InterruptedException {

    helper.monitorExit(lock);

  }

}

to provide a Lock interface to an objects monitor. The Condition class
then might be revised to work with a Lock instead of an Object,

class Condition { // pseduocode

  private Lock lock;

  public Condition(Lock lock) {
    this.lock = lock;
  }

  public synchronized void await() {
    try {
      lock.release();
      wait();
    } finally {
      lock.acquire();
    }
  }

  // ...
}

So now, the small example could be rewritten like this,

class aClass {

  Lock lock = new ObjectLock(this);
  Condition cond = new Condition(lock);

  public synchronized void aMethod() {

     // ...

     while(someConditionNotMet())
       cond.wait();

     // ...

  }

}

What I think is nice about this is this:

 You can use the synchronized keyword when its appropriate and avoid the
 excessive try {} finally {} block that you used to have to write when
 using Locks only.

 The ObjectLock fits into the Lock hierachy, and for me it just feels a
 little better. It fits better with OO design of the rest of the package.
 Again, this is just my opionion, but maybe some others also would like
this.

 The part I like the most is that now the Lock the Condition works with is
 interchangeable with other Locks. I could use a non-recusive lock by
 changing one line [lock = new Semaphore(1)] or, if I wanted to, I could
 use a lock with an interruptible acquire by changing one line [lock = new
 RecursiveLock()]

What do you (anyone) think?

This is the implementation I mentioned earlier. Basically, it creates a
class that will attempt monitorenter & monitorexit when certain methods
are called. Depending on your VM, it may or may not be allowed; it seems
to be an optional restriction. I've been using IBM's 1.3.0 VM today to
make this, and it did not complain. Sun's 1.4.0 VM does check to make sure
monitorenter & monitorexit are balanced in each method, so if you run this
on that VM you'll see an IllegalMonitorStateException. There might be an
option to turn that off, but I couldn't find it.

(It was all done with 100% Java by the way, I used a bytecode toolkit
thats part of the polymorph package on my web page to create the
MonitorHelper)

// The source is also at
// http://www.cse.buffalo.edu/~crahen/jsr166/Condition.java
----------------------------------------------------------------------------
-
// Condition.java begin

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * @class Condition
 * @author Eric Crahen
 *
 * Condition implementation to expirement with
 */
public class Condition {

  private static MonitorHelper helper = new MonitorHelper();

  private Object sync = new Object();
  private Object[] param;

  public Condition(Object lock)
    throws InterruptedException {

    if(lock == null)
      throw new IllegalArgumentException();

    param = new Object[]{lock};

  }

  public void await() throws InterruptedException {

    synchronized(sync) {

      try {
        helper.monitorExit(param);
        sync.wait();
      } finally {
        helper.monitorEnter(param);
      }

    }

  }


  public void signal() {

    synchronized(sync) { sync.notify(); }

  }

  public void signalAll() {

    synchronized(sync) { sync.notifyAll(); }

  }

  static class MonitorHelper extends ClassLoader {

  /**
   * package java.util.concurrent;
   * public abstract class Monitor {
   *   protected Monitor();
   *   public static void enterMonitor(Object o);
   *   public static void exitMonitor(Object o);
   * }
   */
  private final static byte[] bytecode = new byte[] {
   (byte)0xca, (byte)0xfe, (byte)0xba, (byte)0xbe,    0x00, 0x03,
0x00, 0x2d,   0x00, 0x0d, 0x01, 0x00,   0x1c, 0x6a, 0x61, 0x76,
0x61, 0x2f, 0x75, 0x74,   0x69, 0x6c, 0x2f, 0x63,     0x6f, 0x6e, 0x63,
0x75,   0x72, 0x72, 0x65, 0x6e,   0x74, 0x2f, 0x4d, 0x6f,   0x6e,
0x69, 0x74, 0x6f,   0x72, 0x07, 0x00, 0x01,   0x01, 0x00, 0x10, 0x6a,
0x61, 0x76, 0x61, 0x2f,   0x6c, 0x61, 0x6e, 0x67,   0x2f, 0x4f, 0x62,
0x6a,   0x65, 0x63, 0x74, 0x07,   0x00, 0x03, 0x01, 0x00,   0x06,
0x3c, 0x69, 0x6e,   0x69, 0x74, 0x3e, 0x01,   0x00, 0x03, 0x28, 0x29,
0x56, 0x01, 0x00, 0x04,   0x43, 0x6f, 0x64, 0x65,   0x0c, 0x00,
0x05, 0x00,   0x06, 0x0a, 0x00, 0x04,   0x00, 0x08, 0x01, 0x00,
0x0c, 0x6d, 0x6f, 0x6e,   0x69, 0x74, 0x6f, 0x72,   0x45, 0x6e, 0x74,
0x65,   0x72, 0x01, 0x00, 0x15,   0x28, 0x4c, 0x6a, 0x61,   0x76,
0x61, 0x2f, 0x6c,   0x61, 0x6e, 0x67, 0x2f,   0x4f, 0x62, 0x6a, 0x65,
0x63, 0x74, 0x3b, 0x29,   0x56, 0x01, 0x00, 0x0b,   0x6d, 0x6f, 0x6e,
0x69,   0x74, 0x6f, 0x72, 0x45,   0x78, 0x69, 0x74, 0x04,   0x21,
0x00, 0x02, 0x00,   0x04, 0x00, 0x00, 0x00,   0x00, 0x00, 0x03, 0x00,
0x04, 0x00, 0x05, 0x00,   0x06, 0x00, 0x01, 0x00,   0x07, 0x00,
0x00, 0x00,   0x11, 0x00, 0x02, 0x00,   0x01, 0x00, 0x00, 0x00,
0x05, 0x2a, (byte)0xb7, 0x00,   0x09, (byte)0xb1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x09,   0x00, 0x0a, 0x00, 0x0b,   0x00, 0x01, 0x00,
0x07,   0x00, 0x00, 0x00, 0x0f,   0x00, 0x01, 0x00, 0x01,   0x00,
0x00, 0x00, 0x03,   0x2a, (byte)0xc2, (byte)0xb1, 0x00,   0x00, 0x00,
0x00, 0x00,   0x09, 0x00, 0x0c, 0x00,   0x0b, 0x00, 0x01, 0x00,
0x07, 0x00, 0x00, 0x00,   0x0f, 0x00, 0x01, 0x00,   0x01, 0x00, 0x00,
0x00,   0x03, 0x2a, (byte)0xc3, (byte)0xb1,   0x00, 0x00, 0x00, 0x00,
0x00, 0x00
  };
  private static Method monitorEnter;
  private static Method monitorExit;

  MonitorHelper() {

    try {

      Class clazz = defineClass(null, bytecode, 0, bytecode.length);

      monitorEnter = clazz.getMethod("monitorEnter", new
Class[]{Object.class});
      monitorExit =  clazz.getMethod("monitorExit",  new
Class[]{Object.class});
    } catch(Throwable t) {

      t.printStackTrace();
      System.exit(0);

    }

  }

  void monitorEnter(Object[] o) {

    Error err = null;

    try {
      monitorEnter.invoke(null, o);
    } catch(InvocationTargetException e) {

      Throwable t = e.getTargetException();
      if(t instanceof RuntimeException)
        throw (RuntimeException)t;

      err = new Error(t);

    } catch(Exception e) {
      err = new Error(e);
    }

    if(err != null)
      throw err;

  }

  void monitorExit(Object[] o) {

    Error err = null;

    try {
      monitorEnter.invoke(null, o);
    } catch(InvocationTargetException e) {

      Throwable t = e.getTargetException();
      if(t instanceof RuntimeException)
        throw (RuntimeException)t;

      err = new Error(t);

    } catch(Exception e) {
      err = new Error(e);
    }

    if(err != null)
      throw err;

  }

  }

}

// Condition.java end



- Eric
http://www.cse.buffalo.edu/~crahen



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From crahen@cse.Buffalo.EDU Sun, 18 Aug 2002 18:20:27 -0400 (EDT)
Date: Sun, 18 Aug 2002 18:20:27 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Condition thoughts

On Sun, 18 Aug 2002, Joseph Bowbeer wrote:

> I noticed a recurring pattern in the code snippets that raised a red
> flag:
>
>   public synchronized void await() {
>     try {
>       lock.release();
>       wait();
>     } finally {
>       lock.acquire();
>     }
>   }
>
> I would code this as follows, moving the code that enters the protected
> state *before* the try block:

Thanks for pointing that out!

> By the way, both of the monitorEnter(Object[]) and monitorExit(Object[])
> implementations call monitorEnter(null, Object[]).  I'm guessing that's a
> typo.

Thats right, its calling static methods with reflection, so the first
parameter is null since there is no instance of MonitorHelper to invoke
on, the Object[] contains the parameters which in this case is just the
reference to the objects whose monitor needs acquiring or releasing.


- Eric
http://www.cse.buffalo.edu/~crahen










From crahen@cse.Buffalo.EDU Sun, 18 Aug 2002 18:32:04 -0400 (EDT)
Date: Sun, 18 Aug 2002 18:32:04 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Condition thoughts

Whoops, I meant since there is no Monitor instance (the class you see the
bytecode for is named java.util.concurrent.Monitor). The MonitorHelper is
invoking static methods of Monitor via reflection.


- Eric
http://www.cse.buffalo.edu/~crahen





From Andreas.Sterbenz@sun.com Mon, 19 Aug 2002 16:16:42 +0100
Date: Mon, 19 Aug 2002 16:16:42 +0100
From: Andreas Sterbenz Andreas.Sterbenz@sun.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote:
> 
>>Something like
>>   if (lock.attempt(5, Clock.seconds)) ...
>>I would prefer something like
>>   private final static Clock fiveSecondClock = Clock.seconds.divide(5);
>>   ...
>>   if (lock.attempt(fiveSecondClock)) ...
> 
> The reason we rejected this and other approaches is that people doing
> high-precision timing absolutely do not want to construct an Object
> every time they invoke a time-based function.

Just to clarify, I was suggesting one Object per VM invocation and 
timing interval, not one for each method invocation.

Andreas.





From karthik_m@huawei.com Thu, 22 Aug 2002 17:25:07 +0800
Date: Thu, 22 Aug 2002 17:25:07 +0800
From: Karthik karthik_m@huawei.com
Subject: [concurrency-interest]FJRunnerTask

Hi all,
   I have doubt in the FJTask which gets the current FJRunnerTask.

	     /**
   		* Return the FJTaskRunner thread running the current FJTask.
		* Most FJTask methods are just relays to their current
		* FJTaskRunners, that perform the indicated actions.
	      * @exception ClassCastException if caller thread is not a
	      * running FJTask.
            **/

	  public static FJTaskRunner getFJTaskRunner() {
		    return (FJTaskRunner)(Thread.currentThread());
	  }
	The Thread.currentThread will always return the Thread Object but not the
sub class and it will always get the ClassCastException.

Thanks,
M Karthik,


-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Eric D
Crahen
Sent: Monday, August 19, 2002 6:20 AM
To: Joseph Bowbeer
Cc: concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest]Condition thoughts


On Sun, 18 Aug 2002, Joseph Bowbeer wrote:

> I noticed a recurring pattern in the code snippets that raised a red
> flag:
>
>   public synchronized void await() {
>     try {
>       lock.release();
>       wait();
>     } finally {
>       lock.acquire();
>     }
>   }
>
> I would code this as follows, moving the code that enters the protected
> state *before* the try block:

Thanks for pointing that out!

> By the way, both of the monitorEnter(Object[]) and monitorExit(Object[])
> implementations call monitorEnter(null, Object[]).  I'm guessing that's a
> typo.

Thats right, its calling static methods with reflection, so the first
parameter is null since there is no instance of MonitorHelper to invoke
on, the Object[] contains the parameters which in this case is just the
reference to the objects whose monitor needs acquiring or releasing.


- Eric
http://www.cse.buffalo.edu/~crahen







_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From dholmes@dltech.com.au Fri, 23 Aug 2002 09:32:20 +1000
Date: Fri, 23 Aug 2002 09:32:20 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]FJRunnerTask

>    I have doubt in the FJTask which gets the current FJRunnerTask.
>
> 	     /**
>    		* Return the FJTaskRunner thread running the
> current FJTask.
> 		* Most FJTask methods are just relays to their current
> 		* FJTaskRunners, that perform the indicated actions.
> 	      * @exception ClassCastException if caller
> thread is not a
> 	      * running FJTask.
>             **/
>
> 	  public static FJTaskRunner getFJTaskRunner() {
> 		    return (FJTaskRunner)(Thread.currentThread());
> 	  }
> 	The Thread.currentThread will always return the
> Thread Object but not the sub class and it will always get the
> ClassCastException.

No it won't. In Java a reference can always be cast to the actual type
of the Object regardless of the type returned by the method.
Thread.currentThread returns a reference to the currently executing
Thread object. That object will an instance of Thread or a subclass of
Thread such as FJTaskRunner. If the current thread is in fact an
FJTaskRunner then the cast succeeds; else the cast fails and the
operaton fails, as it should.

David Holms





From jozart@csi.com Thu, 22 Aug 2002 17:57:05 -0700
Date: Thu, 22 Aug 2002 17:57:05 -0700
From: Joseph Bowbeer jozart@csi.com
Subject: [concurrency-interest]Clock.MICROSECONDS?

Doug asked that I canvas the groups:

Q: Should the Clock instance names be capitalized, e.g., SECONDS and
MILLISECONDS?

Or should they remain in lowercase?

 http://gee.cs.oswego.edu/dl/concurrent/java/lang/Clock.html


I believe ALL CAPS is prescribed by JDK coding standards, eg, Color.RED.
(The Color constants were originally lowercase, and uppercase versions were
later added.)

Doug says MICROSECONDS looks ugly and points to System.in.

I counter that System.in is not a constant:

    public static void setIn(InputStream in) {
        checkIO();
        setIn0(in);
    }


What do you think?







From larryr@saturn.sdsu.edu 23 Aug 2002 05:14:05 -0000
Date: 23 Aug 2002 05:14:05 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Clock.MICROSECONDS?

> Q: Should the Clock instance names be capitalized,
> e.g., SECONDS and MILLISECONDS?
> [...]
> Doug says MICROSECONDS looks ugly and points to System.in.
> 
> What do you think?

I agree that it looks ugly, but I am afraid having it
lowercase would seem to be inconsistent with the rest
of the JDK APIs.  I suspect if they were to do it now
it would be System.IN, or maybe System.in().

Maybe since the constants are already qualified by
"Clock.", it would be sufficient to use abbreviations,
like Clock.MSEC, Clock.NSEC, Clock.SEC, Clock.USEC?


Larry





From vijay@saraswat.org Fri, 23 Aug 2002 05:44:24 -0400
Date: Fri, 23 Aug 2002 05:44:24 -0400
From: Vijay Saraswat vijay@saraswat.org
Subject: [concurrency-interest]Clock.MICROSECONDS?

My choice is for consistency over prettiness. Hence SECONDS over seconds.

Joseph Bowbeer wrote:

> Doug asked that I canvas the groups:
>
> Q: Should the Clock instance names be capitalized, e.g., SECONDS and
> MILLISECONDS?
>
> Or should they remain in lowercase?
>
>  http://gee.cs.oswego.edu/dl/concurrent/java/lang/Clock.html
>
> I believe ALL CAPS is prescribed by JDK coding standards, eg, Color.RED.
> (The Color constants were originally lowercase, and uppercase versions were
> later added.)
>
> Doug says MICROSECONDS looks ugly and points to System.in.
>
> I counter that System.in is not a constant:
>
>     public static void setIn(InputStream in) {
>         checkIO();
>         setIn0(in);
>     }
>
> What do you think?
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





From tom.may@infospace.com 23 Aug 2002 10:49:59 -0700
Date: 23 Aug 2002 10:49:59 -0700
From: Tom May tom.may@infospace.com
Subject: [concurrency-interest]Clock.MICROSECONDS?

Larry Riedel <larryr@saturn.sdsu.edu> writes:

> > Q: Should the Clock instance names be capitalized,
> > e.g., SECONDS and MILLISECONDS?
> > [...]
> > Doug says MICROSECONDS looks ugly and points to System.in.
> > 
> > What do you think?
> 
> I agree that it looks ugly, but I am afraid having it
> lowercase would seem to be inconsistent with the rest
> of the JDK APIs.  I suspect if they were to do it now
> it would be System.IN, or maybe System.in().
> 
> Maybe since the constants are already qualified by
> "Clock.", it would be sufficient to use abbreviations,
> like Clock.MSEC, Clock.NSEC, Clock.SEC, Clock.USEC?

I just read Clock.MSEC as microseconds until I saw Clock.USEC.  I'm
for spelling it out.

Tom.




From larryr@saturn.sdsu.edu 23 Aug 2002 19:51:29 -0000
Date: 23 Aug 2002 19:51:29 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Clock.MICROSECONDS?

> > Maybe since the constants are already qualified by
> > "Clock.", it would be sufficient to use abbreviations,
> > like Clock.MSEC, Clock.NSEC, Clock.SEC, Clock.USEC?
> 
> I just read Clock.MSEC as microseconds until I
> saw Clock.USEC.  I'm for spelling it out.

For what its worth, those are the abbreviations used in Mozilla 

http://www.mozilla.org/projects/nspr/reference/html/prtime.html#21158

and Doug Schmidt's ACE framework

http://doc.ece.uci.edu/Doxygen/Current/html/ace/classACE__Time__Value.html


Larry





From tom.may@infospace.com 23 Aug 2002 13:42:42 -0700
Date: 23 Aug 2002 13:42:42 -0700
From: Tom May tom.may@infospace.com
Subject: [concurrency-interest]Clock.MICROSECONDS?

Larry Riedel <larryr@saturn.sdsu.edu> writes:

> > > Maybe since the constants are already qualified by
> > > "Clock.", it would be sufficient to use abbreviations,
> > > like Clock.MSEC, Clock.NSEC, Clock.SEC, Clock.USEC?
> > 
> > I just read Clock.MSEC as microseconds until I
> > saw Clock.USEC.  I'm for spelling it out.
> 
> For what its worth, those are the abbreviations used in Mozilla 
> 
> http://www.mozilla.org/projects/nspr/reference/html/prtime.html#21158
> 
> and Doug Schmidt's ACE framework
> 
> http://doc.ece.uci.edu/Doxygen/Current/html/ace/classACE__Time__Value.html

In Doug's case, timeval itself uses usec so Doug probably just
followed the convention of the underlying layer, which is sensible.

In java we've got millis and nanos in a few places, which are less
confusable.

I still think it would be too easy to create or overlook a bug like this:

    // Blah blah blah microseconds blah blah blah

    doSomething(... CLOCK.MSEC ...);

This is exactly why I interpreted MSEC as microseconds in your
proposal -- I'd just been reading about microseconds, saw MSEC, and my
brain matched them up.

Even with precedent I don't think "M" and "U" are good replacements
for SI's "m" and "micron".  The short versions may be faster to type
but they could cause longer debugging sessions or latent bugs.

Tom.




From dl@cs.oswego.edu Sat, 24 Aug 2002 08:02:32 -0400
Date: Sat, 24 Aug 2002 08:02:32 -0400
From: Doug Lea dl@cs.oswego.edu
Subject: [concurrency-interest]Clock.MICROSECONDS?

I'm about to give in on this, but here are a few words of defense.

1. All-caps has bad human factors, leading to misreadings. 
For example, 
  q.poll(10, Clock.MILLISECONDS);
  q.poll(10, Clock.MICROSECONDS);
are more confusable than
  q.poll(10, Clock.milliseconds);
  q.poll(10, Clock.microseconds);

2. I believe that the upcoming "enum" proposal for JDK1.5 recommends
lower-case conventions for enum elements. The Clock class acts as an
enum for most purposes/users. The polymorphic methods of the singeton
objects are used mainly by people implementing queue.poll etc.

-Doug









From crahen@cse.Buffalo.EDU Sat, 24 Aug 2002 09:33:57 -0400 (EDT)
Date: Sat, 24 Aug 2002 09:33:57 -0400 (EDT)
From: Eric D Crahen crahen@cse.Buffalo.EDU
Subject: [concurrency-interest]Executor Pattern

The final (pretty much) version of that pattern paper I mentioned before
is done. Its alot prettier than the draft most people probably looked at.

Its at the same URL if anyone is interested
http://www.cse.buffalo.edu/~crahen/papers/Executor.Pattern.pdf

Thanks to everyone who sent me feedback.

- Eric
http://www.cse.buffalo.edu/~crahen





From larryr@saturn.sdsu.edu 24 Aug 2002 17:55:41 -0000
Date: 24 Aug 2002 17:55:41 -0000
From: Larry Riedel larryr@saturn.sdsu.edu
Subject: [concurrency-interest]Clock.MICROSECONDS?

>   q.poll(10, Clock.MILLISECONDS);
>   q.poll(10, Clock.MICROSECONDS);
> are more confusable than
>   q.poll(10, Clock.milliseconds);
>   q.poll(10, Clock.microseconds);

I think there would not be much confusion if the constants
were Clock.MICRO, Clock.MILLI, Clock.NANO, and Clock.SECOND.
If the names have to be long, maybe it would not be that bad
to go with Clock.MICRO_SECONDS, etc.


> 1. All-caps has bad human factors, leading to misreadings. 

It seems to me that is water under the bridge by now.


Larry





From csapuntz@stanford.edu Wed, 28 Aug 2002 21:06:33 -0700
Date: Wed, 28 Aug 2002 21:06:33 -0700
From: Costa csapuntz@stanford.edu
Subject: [concurrency-interest]Queues that support destroy

Here's a little argument for adding support for "destroy()" to the queues:

I'm looking at implementing servers in a style similar to Matt Welsh's 
SEDA or Jim Larus' Cohort scheduler. In these systems, there is a queue 
at the front of each thread pool which threads take work off of. When a 
thread finishes its work, it puts it on a queue that is attached to 
another worker pool.

In my system, a thread can be associated with a connection. When the 
connection dies, I'd like the thread to die. If the thread decides it 
wishes to go away and no longer listen to its queue, it should be able 
to destroy it. Puts/offers/takes on a destroyed queue will all throw an 
exception.

Naively applying the current design in JSR166, if the thread goes away, 
the writers can still put stuff in the queue (as long as they have a 
pointer to it). If the queue fills, this may lead to them blocking 
indefinitely.

So, I propose adding a destroy() operation that allows me to reclaim the 
queue. I'd love to hear what others think (esp. if there's a better 
solution to my problem :)

Thanks,
-Costa





From dholmes@dltech.com.au Thu, 29 Aug 2002 14:20:51 +1000
Date: Thu, 29 Aug 2002 14:20:51 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Queues that support destroy

> So, I propose adding a destroy() operation that allows me
> to reclaim the queue. I'd love to hear what others think (esp.
> if there's a better  solution to my problem :)

Queues are just simple "dumb" collections - they don't know what they
contain nor how they are being used.

Your destroy() functionality belongs in whatever enacapsulates and
controls access to that collection. So you may define a WorkQueue
class that uses a Queue internally and which has a destroy() method [I
think close() would be more appropriate] that prevents further
additions.

David Holmes





From csapuntz@stanford.edu Wed, 28 Aug 2002 22:11:38 -0700
Date: Wed, 28 Aug 2002 22:11:38 -0700
From: Costa csapuntz@stanford.edu
Subject: [concurrency-interest]Queues that support destroy

> Your destroy() functionality belongs in whatever enacapsulates and
> controls access to that collection. So you may define a WorkQueue
> class that uses a Queue internally and which has a destroy() method [I
> think close() would be more appropriate] that prevents further
> additions

The wrapper is less efficient and harder to write.

Below is the pseudo-code for the destroy/put interaction. It took me a 
couple hours to come up with originally. It has an extra notify call on 
every put.

On the other hand, if implemented inside the base queue, one can avoid 
the postCheck counter and often avoid the destroyed_ flag by using an 
invalid value for another field. In most cases, we're talking about 
adding just one extra if statement to each function.

{
    boolean destroyed_;
    Queue q_;
    int   postCheck_;

    void destroy() {
        Object o;
        synchronized (this) {
	    if (destroyed_)
	       return;

	    destroyed_ = true;
             while ((o = q_.take()) != null) ;

	    while (postCheck_ > 0) {
	         q_.wait();
		 q_.take();
	    }
        }
    }

    void put(Object o) {
       synchronized (this) {
	  if (destroyed_) {
	     return;
	  }

           postCheck_++;
       }

       q_.put(o);

       synchronized (this) {
	  postCheck_--;
           q_.notifyAll();
       }
    }
}

Thanks,
-Costa






From dholmes@dltech.com.au Thu, 29 Aug 2002 15:39:14 +1000
Date: Thu, 29 Aug 2002 15:39:14 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Queues that support destroy

> The wrapper is less efficient and harder to write.

A wrapper adds a level of indirection so it is slightly less efficient
when you want that functionality. On the other hand putting the
functionality in the queue makes every user of the queue pay for
functionality they may not want. It is matter of where to draw the
line. The bounded queues take care of the basic common requirement of
blocking on a full or empty queue. Beyond that each context has its
own particular idiosyncrasies about what else the queue should do.
Hence any additional semantics are left up to the user of the queue.

As for being hard to write .... a basic wrapper with a check for a
closed queue is trivial if that is what you want:

  public class WorkQueue implements BoundedQueue {
     private ArrayBlockingQueue q = new ArrayBlockingQueue();
     private volatile boolean closed = false;

     public void close() { close = true; }

     private void checkClose() {
         if (closed) throw new QueueClosedException();
     }

     public Object take() throws InterruptedException {
         checkClose();
          return q.take();
     }
     ... etc
 }

> Below is the pseudo-code for the destroy/put interaction.

Sorry I can't follow exactly what you are doing but ... if you want to
be able to drain the queue after it is closed then you might define a
special interface to do that (and maybe your consumer is a tightly
coupled inner class); or you might have close() return the set of
elements in the queue. Or you could only close the queue to put() so
that it could drain as normal, or ....

You see there are so many possible things people might want to do,
there is no way to support them all in the util.concurrent queue
itself.

Of course if a large percentage of users asked for the same extra
functionality we'd probably provide. But this seems like the only
reasonable starting point.

David Holmes





From csapuntz@stanford.edu Wed, 28 Aug 2002 23:29:09 -0700
Date: Wed, 28 Aug 2002 23:29:09 -0700
From: Constantine Sapuntzakis csapuntz@stanford.edu
Subject: [concurrency-interest]Queues that support destroy

>
>
>
>As for being hard to write .... a basic wrapper with a check for a
>closed queue is trivial if that is what you want:
>
>  public class WorkQueue implements BoundedQueue {
>     private ArrayBlockingQueue q = new ArrayBlockingQueue();
>     private volatile boolean closed = false;
>
>     public void close() { close = true; }
>
>     private void checkClose() {
>         if (closed) throw new QueueClosedException();
>     }
>
>     public Object take() throws InterruptedException {
>         checkClose();
>          return q.take();
>     }
>     ... etc
> }
>

How would you implement "put" in the trivial wrapper? How do you deal with
threads blocked in put? About to call put?

-Costa






From dholmes@dltech.com.au Thu, 29 Aug 2002 17:04:11 +1000
Date: Thu, 29 Aug 2002 17:04:11 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Queues that support destroy

> How would you implement "put" in the trivial wrapper? How
> do you deal with threads blocked in put? About to call put?

The trivial wrapper would do:

   void put(Object o) throws InterruptedException {
       checkClose();
       q.put();
   }

It's not trying to do anything fancy - just stop the use of the queue.

You want to deal with threads that are blocked waiting when the queue
is closed. Okay so now there are two policies that need to be
specified:

- what to do with items in the queue when it is closed/destroyed
- what to do with threads blocked waiting when it is closed/destroyed

I'm not trying to show you a trivial solution to your problem - it's
not trivial - quite the opposite, I'm trying to show you that the
problem is too complex to be solved with some simple code added to the
library queue class. Your pseudo-code was implementing your choice of
policy, but what if others want a different policy. There is not a
"one size fits all" answer to what a destroy/close method should do -
that is why we don't try to provide one.

BTW these are the sorts of issues that ThreadedExecutor also has to
deal with. Your scenario is not a typical threadpool usage however.

David Holmes





From csapuntz@stanford.edu Thu, 29 Aug 2002 00:40:23 -0700
Date: Thu, 29 Aug 2002 00:40:23 -0700
From: Constantine Sapuntzakis csapuntz@stanford.edu
Subject: [concurrency-interest]Queues that support destroy

>
>
>
>You want to deal with threads that are blocked waiting when the queue
>is closed. Okay so now there are two policies that need to be
>specified:
>
>- what to do with items in the queue when it is closed/destroyed
>
You're right. I hadn't considered that there were two policies here.

>
>- what to do with threads blocked waiting when it is closed/destroyed
>
What applications would require threads to continue to block?  I don't 
see any use for an implementation that doesn't deal with blocked threads.

I have included diffs to the BoundedBuffer class in util.concurrent that 
implements
both policies. It changes emptySlots <0 to indicate that puts are not 
allowed and
usedSlots < 0 to indicate that takes are not allowed.

-Costa

--- concurrent/BoundedBuffer.java    Sat May 15 16:35:46 1999
+++ 
projects/collective2/src/edu/stanford/suif/util/BoundedBuffer.java    
Thu Aug 29 00:37:21 2002
@@ -105,13 +108,18 @@
     if (Thread.interrupted()) throw new InterruptedException();
 
     synchronized(putMonitor_) {
-      while (emptySlots_ <= 0) {
+      while (emptySlots_ == 0) {
     try { putMonitor_.wait(); }
         catch (InterruptedException ex) {
           putMonitor_.notify();
           throw ex;
         }
       }
+      if (emptySlots_ < 0) {
+      // Probably should throw exception to indicate put didn't
+      // succeed
+      return;
+      }
       insert(x);
     }
     incUsedSlots();
@@ -124,7 +132,7 @@
     synchronized(putMonitor_) {
       long start = (msecs <= 0)? 0 : System.currentTimeMillis();
       long waitTime = msecs;
-      while (emptySlots_ <= 0) {
+      while (emptySlots_ == 0) {
         if (waitTime <= 0) return false;
     try { putMonitor_.wait(waitTime); }
         catch (InterruptedException ex) {
@@ -133,6 +141,9 @@
         }
         waitTime = msecs - (System.currentTimeMillis() - start);
       }
+      if (emptySlots_ < 0) {
+      return false;
+      }
       insert(x);
     }
     incUsedSlots();
@@ -145,13 +156,16 @@
     if (Thread.interrupted()) throw new InterruptedException();
     Object old = null;
     synchronized(this) {
-      while (usedSlots_ <= 0) {
+      while (usedSlots_ == 0) {
         try { wait(); }
         catch (InterruptedException ex) {
           notify();
           throw ex;
         }
       }
+      return null;
+      }
       old = extract();
     }
     incEmptySlots();
@@ -165,7 +179,7 @@
       long start = (msecs <= 0)? 0 : System.currentTimeMillis();
       long waitTime = msecs;
      
-      while (usedSlots_ <= 0) {
+      while (usedSlots_ == 0) {
         if (waitTime <= 0) return null;
         try { wait(waitTime); }
         catch (InterruptedException ex) {
@@ -175,12 +189,35 @@
         waitTime = msecs - (System.currentTimeMillis() - start);
 
       }
+      if (usedSlots_ < 0) {
+      return null;
+      }
       old = extract();
     }
     incEmptySlots();
     return old;
   }
 
+  public void destroy() {
+      synchronized (putMonitor_) {
+      // Make sure it stays negative
+      emptySlots_ = Integer.MIN_VALUE;
+      putMonitor_.notify();
+      }
+
+      synchronized (this) {
+      usedSlots_ = Integer.MIN_VALUE;
+      notify();
+      }
+  }
+
+  public void destroyButAllowDraining() {
+      synchronized (putMonitor_) {
+      // Make sure it stays negative
+      emptySlots_ = Integer.MIN_VALUE;
+      putMonitor_.notify();
+      }
+  }
 }
 







From dholmes@dltech.com.au Fri, 30 Aug 2002 07:31:10 +1000
Date: Fri, 30 Aug 2002 07:31:10 +1000
From: David Holmes dholmes@dltech.com.au
Subject: [concurrency-interest]Queues that support destroy

> What applications would require threads to continue to
> block?  I don't see any use for an implementation that doesn't deal
> with blocked threads.

But maybe it is not up to the implementation of the queue to deal with
the blocked threads. Here are some possibilities:

- only use attempt with a timeout so no thread will block forever
- keep track of your own threads and interrupt them when the queue is
closed
- send a special "token" into the queue so that threads know the queue
has been closed

I'm simply saying that while the changes you made to your queue
address your requirements they will not suit everyone.

David Holmes





From paul@paulhaahr.com Thu, 29 Aug 2002 23:59:49 -0700 (PDT)
Date: Thu, 29 Aug 2002 23:59:49 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest]BlockingPriorityQueue vs. Heaps

[Apologies for this stale reply to a note from about three weeks ago;
I've only this week had time to read the draft APIs and this list.]

Doug Lea wrote
> (Note: For consistency, "BlockingPriorityQueue" will probably get a
> new name once we decide on the data structure to implement it with.
> Not Heaps, since we'd like to guarantee FIFOness within priorities,
> which is needed in many applications of blocking priority queues (but
> much less so for non-blocking ones) and which is not something that
> Heaps support.)

When reading the draft APIs, this difference between heaps and blocking
priority queues stuck out like a sore thumb, and I had a hard time
understanding why one wanted FIFOness for one form of priority queue but
not the other.  (I've used inter-thread queues with priority but no
FIFOness in the past without any difficulty.  I have had to resort to
timestamps, though, and include them in comparators, so I guess there
could be a savings.)

As to the naming issue, I'd strongly recommend not using the name of the
underlying data structure, both because it can sound awful (e.g.,
BlockingSkipListPriorityQueue) and, more importantly, because the name
should convey why you would use it, not how it is implemented.

Given that, I suggest that the term you're looking for is ``stable,'' by
analogy to stable sorting, to describe priority queues which preserve
FIFO order.

May I suggest

  PriorityQueue                  // formerly HeapPriorityQueue (j.u)
  StablePriorityQueue            // stable order for equal elements (j.u)
  BlockingPriorityQueue          // based on PriorityQueue (j.u.c)
  BlockingStablePriorityQueue    // based on StablePriorityQueue (j.u.c)

which is not much more work than the two classes already described and
provides a full complement of the desired functionality.

--p




From paul@paulhaahr.com Fri, 30 Aug 2002 00:08:19 -0700 (PDT)
Date: Fri, 30 Aug 2002 00:08:19 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] JSR 166 draft API

Doug Lea wrote, replying to and quoting Mario Juric:
> > I think its a shame that non-reentrant mutexes are excluded from the first
> > release, because I really use them in a case where the lock is not released
> > by the same thread that has acquired it.
> 
> Sorry for our lack of good documentation about this.

It is mentioned in the Semaphore description, which raised my hackles.

> A Semaphore initialized to 1 is precisely what you want in this case.
> Which of course will be supplied.

Actually, a semaphore initialized to 1 feels much heavier weight than a
simple non-reentrant mutex and easier to misuse.  (For example, a mutex
which is released twice can throw an exception, but I wouldn't expect
that from a semaphore.)

In this case, having two separate classes seems like it would reduce the
conceptual complexity of the APIs.

Consider me biased, however:  I never met a semaphore I liked.  They've
always seemed an obfuscating construct.

--p




From paul@paulhaahr.com Fri, 30 Aug 2002 00:11:59 -0700 (PDT)
Date: Fri, 30 Aug 2002 00:11:59 -0700 (PDT)
From: Paul Haahr paul@paulhaahr.com
Subject: [concurrency-interest] JSR 166 draft API

David Holmes wrote
> I'm afraid that this has nothing to do with the lock being reentrant or not.
> 
> The only reason you can release a mutex from another thread is purely and
> simply that the currentThread test was so expensive back then that Doug
> omitted the check for ownership of the mutex for performance reasons.

It also matches a bunch of historical practices that precede Java.

> A lock should only ever be released by the thread that owns it [...]

Fair enough, but there's utility for a mutex construct that can be
passed from thread to thread but has a max release count of 1.
Conflating the two concepts (acquire-here/release-there and variable
number of tickets) in Semaphores, while also grounded in historical
practice, doesn't provide much help to the user.

--p




From TEREKHOV@de.ibm.com Fri, 30 Aug 2002 20:12:11 +0200
Date: Fri, 30 Aug 2002 20:12:11 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] JSR 166 draft API

Paul Haahr wrote:
[...]
> Consider me biased, however:  I never met a semaphore I liked.  They've
> always seemed an obfuscating construct.

Dead accurate! ;-) IMNSHO.

regards,
alexander.


Paul Haahr <paul@paulhaahr.com>@cs.oswego.edu on 08/30/2002 09:08:19 AM

Sent by:    concurrency-interest-admin@cs.oswego.edu


To:    Doug Lea <dl@altair.cs.oswego.edu>
cc:    "Concurrent Interest" <concurrency-interest@altair.cs.oswego.edu>
Subject:    Re: [concurrency-interest] JSR 166 draft API


Doug Lea wrote, replying to and quoting Mario Juric:
> > I think its a shame that non-reentrant mutexes are excluded from the
first
> > release, because I really use them in a case where the lock is not
released
> > by the same thread that has acquired it.
>
> Sorry for our lack of good documentation about this.

It is mentioned in the Semaphore description, which raised my hackles.

> A Semaphore initialized to 1 is precisely what you want in this case.
> Which of course will be supplied.

Actually, a semaphore initialized to 1 feels much heavier weight than a
simple non-reentrant mutex and easier to misuse.  (For example, a mutex
which is released twice can throw an exception, but I wouldn't expect
that from a semaphore.)

In this case, having two separate classes seems like it would reduce the
conceptual complexity of the APIs.

Consider me biased, however:  I never met a semaphore I liked.  They've
always seemed an obfuscating construct.

--p

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest








From TEREKHOV@de.ibm.com Fri, 30 Aug 2002 20:14:16 +0200
Date: Fri, 30 Aug 2002 20:14:16 +0200
From: Alexander Terekhov TEREKHOV@de.ibm.com
Subject: [concurrency-interest] JSR 166 draft API

Paul Haahr wrote:
[...]
> > A lock should only ever be released by the thread that owns it [...]
>
> Fair enough, but there's utility for a mutex construct that can be
> passed from thread to thread but has a max release count of 1.

That's binary semaphore, unless I'm just missing something. And, BTW,
"max release count" is pretty much useless, unless I'm again missing
something...

http://groups.google.com/groups?selm=3BC6BC9A.84996C02%40web.de
(Subject: Re: Non-recursive mutex under Windows NT/2000)

----
> Not sure what you mean. If when you call ReleaseSemaphore the resulting
count in
> the semaphore would go beyond the maximum count value the function
returns
> false. Therefore you can call ReleaseSemaphore as many times as you want
but the
> semaphore count will never exceed 1, which means only one waiting thread
will
> ever be started.

This is NOT true unless you somehow preclude the
race with respect to a thread calling release and
other threads calling wait (see below).

> Seems to me that this capability is something of an error catching
feature.
> Properly functioning code that is using a semaphore as an exclusion type
object
> will never try to set a semaphore count more than one. If the code has a
bug and
> you do try to set the semaphore count greater than the maximum and you
check
> function return values, you have just caught a bug.

hmmm. even if the real purpose is just bug detection
(e.g. a program that intends to use bin.semaphore as
"exclusion type object"):

bin.semaphore (set MS-max.count to 1? well, OK); initial = 1

semaphore                 count = 1; 0 waiting
Thread 1: wait            count = 0; 0 waiting
Thread 2: wait            count = 0; 1 waiting (N2)
Thread 3: wait            count = 0; 2 waiting (N2 and N3)
Thread 1: release         count = 0; 1 waiting N2 is released
Thread 1: release !error! count = 0; 0 waiting N3 is released

N3 is released with NO errors;

Thread 2: release         count = 1; 0 waiting
Thread 2: wait            count = 0; 0 waiting
Thread 3: release         count = 1; 0 waiting
Thread 3: wait            count = 0; 0 waiting
.
.
.

and only later, if/when both N1 and N2 release sema
(and no other thread is waiting at that time), the
"error" could then show up in the form of a bad
release return code. but it is too late and also is
not guaranteed to happen (it's likely that a program
would already fail a long time before an error could
be detected -- e.g. due to corrupted data).

Seems to me that this capability (max.count) is
rather useless and just adds overhead (checking)
with no real benefit (especially for correct
programs).

And of course mutex/POSIX-CV(s) is a much better
(more efficient, less error prone) way to solve
most of synch. problems, IMHO.
----

> Conflating the two concepts (acquire-here/release-there and variable
> number of tickets) in Semaphores, while also grounded in historical
> practice, doesn't provide much help to the user.

???

regards,
alexander.



Paul Haahr <paul@paulhaahr.com>@cs.oswego.edu on 08/30/2002 09:11:59 AM

Sent by:    concurrency-interest-admin@cs.oswego.edu


To:    "David Holmes" <dholmes@dltech.com.au>
cc:    "Concurrent Interest" <concurrency-interest@altair.cs.oswego.edu>
Subject:    RE: [concurrency-interest] JSR 166 draft API


David Holmes wrote
> I'm afraid that this has nothing to do with the lock being reentrant or
not.
>
> The only reason you can release a mutex from another thread is purely and
> simply that the currentThread test was so expensive back then that Doug
> omitted the check for ownership of the mutex for performance reasons.

It also matches a bunch of historical practices that precede Java.

> A lock should only ever be released by the thread that owns it [...]

Fair enough, but there's utility for a mutex construct that can be
passed from thread to thread but has a max release count of 1.
Conflating the two concepts (acquire-here/release-there and variable
number of tickets) in Semaphores, while also grounded in historical
practice, doesn't provide much help to the user.

--p

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest








