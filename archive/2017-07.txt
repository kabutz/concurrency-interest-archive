From michael.hixson at gmail.com  Wed Jul  5 23:59:52 2017
From: michael.hixson at gmail.com (Michael Hixson)
Date: Wed, 5 Jul 2017 20:59:52 -0700
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
Message-ID: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>

AtomicReference and VarHandle are specified to use == in compareAndSet
(and related) operations [1].  Using == to compare instances of
value-based classes may lead to "unpredictable results" [2].  Does
this mean I should avoid using compareAndSet with arguments that are
instances of value-based classes?

It seems like the documentation clearly tells me "yes, avoid doing
that" but I'm hoping I misunderstood, or maybe AtomicReference and
VarHandle are exempt somehow.  Otherwise, how do I implement
non-broken compareAndSet and updateAndGet for a java.time.Instant
value for example?  Do I have to box the value in something that's not
a value-based class first, like AtomicReference<Box<Instant>>?

-Michael

[1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
[2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html

From gil at azul.com  Thu Jul  6 00:20:23 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 04:20:23 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
Message-ID: <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>

Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.

Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.

Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.

— Gil.  

> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
> 
> AtomicReference and VarHandle are specified to use == in compareAndSet
> (and related) operations [1].  Using == to compare instances of
> value-based classes may lead to "unpredictable results" [2].  Does
> this mean I should avoid using compareAndSet with arguments that are
> instances of value-based classes?
> 
> It seems like the documentation clearly tells me "yes, avoid doing
> that" but I'm hoping I misunderstood, or maybe AtomicReference and
> VarHandle are exempt somehow.  Otherwise, how do I implement
> non-broken compareAndSet and updateAndGet for a java.time.Instant
> value for example?  Do I have to box the value in something that's not
> a value-based class first, like AtomicReference<Box<Instant>>?
> 
> -Michael
> 
> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From bronee at gmail.com  Thu Jul  6 00:47:34 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Wed, 5 Jul 2017 21:47:34 -0700
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
Message-ID: <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>

I think the wording in the value-based document is too strong. It's 
perfectly fine to compare value based instances using ==, but it can 
lead to confusing results when comparing distinct instances with 
equivalent state. Using compareAndSet with a box isn't necessary for it 
to work "correctly" with a value-based class.

By "correctly", I mean the compareAndSet operation works correctly, 
using == comparison. However, if your intention is for compareAndSet to 
compare Instants based on their state, then this of course won't work 
properly.

If you want to perform a compareAndSet for an Instant's state (time 
since epoch), then you need to use something that can be compared 
atomically. This means the state must be representable in a 64-bit value 
or smaller. The Instant class measures time using a 64-bit long and a 
32-bit int, and so this state cannot be compared atomically. You'd have 
to chop off some precision or use something else.


On 2017-07-05 09:20 PM, Gil Tene wrote:
> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
> 
> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
> 
> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
> 
> — Gil.
> 
>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
>>
>> AtomicReference and VarHandle are specified to use == in compareAndSet
>> (and related) operations [1].  Using == to compare instances of
>> value-based classes may lead to "unpredictable results" [2].  Does
>> this mean I should avoid using compareAndSet with arguments that are
>> instances of value-based classes?
>>
>> It seems like the documentation clearly tells me "yes, avoid doing
>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>> VarHandle are exempt somehow.  Otherwise, how do I implement
>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>> value for example?  Do I have to box the value in something that's not
>> a value-based class first, like AtomicReference<Box<Instant>>?
>>
>> -Michael
>>
>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html

> 

From gil at azul.com  Thu Jul  6 01:11:34 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 05:11:34 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
Message-ID: <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>


I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future. 
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe). 

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
> 
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
> 
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
> 
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
> 
> 
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
>>> 
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>> 
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>> 
>>> -Michael
>>> 
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dahankzter at gmail.com  Thu Jul  6 02:51:24 2017
From: dahankzter at gmail.com (Henrik Johansson)
Date: Thu, 06 Jul 2017 06:51:24 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
Message-ID: <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>

Oh, without having followed the value type discussions I think it was a
mistake to not "fix" equality. Why not make it a deep comparison if the
reference is different? If it points to the same object we are done
otherwise start checking the struct content.

There may be a lot I missed here but a new type of object could be allowed
to have different meaning equality. Right?

On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com> wrote:

>
> I'd take that documentation seriously. It basically says that ==, !=,
> synchronization, identity hashing, and serialization are undefined
> behaviors.
>
> While the *current* implementations may carry some semi-intuitive
> behvaiors, e.g. where == indicates true when comparing two references to
> instances of a value-based class where the value of the references is the
> same, there is no guarantee that at some point in the [near or far] future
> that behavior will remain. Specifically, attempting == (or !=, or
> synchronization, etc., including compareAndSet) on a reference to a value
> based class is allowed to do ANYTHING in the future.
> For example:
> - It may throw an exception (something it should probably start doing ASAP
> to avoid future surprises).
> - It may return always-false, even when the two references are "to the
> same instance" (and probably will, through many possible value-based
> compiler optimizations that will erase the unneeded notion of reference and
> identity).
> - It may overwrite random locations in memory or to variables that the
> code performing the operation has the privilege to write to (which it
> probably shouldn't, but that's certainly included in what "undefined" and
> "unpredictable effects" can mean).
> - It may sometimes do one of the above, and sometimes seem to be doing
> what you mean it to do. Switching between modes on a whim (e.g. when a tier
> 2 optimizing compilation is applied, or when the mutton is nice and lean
> and the tomato is ripe).
>
> So no, there is no way for compareAndSet to work "correctly" on a
> reference to an instance of a value-based class. Even if it happens to
> appear to work "correctly" now, expect it to blow up in bad and potentially
> silent ways in the future.
>
> — Gil.
>
> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
> >
> > I think the wording in the value-based document is too strong. It's
> perfectly fine to compare value based instances using ==, but it can lead
> to confusing results when comparing distinct instances with equivalent
> state. Using compareAndSet with a box isn't necessary for it to work
> "correctly" with a value-based class.
> >
> > By "correctly", I mean the compareAndSet operation works correctly,
> using == comparison. However, if your intention is for compareAndSet to
> compare Instants based on their state, then this of course won't work
> properly.
> >
> > If you want to perform a compareAndSet for an Instant's state (time
> since epoch), then you need to use something that can be compared
> atomically. This means the state must be representable in a 64-bit value or
> smaller. The Instant class measures time using a 64-bit long and a 32-bit
> int, and so this state cannot be compared atomically. You'd have to chop
> off some precision or use something else.
> >
> >
> > On 2017-07-05 09:20 PM, Gil Tene wrote:
> >> Reference equality for value based classes (as referenced below) lacks
> meaning, as there is no notion of identity in such classes (only a notion
> of value). And since compareAndSet on reference fields is basically an
> idenitity-based operation [in the compare part], the two won't mix well
> logically.
> >> Specifically, while two references to e.g. java.time.LocalDateTime
> instances being == to each other *probably* means that the two are actually
> equal in value, the opposite is not true: Being != to each other does NOT
> mean that they are logically different. As such, the "compare" part in
> compareAndSet may falsely fail even when the two instances are logically
> equal to each other, leaving the rest of your logic potentially exposed.
> >> Bottom line: given the explicit warning to not use == and != on
> references to value-based instances, I'd avoid using compareAndSet on those
> references. If you really need to use a value-based class in your logic,
> consider boxing it in another object that has [normal] identity.
> >> — Gil.
> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com>
> wrote:
> >>>
> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
> >>> (and related) operations [1].  Using == to compare instances of
> >>> value-based classes may lead to "unpredictable results" [2].  Does
> >>> this mean I should avoid using compareAndSet with arguments that are
> >>> instances of value-based classes?
> >>>
> >>> It seems like the documentation clearly tells me "yes, avoid doing
> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
> >>> value for example?  Do I have to box the value in something that's not
> >>> a value-based class first, like AtomicReference<Box<Instant>>?
> >>>
> >>> -Michael
> >>>
> >>> [1]
> http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
> >>> [2]
> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/2cd01ba1/attachment-0001.html>

From gil at azul.com  Thu Jul  6 03:28:44 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 07:28:44 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>,
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
Message-ID: <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:


Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.

There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?

.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else



On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/4733bf4c/attachment.html>

From oleksandr.otenko at gmail.com  Thu Jul  6 03:34:36 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 08:34:36 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
Message-ID: <03618583-4E47-460E-A55D-F35344795CA5@gmail.com>


> On 6 Jul 2017, at 06:11, Gil Tene <gil at azul.com> wrote:
> 
> 
> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
> 
> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future. 
> For example:
> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).

That would be a silly thing to do.

Unless you also forbid casting them to Object, including implicit downcasting due to generics. Java type system is not ready for that.


All it is saying, is that because of factory methods you can’t tell whether two Optional.empty() are the same instance or not, even in the same instance of a VM.

I don’t see why anyone would want to impose any other meaning, especially the varieties of “explosive” treatment you mentioned.


Alex

> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe). 
> 
> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
> 
> — Gil.
> 
>> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
>> 
>> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>> 
>> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>> 
>> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>> 
>> 
>> On 2017-07-05 09:20 PM, Gil Tene wrote:
>>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>> — Gil.
>>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
>>>> 
>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>> (and related) operations [1].  Using == to compare instances of
>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>> this mean I should avoid using compareAndSet with arguments that are
>>>> instances of value-based classes?
>>>> 
>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>> value for example?  Do I have to box the value in something that's not
>>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>> 
>>>> -Michael
>>>> 
>>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu Jul  6 03:38:10 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 08:38:10 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
Message-ID: <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>

All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

Alex

> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com> wrote:
> 
> 
> 
> Sent from my iPad
> 
> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
> 
>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
>> 
>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>> 
> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
> 
> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>   int a = 5;
>   int b = 5;
>   boolean y = (a == b);  // true
> 
> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>   Integer a = new Integer(5);
>   Integer b = new Integer(5);
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // false
> 
> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
> 
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // unpredictable, undefined, who knows. 
>                                          // Could be true, could be false.
>                                          // Could theoretically change the values of a or b, or of something else
> 
> 
>> 
>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com <mailto:gil at azul.com>> wrote:
>> 
>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>> 
>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>> For example:
>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>> 
>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>> 
>> — Gil.
>> 
>> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>> >
>> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>> >
>> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>> >
>> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>> >
>> >
>> > On 2017-07-05 09:20 PM, Gil Tene wrote:
>> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> >> — Gil.
>> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com <mailto:michael.hixson at gmail.com>> wrote:
>> >>>
>> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
>> >>> (and related) operations [1].  Using == to compare instances of
>> >>> value-based classes may lead to "unpredictable results" [2].  Does
>> >>> this mean I should avoid using compareAndSet with arguments that are
>> >>> instances of value-based classes?
>> >>>
>> >>> It seems like the documentation clearly tells me "yes, avoid doing
>> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
>> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>> >>> value for example?  Do I have to box the value in something that's not
>> >>> a value-based class first, like AtomicReference<Box<Instant>>?
>> >>>
>> >>> -Michael
>> >>>
>> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V- <http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V->
>> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html <http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html>
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/f849d8cf/attachment.html>

From dahankzter at gmail.com  Thu Jul  6 03:43:39 2017
From: dahankzter at gmail.com (Henrik Johansson)
Date: Thu, 06 Jul 2017 07:43:39 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
Message-ID: <CAKOF6968w1Q6Fyof-9XfkHro7ybX4AzqwsSaupTjJckoGL4Gxg@mail.gmail.com>

I was kind of hoping, perhaps naively, that the value based classes would
be treated as the primitive types.

On Thu, 6 Jul 2017, 09:38 Alex Otenko, <oleksandr.otenko at gmail.com> wrote:

> All it is saying is:
>
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>
> a==b && b==c can be true and can be false
>
> Alex
>
> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com> wrote:
>
>
>
> Sent from my iPad
>
> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com>
> wrote:
>
> Oh, without having followed the value type discussions I think it was a
> mistake to not "fix" equality. Why not make it a deep comparison if the
> reference is different? If it points to the same object we are done
> otherwise start checking the struct content.
>
> There may be a lot I missed here but a new type of object could be allowed
> to have different meaning equality. Right?
>
> .equals() means what you want it to mean. == and != (and the compare in
> compareAndSet) mean very specific things, and cannot be overridden.
>
> For non-reference value types (int, long, char, etc.), == and != are value
> comparisons. An int has no identity. Just a value:
>   int a = 5;
>   int b = 5;
>   boolean y = (a == b);  // true
>
> For references to instances of (non value-based) classes, == and != can be
> thought of as comparing the value of the reference (and not the contents of
> the object instances). This is an identity comparison, which ignores values
> within the object:
>   Integer a = new Integer(5);
>   Integer b = new Integer(5);
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // false
>
> And for references to value-based classes (which is a relatively new
> thing, but is part of Java 8), the meaning of == and != appears to be
> undefined. E.g.:
>
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // unpredictable, undefined, who knows.
>                                          // Could be true, could be false.
>                                          // Could theoretically change
> the values of a or b, or of something else
>
>
>
> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com> wrote:
>
>>
>> I'd take that documentation seriously. It basically says that ==, !=,
>> synchronization, identity hashing, and serialization are undefined
>> behaviors.
>>
>> While the *current* implementations may carry some semi-intuitive
>> behvaiors, e.g. where == indicates true when comparing two references to
>> instances of a value-based class where the value of the references is the
>> same, there is no guarantee that at some point in the [near or far] future
>> that behavior will remain. Specifically, attempting == (or !=, or
>> synchronization, etc., including compareAndSet) on a reference to a value
>> based class is allowed to do ANYTHING in the future.
>> For example:
>> - It may throw an exception (something it should probably start doing
>> ASAP to avoid future surprises).
>> - It may return always-false, even when the two references are "to the
>> same instance" (and probably will, through many possible value-based
>> compiler optimizations that will erase the unneeded notion of reference and
>> identity).
>> - It may overwrite random locations in memory or to variables that the
>> code performing the operation has the privilege to write to (which it
>> probably shouldn't, but that's certainly included in what "undefined" and
>> "unpredictable effects" can mean).
>> - It may sometimes do one of the above, and sometimes seem to be doing
>> what you mean it to do. Switching between modes on a whim (e.g. when a tier
>> 2 optimizing compilation is applied, or when the mutton is nice and lean
>> and the tomato is ripe).
>>
>> So no, there is no way for compareAndSet to work "correctly" on a
>> reference to an instance of a value-based class. Even if it happens to
>> appear to work "correctly" now, expect it to blow up in bad and potentially
>> silent ways in the future.
>>
>> — Gil.
>>
>> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
>> >
>> > I think the wording in the value-based document is too strong. It's
>> perfectly fine to compare value based instances using ==, but it can lead
>> to confusing results when comparing distinct instances with equivalent
>> state. Using compareAndSet with a box isn't necessary for it to work
>> "correctly" with a value-based class.
>> >
>> > By "correctly", I mean the compareAndSet operation works correctly,
>> using == comparison. However, if your intention is for compareAndSet to
>> compare Instants based on their state, then this of course won't work
>> properly.
>> >
>> > If you want to perform a compareAndSet for an Instant's state (time
>> since epoch), then you need to use something that can be compared
>> atomically. This means the state must be representable in a 64-bit value or
>> smaller. The Instant class measures time using a 64-bit long and a 32-bit
>> int, and so this state cannot be compared atomically. You'd have to chop
>> off some precision or use something else.
>> >
>> >
>> > On 2017-07-05 09:20 PM, Gil Tene wrote:
>> >> Reference equality for value based classes (as referenced below) lacks
>> meaning, as there is no notion of identity in such classes (only a notion
>> of value). And since compareAndSet on reference fields is basically an
>> idenitity-based operation [in the compare part], the two won't mix well
>> logically.
>> >> Specifically, while two references to e.g. java.time.LocalDateTime
>> instances being == to each other *probably* means that the two are actually
>> equal in value, the opposite is not true: Being != to each other does NOT
>> mean that they are logically different. As such, the "compare" part in
>> compareAndSet may falsely fail even when the two instances are logically
>> equal to each other, leaving the rest of your logic potentially exposed.
>> >> Bottom line: given the explicit warning to not use == and != on
>> references to value-based instances, I'd avoid using compareAndSet on those
>> references. If you really need to use a value-based class in your logic,
>> consider boxing it in another object that has [normal] identity.
>> >> — Gil.
>> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com>
>> wrote:
>> >>>
>> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
>> >>> (and related) operations [1].  Using == to compare instances of
>> >>> value-based classes may lead to "unpredictable results" [2].  Does
>> >>> this mean I should avoid using compareAndSet with arguments that are
>> >>> instances of value-based classes?
>> >>>
>> >>> It seems like the documentation clearly tells me "yes, avoid doing
>> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
>> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>> >>> value for example?  Do I have to box the value in something that's not
>> >>> a value-based class first, like AtomicReference<Box<Instant>>?
>> >>>
>> >>> -Michael
>> >>>
>> >>> [1]
>> http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>> >>> [2]
>> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/7e813365/attachment-0001.html>

From gil at azul.com  Thu Jul  6 03:47:39 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 07:47:39 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>,
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
Message-ID: <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>



Sent from my iPad

On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

It also means that even when:

  LocalDateTime d = a;
  ...
  (a == d) may or may not be true. And may change whether it is true or not at any time,


Alex

On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:


Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.

There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?

.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else



On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

- Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> - Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/4857d571/attachment.html>

From oleksandr.otenko at gmail.com  Thu Jul  6 04:17:10 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 09:17:10 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
Message-ID: <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>


> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com> wrote:
> 
> 
> 
> Sent from my iPad
> 
> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> 
>> All it is saying is:
>> 
>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>> 
>> a==b && b==c can be true and can be false
> 
> It also means that even when:
> 
>   LocalDateTime d = a;
>   ...
>   (a == d) may or may not be true. And may change whether it is true or not at any time,

I meant an even stronger assertion:

assert (a==b) == (b==a) : "No Byzantine optimizations"
assert (a==d) == (a==d): “No Byzantine optimizations"

Alex


> 
>> 
>> Alex
>> 
>>> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> 
>>> 
>>> 
>>> Sent from my iPad
>>> 
>>> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
>>> 
>>>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
>>>> 
>>>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>>>> 
>>> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>>> 
>>> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>>>   int a = 5;
>>>   int b = 5;
>>>   boolean y = (a == b);  // true
>>> 
>>> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>>>   Integer a = new Integer(5);
>>>   Integer b = new Integer(5);
>>>   boolean x = a.equals(b);   // true
>>>   boolean y = (a == b);   // false
>>> 
>>> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>>> 
>>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   boolean x = a.equals(b);   // true
>>>   boolean y = (a == b);   // unpredictable, undefined, who knows. 
>>>                                          // Could be true, could be false.
>>>                                          // Could theoretically change the values of a or b, or of something else
>>> 
>>> 
>>>> 
>>>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>> 
>>>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>>>> 
>>>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>>>> For example:
>>>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>>>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>>>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>>>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>>>> 
>>>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>>>> 
>>>> — Gil.
>>>> 
>>>> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>>>> >
>>>> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>>>> >
>>>> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>>>> >
>>>> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>>>> >
>>>> >
>>>> > On 2017-07-05 09:20 PM, Gil Tene wrote:
>>>> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>>> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>>> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>>> >> — Gil.
>>>> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com <mailto:michael.hixson at gmail.com>> wrote:
>>>> >>>
>>>> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>> >>> (and related) operations [1].  Using == to compare instances of
>>>> >>> value-based classes may lead to "unpredictable results" [2].  Does
>>>> >>> this mean I should avoid using compareAndSet with arguments that are
>>>> >>> instances of value-based classes?
>>>> >>>
>>>> >>> It seems like the documentation clearly tells me "yes, avoid doing
>>>> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>> >>> value for example?  Do I have to box the value in something that's not
>>>> >>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>> >>>
>>>> >>> -Michael
>>>> >>>
>>>> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V- <http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V->
>>>> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html <http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html>
>>>> >
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/528a7239/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Thu Jul  6 05:12:08 2017
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Thu, 6 Jul 2017 09:12:08 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet
	with	value-based classes?
In-Reply-To: <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>

just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?

n  Sebastian

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
Sent: Thursday, July 06, 2017 10:17 AM
To: Gil Tene
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?


On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:
All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

It also means that even when:

  LocalDateTime d = a;
  ...
  (a == d) may or may not be true. And may change whether it is true or not at any time,

I meant an even stronger assertion:

assert (a==b) == (b==a) : "No Byzantine optimizations"
assert (a==d) == (a==d): “No Byzantine optimizations"

Alex





Alex

On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:
Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else




On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/50db73cb/attachment-0001.html>

From aph at redhat.com  Thu Jul  6 05:13:15 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 6 Jul 2017 10:13:15 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
Message-ID: <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>

On 06/07/17 04:59, Michael Hixson wrote:
> AtomicReference and VarHandle are specified to use == in compareAndSet
> (and related) operations [1].  Using == to compare instances of
> value-based classes may lead to "unpredictable results" [2].  Does
> this mean I should avoid using compareAndSet with arguments that are
> instances of value-based classes?
> 
> It seems like the documentation clearly tells me "yes, avoid doing
> that" but I'm hoping I misunderstood, or maybe AtomicReference and
> VarHandle are exempt somehow.  Otherwise, how do I implement
> non-broken compareAndSet and updateAndGet for a java.time.Instant
> value for example?

java.time.Instant stores times that are longer than a JVM word, so
they cannot be CAS'd in a lock-free way unless a factory guarantees
that instances which compare equal also have the property of
reference equality.  j.t.Instant factories in the Java library are
explicitly documented *not* to have this property, so that doesn't
help.

If you want to be able to CAS a reference to a j.t.Instant, you're
going to have to wrap accesses to it in a synchronized block.  This is
a direct consequence of the JVM's inability to CAS multi-word objects.

There are some things we know, however, despite the documentation of
"Value-based Classes".  For any reference r, r == r.  If r refers to a
value-based class, r.equals(r) will always return true.  I don't think
that anything which appears in that section can overrule these basic
properties.  Because of this, you can keep a pool of Instant
instances and intern them, and then, I believe, a reference CAS will
work.  But you'll need a synchronized factory to do that.

Obviously a CAS-able timestamp would be a nice thing to have, but
java.time.Instant is not the timestamp you're looking for.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From oleksandr.otenko at gmail.com  Thu Jul  6 06:03:07 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 11:03:07 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
Message-ID: <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>

:-) the one causing Byzantine failures!

Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.

All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).


Alex


> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com> wrote:
> 
> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
> n  Sebastian
>  
> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> Sent: Thursday, July 06, 2017 10:17 AM
> To: Gil Tene
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>  
>  
> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>  
> 
> 
> Sent from my iPad
> 
> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> 
> All it is saying is:
>  
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>  
> a==b && b==c can be true and can be false
>  
> It also means that even when:
>  
>   LocalDateTime d = a;
>   ...
>   (a == d) may or may not be true. And may change whether it is true or not at any time,
>  
> I meant an even stronger assertion:
>  
> assert (a==b) == (b==a) : "No Byzantine optimizations"
> assert (a==d) == (a==d): “No Byzantine optimizations"
>  
> Alex
>  
> 
> 
>  
>  
> Alex
>  
> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>  
> 
> 
> Sent from my iPad
> 
> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
> 
> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content. 
> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>  
> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>   int a = 5;
>   int b = 5;
>   boolean y = (a == b);  // true
>  
> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>   Integer a = new Integer(5);
>   Integer b = new Integer(5);
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // false
>  
> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>  
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // unpredictable, undefined, who knows. 
>                                          // Could be true, could be false.
>                                          // Could theoretically change the values of a or b, or of something else
>  
> 
> 
>  
> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com <mailto:gil at azul.com>> wrote:
> 
> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
> 
> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
> For example:
> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
> 
> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
> 
> — Gil.
> 
> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
> >
> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
> >
> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
> >
> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
> >
> >
> > On 2017-07-05 09:20 PM, Gil Tene wrote:
> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
> >> — Gil.
> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com <mailto:michael.hixson at gmail.com>> wrote:
> >>>
> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
> >>> (and related) operations [1].  Using == to compare instances of
> >>> value-based classes may lead to "unpredictable results" [2].  Does
> >>> this mean I should avoid using compareAndSet with arguments that are
> >>> instances of value-based classes?
> >>>
> >>> It seems like the documentation clearly tells me "yes, avoid doing
> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
> >>> value for example?  Do I have to box the value in something that's not
> >>> a value-based class first, like AtomicReference<Box<Instant>>?
> >>>
> >>> -Michael
> >>>
> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V- <http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V->
> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html <http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>  
>  
> 
> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com <http://www.softwareag.com/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/bad8f6b4/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Jul  6 06:41:43 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 11:41:43 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
Message-ID: <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>


> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
> 
> On 06/07/17 04:59, Michael Hixson wrote:
>> AtomicReference and VarHandle are specified to use == in compareAndSet
>> (and related) operations [1].  Using == to compare instances of
>> value-based classes may lead to "unpredictable results" [2].  Does
>> this mean I should avoid using compareAndSet with arguments that are
>> instances of value-based classes?
>> 
>> It seems like the documentation clearly tells me "yes, avoid doing
>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>> VarHandle are exempt somehow.  Otherwise, how do I implement
>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>> value for example?
> 
> java.time.Instant stores times that are longer than a JVM word, so
> they cannot be CAS'd in a lock-free way unless a factory guarantees
> that instances which compare equal also have the property of
> reference equality.  j.t.Instant factories in the Java library are
> explicitly documented *not* to have this property, so that doesn't
> help.

That’s not entirely clear.

Wouldn’t this loop work:

volatile j.t.Instant curr = ...

j.t.Instant next = …
j.t.Instant tmp = ...
do {
  tmp = curr;
  if (tmp.equal(next)) break;
} while(!curr.CAS(tmp, next));

// assume curr is equal to next


> If you want to be able to CAS a reference to a j.t.Instant, you're
> going to have to wrap accesses to it in a synchronized block.  This is
> a direct consequence of the JVM's inability to CAS multi-word objects.

This is confusing.

Surely this isn’t talking about CASing a reference? The contents of the object can’t be assumed to have any atomicity properties, whether it is j.t.Instant or not.


Alex


> 
> There are some things we know, however, despite the documentation of
> "Value-based Classes".  For any reference r, r == r.  If r refers to a
> value-based class, r.equals(r) will always return true.  I don't think
> that anything which appears in that section can overrule these basic
> properties.  Because of this, you can keep a pool of Instant
> instances and intern them, and then, I believe, a reference CAS will
> work.  But you'll need a synchronized factory to do that.
> 
> Obviously a CAS-able timestamp would be a nice thing to have, but
> java.time.Instant is not the timestamp you're looking for.
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From aph at redhat.com  Thu Jul  6 07:20:01 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 6 Jul 2017 12:20:01 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
Message-ID: <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>

On 06/07/17 11:41, Alex Otenko wrote:
> 
>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>
>> On 06/07/17 04:59, Michael Hixson wrote:
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?
>>
>> java.time.Instant stores times that are longer than a JVM word, so
>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>> that instances which compare equal also have the property of
>> reference equality.  j.t.Instant factories in the Java library are
>> explicitly documented *not* to have this property, so that doesn't
>> help.
> 
> That’s not entirely clear.
>
> Wouldn’t this loop work:
> 
> volatile j.t.Instant curr = ...
> 
> j.t.Instant next = …
> j.t.Instant tmp = ...
> do {
>   tmp = curr;
>   if (tmp.equal(next)) break;
> } while(!curr.CAS(tmp, next));
> 
> // assume curr is equal to next

Something like that, yes.  But it's going to be evil if there are
several high-frequency writers.  If you're doing all that work in
order to CAS a timestamp, why not use a synchronized block?  It would
at least be less prone to the thundering herd, and we'd generate
pretty decent code for that.  It'd be interesting to compare and
contrast the two approaches for contended and non-contended cases.

>> If you want to be able to CAS a reference to a j.t.Instant, you're
>> going to have to wrap accesses to it in a synchronized block.  This is
>> a direct consequence of the JVM's inability to CAS multi-word objects.
> 
> This is confusing.
> 
> Surely this isn’t talking about CASing a reference? The contents of
> the object can’t be assumed to have any atomicity properties,
> whether it is j.t.Instant or not.

I agree.  I'm trying to look at what the OP actually wants to do: I
assume this is some kind of atomic timestamp, and the OP wants to be
able to CAS an instance of j.u.Instant.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From oleksandr.otenko at gmail.com  Thu Jul  6 07:52:36 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 12:52:36 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
Message-ID: <6970EB45-F1D8-4578-80AB-4A50169A90ED@gmail.com>

Thanks, Andrew. That clarifies.

Yes, CAS loop example is just for the sake of argument.

Alex

> On 6 Jul 2017, at 12:20, Andrew Haley <aph at redhat.com> wrote:
> 
> On 06/07/17 11:41, Alex Otenko wrote:
>> 
>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>> 
>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>> (and related) operations [1].  Using == to compare instances of
>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>> this mean I should avoid using compareAndSet with arguments that are
>>>> instances of value-based classes?
>>>> 
>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>> value for example?
>>> 
>>> java.time.Instant stores times that are longer than a JVM word, so
>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>> that instances which compare equal also have the property of
>>> reference equality.  j.t.Instant factories in the Java library are
>>> explicitly documented *not* to have this property, so that doesn't
>>> help.
>> 
>> That’s not entirely clear.
>> 
>> Wouldn’t this loop work:
>> 
>> volatile j.t.Instant curr = ...
>> 
>> j.t.Instant next = …
>> j.t.Instant tmp = ...
>> do {
>>  tmp = curr;
>>  if (tmp.equal(next)) break;
>> } while(!curr.CAS(tmp, next));
>> 
>> // assume curr is equal to next
> 
> Something like that, yes.  But it's going to be evil if there are
> several high-frequency writers.  If you're doing all that work in
> order to CAS a timestamp, why not use a synchronized block?  It would
> at least be less prone to the thundering herd, and we'd generate
> pretty decent code for that.  It'd be interesting to compare and
> contrast the two approaches for contended and non-contended cases.
> 
>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>> going to have to wrap accesses to it in a synchronized block.  This is
>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>> 
>> This is confusing.
>> 
>> Surely this isn’t talking about CASing a reference? The contents of
>> the object can’t be assumed to have any atomicity properties,
>> whether it is j.t.Instant or not.
> 
> I agree.  I'm trying to look at what the OP actually wants to do: I
> assume this is some kind of atomic timestamp, and the OP wants to be
> able to CAS an instance of j.u.Instant.
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com <https://www.redhat.com/>>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/c579fe60/attachment-0001.html>

From dl at cs.oswego.edu  Thu Jul  6 08:25:19 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 6 Jul 2017 08:25:19 -0400
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
Message-ID: <a3fdb242-fa47-7eac-8ae1-60e70a879cf5@cs.oswego.edu>

On 07/06/2017 05:13 AM, Andrew Haley wrote:
> On 06/07/17 04:59, Michael Hixson wrote:
>> AtomicReference and VarHandle are specified to use == in compareAndSet
>> (and related) operations [1].  Using == to compare instances of
>> value-based classes may lead to "unpredictable results" [2].  Does
>> this mean I should avoid using compareAndSet with arguments that are
>> instances of value-based classes?
>>
>> It seems like the documentation clearly tells me "yes, avoid doing
>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>> VarHandle are exempt somehow.  Otherwise, how do I implement
>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>> value for example?
> 
> java.time.Instant stores times that are longer than a JVM word, so
> they cannot be CAS'd in a lock-free way unless a factory guarantees
> that instances which compare equal also have the property of
> reference equality.  j.t.Instant factories in the Java library are
> explicitly documented *not* to have this property, so that doesn't
> help.
> 
> If you want to be able to CAS a reference to a j.t.Instant, you're
> going to have to wrap accesses to it in a synchronized block.  This is
> a direct consequence of the JVM's inability to CAS multi-word objects.

Right. Hoping not add confusion, the underlying issues also arise in
upcoming Value Types. (https://wiki.openjdk.java.net/display/valhalla/Main)

These "actual" value types will (like primitives) use "==" for
(possibly multiple component) equality.
VarHandles for atomic operations will need to use some form of locking.
Possibilities (not yet fully implemented) include some combination of
(1) just using a global lock for all values (2) using a pool of locks
(e.g., hashed on containing object identityHashCode), and/or
(3) using native hardware transactions on platforms supporting them
(e.g., recent x86). Plus potential specializations for non-SC VarHandle
operations (e.g.,  seqlocks for getAcquire).

In principle, you could apply most of these (no HTM) for current uses of
value-based classes.

-Doug





> 
> There are some things we know, however, despite the documentation of
> "Value-based Classes".  For any reference r, r == r.  If r refers to a
> value-based class, r.equals(r) will always return true.  I don't think
> that anything which appears in that section can overrule these basic
> properties.  Because of this, you can keep a pool of Instant
> instances and intern them, and then, I believe, a reference CAS will
> work.  But you'll need a synchronized factory to do that.
> 
> Obviously a CAS-able timestamp would be a nice thing to have, but
> java.time.Instant is not the timestamp you're looking for.
> 


From kimo at webnetic.net  Thu Jul  6 09:37:35 2017
From: kimo at webnetic.net (Kimo Crossman)
Date: Thu, 6 Jul 2017 06:37:35 -0700
Subject: [concurrency-interest] Paper-> Exposing Non-Atomic Methods of
	Concurrent Objects
In-Reply-To: <CALV1V49zQpuFPZtTix_cxOGG0g9cfKcBFfNzco0_3AiHdUGpDg@mail.gmail.com>
References: <CALV1V49nwbZSDnnLZbBwcWR6qrn1zKKqQSWgn6oOCuDmsmAmwg@mail.gmail.com>
 <CALV1V49zQpuFPZtTix_cxOGG0g9cfKcBFfNzco0_3AiHdUGpDg@mail.gmail.com>
Message-ID: <CALV1V49Pf9PJ5V8mztL_3h7BtvhG72f-v3fm7AhME_VMsS6zCg@mail.gmail.com>

https://arxiv.org/abs/1706.09305

Exposing Non-Atomic Methods of Concurrent Objects
Michael Emmi <https://arxiv.org/find/cs/1/au:+Emmi_M/0/1/0/all/0/1>, Constantin
Enea <https://arxiv.org/find/cs/1/au:+Enea_C/0/1/0/all/0/1>
(Submitted on 28 Jun 2017)
In particular, we identify 10 classes in the
java.util.concurrent package which implement queues, deques, sets, and
key-value maps. For each class we
select a small set of core methods which are believed to behave atomically.
These core methods represent the
most basic operations, e.g., a key-value map’s put, get, remove, and
containsKey methods.

Multithreaded software is typically built with specialized concurrent
objects like atomic integers, queues, and maps. These objects' methods are
designed to behave according to certain consistency criteria like
atomicity, despite being optimized to avoid blocking and exploit
parallelism, e.g., by using atomic machine instructions like compare and
exchange (cmpxchg). Exposing atomicity violations is important since they
generally lead to elusive bugs that are difficult to identify, reproduce,
and ultimately repair.
In this work we expose atomicity violations in concurrent object
implementations from the most widely-used software development kit: The
Java Development Kit (JDK). We witness atomicity violations via simple test
harnesses containing few concurrent method invocations. While stress
testing is effective at exposing violations given catalytic test harnesses
and lightweight means of falsifying atomicity, divining effectual catalysts
can be difficult, and atomicity checks are generally cumbersome. We
overcome these problems by automating test-harness search, and establishing
atomicity via membership in precomputed sets of acceptable return-value
outcomes. Our approach enables testing millions of executions of each
harness each second (per processor core). This scale is important since
atomicity violations are observed in very few executions (tens to hundreds
out of millions) of very few harnesses (one out of hundreds to thousands).
Our implementation is open source and publicly available
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/c5f11db3/attachment.html>

From eregontp at gmail.com  Thu Jul  6 10:14:06 2017
From: eregontp at gmail.com (Benoit Daloze)
Date: Thu, 6 Jul 2017 16:14:06 +0200
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
Message-ID: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>

Hello all,

I have been chasing a scalability problem that only happens with over 8
cores on my benchmark and it turns out
ConcurrentHashMap#computeIfAbsent when used as a cache with the same key
does not scale.

Specifically, at least in Oracle JDK 8, #computeIfAbsent on the same key
synchronizes every time (on the same object) to return the existing mapping
value.
On the contrary, ConcurrentHashMap#get() does not synchronize and scales
well.

I thought computeIfAbsent() is a nice method to cache things in a CHM, but
obviously that's a very large drawback.

Original code not scaling:

Charset charset = encodingToCharsetMap.computeIfAbsent(encoding,
EncodingManager::charsetForEncoding);

New code, scaling:

Charset charset = encodingToCharsetMap.get(encoding);
if (charset == null) {
    charset = EncodingManager.charsetForEncoding(encoding);
    encodingToCharsetMap.putIfAbsent(encoding, charset);
    // More complex if charsetForEncoding is not idempotent
}

It seems in general the implementation of computeIfAbsent() in JDK 8
is optimizing for the absent case, which makes little sense when the map is
used as a cache.

Does using a ConcurrentHashMap as a cache with computeIfAbsent() make sense?
Do you think this worth a bug report?

-Benoit
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/0cb8bbaf/attachment.html>

From michael.hixson at gmail.com  Thu Jul  6 10:31:58 2017
From: michael.hixson at gmail.com (Michael Hixson)
Date: Thu, 6 Jul 2017 07:31:58 -0700
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
Message-ID: <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>

Forwarding this reply of mine because I forgot to CC the mailing list.


---------- Forwarded message ----------
From: Michael Hixson <michael.hixson at gmail.com>
Date: Thu, Jul 6, 2017 at 7:24 AM
Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
value-based classes?
To: Andrew Haley <aph at redhat.com>


On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
> On 06/07/17 11:41, Alex Otenko wrote:
>>
>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>
>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>> (and related) operations [1].  Using == to compare instances of
>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>> this mean I should avoid using compareAndSet with arguments that are
>>>> instances of value-based classes?
>>>>
>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>> value for example?
>>>
>>> java.time.Instant stores times that are longer than a JVM word, so
>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>> that instances which compare equal also have the property of
>>> reference equality.  j.t.Instant factories in the Java library are
>>> explicitly documented *not* to have this property, so that doesn't
>>> help.
>>
>> That’s not entirely clear.
>>
>> Wouldn’t this loop work:
>>
>> volatile j.t.Instant curr = ...
>>
>> j.t.Instant next = …
>> j.t.Instant tmp = ...
>> do {
>>   tmp = curr;
>>   if (tmp.equal(next)) break;
>> } while(!curr.CAS(tmp, next));
>>
>> // assume curr is equal to next
>
> Something like that, yes.  But it's going to be evil if there are
> several high-frequency writers.  If you're doing all that work in
> order to CAS a timestamp, why not use a synchronized block?  It would
> at least be less prone to the thundering herd, and we'd generate
> pretty decent code for that.  It'd be interesting to compare and
> contrast the two approaches for contended and non-contended cases.

The main reason I reached for AtomicReference is that I thought, "I
want thread-safe updates to this read-heavy value where writes won't
get lost if there's contention -- this sounds like the sort of problem
that java.util.concurrent.atomic solves."

As a minor point, I wanted synchronization on reads to be as
minor/invisible as possible, to affect the readers' behavior as little
as possible (in comparison to their behavior when the value they're
reading a constant value with no synchronization).

But if AtomicReference is simply the wrong tool to use here, I
shouldn't use it.  That's fine.

>
>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>> going to have to wrap accesses to it in a synchronized block.  This is
>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>
>> This is confusing.
>>
>> Surely this isn’t talking about CASing a reference? The contents of
>> the object can’t be assumed to have any atomicity properties,
>> whether it is j.t.Instant or not.
>
> I agree.  I'm trying to look at what the OP actually wants to do: I
> assume this is some kind of atomic timestamp, and the OP wants to be
> able to CAS an instance of j.u.Instant.

It was more of a general worry and question.  Should I ever use
AtomicReference with value-based classes?  It sounds like the answer
is no.

But here's some code that illustrates the specific problem I was
trying to solve.  I think it "works" right now, but that it's in
violation of the spec for value-based classes and so possibly not
future-proof, and I think I understand how to fix it now.  Thanks for
the tips.

    class MutableClock {

        static MutableClock create(Instant instant, ZoneId zone) {
            return new MutableClock(
                    new AtomicReference<>(instant),
                    zone);
        }

        private final AtomicReference<Instant> instantHolder;
        private final ZoneId zone;

        private MutableClock(
                AtomicReference<Instant> instantHolder,
                ZoneId zone) {
            this.instantHolder = instantHolder;
            this.zone = zone;
        }

        Instant instant() {
            return instantHolder.get();
        }

        ZoneId getZone() {
            return zone;
        }

        void setInstant(Instant newInstant) {
            instantHolder.set(newInstant);
        }

        void add(Duration amountToAdd) {
            // this is the part that uses == and CAS
            instantHolder.updateAndGet(
                  instant -> instant.plus(amountToAdd));
        }

        MutableClock withZone(ZoneId newZone) {
            // conveniently, AtomicReference also acts as a
            // vehicle for "shared updates" between instances
            // of my class
            return new MutableClock(instantHolder, newZone);
        }
    }

-Michael

From michael.hixson at gmail.com  Thu Jul  6 10:35:26 2017
From: michael.hixson at gmail.com (Michael Hixson)
Date: Thu, 6 Jul 2017 07:35:26 -0700
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <d7878920-ea28-1194-033a-d5b5cb38de10@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <CAHqckpPZkzpA0OrcKEUcyq7RVwOR4myqU9Exs_ua4VELH=uNzQ@mail.gmail.com>
 <d7878920-ea28-1194-033a-d5b5cb38de10@redhat.com>
Message-ID: <CAHqckpOJY8N0d7Xus6Z-=-RHuFimOnyecdE53Noeop=t8u_TXg@mail.gmail.com>

On Thu, Jul 6, 2017 at 7:27 AM, Andrew Haley <aph at redhat.com> wrote:
> On 06/07/17 15:00, Michael Hixson wrote:
>> Am I understanding you correctly that the reason compareAndSet does
>> the wrong/unwanted thing here is not actually because of the ==
>> comparison and ties to object identity, but because the value can't be
>> written atomically?
>
> I was trying to clarify, but my explanation seems to have made things worse.
>
> No, I'm not saying that.  The value can't be written atomically, that
> is true.  I am saying that it would be nice if we could CAS the
> *value* of a java.time.Instant, but we can't.  All we can CAS is a
> reference to an Instant, but we're not supposed to do that because
> we're not supposed to compare value-based classes with reference
> equality.  So, it's best to use a synchronized block.
>
> --
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

(re CC'ing the mailing list, oops)

Ah ok.  That makes sense, thanks.

-Michael

From dl at cs.oswego.edu  Thu Jul  6 10:47:17 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 6 Jul 2017 10:47:17 -0400
Subject: [concurrency-interest] Scalability of
 ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
Message-ID: <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>

On 07/06/2017 10:14 AM, Benoit Daloze wrote:

> I have been chasing a scalability problem that only happens with over 8
> cores on my benchmark and it turns out
> ConcurrentHashMap#computeIfAbsent when used as a cache with the same key
> does not scale.

Please try this using JDK9, which locks only on (possible) hash
collision. (See discussion in list archives.)
If we had known that JDK9 would face so much adoption delay,
we might have tried to arrange backports of this and other minor
improvements and fixes...

-Doug


From forax at univ-mlv.fr  Thu Jul  6 10:48:54 2017
From: forax at univ-mlv.fr (Remi Forax)
Date: Thu, 6 Jul 2017 16:48:54 +0200 (CEST)
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <a3fdb242-fa47-7eac-8ae1-60e70a879cf5@cs.oswego.edu>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <a3fdb242-fa47-7eac-8ae1-60e70a879cf5@cs.oswego.edu>
Message-ID: <1312065899.2400507.1499352534554.JavaMail.zimbra@u-pem.fr>

----- Mail original -----
> De: "Doug Lea" <dl at cs.oswego.edu>
> À: concurrency-interest at cs.oswego.edu
> Envoyé: Jeudi 6 Juillet 2017 14:25:19
> Objet: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?

> On 07/06/2017 05:13 AM, Andrew Haley wrote:
>> On 06/07/17 04:59, Michael Hixson wrote:
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?
>> 
>> java.time.Instant stores times that are longer than a JVM word, so
>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>> that instances which compare equal also have the property of
>> reference equality.  j.t.Instant factories in the Java library are
>> explicitly documented *not* to have this property, so that doesn't
>> help.
>> 
>> If you want to be able to CAS a reference to a j.t.Instant, you're
>> going to have to wrap accesses to it in a synchronized block.  This is
>> a direct consequence of the JVM's inability to CAS multi-word objects.
> 
> Right. Hoping not add confusion, the underlying issues also arise in
> upcoming Value Types. (https://wiki.openjdk.java.net/display/valhalla/Main)
> 
> These "actual" value types will (like primitives) use "==" for
> (possibly multiple component) equality.
> VarHandles for atomic operations will need to use some form of locking.
> Possibilities (not yet fully implemented) include some combination of
> (1) just using a global lock for all values (2) using a pool of locks
> (e.g., hashed on containing object identityHashCode), and/or
> (3) using native hardware transactions on platforms supporting them
> (e.g., recent x86). Plus potential specializations for non-SC VarHandle
> operations (e.g.,  seqlocks for getAcquire).
> 
> In principle, you could apply most of these (no HTM) for current uses of
> value-based classes.
> 
> -Doug

Value types have no identity so no identityHashCode.

Another alternative is to force the Value Type to implement an interface that will have a method providing the object that will be used to lock.

interface Lockable {
  Object lock();
}

value class MyValues implements Lockable {
  private final Object lock;
  private final Type1 field1;
  ...

  public Object lock() { return lock; }
}

cheers,
Rémi

From dl at cs.oswego.edu  Thu Jul  6 10:53:10 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 6 Jul 2017 10:53:10 -0400
Subject: [concurrency-interest] Paper-> Exposing Non-Atomic Methods of
 Concurrent Objects
In-Reply-To: <CALV1V49Pf9PJ5V8mztL_3h7BtvhG72f-v3fm7AhME_VMsS6zCg@mail.gmail.com>
References: <CALV1V49nwbZSDnnLZbBwcWR6qrn1zKKqQSWgn6oOCuDmsmAmwg@mail.gmail.com>
 <CALV1V49zQpuFPZtTix_cxOGG0g9cfKcBFfNzco0_3AiHdUGpDg@mail.gmail.com>
 <CALV1V49Pf9PJ5V8mztL_3h7BtvhG72f-v3fm7AhME_VMsS6zCg@mail.gmail.com>
Message-ID: <ceb1ceb8-22f3-1450-16ea-ac31d98b85e7@cs.oswego.edu>

On 07/06/2017 09:37 AM, Kimo Crossman wrote:
> https://arxiv.org/abs/1706.09305
>   Exposing Non-Atomic Methods of Concurrent Objects
> 
> Michael Emmi,  Constantin Enea

This tool seems useful (running it before release would have
picked up a fixed bug). The other non-atomicities reported
are expected, but show that people either don't read our
package-level documentation, or don't always bear it in mind.
Here's what it currently says. We should probably improve it, and/or
replicate some of it in particular classes. Suggestions welcome.

Pasting from ...
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/package-summary.html

Concurrent Collections
Besides Queues, this package supplies Collection implementations
designed for use in multithreaded contexts: ConcurrentHashMap,
ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and
CopyOnWriteArraySet. When many threads are expected to access a given
collection, a ConcurrentHashMap is normally preferable to a synchronized
HashMap, and a ConcurrentSkipListMap is normally preferable to a
synchronized TreeMap. A CopyOnWriteArrayList is preferable to a
synchronized ArrayList when the expected number of reads and traversals
greatly outnumber the number of updates to a list.

The "Concurrent" prefix used with some classes in this package is a
shorthand indicating several differences from similar "synchronized"
classes. For example java.util.Hashtable and
Collections.synchronizedMap(new HashMap()) are synchronized. But
ConcurrentHashMap is "concurrent". A concurrent collection is
thread-safe, but not governed by a single exclusion lock. In the
particular case of ConcurrentHashMap, it safely permits any number of
concurrent reads as well as a large number of concurrent writes.
"Synchronized" classes can be useful when you need to prevent all access
to a collection via a single lock, at the expense of poorer scalability.
In other cases in which multiple threads are expected to access a common
collection, "concurrent" versions are normally preferable. And
unsynchronized collections are preferable when either collections are
unshared, or are accessible only when holding other locks.

Most concurrent Collection implementations (including most Queues) also
differ from the usual java.util conventions in that their Iterators and
Spliterators provide weakly consistent rather than fast-fail traversal:

    they may proceed concurrently with other operations
    they will never throw ConcurrentModificationException
    they are guaranteed to traverse elements as they existed upon
construction exactly once, and may (but are not guaranteed to) reflect
any modifications subsequent to construction.

From jhump at bluegosling.com  Thu Jul  6 11:01:54 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Thu, 6 Jul 2017 11:01:54 -0400
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
Message-ID: <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>

On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>
> > I have been chasing a scalability problem that only happens with over 8
> > cores on my benchmark and it turns out
> > ConcurrentHashMap#computeIfAbsent when used as a cache with the same key
> > does not scale.
>

This is necessary since the spec
<https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function->
indicates
that the operation (including computation of the value) is atomic. To make
this atomic, it must use pessimistic locking, so it seems you are observing
lock contention. (Interestingly, this behavior contrasts with the default
implementation
<https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function->
in
the ConcurrentMap interface, which uses optimistic concurrency and retries
and makes no promise of atomicity.) The scalability of the map relies on
many threads operating on different keys, not all operations using the same
key.

Your work-around, to have every thread eagerly execute the function in
parallel and then "first one wins" to store the value in the map, looks
appropriate.


>
> Please try this using JDK9, which locks only on (possible) hash
> collision. (See discussion in list archives.)
>

The original question indicates the operation not scaling is for the same
key, so I think it will encounter a hash collision and the same scalability
issue even with this patch.


> If we had known that JDK9 would face so much adoption delay,
> we might have tried to arrange backports of this and other minor
> improvements and fixes...
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/bcab346c/attachment.html>

From me at yawk.at  Thu Jul  6 11:11:26 2017
From: me at yawk.at (Jonas Konrad)
Date: Thu, 6 Jul 2017 17:11:26 +0200
Subject: [concurrency-interest] Scalability of
 ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
Message-ID: <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>

I don't see how pessimistic locking is *required* for computeIfAbsent 
with a fast path for already-existing elements. It could basically do 
double-checked locking (and you can already to that manually, with the 
same guarantees as computeIfAbsent).

On 2017-07-06 17:01, Josh Humphries wrote:
> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:
>
>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>
>     > I have been chasing a scalability problem that only happens with over 8
>     > cores on my benchmark and it turns out
>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the same key
>     > does not scale.
>
>
> This is necessary since the spec
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function-> indicates
> that the operation (including computation of the value) is atomic. To
> make this atomic, it must use pessimistic locking, so it seems you are
> observing lock contention. (Interestingly, this behavior contrasts with
> the default implementation
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-> in
> the ConcurrentMap interface, which uses optimistic concurrency and
> retries and makes no promise of atomicity.) The scalability of the map
> relies on many threads operating on different keys, not all operations
> using the same key.
>
> Your work-around, to have every thread eagerly execute the function in
> parallel and then "first one wins" to store the value in the map, looks
> appropriate.
>
>
>
>     Please try this using JDK9, which locks only on (possible) hash
>     collision. (See discussion in list archives.)
>
>
> The original question indicates the operation not scaling is for the
> same key, so I think it will encounter a hash collision and the same
> scalability issue even with this patch.
>
>
>     If we had known that JDK9 would face so much adoption delay,
>     we might have tried to arrange backports of this and other minor
>     improvements and fixes...
>
>     -Doug
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From eregontp at gmail.com  Thu Jul  6 11:25:40 2017
From: eregontp at gmail.com (Benoit Daloze)
Date: Thu, 6 Jul 2017 17:25:40 +0200
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
Message-ID: <CANLTa0D+uCzBShs_a_ONVnK7GuPD7RvDJHTZWjygF7wgEw-jJw@mail.gmail.com>

Thank you for your answers, I'll give it a shot on JDK9.

As Jonas points out, I want to optimize for the key-is-present case.
I believe checking eagerly if the key is in the map does not affect
semantics, but it might affect the performance of the absent case a tiny
bit.

Another workaround which would work just as well here:

Charset charset = encodingToCharsetMap.get(encoding);
if (charset == null) {
    charset = encodingToCharsetMap.computeIfAbsent(encoding,
EncodingManager::charsetForEncoding);
}

So essentially just adding a fast-path, because #computeIfAbsent does not
scale on the same key when the key is already in the map.

-Benoit

On Thu, Jul 6, 2017 at 5:01 PM, Josh Humphries <jhump at bluegosling.com>
wrote:

> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>>
>> > I have been chasing a scalability problem that only happens with over 8
>> > cores on my benchmark and it turns out
>> > ConcurrentHashMap#computeIfAbsent when used as a cache with the same
>> key
>> > does not scale.
>>
>
> This is necessary since the spec
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function-> indicates
> that the operation (including computation of the value) is atomic. To make
> this atomic, it must use pessimistic locking, so it seems you are observing
> lock contention. (Interestingly, this behavior contrasts with the default
> implementation
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-> in
> the ConcurrentMap interface, which uses optimistic concurrency and
> retries and makes no promise of atomicity.) The scalability of the map
> relies on many threads operating on different keys, not all operations
> using the same key.
>
> Your work-around, to have every thread eagerly execute the function in
> parallel and then "first one wins" to store the value in the map, looks
> appropriate.
>
>
>>
>> Please try this using JDK9, which locks only on (possible) hash
>> collision. (See discussion in list archives.)
>>
>
> The original question indicates the operation not scaling is for the same
> key, so I think it will encounter a hash collision and the same scalability
> issue even with this patch.
>
>
>> If we had known that JDK9 would face so much adoption delay,
>> we might have tried to arrange backports of this and other minor
>> improvements and fixes...
>>
>> -Doug
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/45fce197/attachment-0001.html>

From viktor.klang at gmail.com  Thu Jul  6 11:30:47 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 6 Jul 2017 17:30:47 +0200
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
Message-ID: <CANPzfU9EDh4bAaOb-OHPX85PEjtdNST1p+hGZvACj0Fe0s9CYg@mail.gmail.com>

You could do a read, if absent you store a CompletableFuture with
putIfAbsent, and if you win you complete it with the result of the
computation, readers and losers of the putIfAbsent will get the CF and
block until it is available...

-- 
Cheers,
√

On Jul 6, 2017 5:11 PM, "Jonas Konrad" <me at yawk.at> wrote:

I don't see how pessimistic locking is *required* for computeIfAbsent with
a fast path for already-existing elements. It could basically do
double-checked locking (and you can already to that manually, with the same
guarantees as computeIfAbsent).


On 2017-07-06 17:01, Josh Humphries wrote:

> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:
>
>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>
>     > I have been chasing a scalability problem that only happens with
> over 8
>     > cores on my benchmark and it turns out
>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the
> same key
>     > does not scale.
>
>
> This is necessary since the spec
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
> ent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function->
> indicates
>
> that the operation (including computation of the value) is atomic. To
> make this atomic, it must use pessimistic locking, so it seems you are
> observing lock contention. (Interestingly, this behavior contrasts with
> the default implementation
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
> ent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-> in
>
> the ConcurrentMap interface, which uses optimistic concurrency and
> retries and makes no promise of atomicity.) The scalability of the map
> relies on many threads operating on different keys, not all operations
> using the same key.
>
> Your work-around, to have every thread eagerly execute the function in
> parallel and then "first one wins" to store the value in the map, looks
> appropriate.
>
>
>
>     Please try this using JDK9, which locks only on (possible) hash
>     collision. (See discussion in list archives.)
>
>
> The original question indicates the operation not scaling is for the
> same key, so I think it will encounter a hash collision and the same
> scalability issue even with this patch.
>
>
>     If we had known that JDK9 would face so much adoption delay,
>     we might have tried to arrange backports of this and other minor
>     improvements and fixes...
>
>     -Doug
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/149fec07/attachment.html>

From jhump at bluegosling.com  Thu Jul  6 11:38:04 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Thu, 6 Jul 2017 11:38:04 -0400
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
 <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
Message-ID: <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>

On Thu, Jul 6, 2017 at 11:11 AM, Jonas Konrad <me at yawk.at> wrote:

> I don't see how pessimistic locking is *required* for computeIfAbsent with
> a fast path for already-existing elements. It could basically do
> double-checked locking (and you can already to that manually, with the same
> guarantees as computeIfAbsent).


True enough. It is not required for the read case, when a value already
exists. In the latest JSR166 sources (targeted for JDK 9 I guess), if the
key is the first in the bin, it will be returned without locking. But if
querying the key encounters a hash collision (e.g. requires traversing a
list or tree in the bin), then a lock is acquired.


>
> On 2017-07-06 17:01, Josh Humphries wrote:
>
>> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
>> <mailto:dl at cs.oswego.edu>> wrote:
>>
>>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>>
>>     > I have been chasing a scalability problem that only happens with
>> over 8
>>     > cores on my benchmark and it turns out
>>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the
>> same key
>>     > does not scale.
>>
>>
>> This is necessary since the spec
>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>> ent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function->
>> indicates
>> that the operation (including computation of the value) is atomic. To
>> make this atomic, it must use pessimistic locking, so it seems you are
>> observing lock contention. (Interestingly, this behavior contrasts with
>> the default implementation
>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>> ent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-> in
>> the ConcurrentMap interface, which uses optimistic concurrency and
>> retries and makes no promise of atomicity.) The scalability of the map
>> relies on many threads operating on different keys, not all operations
>> using the same key.
>>
>> Your work-around, to have every thread eagerly execute the function in
>> parallel and then "first one wins" to store the value in the map, looks
>> appropriate.
>>
>>
>>
>>     Please try this using JDK9, which locks only on (possible) hash
>>     collision. (See discussion in list archives.)
>>
>>
>> The original question indicates the operation not scaling is for the
>> same key, so I think it will encounter a hash collision and the same
>> scalability issue even with this patch.
>>
>
I misunderstood your comment, Doug. Looks like this would indeed help
reduce the likelihood of the scalability issue observed.
Sorry.


>
>>
>>     If we had known that JDK9 would face so much adoption delay,
>>     we might have tried to arrange backports of this and other minor
>>     improvements and fixes...
>>
>>     -Doug
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/42ec8069/attachment.html>

From ben.manes at gmail.com  Thu Jul  6 11:53:08 2017
From: ben.manes at gmail.com (Benjamin Manes)
Date: Thu, 6 Jul 2017 08:53:08 -0700
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
 <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
 <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>
Message-ID: <CAGu0=MMQe8V_AZ3SwE9W102q+NibT+0H93iECh4SitgCfGuWhQ@mail.gmail.com>

An interesting insight Doug offered when this was first discussed is that
the performance profile differs at 32+ cores. I was surprised and able to
reproduce his results, though I still used the fast path in Caffeine for a
variety of reasons. If I recall correctly, a Zipf spread of keys was faster
with the pessimistic locking and a single key was much more comparable
(perhaps half the throughput). I would not have guess that interactions
with biased locking and safe points would have changed the profile that
much and depend on reaching a threshold core count. I still can't claim to
grok that.

On Thu, Jul 6, 2017 at 8:38 AM, Josh Humphries <jhump at bluegosling.com>
wrote:

>
> On Thu, Jul 6, 2017 at 11:11 AM, Jonas Konrad <me at yawk.at> wrote:
>
>> I don't see how pessimistic locking is *required* for computeIfAbsent
>> with a fast path for already-existing elements. It could basically do
>> double-checked locking (and you can already to that manually, with the same
>> guarantees as computeIfAbsent).
>
>
> True enough. It is not required for the read case, when a value already
> exists. In the latest JSR166 sources (targeted for JDK 9 I guess), if the
> key is the first in the bin, it will be returned without locking. But if
> querying the key encounters a hash collision (e.g. requires traversing a
> list or tree in the bin), then a lock is acquired.
>
>
>>
>> On 2017-07-06 17:01, Josh Humphries wrote:
>>
>>> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
>>> <mailto:dl at cs.oswego.edu>> wrote:
>>>
>>>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>>>
>>>     > I have been chasing a scalability problem that only happens with
>>> over 8
>>>     > cores on my benchmark and it turns out
>>>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the
>>> same key
>>>     > does not scale.
>>>
>>>
>>> This is necessary since the spec
>>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>>> ent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.funct
>>> ion.Function-> indicates
>>> that the operation (including computation of the value) is atomic. To
>>> make this atomic, it must use pessimistic locking, so it seems you are
>>> observing lock contention. (Interestingly, this behavior contrasts with
>>> the default implementation
>>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>>> ent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function->
>>> in
>>> the ConcurrentMap interface, which uses optimistic concurrency and
>>> retries and makes no promise of atomicity.) The scalability of the map
>>> relies on many threads operating on different keys, not all operations
>>> using the same key.
>>>
>>> Your work-around, to have every thread eagerly execute the function in
>>> parallel and then "first one wins" to store the value in the map, looks
>>> appropriate.
>>>
>>>
>>>
>>>     Please try this using JDK9, which locks only on (possible) hash
>>>     collision. (See discussion in list archives.)
>>>
>>>
>>> The original question indicates the operation not scaling is for the
>>> same key, so I think it will encounter a hash collision and the same
>>> scalability issue even with this patch.
>>>
>>
> I misunderstood your comment, Doug. Looks like this would indeed help
> reduce the likelihood of the scalability issue observed.
> Sorry.
>
>
>>
>>>
>>>     If we had known that JDK9 would face so much adoption delay,
>>>     we might have tried to arrange backports of this and other minor
>>>     improvements and fixes...
>>>
>>>     -Doug
>>>
>>>     _______________________________________________
>>>     Concurrency-interest mailing list
>>>     Concurrency-interest at cs.oswego.edu
>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/ba535eca/attachment-0001.html>

From jsampson at guidewire.com  Thu Jul  6 12:01:36 2017
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 6 Jul 2017 16:01:36 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
Message-ID: <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>

Howdy,

This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.

It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.

Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.

Cheers,
Justin


On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:

    Forwarding this reply of mine because I forgot to CC the mailing list.
    
    
    ---------- Forwarded message ----------
    From: Michael Hixson <michael.hixson at gmail.com>
    Date: Thu, Jul 6, 2017 at 7:24 AM
    Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
    value-based classes?
    To: Andrew Haley <aph at redhat.com>
    
    
    On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
    > On 06/07/17 11:41, Alex Otenko wrote:
    >>
    >>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
    >>>
    >>> On 06/07/17 04:59, Michael Hixson wrote:
    >>>> AtomicReference and VarHandle are specified to use == in compareAndSet
    >>>> (and related) operations [1].  Using == to compare instances of
    >>>> value-based classes may lead to "unpredictable results" [2].  Does
    >>>> this mean I should avoid using compareAndSet with arguments that are
    >>>> instances of value-based classes?
    >>>>
    >>>> It seems like the documentation clearly tells me "yes, avoid doing
    >>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
    >>>> VarHandle are exempt somehow.  Otherwise, how do I implement
    >>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
    >>>> value for example?
    >>>
    >>> java.time.Instant stores times that are longer than a JVM word, so
    >>> they cannot be CAS'd in a lock-free way unless a factory guarantees
    >>> that instances which compare equal also have the property of
    >>> reference equality.  j.t.Instant factories in the Java library are
    >>> explicitly documented *not* to have this property, so that doesn't
    >>> help.
    >>
    >> That’s not entirely clear.
    >>
    >> Wouldn’t this loop work:
    >>
    >> volatile j.t.Instant curr = ...
    >>
    >> j.t.Instant next = …
    >> j.t.Instant tmp = ...
    >> do {
    >>   tmp = curr;
    >>   if (tmp.equal(next)) break;
    >> } while(!curr.CAS(tmp, next));
    >>
    >> // assume curr is equal to next
    >
    > Something like that, yes.  But it's going to be evil if there are
    > several high-frequency writers.  If you're doing all that work in
    > order to CAS a timestamp, why not use a synchronized block?  It would
    > at least be less prone to the thundering herd, and we'd generate
    > pretty decent code for that.  It'd be interesting to compare and
    > contrast the two approaches for contended and non-contended cases.
    
    The main reason I reached for AtomicReference is that I thought, "I
    want thread-safe updates to this read-heavy value where writes won't
    get lost if there's contention -- this sounds like the sort of problem
    that java.util.concurrent.atomic solves."
    
    As a minor point, I wanted synchronization on reads to be as
    minor/invisible as possible, to affect the readers' behavior as little
    as possible (in comparison to their behavior when the value they're
    reading a constant value with no synchronization).
    
    But if AtomicReference is simply the wrong tool to use here, I
    shouldn't use it.  That's fine.
    
    >
    >>> If you want to be able to CAS a reference to a j.t.Instant, you're
    >>> going to have to wrap accesses to it in a synchronized block.  This is
    >>> a direct consequence of the JVM's inability to CAS multi-word objects.
    >>
    >> This is confusing.
    >>
    >> Surely this isn’t talking about CASing a reference? The contents of
    >> the object can’t be assumed to have any atomicity properties,
    >> whether it is j.t.Instant or not.
    >
    > I agree.  I'm trying to look at what the OP actually wants to do: I
    > assume this is some kind of atomic timestamp, and the OP wants to be
    > able to CAS an instance of j.u.Instant.
    
    It was more of a general worry and question.  Should I ever use
    AtomicReference with value-based classes?  It sounds like the answer
    is no.
    
    But here's some code that illustrates the specific problem I was
    trying to solve.  I think it "works" right now, but that it's in
    violation of the spec for value-based classes and so possibly not
    future-proof, and I think I understand how to fix it now.  Thanks for
    the tips.
    
        class MutableClock {
    
            static MutableClock create(Instant instant, ZoneId zone) {
                return new MutableClock(
                        new AtomicReference<>(instant),
                        zone);
            }
    
            private final AtomicReference<Instant> instantHolder;
            private final ZoneId zone;
    
            private MutableClock(
                    AtomicReference<Instant> instantHolder,
                    ZoneId zone) {
                this.instantHolder = instantHolder;
                this.zone = zone;
            }
    
            Instant instant() {
                return instantHolder.get();
            }
    
            ZoneId getZone() {
                return zone;
            }
    
            void setInstant(Instant newInstant) {
                instantHolder.set(newInstant);
            }
    
            void add(Duration amountToAdd) {
                // this is the part that uses == and CAS
                instantHolder.updateAndGet(
                      instant -> instant.plus(amountToAdd));
            }
    
            MutableClock withZone(ZoneId newZone) {
                // conveniently, AtomicReference also acts as a
                // vehicle for "shared updates" between instances
                // of my class
                return new MutableClock(instantHolder, newZone);
            }
        }
    
    -Michael
    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    


From test1 at doramail.com  Thu Jul  6 12:20:29 2017
From: test1 at doramail.com (Testo Nakada)
Date: Thu, 6 Jul 2017 18:20:29 +0200
Subject: [concurrency-interest] Scalability of
 ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CAGu0=MMQe8V_AZ3SwE9W102q+NibT+0H93iECh4SitgCfGuWhQ@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
 <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
 <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>
 <CAGu0=MMQe8V_AZ3SwE9W102q+NibT+0H93iECh4SitgCfGuWhQ@mail.gmail.com>
Message-ID: <trinity-b10f6714-3266-49ca-aacb-632141b0ea32-1499358029210@3capp-mailcom-lxa14>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/51c31748/attachment.html>

From gil at azul.com  Thu Jul  6 12:33:52 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 16:33:52 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet
	with	value-based classes?
In-Reply-To: <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>,
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
Message-ID: <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>

It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".

Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.

For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).

We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.

It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.

For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.

One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...

This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.

Sent from my iPad

On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

:-) the one causing Byzantine failures!

Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.

All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).


Alex


On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:

just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
•  Sebastian

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
Sent: Thursday, July 06, 2017 10:17 AM
To: Gil Tene
Cc: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?


On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:
All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

It also means that even when:

  LocalDateTime d = a;
  ...
  (a == d) may or may not be true. And may change whether it is true or not at any time,

I meant an even stronger assertion:

assert (a==b) == (b==a) : "No Byzantine optimizations"
assert (a==d) == (a==d): “No Byzantine optimizations"

Alex





Alex

On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:
Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else




On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com<http://www.softwareag.com/>


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/b36da75a/attachment-0001.html>

From eregontp at gmail.com  Thu Jul  6 13:09:29 2017
From: eregontp at gmail.com (Benoit Daloze)
Date: Thu, 6 Jul 2017 19:09:29 +0200
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <trinity-b10f6714-3266-49ca-aacb-632141b0ea32-1499358029210@3capp-mailcom-lxa14>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
 <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
 <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>
 <CAGu0=MMQe8V_AZ3SwE9W102q+NibT+0H93iECh4SitgCfGuWhQ@mail.gmail.com>
 <trinity-b10f6714-3266-49ca-aacb-632141b0ea32-1499358029210@3capp-mailcom-lxa14>
Message-ID: <CANLTa0C6GaK0mxAtHxYXEe2=vxLfn=dw1w65ve507yX0w1GvNg@mail.gmail.com>

Indeed, this is the exact same issue, thank you for the link!

The fix only fixes the case where this is the first node in the bin (no
collision) though, as Josh mentioned.

This is interestingly contradicting CHM's own JavaDoc:

 * <p>A ConcurrentHashMap can be used as a scalable frequency map (a
 * form of histogram or multiset) by using {@link
 * java.util.concurrent.atomic.LongAdder} values and initializing via
 * {@link #computeIfAbsent computeIfAbsent}. For example, to add a count
 * to a {@code ConcurrentHashMap<String,LongAdder> freqs}, you can use
 * {@code freqs.computeIfAbsent(key, k -> new LongAdder()).increment();}

This will not scale if a key accessed frequently is not the first in its
bin.

-Benoit

On Thu, Jul 6, 2017 at 6:20 PM, Testo Nakada <test1 at doramail.com> wrote:

> Does this have something to do with this JDK issue http://bugs.java.com/
> bugdatabase/view_bug.do?bug_id=8161372?
>
> *Sent:* Thursday, July 06, 2017 at 8:53 AM
> *From:* "Benjamin Manes" <ben.manes at gmail.com>
> *To:* "Josh Humphries" <jhump at bluegosling.com>
> *Cc:* concurrency-interest <concurrency-interest at cs.oswego.edu>
> *Subject:* Re: [concurrency-interest] Scalability of ConcurrentHashMap#
> computeIfAbsent
> An interesting insight Doug offered when this was first discussed is that
> the performance profile differs at 32+ cores. I was surprised and able to
> reproduce his results, though I still used the fast path in Caffeine for a
> variety of reasons. If I recall correctly, a Zipf spread of keys was faster
> with the pessimistic locking and a single key was much more comparable
> (perhaps half the throughput). I would not have guess that interactions
> with biased locking and safe points would have changed the profile that
> much and depend on reaching a threshold core count. I still can't claim to
> grok that.
>
> On Thu, Jul 6, 2017 at 8:38 AM, Josh Humphries <jhump at bluegosling.com>
> wrote:
>>
>>
>> On Thu, Jul 6, 2017 at 11:11 AM, Jonas Konrad <me at yawk.at> wrote:
>>>
>>> I don't see how pessimistic locking is *required* for computeIfAbsent
>>> with a fast path for already-existing elements. It could basically do
>>> double-checked locking (and you can already to that manually, with the same
>>> guarantees as computeIfAbsent).
>>
>>
>> True enough. It is not required for the read case, when a value already
>> exists. In the latest JSR166 sources (targeted for JDK 9 I guess), if the
>> key is the first in the bin, it will be returned without locking. But if
>> querying the key encounters a hash collision (e.g. requires traversing a
>> list or tree in the bin), then a lock is acquired.
>>
>>
>>>
>>> On 2017-07-06 17:01, Josh Humphries wrote:
>>>>
>>>> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
>>>> <mailto:dl at cs.oswego.edu>> wrote:
>>>>
>>>>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>>>>
>>>>     > I have been chasing a scalability problem that only happens with
>>>> over 8
>>>>     > cores on my benchmark and it turns out
>>>>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the
>>>> same key
>>>>     > does not scale.
>>>>
>>>>
>>>> This is necessary since the spec
>>>> <https://docs.oracle.com/javase/8/docs/api/java/util/
>>>> concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.
>>>> util.function.Function-> indicates
>>>> that the operation (including computation of the value) is atomic. To
>>>> make this atomic, it must use pessimistic locking, so it seems you are
>>>> observing lock contention. (Interestingly, this behavior contrasts with
>>>> the default implementation
>>>> <https://docs.oracle.com/javase/8/docs/api/java/util/
>>>> concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.
>>>> function.Function-> in
>>>> the ConcurrentMap interface, which uses optimistic concurrency and
>>>> retries and makes no promise of atomicity.) The scalability of the map
>>>> relies on many threads operating on different keys, not all operations
>>>> using the same key.
>>>>
>>>> Your work-around, to have every thread eagerly execute the function in
>>>> parallel and then "first one wins" to store the value in the map, looks
>>>> appropriate.
>>>>
>>>>
>>>>
>>>>     Please try this using JDK9, which locks only on (possible) hash
>>>>     collision. (See discussion in list archives.)
>>>>
>>>>
>>>> The original question indicates the operation not scaling is for the
>>>> same key, so I think it will encounter a hash collision and the same
>>>> scalability issue even with this patch.
>>>
>>>
>> I misunderstood your comment, Doug. Looks like this would indeed help
>> reduce the likelihood of the scalability issue observed.
>> Sorry.
>>
>>
>>>
>>>>
>>>>     If we had known that JDK9 would face so much adoption delay,
>>>>     we might have tried to arrange backports of this and other minor
>>>>     improvements and fixes...
>>>>
>>>>     -Doug
>>>>
>>>>     _______________________________________________
>>>>     Concurrency-interest mailing list
>>>>     Concurrency-interest at cs.oswego.edu
>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________ Concurrency-interest
> mailing list Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/11d5b020/attachment.html>

From eregontp at gmail.com  Thu Jul  6 13:12:25 2017
From: eregontp at gmail.com (Benoit Daloze)
Date: Thu, 6 Jul 2017 19:12:25 +0200
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CANLTa0C6GaK0mxAtHxYXEe2=vxLfn=dw1w65ve507yX0w1GvNg@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CAO78j+L3=Sz+cwnyGxbmQ5SE2Tt2FTej2B6P-nBtkVNHvHC_eg@mail.gmail.com>
 <53608542-caaf-b44f-9dcb-19398b89bc85@yawk.at>
 <CAO78j+LFyABY5qtKPxshFyBzN4cNrG4Uon8Bw83UAHEX58w0yQ@mail.gmail.com>
 <CAGu0=MMQe8V_AZ3SwE9W102q+NibT+0H93iECh4SitgCfGuWhQ@mail.gmail.com>
 <trinity-b10f6714-3266-49ca-aacb-632141b0ea32-1499358029210@3capp-mailcom-lxa14>
 <CANLTa0C6GaK0mxAtHxYXEe2=vxLfn=dw1w65ve507yX0w1GvNg@mail.gmail.com>
Message-ID: <CANLTa0DA-G=C2VwpQpL1Tf7XGTV3yyGqunkhJ95S1HxNXBOKrg@mail.gmail.com>

(but arguably the increment does not scale so well either if frequently
done on the same LongAdder)

On Thu, Jul 6, 2017 at 7:09 PM, Benoit Daloze <eregontp at gmail.com> wrote:

> Indeed, this is the exact same issue, thank you for the link!
>
> The fix only fixes the case where this is the first node in the bin (no
> collision) though, as Josh mentioned.
>
> This is interestingly contradicting CHM's own JavaDoc:
>
>  * <p>A ConcurrentHashMap can be used as a scalable frequency map (a
>  * form of histogram or multiset) by using {@link
>  * java.util.concurrent.atomic.LongAdder} values and initializing via
>  * {@link #computeIfAbsent computeIfAbsent}. For example, to add a count
>  * to a {@code ConcurrentHashMap<String,LongAdder> freqs}, you can use
>  * {@code freqs.computeIfAbsent(key, k -> new LongAdder()).increment();}
>
> This will not scale if a key accessed frequently is not the first in its
> bin.
>
> -Benoit
>
> On Thu, Jul 6, 2017 at 6:20 PM, Testo Nakada <test1 at doramail.com> wrote:
>
>> Does this have something to do with this JDK issue
>> http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8161372?
>>
>> *Sent:* Thursday, July 06, 2017 at 8:53 AM
>> *From:* "Benjamin Manes" <ben.manes at gmail.com>
>> *To:* "Josh Humphries" <jhump at bluegosling.com>
>> *Cc:* concurrency-interest <concurrency-interest at cs.oswego.edu>
>> *Subject:* Re: [concurrency-interest] Scalability of
>> ConcurrentHashMap#computeIfAbsent
>> An interesting insight Doug offered when this was first discussed is that
>> the performance profile differs at 32+ cores. I was surprised and able to
>> reproduce his results, though I still used the fast path in Caffeine for a
>> variety of reasons. If I recall correctly, a Zipf spread of keys was faster
>> with the pessimistic locking and a single key was much more comparable
>> (perhaps half the throughput). I would not have guess that interactions
>> with biased locking and safe points would have changed the profile that
>> much and depend on reaching a threshold core count. I still can't claim to
>> grok that.
>>
>> On Thu, Jul 6, 2017 at 8:38 AM, Josh Humphries <jhump at bluegosling.com>
>> wrote:
>>>
>>>
>>> On Thu, Jul 6, 2017 at 11:11 AM, Jonas Konrad <me at yawk.at> wrote:
>>>>
>>>> I don't see how pessimistic locking is *required* for computeIfAbsent
>>>> with a fast path for already-existing elements. It could basically do
>>>> double-checked locking (and you can already to that manually, with the same
>>>> guarantees as computeIfAbsent).
>>>
>>>
>>> True enough. It is not required for the read case, when a value already
>>> exists. In the latest JSR166 sources (targeted for JDK 9 I guess), if the
>>> key is the first in the bin, it will be returned without locking. But if
>>> querying the key encounters a hash collision (e.g. requires traversing a
>>> list or tree in the bin), then a lock is acquired.
>>>
>>>
>>>>
>>>> On 2017-07-06 17:01, Josh Humphries wrote:
>>>>>
>>>>> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu
>>>>> <mailto:dl at cs.oswego.edu>> wrote:
>>>>>
>>>>>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
>>>>>
>>>>>     > I have been chasing a scalability problem that only happens with
>>>>> over 8
>>>>>     > cores on my benchmark and it turns out
>>>>>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the
>>>>> same key
>>>>>     > does not scale.
>>>>>
>>>>>
>>>>> This is necessary since the spec
>>>>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>>>>> ent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.
>>>>> function.Function-> indicates
>>>>> that the operation (including computation of the value) is atomic. To
>>>>> make this atomic, it must use pessimistic locking, so it seems you are
>>>>> observing lock contention. (Interestingly, this behavior contrasts with
>>>>> the default implementation
>>>>> <https://docs.oracle.com/javase/8/docs/api/java/util/concurr
>>>>> ent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function->
>>>>> in
>>>>> the ConcurrentMap interface, which uses optimistic concurrency and
>>>>> retries and makes no promise of atomicity.) The scalability of the map
>>>>> relies on many threads operating on different keys, not all operations
>>>>> using the same key.
>>>>>
>>>>> Your work-around, to have every thread eagerly execute the function in
>>>>> parallel and then "first one wins" to store the value in the map, looks
>>>>> appropriate.
>>>>>
>>>>>
>>>>>
>>>>>     Please try this using JDK9, which locks only on (possible) hash
>>>>>     collision. (See discussion in list archives.)
>>>>>
>>>>>
>>>>> The original question indicates the operation not scaling is for the
>>>>> same key, so I think it will encounter a hash collision and the same
>>>>> scalability issue even with this patch.
>>>>
>>>>
>>> I misunderstood your comment, Doug. Looks like this would indeed help
>>> reduce the likelihood of the scalability issue observed.
>>> Sorry.
>>>
>>>
>>>>
>>>>>
>>>>>     If we had known that JDK9 would face so much adoption delay,
>>>>>     we might have tried to arrange backports of this and other minor
>>>>>     improvements and fixes...
>>>>>
>>>>>     -Doug
>>>>>
>>>>>     _______________________________________________
>>>>>     Concurrency-interest mailing list
>>>>>     Concurrency-interest at cs.oswego.edu
>>>>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>> _______________________________________________ Concurrency-interest
>> mailing list Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/5f7aa348/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Jul  6 13:46:09 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 18:46:09 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
Message-ID: <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>

Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.

List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.

Alex

> On 6 Jul 2017, at 17:33, Gil Tene <gil at azul.com> wrote:
> 
> It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen". 
> 
> Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.
> 
> For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).
> 
> We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.
> 
> It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.
> 
> For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.
> 
> One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...
> 
> This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.
> 
> Sent from my iPad
> 
> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> 
>> :-) the one causing Byzantine failures!
>> 
>> Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.
>> 
>> All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).
>> 
>> 
>> Alex
>> 
>> 
>>> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com <mailto:Sebastian.Millies at softwareag.com>> wrote:
>>> 
>>> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
>>> n  Sebastian
>>>  
>>> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Alex Otenko
>>> Sent: Thursday, July 06, 2017 10:17 AM
>>> To: Gil Tene
>>> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
>>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>>>  
>>>  
>>> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>  
>>> 
>>> 
>>> Sent from my iPad
>>> 
>>> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>> 
>>> All it is saying is:
>>>  
>>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>>>  
>>> a==b && b==c can be true and can be false
>>>  
>>> It also means that even when:
>>>  
>>>   LocalDateTime d = a;
>>>   ...
>>>   (a == d) may or may not be true. And may change whether it is true or not at any time,
>>>  
>>> I meant an even stronger assertion:
>>>  
>>> assert (a==b) == (b==a) : "No Byzantine optimizations"
>>> assert (a==d) == (a==d): “No Byzantine optimizations"
>>>  
>>> Alex
>>>  
>>> 
>>> 
>>>  
>>>  
>>> Alex
>>>  
>>> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>  
>>> 
>>> 
>>> Sent from my iPad
>>> 
>>> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
>>> 
>>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content. 
>>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>>> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>>>  
>>> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>>>   int a = 5;
>>>   int b = 5;
>>>   boolean y = (a == b);  // true
>>>  
>>> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>>>   Integer a = new Integer(5);
>>>   Integer b = new Integer(5);
>>>   boolean x = a.equals(b);   // true
>>>   boolean y = (a == b);   // false
>>>  
>>> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>>>  
>>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>   boolean x = a.equals(b);   // true
>>>   boolean y = (a == b);   // unpredictable, undefined, who knows. 
>>>                                          // Could be true, could be false.
>>>                                          // Could theoretically change the values of a or b, or of something else
>>>  
>>> 
>>> 
>>>  
>>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> 
>>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>>> 
>>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>>> For example:
>>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>>> 
>>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>>> 
>>> — Gil.
>>> 
>>> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>>> >
>>> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>>> >
>>> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>>> >
>>> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>>> >
>>> >
>>> > On 2017-07-05 09:20 PM, Gil Tene wrote:
>>> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>> >> — Gil.
>>> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com <mailto:michael.hixson at gmail.com>> wrote:
>>> >>>
>>> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> >>> (and related) operations [1].  Using == to compare instances of
>>> >>> value-based classes may lead to "unpredictable results" [2].  Does
>>> >>> this mean I should avoid using compareAndSet with arguments that are
>>> >>> instances of value-based classes?
>>> >>>
>>> >>> It seems like the documentation clearly tells me "yes, avoid doing
>>> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> >>> value for example?  Do I have to box the value in something that's not
>>> >>> a value-based class first, like AtomicReference<Box<Instant>>?
>>> >>>
>>> >>> -Michael
>>> >>>
>>> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V- <http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V->
>>> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html <http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html>
>>> >
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>  
>>>  
>>> 
>>> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com <http://www.softwareag.com/>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/99d2dba5/attachment-0001.html>

From david.lloyd at redhat.com  Thu Jul  6 13:46:45 2017
From: david.lloyd at redhat.com (David Lloyd)
Date: Thu, 6 Jul 2017 12:46:45 -0500
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
Message-ID: <CANghgrRkCn9MXA4gCDWitXOmrJWLqb9FJwaoQEPDm6WL-nn8oQ@mail.gmail.com>

I sent this from the wrong e-mail address due to MUA change.  Resending...

On Wed, Jul 5, 2017 at 11:20 PM, Gil Tene <gil at azul.com> wrote:
> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>
> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>
> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.

How many generic concurrent data structures exist which (to name one
example) use compareAndSet() to update a value in the two-argument
replace() case?  What measures do (or can) these structures take to
prevent these magical value types from being used in these cases?

If we (as the collective concurrency community and as the greater Java
community) allow these magical value types to *actually* stop working
in some logical fashion with == and therefore with CAS, we are utterly
deserving of the chaos that will result.  In particular, it would be a
terrible idea to allow the basic CAS loop to be broken for some Object
subclasses:

   do {
       a = atomic.get();
       b = compute(a);
   } while (! atomic.compareAndSet(a, b));

No amount of performance optimization is worth breaking the
correctness of this fundamental structure.

From gil at azul.com  Thu Jul  6 13:49:38 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 17:49:38 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>,
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
Message-ID: <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>

We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.

To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
- There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
- Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.

This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).

Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.

In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().

Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 

Sent from my iPad

> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
> 
> Howdy,
> 
> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
> 
> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
> 
> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
> 
> Cheers,
> Justin
> 
> 
> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
> 
>    Forwarding this reply of mine because I forgot to CC the mailing list.
> 
> 
>    ---------- Forwarded message ----------
>    From: Michael Hixson <michael.hixson at gmail.com>
>    Date: Thu, Jul 6, 2017 at 7:24 AM
>    Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>    value-based classes?
>    To: Andrew Haley <aph at redhat.com>
> 
> 
>>>>    On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>> 
>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>> 
>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>> (and related) operations [1].  Using == to compare instances of
>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>> instances of value-based classes?
>>>>> 
>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>> value for example?
>>>> 
>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>> that instances which compare equal also have the property of
>>>> reference equality.  j.t.Instant factories in the Java library are
>>>> explicitly documented *not* to have this property, so that doesn't
>>>> help.
>>> 
>>> That’s not entirely clear.
>>> 
>>> Wouldn’t this loop work:
>>> 
>>> volatile j.t.Instant curr = ...
>>> 
>>> j.t.Instant next = …
>>> j.t.Instant tmp = ...
>>> do {
>>>  tmp = curr;
>>>  if (tmp.equal(next)) break;
>>> } while(!curr.CAS(tmp, next));
>>> 
>>> // assume curr is equal to next
>> 
>> Something like that, yes.  But it's going to be evil if there are
>> several high-frequency writers.  If you're doing all that work in
>> order to CAS a timestamp, why not use a synchronized block?  It would
>> at least be less prone to the thundering herd, and we'd generate
>> pretty decent code for that.  It'd be interesting to compare and
>> contrast the two approaches for contended and non-contended cases.
> 
>    The main reason I reached for AtomicReference is that I thought, "I
>    want thread-safe updates to this read-heavy value where writes won't
>    get lost if there's contention -- this sounds like the sort of problem
>    that java.util.concurrent.atomic solves."
> 
>    As a minor point, I wanted synchronization on reads to be as
>    minor/invisible as possible, to affect the readers' behavior as little
>    as possible (in comparison to their behavior when the value they're
>    reading a constant value with no synchronization).
> 
>    But if AtomicReference is simply the wrong tool to use here, I
>    shouldn't use it.  That's fine.
> 
>> 
>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>> 
>>> This is confusing.
>>> 
>>> Surely this isn’t talking about CASing a reference? The contents of
>>> the object can’t be assumed to have any atomicity properties,
>>> whether it is j.t.Instant or not.
>> 
>> I agree.  I'm trying to look at what the OP actually wants to do: I
>> assume this is some kind of atomic timestamp, and the OP wants to be
>> able to CAS an instance of j.u.Instant.
> 
>    It was more of a general worry and question.  Should I ever use
>    AtomicReference with value-based classes?  It sounds like the answer
>    is no.
> 
>    But here's some code that illustrates the specific problem I was
>    trying to solve.  I think it "works" right now, but that it's in
>    violation of the spec for value-based classes and so possibly not
>    future-proof, and I think I understand how to fix it now.  Thanks for
>    the tips.
> 
>        class MutableClock {
> 
>            static MutableClock create(Instant instant, ZoneId zone) {
>                return new MutableClock(
>                        new AtomicReference<>(instant),
>                        zone);
>            }
> 
>            private final AtomicReference<Instant> instantHolder;
>            private final ZoneId zone;
> 
>            private MutableClock(
>                    AtomicReference<Instant> instantHolder,
>                    ZoneId zone) {
>                this.instantHolder = instantHolder;
>                this.zone = zone;
>            }
> 
>            Instant instant() {
>                return instantHolder.get();
>            }
> 
>            ZoneId getZone() {
>                return zone;
>            }
> 
>            void setInstant(Instant newInstant) {
>                instantHolder.set(newInstant);
>            }
> 
>            void add(Duration amountToAdd) {
>                // this is the part that uses == and CAS
>                instantHolder.updateAndGet(
>                      instant -> instant.plus(amountToAdd));
>            }
> 
>            MutableClock withZone(ZoneId newZone) {
>                // conveniently, AtomicReference also acts as a
>                // vehicle for "shared updates" between instances
>                // of my class
>                return new MutableClock(instantHolder, newZone);
>            }
>        }
> 
>    -Michael
>    _______________________________________________
>    Concurrency-interest mailing list
>    Concurrency-interest at cs.oswego.edu
>    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From gil at azul.com  Thu Jul  6 13:52:56 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 17:52:56 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>,
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
Message-ID: <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>

Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).

Sent from my iPad

On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.

List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.

Alex

On 6 Jul 2017, at 17:33, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:

It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".

Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.

For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).

We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.

It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.

For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.

One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...

This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.

Sent from my iPad

On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

:-) the one causing Byzantine failures!

Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.

All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).


Alex


On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:

just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
•  Sebastian

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
Sent: Thursday, July 06, 2017 10:17 AM
To: Gil Tene
Cc: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?


On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:
All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

It also means that even when:

  LocalDateTime d = a;
  ...
  (a == d) may or may not be true. And may change whether it is true or not at any time,

I meant an even stronger assertion:

assert (a==b) == (b==a) : "No Byzantine optimizations"
assert (a==d) == (a==d): “No Byzantine optimizations"

Alex





Alex

On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:
Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else




On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com<http://www.softwareag.com/>


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/01f5fd24/attachment-0001.html>

From gil at azul.com  Thu Jul  6 14:15:28 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 18:15:28 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>,
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>,
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
Message-ID: <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>

David, the below is a (potentially good) argument for not allowing the creation of subclasses of Object that do not have well defined support identity, identity comparison, identity hashing, or synchronization, since Object supports all those, things that hold Object instances may very well make use of them.

But that horse has long fled the barn. We can argue that value-based classes should not have been specified in Java 8. Or that the future value types should not be derived from Object. But the first case is already in the Java spec, and the second is likely coming (and is sneakily able to use the first as a precedent).

For the "how should we specify things?" discussion, I'm actually squarely on the side of "things with no identity should never have been derived from Object" of this argument. E.g. I would advise other language specifications to avoid making the same mistake, either by not giving the base Object class identity to begin with, or by creating a separate orthogonal type hierarchy for value types and "value based" classes. However, I don't see a way to "fix" the mistake already made, and we have to deal with the language and the machine as spec'ed, not as we wish it were. And so does anyone writing code in the language.

In the context of that reality, we are discussing what correct uses of those new "basterd children of Object" are. And since the basterds clearly have no identity, using any logic that relies on identity behavior in any way is wrong.

Sent from my iPad

On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:

Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).

Sent from my iPad

On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.

List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.

Alex

On 6 Jul 2017, at 17:33, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:

It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".

Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.

For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).

We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.

It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.

For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.

One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...

This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.

Sent from my iPad

On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

:-) the one causing Byzantine failures!

Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.

All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).


Alex


On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:

just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
•  Sebastian

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
Sent: Thursday, July 06, 2017 10:17 AM
To: Gil Tene
Cc: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?


On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:
All it is saying is:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");

a==b && b==c can be true and can be false

It also means that even when:

  LocalDateTime d = a;
  ...
  (a == d) may or may not be true. And may change whether it is true or not at any time,

I meant an even stronger assertion:

assert (a==b) == (b==a) : "No Byzantine optimizations"
assert (a==d) == (a==d): “No Byzantine optimizations"

Alex





Alex

On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:



Sent from my iPad

On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com<mailto:dahankzter at gmail.com>> wrote:
Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
.equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.

For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
  int a = 5;
  int b = 5;
  boolean y = (a == b);  // true

For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
  Integer a = new Integer(5);
  Integer b = new Integer(5);
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // false

And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:

  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
  boolean x = a.equals(b);   // true
  boolean y = (a == b);   // unpredictable, undefined, who knows.
                                         // Could be true, could be false.
                                         // Could theoretically change the values of a or b, or of something else




On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com<mailto:gil at azul.com>> wrote:

I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.

While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
For example:
- It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
- It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
- It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
- It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).

So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.

— Gil.

> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:
>
> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>
> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>
> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>
>
> On 2017-07-05 09:20 PM, Gil Tene wrote:
>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>> — Gil.
>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com<mailto:michael.hixson at gmail.com>> wrote:
>>>
>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>> (and related) operations [1].  Using == to compare instances of
>>> value-based classes may lead to "unpredictable results" [2].  Does
>>> this mean I should avoid using compareAndSet with arguments that are
>>> instances of value-based classes?
>>>
>>> It seems like the documentation clearly tells me "yes, avoid doing
>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>> value for example?  Do I have to box the value in something that's not
>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>
>>> -Michael
>>>
>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com<http://www.softwareag.com/>


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/b6de7ed8/attachment-0001.html>

From jsampson at guidewire.com  Thu Jul  6 14:47:31 2017
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 6 Jul 2017 18:47:31 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
Message-ID: <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>

That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.

-Justin


On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:

    We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
    
    To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
    - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
    - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
    
    This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
    
    Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
    
    In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
    
    Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
    
    Sent from my iPad
    
    > On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
    > 
    > Howdy,
    > 
    > This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
    > 
    > It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
    > 
    > Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
    > 
    > Cheers,
    > Justin
    > 
    > 
    > On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
    > 
    >    Forwarding this reply of mine because I forgot to CC the mailing list.
    > 
    > 
    >    ---------- Forwarded message ----------
    >    From: Michael Hixson <michael.hixson at gmail.com>
    >    Date: Thu, Jul 6, 2017 at 7:24 AM
    >    Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
    >    value-based classes?
    >    To: Andrew Haley <aph at redhat.com>
    > 
    > 
    >>>>    On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
    >>>>> On 06/07/17 11:41, Alex Otenko wrote:
    >>>> 
    >>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
    >>>> 
    >>>> On 06/07/17 04:59, Michael Hixson wrote:
    >>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
    >>>>> (and related) operations [1].  Using == to compare instances of
    >>>>> value-based classes may lead to "unpredictable results" [2].  Does
    >>>>> this mean I should avoid using compareAndSet with arguments that are
    >>>>> instances of value-based classes?
    >>>>> 
    >>>>> It seems like the documentation clearly tells me "yes, avoid doing
    >>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
    >>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
    >>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
    >>>>> value for example?
    >>>> 
    >>>> java.time.Instant stores times that are longer than a JVM word, so
    >>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
    >>>> that instances which compare equal also have the property of
    >>>> reference equality.  j.t.Instant factories in the Java library are
    >>>> explicitly documented *not* to have this property, so that doesn't
    >>>> help.
    >>> 
    >>> That’s not entirely clear.
    >>> 
    >>> Wouldn’t this loop work:
    >>> 
    >>> volatile j.t.Instant curr = ...
    >>> 
    >>> j.t.Instant next = …
    >>> j.t.Instant tmp = ...
    >>> do {
    >>>  tmp = curr;
    >>>  if (tmp.equal(next)) break;
    >>> } while(!curr.CAS(tmp, next));
    >>> 
    >>> // assume curr is equal to next
    >> 
    >> Something like that, yes.  But it's going to be evil if there are
    >> several high-frequency writers.  If you're doing all that work in
    >> order to CAS a timestamp, why not use a synchronized block?  It would
    >> at least be less prone to the thundering herd, and we'd generate
    >> pretty decent code for that.  It'd be interesting to compare and
    >> contrast the two approaches for contended and non-contended cases.
    > 
    >    The main reason I reached for AtomicReference is that I thought, "I
    >    want thread-safe updates to this read-heavy value where writes won't
    >    get lost if there's contention -- this sounds like the sort of problem
    >    that java.util.concurrent.atomic solves."
    > 
    >    As a minor point, I wanted synchronization on reads to be as
    >    minor/invisible as possible, to affect the readers' behavior as little
    >    as possible (in comparison to their behavior when the value they're
    >    reading a constant value with no synchronization).
    > 
    >    But if AtomicReference is simply the wrong tool to use here, I
    >    shouldn't use it.  That's fine.
    > 
    >> 
    >>>> If you want to be able to CAS a reference to a j.t.Instant, you're
    >>>> going to have to wrap accesses to it in a synchronized block.  This is
    >>>> a direct consequence of the JVM's inability to CAS multi-word objects.
    >>> 
    >>> This is confusing.
    >>> 
    >>> Surely this isn’t talking about CASing a reference? The contents of
    >>> the object can’t be assumed to have any atomicity properties,
    >>> whether it is j.t.Instant or not.
    >> 
    >> I agree.  I'm trying to look at what the OP actually wants to do: I
    >> assume this is some kind of atomic timestamp, and the OP wants to be
    >> able to CAS an instance of j.u.Instant.
    > 
    >    It was more of a general worry and question.  Should I ever use
    >    AtomicReference with value-based classes?  It sounds like the answer
    >    is no.
    > 
    >    But here's some code that illustrates the specific problem I was
    >    trying to solve.  I think it "works" right now, but that it's in
    >    violation of the spec for value-based classes and so possibly not
    >    future-proof, and I think I understand how to fix it now.  Thanks for
    >    the tips.
    > 
    >        class MutableClock {
    > 
    >            static MutableClock create(Instant instant, ZoneId zone) {
    >                return new MutableClock(
    >                        new AtomicReference<>(instant),
    >                        zone);
    >            }
    > 
    >            private final AtomicReference<Instant> instantHolder;
    >            private final ZoneId zone;
    > 
    >            private MutableClock(
    >                    AtomicReference<Instant> instantHolder,
    >                    ZoneId zone) {
    >                this.instantHolder = instantHolder;
    >                this.zone = zone;
    >            }
    > 
    >            Instant instant() {
    >                return instantHolder.get();
    >            }
    > 
    >            ZoneId getZone() {
    >                return zone;
    >            }
    > 
    >            void setInstant(Instant newInstant) {
    >                instantHolder.set(newInstant);
    >            }
    > 
    >            void add(Duration amountToAdd) {
    >                // this is the part that uses == and CAS
    >                instantHolder.updateAndGet(
    >                      instant -> instant.plus(amountToAdd));
    >            }
    > 
    >            MutableClock withZone(ZoneId newZone) {
    >                // conveniently, AtomicReference also acts as a
    >                // vehicle for "shared updates" between instances
    >                // of my class
    >                return new MutableClock(instantHolder, newZone);
    >            }
    >        }
    > 
    >    -Michael
    >    _______________________________________________
    >    Concurrency-interest mailing list
    >    Concurrency-interest at cs.oswego.edu
    >    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    > 
    > 
    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at cs.oswego.edu
    > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
    


From bronee at gmail.com  Thu Jul  6 14:52:50 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Thu, 6 Jul 2017 11:52:50 -0700
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
 <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
Message-ID: <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>

Although it would be nice to have value-based classes truly supported, 
because the java.time classes are defined as ordinary classes, they can 
never change into becoming true value-based classes without breaking 
compatibility. You can't just change the definition of instance equality 
without completely breaking the language completely. Improper use of a 
weak value-based class should at the very least trigger a compiler 
warning, but a full runtime check is too extreme.

Consider how these checks are implemented by the compiler. Adding a 
runtime check would be equivalent to making every == check, cas, etc 
behave like a virtual method call. I wouldn't be terribly happy to see a 
performance regression introduced in something so fundamental and used 
everywhere.

Also consider problems resulting an exception thrown from the == 
operator. This isn't supposed to happen. Any piece of code which is 
designed to be fault tolerant (via exception handling) is now broken, 
because it assumed (correctly) that fundamental language design elements 
don't change.


On 2017-07-06 11:15 AM, Gil Tene wrote:
> David, the below is a (potentially good) argument for not allowing the 
> creation of subclasses of Object that do not have well defined support 
> identity, identity comparison, identity hashing, or synchronization, 
> since Object supports all those, things that hold Object instances may 
> very well make use of them.
> 
> But that horse has long fled the barn. We can argue that value-based 
> classes should not have been specified in Java 8. Or that the future 
> value types should not be derived from Object. But the first case is 
> already in the Java spec, and the second is likely coming (and is 
> sneakily able to use the first as a precedent).
> 
> For the "how should we specify things?" discussion, I'm actually 
> squarely on the side of "things with no identity should never have been 
> derived from Object" of this argument. E.g. I would advise other 
> language specifications to avoid making the same mistake, either by not 
> giving the base Object class identity to begin with, or by creating a 
> separate orthogonal type hierarchy for value types and "value based" 
> classes. However, I don't see a way to "fix" the mistake already made, 
> and we have to deal with the language and the machine as spec'ed, not as 
> we wish it were. And so does anyone writing code in the language.
> 
> In the context of that reality, we are discussing what correct uses of 
> those new "basterd children of Object" are. And since the basterds 
> clearly have no identity, using any logic that relies on identity 
> behavior in any way is wrong.
> 
> Sent from my iPad
> 
> On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com 
> <mailto:gil at azul.com>> wrote:
> 
>> Hence my suggestion that identity-based operations on instances of 
>> value-based classes should throw exceptions... Right now they silently 
>> do unpredictable things, and should be avoided in any case (but harder 
>> to know/find when you accidentally use them).
>>
>> Sent from my iPad
>>
>> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com 
>> <mailto:oleksandr.otenko at gmail.com>> wrote:
>>
>>> Are they subclasses of Object or not? If they are not, no questions. 
>>> If they are, someone still needs to explain how exactly the “identity 
>>> based operations” can be avoided safely.
>>>
>>> List<j.u.Optional> is just a List underneath, and searching for an 
>>> item may use “identity based operations”, whether you want it or not 
>>> - depending on what implementation of List you happen to use.
>>>
>>> Alex
>>>

From gil at azul.com  Thu Jul  6 15:12:09 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 19:12:09 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
Message-ID: <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>

The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.

The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...

— Gil.

> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
> 
> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
> 
> -Justin
> 
> 
> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
> 
>    We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
> 
>    To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>    - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>    - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
> 
>    This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
> 
>    Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
> 
>    In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
> 
>    Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
> 
>    Sent from my iPad
> 
>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>> 
>> Howdy,
>> 
>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>> 
>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>> 
>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>> 
>> Cheers,
>> Justin
>> 
>> 
>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>> 
>>   Forwarding this reply of mine because I forgot to CC the mailing list.
>> 
>> 
>>   ---------- Forwarded message ----------
>>   From: Michael Hixson <michael.hixson at gmail.com>
>>   Date: Thu, Jul 6, 2017 at 7:24 AM
>>   Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>   value-based classes?
>>   To: Andrew Haley <aph at redhat.com>
>> 
>> 
>>>>>   On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>> 
>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>> 
>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>> instances of value-based classes?
>>>>>> 
>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>> value for example?
>>>>> 
>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>> that instances which compare equal also have the property of
>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>> help.
>>>> 
>>>> That’s not entirely clear.
>>>> 
>>>> Wouldn’t this loop work:
>>>> 
>>>> volatile j.t.Instant curr = ...
>>>> 
>>>> j.t.Instant next = …
>>>> j.t.Instant tmp = ...
>>>> do {
>>>> tmp = curr;
>>>> if (tmp.equal(next)) break;
>>>> } while(!curr.CAS(tmp, next));
>>>> 
>>>> // assume curr is equal to next
>>> 
>>> Something like that, yes.  But it's going to be evil if there are
>>> several high-frequency writers.  If you're doing all that work in
>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>> at least be less prone to the thundering herd, and we'd generate
>>> pretty decent code for that.  It'd be interesting to compare and
>>> contrast the two approaches for contended and non-contended cases.
>> 
>>   The main reason I reached for AtomicReference is that I thought, "I
>>   want thread-safe updates to this read-heavy value where writes won't
>>   get lost if there's contention -- this sounds like the sort of problem
>>   that java.util.concurrent.atomic solves."
>> 
>>   As a minor point, I wanted synchronization on reads to be as
>>   minor/invisible as possible, to affect the readers' behavior as little
>>   as possible (in comparison to their behavior when the value they're
>>   reading a constant value with no synchronization).
>> 
>>   But if AtomicReference is simply the wrong tool to use here, I
>>   shouldn't use it.  That's fine.
>> 
>>> 
>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>> 
>>>> This is confusing.
>>>> 
>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>> the object can’t be assumed to have any atomicity properties,
>>>> whether it is j.t.Instant or not.
>>> 
>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>> able to CAS an instance of j.u.Instant.
>> 
>>   It was more of a general worry and question.  Should I ever use
>>   AtomicReference with value-based classes?  It sounds like the answer
>>   is no.
>> 
>>   But here's some code that illustrates the specific problem I was
>>   trying to solve.  I think it "works" right now, but that it's in
>>   violation of the spec for value-based classes and so possibly not
>>   future-proof, and I think I understand how to fix it now.  Thanks for
>>   the tips.
>> 
>>       class MutableClock {
>> 
>>           static MutableClock create(Instant instant, ZoneId zone) {
>>               return new MutableClock(
>>                       new AtomicReference<>(instant),
>>                       zone);
>>           }
>> 
>>           private final AtomicReference<Instant> instantHolder;
>>           private final ZoneId zone;
>> 
>>           private MutableClock(
>>                   AtomicReference<Instant> instantHolder,
>>                   ZoneId zone) {
>>               this.instantHolder = instantHolder;
>>               this.zone = zone;
>>           }
>> 
>>           Instant instant() {
>>               return instantHolder.get();
>>           }
>> 
>>           ZoneId getZone() {
>>               return zone;
>>           }
>> 
>>           void setInstant(Instant newInstant) {
>>               instantHolder.set(newInstant);
>>           }
>> 
>>           void add(Duration amountToAdd) {
>>               // this is the part that uses == and CAS
>>               instantHolder.updateAndGet(
>>                     instant -> instant.plus(amountToAdd));
>>           }
>> 
>>           MutableClock withZone(ZoneId newZone) {
>>               // conveniently, AtomicReference also acts as a
>>               // vehicle for "shared updates" between instances
>>               // of my class
>>               return new MutableClock(instantHolder, newZone);
>>           }
>>       }
>> 
>>   -Michael
>>   _______________________________________________
>>   Concurrency-interest mailing list
>>   Concurrency-interest at cs.oswego.edu
>>   http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 


From kirk at kodewerk.com  Thu Jul  6 15:22:04 2017
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Thu, 6 Jul 2017 21:22:04 +0200
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
Message-ID: <1D0D7911-E375-4CEC-B04D-9D71B88A914A@kodewerk.com>

I think this is horrifying. One of the guarantees of these types of systems is a notion of identity and singularity which ensures consistency in the runtime. This one of the things I liked about value types. It gave a stronger sense of singularity but now as I understand this, singularity is no longer guaranteed which means you need to do extra stuff to ensure consistency. This brings us smack into the problems with O/R mapping (inject and maintenance of foreign key to ensure singularity and consistency).

I do hope I’ve misunderstood this whole thread.

Regards,
Kirk

> On Jul 6, 2017, at 9:12 PM, Gil Tene <gil at azul.com> wrote:
> 
> The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.
> 
> The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...
> 
> — Gil.
> 
>> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>> 
>> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
>> 
>> -Justin
>> 
>> 
>> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
>> 
>>   We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
>> 
>>   To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>>   - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>>   - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
>> 
>>   This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
>> 
>>   Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
>> 
>>   In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
>> 
>>   Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
>> 
>>   Sent from my iPad
>> 
>>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>> 
>>> Howdy,
>>> 
>>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>>> 
>>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>>> 
>>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>>> 
>>> Cheers,
>>> Justin
>>> 
>>> 
>>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>>> 
>>>  Forwarding this reply of mine because I forgot to CC the mailing list.
>>> 
>>> 
>>>  ---------- Forwarded message ----------
>>>  From: Michael Hixson <michael.hixson at gmail.com>
>>>  Date: Thu, Jul 6, 2017 at 7:24 AM
>>>  Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>>  value-based classes?
>>>  To: Andrew Haley <aph at redhat.com>
>>> 
>>> 
>>>>>>  On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>>> 
>>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>>> 
>>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>>> instances of value-based classes?
>>>>>>> 
>>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>>> value for example?
>>>>>> 
>>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>>> that instances which compare equal also have the property of
>>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>>> help.
>>>>> 
>>>>> That’s not entirely clear.
>>>>> 
>>>>> Wouldn’t this loop work:
>>>>> 
>>>>> volatile j.t.Instant curr = ...
>>>>> 
>>>>> j.t.Instant next = …
>>>>> j.t.Instant tmp = ...
>>>>> do {
>>>>> tmp = curr;
>>>>> if (tmp.equal(next)) break;
>>>>> } while(!curr.CAS(tmp, next));
>>>>> 
>>>>> // assume curr is equal to next
>>>> 
>>>> Something like that, yes.  But it's going to be evil if there are
>>>> several high-frequency writers.  If you're doing all that work in
>>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>>> at least be less prone to the thundering herd, and we'd generate
>>>> pretty decent code for that.  It'd be interesting to compare and
>>>> contrast the two approaches for contended and non-contended cases.
>>> 
>>>  The main reason I reached for AtomicReference is that I thought, "I
>>>  want thread-safe updates to this read-heavy value where writes won't
>>>  get lost if there's contention -- this sounds like the sort of problem
>>>  that java.util.concurrent.atomic solves."
>>> 
>>>  As a minor point, I wanted synchronization on reads to be as
>>>  minor/invisible as possible, to affect the readers' behavior as little
>>>  as possible (in comparison to their behavior when the value they're
>>>  reading a constant value with no synchronization).
>>> 
>>>  But if AtomicReference is simply the wrong tool to use here, I
>>>  shouldn't use it.  That's fine.
>>> 
>>>> 
>>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>>> 
>>>>> This is confusing.
>>>>> 
>>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>>> the object can’t be assumed to have any atomicity properties,
>>>>> whether it is j.t.Instant or not.
>>>> 
>>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>>> able to CAS an instance of j.u.Instant.
>>> 
>>>  It was more of a general worry and question.  Should I ever use
>>>  AtomicReference with value-based classes?  It sounds like the answer
>>>  is no.
>>> 
>>>  But here's some code that illustrates the specific problem I was
>>>  trying to solve.  I think it "works" right now, but that it's in
>>>  violation of the spec for value-based classes and so possibly not
>>>  future-proof, and I think I understand how to fix it now.  Thanks for
>>>  the tips.
>>> 
>>>      class MutableClock {
>>> 
>>>          static MutableClock create(Instant instant, ZoneId zone) {
>>>              return new MutableClock(
>>>                      new AtomicReference<>(instant),
>>>                      zone);
>>>          }
>>> 
>>>          private final AtomicReference<Instant> instantHolder;
>>>          private final ZoneId zone;
>>> 
>>>          private MutableClock(
>>>                  AtomicReference<Instant> instantHolder,
>>>                  ZoneId zone) {
>>>              this.instantHolder = instantHolder;
>>>              this.zone = zone;
>>>          }
>>> 
>>>          Instant instant() {
>>>              return instantHolder.get();
>>>          }
>>> 
>>>          ZoneId getZone() {
>>>              return zone;
>>>          }
>>> 
>>>          void setInstant(Instant newInstant) {
>>>              instantHolder.set(newInstant);
>>>          }
>>> 
>>>          void add(Duration amountToAdd) {
>>>              // this is the part that uses == and CAS
>>>              instantHolder.updateAndGet(
>>>                    instant -> instant.plus(amountToAdd));
>>>          }
>>> 
>>>          MutableClock withZone(ZoneId newZone) {
>>>              // conveniently, AtomicReference also acts as a
>>>              // vehicle for "shared updates" between instances
>>>              // of my class
>>>              return new MutableClock(instantHolder, newZone);
>>>          }
>>>      }
>>> 
>>>  -Michael
>>>  _______________________________________________
>>>  Concurrency-interest mailing list
>>>  Concurrency-interest at cs.oswego.edu
>>>  http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gil at azul.com  Thu Jul  6 15:23:11 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 19:23:11 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
 <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
 <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>
Message-ID: <B452CF16-A3A2-461A-B5D3-E722317B578F@azul.com>

I think that performant runtime checks can be added. When you haven't stuffed indentity-lacking things into other things that explore identity, things will be just as fast. When you do, they will blow up, and speed won't matter.

The larger problem of "surprising behavior" when passing a non-identity-capable thing (basterd child of Object) to some thing that expects Object and does object things with it at some future point in time (like maybe using identity for something) is likely to come at us hard when "codes like a class, works like an int" value types are introduced. IMO, it is "hard" (as in impractical) to compile-time check this stuff away completely. You can cover some (many?) cases, but runtime issues will always remain. The situation where people are appalled at what can happen with instances of value-based classes that they may pass to innocent Object-expecting things is just a glimpse of the future. IMO an exception is the least bad thing you can do to them. Much better than letting their code run.

— Gil.

> On Jul 6, 2017, at 11:52 AM, Brian S O'Neill <bronee at gmail.com> wrote:
> 
> Although it would be nice to have value-based classes truly supported, because the java.time classes are defined as ordinary classes, they can never change into becoming true value-based classes without breaking compatibility. You can't just change the definition of instance equality without completely breaking the language completely. Improper use of a weak value-based class should at the very least trigger a compiler warning, but a full runtime check is too extreme.
> 
> Consider how these checks are implemented by the compiler. Adding a runtime check would be equivalent to making every == check, cas, etc behave like a virtual method call. I wouldn't be terribly happy to see a performance regression introduced in something so fundamental and used everywhere.
> 
> Also consider problems resulting an exception thrown from the == operator. This isn't supposed to happen. Any piece of code which is designed to be fault tolerant (via exception handling) is now broken, because it assumed (correctly) that fundamental language design elements don't change.
> 
> 
> On 2017-07-06 11:15 AM, Gil Tene wrote:
>> David, the below is a (potentially good) argument for not allowing the creation of subclasses of Object that do not have well defined support identity, identity comparison, identity hashing, or synchronization, since Object supports all those, things that hold Object instances may very well make use of them.
>> But that horse has long fled the barn. We can argue that value-based classes should not have been specified in Java 8. Or that the future value types should not be derived from Object. But the first case is already in the Java spec, and the second is likely coming (and is sneakily able to use the first as a precedent).
>> For the "how should we specify things?" discussion, I'm actually squarely on the side of "things with no identity should never have been derived from Object" of this argument. E.g. I would advise other language specifications to avoid making the same mistake, either by not giving the base Object class identity to begin with, or by creating a separate orthogonal type hierarchy for value types and "value based" classes. However, I don't see a way to "fix" the mistake already made, and we have to deal with the language and the machine as spec'ed, not as we wish it were. And so does anyone writing code in the language.
>> In the context of that reality, we are discussing what correct uses of those new "basterd children of Object" are. And since the basterds clearly have no identity, using any logic that relies on identity behavior in any way is wrong.
>> Sent from my iPad
>> On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).
>>> 
>>> Sent from my iPad
>>> 
>>> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>> 
>>>> Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.
>>>> 
>>>> List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.
>>>> 
>>>> Alex
>>>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu Jul  6 16:09:37 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 21:09:37 +0100
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
Message-ID: <0983AEC3-BB6C-42CB-9B7C-B2F31F7AF3AF@gmail.com>

:-) It’s NaN, but for the objects.

Using “equals” is just as ugly. It has completely different semantics.

equality
equivalence
homotopy

all talk about sameness of things. I would tell the “it’s not as horrifying” crowd that it is absolutely wrong to force me to use equivalence where I mean equality. That’s the horrifying thing.

It’s not “more correct” to use “equals()” instead of “==“. Because it is not an optimisation, it just has a different meaning. Optional(x).equals(Optional(y)), if x.equals(y), but it doesn’t mean I don’t care which one is referenced - exactly because x and y do have identities.


There is sense in having a concept of a class whose objects convey no meaning except the existence of extra structure with its own virtual method table around some other values. But language needs support for safe use of them.


Alex

> On 6 Jul 2017, at 20:12, Gil Tene <gil at azul.com> wrote:
> 
> The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.
> 
> The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...
> 
> — Gil.
> 
>> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>> 
>> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
>> 
>> -Justin
>> 
>> 
>> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
>> 
>>   We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
>> 
>>   To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>>   - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>>   - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
>> 
>>   This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
>> 
>>   Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
>> 
>>   In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
>> 
>>   Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
>> 
>>   Sent from my iPad
>> 
>>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>> 
>>> Howdy,
>>> 
>>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>>> 
>>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>>> 
>>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>>> 
>>> Cheers,
>>> Justin
>>> 
>>> 
>>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>>> 
>>>  Forwarding this reply of mine because I forgot to CC the mailing list.
>>> 
>>> 
>>>  ---------- Forwarded message ----------
>>>  From: Michael Hixson <michael.hixson at gmail.com>
>>>  Date: Thu, Jul 6, 2017 at 7:24 AM
>>>  Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>>  value-based classes?
>>>  To: Andrew Haley <aph at redhat.com>
>>> 
>>> 
>>>>>>  On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>>> 
>>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>>> 
>>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>>> instances of value-based classes?
>>>>>>> 
>>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>>> value for example?
>>>>>> 
>>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>>> that instances which compare equal also have the property of
>>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>>> help.
>>>>> 
>>>>> That’s not entirely clear.
>>>>> 
>>>>> Wouldn’t this loop work:
>>>>> 
>>>>> volatile j.t.Instant curr = ...
>>>>> 
>>>>> j.t.Instant next = …
>>>>> j.t.Instant tmp = ...
>>>>> do {
>>>>> tmp = curr;
>>>>> if (tmp.equal(next)) break;
>>>>> } while(!curr.CAS(tmp, next));
>>>>> 
>>>>> // assume curr is equal to next
>>>> 
>>>> Something like that, yes.  But it's going to be evil if there are
>>>> several high-frequency writers.  If you're doing all that work in
>>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>>> at least be less prone to the thundering herd, and we'd generate
>>>> pretty decent code for that.  It'd be interesting to compare and
>>>> contrast the two approaches for contended and non-contended cases.
>>> 
>>>  The main reason I reached for AtomicReference is that I thought, "I
>>>  want thread-safe updates to this read-heavy value where writes won't
>>>  get lost if there's contention -- this sounds like the sort of problem
>>>  that java.util.concurrent.atomic solves."
>>> 
>>>  As a minor point, I wanted synchronization on reads to be as
>>>  minor/invisible as possible, to affect the readers' behavior as little
>>>  as possible (in comparison to their behavior when the value they're
>>>  reading a constant value with no synchronization).
>>> 
>>>  But if AtomicReference is simply the wrong tool to use here, I
>>>  shouldn't use it.  That's fine.
>>> 
>>>> 
>>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>>> 
>>>>> This is confusing.
>>>>> 
>>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>>> the object can’t be assumed to have any atomicity properties,
>>>>> whether it is j.t.Instant or not.
>>>> 
>>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>>> able to CAS an instance of j.u.Instant.
>>> 
>>>  It was more of a general worry and question.  Should I ever use
>>>  AtomicReference with value-based classes?  It sounds like the answer
>>>  is no.
>>> 
>>>  But here's some code that illustrates the specific problem I was
>>>  trying to solve.  I think it "works" right now, but that it's in
>>>  violation of the spec for value-based classes and so possibly not
>>>  future-proof, and I think I understand how to fix it now.  Thanks for
>>>  the tips.
>>> 
>>>      class MutableClock {
>>> 
>>>          static MutableClock create(Instant instant, ZoneId zone) {
>>>              return new MutableClock(
>>>                      new AtomicReference<>(instant),
>>>                      zone);
>>>          }
>>> 
>>>          private final AtomicReference<Instant> instantHolder;
>>>          private final ZoneId zone;
>>> 
>>>          private MutableClock(
>>>                  AtomicReference<Instant> instantHolder,
>>>                  ZoneId zone) {
>>>              this.instantHolder = instantHolder;
>>>              this.zone = zone;
>>>          }
>>> 
>>>          Instant instant() {
>>>              return instantHolder.get();
>>>          }
>>> 
>>>          ZoneId getZone() {
>>>              return zone;
>>>          }
>>> 
>>>          void setInstant(Instant newInstant) {
>>>              instantHolder.set(newInstant);
>>>          }
>>> 
>>>          void add(Duration amountToAdd) {
>>>              // this is the part that uses == and CAS
>>>              instantHolder.updateAndGet(
>>>                    instant -> instant.plus(amountToAdd));
>>>          }
>>> 
>>>          MutableClock withZone(ZoneId newZone) {
>>>              // conveniently, AtomicReference also acts as a
>>>              // vehicle for "shared updates" between instances
>>>              // of my class
>>>              return new MutableClock(instantHolder, newZone);
>>>          }
>>>      }
>>> 
>>>  -Michael
>>>  _______________________________________________
>>>  Concurrency-interest mailing list
>>>  Concurrency-interest at cs.oswego.edu
>>>  http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu Jul  6 16:56:22 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 21:56:22 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <B452CF16-A3A2-461A-B5D3-E722317B578F@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
 <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
 <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>
 <B452CF16-A3A2-461A-B5D3-E722317B578F@azul.com>
Message-ID: <A5EAFD64-E012-4A4A-BB8F-615CAB6CCE6D@gmail.com>

What’s wrong with “==“ doing a sensible default thing? Like, bitwise compare the “contents”? It’s certainly no slower than calling equals() that perhaps will do more than just bitwise-compare.

What’s wrong with identityHashCode producing a code based on identityHashCodes of the “contents”, or the bit contents of the primitive members?

Alex

> On 6 Jul 2017, at 20:23, Gil Tene <gil at azul.com> wrote:
> 
> I think that performant runtime checks can be added. When you haven't stuffed indentity-lacking things into other things that explore identity, things will be just as fast. When you do, they will blow up, and speed won't matter.
> 
> The larger problem of "surprising behavior" when passing a non-identity-capable thing (basterd child of Object) to some thing that expects Object and does object things with it at some future point in time (like maybe using identity for something) is likely to come at us hard when "codes like a class, works like an int" value types are introduced. IMO, it is "hard" (as in impractical) to compile-time check this stuff away completely. You can cover some (many?) cases, but runtime issues will always remain. The situation where people are appalled at what can happen with instances of value-based classes that they may pass to innocent Object-expecting things is just a glimpse of the future. IMO an exception is the least bad thing you can do to them. Much better than letting their code run.
> 
> — Gil.
> 
>> On Jul 6, 2017, at 11:52 AM, Brian S O'Neill <bronee at gmail.com> wrote:
>> 
>> Although it would be nice to have value-based classes truly supported, because the java.time classes are defined as ordinary classes, they can never change into becoming true value-based classes without breaking compatibility. You can't just change the definition of instance equality without completely breaking the language completely. Improper use of a weak value-based class should at the very least trigger a compiler warning, but a full runtime check is too extreme.
>> 
>> Consider how these checks are implemented by the compiler. Adding a runtime check would be equivalent to making every == check, cas, etc behave like a virtual method call. I wouldn't be terribly happy to see a performance regression introduced in something so fundamental and used everywhere.
>> 
>> Also consider problems resulting an exception thrown from the == operator. This isn't supposed to happen. Any piece of code which is designed to be fault tolerant (via exception handling) is now broken, because it assumed (correctly) that fundamental language design elements don't change.
>> 
>> 
>> On 2017-07-06 11:15 AM, Gil Tene wrote:
>>> David, the below is a (potentially good) argument for not allowing the creation of subclasses of Object that do not have well defined support identity, identity comparison, identity hashing, or synchronization, since Object supports all those, things that hold Object instances may very well make use of them.
>>> But that horse has long fled the barn. We can argue that value-based classes should not have been specified in Java 8. Or that the future value types should not be derived from Object. But the first case is already in the Java spec, and the second is likely coming (and is sneakily able to use the first as a precedent).
>>> For the "how should we specify things?" discussion, I'm actually squarely on the side of "things with no identity should never have been derived from Object" of this argument. E.g. I would advise other language specifications to avoid making the same mistake, either by not giving the base Object class identity to begin with, or by creating a separate orthogonal type hierarchy for value types and "value based" classes. However, I don't see a way to "fix" the mistake already made, and we have to deal with the language and the machine as spec'ed, not as we wish it were. And so does anyone writing code in the language.
>>> In the context of that reality, we are discussing what correct uses of those new "basterd children of Object" are. And since the basterds clearly have no identity, using any logic that relies on identity behavior in any way is wrong.
>>> Sent from my iPad
>>> On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>> Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).
>>>> 
>>>> Sent from my iPad
>>>> 
>>>> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>>> 
>>>>> Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.
>>>>> 
>>>>> List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.
>>>>> 
>>>>> Alex
>>>>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gil at azul.com  Thu Jul  6 17:23:22 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 21:23:22 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <0983AEC3-BB6C-42CB-9B7C-B2F31F7AF3AF@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <0983AEC3-BB6C-42CB-9B7C-B2F31F7AF3AF@gmail.com>
Message-ID: <6F56E0F2-B084-47C4-B5F7-B3B8DBE87C21@azul.com>


> On Jul 6, 2017, at 1:09 PM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
> 
> :-) It’s NaN, but for the objects.
> 

Well put. And a very good analogy. The identity of an instance of a value-based classes may act like a NaN at any time. And x == x is false when x is a NaN...

> Using “equals” is just as ugly. It has completely different semantics.


> 
> equality
> equivalence
> homotopy

And == for objects (which means "same identity") is [I believe] different from all of the above.

Alas, we don't have a well established meaning for .equivalent() in Java.

> 
> all talk about sameness of things. I would tell the “it’s not as horrifying” crowd that it is absolutely wrong to force me to use equivalence where I mean equality. That’s the horrifying thing.
> 
> It’s not “more correct” to use “equals()” instead of “==“. Because it is not an optimisation, it just has a different meaning. Optional(x).equals(Optional(y)), if x.equals(y), but it doesn’t mean I don’t care which one is referenced - exactly because x and y do have identities.

Agreed.

Alas, being immutable and non-constrictble (created only by factories) doesn't actually mean non-null everywhere… Super-annoyingly, it is perfectly "valid" (as in will compile and run something) to pass a null argument when an Optional is expected… 

Interesting mention of "nullability": http://mail.openjdk.java.net/pipermail/valhalla-dev/2015-January/000555.html , and a discussion of the subject in general (with some good links) here: https://blog.codefx.org/java/value-based-classes/ . I especially like the specific quotes from sources:

-  "Optional is new, and the disclaimers arrived on day 1. Integer, on the other hand, is probably hopelessly polluted, and I am sure that it would break gobs of important code if Integer ceased to be lockable (despite what we may think of such a practice.)"

- "In Java 8 value types are preceded by value-based classes. Their precise relation in the future is unclear but it could be similar to that of boxed and unboxed primitives (e.g. Integer and  int). Additionally, the compiler will likely be free to silently switch between the two to improve performance. Exactly that switching back and forth, i.e. removing and later recreating a reference, also forbids identity-based mechanisms to be applied to value-based classes."

removing and later recreating a reference…. That's certainly in the cars.


> 
> 
> There is sense in having a concept of a class whose objects convey no meaning except the existence of extra structure with its own virtual method table around some other values. But language needs support for safe use of them.
> 
> 
> Alex
> 
>> On 6 Jul 2017, at 20:12, Gil Tene <gil at azul.com> wrote:
>> 
>> The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.
>> 
>> The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...
>> 
>> — Gil.
>> 
>>> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>> 
>>> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
>>> 
>>> -Justin
>>> 
>>> 
>>> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
>>> 
>>>  We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
>>> 
>>>  To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>>>  - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>>>  - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
>>> 
>>>  This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
>>> 
>>>  Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
>>> 
>>>  In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
>>> 
>>>  Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
>>> 
>>>  Sent from my iPad
>>> 
>>>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>>> 
>>>> Howdy,
>>>> 
>>>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>>>> 
>>>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>>>> 
>>>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>>>> 
>>>> Cheers,
>>>> Justin
>>>> 
>>>> 
>>>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>>>> 
>>>> Forwarding this reply of mine because I forgot to CC the mailing list.
>>>> 
>>>> 
>>>> ---------- Forwarded message ----------
>>>> From: Michael Hixson <michael.hixson at gmail.com>
>>>> Date: Thu, Jul 6, 2017 at 7:24 AM
>>>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>>> value-based classes?
>>>> To: Andrew Haley <aph at redhat.com>
>>>> 
>>>> 
>>>>>>> On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>>>> 
>>>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>>>> 
>>>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>>>> instances of value-based classes?
>>>>>>>> 
>>>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>>>> value for example?
>>>>>>> 
>>>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>>>> that instances which compare equal also have the property of
>>>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>>>> help.
>>>>>> 
>>>>>> That’s not entirely clear.
>>>>>> 
>>>>>> Wouldn’t this loop work:
>>>>>> 
>>>>>> volatile j.t.Instant curr = ...
>>>>>> 
>>>>>> j.t.Instant next = …
>>>>>> j.t.Instant tmp = ...
>>>>>> do {
>>>>>> tmp = curr;
>>>>>> if (tmp.equal(next)) break;
>>>>>> } while(!curr.CAS(tmp, next));
>>>>>> 
>>>>>> // assume curr is equal to next
>>>>> 
>>>>> Something like that, yes.  But it's going to be evil if there are
>>>>> several high-frequency writers.  If you're doing all that work in
>>>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>>>> at least be less prone to the thundering herd, and we'd generate
>>>>> pretty decent code for that.  It'd be interesting to compare and
>>>>> contrast the two approaches for contended and non-contended cases.
>>>> 
>>>> The main reason I reached for AtomicReference is that I thought, "I
>>>> want thread-safe updates to this read-heavy value where writes won't
>>>> get lost if there's contention -- this sounds like the sort of problem
>>>> that java.util.concurrent.atomic solves."
>>>> 
>>>> As a minor point, I wanted synchronization on reads to be as
>>>> minor/invisible as possible, to affect the readers' behavior as little
>>>> as possible (in comparison to their behavior when the value they're
>>>> reading a constant value with no synchronization).
>>>> 
>>>> But if AtomicReference is simply the wrong tool to use here, I
>>>> shouldn't use it.  That's fine.
>>>> 
>>>>> 
>>>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>>>> 
>>>>>> This is confusing.
>>>>>> 
>>>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>>>> the object can’t be assumed to have any atomicity properties,
>>>>>> whether it is j.t.Instant or not.
>>>>> 
>>>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>>>> able to CAS an instance of j.u.Instant.
>>>> 
>>>> It was more of a general worry and question.  Should I ever use
>>>> AtomicReference with value-based classes?  It sounds like the answer
>>>> is no.
>>>> 
>>>> But here's some code that illustrates the specific problem I was
>>>> trying to solve.  I think it "works" right now, but that it's in
>>>> violation of the spec for value-based classes and so possibly not
>>>> future-proof, and I think I understand how to fix it now.  Thanks for
>>>> the tips.
>>>> 
>>>>     class MutableClock {
>>>> 
>>>>         static MutableClock create(Instant instant, ZoneId zone) {
>>>>             return new MutableClock(
>>>>                     new AtomicReference<>(instant),
>>>>                     zone);
>>>>         }
>>>> 
>>>>         private final AtomicReference<Instant> instantHolder;
>>>>         private final ZoneId zone;
>>>> 
>>>>         private MutableClock(
>>>>                 AtomicReference<Instant> instantHolder,
>>>>                 ZoneId zone) {
>>>>             this.instantHolder = instantHolder;
>>>>             this.zone = zone;
>>>>         }
>>>> 
>>>>         Instant instant() {
>>>>             return instantHolder.get();
>>>>         }
>>>> 
>>>>         ZoneId getZone() {
>>>>             return zone;
>>>>         }
>>>> 
>>>>         void setInstant(Instant newInstant) {
>>>>             instantHolder.set(newInstant);
>>>>         }
>>>> 
>>>>         void add(Duration amountToAdd) {
>>>>             // this is the part that uses == and CAS
>>>>             instantHolder.updateAndGet(
>>>>                   instant -> instant.plus(amountToAdd));
>>>>         }
>>>> 
>>>>         MutableClock withZone(ZoneId newZone) {
>>>>             // conveniently, AtomicReference also acts as a
>>>>             // vehicle for "shared updates" between instances
>>>>             // of my class
>>>>             return new MutableClock(instantHolder, newZone);
>>>>         }
>>>>     }
>>>> 
>>>> -Michael
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From scolebourne at joda.org  Thu Jul  6 17:29:55 2017
From: scolebourne at joda.org (Stephen Colebourne)
Date: Thu, 6 Jul 2017 22:29:55 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
Message-ID: <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>

Given:

Instant i1 = Instant.ofEpochMilli(2);
Instant i2 = Instant.ofEpochMilli(2);

In Java 8:

i1.equals(i2) is true
i1 == i2  is false

And in some future version, i1 == i2  might be true.

But this is not especially radical. Java 10 could introduce a cache in
the factory method that always returns the same instance. In fact,
there already is a cache if you call
Instant.ofEpochMilli(0);

The key phrase in
http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
is "A program may produce unpredictable results if it attempts to
distinguish two references to equal values of a value-based class".
IMO, the intent is to tell everyone that they shouldn't try to tell
the difference between two instances using ==, and if they do their
program may change meaning in the future (ie. be unpredictable, but
not stupidly unpredictable as some in the thread are suggesting).

Stephen


On 6 July 2017 at 17:33, Gil Tene <gil at azul.com> wrote:
>
> It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".
>
> Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.
>
> For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).
>
> We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.
>
> It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.
>
> For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.
>
> One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...
>
> This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.
>
> Sent from my iPad
>
> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>
> :-) the one causing Byzantine failures!
>
> Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.
>
> All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).
>
>
> Alex
>
>
> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com> wrote:
>
> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
> n  Sebastian
>
> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
> Sent: Thursday, July 06, 2017 10:17 AM
> To: Gil Tene
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>
>
>
> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com> wrote:
>
>
>
> Sent from my iPad
>
>
> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>
> All it is saying is:
>
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>
> a==b && b==c can be true and can be false
>
>
> It also means that even when:
>
>   LocalDateTime d = a;
>   ...
>   (a == d) may or may not be true. And may change whether it is true or not at any time,
>
>
> I meant an even stronger assertion:
>
> assert (a==b) == (b==a) : "No Byzantine optimizations"
> assert (a==d) == (a==d): “No Byzantine optimizations"
>
> Alex
>
>
>
>
>
>
> Alex
>
>
> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com> wrote:
>
>
>
> Sent from my iPad
>
>
> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com> wrote:
>
> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>
> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>
> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>   int a = 5;
>   int b = 5;
>   boolean y = (a == b);  // true
>
> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>   Integer a = new Integer(5);
>   Integer b = new Integer(5);
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // false
>
> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>
>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>   boolean x = a.equals(b);   // true
>   boolean y = (a == b);   // unpredictable, undefined, who knows.
>                                          // Could be true, could be false.
>                                          // Could theoretically change the values of a or b, or of something else
>
>
>
>
> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com> wrote:
>
>
> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>
> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
> For example:
> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>
> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>
> — Gil.
>
> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
> >
> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
> >
> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
> >
> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
> >
> >
> > On 2017-07-05 09:20 PM, Gil Tene wrote:
> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
> >> — Gil.
> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
> >>>
> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
> >>> (and related) operations [1].  Using == to compare instances of
> >>> value-based classes may lead to "unpredictable results" [2].  Does
> >>> this mean I should avoid using compareAndSet with arguments that are
> >>> instances of value-based classes?
> >>>
> >>> It seems like the documentation clearly tells me "yes, avoid doing
> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
> >>> value for example?  Do I have to box the value in something that's not
> >>> a value-based class first, like AtomicReference<Box<Instant>>?
> >>>
> >>> -Michael
> >>>
> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From bronee at gmail.com  Thu Jul  6 17:52:05 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Thu, 6 Jul 2017 14:52:05 -0700
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
Message-ID: <2b407dba-b16f-a910-0ced-6bca7d45aa9b@gmail.com>

It sounds like the documentation should be updated to prevent further 
confusion. Perhaps this example (or something like it) should be provided.

On 2017-07-06 02:29 PM, Stephen Colebourne wrote:
> Given:
> 
> Instant i1 = Instant.ofEpochMilli(2);
> Instant i2 = Instant.ofEpochMilli(2);
> 
> In Java 8:
> 
> i1.equals(i2) is true
> i1 == i2  is false
> 
> And in some future version, i1 == i2  might be true.
> 
> But this is not especially radical. Java 10 could introduce a cache in
> the factory method that always returns the same instance. In fact,
> there already is a cache if you call
> Instant.ofEpochMilli(0);
> 
> The key phrase in
> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> is "A program may produce unpredictable results if it attempts to
> distinguish two references to equal values of a value-based class".
> IMO, the intent is to tell everyone that they shouldn't try to tell
> the difference between two instances using ==, and if they do their
> program may change meaning in the future (ie. be unpredictable, but
> not stupidly unpredictable as some in the thread are suggesting).
> 
> Stephen
> 
> 

From gil at azul.com  Thu Jul  6 17:57:04 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 21:57:04 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <A5EAFD64-E012-4A4A-BB8F-615CAB6CCE6D@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
 <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
 <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>
 <B452CF16-A3A2-461A-B5D3-E722317B578F@azul.com>
 <A5EAFD64-E012-4A4A-BB8F-615CAB6CCE6D@gmail.com>
Message-ID: <CA0CA26F-9C4A-4812-821B-00C96314E992@azul.com>


On Jul 6, 2017, at 1:56 PM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

What’s wrong with “==“ doing a sensible default thing? Like, bitwise compare the “contents”? It’s certainly no slower than calling equals() that perhaps will do more than just bitwise-compare.

Nothing "wrong" with that if we had a good specification on WHEN it means that. And "when both sides of the == are instances of value-based classes" probably doesn't cut it.

To see why, the javac compiler won't let us write:

int i = 0;
Object o = new Object();
boolean b = (o == i);

That's because int is NOT AN OBJECT.

But javac absolutely does let us write:

Object o1 = getSomeObject();
Optional o2 = getSomeOtherObject();
boolean b = (o1 == o2);

What does that == mean? What can it mean without being "surprising"?

And while it's tempting to say that here:

Optional o1 = Optional.of(objA);
Optional o2 = Optional.of(objB);
boolean b = (o1 == o2);

The == means "compare the contents". What should it mean here:

Object o1 = Optional.of(objA);
Object o2 = Optional.of(objB);
boolean b = (o1 == o2);

I suspect that the curse of being the basterd children of Object will follow instances of value based classes around for generations to come… It will be curious to see how value types deal with this same problem in an eventual working syntax.


What’s wrong with identityHashCode producing a code based on identityHashCodes of the “contents”, or the bit contents of the primitive members?

Similarly, identityHashCode already has a meaning for Object, where it will NOT be computed based on contents. Changing that for the basterd children of Object will create all sorts of in-fighting in the family:

Optional o1 = Optional.of(objA);
int ihc1 = System.identityHashCode(o1);
...
Object o2 = o1;
int ihc2 = System.identityHashCode(o2);
boolean b = (ihc1 == ihc2); // Is this allowed to be False?

Alex

On 6 Jul 2017, at 20:23, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:

I think that performant runtime checks can be added. When you haven't stuffed indentity-lacking things into other things that explore identity, things will be just as fast. When you do, they will blow up, and speed won't matter.

The larger problem of "surprising behavior" when passing a non-identity-capable thing (basterd child of Object) to some thing that expects Object and does object things with it at some future point in time (like maybe using identity for something) is likely to come at us hard when "codes like a class, works like an int" value types are introduced. IMO, it is "hard" (as in impractical) to compile-time check this stuff away completely. You can cover some (many?) cases, but runtime issues will always remain. The situation where people are appalled at what can happen with instances of value-based classes that they may pass to innocent Object-expecting things is just a glimpse of the future. IMO an exception is the least bad thing you can do to them. Much better than letting their code run.

— Gil.

On Jul 6, 2017, at 11:52 AM, Brian S O'Neill <bronee at gmail.com<mailto:bronee at gmail.com>> wrote:

Although it would be nice to have value-based classes truly supported, because the java.time classes are defined as ordinary classes, they can never change into becoming true value-based classes without breaking compatibility. You can't just change the definition of instance equality without completely breaking the language completely. Improper use of a weak value-based class should at the very least trigger a compiler warning, but a full runtime check is too extreme.

Consider how these checks are implemented by the compiler. Adding a runtime check would be equivalent to making every == check, cas, etc behave like a virtual method call. I wouldn't be terribly happy to see a performance regression introduced in something so fundamental and used everywhere.

Also consider problems resulting an exception thrown from the == operator. This isn't supposed to happen. Any piece of code which is designed to be fault tolerant (via exception handling) is now broken, because it assumed (correctly) that fundamental language design elements don't change.


On 2017-07-06 11:15 AM, Gil Tene wrote:
David, the below is a (potentially good) argument for not allowing the creation of subclasses of Object that do not have well defined support identity, identity comparison, identity hashing, or synchronization, since Object supports all those, things that hold Object instances may very well make use of them.
But that horse has long fled the barn. We can argue that value-based classes should not have been specified in Java 8. Or that the future value types should not be derived from Object. But the first case is already in the Java spec, and the second is likely coming (and is sneakily able to use the first as a precedent).
For the "how should we specify things?" discussion, I'm actually squarely on the side of "things with no identity should never have been derived from Object" of this argument. E.g. I would advise other language specifications to avoid making the same mistake, either by not giving the base Object class identity to begin with, or by creating a separate orthogonal type hierarchy for value types and "value based" classes. However, I don't see a way to "fix" the mistake already made, and we have to deal with the language and the machine as spec'ed, not as we wish it were. And so does anyone writing code in the language.
In the context of that reality, we are discussing what correct uses of those new "basterd children of Object" are. And since the basterds clearly have no identity, using any logic that relies on identity behavior in any way is wrong.
Sent from my iPad
On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com<mailto:gil at azul.com> <mailto:gil at azul.com>> wrote:
Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).

Sent from my iPad

On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com> <mailto:oleksandr.otenko at gmail.com>> wrote:

Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.

List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.

Alex

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/80f47ca6/attachment-0001.html>

From gil at azul.com  Thu Jul  6 18:33:17 2017
From: gil at azul.com (Gil Tene)
Date: Thu, 6 Jul 2017 22:33:17 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
Message-ID: <1F1475AA-C432-4BA3-8356-E7265E86BBC5@azul.com>


> On Jul 6, 2017, at 2:29 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
> 
> Given:
> 
> Instant i1 = Instant.ofEpochMilli(2);
> Instant i2 = Instant.ofEpochMilli(2);
> 
> In Java 8:
> 
> i1.equals(i2) is true
> i1 == i2  is false
> 
> And in some future version, i1 == i2  might be true.
> 
> But this is not especially radical. Java 10 could introduce a cache in
> the factory method that always returns the same instance. In fact,
> there already is a cache if you call
> Instant.ofEpochMilli(0);
> 
> The key phrase in
> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> is "A program may produce unpredictable results if it attempts to
> distinguish two references to equal values of a value-based class".

Read on, past the first comma. The full paragraph says:

"A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization, or any other identity-sensitive mechanism. Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided."

> IMO, the intent is to tell everyone that they shouldn't try to tell
> the difference between two instances using ==,

That's one tiny part of what they tell you not to do. read the full sentence it. The "or any other identity-sensitive mechanism" leaves no room for interpretations that start with "but if == is true, then…". 

Also note that the "an appeal to synchronization" part absolutely applies to atomic things like CAS that may attempt to operate based on an identity-sensitive mechanism...

> and if they do their
> program may change meaning in the future (ie. be unpredictable, but
> not stupidly unpredictable as some in the thread are suggesting).

Stupidity is in the eye of the beholder, I guess.

Unpredictable effects and unpredictable results are just that. Unpredictable. Not just in the future. Not just when the unpredictability makes sense. Also run-to-run, millisecond-to-millisecond, value-to-value. When-I-feel-like-it-to-when-I-dont.

E.g. nowhere does it say that if == is true then .equals() has to be true. That's just wishful thinking by folks that want to say "that would be stupid" because it would be "surprising" to them.

The optimizers will only be fed with the rules of what they must follow. And for e.g. == on instances of value-based classes, that is plainly "this specific == doesn't have a meaning. Do whatever you want to do or need to do with that.". It's not that there is some well-defined meaning that something is "smartly" attempting to ignore. It's that there is literally no defined meaning. Optimizers won't intentionally look to do "stupid" things. They will simply follow the actual rules, and not make up new ones. If the rules allow "stupid", and "stupid" seems to be profitable, an optimizer may very well do it. The surprising, unpredictable results and behavior that may come out of it is nobody's fault but the the person who put in the == to begin with, when explicitly told 17 different ways "don't do that", accompanied with scary statements like: "this may have unpredictable effects", and "your *program* (read: not just the == operation you'd like to try and reason about) may produce unpredictable results".

> 
> Stephen
> 
> 
> On 6 July 2017 at 17:33, Gil Tene <gil at azul.com> wrote:
>> 
>> It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".
>> 
>> Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.
>> 
>> For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).
>> 
>> We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.
>> 
>> It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.
>> 
>> For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.
>> 
>> One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...
>> 
>> This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.
>> 
>> Sent from my iPad
>> 
>> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>> 
>> :-) the one causing Byzantine failures!
>> 
>> Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.
>> 
>> All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).
>> 
>> 
>> Alex
>> 
>> 
>> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com> wrote:
>> 
>> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
>> n  Sebastian
>> 
>> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
>> Sent: Thursday, July 06, 2017 10:17 AM
>> To: Gil Tene
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>> 
>> 
>> 
>> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com> wrote:
>> 
>> 
>> 
>> Sent from my iPad
>> 
>> 
>> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>> 
>> All it is saying is:
>> 
>>  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>  LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>> 
>> a==b && b==c can be true and can be false
>> 
>> 
>> It also means that even when:
>> 
>>  LocalDateTime d = a;
>>  ...
>>  (a == d) may or may not be true. And may change whether it is true or not at any time,
>> 
>> 
>> I meant an even stronger assertion:
>> 
>> assert (a==b) == (b==a) : "No Byzantine optimizations"
>> assert (a==d) == (a==d): “No Byzantine optimizations"
>> 
>> Alex
>> 
>> 
>> 
>> 
>> 
>> 
>> Alex
>> 
>> 
>> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com> wrote:
>> 
>> 
>> 
>> Sent from my iPad
>> 
>> 
>> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com> wrote:
>> 
>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>> 
>> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>> 
>> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>>  int a = 5;
>>  int b = 5;
>>  boolean y = (a == b);  // true
>> 
>> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>>  Integer a = new Integer(5);
>>  Integer b = new Integer(5);
>>  boolean x = a.equals(b);   // true
>>  boolean y = (a == b);   // false
>> 
>> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>> 
>>  LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>  LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>  boolean x = a.equals(b);   // true
>>  boolean y = (a == b);   // unpredictable, undefined, who knows.
>>                                         // Could be true, could be false.
>>                                         // Could theoretically change the values of a or b, or of something else
>> 
>> 
>> 
>> 
>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com> wrote:
>> 
>> 
>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>> 
>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>> For example:
>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>> 
>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>> 
>> — Gil.
>> 
>>> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
>>> 
>>> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>>> 
>>> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>>> 
>>> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>>> 
>>> 
>>> On 2017-07-05 09:20 PM, Gil Tene wrote:
>>>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>>> — Gil.
>>>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
>>>>> 
>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>> (and related) operations [1].  Using == to compare instances of
>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>> instances of value-based classes?
>>>>> 
>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>> value for example?  Do I have to box the value in something that's not
>>>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>>> 
>>>>> -Michael
>>>>> 
>>>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> 
>> 
>> 
>> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu Jul  6 18:43:04 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 6 Jul 2017 23:43:04 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <CA0CA26F-9C4A-4812-821B-00C96314E992@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com>
 <9D79E215-482B-4859-B35E-CB593A99E6A6@azul.com>
 <CBEA620A-5F21-4878-B56B-C8B0903B05FA@azul.com>
 <80a7d3fe-f30d-e953-dfb3-f8bb257142c2@gmail.com>
 <B452CF16-A3A2-461A-B5D3-E722317B578F@azul.com>
 <A5EAFD64-E012-4A4A-BB8F-615CAB6CCE6D@gmail.com>
 <CA0CA26F-9C4A-4812-821B-00C96314E992@azul.com>
Message-ID: <CD28DDF6-135B-426A-AFAA-A937006EE3F5@gmail.com>

It’s worse than that :-)

a = d;
a.x = 1;

What is d.x?

That’s the meaning of identity.


> On 6 Jul 2017, at 22:57, Gil Tene <gil at azul.com> wrote:
> 
> 
>> On Jul 6, 2017, at 1:56 PM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>> 
>> What’s wrong with “==“ doing a sensible default thing? Like, bitwise compare the “contents”? It’s certainly no slower than calling equals() that perhaps will do more than just bitwise-compare.
> 
> Nothing "wrong" with that if we had a good specification on WHEN it means that. And "when both sides of the == are instances of value-based classes" probably doesn't cut it.
> 
> To see why, the javac compiler won't let us write:
> int i = 0;
> Object o = new Object();
> boolean b = (o == i);
> That's because int is NOT AN OBJECT.
> 
> But javac absolutely does let us write:
> Object o1 = getSomeObject();
> Optional o2 = getSomeOtherObject();
> boolean b = (o1 == o2);
> What does that == mean? What can it mean without being "surprising"?
> 
> And while it's tempting to say that here:
> Optional o1 = Optional.of(objA);
> Optional o2 = Optional.of(objB);
> boolean b = (o1 == o2);
> The == means "compare the contents". What should it mean here:
> Object o1 = Optional.of(objA);
> Object o2 = Optional.of(objB);
> boolean b = (o1 == o2);
> I suspect that the curse of being the basterd children of Object will follow instances of value based classes around for generations to come… It will be curious to see how value types deal with this same problem in an eventual working syntax. 

I see no problem here.

If the compiler has no problem finding o2's equals() method, surely it can find its “==“ method.



>> What’s wrong with identityHashCode producing a code based on identityHashCodes of the “contents”, or the bit contents of the primitive members?
> 
> Similarly, identityHashCode already has a meaning for Object, where it will NOT be computed based on contents. Changing that for the basterd children of Object will create all sorts of in-fighting in the family:


The ugly duckling has to have immutable “contents”, because of “what’s d.x?” - or “mutating” produces a different value, which, again, exposes its non-Object-like nature. So identityHashCode as a hash of "contents" is not an issue.


Alex

> Optional o1 = Optional.of(objA);
> int ihc1 = System.identityHashCode(o1);
> ...
> Object o2 = o1;
> int ihc2 = System.identityHashCode(o2);
> boolean b = (ihc1 == ihc2); // Is this allowed to be False?
>> 
>> Alex
>> 
>>> On 6 Jul 2017, at 20:23, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> 
>>> I think that performant runtime checks can be added. When you haven't stuffed indentity-lacking things into other things that explore identity, things will be just as fast. When you do, they will blow up, and speed won't matter.
>>> 
>>> The larger problem of "surprising behavior" when passing a non-identity-capable thing (basterd child of Object) to some thing that expects Object and does object things with it at some future point in time (like maybe using identity for something) is likely to come at us hard when "codes like a class, works like an int" value types are introduced. IMO, it is "hard" (as in impractical) to compile-time check this stuff away completely. You can cover some (many?) cases, but runtime issues will always remain. The situation where people are appalled at what can happen with instances of value-based classes that they may pass to innocent Object-expecting things is just a glimpse of the future. IMO an exception is the least bad thing you can do to them. Much better than letting their code run.
>>> 
>>> — Gil.
>>> 
>>>> On Jul 6, 2017, at 11:52 AM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>>>> 
>>>> Although it would be nice to have value-based classes truly supported, because the java.time classes are defined as ordinary classes, they can never change into becoming true value-based classes without breaking compatibility. You can't just change the definition of instance equality without completely breaking the language completely. Improper use of a weak value-based class should at the very least trigger a compiler warning, but a full runtime check is too extreme.
>>>> 
>>>> Consider how these checks are implemented by the compiler. Adding a runtime check would be equivalent to making every == check, cas, etc behave like a virtual method call. I wouldn't be terribly happy to see a performance regression introduced in something so fundamental and used everywhere.
>>>> 
>>>> Also consider problems resulting an exception thrown from the == operator. This isn't supposed to happen. Any piece of code which is designed to be fault tolerant (via exception handling) is now broken, because it assumed (correctly) that fundamental language design elements don't change.
>>>> 
>>>> 
>>>> On 2017-07-06 11:15 AM, Gil Tene wrote:
>>>>> David, the below is a (potentially good) argument for not allowing the creation of subclasses of Object that do not have well defined support identity, identity comparison, identity hashing, or synchronization, since Object supports all those, things that hold Object instances may very well make use of them.
>>>>> But that horse has long fled the barn. We can argue that value-based classes should not have been specified in Java 8. Or that the future value types should not be derived from Object. But the first case is already in the Java spec, and the second is likely coming (and is sneakily able to use the first as a precedent).
>>>>> For the "how should we specify things?" discussion, I'm actually squarely on the side of "things with no identity should never have been derived from Object" of this argument. E.g. I would advise other language specifications to avoid making the same mistake, either by not giving the base Object class identity to begin with, or by creating a separate orthogonal type hierarchy for value types and "value based" classes. However, I don't see a way to "fix" the mistake already made, and we have to deal with the language and the machine as spec'ed, not as we wish it were. And so does anyone writing code in the language.
>>>>> In the context of that reality, we are discussing what correct uses of those new "basterd children of Object" are. And since the basterds clearly have no identity, using any logic that relies on identity behavior in any way is wrong.
>>>>> Sent from my iPad
>>>>> On Jul 6, 2017, at 10:53 AM, Gil Tene <gil at azul.com <mailto:gil at azul.com> <mailto:gil at azul.com <mailto:gil at azul.com>>> wrote:
>>>>>> Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).
>>>>>> 
>>>>>> Sent from my iPad
>>>>>> 
>>>>>> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com> <mailto:oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>>> wrote:
>>>>>> 
>>>>>>> Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.
>>>>>>> 
>>>>>>> List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.
>>>>>>> 
>>>>>>> Alex
>>>>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170706/5bbf802e/attachment.html>

From aph at redhat.com  Fri Jul  7 04:39:13 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 09:39:13 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
Message-ID: <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>

On 06/07/17 17:33, Gil Tene wrote:

> We could further discuss whether or not the JVM is allowed to
> "falsely" indicate that == is true (or that != is false) even when
> the instances differ in value (so are not .equals()). It is.

No it isn't, unless you believe that the paragraph on value-based
classes overrides the JLS.  For it to do so, the definition of
reference equality would have to change.  Right now, all it says is
"At run time, the result of == is true if the operand values are both
null or both refer to the same object or array; otherwise, the result
is false."  I suppose you could argue that in the context of a
value-based class the notion of "same object" is vacuous, but that
would be a heck of a stretch.

> Doing that may certainly surprise anyone who uses the identity based
> == for anything to do with instances of value-based classes, even
> tho using it would be silly given that == might obviously be
> always-false. For example, I could see how someone may mistakenly
> try to use == as an "optimization" on the assumption that if they
> get lucky and == is true, .equals() must be true as well, and that
> evaluating == might be cheaper, but they would still "do the right
> thing" in the != case. But that would be a mistake, and a clear
> violation of the "don't do that" admonition above.

Frankly, I don't believe it.  Any JVM which did what you suggest would
IMO be in violation of the JLS and the JVM specification.  It is
possible that the definition of reference equality will be changed, but
that would require the incompatible specification change to be
discussed.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From aph at redhat.com  Fri Jul  7 05:20:25 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 10:20:25 +0100
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
Message-ID: <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>

On 06/07/17 20:12, Gil Tene wrote:

> The answer to this is generally "But… concurrency!". Which is why
> this is an ok place to chat about it probably. With no identity, how
> do you achieve atomic updates? Michael's MutableClock example
> (scroll down) of wanting to (potentially concurrently) add duration
> amounts to some notion of a point in time, while avoiding the
> potential for "losing" an add racy situations, requires some sort of
> synchronization. Since Instant is not mutable, and we are
> necessarily trying to atomically replace one Instant value with
> another, we have a problem with the notion that these values have no
> identity (and therefore no way to do a proper CAS on).

In practice it doesn't matter, because you don't need to CAS a
reference to an Instant: all you need to do is to wrap all of the
updates to that reference in synchronized blocks.  Readers don't need
anything more than for that reference to be volatile.  The
immutability of Instant and the sequential consistency of volatile
provide all the guarantees that anyone needs or are possible.

I doubt that a synchronized block is going to perform much more badly
than spinning in a CAS loop, especially in the presence of high
contention.  In the many readers/few writers situation that Michael
describes this is the optimal solution.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From oleksandr.otenko at gmail.com  Fri Jul  7 05:23:58 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 7 Jul 2017 10:23:58 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
Message-ID: <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>

No, not only updates, but reads, too.

If you assume non-atomic updates, the problem becomes just like with volatile long - has to use synchronized block for all accesses.

Alex

> On 7 Jul 2017, at 10:20, Andrew Haley <aph at redhat.com> wrote:
> 
> On 06/07/17 20:12, Gil Tene wrote:
> 
>> The answer to this is generally "But… concurrency!". Which is why
>> this is an ok place to chat about it probably. With no identity, how
>> do you achieve atomic updates? Michael's MutableClock example
>> (scroll down) of wanting to (potentially concurrently) add duration
>> amounts to some notion of a point in time, while avoiding the
>> potential for "losing" an add racy situations, requires some sort of
>> synchronization. Since Instant is not mutable, and we are
>> necessarily trying to atomically replace one Instant value with
>> another, we have a problem with the notion that these values have no
>> identity (and therefore no way to do a proper CAS on).
> 
> In practice it doesn't matter, because you don't need to CAS a
> reference to an Instant: all you need to do is to wrap all of the
> updates to that reference in synchronized blocks.  Readers don't need
> anything more than for that reference to be volatile.  The
> immutability of Instant and the sequential consistency of volatile
> provide all the guarantees that anyone needs or are possible.
> 
> I doubt that a synchronized block is going to perform much more badly
> than spinning in a CAS loop, especially in the presence of high
> contention.  In the many readers/few writers situation that Michael
> describes this is the optimal solution.
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Fri Jul  7 05:24:52 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 7 Jul 2017 10:24:52 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
Message-ID: <C8BE1D9A-DEE8-40DE-997D-54F520E9EBF6@gmail.com>

(of course, for platforms that don’t support atomic 64-bit writes)

Alex

> On 7 Jul 2017, at 10:23, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
> 
> No, not only updates, but reads, too.
> 
> If you assume non-atomic updates, the problem becomes just like with volatile long - has to use synchronized block for all accesses.
> 
> Alex
> 
>> On 7 Jul 2017, at 10:20, Andrew Haley <aph at redhat.com> wrote:
>> 
>> On 06/07/17 20:12, Gil Tene wrote:
>> 
>>> The answer to this is generally "But… concurrency!". Which is why
>>> this is an ok place to chat about it probably. With no identity, how
>>> do you achieve atomic updates? Michael's MutableClock example
>>> (scroll down) of wanting to (potentially concurrently) add duration
>>> amounts to some notion of a point in time, while avoiding the
>>> potential for "losing" an add racy situations, requires some sort of
>>> synchronization. Since Instant is not mutable, and we are
>>> necessarily trying to atomically replace one Instant value with
>>> another, we have a problem with the notion that these values have no
>>> identity (and therefore no way to do a proper CAS on).
>> 
>> In practice it doesn't matter, because you don't need to CAS a
>> reference to an Instant: all you need to do is to wrap all of the
>> updates to that reference in synchronized blocks.  Readers don't need
>> anything more than for that reference to be volatile.  The
>> immutability of Instant and the sequential consistency of volatile
>> provide all the guarantees that anyone needs or are possible.
>> 
>> I doubt that a synchronized block is going to perform much more badly
>> than spinning in a CAS loop, especially in the presence of high
>> contention.  In the many readers/few writers situation that Michael
>> describes this is the optimal solution.
>> 
>> -- 
>> Andrew Haley
>> Java Platform Lead Engineer
>> Red Hat UK Ltd. <https://www.redhat.com>
>> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From aph at redhat.com  Fri Jul  7 05:32:05 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 10:32:05 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
Message-ID: <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>

On 07/07/17 10:23, Alex Otenko wrote:
> No, not only updates, but reads, too.
> 
> If you assume non-atomic updates, the problem becomes just like with
> volatile long - has to use synchronized block for all accesses.

No.  There is one reference to the Instant, reference updates are
atomic, and Instant itself is immutable, so none of its state becomes
visible before all of its fields are initialized.  I do not believe
that it is necessary for readers to be synchronized.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From kirk at kodewerk.com  Fri Jul  7 05:41:41 2017
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Fri, 7 Jul 2017 11:41:41 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <CACzrW9An5KG9h4WqEhDCBm8y+xZP_4RE6pJmSuvG9HBtF6mhXg@mail.gmail.com>
Message-ID: <9A2980F9-8612-48AC-BFAA-FB3FCCB8AEDB@kodewerk.com>


> On Jul 6, 2017, at 11:29 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
> 
> Given:
> 
> Instant i1 = Instant.ofEpochMilli(2);
> Instant i2 = Instant.ofEpochMilli(2);
> 
> In Java 8:
> 
> i1.equals(i2) is true
> i1 == i2  is false
> 
> And in some future version, i1 == i2  might be true.
> 
> But this is not especially radical. Java 10 could introduce a cache in
> the factory method that always returns the same instance. In fact,
> there already is a cache if you call
> Instant.ofEpochMilli(0);
> 
> The key phrase in
> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> is "A program may produce unpredictable results if it attempts to
> distinguish two references to equal values of a value-based class".
> IMO, the intent is to tell everyone that they shouldn't try to tell
> the difference between two instances using ==, and if they do their
> program may change meaning in the future (ie. be unpredictable, but
> not stupidly unpredictable as some in the thread are suggesting).

I’m sorry but of the reasons I previously stated, this is broken.

— Kirk


From dl at cs.oswego.edu  Fri Jul  7 08:20:19 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 7 Jul 2017 08:20:19 -0400
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
Message-ID: <b345ea43-c251-c57a-9d6a-395e2c1ec0e4@cs.oswego.edu>

On 07/07/2017 05:20 AM, Andrew Haley wrote:

> In practice it doesn't matter, because you don't need to CAS a
> reference to an Instant: all you need to do is to wrap all of the
> updates to that reference in synchronized blocks.  Readers don't need
> anything more than for that reference to be volatile.  The
> immutability of Instant and the sequential consistency of volatile
> provide all the guarantees that anyone needs or are possible.
> 
> I doubt that a synchronized block is going to perform much more badly
> than spinning in a CAS loop, especially in the presence of high
> contention.  In the many readers/few writers situation that Michael
> describes this is the optimal solution.
> 

Although amenable to the VarHandle tweak of using getAcquire
(vs implicit getVolatile) for reads. This tiny loosening of sequential
consistency might improve performance on ARM and POWER.
It's the Volatile/locked-write, acquiring-read pattern mentioned in
  http://gee.cs.oswego.edu/dl/html/j9mm.html#mixedvolatilesec

-Doug

From oleksandr.otenko at gmail.com  Fri Jul  7 08:27:05 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 7 Jul 2017 13:27:05 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
Message-ID: <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>

If you are updating a reference, then CAS can also work. If you are talking about imitating update of the reference by mutating inlined object contents, then you do need synchronized for readers.

Alex

> On 7 Jul 2017, at 10:32, Andrew Haley <aph at redhat.com> wrote:
> 
> On 07/07/17 10:23, Alex Otenko wrote:
>> No, not only updates, but reads, too.
>> 
>> If you assume non-atomic updates, the problem becomes just like with
>> volatile long - has to use synchronized block for all accesses.
> 
> No.  There is one reference to the Instant, reference updates are
> atomic, and Instant itself is immutable, so none of its state becomes
> visible before all of its fields are initialized.  I do not believe
> that it is necessary for readers to be synchronized.
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From dl at cs.oswego.edu  Fri Jul  7 09:01:10 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 7 Jul 2017 09:01:10 -0400
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
 <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
Message-ID: <2af4c799-b132-6399-28fb-5d6993e23eac@cs.oswego.edu>

On 07/07/2017 08:27 AM, Alex Otenko wrote:
> If you are updating a reference, then CAS can also work. If you are
> talking about imitating update of the reference by mutating inlined
> object contents, then you do need synchronized for readers.

Or use a StampedLock, with initial optimistic read, falling
back to read-lock, as in the javadoc examples for StampedLock:
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/locks/StampedLock.html

(This is an extension of the SC-write, acquire-read pattern in
my last post.)

-Doug



> 
> Alex
> 
>> On 7 Jul 2017, at 10:32, Andrew Haley <aph at redhat.com> wrote:
>> 
>> On 07/07/17 10:23, Alex Otenko wrote:
>>> No, not only updates, but reads, too.
>>> 
>>> If you assume non-atomic updates, the problem becomes just like
>>> with volatile long - has to use synchronized block for all
>>> accesses.
>> 
>> No.  There is one reference to the Instant, reference updates are 
>> atomic, and Instant itself is immutable, so none of its state
>> becomes visible before all of its fields are initialized.  I do not
>> believe that it is necessary for readers to be synchronized.
>> 
>> -- Andrew Haley Java Platform Lead Engineer Red Hat UK Ltd.
>> <https://www.redhat.com> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035
>> 332F A671
> 
> _______________________________________________ Concurrency-interest
> mailing list Concurrency-interest at cs.oswego.edu 
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From dl at cs.oswego.edu  Fri Jul  7 09:10:43 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 7 Jul 2017 09:10:43 -0400
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <1312065899.2400507.1499352534554.JavaMail.zimbra@u-pem.fr>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <a3fdb242-fa47-7eac-8ae1-60e70a879cf5@cs.oswego.edu>
 <1312065899.2400507.1499352534554.JavaMail.zimbra@u-pem.fr>
Message-ID: <94bc1e09-3754-e1f3-8964-483f190d5d7c@cs.oswego.edu>


On 07/06/2017 10:48 AM, Remi Forax wrote:
> 
> Value types have no identity so no identityHashCode.

But all instances accessible by multiple threads are contained by
an object with an identity (or transitively so).
So for example container-hash plus offset might suffice.

(This is veering too far off topic; let's take followups elsewhere.)

-Doug


From aph at redhat.com  Fri Jul  7 09:26:06 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 14:26:06 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
 <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
Message-ID: <bb484798-d2dc-138a-8e5f-2fcb8b5c1ed2@redhat.com>

On 07/07/17 13:27, Alex Otenko wrote:

> If you are updating a reference, then CAS can also work.

Well, that is the subject of some contention here, because the spec
*explicitly* says you should not compare quality, and that is what a
CAS does.  But the re is no need for a CAS; synchronized will do, and
it allows you to call equals() rather than using reference equality.

In practice, avoiding the use of reference equality is not a problem.
That is my point.

> If you are talking about imitating update of the reference by
> mutating inlined object contents,

You're not in this case.

> then you do need synchronized for readers.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From david.lloyd at redhat.com  Fri Jul  7 09:41:53 2017
From: david.lloyd at redhat.com (David Lloyd)
Date: Fri, 7 Jul 2017 08:41:53 -0500
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
Message-ID: <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>

On Fri, Jul 7, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
> In practice it doesn't matter, because you don't need to CAS a
> reference to an Instant: all you need to do is to wrap all of the

I think you must have meant, "In practice it doesn't matter _in this
particular case_".  The problem of general data structures which use
CAS for updates matters very much in practice.

From aph at redhat.com  Fri Jul  7 09:52:24 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 14:52:24 +0100
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
Message-ID: <d6279627-8479-875e-008b-788ba6696599@redhat.com>

On 07/07/17 14:41, David Lloyd wrote:
> On Fri, Jul 7, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>> In practice it doesn't matter, because you don't need to CAS a
>> reference to an Instant: all you need to do is to wrap all of the
> 
> I think you must have meant, "In practice it doesn't matter _in this
> particular case_".  The problem of general data structures which use
> CAS for updates matters very much in practice.

I'm talking about the problem of atomically updating an instance of a
value-based class while multiple threads are accessing it.  Unless I
am very much mistaken this thread is about no other subject.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From david.lloyd at redhat.com  Fri Jul  7 10:02:05 2017
From: david.lloyd at redhat.com (David Lloyd)
Date: Fri, 7 Jul 2017 09:02:05 -0500
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <d6279627-8479-875e-008b-788ba6696599@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
Message-ID: <CANghgrSAnTRt75BmtK2t1q2TmZ6-=htUYxkwR3=eQY__1drYdQ@mail.gmail.com>

On Fri, Jul 7, 2017 at 8:52 AM, Andrew Haley <aph at redhat.com> wrote:
> On 07/07/17 14:41, David Lloyd wrote:
>> On Fri, Jul 7, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>> In practice it doesn't matter, because you don't need to CAS a
>>> reference to an Instant: all you need to do is to wrap all of the
>>
>> I think you must have meant, "In practice it doesn't matter _in this
>> particular case_".  The problem of general data structures which use
>> CAS for updates matters very much in practice.
>
> I'm talking about the problem of atomically updating an instance of a
> value-based class while multiple threads are accessing it.  Unless I
> am very much mistaken this thread is about no other subject.

By my reading of the thread, most of it, if not all of it, is about
the more general problem of atomically updating a reference with CAS
and the behavior of the "compare" part in relation to value classes.
There is a clear problem if you don't know that your target type is a
value class and your JVM aggressively optimizes them in a way which
breaks referential equality in an unexpected way.

From gil at azul.com  Fri Jul  7 12:32:00 2017
From: gil at azul.com (Gil Tene)
Date: Fri, 7 Jul 2017 16:32:00 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
Message-ID: <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>


> On Jul 7, 2017, at 1:39 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 06/07/17 17:33, Gil Tene wrote:
> 
>> We could further discuss whether or not the JVM is allowed to
>> "falsely" indicate that == is true (or that != is false) even when
>> the instances differ in value (so are not .equals()). It is.
> 
> No it isn't, unless you believe that the paragraph on value-based
> classes overrides the JLS.  For it to do so, the definition of
> reference equality would have to change.  Right now, all it says is
> "At run time, the result of == is true if the operand values are both
> null or both refer to the same object or array; otherwise, the result
> is false."  I suppose you could argue that in the context of a
> value-based class the notion of "same object" is vacuous, but that
> would be a heck of a stretch.
> 
>> Doing that may certainly surprise anyone who uses the identity based
>> == for anything to do with instances of value-based classes, even
>> tho using it would be silly given that == might obviously be
>> always-false. For example, I could see how someone may mistakenly
>> try to use == as an "optimization" on the assumption that if they
>> get lucky and == is true, .equals() must be true as well, and that
>> evaluating == might be cheaper, but they would still "do the right
>> thing" in the != case. But that would be a mistake, and a clear
>> violation of the "don't do that" admonition above.
> 
> Frankly, I don't believe it.  Any JVM which did what you suggest would
> IMO be in violation of the JLS and the JVM specification.  It is
> possible that the definition of reference equality will be changed, but
> that would require the incompatible specification change to be
> discussed.

The argument would be (as you note above in the "heck of a stretch") that the field we use to talk about the instance is not a reference, but something else. Because a reference is an object identity, and value-based classes have no object identity. So it is something else. A "value identifier" of some sort. And the == operator is simply undefined on that something else. It certainly doesn't have the meaning of "IFF == is true then the value is the same" (which may be want we'd want it to mean). And it can't possibly mean "if == is the same the the object identity is the same" because there is no identity…

The "ugly" part of all this is that the compiler (and the way this stuff is derived from Object) will let you write this stuff about identity that doesn't exist, so we get to argue over what it means, and what reasonable or unreasonable ways to deal with undefined operations on non-existent identity would be.

When discussing how far a "reasonable" JVM would go:

1.  I'd agree with you that I would feel too nervous about making this undefined-behavior == operation evaluate as true for non-equal values.
 [this shouldn't make people writing Java code "comfortable" with interpreting the operand to mean that the values must be equal. It is still undefined. And this is still wrong code to write. But I'm going to want to avoid arguing too much about it, so...]

2. I would feel completely comfortable with == evaluating as always false, and != evaluating as always-true. 
[Those are clearly possible and valid results. The "reference" *could* be taken away at any point, and freely replaced with something else for which .equals() is true. So acting like that happens every single time is completely reasonable. This is what makes CAS useless BTW, since it may always fail even with no contention.]

3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.


> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From gil at azul.com  Fri Jul  7 13:02:47 2017
From: gil at azul.com (Gil Tene)
Date: Fri, 7 Jul 2017 17:02:47 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <d6279627-8479-875e-008b-788ba6696599@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
Message-ID: <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>


On Jul 7, 2017, at 6:52 AM, Andrew Haley <aph at redhat.com<mailto:aph at redhat.com>> wrote:

On 07/07/17 14:41, David Lloyd wrote:
On Fri, Jul 7, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com<mailto:aph at redhat.com>> wrote:
In practice it doesn't matter, because you don't need to CAS a
reference to an Instant: all you need to do is to wrap all of the

I think you must have meant, "In practice it doesn't matter _in this
particular case_".  The problem of general data structures which use
CAS for updates matters very much in practice.

I'm talking about the problem of atomically updating an instance of a
value-based class while multiple threads are accessing it.  Unless I
am very much mistaken this thread is about no other subject.

You are right. That's the subject of the thread. And in some cases locking (on something other than the reference to the value-based class) will be perfectly sufficient. But in cases where people seek lock-free or wait-free operations, locking may not be an acceptable thing. E.g. Clocks and Instants are starting to show up in the low latency paths of FinServ software due to MiFID 2 requirements, and that sort of code often tries to avoid locking like the plague…

For reference, here are my variants of Michael's originally posted MutableClock (which is the thing that started this thread, I believe). They is still lock free, and CAS's on a boxed Instant to avoid the "compare" on undefined identity. MutableClock still supports sharing updates across clock instances, but UnsharedMutableClock is a [I think correct] variant where "shared updates" are not supported, and caches the Instant for faster read access.


public class MutableClock {

    public static MutableClock create(final Instant instant, final ZoneId zone) {
        return new MutableClock(
                new AtomicReference<>(new BoxedInstant(instant)),
                zone);
    }

    private final AtomicReference<BoxedInstant> instantHolder;
    private final ZoneId zone;

    private MutableClock(
            final AtomicReference<BoxedInstant> instantHolder,
            final ZoneId zone) {
        this.instantHolder = instantHolder;
        this.zone = zone;
    }

    public Instant instant() {
        return instantHolder.get().getInstant();
    }

    public ZoneId getZone() {
        return zone;
    }

    public void setInstant(final Instant newInstant) {
        instantHolder.get().setInstant(newInstant);
    }

    public void add(final Duration amountToAdd) {
        boolean success;
        do {
            BoxedInstant currentBoxedInstance = instantHolder.get();
            BoxedInstant newBoxedInstant =
                    new BoxedInstant(currentBoxedInstance.getInstant().plus(amountToAdd));
            success = instantHolder.compareAndSet(currentBoxedInstance, newBoxedInstant);
        } while (!success);
    }

    public MutableClock withZone(final ZoneId newZone) {
        // conveniently, AtomicReference also acts as a
        // vehicle for "shared updates" between instances:
        return new MutableClock(instantHolder, newZone);
    }

    private static class BoxedInstant {
        private Instant instant;

        BoxedInstant(final Instant instant) {
            setInstant(instant);
        }

        Instant getInstant() {
            return instant;
        }

        void setInstant(final Instant instant) {
            if (instant == null) {
                throw new UnsupportedOperationException("null instants are unsupported");
            }
            this.instant = instant;
        }
    }
}


public class UnsharedMutableClock {

    public static UnsharedMutableClock create(final Instant instant, final ZoneId zone) {
        return new UnsharedMutableClock(
                new AtomicReference<>(new BoxedInstant(instant)),
                zone);
    }

    private final AtomicReference<BoxedInstant> instantHolder;
    private final ZoneId zone;
    private Instant cachedInstant;
    private volatile boolean cacheIsValid = false;

    private UnsharedMutableClock(
            final AtomicReference<BoxedInstant> instantHolder,
            final ZoneId zone) {
        this.instantHolder = instantHolder;
        this.zone = zone;
        this.cachedInstant = instantHolder.get().getInstant();
    }

    public Instant instant() {
        if (!cacheIsValid) {
            cachedInstant = instantHolder.get().getInstant();
        }
        return cachedInstant;
    }

    public ZoneId getZone() {
        return zone;
    }

    public void setInstant(final Instant newInstant) {
        instantHolder.get().setInstant(newInstant);
        cacheIsValid = false;
    }

    public void add(final Duration amountToAdd) {
        boolean success;
        do {
            BoxedInstant currentBoxedInstance = instantHolder.get();
            BoxedInstant newBoxedInstant =
                    new BoxedInstant(currentBoxedInstance.getInstant().plus(amountToAdd));
            success = instantHolder.compareAndSet(currentBoxedInstance, newBoxedInstant);
        } while (!success);
        cacheIsValid = false;
    }

    private static class BoxedInstant {
        private Instant instant;

        BoxedInstant(final Instant instant) {
            setInstant(instant);
        }

        Instant getInstant() {
            return instant;
        }

        void setInstant(final Instant instant) {
            if (instant == null) {
                throw new UnsupportedOperationException("null instants are unsupported");
            }
            this.instant = instant;
        }
    }

}




--
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/edc5c12c/attachment-0001.html>

From kirk at kodewerk.com  Fri Jul  7 13:04:03 2017
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Fri, 7 Jul 2017 19:04:03 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
Message-ID: <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>

> 
> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.

I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.

— Kirk


From aph at redhat.com  Fri Jul  7 13:29:52 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 18:29:52 +0100
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
 <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
Message-ID: <b5a3c2f4-5c8b-f77a-66f2-63b17aa6aa7b@redhat.com>

On 07/07/17 18:02, Gil Tene wrote:
> 
> And in some cases locking (on something other than the reference to
> the value-based class) will be perfectly sufficient. But in cases
> where people seek lock-free or wait-free operations, locking may not
> be an acceptable thing. E.g. Clocks and Instants are starting to
> show up in the low latency paths of FinServ software due to MiFID 2
> requirements, and that sort of code often tries to avoid locking
> like the plague…

Mmm, but then the question is whether something like this is more
performant than locking:

>     public void add(final Duration amountToAdd) {
>         boolean success;
>         do {
>             BoxedInstant currentBoxedInstance = instantHolder.get();
>             BoxedInstant newBoxedInstant =
>                     new BoxedInstant(currentBoxedInstance.getInstant().plus(amountToAdd));
>             success = instantHolder.compareAndSet(currentBoxedInstance, newBoxedInstant);
>         } while (!success);
>     }

I'd argue that it's may well not be, because in the mostly-uncontended
case acquiring a lock will sail straight through with no significant
delay -- certainly no more than the compareAndSet we see here.  In the
highly-contended case, locking may be preferable to the inter-thread
thrashing this CAS loop might cause.  At least one of the threads
would acquire the lock, and at least one of them would make some
forward progress.  And the readers would be simpler and faster.  The
lock used could be a fast spinlock: it doesn't have to block at the OS
level.  But to know for sure you'd have to measure some real
application behaviour.

And the meta-question is whether people who avoid locking like the
plague, even when it really is the simplest and cleanest thing to do,
are doing it for good reasons or following a cargo cult.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From gil at azul.com  Fri Jul  7 13:32:29 2017
From: gil at azul.com (Gil Tene)
Date: Fri, 7 Jul 2017 17:32:29 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
Message-ID: <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>


On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com<mailto:kirk at kodewerk.com>> wrote:


3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.

I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.

Synchronous exceptions can be thrown for example because (https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2):

  *   evaluation of an expression violates the normal semantics of the Java programming language (§15.6<https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer divide by zero.

  *   an error occurs while loading, linking, or initializing part of the program (§12.2<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.2>, §12.3<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>); in this case, an instance of a subclass of LinkageError is thrown.

  *   an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMethodError is thrown. [GT: this is mis-spelled in the spec. Should be VirtualMachineError].

I'd hope to have it qualify under the first bullet, but it is not listed in the specific list of runtime exception causes in 15.6. However, evaluating an == expression where one of the operands is an instance of a value-based class (and has no identity) can probably qualify under "an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language" (third bullet). Especially when the Java SE spec explicitly says "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects".

Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An OOME can hit a == point in the code too.

I'd rather not make such exceptions a subclass of VirtualMachineError would be better tho...


— Kirk

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/1c85bf0a/attachment.html>

From vitalyd at gmail.com  Fri Jul  7 13:39:28 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 07 Jul 2017 17:39:28 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
Message-ID: <CAHjP37HT7M7Nc-8nuBmxrpAVzsNsgDg5fmxqhx+OC7qtzGk_Tw@mail.gmail.com>

I've skimmed this thread, so maybe missing something, but I agree with Kirk
here.

This needs to be solved at the type system level, not runtime exceptions
(nevermind the compatibility story).  A ValueBased class, IMO, is at most a
lint - I have a hard time imagining how those classes can be converted to
real VT when those exist.  No amount of javadoc will avoid breakage.
Without this being in the type system proper and thus making a compiler
fail a build if misused.  == needs to stay as is, and any code today that
uses == must be changed to only work on T=reference type when VT is
introduced and must refuse compilation (and verification) if provided a VT.

How to enable CAS and the like for VT would be a separate matter.

On Fri, Jul 7, 2017 at 1:05 PM Kirk Pepperdine <kirk at kodewerk.com> wrote:

> >
> > 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e.
> throw some runtime exception when encountering an indentity-based operation
> on an instance of a value-based class. Hard to argue that "an exception
> should not be thrown here" given the clear warnings in the spec. My worry
> is mostly about coverage. Throwing exceptions in all cases where identity
> based operations are attempted would clearly be right, and healthy. But
> doing so only in some cases (and leaving some undefined behavior executing
> paths that don't throw exceptions) doesn't solve the problem [and may make
> things worse by encouraging false confidence]. Since no one *requires* us
> to throw an exception right now, JVM implementors will probably keep taking
> the lazy approach and not work hard on trying to achieve complete coverage.
> And since don't do it at all" is probably better/easier to verify than "do
> it in some places but not in others", we'll probably avoid it altogether
> for now. This *may* change when value-based optimizations materialize.
>
> I think I’d have to (violently) disagree with this. There is a reason no
> one requires you to throw an exception when expressing equality and that is
> because this is a guaranteed property in the runtime. Without it you lose a
> fundamental property of the runtime.
>
> — Kirk
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/6ac803f2/attachment-0001.html>

From oleksandr.otenko at gmail.com  Fri Jul  7 13:41:49 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 7 Jul 2017 18:41:49 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <bb484798-d2dc-138a-8e5f-2fcb8b5c1ed2@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
 <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
 <bb484798-d2dc-138a-8e5f-2fcb8b5c1ed2@redhat.com>
Message-ID: <98BABECB-ACB9-4887-9DDC-2069C3BB8C35@gmail.com>

I think there is a bit of a split mind here: what the value class instance is (is it Object-like in the language spec, so does it behave like references?), and what the value class instance is implemented as by the JVM (is it Object-like in the actual memory layout, so does it behave like a reference?).

The value class instance does not necessarily fit in a single machine word - time Instance certainly doesn’t. If the time Instance is “inlined” by the JVM, then you can’t guarantee atomicity of writes, and atomicity of reads also, so the reads also need to use a synchronized block - whether demand that explicitly from the programmer, or do that implicitly, like it’s done for volatile long on some platforms, does not matter. (Or use StampedLock, as Doug points out).

If it’s done implicitly by the JVM that “inlines” the value class instance, then there is no need to require extra steps from the programmer.


Alex


> On 7 Jul 2017, at 14:26, Andrew Haley <aph at redhat.com> wrote:
> 
> On 07/07/17 13:27, Alex Otenko wrote:
> 
>> If you are updating a reference, then CAS can also work.
> 
> Well, that is the subject of some contention here, because the spec
> *explicitly* says you should not compare quality, and that is what a
> CAS does.  But the re is no need for a CAS; synchronized will do, and
> it allows you to call equals() rather than using reference equality.
> 
> In practice, avoiding the use of reference equality is not a problem.
> That is my point.
> 
>> If you are talking about imitating update of the reference by
>> mutating inlined object contents,
> 
> You're not in this case.
> 
>> then you do need synchronized for readers.
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From gil at azul.com  Fri Jul  7 13:42:26 2017
From: gil at azul.com (Gil Tene)
Date: Fri, 7 Jul 2017 17:42:26 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <b5a3c2f4-5c8b-f77a-66f2-63b17aa6aa7b@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
 <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
 <b5a3c2f4-5c8b-f77a-66f2-63b17aa6aa7b@redhat.com>
Message-ID: <7BDF786B-4945-4F49-AFCE-E90DEBB05CA9@azul.com>


> On Jul 7, 2017, at 10:29 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 07/07/17 18:02, Gil Tene wrote:
>> 
>> And in some cases locking (on something other than the reference to
>> the value-based class) will be perfectly sufficient. But in cases
>> where people seek lock-free or wait-free operations, locking may not
>> be an acceptable thing. E.g. Clocks and Instants are starting to
>> show up in the low latency paths of FinServ software due to MiFID 2
>> requirements, and that sort of code often tries to avoid locking
>> like the plague…
> 
> Mmm, but then the question is whether something like this is more
> performant than locking:
> 
>>    public void add(final Duration amountToAdd) {
>>        boolean success;
>>        do {
>>            BoxedInstant currentBoxedInstance = instantHolder.get();
>>            BoxedInstant newBoxedInstant =
>>                    new BoxedInstant(currentBoxedInstance.getInstant().plus(amountToAdd));
>>            success = instantHolder.compareAndSet(currentBoxedInstance, newBoxedInstant);
>>        } while (!success);
>>    }
> 
> I'd argue that it's may well not be, because in the mostly-uncontended
> case acquiring a lock will sail straight through with no significant
> delay -- certainly no more than the compareAndSet we see here.  In the
> highly-contended case, locking may be preferable to the inter-thread
> thrashing this CAS loop might cause.  At least one of the threads
> would acquire the lock, and at least one of them would make some
> forward progress.  And the readers would be simpler and faster.  The
> lock used could be a fast spinlock: it doesn't have to block at the OS
> level.  But to know for sure you'd have to measure some real
> application behaviour.
> 
> And the meta-question is whether people who avoid locking like the
> plague, even when it really is the simplest and cleanest thing to do,
> are doing it for good reasons or following a cargo cult.

The cult thing certainly does exist, but lock-freedom and wait-freedom as design criteria have real and good reasons too.

One typical and very real case is when a critical path thread cannot afford to block waiting for a non-critical path thread, even in a very rare case. Imagine that the two threads share a clock for some reason, and both participate in updating it (again, for some reason). The critical path thread will prefer taking the [potentially] extra hit of the code above in order to never be blocked behind the background thread owning a lock it is waiting on (which may have been context switched out for 10s of msec for one of many possible reasons).

This is a very common pattern in low latency systems where the critical path thread does operations that take low 10s of usec, but a background thread is doing some other thing [like updating a journal]. Such systems will often do much to protect the critical path thread from interference (e.g. pin it to a dedicated core, etc.).

> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From vitalyd at gmail.com  Fri Jul  7 13:52:52 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 7 Jul 2017 13:52:52 -0400
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <98BABECB-ACB9-4887-9DDC-2069C3BB8C35@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
 <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
 <bb484798-d2dc-138a-8e5f-2fcb8b5c1ed2@redhat.com>
 <98BABECB-ACB9-4887-9DDC-2069C3BB8C35@gmail.com>
Message-ID: <CAHjP37GgYz0LkfAPzc-5=GhTMFCDbTWLGQtrAuUJ-Vwy9gXh6Q@mail.gmail.com>

At worst, you can extract/pack CAS-width-compatible value (e.g. long) and
use that as the CAS storage.  Then materialize the VT from that on the fly
after reading the storage value out.  If that's not possible, then you use
locking, put it behind a heap object, or whatever other mechanism.

That's roughly what you do in the CLR, which doesn't allow CAS on structs
(irrespective of its size).

On Fri, Jul 7, 2017 at 1:42 PM Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> I think there is a bit of a split mind here: what the value class instance
> is (is it Object-like in the language spec, so does it behave like
> references?), and what the value class instance is implemented as by the
> JVM (is it Object-like in the actual memory layout, so does it behave like
> a reference?).
>
> The value class instance does not necessarily fit in a single machine word
> - time Instance certainly doesn’t. If the time Instance is “inlined” by the
> JVM, then you can’t guarantee atomicity of writes, and atomicity of reads
> also, so the reads also need to use a synchronized block - whether demand
> that explicitly from the programmer, or do that implicitly, like it’s done
> for volatile long on some platforms, does not matter. (Or use StampedLock,
> as Doug points out).
>
> If it’s done implicitly by the JVM that “inlines” the value class
> instance, then there is no need to require extra steps from the programmer.
>
>
> Alex
>
>
> > On 7 Jul 2017, at 14:26, Andrew Haley <aph at redhat.com> wrote:
> >
> > On 07/07/17 13:27, Alex Otenko wrote:
> >
> >> If you are updating a reference, then CAS can also work.
> >
> > Well, that is the subject of some contention here, because the spec
> > *explicitly* says you should not compare quality, and that is what a
> > CAS does.  But the re is no need for a CAS; synchronized will do, and
> > it allows you to call equals() rather than using reference equality.
> >
> > In practice, avoiding the use of reference equality is not a problem.
> > That is my point.
> >
> >> If you are talking about imitating update of the reference by
> >> mutating inlined object contents,
> >
> > You're not in this case.
> >
> >> then you do need synchronized for readers.
> >
> > --
> > Andrew Haley
> > Java Platform Lead Engineer
> > Red Hat UK Ltd. <https://www.redhat.com>
> > EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/d5e5e82b/attachment.html>

From aph at redhat.com  Fri Jul  7 14:16:30 2017
From: aph at redhat.com (Andrew Haley)
Date: Fri, 7 Jul 2017 19:16:30 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <98BABECB-ACB9-4887-9DDC-2069C3BB8C35@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <643DFCAB-7213-4840-B252-9F2A3BFF3429@gmail.com>
 <5c7e373c-7fc8-d28d-3f9b-40007887c655@redhat.com>
 <2C2833CB-08DE-4BD1-AF65-BCA2E2D9484F@gmail.com>
 <bb484798-d2dc-138a-8e5f-2fcb8b5c1ed2@redhat.com>
 <98BABECB-ACB9-4887-9DDC-2069C3BB8C35@gmail.com>
Message-ID: <9935e2f0-9f0a-f4f3-d051-af60af5e8982@redhat.com>

On 07/07/17 18:41, Alex Otenko wrote:

> The value class instance does not necessarily fit in a single
> machine word - time Instance certainly doesn’t. If the time Instance
> is “inlined” by the JVM, then you can’t guarantee atomicity of
> writes, and atomicity of reads also, so the reads also need to use a
> synchronized block - whether demand that explicitly from the
> programmer, or do that implicitly, like it’s done for volatile long
> on some platforms, does not matter. (Or use StampedLock, as Doug
> points out).

To be able to see a partly-constructed or overlapped instance of a
value-based class would be a clear violation of the JLS, so we don't
have to worry about that.  Any VM designer who wants to embed
instances of value-based classes is going to have to figure out how to
guarantee atomicity of updates.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From jsampson at guidewire.com  Fri Jul  7 15:07:55 2017
From: jsampson at guidewire.com (Justin Sampson)
Date: Fri, 7 Jul 2017 19:07:55 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
 <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
Message-ID: <E79858DB-8CAE-44CC-A426-886700AFA2E3@guidewire.com>

Gil Tene wrote:

> public void setInstant(final Instant newInstant) {
>   instantHolder.get().setInstant(newInstant);
> }

This is broken because there's no volatile write. It needs to be instantHolder.set(new BoxedInstant(newInstant)), and then BoxedInstant can be immutable. I don't think you can get away from instantiating a new box each time, if your interpretation is correct.

Cheers,
Justin


From gil at azul.com  Fri Jul  7 15:21:33 2017
From: gil at azul.com (Gil Tene)
Date: Fri, 7 Jul 2017 19:21:33 +0000
Subject: [concurrency-interest] Fwd: Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E79858DB-8CAE-44CC-A426-886700AFA2E3@guidewire.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <1ffd08fe-eb28-5c3e-73e3-98e1be209d67@redhat.com>
 <CANghgrRmfmDm8mia1xu_AhsX=NTBBDsHCWu0rWfipkr0o4gnbA@mail.gmail.com>
 <d6279627-8479-875e-008b-788ba6696599@redhat.com>
 <9957B55B-6BCB-4246-A3D6-1D0D3988C777@azul.com>
 <E79858DB-8CAE-44CC-A426-886700AFA2E3@guidewire.com>
Message-ID: <6985972A-A980-40A2-B4E4-4D929D01CB15@azul.com>


On Jul 7, 2017, at 12:07 PM, Justin Sampson <jsampson at guidewire.com<mailto:jsampson at guidewire.com>> wrote:

Gil Tene wrote:

public void setInstant(final Instant newInstant) {
 instantHolder.get().setInstant(newInstant);
}

This is broken because there's no volatile write. It needs to be instantHolder.set(new BoxedInstant(newInstant)), and then BoxedInstant can be immutable. I don't think you can get away from instantiating a new box each time, if your interpretation is correct.

You are right that the code above is broken due to a missing volatile write. But I don't think we need to force allocation each time here. Instead, we can keep the box mutable and introduce the missing volatile write this way:

public void setInstant(final Instant newInstant) {
    BoxedInstant boxedInstant = instantHolder.get();
    boxedInstant.setInstant(newInstant);
    instantHolder.set(boxedInstant); // to force volatile write
}

I believe that the various races possible between this  and other modifiers (other setInstant() caller, add() callers), are all possible in any case.


Cheers,
Justin


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/5e79e1ea/attachment.html>

From kirk at kodewerk.com  Fri Jul  7 17:06:47 2017
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Fri, 7 Jul 2017 23:06:47 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
Message-ID: <52D0E8AE-28EE-4CF6-BB69-DDAFD484252B@kodewerk.com>


> On Jul 7, 2017, at 7:32 PM, Gil Tene <gil at azul.com> wrote:
> 
> 
>> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com <mailto:kirk at kodewerk.com>> wrote:
>> 
>>> 
>>> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.
>> 
>> I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.
> 
> Synchronous exceptions can be thrown for example because (https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2>):
> evaluation of an expression violates the normal semantics of the Java programming language (§15.6 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer divide by zero.
> 
> 
Normal….
> 
>  <>an error occurs while loading, linking, or initializing part of the program (§12.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.2>, §12.3 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>); in this case, an instance of a subclass of LinkageError is thrown.
> 
> 
Again normal...
> 
>  <>an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMethodError is thrown. [GT: this is mis-spelled in the spec. Should be VirtualMachineError]. 
> 
> 
Again expected….
> 
> 
> I'd hope to have it qualify under the first bullet, but it is not listed in the specific list of runtime exception causes in 15.6. However, evaluating an == expression where one of the operands is an instance of a value-based class (and has no identity) can probably qualify under "an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language" (third bullet). Especially when the Java SE spec explicitly says "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects". 
> 
> Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An OOME can hit a == point in the code too.
> 
> I'd rather not make such exceptions a subclass of VirtualMachineError would be better tho…

There is only one 1. There is only one 2. I would expect in a value type where the value is a’, I would expect that there will only be one a’. Other wise you don’t have a value type, you have some weird form of boxing.

Kind regards,
Kirk

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170707/c3946c29/attachment.html>

From oleksandr.otenko at gmail.com  Fri Jul  7 19:22:37 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Sat, 8 Jul 2017 00:22:37 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
Message-ID: <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>

A type with no identity certainly is a frankentype. I don’t see why the poor specification needs to be taken to its extreme interpretation. Conceptual clarity is more important than saving CPU cycles.

Having a type that is reified as something that does not have “a unique address” in memory (that we understand as the identity of Objects) is different from “no identity”.

Being unable to use “value type” instances for synchronization is perfectly reasonable - in the end, you aren’t meant to synchronize using random objects, and the whole purpose of supporting synchronization on every object is to ease construction of thread-safe code (through declaration of synchronized methods). If "the thing” is immutable, there is no need to support synchronization on those specific instances, and choosing such instances as the means of synchronizing something else requires justification, even if “the thing” subclasses from Object.

Restricting the meaning of identityHashCode is questionable, but in the end hinges on whether “the thing” is a subclass of an Object or not. If it is, then there are ways to support identityHashCode - even if there is no notion of “a unique address”.

Restricting the use of "==“ because of some compiler optimizations, is inventing obstacles. I don’t see why compiler problems of this sort should leak into the application programmer’s life, especially in the form of RandomExceptions and heisenbugs.


Alex


> On 7 Jul 2017, at 18:32, Gil Tene <gil at azul.com> wrote:
> 
> 
>> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com <mailto:kirk at kodewerk.com>> wrote:
>> 
>>> 
>>> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.
>> 
>> I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.
> 
> Synchronous exceptions can be thrown for example because (https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2>):
> evaluation of an expression violates the normal semantics of the Java programming language (§15.6 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer divide by zero.
> 
>  <>an error occurs while loading, linking, or initializing part of the program (§12.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.2>, §12.3 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>); in this case, an instance of a subclass of LinkageError is thrown.
> 
>  <>an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMethodError is thrown. [GT: this is mis-spelled in the spec. Should be VirtualMachineError]. 
> 
> 
> I'd hope to have it qualify under the first bullet, but it is not listed in the specific list of runtime exception causes in 15.6. However, evaluating an == expression where one of the operands is an instance of a value-based class (and has no identity) can probably qualify under "an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language" (third bullet). Especially when the Java SE spec explicitly says "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects". 
> 
> Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An OOME can hit a == point in the code too.
> 
> I'd rather not make such exceptions a subclass of VirtualMachineError would be better tho...
> 
>> 
>> — Kirk
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170708/cc96ef25/attachment-0001.html>

From gil at azul.com  Sat Jul  8 02:38:53 2017
From: gil at azul.com (Gil Tene)
Date: Sat, 8 Jul 2017 06:38:53 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>,
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
Message-ID: <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>

Alex, your statements below are all arguments for why value-based classes (as specified) and value types (as they seem to be headed) should not exist as subclasses of Object. As noted before, I'd probably be on your side if that one.

But they do exist, and they (very clearly and explicitly) have no identity. We can't change that fact. We can avoid using them if we want. But we probably can't use them and argue that what we are using should be behaving in some directly-opposite-from-their-specification way.

For vale-based classes, the meaning of  == , identityHashCode, and synchronization are all clearly, explicitly and loudly undefined, promising unpredictable behavior. For value types it is not yet clear if the == operand will be similarly (explicitly) undefined, or if it will have a new meaning (act like == on an int), but things are pretty clear when it comes to identityHashCode and synchronization.

The reasoning for these value-based classes and value types goes far beyond compiler optimizations. And I'm not the one arguing for them.

My arguments here are not about trying to justify some compiler optimizations, or trying to justify the choices of making these things subclasses the Object. They are about pointing out the actual meaning of things as defined and the (very high risk) of coding against it based on a hope that some temporarily observed behavior is actually reliable, when everything that describes what it does says otherwise. My mentions of potential optimizations are simply attempts to demonstrate how strange things can happen to code that does these "may cause unpredictable behavior" things.

Sent from my iPad

On Jul 7, 2017, at 4:22 PM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:

A type with no identity certainly is a frankentype. I don’t see why the poor specification needs to be taken to its extreme interpretation. Conceptual clarity is more important than saving CPU cycles.

Having a type that is reified as something that does not have “a unique address” in memory (that we understand as the identity of Objects) is different from “no identity”.

Being unable to use “value type” instances for synchronization is perfectly reasonable - in the end, you aren’t meant to synchronize using random objects, and the whole purpose of supporting synchronization on every object is to ease construction of thread-safe code (through declaration of synchronized methods). If "the thing” is immutable, there is no need to support synchronization on those specific instances, and choosing such instances as the means of synchronizing something else requires justification, even if “the thing” subclasses from Object.

Restricting the meaning of identityHashCode is questionable, but in the end hinges on whether “the thing” is a subclass of an Object or not. If it is, then there are ways to support identityHashCode - even if there is no notion of “a unique address”.

Restricting the use of "==“ because of some compiler optimizations, is inventing obstacles. I don’t see why compiler problems of this sort should leak into the application programmer’s life, especially in the form of RandomExceptions and heisenbugs.


Alex


On 7 Jul 2017, at 18:32, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:


On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com<mailto:kirk at kodewerk.com>> wrote:


3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.

I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.

Synchronous exceptions can be thrown for example because (https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2):

  *   evaluation of an expression violates the normal semantics of the Java programming language (§15.6<https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer divide by zero.

  *   an error occurs while loading, linking, or initializing part of the program (§12.2<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.2>, §12.3<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4<https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>); in this case, an instance of a subclass of LinkageError is thrown.

  *   an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMethodError is thrown. [GT: this is mis-spelled in the spec. Should be VirtualMachineError].

I'd hope to have it qualify under the first bullet, but it is not listed in the specific list of runtime exception causes in 15.6. However, evaluating an == expression where one of the operands is an instance of a value-based class (and has no identity) can probably qualify under "an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language" (third bullet). Especially when the Java SE spec explicitly says "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects".

Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An OOME can hit a == point in the code too.

I'd rather not make such exceptions a subclass of VirtualMachineError would be better tho...


— Kirk

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170708/b22f9b11/attachment.html>

From oleksandr.otenko at gmail.com  Sat Jul  8 03:26:46 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Sat, 8 Jul 2017 08:26:46 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
Message-ID: <8FC107D7-28BB-42CA-89C1-4A4DC8A3FCBA@gmail.com>

Sure, so it should change to a sensible definition. :-)

As such there isn’t even a generic way of determining whether something is a "value-based” instance or not - not even at runtime.

Alex

> On 8 Jul 2017, at 07:38, Gil Tene <gil at azul.com> wrote:
> 
> Alex, your statements below are all arguments for why value-based classes (as specified) and value types (as they seem to be headed) should not exist as subclasses of Object. As noted before, I'd probably be on your side if that one.
> 
> But they do exist, and they (very clearly and explicitly) have no identity. We can't change that fact. We can avoid using them if we want. But we probably can't use them and argue that what we are using should be behaving in some directly-opposite-from-their-specification way.
> 
> For vale-based classes, the meaning of  == , identityHashCode, and synchronization are all clearly, explicitly and loudly undefined, promising unpredictable behavior. For value types it is not yet clear if the == operand will be similarly (explicitly) undefined, or if it will have a new meaning (act like == on an int), but things are pretty clear when it comes to identityHashCode and synchronization.
> 
> The reasoning for these value-based classes and value types goes far beyond compiler optimizations. And I'm not the one arguing for them.
> 
> My arguments here are not about trying to justify some compiler optimizations, or trying to justify the choices of making these things subclasses the Object. They are about pointing out the actual meaning of things as defined and the (very high risk) of coding against it based on a hope that some temporarily observed behavior is actually reliable, when everything that describes what it does says otherwise. My mentions of potential optimizations are simply attempts to demonstrate how strange things can happen to code that does these "may cause unpredictable behavior" things.
> 
> Sent from my iPad
> 
> On Jul 7, 2017, at 4:22 PM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> 
>> A type with no identity certainly is a frankentype. I don’t see why the poor specification needs to be taken to its extreme interpretation. Conceptual clarity is more important than saving CPU cycles.
>> 
>> Having a type that is reified as something that does not have “a unique address” in memory (that we understand as the identity of Objects) is different from “no identity”.
>> 
>> Being unable to use “value type” instances for synchronization is perfectly reasonable - in the end, you aren’t meant to synchronize using random objects, and the whole purpose of supporting synchronization on every object is to ease construction of thread-safe code (through declaration of synchronized methods). If "the thing” is immutable, there is no need to support synchronization on those specific instances, and choosing such instances as the means of synchronizing something else requires justification, even if “the thing” subclasses from Object.
>> 
>> Restricting the meaning of identityHashCode is questionable, but in the end hinges on whether “the thing” is a subclass of an Object or not. If it is, then there are ways to support identityHashCode - even if there is no notion of “a unique address”.
>> 
>> Restricting the use of "==“ because of some compiler optimizations, is inventing obstacles. I don’t see why compiler problems of this sort should leak into the application programmer’s life, especially in the form of RandomExceptions and heisenbugs.
>> 
>> 
>> Alex
>> 
>> 
>>> On 7 Jul 2017, at 18:32, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> 
>>> 
>>>> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com <mailto:kirk at kodewerk.com>> wrote:
>>>> 
>>>>> 
>>>>> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw some runtime exception when encountering an indentity-based operation on an instance of a value-based class. Hard to argue that "an exception should not be thrown here" given the clear warnings in the spec. My worry is mostly about coverage. Throwing exceptions in all cases where identity based operations are attempted would clearly be right, and healthy. But doing so only in some cases (and leaving some undefined behavior executing paths that don't throw exceptions) doesn't solve the problem [and may make things worse by encouraging false confidence]. Since no one *requires* us to throw an exception right now, JVM implementors will probably keep taking the lazy approach and not work hard on trying to achieve complete coverage. And since don't do it at all" is probably better/easier to verify than "do it in some places but not in others", we'll probably avoid it altogether for now. This *may* change when value-based optimizations materialize.
>>>> 
>>>> I think I’d have to (violently) disagree with this. There is a reason no one requires you to throw an exception when expressing equality and that is because this is a guaranteed property in the runtime. Without it you lose a fundamental property of the runtime.
>>> 
>>> Synchronous exceptions can be thrown for example because (https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2>):
>>> evaluation of an expression violates the normal semantics of the Java programming language (§15.6 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer divide by zero.
>>> 
>>>  <>an error occurs while loading, linking, or initializing part of the program (§12.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.2>, §12.3 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>); in this case, an instance of a subclass of LinkageError is thrown.
>>> 
>>>  <>an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMethodError is thrown. [GT: this is mis-spelled in the spec. Should be VirtualMachineError]. 
>>> 
>>> 
>>> I'd hope to have it qualify under the first bullet, but it is not listed in the specific list of runtime exception causes in 15.6. However, evaluating an == expression where one of the operands is an instance of a value-based class (and has no identity) can probably qualify under "an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language" (third bullet). Especially when the Java SE spec explicitly says "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects". 
>>> 
>>> Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An OOME can hit a == point in the code too.
>>> 
>>> I'd rather not make such exceptions a subclass of VirtualMachineError would be better tho...
>>> 
>>>> 
>>>> — Kirk
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170708/bacf34fc/attachment-0001.html>

From aph at redhat.com  Sat Jul  8 04:19:08 2017
From: aph at redhat.com (Andrew Haley)
Date: Sat, 8 Jul 2017 09:19:08 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
Message-ID: <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>

On 08/07/17 07:38, Gil Tene wrote:

> My arguments here are not about trying to justify some compiler
> optimizations, or trying to justify the choices of making these
> things subclasses the Object. They are about pointing out the actual
> meaning of things as defined and the (very high risk) of coding
> against it based on a hope that some temporarily observed behavior
> is actually reliable, when everything that describes what it does
> says otherwise.

I disagree with this interpretation.  You're interpreting the language
in that paragraph as overriding some fundamental properties in the JLS.

In the case of C, the thing to do would be to ask for a clarification,
but I suspect that if we asked, say, John Rose, Alex Buckley, and
Brian Goetz we'd get different answers.  ;-)

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From forax at univ-mlv.fr  Sat Jul  8 05:57:50 2017
From: forax at univ-mlv.fr (Remi Forax)
Date: Sat, 8 Jul 2017 11:57:50 +0200 (CEST)
Subject: [concurrency-interest] Should I avoid compareAndSet
	with	value-based classes?
In-Reply-To: <8FC107D7-28BB-42CA-89C1-4A4DC8A3FCBA@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <8FC107D7-28BB-42CA-89C1-4A4DC8A3FCBA@gmail.com>
Message-ID: <464502522.3268505.1499507870152.JavaMail.zimbra@u-pem.fr>

@Alex 
Not yet, but at some point in the future, you will have a root of all value types and a common super type between objects, value types and primitives. 

@Gil: 
== already maps into different bytecodes, for value types, you can introduce a vcmp that compares all fields. 

@all, 
The in-progress writing about the minimal value type spec is here: 
http://cr.openjdk.java.net/~dlsmith/values.html 
There are currently two prototypes of that the MVT spec, one in the valhalla workspace of the OpenJDK and one by IBM. 

Then we will move to a more complex spec (called full value type spec) that will deal with the interaction between the different kind of types and also includes the support of generics. 

Rémi 

> De: "Alex Otenko" <oleksandr.otenko at gmail.com>
> À: "Gil Tene" <gil at azul.com>
> Cc: "concurrency-interest" <concurrency-interest at cs.oswego.edu>
> Envoyé: Samedi 8 Juillet 2017 09:26:46
> Objet: Re: [concurrency-interest] Should I avoid compareAndSet with value-based
> classes?

> Sure, so it should change to a sensible definition. :-)

> As such there isn’t even a generic way of determining whether something is a
> "value-based” instance or not - not even at runtime.

> Alex

>> On 8 Jul 2017, at 07:38, Gil Tene < gil at azul.com > wrote:

>> Alex, your statements below are all arguments for why value-based classes (as
>> specified) and value types (as they seem to be headed) should not exist as
>> subclasses of Object. As noted before, I'd probably be on your side if that
>> one.

>> But they do exist, and they (very clearly and explicitly) have no identity. We
>> can't change that fact. We can avoid using them if we want. But we probably
>> can't use them and argue that what we are using should be behaving in some
>> directly-opposite-from-their-specification way.

>> For vale-based classes, the meaning of == , identityHashCode, and
>> synchronization are all clearly, explicitly and loudly undefined, promising
>> unpredictable behavior. For value types it is not yet clear if the == operand
>> will be similarly (explicitly) undefined, or if it will have a new meaning (act
>> like == on an int), but things are pretty clear when it comes to
>> identityHashCode and synchronization.

>> The reasoning for these value-based classes and value types goes far beyond
>> compiler optimizations. And I'm not the one arguing for them.

>> My arguments here are not about trying to justify some compiler optimizations,
>> or trying to justify the choices of making these things subclasses the Object.
>> They are about pointing out the actual meaning of things as defined and the
>> (very high risk) of coding against it based on a hope that some temporarily
>> observed behavior is actually reliable, when everything that describes what it
>> does says otherwise. My mentions of potential optimizations are simply attempts
>> to demonstrate how strange things can happen to code that does these "may cause
>> unpredictable behavior" things.

>> Sent from my iPad

>> On Jul 7, 2017, at 4:22 PM, Alex Otenko < oleksandr.otenko at gmail.com > wrote:

>>> A type with no identity certainly is a frankentype. I don’t see why the poor
>>> specification needs to be taken to its extreme interpretation. Conceptual
>>> clarity is more important than saving CPU cycles.

>>> Having a type that is reified as something that does not have “a unique address”
>>> in memory (that we understand as the identity of Objects) is different from “no
>>> identity”.

>>> Being unable to use “value type” instances for synchronization is perfectly
>>> reasonable - in the end, you aren’t meant to synchronize using random objects,
>>> and the whole purpose of supporting synchronization on every object is to ease
>>> construction of thread-safe code (through declaration of synchronized methods).
>>> If "the thing” is immutable, there is no need to support synchronization on
>>> those specific instances, and choosing such instances as the means of
>>> synchronizing something else requires justification, even if “the thing”
>>> subclasses from Object.

>>> Restricting the meaning of identityHashCode is questionable, but in the end
>>> hinges on whether “the thing” is a subclass of an Object or not. If it is, then
>>> there are ways to support identityHashCode - even if there is no notion of “a
>>> unique address”.

>>> Restricting the use of "==“ because of some compiler optimizations, is inventing
>>> obstacles. I don’t see why compiler problems of this sort should leak into the
>>> application programmer’s life, especially in the form of RandomExceptions and
>>> heisenbugs.

>>> Alex

>>>> On 7 Jul 2017, at 18:32, Gil Tene < gil at azul.com > wrote:

>>>>> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine < kirk at kodewerk.com > wrote:

>>>>>> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e. throw
>>>>>> some runtime exception when encountering an indentity-based operation on an
>>>>>> instance of a value-based class. Hard to argue that "an exception should not be
>>>>>> thrown here" given the clear warnings in the spec. My worry is mostly about
>>>>>> coverage. Throwing exceptions in all cases where identity based operations are
>>>>>> attempted would clearly be right, and healthy. But doing so only in some cases
>>>>>> (and leaving some undefined behavior executing paths that don't throw
>>>>>> exceptions) doesn't solve the problem [and may make things worse by encouraging
>>>>>> false confidence]. Since no one *requires* us to throw an exception right now,
>>>>>> JVM implementors will probably keep taking the lazy approach and not work hard
>>>>>> on trying to achieve complete coverage. And since don't do it at all" is
>>>>>> probably better/easier to verify than "do it in some places but not in others",
>>>>>> we'll probably avoid it altogether for now. This *may* change when value-based
>>>>>> optimizations materialize.

>>>>> I think I’d have to (violently) disagree with this. There is a reason no one
>>>>> requires you to throw an exception when expressing equality and that is because
>>>>> this is a guaranteed property in the runtime. Without it you lose a fundamental
>>>>> property of the runtime.

>>>> Synchronous exceptions can be thrown for example because (
>>>> https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2 ):

>>>>     *

>>>> evaluation of an expression violates the normal semantics of the Java
>>>> programming language ( §15.6 ), such as an integer divide by zero.
>>>>     *

>>>> an error occurs while loading, linking, or initializing part of the program (
>>>> §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of
>>>> LinkageError is thrown.
>>>>     *

>>>> an internal error or resource limitation prevents the Java Virtual Machine from
>>>> implementing the semantics of the Java programming language; in this case, an
>>>> instance of a subclass of VirtualMethodError is thrown. [GT: this is
>>>> mis-spelled in the spec. Should be VirtualMachineError].

>>>> I'd hope to have it qualify under the first bullet, but it is not listed in the
>>>> specific list of runtime exception causes in 15.6. However, evaluating an ==
>>>> expression where one of the operands is an instance of a value-based class (and
>>>> has no identity) can probably qualify under "an internal error or resource
>>>> limitation prevents the Java Virtual Machine from implementing the semantics of
>>>> the Java programming language" (third bullet). Especially when the Java SE spec
>>>> explicitly says "Use of such identity-sensitive operations on instances of
>>>> value-based classes may have unpredictable effects".

>>>> Separately, asynchronous exceptions can be thrown anywhere in the code. E.g. An
>>>> OOME can hit a == point in the code too.

>>>> I'd rather not make such exceptions a subclass of VirtualMachineError would be
>>>> better tho...

>>>>> — Kirk

>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170708/d41487bf/attachment-0001.html>

From gil at azul.com  Sat Jul  8 08:22:33 2017
From: gil at azul.com (Gil Tene)
Date: Sat, 8 Jul 2017 12:22:33 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
Message-ID: <4855064A-EE00-4421-A258-519F38047ACA@azul.com>


> On Jul 8, 2017, at 1:19 AM, Andrew Haley <aph at redhat.com> wrote:
> 
> On 08/07/17 07:38, Gil Tene wrote:
> 
>> My arguments here are not about trying to justify some compiler
>> optimizations, or trying to justify the choices of making these
>> things subclasses the Object. They are about pointing out the actual
>> meaning of things as defined and the (very high risk) of coding
>> against it based on a hope that some temporarily observed behavior
>> is actually reliable, when everything that describes what it does
>> says otherwise.
> 
> I disagree with this interpretation.  You're interpreting the language
> in that paragraph as overriding some fundamental properties in the JLS.

To keep this to a simple case that

What specific property of the JLS requires that == not be always-false?

I.e., what is it in the JLS that requires that this loop ever terminate when there is no external interference by another thread?:

  // David Lloyd's example from earlier in the thread (Jul 6, 10:48AM PDT):
  AtomicReference<Instant> atomic;
  Instant a, b;
  ...
  do {
      a = atomic.get();
      b = compute(a);
  } while (! atomic.compareAndSet(a, b));


or for that matter, that this loop ever terminate when there is no external interference by another thread?:

  volatile Instant thing;
  Instant a, b;
  …
  boolean success = false;
  do {
      a = thing;
      b = compute(a);
      if (thing == a) {
          thing = b;
          success = true;      
      }
  } while (!success);

The termination of both of these loops relies on the notion of identity (the logical value of a reference) being preserved between the reading of a reference to an instance of a value-based class from memory, and the eventual comparison of that instance's reference with another one stored in a memory location.

I'm really asking… I'd love to find something in the JLS that says this must be preserved, and thereby contradict the statements that say that instances of value-based classes "are freely substitutable when equal" and "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects". 

I'd like to point out that Instant happens to be one of those cool ""partially compressible value" classes who's value cannot be fully represented with a single 64 bit value, but where "a wide and interesting range" of values can be: specifically, all the possible values of Instant between the epoch and some time in the year 2043 *can* be represented in 63 bits, making smalltalk-like inlined "it's not a pointer, it's a value" representations very possible (e.g. negative references are actual the values) and appealing for many reasons (both space and speed). This works as long as both identity and type can be erased from the contents without hurting computations [which can be done safely when stored in registers whose type is known, for example]. And this quality is specifically provided by the documentation of the type as a value-based class.

However, since it is possible for instances of Instant to be stored in locations that do not have this quality [e.g. Object fields, or even known-to-be-of-type-Instant fields in memory depending on implementation], each possible "compressible value" also needs a non-compressed representation in a heap-based object contents form. This means that the value in the memory location may be a true reference, while the value we read into local variables may not be, at least for a wide range of possible values. And that in turn means that the loops above will never terminate (since they will never be able to show that the reference contents of "atomic" or of "thing" is == to the value in a).

> 
> In the case of C, the thing to do would be to ask for a clarification,
> but I suspect that if we asked, say, John Rose, Alex Buckley, and
> Brian Goetz we'd get different answers.  ;-)
> 
> -- 
> Andrew Haley
> Java Platform Lead Engineer
> Red Hat UK Ltd. <https://www.redhat.com>
> EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671


From gil at azul.com  Sat Jul  8 09:17:24 2017
From: gil at azul.com (Gil Tene)
Date: Sat, 8 Jul 2017 13:17:24 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
Message-ID: <38767650-4AD7-4193-BBC4-A4B5F7A2DE21@azul.com>

With all this said (and I absolutely think that e.g. it should be expected that loops like my examples from the previous post may never terminate), this discussion has made me come up with a way to (I *think*) safely apply CAS to instances of Instant (and on any other instances that happen to be of value-based classes) as long as we code the CAS and the type it operates on carefully. I believe it is safe to do so as long as the field being CAS'ed into is declared as an Object and NOT as an Instant. By casting from Object to Instant to perform Instant operations [e.g. adding a duration] while preserving the Object form for the thing being compared in the CAS operation, I believe the CAS remains valid. See code below.

The reason that I believe this approach is inherently safe is that the contents of fields and local variables of type Object are [I think] required to retain identity-sensitive operation behaviors regardless of the actual (derived from Object) type of the current contents. The contents of fields and variables *known* to be of type Instant (and of other value-based classes that are inherited from Object) may lose identity information and produce unpredictable behaviors when used with identity-sensitive operations, based on the specification of the behaviors of value-based classes. However, this freedom to lose track of identity does not extend to fields and variables of type Object (or other non-value-based classes).

In effect, I believe that the JVM is required to "box" instances of value-based classes in actual object references to actual objects with actual identity when storing them in fields or variables of a type that is not a value-based class. And all identity-based operations done on those fields and variables remain as-expected regardless of whether or not the contents is a reference to an instance of a value-based class. This quality is lost once something is cast to a value-based class (for storage in either a variable or field). In back-and-forth casting (implicit or explicit), the identities of objects that are created by casting back to Object does not have to remain the same as the identities of the original Objects cast from to a value-based class.

[** in this logic, "field" includes an array element]

This also leads me to [partially] retract my suggestion for throwing exceptions when encountering identity-based operations on instances of value-based classes. Such exceptions clearly shouldn't be thrown when the declared types of the operands involved are not value-based classes (even if the contents is of those type). I still think that throwing exceptions when the declared types are value-based classes could make sense, but this can actually be done better by the Java compiler refusing to compile such code (and it should know enough to do that, since the types are declared).

Since Generics do reification, this stuff would be un-enforceable in the generics source code. But it can still be enforced in code that uses generics, e.g. a AtomicReference<Object>.compareAndSet() can still refuse [at compile time] to accept a declared-as-value-based-class type as it's "expected" parameter.

public class MutableClock {

    public static MutableClock create(final Instant instant, final ZoneId zone) {
        return new MutableClock(
                new AtomicReference<>(instant),
                zone);
    }

    // Instants are held in an Object field to allow identity-based CAS operations:
    private final AtomicReference<Object> instantHolder;
    private final ZoneId zone;

    private MutableClock(
            final AtomicReference<Object> instantHolder,
            final ZoneId zone) {
        this.instantHolder = instantHolder;
        this.zone = zone;
    }

    public Instant instant() {
        return (Instant) instantHolder.get();
    }

    public ZoneId getZone() {
        return zone;
    }

    public void setInstant(final Instant newInstant) {
        instantHolder.set(newInstant);
    }

    void add(Duration amountToAdd) {
        boolean success = false;
        do {
            Object currentContents = instantHolder.get();
            // ((Instant) currentContents) may have no identity, but currentContents does...
            Instant newInstant = ((Instant) currentContents).plus(amountToAdd);
            // Compare part of CAS would not be valid for an Instant field,
            // but is valid for an Object field:
            success = instantHolder.compareAndSet(currentContents, newInstant);
        } while (!success);

        // the above is equivalent to this, I believe:
        //   instantHolder.updateAndGet(instant -> ((Instant)instant).plus(amountToAdd));
    }

    public MutableClock withZone(final ZoneId newZone) {
        // conveniently, AtomicReference also acts as a
        // vehicle for "shared updates" between instances:
        return new MutableClock(instantHolder, newZone);
    }
}




On Jul 8, 2017, at 5:22 AM, Gil Tene <gil at azul.com<mailto:gil at azul.com>> wrote:


On Jul 8, 2017, at 1:19 AM, Andrew Haley <aph at redhat.com<mailto:aph at redhat.com>> wrote:

On 08/07/17 07:38, Gil Tene wrote:

My arguments here are not about trying to justify some compiler
optimizations, or trying to justify the choices of making these
things subclasses the Object. They are about pointing out the actual
meaning of things as defined and the (very high risk) of coding
against it based on a hope that some temporarily observed behavior
is actually reliable, when everything that describes what it does
says otherwise.

I disagree with this interpretation.  You're interpreting the language
in that paragraph as overriding some fundamental properties in the JLS.

To keep this to a simple case that

What specific property of the JLS requires that == not be always-false?

I.e., what is it in the JLS that requires that this loop ever terminate when there is no external interference by another thread?:

 // David Lloyd's example from earlier in the thread (Jul 6, 10:48AM PDT):
 AtomicReference<Instant> atomic;
 Instant a, b;
 ...
 do {
     a = atomic.get();
     b = compute(a);
 } while (! atomic.compareAndSet(a, b));


or for that matter, that this loop ever terminate when there is no external interference by another thread?:

 volatile Instant thing;
 Instant a, b;
 …
 boolean success = false;
 do {
     a = thing;
     b = compute(a);
     if (thing == a) {
         thing = b;
         success = true;
     }
 } while (!success);

The termination of both of these loops relies on the notion of identity (the logical value of a reference) being preserved between the reading of a reference to an instance of a value-based class from memory, and the eventual comparison of that instance's reference with another one stored in a memory location.

I'm really asking… I'd love to find something in the JLS that says this must be preserved, and thereby contradict the statements that say that instances of value-based classes "are freely substitutable when equal" and "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects".

I'd like to point out that Instant happens to be one of those cool ""partially compressible value" classes who's value cannot be fully represented with a single 64 bit value, but where "a wide and interesting range" of values can be: specifically, all the possible values of Instant between the epoch and some time in the year 2043 *can* be represented in 63 bits, making smalltalk-like inlined "it's not a pointer, it's a value" representations very possible (e.g. negative references are actual the values) and appealing for many reasons (both space and speed). This works as long as both identity and type can be erased from the contents without hurting computations [which can be done safely when stored in registers whose type is known, for example]. And this quality is specifically provided by the documentation of the type as a value-based class.

However, since it is possible for instances of Instant to be stored in locations that do not have this quality [e.g. Object fields, or even known-to-be-of-type-Instant fields in memory depending on implementation], each possible "compressible value" also needs a non-compressed representation in a heap-based object contents form. This means that the value in the memory location may be a true reference, while the value we read into local variables may not be, at least for a wide range of possible values. And that in turn means that the loops above will never terminate (since they will never be able to show that the reference contents of "atomic" or of "thing" is == to the value in a).


In the case of C, the thing to do would be to ask for a clarification,
but I suspect that if we asked, say, John Rose, Alex Buckley, and
Brian Goetz we'd get different answers.  ;-)

--
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170708/ecfb31af/attachment-0001.html>

From gergg at cox.net  Sat Jul  8 17:14:14 2017
From: gergg at cox.net (Gregg Wonderly)
Date: Sat, 8 Jul 2017 16:14:14 -0500
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <hZPU1v01T02hR0p01ZPW6E>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com>
 <E35C2D88-13A4-4C4E-85F9-D5B6902C9046@azul.com>
 <0983AEC3-BB6C-42CB-9B7C-B2F31F7AF3AF@gmail.com> <hZPU1v01T02hR0p01ZPW6E>
Message-ID: <2C25A467-C279-491D-8CDA-D0CDA415FEE1@cox.net>

You are talking about a different language than Java then.   Identity vs equality is everywhere in my code.  I use both to do exactly what I mean.  Identity is the same instance that I created and referenced somewhere.  Equals is contains the same value.  There is a big different between is the same object and contains the same values.

Gregg

> On Jul 6, 2017, at 4:23 PM, Gil Tene <gil at azul.com> wrote:
> 
> 
>> On Jul 6, 2017, at 1:09 PM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>> 
>> :-) It’s NaN, but for the objects.
>> 
> 
> Well put. And a very good analogy. The identity of an instance of a value-based classes may act like a NaN at any time. And x == x is false when x is a NaN...
> 
>> Using “equals” is just as ugly. It has completely different semantics.
> 
> 
>> 
>> equality
>> equivalence
>> homotopy
> 
> And == for objects (which means "same identity") is [I believe] different from all of the above.
> 
> Alas, we don't have a well established meaning for .equivalent() in Java.
> 
>> 
>> all talk about sameness of things. I would tell the “it’s not as horrifying” crowd that it is absolutely wrong to force me to use equivalence where I mean equality. That’s the horrifying thing.
>> 
>> It’s not “more correct” to use “equals()” instead of “==“. Because it is not an optimisation, it just has a different meaning. Optional(x).equals(Optional(y)), if x.equals(y), but it doesn’t mean I don’t care which one is referenced - exactly because x and y do have identities.
> 
> Agreed.
> 
> Alas, being immutable and non-constrictble (created only by factories) doesn't actually mean non-null everywhere… Super-annoyingly, it is perfectly "valid" (as in will compile and run something) to pass a null argument when an Optional is expected… 
> 
> Interesting mention of "nullability": http://mail.openjdk.java.net/pipermail/valhalla-dev/2015-January/000555.html , and a discussion of the subject in general (with some good links) here: https://blog.codefx.org/java/value-based-classes/ . I especially like the specific quotes from sources:
> 
> -  "Optional is new, and the disclaimers arrived on day 1. Integer, on the other hand, is probably hopelessly polluted, and I am sure that it would break gobs of important code if Integer ceased to be lockable (despite what we may think of such a practice.)"
> 
> - "In Java 8 value types are preceded by value-based classes. Their precise relation in the future is unclear but it could be similar to that of boxed and unboxed primitives (e.g. Integer and  int). Additionally, the compiler will likely be free to silently switch between the two to improve performance. Exactly that switching back and forth, i.e. removing and later recreating a reference, also forbids identity-based mechanisms to be applied to value-based classes."
> 
> removing and later recreating a reference…. That's certainly in the cars.
> 
> 
>> 
>> 
>> There is sense in having a concept of a class whose objects convey no meaning except the existence of extra structure with its own virtual method table around some other values. But language needs support for safe use of them.
>> 
>> 
>> Alex
>> 
>>> On 6 Jul 2017, at 20:12, Gil Tene <gil at azul.com> wrote:
>>> 
>>> The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.
>>> 
>>> The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...
>>> 
>>> — Gil.
>>> 
>>>> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>>> 
>>>> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
>>>> 
>>>> -Justin
>>>> 
>>>> 
>>>> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
>>>> 
>>>> We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
>>>> 
>>>> To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>>>> - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>>>> - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
>>>> 
>>>> This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
>>>> 
>>>> Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
>>>> 
>>>> In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
>>>> 
>>>> Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
>>>> 
>>>> Sent from my iPad
>>>> 
>>>>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>>>> 
>>>>> Howdy,
>>>>> 
>>>>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>>>>> 
>>>>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>>>>> 
>>>>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>>>>> 
>>>>> Cheers,
>>>>> Justin
>>>>> 
>>>>> 
>>>>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>>>>> 
>>>>> Forwarding this reply of mine because I forgot to CC the mailing list.
>>>>> 
>>>>> 
>>>>> ---------- Forwarded message ----------
>>>>> From: Michael Hixson <michael.hixson at gmail.com>
>>>>> Date: Thu, Jul 6, 2017 at 7:24 AM
>>>>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>>>> value-based classes?
>>>>> To: Andrew Haley <aph at redhat.com>
>>>>> 
>>>>> 
>>>>>>>> On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>>>>> 
>>>>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>>>>> 
>>>>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>>>>> instances of value-based classes?
>>>>>>>>> 
>>>>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>>>>> value for example?
>>>>>>>> 
>>>>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>>>>> that instances which compare equal also have the property of
>>>>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>>>>> help.
>>>>>>> 
>>>>>>> That’s not entirely clear.
>>>>>>> 
>>>>>>> Wouldn’t this loop work:
>>>>>>> 
>>>>>>> volatile j.t.Instant curr = ...
>>>>>>> 
>>>>>>> j.t.Instant next = …
>>>>>>> j.t.Instant tmp = ...
>>>>>>> do {
>>>>>>> tmp = curr;
>>>>>>> if (tmp.equal(next)) break;
>>>>>>> } while(!curr.CAS(tmp, next));
>>>>>>> 
>>>>>>> // assume curr is equal to next
>>>>>> 
>>>>>> Something like that, yes.  But it's going to be evil if there are
>>>>>> several high-frequency writers.  If you're doing all that work in
>>>>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>>>>> at least be less prone to the thundering herd, and we'd generate
>>>>>> pretty decent code for that.  It'd be interesting to compare and
>>>>>> contrast the two approaches for contended and non-contended cases.
>>>>> 
>>>>> The main reason I reached for AtomicReference is that I thought, "I
>>>>> want thread-safe updates to this read-heavy value where writes won't
>>>>> get lost if there's contention -- this sounds like the sort of problem
>>>>> that java.util.concurrent.atomic solves."
>>>>> 
>>>>> As a minor point, I wanted synchronization on reads to be as
>>>>> minor/invisible as possible, to affect the readers' behavior as little
>>>>> as possible (in comparison to their behavior when the value they're
>>>>> reading a constant value with no synchronization).
>>>>> 
>>>>> But if AtomicReference is simply the wrong tool to use here, I
>>>>> shouldn't use it.  That's fine.
>>>>> 
>>>>>> 
>>>>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>>>>> 
>>>>>>> This is confusing.
>>>>>>> 
>>>>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>>>>> the object can’t be assumed to have any atomicity properties,
>>>>>>> whether it is j.t.Instant or not.
>>>>>> 
>>>>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>>>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>>>>> able to CAS an instance of j.u.Instant.
>>>>> 
>>>>> It was more of a general worry and question.  Should I ever use
>>>>> AtomicReference with value-based classes?  It sounds like the answer
>>>>> is no.
>>>>> 
>>>>> But here's some code that illustrates the specific problem I was
>>>>> trying to solve.  I think it "works" right now, but that it's in
>>>>> violation of the spec for value-based classes and so possibly not
>>>>> future-proof, and I think I understand how to fix it now.  Thanks for
>>>>> the tips.
>>>>> 
>>>>>  class MutableClock {
>>>>> 
>>>>>      static MutableClock create(Instant instant, ZoneId zone) {
>>>>>          return new MutableClock(
>>>>>                  new AtomicReference<>(instant),
>>>>>                  zone);
>>>>>      }
>>>>> 
>>>>>      private final AtomicReference<Instant> instantHolder;
>>>>>      private final ZoneId zone;
>>>>> 
>>>>>      private MutableClock(
>>>>>              AtomicReference<Instant> instantHolder,
>>>>>              ZoneId zone) {
>>>>>          this.instantHolder = instantHolder;
>>>>>          this.zone = zone;
>>>>>      }
>>>>> 
>>>>>      Instant instant() {
>>>>>          return instantHolder.get();
>>>>>      }
>>>>> 
>>>>>      ZoneId getZone() {
>>>>>          return zone;
>>>>>      }
>>>>> 
>>>>>      void setInstant(Instant newInstant) {
>>>>>          instantHolder.set(newInstant);
>>>>>      }
>>>>> 
>>>>>      void add(Duration amountToAdd) {
>>>>>          // this is the part that uses == and CAS
>>>>>          instantHolder.updateAndGet(
>>>>>                instant -> instant.plus(amountToAdd));
>>>>>      }
>>>>> 
>>>>>      MutableClock withZone(ZoneId newZone) {
>>>>>          // conveniently, AtomicReference also acts as a
>>>>>          // vehicle for "shared updates" between instances
>>>>>          // of my class
>>>>>          return new MutableClock(instantHolder, newZone);
>>>>>      }
>>>>>  }
>>>>> 
>>>>> -Michael
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>> 
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gergg at cox.net  Sat Jul  8 17:14:17 2017
From: gergg at cox.net (Gregg Wonderly)
Date: Sat, 8 Jul 2017 16:14:17 -0500
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <hXCW1v01D02hR0p01XCZKb>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <0b1c5f0d-8c2e-8903-615b-626d9aecf0ce@redhat.com>
 <7D3F4D4B-9CF1-4117-BAC2-23B74555A206@gmail.com>
 <455a1500-7fa9-3819-4adc-965baa06b608@redhat.com>
 <CAHqckpP4EuFU9XR0cF1RWqVH2Os5AOr3w+gFr_kJijnt=Dd6rw@mail.gmail.com>
 <CAHqckpO+7xjiYKim7-A4L9KgMA53YPHwiBaffqcZ1UPOPH=VXQ@mail.gmail.com>
 <3FA2E9A4-9099-445C-A9AC-99E54FC8FED0@guidewire.com>
 <A07B42D7-8CFF-47DE-99BF-77838C8AC535@azul.com>
 <CE278028-13D1-4AC2-BFB8-21099E09EF28@guidewire.com> <hXCW1v01D02hR0p01XCZKb>
Message-ID: <03646B02-7E94-4830-8DD7-17F005DB6F2A@cox.net>

So you are suggesting that I can’t create two different Instant objects and compare them with identity == on a third object which references one of those instances as a form of decision logic?   Why in the world would you want to break Java in that way?

Gregg


> On Jul 6, 2017, at 2:12 PM, Gil Tene <gil at azul.com> wrote:
> 
> The "it's not as horrifying as you might think" crowd (which I'm not sure I'm part of or not) would argue that the worries are overblown. Yes, one "instance" can be freely replaced by another at any point, without you knowing about it. But why would you care? Howe would you be able to tell? If you properly avoid using identity operations (which you were told not to), where is the problem? The objects are immutable, so proper equality testing will never get you the "wrong" logical behavior.
> 
> The answer to this is generally "But… concurrency!". Which is why this is an ok place to chat about it probably. With no identity, how do you achieve atomic updates? Michael's MutableClock example (scroll down) of wanting to (potentially concurrently) add duration amounts to some notion of a point in time, while avoiding the potential for "losing" an add racy situations, requires some sort of synchronization. Since Instant is not mutable, and we are necessarily trying to atomically replace one Instant value with another, we have a problem with the notion that these values have no identity (and therefore no way to do a proper CAS on). We are also specifically admonished to not do any synchronization on "instances" of such classes, which should serious dissuade one from trying. Boxing is *an* answer (put the value in an instance that has a proper identity, and then CAS the identity), but a seemingly unsatisfying one...
> 
> — Gil.
> 
>> On Jul 6, 2017, at 11:47 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>> 
>> That is absolutely horrifying, and leads me to believe we should not use such "value-based" classes at all in our code. Off I go to find a list of them and forbid them in my codebase. Somehow I thought that I was relatively up-to-date on my Java knowledge and this is the very first time I'm hearing about them. Surely the vast majority of Java programmers are similarly unaware, and the idea that an object instance can actually be replaced by another object instance at runtime is beyond surprising.
>> 
>> -Justin
>> 
>> 
>> On 7/6/17, 10:49 AM, "Gil Tene" <gil at azul.com> wrote:
>> 
>> We are not discussing the upcoming value types. We are discussing the value-based classes as currently spec'ed in Java SE 8. Instant is a good example of such a class.
>> 
>> To give you a feel for a currently valid (and may soon occur) optimization in Java 8: The current spec'ed behavior for Instant makes it possible to "inline" instances of Instant into their containing objects (which refer to them with mutable fields):
>> - There are no valid identity operations on Instant, so assignment can be validly done by copying contents onto the inlined version. A "get" of an inlined instance (where it can't be escape analyzed away) can be performed by returning a new (and different) instance of Instant.
>> - Word-tearing on value assignment [e.g. myClock.setInstsnt(Instant.now()))] can be avoided at least on some platforms, e.g. with 16-byte atomic operations, where the state of Instant instances can be represented in 16 bytes or less.
>> 
>> This can then result in an elimination of a dereferencing operation when e.g. accessing someClock.getInstant().getNano(). (and no new instance will be created).
>> 
>> Now the specific generics based containment below [AtomicReference<Instant>] may seem a bit more "challenging" (and likely will happen much later than in the non generic cases), but given the fact that the AtomicReference instance use is local to the MutableClock class and private, and no instances of that AtomicReference are exposed elsewhere, it would be valid to transform this code to use some custom subclass of AtomicReference that had  an Instant instance inlined in it. At that point, the updateAndGet operation comes into play. It may have "interesting" behavior because it is identity based, or (more likely) its existence could just prevent the whole optimization from occurring.
>> 
>> In any case, to keep to well specified behavior, I'd box the Instant when putting it in an AtomicReference. That will provide you with a safe concurrent add() that doesn't use identity on Instant. You can probably do some simple caching on the get for speed (hold a cachedInstant field and a valid flag, re-read from boxed contents whenever invalid) with an invalidation (set invalid after each modification of the boxed contents) in set() and add().
>> 
>> Oh, and BTW, you should probably check for null and enforce non-null for all incoming Instance arguments, e.g. in the constructor and in setInstance(). 
>> 
>> Sent from my iPad
>> 
>>> On Jul 6, 2017, at 9:01 AM, Justin Sampson <jsampson at guidewire.com> wrote:
>>> 
>>> Howdy,
>>> 
>>> This thread got sidetracked with discussion of the upcoming "value types" in some later version of the JDK, which don't exist yet in 8, and really aren't relevant at all to Michael's question. He's asking about the existing Instant class, which is simply an immutable object with an equals() that compares its contents.
>>> 
>>> It's absolutely silly to suggest that AtomicReference "doesn't work" for things like Instant. It simply uses identity instead of equals() in its operations, which is entirely well-defined.
>>> 
>>> Michael's example MutableClock will work just fine. It uses updateAndGet(), which CAS's the result of the update. The point of the CAS is merely to check whether another thread has updated the reference concurrently, for which identity works correctly. The update is retried if the CAS fails, so there's no problem introduced by the fact that equals() for the value is different from equality.
>>> 
>>> Cheers,
>>> Justin
>>> 
>>> 
>>> On 7/6/17, 7:31 AM, "Concurrency-interest on behalf of Michael Hixson" <concurrency-interest-bounces at cs.oswego.edu on behalf of michael.hixson at gmail.com> wrote:
>>> 
>>> Forwarding this reply of mine because I forgot to CC the mailing list.
>>> 
>>> 
>>> ---------- Forwarded message ----------
>>> From: Michael Hixson <michael.hixson at gmail.com>
>>> Date: Thu, Jul 6, 2017 at 7:24 AM
>>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>>> value-based classes?
>>> To: Andrew Haley <aph at redhat.com>
>>> 
>>> 
>>>>>> On Thu, Jul 6, 2017 at 4:20 AM, Andrew Haley <aph at redhat.com> wrote:
>>>>>>> On 06/07/17 11:41, Alex Otenko wrote:
>>>>>> 
>>>>>> On 6 Jul 2017, at 10:13, Andrew Haley <aph at redhat.com> wrote:
>>>>>> 
>>>>>> On 06/07/17 04:59, Michael Hixson wrote:
>>>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>>>> (and related) operations [1].  Using == to compare instances of
>>>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>>>> instances of value-based classes?
>>>>>>> 
>>>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>>>> value for example?
>>>>>> 
>>>>>> java.time.Instant stores times that are longer than a JVM word, so
>>>>>> they cannot be CAS'd in a lock-free way unless a factory guarantees
>>>>>> that instances which compare equal also have the property of
>>>>>> reference equality.  j.t.Instant factories in the Java library are
>>>>>> explicitly documented *not* to have this property, so that doesn't
>>>>>> help.
>>>>> 
>>>>> That’s not entirely clear.
>>>>> 
>>>>> Wouldn’t this loop work:
>>>>> 
>>>>> volatile j.t.Instant curr = ...
>>>>> 
>>>>> j.t.Instant next = …
>>>>> j.t.Instant tmp = ...
>>>>> do {
>>>>> tmp = curr;
>>>>> if (tmp.equal(next)) break;
>>>>> } while(!curr.CAS(tmp, next));
>>>>> 
>>>>> // assume curr is equal to next
>>>> 
>>>> Something like that, yes.  But it's going to be evil if there are
>>>> several high-frequency writers.  If you're doing all that work in
>>>> order to CAS a timestamp, why not use a synchronized block?  It would
>>>> at least be less prone to the thundering herd, and we'd generate
>>>> pretty decent code for that.  It'd be interesting to compare and
>>>> contrast the two approaches for contended and non-contended cases.
>>> 
>>> The main reason I reached for AtomicReference is that I thought, "I
>>> want thread-safe updates to this read-heavy value where writes won't
>>> get lost if there's contention -- this sounds like the sort of problem
>>> that java.util.concurrent.atomic solves."
>>> 
>>> As a minor point, I wanted synchronization on reads to be as
>>> minor/invisible as possible, to affect the readers' behavior as little
>>> as possible (in comparison to their behavior when the value they're
>>> reading a constant value with no synchronization).
>>> 
>>> But if AtomicReference is simply the wrong tool to use here, I
>>> shouldn't use it.  That's fine.
>>> 
>>>> 
>>>>>> If you want to be able to CAS a reference to a j.t.Instant, you're
>>>>>> going to have to wrap accesses to it in a synchronized block.  This is
>>>>>> a direct consequence of the JVM's inability to CAS multi-word objects.
>>>>> 
>>>>> This is confusing.
>>>>> 
>>>>> Surely this isn’t talking about CASing a reference? The contents of
>>>>> the object can’t be assumed to have any atomicity properties,
>>>>> whether it is j.t.Instant or not.
>>>> 
>>>> I agree.  I'm trying to look at what the OP actually wants to do: I
>>>> assume this is some kind of atomic timestamp, and the OP wants to be
>>>> able to CAS an instance of j.u.Instant.
>>> 
>>> It was more of a general worry and question.  Should I ever use
>>> AtomicReference with value-based classes?  It sounds like the answer
>>> is no.
>>> 
>>> But here's some code that illustrates the specific problem I was
>>> trying to solve.  I think it "works" right now, but that it's in
>>> violation of the spec for value-based classes and so possibly not
>>> future-proof, and I think I understand how to fix it now.  Thanks for
>>> the tips.
>>> 
>>>   class MutableClock {
>>> 
>>>       static MutableClock create(Instant instant, ZoneId zone) {
>>>           return new MutableClock(
>>>                   new AtomicReference<>(instant),
>>>                   zone);
>>>       }
>>> 
>>>       private final AtomicReference<Instant> instantHolder;
>>>       private final ZoneId zone;
>>> 
>>>       private MutableClock(
>>>               AtomicReference<Instant> instantHolder,
>>>               ZoneId zone) {
>>>           this.instantHolder = instantHolder;
>>>           this.zone = zone;
>>>       }
>>> 
>>>       Instant instant() {
>>>           return instantHolder.get();
>>>       }
>>> 
>>>       ZoneId getZone() {
>>>           return zone;
>>>       }
>>> 
>>>       void setInstant(Instant newInstant) {
>>>           instantHolder.set(newInstant);
>>>       }
>>> 
>>>       void add(Duration amountToAdd) {
>>>           // this is the part that uses == and CAS
>>>           instantHolder.updateAndGet(
>>>                 instant -> instant.plus(amountToAdd));
>>>       }
>>> 
>>>       MutableClock withZone(ZoneId newZone) {
>>>           // conveniently, AtomicReference also acts as a
>>>           // vehicle for "shared updates" between instances
>>>           // of my class
>>>           return new MutableClock(instantHolder, newZone);
>>>       }
>>>   }
>>> 
>>> -Michael
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gergg at cox.net  Sun Jul  9 19:10:20 2017
From: gergg at cox.net (Gregg Wonderly)
Date: Sun, 9 Jul 2017 18:10:20 -0500
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <hZWU1v01Y02hR0p01ZWW1a>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com> <hZWU1v01Y02hR0p01ZWW1a>
Message-ID: <60A98D66-4F13-4E14-B208-84E49AA6C00B@cox.net>

Factories have the right to decide which instance to return, but once I have an instance, identity should still apply from that point forward.  A developer will read some documentation about random return values, but you are talking about a new language if a reference ever changes identity in Java.

Gregg

> On Jul 6, 2017, at 4:29 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
> 
> Given:
> 
> Instant i1 = Instant.ofEpochMilli(2);
> Instant i2 = Instant.ofEpochMilli(2);
> 
> In Java 8:
> 
> i1.equals(i2) is true
> i1 == i2  is false
> 
> And in some future version, i1 == i2  might be true.
> 
> But this is not especially radical. Java 10 could introduce a cache in
> the factory method that always returns the same instance. In fact,
> there already is a cache if you call
> Instant.ofEpochMilli(0);
> 
> The key phrase in
> http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
> is "A program may produce unpredictable results if it attempts to
> distinguish two references to equal values of a value-based class".
> IMO, the intent is to tell everyone that they shouldn't try to tell
> the difference between two instances using ==, and if they do their
> program may change meaning in the future (ie. be unpredictable, but
> not stupidly unpredictable as some in the thread are suggesting).
> 
> Stephen
> 
> 
> On 6 July 2017 at 17:33, Gil Tene <gil at azul.com> wrote:
>> 
>> It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen".
>> 
>> Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.
>> 
>> For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).
>> 
>> We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.
>> 
>> It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.
>> 
>> For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.
>> 
>> One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...
>> 
>> This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.
>> 
>> Sent from my iPad
>> 
>> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>> 
>> :-) the one causing Byzantine failures!
>> 
>> Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.
>> 
>> All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).
>> 
>> 
>> Alex
>> 
>> 
>> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com> wrote:
>> 
>> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
>> n  Sebastian
>> 
>> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Alex Otenko
>> Sent: Thursday, July 06, 2017 10:17 AM
>> To: Gil Tene
>> Cc: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>> 
>> 
>> 
>> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com> wrote:
>> 
>> 
>> 
>> Sent from my iPad
>> 
>> 
>> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
>> 
>> All it is saying is:
>> 
>> LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>> LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>> LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>> 
>> a==b && b==c can be true and can be false
>> 
>> 
>> It also means that even when:
>> 
>> LocalDateTime d = a;
>> ...
>> (a == d) may or may not be true. And may change whether it is true or not at any time,
>> 
>> 
>> I meant an even stronger assertion:
>> 
>> assert (a==b) == (b==a) : "No Byzantine optimizations"
>> assert (a==d) == (a==d): “No Byzantine optimizations"
>> 
>> Alex
>> 
>> 
>> 
>> 
>> 
>> 
>> Alex
>> 
>> 
>> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com> wrote:
>> 
>> 
>> 
>> Sent from my iPad
>> 
>> 
>> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com> wrote:
>> 
>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content.
>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>> 
>> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>> 
>> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>> int a = 5;
>> int b = 5;
>> boolean y = (a == b);  // true
>> 
>> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>> Integer a = new Integer(5);
>> Integer b = new Integer(5);
>> boolean x = a.equals(b);   // true
>> boolean y = (a == b);   // false
>> 
>> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>> 
>> LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>> LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>> boolean x = a.equals(b);   // true
>> boolean y = (a == b);   // unpredictable, undefined, who knows.
>>                                       // Could be true, could be false.
>>                                       // Could theoretically change the values of a or b, or of something else
>> 
>> 
>> 
>> 
>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com> wrote:
>> 
>> 
>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>> 
>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>> For example:
>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>> 
>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>> 
>> — Gil.
>> 
>>> On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com> wrote:
>>> 
>>> I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>>> 
>>> By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>>> 
>>> If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>>> 
>>> 
>>> On 2017-07-05 09:20 PM, Gil Tene wrote:
>>>> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>>> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>>> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>>> — Gil.
>>>>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com> wrote:
>>>>> 
>>>>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>> (and related) operations [1].  Using == to compare instances of
>>>>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>> this mean I should avoid using compareAndSet with arguments that are
>>>>> instances of value-based classes?
>>>>> 
>>>>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>> value for example?  Do I have to box the value in something that's not
>>>>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>>> 
>>>>> -Michael
>>>>> 
>>>>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>>>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> 
>> 
>> 
>> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From gergg at cox.net  Sun Jul  9 19:10:35 2017
From: gergg at cox.net (Gregg Wonderly)
Date: Sun, 9 Jul 2017 18:10:35 -0500
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <hVsz1v01i02hR0p01Vt4JL>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com> <hVsz1v01i02hR0p01Vt4JL>
Message-ID: <E743F36D-E587-46DD-82F7-717D291298A9@cox.net>

Anything that is a Number should be performing automatic unboxing to perform literal value comparisons.  I count on this day in and day out.  There is no reason that Number values should ever do anything different.   You can suggest that two Number values which might be typed as Object parameters into a code structure that compares them with ==, will be costly to execute because of runtime type checking.  But, if the developer codes it that way, because they have other Object values which are used in identity comparisons that are logically valid for the code structure, why perform a compile time optimization that invalidates the premise of how identity works against auto-boxing/unboxing?

Gregg

> On Jul 6, 2017, at 12:52 PM, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
> 
> Hence my suggestion that identity-based operations on instances of value-based classes should throw exceptions... Right now they silently do unpredictable things, and should be avoided in any case (but harder to know/find when you accidentally use them).
> 
> Sent from my iPad
> 
> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> 
>> Are they subclasses of Object or not? If they are not, no questions. If they are, someone still needs to explain how exactly the “identity based operations” can be avoided safely.
>> 
>> List<j.u.Optional> is just a List underneath, and searching for an item may use “identity based operations”, whether you want it or not - depending on what implementation of List you happen to use.
>> 
>> Alex
>> 
>>> On 6 Jul 2017, at 17:33, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>> 
>>> It says: "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided." It does not say what the reason for  the unpredictable effect may be and WHEN you shouldn't use identity based operations, it warns you not to use them for any reason whatsoever. Can't be much more clear than that, and you don't need to be a JVM or compiler implementor to understand it. It means "don't do that". And "if you do that, very surprising things may (or may not) happen". 
>>> 
>>> Acting on a current understanding and perception of what implementations actually do, and saying "I thought that what it really means is that using identity in some way X would be unreliable because of effect Y, but using identity in case Z is ok, because I don't see why it shouldn't be" is a wrong reading of this clear admonition to not use identity for anything. Doing so will come back to bite you, either now or in the future.
>>> 
>>> For example, instances of value-based classes have the [well documented] quality of being "freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior." The JVM may (and likely will at some point will) use this quality freely in some optimizations, A simple and obviously valid resulting optimization would be for == to always be evaluated as false when the operands are instances of value-based classes: since the JVM *may* freely substitute the instances of either side of the == evaluation with some instance that is equal according to equals(), it can choose to do so in all evaluations of ==, which would mean that the two sides are never the same instance, and would then mean that the JVM can treat all code that would only execute if == were true as dead code. Similarly, != may trivially be evaluated as always-true. And since these optimizations may or may not be applied in different places and times, they may lead to seemingly random evaluation of == or != for identical code on identical data (for the exact same, unmodified values of a and d, a will sometimes be equal to d and sometimes not, and at the same point in code, depending on mood).
>>> 
>>> We could further discuss whether or not the JVM is allowed to "falsely" indicate that == is true (or that != is false) even when the instances differ in value (so are not .equals()). It is. Doing that may certainly surprise anyone who uses the identity based == for anything to do with instances of value-based classes, even tho using it would be silly given that == might obviously be always-false. For example, I could see how someone may mistakenly try to use == as an "optimization" on the assumption that if they get lucky and == is true, .equals() must be true as well, and that evaluating == might be cheaper, but they would still "do the right thing" in the != case. But that would be a mistake, and a clear violation of the "don't do that" admonition above. The cases where the result of == can be *unpredictable* are not limited to cases where the JVM freely substitutes instances for other equal() ones, that's just one example of how the JVM may obviously and validly use one known quality of value-based classes. But another key quality of instances of value based classes is that they "are considered equal solely based on equals(), not based on reference equality (==)". There is nothing there that limits us to "if == is true, equals() must be true as well". It may be convenient to think otherwise when wanting to explain how breaking the rules in some specific way is still ok (and currently seems to work). But it's not. Bottom line: The JVM *may* choose to make == always-true. Nothing wrong with that.
>>> 
>>> It is dangerous (and nearly impossible) to deduce which optimizations may or may not happen when they are clearly allowed by the specified set of rules and qualities. The defined qualities are what matter, and optimizations that indirectly result from the propagation of those qualities are allowed and may (or may  not) happen. Instance identity either exists or doesn't, and instance Identity checks either have meaning, or they don't. If they do, certain things follow (like .equals() always being true if the identity of the twin instances is the same, as tested by ==). If they don't, then identity checks are meaningless, and can be discarded or conveniently evaluated in ways that seem profitable.
>>> 
>>> For "instances" of value-based classes, instance identity does not exist. Unfortunately, unlike value types, where the operand == is defined to act on value and not on identity, the operand == is undefined for instances of value-based classes. It certainly does not mean "if true, the identity of these things is the same", and it certainly doesn't mean "if false, these things are not equal". But it also doesn't mean "if true, these things are equal". It is *undefined*, specified with "may have unpredictable effects", and users are clearly told not to use it for anything.
>>> 
>>> One can argue that the spec should change, e.g. add a statement that would have the effect of requiring "if == is true then .equals() is also true", and would prevent or limit certain  unpredictable effects when considering the identity of identity-less things, but I suspect that writing that down in actual words would be painful given the necessary "there is no meaning to identify, but..." logic. We could also look to redefine the meaning of certain operands, e.g. == and != can be dealt with as they are in value types, but compare in compareAndSet is more challenging...
>>> 
>>> This is [partly] why I think that throwing an exception (or even a compile-time error where possible) when encountering == or != operations (and any of the other undefined behavior ones) on instances of value-based classes is a good idea, and something that should start happening ASAP. Any such operation is wrong (literally) by definition, and the "may have unpredictable effects" statement in the spec is certainly wide enough to allow exception throwing. It is wide enough to allow much worse things to happen, and silent unpredictable and undefined behavior, while allowed, is worse than preventing the code from executing. The same way we wouldn't argue that synchronized(int) should simply be "undefined" but silently allowed to run with unpredictable effects, we shouldn't argue that synchronized(LocalDateTime) should.
>>> 
>>> Sent from my iPad
>>> 
>>> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>> 
>>>> :-) the one causing Byzantine failures!
>>>> 
>>>> Given how underspecified the things generally are, and that the target audience of such javadoc is not a JVM implementor, we shouldn’t read too much into the possible freedoms the vague wording seems to imply. It shouldn’t suddenly break the promises about identity equality for specific instances.
>>>> 
>>>> All it’s saying is that, like Integer.from(10) may or may not return the same instance. It may or may not work the same way throughout the JVM’s lifetime, allowing the implementors to choose suitable caching strategies, code optimizations, etc - therefore should not rely on comparing identities, and such; for example, synchronized(Integer.from(10)) does not guarantee neither lock freedom, nor deadlock freedom. It should not say that suddenly it is unsafe to compare identities (like Gil suggests JVM could start throwing exceptions). It should not say that suddenly we shouldn’t be able to CAS (like Gil says suddenly the reference to instance can sneakily be replaced with something else).
>>>> 
>>>> 
>>>> Alex
>>>> 
>>>> 
>>>>> On 6 Jul 2017, at 10:12, Millies, Sebastian <Sebastian.Millies at softwareag.com <mailto:Sebastian.Millies at softwareag.com>> wrote:
>>>>> 
>>>>> just out of curiosity: I am familiar with the term “Byzantine failure”, but what is a “Byzantine optimization”?
>>>>> n  Sebastian
>>>>>  
>>>>> From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Alex Otenko
>>>>> Sent: Thursday, July 06, 2017 10:17 AM
>>>>> To: Gil Tene
>>>>> Cc: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
>>>>> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>>>>>  
>>>>>  
>>>>> On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>>>  
>>>>> 
>>>>> 
>>>>> Sent from my iPad
>>>>> 
>>>>> On Jul 6, 2017, at 12:38 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>>>> 
>>>>> All it is saying is:
>>>>>  
>>>>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>   LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>  
>>>>> a==b && b==c can be true and can be false
>>>>>  
>>>>> It also means that even when:
>>>>>  
>>>>>   LocalDateTime d = a;
>>>>>   ...
>>>>>   (a == d) may or may not be true. And may change whether it is true or not at any time,
>>>>>  
>>>>> I meant an even stronger assertion:
>>>>>  
>>>>> assert (a==b) == (b==a) : "No Byzantine optimizations"
>>>>> assert (a==d) == (a==d): “No Byzantine optimizations"
>>>>>  
>>>>> Alex
>>>>>  
>>>>> 
>>>>> 
>>>>>  
>>>>>  
>>>>> Alex
>>>>>  
>>>>> On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>>>  
>>>>> 
>>>>> 
>>>>> Sent from my iPad
>>>>> 
>>>>> On Jul 5, 2017, at 11:51 PM, Henrik Johansson <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
>>>>> 
>>>>> Oh, without having followed the value type discussions I think it was a mistake to not "fix" equality. Why not make it a deep comparison if the reference is different? If it points to the same object we are done otherwise start checking the struct content. 
>>>>> There may be a lot I missed here but a new type of object could be allowed to have different meaning equality. Right?
>>>>> .equals() means what you want it to mean. == and != (and the compare in compareAndSet) mean very specific things, and cannot be overridden.
>>>>>  
>>>>> For non-reference value types (int, long, char, etc.), == and != are value comparisons. An int has no identity. Just a value:
>>>>>   int a = 5;
>>>>>   int b = 5;
>>>>>   boolean y = (a == b);  // true
>>>>>  
>>>>> For references to instances of (non value-based) classes, == and != can be thought of as comparing the value of the reference (and not the contents of the object instances). This is an identity comparison, which ignores values within the object:
>>>>>   Integer a = new Integer(5);
>>>>>   Integer b = new Integer(5);
>>>>>   boolean x = a.equals(b);   // true
>>>>>   boolean y = (a == b);   // false
>>>>>  
>>>>> And for references to value-based classes (which is a relatively new thing, but is part of Java 8), the meaning of == and != appears to be undefined. E.g.:
>>>>>  
>>>>>   LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>   LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>   boolean x = a.equals(b);   // true
>>>>>   boolean y = (a == b);   // unpredictable, undefined, who knows. 
>>>>>                                          // Could be true, could be false.
>>>>>                                          // Could theoretically change the values of a or b, or of something else
>>>>>  
>>>>> 
>>>>> 
>>>>>  
>>>>> On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com <mailto:gil at azul.com>> wrote:
>>>>> 
>>>>> I'd take that documentation seriously. It basically says that ==, !=, synchronization, identity hashing, and serialization are undefined behaviors.
>>>>> 
>>>>> While the *current* implementations may carry some semi-intuitive behvaiors, e.g. where == indicates true when comparing two references to instances of a value-based class where the value of the references is the same, there is no guarantee that at some point in the [near or far] future that behavior will remain. Specifically, attempting == (or !=, or synchronization, etc., including compareAndSet) on a reference to a value based class is allowed to do ANYTHING in the future.
>>>>> For example:
>>>>> - It may throw an exception (something it should probably start doing ASAP to avoid future surprises).
>>>>> - It may return always-false, even when the two references are "to the same instance" (and probably will, through many possible value-based compiler optimizations that will erase the unneeded notion of reference and identity).
>>>>> - It may overwrite random locations in memory or to variables that the code performing the operation has the privilege to write to (which it probably shouldn't, but that's certainly included in what "undefined" and "unpredictable effects" can mean).
>>>>> - It may sometimes do one of the above, and sometimes seem to be doing what you mean it to do. Switching between modes on a whim (e.g. when a tier 2 optimizing compilation is applied, or when the mutton is nice and lean and the tomato is ripe).
>>>>> 
>>>>> So no, there is no way for compareAndSet to work "correctly" on a reference to an instance of a value-based class. Even if it happens to appear to work "correctly" now, expect it to blow up in bad and potentially silent ways in the future.
>>>>> 
>>>>> — Gil.
>>>>> 
>>>>> > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>>>>> >
>>>>> > I think the wording in the value-based document is too strong. It's perfectly fine to compare value based instances using ==, but it can lead to confusing results when comparing distinct instances with equivalent state. Using compareAndSet with a box isn't necessary for it to work "correctly" with a value-based class.
>>>>> >
>>>>> > By "correctly", I mean the compareAndSet operation works correctly, using == comparison. However, if your intention is for compareAndSet to compare Instants based on their state, then this of course won't work properly.
>>>>> >
>>>>> > If you want to perform a compareAndSet for an Instant's state (time since epoch), then you need to use something that can be compared atomically. This means the state must be representable in a 64-bit value or smaller. The Instant class measures time using a 64-bit long and a 32-bit int, and so this state cannot be compared atomically. You'd have to chop off some precision or use something else.
>>>>> >
>>>>> >
>>>>> > On 2017-07-05 09:20 PM, Gil Tene wrote:
>>>>> >> Reference equality for value based classes (as referenced below) lacks meaning, as there is no notion of identity in such classes (only a notion of value). And since compareAndSet on reference fields is basically an idenitity-based operation [in the compare part], the two won't mix well logically.
>>>>> >> Specifically, while two references to e.g. java.time.LocalDateTime instances being == to each other *probably* means that the two are actually equal in value, the opposite is not true: Being != to each other does NOT mean that they are logically different. As such, the "compare" part in compareAndSet may falsely fail even when the two instances are logically equal to each other, leaving the rest of your logic potentially exposed.
>>>>> >> Bottom line: given the explicit warning to not use == and != on references to value-based instances, I'd avoid using compareAndSet on those references. If you really need to use a value-based class in your logic, consider boxing it in another object that has [normal] identity.
>>>>> >> — Gil.
>>>>> >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson <michael.hixson at gmail.com <mailto:michael.hixson at gmail.com>> wrote:
>>>>> >>>
>>>>> >>> AtomicReference and VarHandle are specified to use == in compareAndSet
>>>>> >>> (and related) operations [1].  Using == to compare instances of
>>>>> >>> value-based classes may lead to "unpredictable results" [2].  Does
>>>>> >>> this mean I should avoid using compareAndSet with arguments that are
>>>>> >>> instances of value-based classes?
>>>>> >>>
>>>>> >>> It seems like the documentation clearly tells me "yes, avoid doing
>>>>> >>> that" but I'm hoping I misunderstood, or maybe AtomicReference and
>>>>> >>> VarHandle are exempt somehow.  Otherwise, how do I implement
>>>>> >>> non-broken compareAndSet and updateAndGet for a java.time.Instant
>>>>> >>> value for example?  Do I have to box the value in something that's not
>>>>> >>> a value-based class first, like AtomicReference<Box<Instant>>?
>>>>> >>>
>>>>> >>> -Michael
>>>>> >>>
>>>>> >>> [1] http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V- <http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V->
>>>>> >>> [2] http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html <http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html>
>>>>> >
>>>>> > _______________________________________________
>>>>> > Concurrency-interest mailing list
>>>>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>> 
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>>>  
>>>>>  
>>>>> 
>>>>> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 Darmstadt, Germany – Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com <http://www.softwareag.com/>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170709/90c4585b/attachment-0001.html>

From nathanila at gmail.com  Sun Jul  9 20:41:56 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Sun, 9 Jul 2017 18:41:56 -0600
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E743F36D-E587-46DD-82F7-717D291298A9@cox.net>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <759897D4-26C7-4300-B0EC-633025B80CAA@azul.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <6C708A3F-EBF1-484C-B7E8-1CD839AADFBF@gmail.com> <hVsz1v01i02hR0p01Vt4JL>
 <E743F36D-E587-46DD-82F7-717D291298A9@cox.net>
Message-ID: <e8ddf0d8-c91f-190f-59fb-dffd459e7ed3@gmail.com>

Perhaps this thread has diverged too far...

Someone wondered on this thread, if synchronized or compare and set 
would work better under high contention.  The example I have does not 
use equals() so it does not quite match the original question.  However, 
the example does use Instant and compareTo() and hence might be similar 
enough to illustrate.

My program needs an id that is unique even among runs of a singleton 
process.  I figured the easiest way was to use the current time.  I 
could have used System.currentTimeMillis() but decided to go with 
Instant since that would probably make the code easier to understand and 
maintain.

I had code like the following...

       Instant result;

       result = Instant.now();

       synchronized (Task.class)
       {
          if (result.compareTo(last) <= 0)
             result = last.plusNanos(1);

          last = result;
       }

This code didn't scale.  I changed the code to this...

       Instant result;

       result = Instant.now();

       while (true)
       {
          expect = last.get();    // last is now an AtomicReference

          if (result.compareTo(expect) <= 0)
             result = last.plusNanos(1);

          if (last.compareAndSet(expect, result))
             return(result);
       }

This code scales much better.  I no longer see any scalability or 
performance issues with this code.  This code is using both identity 
comparison (i.e. "inside" compareAndSet when comparing expect to the 
actual current value) as well as compareTo().

-Nathan

On 7/9/2017 5:10 PM, Gregg Wonderly wrote:
> Anything that is a Number should be performing automatic unboxing to 
> perform literal value comparisons.  I count on this day in and day 
> out.  There is no reason that Number values should ever do anything 
> different.   You can suggest that two Number values which might be 
> typed as Object parameters into a code structure that compares them 
> with ==, will be costly to execute because of runtime type checking. 
>  But, if the developer codes it that way, because they have other 
> Object values which are used in identity comparisons that are 
> logically valid for the code structure, why perform a compile time 
> optimization that invalidates the premise of how identity works 
> against auto-boxing/unboxing?
>
> Gregg
>
>> On Jul 6, 2017, at 12:52 PM, Gil Tene <gil at azul.com 
>> <mailto:gil at azul.com>> wrote:
>>
>> Hence my suggestion that identity-based operations on instances of 
>> value-based classes should throw exceptions... Right now they 
>> silently do unpredictable things, and should be avoided in any case 
>> (but harder to know/find when you accidentally use them).
>>
>> Sent from my iPad
>>
>> On Jul 6, 2017, at 10:46 AM, Alex Otenko <oleksandr.otenko at gmail.com 
>> <mailto:oleksandr.otenko at gmail.com>> wrote:
>>
>>> Are they subclasses of Object or not? If they are not, no questions. 
>>> If they are, someone still needs to explain how exactly the 
>>> “identity based operations” can be avoided safely.
>>>
>>> List<j.u.Optional> is just a List underneath, and searching for an 
>>> item may use “identity based operations”, whether you want it or not 
>>> - depending on what implementation of List you happen to use.
>>>
>>> Alex
>>>
>>>> On 6 Jul 2017, at 17:33, Gil Tene <gil at azul.com 
>>>> <mailto:gil at azul.com>> wrote:
>>>>
>>>> It says: "Use of such identity-sensitive operations on instances of 
>>>> value-based classes may have unpredictable effects and should be 
>>>> avoided." It does not say what the reason for the unpredictable 
>>>> effect may be and WHEN you shouldn't use identity based operations, 
>>>> it warns you not to use them for any reason whatsoever. Can't be 
>>>> much more clear than that, and you don't need to be a JVM or 
>>>> compiler implementor to understand it. It means "don't do that". 
>>>> And "if you do that, very surprising things may (or may not) happen".
>>>>
>>>> Acting on a current understanding and perception of what 
>>>> implementations actually do, and saying "I thought that what it 
>>>> really means is that using identity in some way X would be 
>>>> unreliable because of effect Y, but using identity in case Z is ok, 
>>>> because I don't see why it shouldn't be" is a wrong reading of this 
>>>> clear admonition to not use identity for anything. Doing so will 
>>>> come back to bite you, either now or in the future.
>>>>
>>>> For example, instances of value-based classes have the [well 
>>>> documented] quality of being "/freely substitutable/when equal, 
>>>> meaning that interchanging any two instances|x|and|y|that are equal 
>>>> according to|equals()|in any computation or method invocation 
>>>> should produce no visible change in behavior." The JVM may (and 
>>>> likely will at some point will) use this quality freely in some 
>>>> optimizations, A simple and obviously valid resulting optimization 
>>>> would be for == to always be evaluated as false when the operands 
>>>> are instances of value-based classes: since the JVM *may* freely 
>>>> substitute the instances of either side of the == evaluation with 
>>>> some instance that is equal according to equals(), it can choose to 
>>>> do so in all evaluations of ==, which would mean that the two sides 
>>>> are never the same instance, and would then mean that the JVM can 
>>>> treat all code that would only execute if == were true as dead 
>>>> code. Similarly, != may trivially be evaluated as always-true. And 
>>>> since these optimizations may or may not be applied in different 
>>>> places and times, they may lead to seemingly random evaluation of 
>>>> == or != for identical code on identical data (for the exact same, 
>>>> unmodified values of a and d, a will sometimes be equal to d and 
>>>> sometimes not, and at the same point in code, depending on mood).
>>>>
>>>> We could further discuss whether or not the JVM is allowed to 
>>>> "falsely" indicate that == is true (or that != is false) even when 
>>>> the instances differ in value (so are not .equals()). It is. Doing 
>>>> that may certainly surprise anyone who uses the identity based == 
>>>> for anything to do with instances of value-based classes, even tho 
>>>> using it would be silly given that == might obviously be 
>>>> always-false. For example, I could see how someone may mistakenly 
>>>> try to use == as an "optimization" on the assumption that if they 
>>>> get lucky and == is true, .equals() must be true as well, and that 
>>>> evaluating == might be cheaper, but they would still "do the right 
>>>> thing" in the != case. But that would be a mistake, and a clear 
>>>> violation of the "don't do that" admonition above. The cases where 
>>>> the result of == can be *unpredictable* are not limited to cases 
>>>> where the JVM freely substitutes instances for other equal() ones, 
>>>> that's just one example of how the JVM may obviously and validly 
>>>> use one known quality of value-based classes. But another key 
>>>> quality of instances of value based classes is that they "are 
>>>> considered equal solely based on |equals()|, not based on reference 
>>>> equality (|==|)". There is nothing there that limits us to "if == 
>>>> is true, equals() must be true as well". It may be convenient to 
>>>> think otherwise when wanting to explain how breaking the rules in 
>>>> some specific way is still ok (and currently seems to work). But 
>>>> it's not. Bottom line: The JVM *may* choose to make == always-true. 
>>>> Nothing wrong with that.
>>>>
>>>> It is dangerous (and nearly impossible) to deduce which 
>>>> optimizations may or may not happen when they are clearly allowed 
>>>> by the specified set of rules and qualities. The defined qualities 
>>>> are what matter, and optimizations that indirectly result from the 
>>>> propagation of those qualities are allowed and may (or may  not) 
>>>> happen. Instance identity either exists or doesn't, and instance 
>>>> Identity checks either have meaning, or they don't. If they do, 
>>>> certain things follow (like .equals() always being true if the 
>>>> identity of the twin instances is the same, as tested by ==). If 
>>>> they don't, then identity checks are meaningless, and can be 
>>>> discarded or conveniently evaluated in ways that seem profitable.
>>>>
>>>> For "instances" of value-based classes, instance identity does not 
>>>> exist. Unfortunately, unlike value types, where the operand == is 
>>>> defined to act on value and not on identity, the operand == is 
>>>> undefined for instances of value-based classes. It certainly does 
>>>> not mean "if true, the identity of these things is the same", and 
>>>> it certainly doesn't mean "if false, these things are not equal". 
>>>> But it also doesn't mean "if true, these things are equal". It is 
>>>> *undefined*, specified with "may have unpredictable effects", and 
>>>> users are clearly told not to use it for anything.
>>>>
>>>> One can argue that the spec should change, e.g. add a statement 
>>>> that would have the effect of requiring "if == is true then 
>>>> .equals() is also true", and would prevent or limit certain 
>>>> unpredictable effects when considering the identity of 
>>>> identity-less things, but I suspect that writing that down in 
>>>> actual words would be painful given the necessary "there is no 
>>>> meaning to identify, but..." logic. We could also look to redefine 
>>>> the meaning of certain operands, e.g. == and != can be dealt with 
>>>> as they are in value types, but compare in compareAndSet is more 
>>>> challenging...
>>>>
>>>> This is [partly] why I think that throwing an exception (or even a 
>>>> compile-time error where possible) when encountering == or != 
>>>> operations (and any of the other undefined behavior ones) on 
>>>> instances of value-based classes is a good idea, and something that 
>>>> should start happening ASAP. Any such operation is wrong 
>>>> (literally) by definition, and the "may have unpredictable effects" 
>>>> statement in the spec is certainly wide enough to allow exception 
>>>> throwing. It is wide enough to allow much worse things to happen, 
>>>> and silent unpredictable and undefined behavior, while allowed, is 
>>>> worse than preventing the code from executing. The same way we 
>>>> wouldn't argue that synchronized(int) should simply be "undefined" 
>>>> but silently allowed to run with unpredictable effects, we 
>>>> shouldn't argue that synchronized(LocalDateTime) should.
>>>>
>>>> Sent from my iPad
>>>>
>>>> On Jul 6, 2017, at 3:04 AM, Alex Otenko <oleksandr.otenko at gmail.com 
>>>> <mailto:oleksandr.otenko at gmail.com>> wrote:
>>>>
>>>>> :-) the one causing Byzantine failures!
>>>>>
>>>>> Given how underspecified the things generally are, and that the 
>>>>> target audience of such javadoc is not a JVM implementor, we 
>>>>> shouldn’t read too much into the possible freedoms the vague 
>>>>> wording seems to imply. It shouldn’t suddenly break the promises 
>>>>> about identity equality for specific instances.
>>>>>
>>>>> All it’s saying is that, like Integer.from(10) may or may not 
>>>>> return the same instance. It may or may not work the same way 
>>>>> throughout the JVM’s lifetime, allowing the implementors to choose 
>>>>> suitable caching strategies, code optimizations, etc - 
>>>>> *therefore* should not rely on comparing identities, and such; for 
>>>>> example, synchronized(Integer.from(10)) does not guarantee neither 
>>>>> lock freedom, nor deadlock freedom. It should not say that 
>>>>> suddenly it is unsafe to compare identities (like Gil suggests JVM 
>>>>> could start throwing exceptions). It should not say that suddenly 
>>>>> we shouldn’t be able to CAS (like Gil says suddenly the reference 
>>>>> to instance can sneakily be replaced with something else).
>>>>>
>>>>>
>>>>> Alex
>>>>>
>>>>>
>>>>>> On 6 Jul 2017, at 10:12, Millies, Sebastian 
>>>>>> <Sebastian.Millies at softwareag.com 
>>>>>> <mailto:Sebastian.Millies at softwareag.com>> wrote:
>>>>>>
>>>>>> just out of curiosity: I am familiar with the term “Byzantine 
>>>>>> failure”, but what is a “Byzantine optimization”?
>>>>>> ■Sebastian
>>>>>> *From:*Concurrency-interest 
>>>>>> [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf 
>>>>>> Of*Alex Otenko
>>>>>> *Sent:*Thursday, July 06, 2017 10:17 AM
>>>>>> *To:*Gil Tene
>>>>>> *Cc:*concurrency-interest at cs.oswego.edu 
>>>>>> <mailto:concurrency-interest at cs.oswego.edu>
>>>>>> *Subject:*Re: [concurrency-interest] Should I avoid compareAndSet 
>>>>>> with value-based classes?
>>>>>>
>>>>>>     On 6 Jul 2017, at 08:47, Gil Tene <gil at azul.com
>>>>>>     <mailto:gil at azul.com>> wrote:
>>>>>>
>>>>>>
>>>>>>     Sent from my iPad
>>>>>>
>>>>>>
>>>>>>     On Jul 6, 2017, at 12:38 AM, Alex Otenko
>>>>>>     <oleksandr.otenko at gmail.com
>>>>>>     <mailto:oleksandr.otenko at gmail.com>> wrote:
>>>>>>
>>>>>>         All it is saying is:
>>>>>>         LocalDateTime a = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>>         LocalDateTime b = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>>         LocalDateTime c = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>>         a==b && b==c can be true and can be false
>>>>>>
>>>>>>     It also means that even when:
>>>>>>     LocalDateTime d = a;
>>>>>>       ...
>>>>>>       (a == d) may or may not be true. And may change whether it
>>>>>>     is true or not at any time,
>>>>>>
>>>>>> I meant an even stronger assertion:
>>>>>> assert (a==b) == (b==a) : "No Byzantine optimizations"
>>>>>> assert (a==d) == (a==d): “No Byzantine optimizations"
>>>>>> Alex
>>>>>>
>>>>>>
>>>>>>     Alex
>>>>>>
>>>>>>         On 6 Jul 2017, at 08:28, Gil Tene <gil at azul.com
>>>>>>         <mailto:gil at azul.com>> wrote:
>>>>>>
>>>>>>
>>>>>>         Sent from my iPad
>>>>>>
>>>>>>
>>>>>>         On Jul 5, 2017, at 11:51 PM, Henrik Johansson
>>>>>>         <dahankzter at gmail.com <mailto:dahankzter at gmail.com>> wrote:
>>>>>>
>>>>>>             Oh, without having followed the value type
>>>>>>             discussions I think it was a mistake to not "fix"
>>>>>>             equality. Why not make it a deep comparison if the
>>>>>>             reference is different? If it points to the same
>>>>>>             object we are done otherwise start checking the
>>>>>>             struct content.
>>>>>>             There may be a lot I missed here but a new type of
>>>>>>             object could be allowed to have different meaning
>>>>>>             equality. Right?
>>>>>>
>>>>>>         .equals() means what you want it to mean. == and != (and
>>>>>>         the compare in compareAndSet) mean very specific things,
>>>>>>         and cannot be overridden.
>>>>>>         For non-reference value types (int, long, char, etc.), ==
>>>>>>         and != are value comparisons. An int has no identity.
>>>>>>         Just a value:
>>>>>>           int a = 5;
>>>>>>           int b = 5;
>>>>>>           boolean y = (a == b);  // true
>>>>>>         For references to instances of (non value-based) classes,
>>>>>>         == and != can be thought of as comparing the value of the
>>>>>>         reference (and not the contents of the object instances).
>>>>>>         This is an identity comparison, which ignores values
>>>>>>         within the object:
>>>>>>           Integer a = new Integer(5);
>>>>>>           Integer b = new Integer(5);
>>>>>>           boolean x = a.equals(b); // true
>>>>>>           boolean y = (a == b);   // false
>>>>>>         And for references to value-based classes (which is a
>>>>>>         relatively new thing, but is part of Java 8), the meaning
>>>>>>         of == and != appears to be undefined. E.g.:
>>>>>>           LocalDateTime a
>>>>>>         = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>>           LocalDateTime b
>>>>>>         = LocalDateTime.parse("2007-12-03T10:15:30");
>>>>>>           boolean x = a.equals(b); // true
>>>>>>           boolean y = (a == b); // unpredictable, undefined, who
>>>>>>         knows.
>>>>>>          // Could be true, could be false.
>>>>>>          // Could theoretically change the values of a or b, or
>>>>>>         of something else
>>>>>>
>>>>>>
>>>>>>         On Thu, 6 Jul 2017, 07:12 Gil Tene, <gil at azul.com
>>>>>>         <mailto:gil at azul.com>> wrote:
>>>>>>
>>>>>>
>>>>>>             I'd take that documentation seriously. It basically
>>>>>>             says that ==, !=, synchronization, identity hashing,
>>>>>>             and serialization are undefined behaviors.
>>>>>>
>>>>>>             While the *current* implementations may carry some
>>>>>>             semi-intuitive behvaiors, e.g. where == indicates
>>>>>>             true when comparing two references to instances of a
>>>>>>             value-based class where the value of the references
>>>>>>             is the same, there is no guarantee that at some point
>>>>>>             in the [near or far] future that behavior will
>>>>>>             remain. Specifically, attempting == (or !=, or
>>>>>>             synchronization, etc., including compareAndSet) on a
>>>>>>             reference to a value based class is allowed to do
>>>>>>             ANYTHING in the future.
>>>>>>             For example:
>>>>>>             - It may throw an exception (something it should
>>>>>>             probably start doing ASAP to avoid future surprises).
>>>>>>             - It may return always-false, even when the two
>>>>>>             references are "to the same instance" (and probably
>>>>>>             will, through many possible value-based compiler
>>>>>>             optimizations that will erase the unneeded notion of
>>>>>>             reference and identity).
>>>>>>             - It may overwrite random locations in memory or to
>>>>>>             variables that the code performing the operation has
>>>>>>             the privilege to write to (which it probably
>>>>>>             shouldn't, but that's certainly included in what
>>>>>>             "undefined" and "unpredictable effects" can mean).
>>>>>>             - It may sometimes do one of the above, and sometimes
>>>>>>             seem to be doing what you mean it to do. Switching
>>>>>>             between modes on a whim (e.g. when a tier 2
>>>>>>             optimizing compilation is applied, or when the mutton
>>>>>>             is nice and lean and the tomato is ripe).
>>>>>>
>>>>>>             So no, there is no way for compareAndSet to work
>>>>>>             "correctly" on a reference to an instance of a
>>>>>>             value-based class. Even if it happens to appear to
>>>>>>             work "correctly" now, expect it to blow up in bad and
>>>>>>             potentially silent ways in the future.
>>>>>>
>>>>>>             — Gil.
>>>>>>
>>>>>>             > On Jul 5, 2017, at 9:47 PM, Brian S O'Neill
>>>>>>             <bronee at gmail.com <mailto:bronee at gmail.com>> wrote:
>>>>>>             >
>>>>>>             > I think the wording in the value-based document is
>>>>>>             too strong. It's perfectly fine to compare value
>>>>>>             based instances using ==, but it can lead to
>>>>>>             confusing results when comparing distinct instances
>>>>>>             with equivalent state. Using compareAndSet with a box
>>>>>>             isn't necessary for it to work "correctly" with a
>>>>>>             value-based class.
>>>>>>             >
>>>>>>             > By "correctly", I mean the compareAndSet operation
>>>>>>             works correctly, using == comparison. However, if
>>>>>>             your intention is for compareAndSet to compare
>>>>>>             Instants based on their state, then this of course
>>>>>>             won't work properly.
>>>>>>             >
>>>>>>             > If you want to perform a compareAndSet for an
>>>>>>             Instant's state (time since epoch), then you need to
>>>>>>             use something that can be compared atomically. This
>>>>>>             means the state must be representable in a 64-bit
>>>>>>             value or smaller. The Instant class measures time
>>>>>>             using a 64-bit long and a 32-bit int, and so this
>>>>>>             state cannot be compared atomically. You'd have to
>>>>>>             chop off some precision or use something else.
>>>>>>             >
>>>>>>             >
>>>>>>             > On 2017-07-05 09:20 PM, Gil Tene wrote:
>>>>>>             >> Reference equality for value based classes (as
>>>>>>             referenced below) lacks meaning, as there is no
>>>>>>             notion of identity in such classes (only a notion of
>>>>>>             value). And since compareAndSet on reference fields
>>>>>>             is basically an idenitity-based operation [in the
>>>>>>             compare part], the two won't mix well logically.
>>>>>>             >> Specifically, while two references to e.g.
>>>>>>             java.time.LocalDateTime instances being == to each
>>>>>>             other *probably* means that the two are actually
>>>>>>             equal in value, the opposite is not true: Being != to
>>>>>>             each other does NOT mean that they are logically
>>>>>>             different. As such, the "compare" part in
>>>>>>             compareAndSet may falsely fail even when the two
>>>>>>             instances are logically equal to each other, leaving
>>>>>>             the rest of your logic potentially exposed.
>>>>>>             >> Bottom line: given the explicit warning to not use
>>>>>>             == and != on references to value-based instances, I'd
>>>>>>             avoid using compareAndSet on those references. If you
>>>>>>             really need to use a value-based class in your logic,
>>>>>>             consider boxing it in another object that has
>>>>>>             [normal] identity.
>>>>>>             >> — Gil.
>>>>>>             >>> On Jul 5, 2017, at 8:59 PM, Michael Hixson
>>>>>>             <michael.hixson at gmail.com
>>>>>>             <mailto:michael.hixson at gmail.com>> wrote:
>>>>>>             >>>
>>>>>>             >>> AtomicReference and VarHandle are specified to
>>>>>>             use == in compareAndSet
>>>>>>             >>> (and related) operations [1].  Using == to
>>>>>>             compare instances of
>>>>>>             >>> value-based classes may lead to "unpredictable
>>>>>>             results" [2]. Does
>>>>>>             >>> this mean I should avoid using compareAndSet with
>>>>>>             arguments that are
>>>>>>             >>> instances of value-based classes?
>>>>>>             >>>
>>>>>>             >>> It seems like the documentation clearly tells me
>>>>>>             "yes, avoid doing
>>>>>>             >>> that" but I'm hoping I misunderstood, or maybe
>>>>>>             AtomicReference and
>>>>>>             >>> VarHandle are exempt somehow. Otherwise, how do I
>>>>>>             implement
>>>>>>             >>> non-broken compareAndSet and updateAndGet for a
>>>>>>             java.time.Instant
>>>>>>             >>> value for example?  Do I have to box the value in
>>>>>>             something that's not
>>>>>>             >>> a value-based class first, like
>>>>>>             AtomicReference<Box<Instant>>?
>>>>>>             >>>
>>>>>>             >>> -Michael
>>>>>>             >>>
>>>>>>             >>>
>>>>>>             [1]http://download.java.net/java/jdk9/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet-V-V-
>>>>>>             >>>
>>>>>>             [2]http://download.java.net/java/jdk9/docs/api/java/lang/doc-files/ValueBased.html
>>>>>>             >
>>>>>>             > _______________________________________________
>>>>>>             > Concurrency-interest mailing list
>>>>>>             >Concurrency-interest at cs.oswego.edu
>>>>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>             >http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>             _______________________________________________
>>>>>>             Concurrency-interest mailing list
>>>>>>             Concurrency-interest at cs.oswego.edu
>>>>>>             <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>         _______________________________________________
>>>>>>         Concurrency-interest mailing list
>>>>>>         Concurrency-interest at cs.oswego.edu
>>>>>>         <mailto:Concurrency-interest at cs.oswego.edu>
>>>>>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>> Software AG – Sitz/Registered office: Uhlandstraße 12, 64297 
>>>>>> Darmstadt, Germany – Registergericht/Commercial register: 
>>>>>> Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz 
>>>>>> Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram 
>>>>>> Jost, Arnd Zinnhardt, Dr. Stefan Sigg; - 
>>>>>> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. 
>>>>>> Andreas Bereczky -*http://www.softwareag.com* 
>>>>>> <http://www.softwareag.com/>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu 
>>>>> <mailto:Concurrency-interest at cs.oswego.edu>
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu 
>> <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170709/9b3d0e68/attachment-0001.html>

From aph at redhat.com  Mon Jul 10 05:22:22 2017
From: aph at redhat.com (Andrew Haley)
Date: Mon, 10 Jul 2017 10:22:22 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <fb73724e-21d0-5018-c0f0-035ddb4e02d5@gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
Message-ID: <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>

On 08/07/17 13:22, Gil Tene wrote:
> 
>> On Jul 8, 2017, at 1:19 AM, Andrew Haley <aph at redhat.com> wrote:
>>
>> On 08/07/17 07:38, Gil Tene wrote:
>>
>>> My arguments here are not about trying to justify some compiler
>>> optimizations, or trying to justify the choices of making these
>>> things subclasses the Object. They are about pointing out the actual
>>> meaning of things as defined and the (very high risk) of coding
>>> against it based on a hope that some temporarily observed behavior
>>> is actually reliable, when everything that describes what it does
>>> says otherwise.
>>
>> I disagree with this interpretation.  You're interpreting the language
>> in that paragraph as overriding some fundamental properties in the JLS.
> 
> To keep this to a simple case that
> 
> What specific property of the JLS requires that == not be always-false?

I think the ontion that

> I.e., what is it in the JLS that requires that this loop ever
> terminate when there is no external interference by another thread?:
> 
>   // David Lloyd's example from earlier in the thread (Jul 6, 10:48AM PDT):
>   AtomicReference<Instant> atomic;
>   Instant a, b;
>   ...
>   do {
>       a = atomic.get();
>       b = compute(a);
>   } while (! atomic.compareAndSet(a, b));
> 
> 
> or for that matter, that this loop ever terminate when there is no
> external interference by another thread?:
> 
>   volatile Instant thing;
>   Instant a, b;
>   …
>   boolean success = false;
>   do {
>       a = thing;
>       b = compute(a);
>       if (thing == a) {
>           thing = b;
>           success = true;      
>       }
>   } while (!success);
> 
> The termination of both of these loops relies on the notion of
> identity (the logical value of a reference) being preserved between
> the reading of a reference to an instance of a value-based class
> from memory, and the eventual comparison of that instance's
> reference with another one stored in a memory location.

Indeed.  I already quoted the language in the JLS I'm relying on, and
said that I find it convincing.  I believe that 15.21.3, "Reference
Equality Operators == and !=" would have to be changed in order for
your interpretation of reference equality to be correct.

So let's move on to another matter, the JVM specification, and the way
that Java maps on to the JVM.  In the JVM, the instruction if_acmpeq
is supposed to return true if value1 = value2.  So,

   dup; if_acmpeq

is bound to succeed.

You could argue that it is theoretically possible that Java could be
compiled onto the JVM in some other way, so that your interpretation
of the JLS would be correct, but I don't think it's much to worry
about.  You could also argue that the section which describes
value-based classes implicitly changes the JVM specification, but I'd
like to see that in writing.

-- 
Andrew Haley
Java Platform Lead Engineer
Red Hat UK Ltd. <https://www.redhat.com>
EAC8 43EB D3EF DB98 CC77 2FAD A5CD 6035 332F A671

From shade at redhat.com  Mon Jul 10 05:53:15 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Mon, 10 Jul 2017 11:53:15 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
Message-ID: <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>

On 07/10/2017 11:22 AM, Andrew Haley wrote:
> Indeed.  I already quoted the language in the JLS I'm relying on, and
> said that I find it convincing.  I believe that 15.21.3, "Reference
> Equality Operators == and !=" would have to be changed in order for
> your interpretation of reference equality to be correct.
> 
> So let's move on to another matter, the JVM specification, and the way
> that Java maps on to the JVM.  In the JVM, the instruction if_acmpeq
> is supposed to return true if value1 = value2.  So,
> 
>    dup; if_acmpeq
> 
> is bound to succeed.
> 
> You could argue that it is theoretically possible that Java could be
> compiled onto the JVM in some other way, so that your interpretation
> of the JLS would be correct, but I don't think it's much to worry
> about.  You could also argue that the section which describes
> value-based classes implicitly changes the JVM specification, but I'd
> like to see that in writing.

I remember this was the early confusion with lambdas, which had the relaxed
notion of identity too. And there was the same confusion of "OMG, I can get the
exception doing '==' on lambda?!". But that only extended to "you don't know
what would the evaluation result of lambda expression be: it might be equal to
something else, or not".

That is:

  Runnable r1 = () -> {};
  Runnable r2 = () -> {};
  assert (r1 == r2);                       // deliberately unspecified
  assert (r1.getClass() == r2.getClass()); // deliberately unspecified
  assert (r1 == r1);                       // keeps being true!
  assert (r2 == r2);                       // keeps being true!
  assert (r1.getClass() == r1.getClass()); // keeps being true!
  assert (r2.getClass() == r2.getClass()); // keeps being true!

I think that for value objects, whether they are really implemented on JVM, or
they are just declared in Javadoc, the same thing applies. This stance in docs
is the key: "[Value-based classes:] - do not have accessible constructors, but
are instead instantiated through factory methods which make no committment as to
the identity of returned instances;". The rest of the properties seem to be
derived from that unreliable identity.

In other words, "no commitment" reads as "identity is unknown" rather than
"identity is non-existent". Unknown identity is still reflexive, symmetric,
transitive. The identity of the value type *box* that you get from the
expression should be deliberately unspecified to provide implementation freedom,
but once you get the boxed reference, it is bound by the same JLS rules Andrew
quotes.

In yet other words, "value-based class" tells to be careful about the identity
semantics of producing expressions, but it does not relax the semantics of the
boxed references you get from them either explicitly or implicitly. This is
pretty much like current primitive autoboxing works :)

Thanks,
-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170710/eb89c5f3/attachment.sig>

From oleksandr.otenko at gmail.com  Mon Jul 10 06:02:59 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 10 Jul 2017 11:02:59 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
Message-ID: <1EDF1D24-CE0A-4FA9-87AD-52FC5F83F695@gmail.com>

Thanks, this is very useful.

What about

Runnable r1 = () -> {};
Runnable r2 = r1;
assert r1 == r2;

should we expect a bombshell here? Clearly, autoboxing/unboxing is allowed to happen, if, say, r1 and r2 were Integers, but which side of the surprising behaviour will the JVM choose?


Alex

> On 10 Jul 2017, at 10:53, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 07/10/2017 11:22 AM, Andrew Haley wrote:
>> Indeed.  I already quoted the language in the JLS I'm relying on, and
>> said that I find it convincing.  I believe that 15.21.3, "Reference
>> Equality Operators == and !=" would have to be changed in order for
>> your interpretation of reference equality to be correct.
>> 
>> So let's move on to another matter, the JVM specification, and the way
>> that Java maps on to the JVM.  In the JVM, the instruction if_acmpeq
>> is supposed to return true if value1 = value2.  So,
>> 
>>   dup; if_acmpeq
>> 
>> is bound to succeed.
>> 
>> You could argue that it is theoretically possible that Java could be
>> compiled onto the JVM in some other way, so that your interpretation
>> of the JLS would be correct, but I don't think it's much to worry
>> about.  You could also argue that the section which describes
>> value-based classes implicitly changes the JVM specification, but I'd
>> like to see that in writing.
> 
> I remember this was the early confusion with lambdas, which had the relaxed
> notion of identity too. And there was the same confusion of "OMG, I can get the
> exception doing '==' on lambda?!". But that only extended to "you don't know
> what would the evaluation result of lambda expression be: it might be equal to
> something else, or not".
> 
> That is:
> 
>  Runnable r1 = () -> {};
>  Runnable r2 = () -> {};
>  assert (r1 == r2);                       // deliberately unspecified
>  assert (r1.getClass() == r2.getClass()); // deliberately unspecified
>  assert (r1 == r1);                       // keeps being true!
>  assert (r2 == r2);                       // keeps being true!
>  assert (r1.getClass() == r1.getClass()); // keeps being true!
>  assert (r2.getClass() == r2.getClass()); // keeps being true!
> 
> I think that for value objects, whether they are really implemented on JVM, or
> they are just declared in Javadoc, the same thing applies. This stance in docs
> is the key: "[Value-based classes:] - do not have accessible constructors, but
> are instead instantiated through factory methods which make no committment as to
> the identity of returned instances;". The rest of the properties seem to be
> derived from that unreliable identity.
> 
> In other words, "no commitment" reads as "identity is unknown" rather than
> "identity is non-existent". Unknown identity is still reflexive, symmetric,
> transitive. The identity of the value type *box* that you get from the
> expression should be deliberately unspecified to provide implementation freedom,
> but once you get the boxed reference, it is bound by the same JLS rules Andrew
> quotes.
> 
> In yet other words, "value-based class" tells to be careful about the identity
> semantics of producing expressions, but it does not relax the semantics of the
> boxed references you get from them either explicitly or implicitly. This is
> pretty much like current primitive autoboxing works :)
> 
> Thanks,
> -Aleksey
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From shade at redhat.com  Mon Jul 10 06:06:22 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Mon, 10 Jul 2017 12:06:22 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <1EDF1D24-CE0A-4FA9-87AD-52FC5F83F695@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <1EDF1D24-CE0A-4FA9-87AD-52FC5F83F695@gmail.com>
Message-ID: <22a8a14b-34ab-75a3-a0e3-79d2d4c55d08@redhat.com>

On 07/10/2017 12:02 PM, Alex Otenko wrote:
> Thanks, this is very useful.
> 
> What about
> 
> Runnable r1 = () -> {};
> Runnable r2 = r1;
> assert r1 == r2;
> 
> should we expect a bombshell here? Clearly, autoboxing/unboxing is allowed to happen, if, say, r1 and r2 were Integers, but which side of the surprising behaviour will the JVM choose?

I think the answer is the same as with Integers, if you rephrase your example
with them:

  Integer i1 = 4242;
  Integer i2 = i1;   // this is not autoboxing anymore, this is reference store
  assert (i1 == i2); // would you expect this to fail?

Similarly, the key part is here:
  Runnable r2 = r1;  // this is not a lambda-expression, this is reference store

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170710/c944f342/attachment-0001.sig>

From oleksandr.otenko at gmail.com  Mon Jul 10 06:23:19 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 10 Jul 2017 11:23:19 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <22a8a14b-34ab-75a3-a0e3-79d2d4c55d08@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <1EDF1D24-CE0A-4FA9-87AD-52FC5F83F695@gmail.com>
 <22a8a14b-34ab-75a3-a0e3-79d2d4c55d08@redhat.com>
Message-ID: <FBA2A942-25E4-4F91-941B-08583C504415@gmail.com>

Thanks, that makes sense. The evasive language of the spec can get interpreted by some to mean that it is not guaranteed, so perhaps some clarification needs to be signed off - like, if unboxing is not required, then it should behave like no unboxing happened.


Alex


> On 10 Jul 2017, at 11:06, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 07/10/2017 12:02 PM, Alex Otenko wrote:
>> Thanks, this is very useful.
>> 
>> What about
>> 
>> Runnable r1 = () -> {};
>> Runnable r2 = r1;
>> assert r1 == r2;
>> 
>> should we expect a bombshell here? Clearly, autoboxing/unboxing is allowed to happen, if, say, r1 and r2 were Integers, but which side of the surprising behaviour will the JVM choose?
> 
> I think the answer is the same as with Integers, if you rephrase your example
> with them:
> 
>  Integer i1 = 4242;
>  Integer i2 = i1;   // this is not autoboxing anymore, this is reference store
>  assert (i1 == i2); // would you expect this to fail?
> 
> Similarly, the key part is here:
>  Runnable r2 = r1;  // this is not a lambda-expression, this is reference store
> 
> Thanks,
> -Aleksey
> 


From oleksandr.otenko at gmail.com  Mon Jul 10 07:02:09 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 10 Jul 2017 12:02:09 +0100
Subject: [concurrency-interest] Scalability of
	ConcurrentHashMap#computeIfAbsent
In-Reply-To: <CANPzfU9EDh4bAaOb-OHPX85PEjtdNST1p+hGZvACj0Fe0s9CYg@mail.gmail.com>
References: <CANLTa0CO_C-V7DDRy-+Zo+SqEEhHdnXSh3zTkwKVmOUgP+vQTw@mail.gmail.com>
 <e8334876-4ab5-dc9d-00eb-a4b4d0fdfe97@cs.oswego.edu>
 <CANPzfU9EDh4bAaOb-OHPX85PEjtdNST1p+hGZvACj0Fe0s9CYg@mail.gmail.com>
Message-ID: <B37F9C72-56D0-4D42-A93B-62254B4786F9@gmail.com>

Readers shouldn’t block.

Losers need a mechanism to contend again, if CF fails.


Alex


> On 6 Jul 2017, at 16:30, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> You could do a read, if absent you store a CompletableFuture with putIfAbsent, and if you win you complete it with the result of the computation, readers and losers of the putIfAbsent will get the CF and block until it is available...
> 
> -- 
> Cheers,
> √
> 
> On Jul 6, 2017 5:11 PM, "Jonas Konrad" <me at yawk.at <mailto:me at yawk.at>> wrote:
> I don't see how pessimistic locking is *required* for computeIfAbsent with a fast path for already-existing elements. It could basically do double-checked locking (and you can already to that manually, with the same guarantees as computeIfAbsent).
> 
> 
> On 2017-07-06 17:01, Josh Humphries wrote:
> On Thu, Jul 6, 2017 at 10:47 AM, Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>
> <mailto:dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>> wrote:
> 
>     On 07/06/2017 10:14 AM, Benoit Daloze wrote:
> 
>     > I have been chasing a scalability problem that only happens with over 8
>     > cores on my benchmark and it turns out
>     > ConcurrentHashMap#computeIfAbsent when used as a cache with the same key
>     > does not scale.
> 
> 
> This is necessary since the spec
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function- <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function->> indicates
> 
> that the operation (including computation of the value) is atomic. To
> make this atomic, it must use pessimistic locking, so it seems you are
> observing lock contention. (Interestingly, this behavior contrasts with
> the default implementation
> <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function- <https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function->> in
> 
> the ConcurrentMap interface, which uses optimistic concurrency and
> retries and makes no promise of atomicity.) The scalability of the map
> relies on many threads operating on different keys, not all operations
> using the same key.
> 
> Your work-around, to have every thread eagerly execute the function in
> parallel and then "first one wins" to store the value in the map, looks
> appropriate.
> 
> 
> 
>     Please try this using JDK9, which locks only on (possible) hash
>     collision. (See discussion in list archives.)
> 
> 
> The original question indicates the operation not scaling is for the
> same key, so I think it will encounter a hash collision and the same
> scalability issue even with this patch.
> 
> 
>     If we had known that JDK9 would face so much adoption delay,
>     we might have tried to arrange backports of this and other minor
>     improvements and fixes...
> 
>     -Doug
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     <mailto:Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
> 
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170710/5ef7d141/attachment.html>

From gil at azul.com  Tue Jul 11 12:22:48 2017
From: gil at azul.com (Gil Tene)
Date: Tue, 11 Jul 2017 16:22:48 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
Message-ID: <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>


> On Jul 10, 2017, at 2:53 AM, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 07/10/2017 11:22 AM, Andrew Haley wrote:
>> Indeed.  I already quoted the language in the JLS I'm relying on, and
>> said that I find it convincing.  I believe that 15.21.3, "Reference
>> Equality Operators == and !=" would have to be changed in order for
>> your interpretation of reference equality to be correct.
>> 
>> So let's move on to another matter, the JVM specification, and the way
>> that Java maps on to the JVM.  In the JVM, the instruction if_acmpeq
>> is supposed to return true if value1 = value2.  So,
>> 
>>   dup; if_acmpeq
>> 
>> is bound to succeed.
>> 
>> You could argue that it is theoretically possible that Java could be
>> compiled onto the JVM in some other way, so that your interpretation
>> of the JLS would be correct, but I don't think it's much to worry
>> about.  You could also argue that the section which describes
>> value-based classes implicitly changes the JVM specification, but I'd
>> like to see that in writing.
> 
> I remember this was the early confusion with lambdas, which had the relaxed
> notion of identity too. And there was the same confusion of "OMG, I can get the
> exception doing '==' on lambda?!". But that only extended to "you don't know
> what would the evaluation result of lambda expression be: it might be equal to
> something else, or not".
> 
> That is:
> 
>  Runnable r1 = () -> {};
>  Runnable r2 = () -> {};
>  assert (r1 == r2);                       // deliberately unspecified
>  assert (r1.getClass() == r2.getClass()); // deliberately unspecified
>  assert (r1 == r1);                       // keeps being true!
>  assert (r2 == r2);                       // keeps being true!
>  assert (r1.getClass() == r1.getClass()); // keeps being true!
>  assert (r2.getClass() == r2.getClass()); // keeps being true!

The [very important] difference is that Runnable is NOT a value-based class. But Instant is. Runnable never said anything about the use of identity resulting in unpredictable effects, Instant does. Runnable never said anything about being allowed to be freely substitute with other Runnables that are .equals() in any computation. Instant does.

To test the notion that == "means what you think it means" in some places. Lets take your example a couple of steps farther:

Class AnnotatedTime {
      String annotation;
      long secondsSinceEpoch;
      long nanosInSecond;
      Instant instant;

      boolean isExactSameInstant(Instant other) {
           return (instant == other);
      }
 }

 HashMap<Long, Instant > instanceCache = new HashMap<>();

 Instant i1 = Instance.ofEpochSecond(1000);
 Instant i2 = Instance.ofEpochSecond(1000);
 
 AnnotatedTimes annotatedTime = new AnnotatedTime();
 annotatedTime1.annotation = "Time at 1000"; 
 annotatedTime1. secondsSinceEpoch = 1000;
 annotatedTime1. instant = i1;

 instanceCache.put(1000L, i1);

 A. (i1 == i2)  // We all agree it may be true or false depending on implementation details
 B. (i1 == i1)  // You say it must remain true. I say it could validly be false. This is a computation of a boolean expression.
 C. (i1 == annotatedTime. instant) // You say this must be true as well??
 D. (annotatedTime1.isExactSameInstant(i1)) // Is this required to be true?
 E. (i1 == instanceCache.get(1000L)) // And this must also be true??

If you say that B,C,D,E must all be true (which would presumably be self-consistent), you are basically saying that even tho the spec says so, Instant cannot be freely replaced with other Instants that are .equals() with it in computations and method invocations. At that point, nothing distinguishes a value-based class from a regular class that is immutable. E.g. Instant and Integer have the same defined behavior according to this interpretation, and all mention of a value-based class in the spec is basically a no-op.

If you say e.g. that B must be true but either C, D, or E doesn't have to be true. Where do you draw the line? Is it at local variables vs. heap storage? Is it in parameter passing? What things are allowed to freely replace one Instant with some other Instant that is .equals() to it, and what things aren't?

Note that long-standing immutable classes with clean .equals() and hashcode behaviors (like Integer, Long, etc.) have not been specified to be value-based classes. Presumably due to historical compatibility reasons, since the identity of instances of those classes certainly carries meaning, and B-E above would all have to be true for them. In contrast, all current classes that are defined as value-based classes have been defined so from their inception. If you want to interpret the specification of value-based classes as not contradicting the behavior of e.g. Integer, why the definition? And why is Integer NOT a value-based class?

> 
> I think that for value objects, whether they are really implemented on JVM, or
> they are just declared in Javadoc, the same thing applies. This stance in docs
> is the key: "[Value-based classes:] - do not have accessible constructors, but
> are instead instantiated through factory methods which make no committment as to
> the identity of returned instances;". The rest of the properties seem to be
> derived from that unreliable identity.
> 
> In other words, "no commitment" reads as "identity is unknown" rather than
> "identity is non-existent". Unknown identity is still reflexive, symmetric,
> transitive. The identity of the value type *box* that you get from the
> expression should be deliberately unspecified to provide implementation freedom,
> but once you get the boxed reference, it is bound by the same JLS rules Andrew
> quotes.
> 
> In yet other words, "value-based class" tells to be careful about the identity
> semantics of producing expressions, but it does not relax the semantics of the
> boxed references you get from them either explicitly or implicitly. This is
> pretty much like current primitive autoboxing works :)
> 
> Thanks,
> -Aleksey
> 
> 


From vitalyd at gmail.com  Tue Jul 11 12:44:27 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 11 Jul 2017 16:44:27 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <9B795214-2C8C-4FD9-A135-4044C2B715B1@azul.com>
 <CAKOF6964=goQLu+R6Moiq1Qrh6f_Tg3rGs4Pr80ZrVcTpLhGew@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
Message-ID: <CAHjP37HHWz_J0MW=s59SX9DMLmnBW87u8fysfAeBW9zJp2_zyg@mail.gmail.com>

Integer and friends have public constructors, so they can't really be value
based classes to begin with (at least as far as value based is defined).

But beside that, value based class warnings are really the same thing as
the warnings with regard to autoboxing and the box cache in the JDK, except
value based permits *all* instances to be cached, and since there's no way
to create your own (short of reflection and the like), there's no defined
identity.

I think once VT are introduced, the simplest and most straightforward
approach is to forbid those types from participating in generic methods
where T can be a VT (ie T must be a class/ref type).

On Tue, Jul 11, 2017 at 12:24 PM Gil Tene <gil at azul.com> wrote:

>
> > On Jul 10, 2017, at 2:53 AM, Aleksey Shipilev <shade at redhat.com> wrote:
> >
> > On 07/10/2017 11:22 AM, Andrew Haley wrote:
> >> Indeed.  I already quoted the language in the JLS I'm relying on, and
> >> said that I find it convincing.  I believe that 15.21.3, "Reference
> >> Equality Operators == and !=" would have to be changed in order for
> >> your interpretation of reference equality to be correct.
> >>
> >> So let's move on to another matter, the JVM specification, and the way
> >> that Java maps on to the JVM.  In the JVM, the instruction if_acmpeq
> >> is supposed to return true if value1 = value2.  So,
> >>
> >>   dup; if_acmpeq
> >>
> >> is bound to succeed.
> >>
> >> You could argue that it is theoretically possible that Java could be
> >> compiled onto the JVM in some other way, so that your interpretation
> >> of the JLS would be correct, but I don't think it's much to worry
> >> about.  You could also argue that the section which describes
> >> value-based classes implicitly changes the JVM specification, but I'd
> >> like to see that in writing.
> >
> > I remember this was the early confusion with lambdas, which had the
> relaxed
> > notion of identity too. And there was the same confusion of "OMG, I can
> get the
> > exception doing '==' on lambda?!". But that only extended to "you don't
> know
> > what would the evaluation result of lambda expression be: it might be
> equal to
> > something else, or not".
> >
> > That is:
> >
> >  Runnable r1 = () -> {};
> >  Runnable r2 = () -> {};
> >  assert (r1 == r2);                       // deliberately unspecified
> >  assert (r1.getClass() == r2.getClass()); // deliberately unspecified
> >  assert (r1 == r1);                       // keeps being true!
> >  assert (r2 == r2);                       // keeps being true!
> >  assert (r1.getClass() == r1.getClass()); // keeps being true!
> >  assert (r2.getClass() == r2.getClass()); // keeps being true!
>
> The [very important] difference is that Runnable is NOT a value-based
> class. But Instant is. Runnable never said anything about the use of
> identity resulting in unpredictable effects, Instant does. Runnable never
> said anything about being allowed to be freely substitute with other
> Runnables that are .equals() in any computation. Instant does.
>
> To test the notion that == "means what you think it means" in some places.
> Lets take your example a couple of steps farther:
>
> Class AnnotatedTime {
>       String annotation;
>       long secondsSinceEpoch;
>       long nanosInSecond;
>       Instant instant;
>
>       boolean isExactSameInstant(Instant other) {
>            return (instant == other);
>       }
>  }
>
>  HashMap<Long, Instant > instanceCache = new HashMap<>();
>
>  Instant i1 = Instance.ofEpochSecond(1000);
>  Instant i2 = Instance.ofEpochSecond(1000);
>
>  AnnotatedTimes annotatedTime = new AnnotatedTime();
>  annotatedTime1.annotation = "Time at 1000";
>  annotatedTime1. secondsSinceEpoch = 1000;
>  annotatedTime1. instant = i1;
>
>  instanceCache.put(1000L, i1);
>
>  A. (i1 == i2)  // We all agree it may be true or false depending on
> implementation details
>  B. (i1 == i1)  // You say it must remain true. I say it could validly be
> false. This is a computation of a boolean expression.
>  C. (i1 == annotatedTime. instant) // You say this must be true as well??
>  D. (annotatedTime1.isExactSameInstant(i1)) // Is this required to be true?
>  E. (i1 == instanceCache.get(1000L)) // And this must also be true??
>
> If you say that B,C,D,E must all be true (which would presumably be
> self-consistent), you are basically saying that even tho the spec says so,
> Instant cannot be freely replaced with other Instants that are .equals()
> with it in computations and method invocations. At that point, nothing
> distinguishes a value-based class from a regular class that is immutable.
> E.g. Instant and Integer have the same defined behavior according to this
> interpretation, and all mention of a value-based class in the spec is
> basically a no-op.
>
> If you say e.g. that B must be true but either C, D, or E doesn't have to
> be true. Where do you draw the line? Is it at local variables vs. heap
> storage? Is it in parameter passing? What things are allowed to freely
> replace one Instant with some other Instant that is .equals() to it, and
> what things aren't?
>
> Note that long-standing immutable classes with clean .equals() and
> hashcode behaviors (like Integer, Long, etc.) have not been specified to be
> value-based classes. Presumably due to historical compatibility reasons,
> since the identity of instances of those classes certainly carries meaning,
> and B-E above would all have to be true for them. In contrast, all current
> classes that are defined as value-based classes have been defined so from
> their inception. If you want to interpret the specification of value-based
> classes as not contradicting the behavior of e.g. Integer, why the
> definition? And why is Integer NOT a value-based class?
>
> >
> > I think that for value objects, whether they are really implemented on
> JVM, or
> > they are just declared in Javadoc, the same thing applies. This stance
> in docs
> > is the key: "[Value-based classes:] - do not have accessible
> constructors, but
> > are instead instantiated through factory methods which make no
> committment as to
> > the identity of returned instances;". The rest of the properties seem to
> be
> > derived from that unreliable identity.
> >
> > In other words, "no commitment" reads as "identity is unknown" rather
> than
> > "identity is non-existent". Unknown identity is still reflexive,
> symmetric,
> > transitive. The identity of the value type *box* that you get from the
> > expression should be deliberately unspecified to provide implementation
> freedom,
> > but once you get the boxed reference, it is bound by the same JLS rules
> Andrew
> > quotes.
> >
> > In yet other words, "value-based class" tells to be careful about the
> identity
> > semantics of producing expressions, but it does not relax the semantics
> of the
> > boxed references you get from them either explicitly or implicitly. This
> is
> > pretty much like current primitive autoboxing works :)
> >
> > Thanks,
> > -Aleksey
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/eb8e61f3/attachment-0001.html>

From shade at redhat.com  Tue Jul 11 13:30:04 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 11 Jul 2017 19:30:04 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
Message-ID: <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>

On 07/11/2017 06:22 PM, Gil Tene wrote:
> To test the notion that == "means what you think it means" in some places.
> Lets take your example a couple of steps farther:

> Class AnnotatedTime {
>       String annotation;
>       long secondsSinceEpoch;
>       long nanosInSecond;
>       Instant instant;
> 
>       boolean isExactSameInstant(Instant other) {
>            return (instant == other);
>       }
>  }
> 
>  HashMap<Long, Instant > instanceCache = new HashMap<>();
> 
>  Instant i1 = Instance.ofEpochSecond(1000);
>  Instant i2 = Instance.ofEpochSecond(1000);
>  
>  AnnotatedTimes annotatedTime = new AnnotatedTime();
>  annotatedTime1.annotation = "Time at 1000"; 
>  annotatedTime1. secondsSinceEpoch = 1000;
>  annotatedTime1. instant = i1;
> 
>  instanceCache.put(1000L, i1);
> 
>  A. (i1 == i2)  // We all agree it may be true or false depending on implementation details

Yup.

> B. (i1 == i1)  // You say it must remain true. I say it could validly be
> false. This is a computation of a boolean expression.
I assume you have a highly-paid language lawyer on retainer than could justify
this :) I do think that referential equality stays reflexive, no matter the
nature of reference you are comparing.

The reflexivity seems to come from reference equality operator definition in
15.21.3: "At run time, the result of == is true if the operand values are both
null or both refer to the same object or array; otherwise, the result is false".
I have a hard time coming up with a definition of "same" that is not reflexive.
Can you do it?

The only way out from here is to claim that either == is not reference
comparison, or there is some sort of conversion is taking place before ==. This
is the case for auto-boxed primitives, for example. For Instant case, you cannot
claim either: it is a reference type, and reference comparisons do not need
conversions.

I guess "real" value types, if implemented, would experience this:

 MyValueType v1; // <--- *not* a reference type

 // if "==" is a value comparison, should pass
 // if "==" is a reference comparison, *and* prior boxing, may fail
 assert(v1 == v1);

In fact, spec may be allowed to produce new instance on every single boxing.
Which will render reference CAS -- that requires boxing -- useless, if that what
OP originally asked.

But, there are no non-reference types yet, except for primitives, which makes
this construction moot for all Java's up to and including 9.

>  C. (i1 == annotatedTime. instant) // You say this must be true as well??

Yes, because it compares the reference to the same object.

>  D. (annotatedTime1.isExactSameInstant(i1)) // Is this required to be true?

Yes, because it compares the reference to the same object.

>  E. (i1 == instanceCache.get(1000L)) // And this must also be true??

Yes, because it compares the reference to the same object.


> If you say that B,C,D,E must all be true (which would presumably be
> self-consistent), you are basically saying that even tho the spec says so,
> Instant cannot be freely replaced with other Instants that are .equals() with
> it in computations and method invocations. At that point, nothing
> distinguishes a value-based class from a regular class that is immutable.
> E.g. Instant and Integer have the same defined behavior according to this
> interpretation, and all mention of a value-based class in the spec is
> basically a no-op.

My interpretation is that "value-based class" today is the property of the
producing expressions -- Instant.ofEpochSecond in this case -- extended to every
producing expression (whether it is a language construct, factory call, etc)
that can give the instance.


> Note that long-standing immutable classes with clean .equals() and hashcode
> behaviors (like Integer, Long, etc.) have not been specified to be
> value-based classes. Presumably due to historical compatibility reasons,
> since the identity of instances of those classes certainly carries meaning,
> and B-E above would all have to be true for them. In contrast, all current
> classes that are defined as value-based classes have been defined so from
> their inception. If you want to interpret the specification of value-based
> classes as not contradicting the behavior of e.g. Integer, why the
> definition? And why is Integer NOT a value-based class?
I think "value-based class" language is provisional for "do not rely on
identity, even if it is defined for the objects you will be getting". Integer,
as you say, have already leaked the identity in public, and we are done there,
the guy is disqualified.

In this parlance, saying "Instant is like primitive/Integer" is far worse
language than actually spelling out the "unknown identity" rules with
"value-based class" text. Having these rules spelled out eases switching them to
real value types, with appropriate spec changes. But, it does not give a blanket
approval for doing so, it just minimizes the damage.

I understand one could claim "JVM is allowed to ignore identity for value-based
classes, because it is claimed to be unpredictable anyway", and probably lawyer
up to say it is spec-legal. Although it would be fun to see the defense where
Javadoc trumps the core JLS.

Still, I think the interpretation of "identity stays unknown, but still behaves
like an object" is saner from quality of implementation, principle of least
astonishment, "don't break Java" standpoints.

How will Valhalla deal with these problems, we shall see. My bet is on
value-type-specific comparisons (which should catch CAS in its wake), plus
boxing where the references are needed (which would capitalize on what we
learned to love about Java's primitives).

I think this CAS example is interesting to discuss in valhalla-dev@, where it
actually matters, not here.

Thanks,
-Aleksey



-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/3645a0c6/attachment.sig>

From shade at redhat.com  Tue Jul 11 13:48:36 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 11 Jul 2017 19:48:36 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
Message-ID: <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>

On 07/11/2017 07:30 PM, Aleksey Shipilev wrote:
> How will Valhalla deal with these problems, we shall see. My bet is on
> value-type-specific comparisons (which should catch CAS in its wake), plus
> boxing where the references are needed (which would capitalize on what we
> learned to love about Java's primitives).

Ah, quoting http://cr.openjdk.java.net/~jrose/values/values-0.html:

"Many of the above restrictions correspond to the restrictions on so-called
value-based classes. In fact, it seems likely that the boxed form of every value
type will be a value-based class."

So this seems to imply that identity-wise:
  "value type" < "value-based class" < "ordinary class".

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/8967eb71/attachment.sig>

From dl at cs.oswego.edu  Tue Jul 11 13:55:14 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 11 Jul 2017 13:55:14 -0400
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
Message-ID: <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>

On 07/11/2017 01:48 PM, Aleksey Shipilev wrote:
> 
> Ah, quoting http://cr.openjdk.java.net/~jrose/values/values-0.html:
> 
> "Many of the above restrictions correspond to the restrictions on so-called
> value-based classes. In fact, it seems likely that the boxed form of every value
> type will be a value-based class."
> 
> So this seems to imply that identity-wise:
>   "value type" < "value-based class" < "ordinary class".
> 

Yes, thanks for nicely capturing what Remy and I were trying to get
across last week. My understanding of Gil's suggestions
about treating value-based class as values is that they are only
valid if a compiler does enough global analysis to be sure there
is no possible reliance on identity (including ==).

-Doug





From oleksandr.otenko at gmail.com  Tue Jul 11 14:15:39 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 11 Jul 2017 19:15:39 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
Message-ID: <540FBA1F-8C80-4C47-B4FB-3CF57B29E8F5@gmail.com>


> On 11 Jul 2017, at 18:30, Aleksey Shipilev <shade at redhat.com> wrote:
>> ...
> I think "value-based class" language is provisional for "do not rely on
> identity, even if it is defined for the objects you will be getting". Integer,
> as you say, have already leaked the identity in public, and we are done there,
> the guy is disqualified.
> 
> In this parlance, saying "Instant is like primitive/Integer" is far worse
> language than actually spelling out the "unknown identity" rules with

Spelling out “unknown identity” is like “we don’t really know what we are doing”.

There is no similar problem with Integer, but not because of “public constructors”. It is because there is a clear separation between boxed context (Integer a), and unboxed context (int a).

The reference Remi quoted a few days ago is also more sensible than what we are talking about here. Even though I don’t like the language, clearly there’s a notion of boxing-unboxing instructions. Clearly, there are meant to be rules about where those instructions can and cannot go. Those rules determine the meaning of “==“.

I will expect the variable that is not assigned a different value to retain its “identity” within the lexical scope of the value’s visibility.

I will expect there will be no heisen-boxing - replacing unboxed values with boxed values, when the value is still observed in the lexical scope.


Alex

> "value-based class" text. Having these rules spelled out eases switching them to
> real value types, with appropriate spec changes. But, it does not give a blanket
> approval for doing so, it just minimizes the damage.
> 
> I understand one could claim "JVM is allowed to ignore identity for value-based
> classes, because it is claimed to be unpredictable anyway", and probably lawyer
> up to say it is spec-legal. Although it would be fun to see the defense where
> Javadoc trumps the core JLS.
> 
> Still, I think the interpretation of "identity stays unknown, but still behaves
> like an object" is saner from quality of implementation, principle of least
> astonishment, "don't break Java" standpoints.
> 
> How will Valhalla deal with these problems, we shall see. My bet is on
> value-type-specific comparisons (which should catch CAS in its wake), plus
> boxing where the references are needed (which would capitalize on what we
> learned to love about Java's primitives).
> 
> I think this CAS example is interesting to discuss in valhalla-dev@, where it
> actually matters, not here.
> 
> Thanks,
> -Aleksey
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/15847274/attachment-0001.html>

From gil at azul.com  Tue Jul 11 14:22:51 2017
From: gil at azul.com (Gil Tene)
Date: Tue, 11 Jul 2017 18:22:51 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
Message-ID: <3E962C4F-FD9E-44F4-AE08-539B42848D96@azul.com>


> On Jul 11, 2017, at 10:30 AM, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 07/11/2017 06:22 PM, Gil Tene wrote:
>> To test the notion that == "means what you think it means" in some places.
>> Lets take your example a couple of steps farther:
> 
>> Class AnnotatedTime {
>>      String annotation;
>>      long secondsSinceEpoch;
>>      long nanosInSecond;
>>      Instant instant;
>> 
>>      boolean isExactSameInstant(Instant other) {
>>           return (instant == other);
>>      }
>> }
>> 
>> HashMap<Long, Instant > instanceCache = new HashMap<>();
>> 
>> Instant i1 = Instance.ofEpochSecond(1000);
>> Instant i2 = Instance.ofEpochSecond(1000);
>> 
>> AnnotatedTimes annotatedTime = new AnnotatedTime();
>> annotatedTime1.annotation = "Time at 1000"; 
>> annotatedTime1. secondsSinceEpoch = 1000;
>> annotatedTime1. instant = i1;
>> 
>> instanceCache.put(1000L, i1);
>> 
>> A. (i1 == i2)  // We all agree it may be true or false depending on implementation details
> 
> Yup.
> 
>> B. (i1 == i1)  // You say it must remain true. I say it could validly be
>> false. This is a computation of a boolean expression.
> I assume you have a highly-paid language lawyer on retainer than could justify
> this :) I do think that referential equality stays reflexive, no matter the
> nature of reference you are comparing.
> 
> The reflexivity seems to come from reference equality operator definition in
> 15.21.3: "At run time, the result of == is true if the operand values are both
> null or both refer to the same object or array; otherwise, the result is false".
> I have a hard time coming up with a definition of "same" that is not reflexive.
> Can you do it?

identityHash and synchronized have similarly strong behavior expectations when performed on the same object. If we say that the notion of "same object" applies to instances value based classes when evaluating ==, are we also saying that it also applies to synchronized and identityHash? [It must be. What's the alternative?]

> 
> The only way out from here is to claim that either == is not reference
> comparison, or there is some sort of conversion is taking place before ==.

Value-purists might argue that == on a value based class is not a reference comparison because a field "referring" to an instance of value based class is not a reference. I'm not quite that pure tho.

I'd rely on ""Instances of a value-based class… are freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior.".

So while you have a reference to an object that is an instance of a value based class, any use of that reference can include replacing the value you just read from the [field or variable] with some other (potentially !=) logical reference that is .equals() to the one being replaced. There is no way to write a == expression on references to value based objects and know that the references are to "the same object", since the value on either side of the == operations can be freely substituted with something else before the == is evaluated. Same for when you store a value in a field (what you store could be the substituted value), or pass a parameter to a method (what you pass could be substituted). This consistently applies to identityHash() (the "this" passed to identityHash() could be substituted) and the synchronized(instant)...

I seem to claim that instances of value based classes can be freely substituted (with a .equals() instance) in pretty much any expression that explicitly operates on a value based class type. [I also separately think that when expressions operate purely on Object types (and not explicitly on a value based class type) this substitution is not allowed,  even when the Object instance happens to be a value based class. The two statements can validly co-exist IMO]. 

You seem to claim that substitution is not allowed in expressions (in spite of spec statement), but that separately executing expressions that create new instances with the "same" (.equals()) value do not have to produce the same (==) object instance.

So, are there expressions on explicitly-typed-as-value-based-class things where instance substitution is not allowed in spite of the value-based class specification statements? (Your answer will probably be "still not allowed in ANY expressions", my answer is "I think it's allowed in ALL expressions as long as the type is explicitly a value based class". Maybe there are some where is and some where it isn't?)

> This
> is the case for auto-boxed primitives, for example. For Instant case, you cannot
> claim either: it is a reference type, and reference comparisons do not need
> conversions.
> 
> I guess "real" value types, if implemented, would experience this:
> 
> MyValueType v1; // <--- *not* a reference type
> 
> // if "==" is a value comparison, should pass
> // if "==" is a reference comparison, *and* prior boxing, may fail
> assert(v1 == v1);
> 
> In fact, spec may be allowed to produce new instance on every single boxing.
> Which will render reference CAS -- that requires boxing -- useless, if that what
> OP originally asked.
> 
> But, there are no non-reference types yet, except for primitives, which makes
> this construction moot for all Java's up to and including 9.
> 
>> C. (i1 == annotatedTime. instant) // You say this must be true as well??
> 
> Yes, because it compares the reference to the same object.
> 
>> D. (annotatedTime1.isExactSameInstant(i1)) // Is this required to be true?
> 
> Yes, because it compares the reference to the same object.
> 
>> E. (i1 == instanceCache.get(1000L)) // And this must also be true??
> 
> Yes, because it compares the reference to the same object.
> 
> 
>> If you say that B,C,D,E must all be true (which would presumably be
>> self-consistent), you are basically saying that even tho the spec says so,
>> Instant cannot be freely replaced with other Instants that are .equals() with
>> it in computations and method invocations. At that point, nothing
>> distinguishes a value-based class from a regular class that is immutable.
>> E.g. Instant and Integer have the same defined behavior according to this
>> interpretation, and all mention of a value-based class in the spec is
>> basically a no-op.
> 
> My interpretation is that "value-based class" today is the property of the
> producing expressions -- Instant.ofEpochSecond in this case -- extended to every
> producing expression (whether it is a language construct, factory call, etc)
> that can give the instance.
> 
> 
>> Note that long-standing immutable classes with clean .equals() and hashcode
>> behaviors (like Integer, Long, etc.) have not been specified to be
>> value-based classes. Presumably due to historical compatibility reasons,
>> since the identity of instances of those classes certainly carries meaning,
>> and B-E above would all have to be true for them. In contrast, all current
>> classes that are defined as value-based classes have been defined so from
>> their inception. If you want to interpret the specification of value-based
>> classes as not contradicting the behavior of e.g. Integer, why the
>> definition? And why is Integer NOT a value-based class?
> I think "value-based class" language is provisional for "do not rely on
> identity, even if it is defined for the objects you will be getting". Integer,
> as you say, have already leaked the identity in public, and we are done there,
> the guy is disqualified.
> 
> In this parlance, saying "Instant is like primitive/Integer" is far worse
> language than actually spelling out the "unknown identity" rules with
> "value-based class" text. Having these rules spelled out eases switching them to
> real value types, with appropriate spec changes. But, it does not give a blanket
> approval for doing so, it just minimizes the damage.
> 
> I understand one could claim "JVM is allowed to ignore identity for value-based
> classes, because it is claimed to be unpredictable anyway", and probably lawyer
> up to say it is spec-legal. Although it would be fun to see the defense where
> Javadoc trumps the core JLS.
> 
> Still, I think the interpretation of "identity stays unknown, but still behaves
> like an object" is saner from quality of implementation, principle of least
> astonishment, "don't break Java" standpoints.
> 
> How will Valhalla deal with these problems, we shall see. My bet is on
> value-type-specific comparisons (which should catch CAS in its wake), plus
> boxing where the references are needed (which would capitalize on what we
> learned to love about Java's primitives).
> 
> I think this CAS example is interesting to discuss in valhalla-dev@, where it
> actually matters, not here.
> 
> Thanks,
> -Aleksey
> 
> 
> 


From gil at azul.com  Tue Jul 11 14:32:08 2017
From: gil at azul.com (Gil Tene)
Date: Tue, 11 Jul 2017 18:32:08 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <540FBA1F-8C80-4C47-B4FB-3CF57B29E8F5@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <540FBA1F-8C80-4C47-B4FB-3CF57B29E8F5@gmail.com>
Message-ID: <BFE9E53D-7E6E-46C7-A96A-377B4FC47EBB@azul.com>


On Jul 11, 2017, at 11:15 AM, Alex Otenko <oleksandr.otenko at gmail.com<mailto:oleksandr.otenko at gmail.com>> wrote:


On 11 Jul 2017, at 18:30, Aleksey Shipilev <shade at redhat.com<mailto:shade at redhat.com>> wrote:
...
I think "value-based class" language is provisional for "do not rely on
identity, even if it is defined for the objects you will be getting". Integer,
as you say, have already leaked the identity in public, and we are done there,
the guy is disqualified.

In this parlance, saying "Instant is like primitive/Integer" is far worse
language than actually spelling out the "unknown identity" rules with

Spelling out “unknown identity” is like “we don’t really know what we are doing”.

There is no similar problem with Integer, but not because of “public constructors”. It is because there is a clear separation between boxed context (Integer a), and unboxed context (int a).

The reference Remi quoted a few days ago is also more sensible than what we are talking about here. Even though I don’t like the language, clearly there’s a notion of boxing-unboxing instructions. Clearly, there are meant to be rules about where those instructions can and cannot go. Those rules determine the meaning of “==“.

I will expect the variable that is not assigned a different value to retain its “identity” within the lexical scope of the value’s visibility.

I will expect there will be no heisen-boxing - replacing unboxed values with boxed values, when the value is still observed in the lexical scope.

Does this means that you draw the line between local variables and heap storage (in e.g. fields or array elements)? As in:

B. (i1 == i1)  // always true
C. (i1 == annotatedTime. instant) // May be true or false
D. (annotatedTime1.isExactSameInstant(i1)) // May be true or false
E. (i1 == instanceCache.get(1000L)) // May be true or false

That's interesting, as it can probably work ok. But it's probably hard to explain (can be freely substituted when reading from or writing to fields, but not in reading from or writing to local variables) …



Alex

"value-based class" text. Having these rules spelled out eases switching them to
real value types, with appropriate spec changes. But, it does not give a blanket
approval for doing so, it just minimizes the damage.

I understand one could claim "JVM is allowed to ignore identity for value-based
classes, because it is claimed to be unpredictable anyway", and probably lawyer
up to say it is spec-legal. Although it would be fun to see the defense where
Javadoc trumps the core JLS.

Still, I think the interpretation of "identity stays unknown, but still behaves
like an object" is saner from quality of implementation, principle of least
astonishment, "don't break Java" standpoints.

How will Valhalla deal with these problems, we shall see. My bet is on
value-type-specific comparisons (which should catch CAS in its wake), plus
boxing where the references are needed (which would capitalize on what we
learned to love about Java's primitives).

I think this CAS example is interesting to discuss in valhalla-dev@, where it
actually matters, not here.

Thanks,
-Aleksey



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/13e7e1d9/attachment-0001.html>

From oleksandr.otenko at gmail.com  Tue Jul 11 14:52:14 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 11 Jul 2017 19:52:14 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <BFE9E53D-7E6E-46C7-A96A-377B4FC47EBB@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <FFC15F26-2AD3-46FB-A10B-F18FD5E2B27D@azul.com>
 <97B9BC35-62C2-4EB9-9224-6FA56D38A7A9@gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <540FBA1F-8C80-4C47-B4FB-3CF57B29E8F5@gmail.com>
 <BFE9E53D-7E6E-46C7-A96A-377B4FC47EBB@azul.com>
Message-ID: <6CC7F433-1D03-4651-A139-5619B65E8DF7@gmail.com>

No, I draw a line around the visibility of assignments. If no assignment is in the code, the identity should not change - whether it is a reference equality, or bitwise equality of unboxed values.

I don’t pretend to understand the ramifications of this, but it seems the other languages solve this.

Alex

> On 11 Jul 2017, at 19:32, Gil Tene <gil at azul.com> wrote:
> 
>> 
>> On Jul 11, 2017, at 11:15 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>> 
>>> 
>>> On 11 Jul 2017, at 18:30, Aleksey Shipilev <shade at redhat.com <mailto:shade at redhat.com>> wrote:
>>>> ...
>>> I think "value-based class" language is provisional for "do not rely on
>>> identity, even if it is defined for the objects you will be getting". Integer,
>>> as you say, have already leaked the identity in public, and we are done there,
>>> the guy is disqualified.
>>> 
>>> In this parlance, saying "Instant is like primitive/Integer" is far worse
>>> language than actually spelling out the "unknown identity" rules with
>> 
>> Spelling out “unknown identity” is like “we don’t really know what we are doing”.
>> 
>> There is no similar problem with Integer, but not because of “public constructors”. It is because there is a clear separation between boxed context (Integer a), and unboxed context (int a).
>> 
>> The reference Remi quoted a few days ago is also more sensible than what we are talking about here. Even though I don’t like the language, clearly there’s a notion of boxing-unboxing instructions. Clearly, there are meant to be rules about where those instructions can and cannot go. Those rules determine the meaning of “==“.
>> 
>> I will expect the variable that is not assigned a different value to retain its “identity” within the lexical scope of the value’s visibility.
>> 
>> I will expect there will be no heisen-boxing - replacing unboxed values with boxed values, when the value is still observed in the lexical scope.
> 
> Does this means that you draw the line between local variables and heap storage (in e.g. fields or array elements)? As in:
> 
> B. (i1 == i1)  // always true
> C. (i1 == annotatedTime. instant) // May be true or false
> D. (annotatedTime1.isExactSameInstant(i1)) // May be true or false
> E. (i1 == instanceCache.get(1000L)) // May be true or false
> 
> That's interesting, as it can probably work ok. But it's probably hard to explain (can be freely substituted when reading from or writing to fields, but not in reading from or writing to local variables) …
> 
>> 
>> 
>> Alex
>> 
>>> "value-based class" text. Having these rules spelled out eases switching them to
>>> real value types, with appropriate spec changes. But, it does not give a blanket
>>> approval for doing so, it just minimizes the damage.
>>> 
>>> I understand one could claim "JVM is allowed to ignore identity for value-based
>>> classes, because it is claimed to be unpredictable anyway", and probably lawyer
>>> up to say it is spec-legal. Although it would be fun to see the defense where
>>> Javadoc trumps the core JLS.
>>> 
>>> Still, I think the interpretation of "identity stays unknown, but still behaves
>>> like an object" is saner from quality of implementation, principle of least
>>> astonishment, "don't break Java" standpoints.
>>> 
>>> How will Valhalla deal with these problems, we shall see. My bet is on
>>> value-type-specific comparisons (which should catch CAS in its wake), plus
>>> boxing where the references are needed (which would capitalize on what we
>>> learned to love about Java's primitives).
>>> 
>>> I think this CAS example is interesting to discuss in valhalla-dev@, where it
>>> actually matters, not here.
>>> 
>>> Thanks,
>>> -Aleksey
>>> 
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/7092c78d/attachment.html>

From shade at redhat.com  Tue Jul 11 15:01:11 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 11 Jul 2017 21:01:11 +0200
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <3E962C4F-FD9E-44F4-AE08-539B42848D96@azul.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <C3D14939-1E63-478C-BD66-8BAF0508667B@azul.com>
 <E5636FDF-C0EC-47B6-B694-379B6C38CEFD@gmail.com>
 <32F15738E8E5524DA4F01A0FA4A8E49001177A29BA@daeexmbx1.eur.ad.sag>
 <6A912B46-A40B-4616-BDB1-CCFF8CCDFE59@gmail.com>
 <3A75F5B4-949F-4578-9577-5779DE07B9FB@azul.com>
 <3f7c5c53-d653-a9db-a5f4-0d9aef7c6af0@redhat.com>
 <1D8785D4-018F-4205-8A34-327F0FBCC546@azul.com>
 <EB34BF86-15AC-42AE-A25F-9C1BF71A9A12@kodewerk.com>
 <5DAE0058-289A-4B3F-9E72-3D6D2DABB152@azul.com>
 <902AA8CC-22A1-4932-BBE4-54AB4616BF99@gmail.com>
 <E4EE9375-6812-4E95-9CC1-B0B88A212D1F@azul.com>
 <30e1f56d-9d35-7245-046f-d21e64c5355d@redhat.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <3E962C4F-FD9E-44F4-AE08-539B42848D96@azul.com>
Message-ID: <c9d61cb9-5dcd-2b21-73af-2e05e66de2b4@redhat.com>

On 07/11/2017 08:22 PM, Gil Tene wrote:
> identityHash and synchronized have similarly strong behavior expectations 
> when performed on the same object. If we say that the notion of "same object"
> applies to instances value based classes when evaluating ==, are we also
> saying that it also applies to synchronized and identityHash? [It must be.
> What's the alternative?]

Yes. You can get the instance of reference type, share it around, and it should
be fine: synchronized should work, identity hash code has to stay consistent. It
is irrelevant if that instance if the instance of value-based class or not.

What matters is that is _still_ a reference to an object, with all the
associated baggage. Which sucks. This is why you want value types in the
*language spec* that would make something that is not a reference type, and not
the primitive available at your disposal.


>> The only way out from here is to claim that either == is not reference
>> comparison, or there is some sort of conversion is taking place before ==.
> 
> Value-purists might argue that == on a value based class is not a reference 
> comparison because a field "referring" to an instance of value based class is
> not a reference. I'm not quite that pure tho.

Well, they can have their own non-compliant JVM then, because they ignore what
spec says "==" is, and come up with some interesting non-reference non-primitive
entity that is never mentioned in the language ;)


> I'd rely on ""Instances of a value-based class… are freely substitutable when
> equal, meaning that interchanging any two instances x and y that are equal
> according to equals() in any computation or method invocation should produce
> no visible change in behavior.".

Don't forget a *plus*, and this is a very large PLUS: behaviors with
identity-sensitive operations are unpredictable. Do I summarize it right that we
are arguing about what is the allowed behavior in the grey area of
"unpredictable behavior with identity-sensitive operations"?

You seem to claim that since identity-sensitive operations are unpredictable for
value-based classes, you might as well substitute instances. I seem to claim
that even the basic reflexivity rule in reference == prevents automatic
substitution, once the instance was created. You can play trick when creating
value-based class instances, though, and that's the freedom that definition
gives implementors. Once the instance is created, the ship had sailed.

Even if your claim is technically correct, and true in letter of the spec (which
I am still not sure about), I think it contradicts the spirit of it, which is:
  - value types have no identity
  - value-based classes have unknown (still stable) identity
  - ordinary classes have known and stable identity

Value-based classes seem to be more of the library construct, that specifies the
overarching contract for any factory or method that creates them.

Value-based classes are the middle-ground between value types and ordinary
classes. They still are reference types. Their properties are almost as if they
are value types -- which might trip someone into believing they actually are --
but not quite, they differ in identity/nullability/etc properties.

I see no point in discussing this further without the actual language lawyers (I
think at valhalla- or somewhere-else-dev-).

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170711/a2575757/attachment-0001.sig>

From forax at univ-mlv.fr  Tue Jul 11 15:07:21 2017
From: forax at univ-mlv.fr (Remi Forax)
Date: Tue, 11 Jul 2017 21:07:21 +0200 (CEST)
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
Message-ID: <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>

----- Mail original -----
> De: "Doug Lea" <dl at cs.oswego.edu>
> À: concurrency-interest at cs.oswego.edu
> Envoyé: Mardi 11 Juillet 2017 19:55:14
> Objet: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?

> On 07/11/2017 01:48 PM, Aleksey Shipilev wrote:
>> 
>> Ah, quoting http://cr.openjdk.java.net/~jrose/values/values-0.html:
>> 
>> "Many of the above restrictions correspond to the restrictions on so-called
>> value-based classes. In fact, it seems likely that the boxed form of every value
>> type will be a value-based class."
>> 
>> So this seems to imply that identity-wise:
>>   "value type" < "value-based class" < "ordinary class".
>> 
> 
> Yes, thanks for nicely capturing what Remy and I were trying to get
> across last week. My understanding of Gil's suggestions
> about treating value-based class as values is that they are only
> valid if a compiler does enough global analysis to be sure there
> is no possible reliance on identity (including ==).

It's more:
"value type" -> acts as real values, boxing on stack may occur in the interpreter but it's transparent because value types are non mutable.
"value-based class" / "value capable class" -> boxed by default, can be unboxed by the JIT and re-boxed at the edge by partial escape analysis, so == may compare different boxes.
"ordinary class" -> can be unboxed by escape analysis but it has to be pessimistic, i.e. need to be sure that no code contains a ==.

and for the astute reader, which kind of type is java.lang.Integer ?

> 
> -Doug

Rémi

From scolebourne at joda.org  Wed Jul 12 06:15:13 2017
From: scolebourne at joda.org (Stephen Colebourne)
Date: Wed, 12 Jul 2017 11:15:13 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
 <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
Message-ID: <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>

As the author of Instant, what I would really like is for == to mean
.equals(). Of course I might not get my wish.
Stephen


On 11 July 2017 at 20:07, Remi Forax <forax at univ-mlv.fr> wrote:
> ----- Mail original -----
>> De: "Doug Lea" <dl at cs.oswego.edu>
>> À: concurrency-interest at cs.oswego.edu
>> Envoyé: Mardi 11 Juillet 2017 19:55:14
>> Objet: Re: [concurrency-interest] Should I avoid compareAndSet with value-based classes?
>
>> On 07/11/2017 01:48 PM, Aleksey Shipilev wrote:
>>>
>>> Ah, quoting http://cr.openjdk.java.net/~jrose/values/values-0.html:
>>>
>>> "Many of the above restrictions correspond to the restrictions on so-called
>>> value-based classes. In fact, it seems likely that the boxed form of every value
>>> type will be a value-based class."
>>>
>>> So this seems to imply that identity-wise:
>>>   "value type" < "value-based class" < "ordinary class".
>>>
>>
>> Yes, thanks for nicely capturing what Remy and I were trying to get
>> across last week. My understanding of Gil's suggestions
>> about treating value-based class as values is that they are only
>> valid if a compiler does enough global analysis to be sure there
>> is no possible reliance on identity (including ==).
>
> It's more:
> "value type" -> acts as real values, boxing on stack may occur in the interpreter but it's transparent because value types are non mutable.
> "value-based class" / "value capable class" -> boxed by default, can be unboxed by the JIT and re-boxed at the edge by partial escape analysis, so == may compare different boxes.
> "ordinary class" -> can be unboxed by escape analysis but it has to be pessimistic, i.e. need to be sure that no code contains a ==.
>
> and for the astute reader, which kind of type is java.lang.Integer ?
>
>>
>> -Doug
>
> Rémi
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From kirk at kodewerk.com  Wed Jul 12 06:18:16 2017
From: kirk at kodewerk.com (Kirk Pepperdine)
Date: Wed, 12 Jul 2017 13:18:16 +0300
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
 <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
 <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>
Message-ID: <2E6C990B-9550-4AE9-9724-96953CD38FA4@kodewerk.com>


> On Jul 12, 2017, at 1:15 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
> 
> As the author of Instant, what I would really like is for == to mean
> .equals().

Really? There is a definitive semantic difference between == and equals() and I’m trying to sort out why anyone would want to confuse them.

Kind regards,
Kirk


From oleksandr.otenko at gmail.com  Wed Jul 12 06:44:59 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Wed, 12 Jul 2017 11:44:59 +0100
Subject: [concurrency-interest] Should I avoid compareAndSet with
	value-based classes?
In-Reply-To: <2E6C990B-9550-4AE9-9724-96953CD38FA4@kodewerk.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
 <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
 <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>
 <2E6C990B-9550-4AE9-9724-96953CD38FA4@kodewerk.com>
Message-ID: <975F0181-88DE-4EFF-9546-853B88E4A1A5@gmail.com>

That shouldn’t be a problem for some well-behaving types. Immutable types certainly could behave like that - that’s the behaviour when there is a single instance for any value.

Since there is never a “direct” way to CAS values, it would be the job of the AtomicFieldUpdater to do “the right thing” for values that are such special values for which people struggle to formulate an uncontentious javadoc about its “==“ and its impact on CAS.

Alex

> On 12 Jul 2017, at 11:18, Kirk Pepperdine <kirk at kodewerk.com> wrote:
> 
> 
>> On Jul 12, 2017, at 1:15 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
>> 
>> As the author of Instant, what I would really like is for == to mean
>> .equals().
> 
> Really? There is a definitive semantic difference between == and equals() and I’m trying to sort out why anyone would want to confuse them.
> 
> Kind regards,
> Kirk
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From nathanila at gmail.com  Wed Jul 12 09:51:19 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Wed, 12 Jul 2017 07:51:19 -0600
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <975F0181-88DE-4EFF-9546-853B88E4A1A5@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
 <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
 <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>
 <2E6C990B-9550-4AE9-9724-96953CD38FA4@kodewerk.com>
 <975F0181-88DE-4EFF-9546-853B88E4A1A5@gmail.com>
Message-ID: <920e4825-ba76-8a27-19ec-4ce5c22614b4@gmail.com>

At first, I thought I wouldn't want == to mean equals(). However, String 
consumes a lot of heap space.  G1 GC already can de-duplicate the 
char[]/byte[] inside String to reduce memory usage.  But, G1 GC can't 
de-duplicate the String objects themselves because it could break code 
which relies on the fact that equals() does not mean ==.  So, if this 
constraint could be relaxed for String, then additional heap savings is 
possible.  If this constraint were relaxed for all immutable classes, 
then additional heap savings is possible but insignificant for the 
general case.

-Nathan

On 7/12/2017 4:44 AM, Alex Otenko wrote:
> That shouldn’t be a problem for some well-behaving types. Immutable types certainly could behave like that - that’s the behaviour when there is a single instance for any value.
>
> Since there is never a “direct” way to CAS values, it would be the job of the AtomicFieldUpdater to do “the right thing” for values that are such special values for which people struggle to formulate an uncontentious javadoc about its “==“ and its impact on CAS.
>
> Alex
>
>> On 12 Jul 2017, at 11:18, Kirk Pepperdine <kirk at kodewerk.com> wrote:
>>
>>
>>> On Jul 12, 2017, at 1:15 PM, Stephen Colebourne <scolebourne at joda.org> wrote:
>>>
>>> As the author of Instant, what I would really like is for == to mean
>>> .equals().
>> Really? There is a definitive semantic difference between == and equals() and I’m trying to sort out why anyone would want to confuse them.
>>
>> Kind regards,
>> Kirk
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From vitalyd at gmail.com  Wed Jul 12 13:11:47 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Wed, 12 Jul 2017 17:11:47 +0000
Subject: [concurrency-interest] Should I avoid compareAndSet with
 value-based classes?
In-Reply-To: <920e4825-ba76-8a27-19ec-4ce5c22614b4@gmail.com>
References: <CAHqckpM7jKPRjybBXMR79fGr9A=KxK7jzcWh6vPDeZpLhOeVpQ@mail.gmail.com>
 <4855064A-EE00-4421-A258-519F38047ACA@azul.com>
 <30a04c94-76b8-f54a-d53c-f893222334d3@redhat.com>
 <38236ea7-6d7a-6a48-d3e5-192bcac828b6@redhat.com>
 <E0466E19-A054-4AA5-A37B-CDD48008F40B@azul.com>
 <b51e8ef1-19a8-aad5-b4f2-07c53d51d9d0@redhat.com>
 <599adb38-91dd-a328-ccf7-b8ae2e91f59d@redhat.com>
 <b305f520-6a81-3653-394e-8a65c1b63d72@cs.oswego.edu>
 <945078079.519702.1499800041530.JavaMail.zimbra@u-pem.fr>
 <CACzrW9Cv-O8Z-O=zJMDZZ=UWAeVXWMYZDkHew4pS3T+_=aFwwQ@mail.gmail.com>
 <2E6C990B-9550-4AE9-9724-96953CD38FA4@kodewerk.com>
 <975F0181-88DE-4EFF-9546-853B88E4A1A5@gmail.com>
 <920e4825-ba76-8a27-19ec-4ce5c22614b4@gmail.com>
Message-ID: <CAHjP37E76KkP=oZy+DQZFM2VzXO4Umpys-huX30Ft-Lbga8KnA@mail.gmail.com>

== vs equals() also has the difference that equals is an implicit null
check.  JIT can optimize around that, but it's an impl detail.  So long as
these value based classes are still reference types (with nullness,
synchronizability, identity), it's not going to work well.

It would've been nice to wait for VT (or have VT a priority for earlier
Java releases) to unleash the java.time, Optional, and the like "properly",
but that ship has sailed.  Commingling true value types with value
based/like classes will result in surprises for Java users.  As I
mentioned, these surprises need to be eliminated at the type system level
where the compiler and verifier refuse bogus code.

On Wed, Jul 12, 2017 at 9:52 AM Nathan and Ila Reynolds <nathanila at gmail.com>
wrote:

> At first, I thought I wouldn't want == to mean equals(). However, String
> consumes a lot of heap space.  G1 GC already can de-duplicate the
> char[]/byte[] inside String to reduce memory usage.  But, G1 GC can't
> de-duplicate the String objects themselves because it could break code
> which relies on the fact that equals() does not mean ==.  So, if this
> constraint could be relaxed for String, then additional heap savings is
> possible.  If this constraint were relaxed for all immutable classes,
> then additional heap savings is possible but insignificant for the
> general case.
>
> -Nathan
>
> On 7/12/2017 4:44 AM, Alex Otenko wrote:
> > That shouldn’t be a problem for some well-behaving types. Immutable
> types certainly could behave like that - that’s the behaviour when there is
> a single instance for any value.
> >
> > Since there is never a “direct” way to CAS values, it would be the job
> of the AtomicFieldUpdater to do “the right thing” for values that are such
> special values for which people struggle to formulate an uncontentious
> javadoc about its “==“ and its impact on CAS.
> >
> > Alex
> >
> >> On 12 Jul 2017, at 11:18, Kirk Pepperdine <kirk at kodewerk.com> wrote:
> >>
> >>
> >>> On Jul 12, 2017, at 1:15 PM, Stephen Colebourne <scolebourne at joda.org>
> wrote:
> >>>
> >>> As the author of Instant, what I would really like is for == to mean
> >>> .equals().
> >> Really? There is a definitive semantic difference between == and
> equals() and I’m trying to sort out why anyone would want to confuse them.
> >>
> >> Kind regards,
> >> Kirk
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> --
> -Nathan
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170712/f1a8341f/attachment.html>

From mayankjain.jain71 at gmail.com  Sun Jul 16 09:54:20 2017
From: mayankjain.jain71 at gmail.com (Mayank jain)
Date: Sun, 16 Jul 2017 19:24:20 +0530
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 150,
	Issue 28
In-Reply-To: <mailman.56.1499498812.6774.concurrency-interest@cs.oswego.edu>
References: <mailman.56.1499498812.6774.concurrency-interest@cs.oswego.edu>
Message-ID: <CAFeG182ecbAxZsFanKxBHWrQ=u1oR=SMgQOwR7Khv_zvHO8t7Q@mail.gmail.com>

On Jul 8, 2017 12:59 PM, <concurrency-interest-request at cs.oswego.edu> wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Re: Should I avoid compareAndSet with value-based classes?
>       (Gil Tene)
>    2. Re: Should I avoid compareAndSet with     value-based classes?
>       (Alex Otenko)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sat, 8 Jul 2017 06:38:53 +0000
> From: Gil Tene <gil at azul.com>
> To: Alex Otenko <oleksandr.otenko at gmail.com>
> Cc: Kirk Pepperdine <kirk at kodewerk.com>, concurrency-interest
>         <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>         value-based classes?
> Message-ID: <E4EE9375-6812-4E95-9CC1-B0B88A212D1F at azul.com>
> Content-Type: text/plain; charset="windows-1252"
>
> Alex, your statements below are all arguments for why value-based classes
> (as specified) and value types (as they seem to be headed) should not exist
> as subclasses of Object. As noted before, I'd probably be on your side if
> that one.
>
> But they do exist, and they (very clearly and explicitly) have no
> identity. We can't change that fact. We can avoid using them if we want.
> But we probably can't use them and argue that what we are using should be
> behaving in some directly-opposite-from-their-specification way.
>
> For vale-based classes, the meaning of  == , identityHashCode, and
> synchronization are all clearly, explicitly and loudly undefined, promising
> unpredictable behavior. For value types it is not yet clear if the ==
> operand will be similarly (explicitly) undefined, or if it will have a new
> meaning (act like == on an int), but things are pretty clear when it comes
> to identityHashCode and synchronization.
>
> The reasoning for these value-based classes and value types goes far
> beyond compiler optimizations. And I'm not the one arguing for them.
>
> My arguments here are not about trying to justify some compiler
> optimizations, or trying to justify the choices of making these things
> subclasses the Object. They are about pointing out the actual meaning of
> things as defined and the (very high risk) of coding against it based on a
> hope that some temporarily observed behavior is actually reliable, when
> everything that describes what it does says otherwise. My mentions of
> potential optimizations are simply attempts to demonstrate how strange
> things can happen to code that does these "may cause unpredictable
> behavior" things.
>
> Sent from my iPad
>
> On Jul 7, 2017, at 4:22 PM, Alex Otenko <oleksandr.otenko at gmail.com<
> mailto:oleksandr.otenko at gmail.com>> wrote:
>
> A type with no identity certainly is a frankentype. I don’t see why the
> poor specification needs to be taken to its extreme interpretation.
> Conceptual clarity is more important than saving CPU cycles.
>
> Having a type that is reified as something that does not have “a unique
> address” in memory (that we understand as the identity of Objects) is
> different from “no identity”.
>
> Being unable to use “value type” instances for synchronization is
> perfectly reasonable - in the end, you aren’t meant to synchronize using
> random objects, and the whole purpose of supporting synchronization on
> every object is to ease construction of thread-safe code (through
> declaration of synchronized methods). If "the thing” is immutable, there is
> no need to support synchronization on those specific instances, and
> choosing such instances as the means of synchronizing something else
> requires justification, even if “the thing” subclasses from Object.
>
> Restricting the meaning of identityHashCode is questionable, but in the
> end hinges on whether “the thing” is a subclass of an Object or not. If it
> is, then there are ways to support identityHashCode - even if there is no
> notion of “a unique address”.
>
> Restricting the use of "==“ because of some compiler optimizations, is
> inventing obstacles. I don’t see why compiler problems of this sort should
> leak into the application programmer’s life, especially in the form of
> RandomExceptions and heisenbugs.
>
>
> Alex
>
>
> On 7 Jul 2017, at 18:32, Gil Tene <gil at azul.com<mailto:gil at azul.com>>
> wrote:
>
>
> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com<mailto:
> kirk at kodewerk.com>> wrote:
>
>
> 3. The exception-throwing thing is IMO the healthy way to go IMO. I.e.
> throw some runtime exception when encountering an indentity-based operation
> on an instance of a value-based class. Hard to argue that "an exception
> should not be thrown here" given the clear warnings in the spec. My worry
> is mostly about coverage. Throwing exceptions in all cases where identity
> based operations are attempted would clearly be right, and healthy. But
> doing so only in some cases (and leaving some undefined behavior executing
> paths that don't throw exceptions) doesn't solve the problem [and may make
> things worse by encouraging false confidence]. Since no one *requires* us
> to throw an exception right now, JVM implementors will probably keep taking
> the lazy approach and not work hard on trying to achieve complete coverage.
> And since don't do it at all" is probably better/easier to verify than "do
> it in some places but not in others", we'll probably avoid it altogether
> for now. This *may* change when value-based optimizations materialize.
>
> I think I’d have to (violently) disagree with this. There is a reason no
> one requires you to throw an exception when expressing equality and that is
> because this is a guaranteed property in the runtime. Without it you lose a
> fundamental property of the runtime.
>
> Synchronous exceptions can be thrown for example because (
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2):
>
>   *   evaluation of an expression violates the normal semantics of the
> Java programming language (§15.6<https://docs.oracle.
> com/javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer
> divide by zero.
>
>   *   an error occurs while loading, linking, or initializing part of the
> program (§12.2<https://docs.oracle.com/javase/specs/jls/se7/html/
> jls-12.html#jls-12.2>, §12.3<https://docs.oracle.com/
> javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4<
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>);
> in this case, an instance of a subclass of LinkageError is thrown.
>
>   *   an internal error or resource limitation prevents the Java Virtual
> Machine from implementing the semantics of the Java programming language;
> in this case, an instance of a subclass of VirtualMethodError is thrown.
> [GT: this is mis-spelled in the spec. Should be VirtualMachineError].
>
> I'd hope to have it qualify under the first bullet, but it is not listed
> in the specific list of runtime exception causes in 15.6. However,
> evaluating an == expression where one of the operands is an instance of a
> value-based class (and has no identity) can probably qualify under "an
> internal error or resource limitation prevents the Java Virtual Machine
> from implementing the semantics of the Java programming language" (third
> bullet). Especially when the Java SE spec explicitly says "Use of such
> identity-sensitive operations on instances of value-based classes may have
> unpredictable effects".
>
> Separately, asynchronous exceptions can be thrown anywhere in the code.
> E.g. An OOME can hit a == point in the code too.
>
> I'd rather not make such exceptions a subclass of VirtualMachineError
> would be better tho...
>
>
> — Kirk
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu<mailto:Concurrency-
> interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-
> interest/attachments/20170708/b22f9b11/attachment-0001.html>
>
> ------------------------------
>
> Message: 2
> Date: Sat, 8 Jul 2017 08:26:46 +0100
> From: Alex Otenko <oleksandr.otenko at gmail.com>
> To: Gil Tene <gil at azul.com>
> Cc: Kirk Pepperdine <kirk at kodewerk.com>, concurrency-interest
>         <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Should I avoid compareAndSet with
>         value-based classes?
> Message-ID: <8FC107D7-28BB-42CA-89C1-4A4DC8A3FCBA at gmail.com>
> Content-Type: text/plain; charset="windows-1252"
>
> Sure, so it should change to a sensible definition. :-)
>
> As such there isn’t even a generic way of determining whether something is
> a "value-based” instance or not - not even at runtime.
>
> Alex
>
> > On 8 Jul 2017, at 07:38, Gil Tene <gil at azul.com> wrote:
> >
> > Alex, your statements below are all arguments for why value-based
> classes (as specified) and value types (as they seem to be headed) should
> not exist as subclasses of Object. As noted before, I'd probably be on your
> side if that one.
> >
> > But they do exist, and they (very clearly and explicitly) have no
> identity. We can't change that fact. We can avoid using them if we want.
> But we probably can't use them and argue that what we are using should be
> behaving in some directly-opposite-from-their-specification way.
> >
> > For vale-based classes, the meaning of  == , identityHashCode, and
> synchronization are all clearly, explicitly and loudly undefined, promising
> unpredictable behavior. For value types it is not yet clear if the ==
> operand will be similarly (explicitly) undefined, or if it will have a new
> meaning (act like == on an int), but things are pretty clear when it comes
> to identityHashCode and synchronization.
> >
> > The reasoning for these value-based classes and value types goes far
> beyond compiler optimizations. And I'm not the one arguing for them.
> >
> > My arguments here are not about trying to justify some compiler
> optimizations, or trying to justify the choices of making these things
> subclasses the Object. They are about pointing out the actual meaning of
> things as defined and the (very high risk) of coding against it based on a
> hope that some temporarily observed behavior is actually reliable, when
> everything that describes what it does says otherwise. My mentions of
> potential optimizations are simply attempts to demonstrate how strange
> things can happen to code that does these "may cause unpredictable
> behavior" things.
> >
> > Sent from my iPad
> >
> > On Jul 7, 2017, at 4:22 PM, Alex Otenko <oleksandr.otenko at gmail.com
> <mailto:oleksandr.otenko at gmail.com>> wrote:
> >
> >> A type with no identity certainly is a frankentype. I don’t see why the
> poor specification needs to be taken to its extreme interpretation.
> Conceptual clarity is more important than saving CPU cycles.
> >>
> >> Having a type that is reified as something that does not have “a unique
> address” in memory (that we understand as the identity of Objects) is
> different from “no identity”.
> >>
> >> Being unable to use “value type” instances for synchronization is
> perfectly reasonable - in the end, you aren’t meant to synchronize using
> random objects, and the whole purpose of supporting synchronization on
> every object is to ease construction of thread-safe code (through
> declaration of synchronized methods). If "the thing” is immutable, there is
> no need to support synchronization on those specific instances, and
> choosing such instances as the means of synchronizing something else
> requires justification, even if “the thing” subclasses from Object.
> >>
> >> Restricting the meaning of identityHashCode is questionable, but in the
> end hinges on whether “the thing” is a subclass of an Object or not. If it
> is, then there are ways to support identityHashCode - even if there is no
> notion of “a unique address”.
> >>
> >> Restricting the use of "==“ because of some compiler optimizations, is
> inventing obstacles. I don’t see why compiler problems of this sort should
> leak into the application programmer’s life, especially in the form of
> RandomExceptions and heisenbugs.
> >>
> >>
> >> Alex
> >>
> >>
> >>> On 7 Jul 2017, at 18:32, Gil Tene <gil at azul.com <mailto:gil at azul.com>>
> wrote:
> >>>
> >>>
> >>>> On Jul 7, 2017, at 10:04 AM, Kirk Pepperdine <kirk at kodewerk.com
> <mailto:kirk at kodewerk.com>> wrote:
> >>>>
> >>>>>
> >>>>> 3. The exception-throwing thing is IMO the healthy way to go IMO.
> I.e. throw some runtime exception when encountering an indentity-based
> operation on an instance of a value-based class. Hard to argue that "an
> exception should not be thrown here" given the clear warnings in the spec.
> My worry is mostly about coverage. Throwing exceptions in all cases where
> identity based operations are attempted would clearly be right, and
> healthy. But doing so only in some cases (and leaving some undefined
> behavior executing paths that don't throw exceptions) doesn't solve the
> problem [and may make things worse by encouraging false confidence]. Since
> no one *requires* us to throw an exception right now, JVM implementors will
> probably keep taking the lazy approach and not work hard on trying to
> achieve complete coverage. And since don't do it at all" is probably
> better/easier to verify than "do it in some places but not in others",
> we'll probably avoid it altogether for now. This *may* change when
> value-based optimizations materialize.
> >>>>
> >>>> I think I’d have to (violently) disagree with this. There is a reason
> no one requires you to throw an exception when expressing equality and that
> is because this is a guaranteed property in the runtime. Without it you
> lose a fundamental property of the runtime.
> >>>
> >>> Synchronous exceptions can be thrown for example because (
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2 <
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.1.2
> >):
> >>> evaluation of an expression violates the normal semantics of the Java
> programming language (§15.6 <https://docs.oracle.com/
> javase/specs/jls/se7/html/jls-15.html#jls-15.6>), such as an integer
> divide by zero.
> >>>
> >>>  <>an error occurs while loading, linking, or initializing part of the
> program (§12.2 <https://docs.oracle.com/javase/specs/jls/se7/html/jls-
> 12.html#jls-12.2>, §12.3 <https://docs.oracle.com/
> javase/specs/jls/se7/html/jls-12.html#jls-12.3>, §12.4 <
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4>);
> in this case, an instance of a subclass of LinkageError is thrown.
> >>>
> >>>  <>an internal error or resource limitation prevents the Java Virtual
> Machine from implementing the semantics of the Java programming language;
> in this case, an instance of a subclass of VirtualMethodError is thrown.
> [GT: this is mis-spelled in the spec. Should be VirtualMachineError].
> >>>
> >>>
> >>> I'd hope to have it qualify under the first bullet, but it is not
> listed in the specific list of runtime exception causes in 15.6. However,
> evaluating an == expression where one of the operands is an instance of a
> value-based class (and has no identity) can probably qualify under "an
> internal error or resource limitation prevents the Java Virtual Machine
> from implementing the semantics of the Java programming language" (third
> bullet). Especially when the Java SE spec explicitly says "Use of such
> identity-sensitive operations on instances of value-based classes may have
> unpredictable effects".
> >>>
> >>> Separately, asynchronous exceptions can be thrown anywhere in the
> code. E.g. An OOME can hit a == point in the code too.
> >>>
> >>> I'd rather not make such exceptions a subclass of VirtualMachineError
> would be better tho...
> >>>
> >>>>
> >>>> — Kirk
> >>>
> >>> _______________________________________________
> >>> Concurrency-interest mailing list
> >>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest@
> cs.oswego.edu>
> >>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >>
>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-
> interest/attachments/20170708/bacf34fc/attachment.html>
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 150, Issue 28
> *****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170716/719731ff/attachment-0001.html>

From gmatthew at callutheran.edu  Wed Jul 19 23:41:23 2017
From: gmatthew at callutheran.edu (Matthews, Graham)
Date: Thu, 20 Jul 2017 03:41:23 +0000
Subject: [concurrency-interest] strange performance issue with
	ArrayBlockingQueue on Linux
Message-ID: <1500522083051.77042@callutheran.edu>

?[apologies in advance if this is the wrong place to discuss this issue. also apologies for the long setup -- I promise this is about ArrayBlockingQueue, Java, and a performance issue with them]


My student and I have been benchmarking various ways to run cross data source joins. The basic setup is as follows:


           J2

           /  \

          /    \

        R3  J1

              /  \

             /    \

           R2  R1

R1, R2 and R3 are called receive operators as they receive data from the databases. J1 and J2 are inner join operators joining values from R2 with values from R1 and then the result with values from R3.

One way to run these queries is the classic producers and consumers approach -- so each operator is a Java thread, and there are bounded queues (ArrayBlockingQueues) between the operators. So the above example has 5 threads and 4 ArrayBlockingQueues. So here we interleave I/O with computation.

Another way to run this is to first load R3 into J2 in parallel with loading R2 into J1 (the loads build hash maps in J1 and J2), and then have a thread pool with N workers (where N is the number of cores), where each worker takes a value from R1 and joins it "up the spine" of the tree -- so matches against the hash map in J1 and then J2. This approach (the phased approach) therefore has an I/O phase, followed by a computation phase.


On OS X El Capitan (10.11.6), the queueing approach and the phased approach perform roughly equally (more variation in the run times for the queueing approach, but performance within 10% of each other). On Linux (Ubuntu 16.04 LTS) the queueing approach is almost three times slower than the phased approach!

On top of that the queueing approach runs over twice as fast on OS X as it is does on Linux, despite the fact that I am running OS X on old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and Linux on relatively new hardware (6th Gen Intel Core i7-5500U).

We have boiled the problem down to code that doesn't involve databases -- just threads and ArrayBlockingQueues. Attached are 5 Java files which "approximate" the queueing approach by having each receive thread simply output numbers (rather than get values from a database) to an ArrayBlockingQueue, and each Join thread simply read its two input queues, adds the values together, and then output the sum to the output queue.

On the same hardware above this code runs in 1 minute 30 secs on OS X, and 2 minutes 13 secs on Linux!

The code is very simple -- just a bunch of threads and a bunch of ArrayBlockingQueues. So I am at a loss to explain the size-able performance differences noted above.

Again apologies if this is not the right forum to discuss this issue.

graham

?
------
Graham MATTHEWS, Ph.D.
Assistant Professor
Department of Computer Science |  California Lutheran University
60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
gmatthew at callutheran.edu  | Office location: D19
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Buffer.java
Type: application/octet-stream
Size: 194 bytes
Desc: Buffer.java
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Join.java
Type: application/octet-stream
Size: 1392 bytes
Desc: Join.java
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment-0001.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Receive.java
Type: application/octet-stream
Size: 707 bytes
Desc: Receive.java
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment-0002.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Stream.java
Type: application/octet-stream
Size: 664 bytes
Desc: Stream.java
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment-0003.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Test.java
Type: application/octet-stream
Size: 2861 bytes
Desc: Test.java
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/09c3ae0d/attachment-0004.obj>

From martinrb at google.com  Wed Jul 19 23:57:30 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 19 Jul 2017 20:57:30 -0700
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <1500522083051.77042@callutheran.edu>
References: <1500522083051.77042@callutheran.edu>
Message-ID: <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>

One obvious variable is the version of ABQ you are using.  It was modified
in jdk9 and you should be doing all performance work with latest jdk9
binaries e.g. from http://jdk.java.net/9/

On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham <gmatthew at callutheran.edu>
wrote:

> ​[apologies in advance if this is the wrong place to discuss this issue.
> also apologies for the long setup -- I promise this is about
> ArrayBlockingQueue, Java, and a performance issue with them]
>
>
> My student and I have been benchmarking various ways to run cross data
> source joins. The basic setup is as follows:
>
>
>            J2
>
>            /  \
>
>           /    \
>
>         R3  J1
>
>               /  \
>
>              /    \
>            R2  R1
>
> R1, R2 and R3 are called receive operators as they receive data from the
> databases. J1 and J2 are inner join operators joining values from R2 with
> values from R1 and then the result with values from R3.
>
> One way to run these queries is the classic producers and consumers
> approach -- so each operator is a Java thread, and there are bounded queues
> (ArrayBlockingQueues) between the operators. So the above example has
> 5 threads and 4 ArrayBlockingQueues. So here we interleave I/O with
> computation.
>
> Another way to run this is to first load R3 into J2 in parallel with
> loading R2 into J1 (the loads build hash maps in J1 and J2), and then have
> a thread pool with N workers (where N is the number of cores), where each
> worker takes a value from R1 and joins it "up the spine" of the tree -- so
> matches against the hash map in J1 and then J2. This approach (the phased
> approach) therefore has an I/O phase, followed by a computation phase.
>
>
> On OS X El Capitan (10.11.6), the queueing approach and the phased approach
> perform roughly equally (more variation in the run times for the queueing
> approach, but performance within 10% of each other). On Linux (Ubuntu
> 16.04 LTS) the queueing approach is almost three times slower than the
> phased approach!
>
> On top of that the queueing approach runs over twice as fast on OS X as it
> is does on Linux, despite the fact that I am running OS X on old hardware
> (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and Linux on
> relatively new hardware (6th Gen Intel Core i7-5500U).
>
> We have boiled the problem down to code that doesn't involve databases --
> just threads and ArrayBlockingQueues. Attached are 5 Java files which
> "approximate" the queueing approach by having each receive thread simply
> output numbers (rather than get values from a database) to
> an ArrayBlockingQueue, and each Join thread simply read its two input
> queues, adds the values together, and then output the sum to the output
> queue.
>
> On the same hardware above this code runs in 1 minute 30 secs on OS X,
> and 2 minutes 13 secs on Linux!
>
> The code is very simple -- just a bunch of threads and a bunch of
> ArrayBlockingQueues. So I am at a loss to explain the size-able performance
> differences noted above.
>
> Again apologies if this is not the right forum to discuss this issue.
>
> graham
>
> ​
> ------
> Graham MATTHEWS, Ph.D.
> Assistant Professor
> Department of Computer Science |  California Lutheran University
> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
> gmatthew at callutheran.edu  | Office location: D19
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170719/d8cdfac6/attachment-0001.html>

From gmatthew at callutheran.edu  Thu Jul 20 00:11:14 2017
From: gmatthew at callutheran.edu (Matthews, Graham)
Date: Thu, 20 Jul 2017 04:11:14 +0000
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
References: <1500522083051.77042@callutheran.edu>,
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
Message-ID: <1500523874644.85107@callutheran.edu>

?Ah yes, sorry I should have said we are working in Java 8.

graham


------
Graham MATTHEWS, Ph.D.
Assistant Professor
Department of Computer Science |  California Lutheran University
60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
gmatthew at callutheran.edu  | Office location: D19
________________________________
From: Martin Buchholz <martinrb at google.com>
Sent: Wednesday, July 19, 2017 8:57 PM
To: Matthews, Graham
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux

One obvious variable is the version of ABQ you are using.  It was modified in jdk9 and you should be doing all performance work with latest jdk9 binaries e.g. from http://jdk.java.net/9/

On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham <gmatthew at callutheran.edu<mailto:gmatthew at callutheran.edu>> wrote:

?[apologies in advance if this is the wrong place to discuss this issue. also apologies for the long setup -- I promise this is about ArrayBlockingQueue, Java, and a performance issue with them]


My student and I have been benchmarking various ways to run cross data source joins. The basic setup is as follows:


           J2

           /  \

          /    \

        R3  J1

              /  \

             /    \

           R2  R1

R1, R2 and R3 are called receive operators as they receive data from the databases. J1 and J2 are inner join operators joining values from R2 with values from R1 and then the result with values from R3.

One way to run these queries is the classic producers and consumers approach -- so each operator is a Java thread, and there are bounded queues (ArrayBlockingQueues) between the operators. So the above example has 5 threads and 4 ArrayBlockingQueues. So here we interleave I/O with computation.

Another way to run this is to first load R3 into J2 in parallel with loading R2 into J1 (the loads build hash maps in J1 and J2), and then have a thread pool with N workers (where N is the number of cores), where each worker takes a value from R1 and joins it "up the spine" of the tree -- so matches against the hash map in J1 and then J2. This approach (the phased approach) therefore has an I/O phase, followed by a computation phase.


On OS X El Capitan (10.11.6), the queueing approach and the phased approach perform roughly equally (more variation in the run times for the queueing approach, but performance within 10% of each other). On Linux (Ubuntu 16.04 LTS) the queueing approach is almost three times slower than the phased approach!

On top of that the queueing approach runs over twice as fast on OS X as it is does on Linux, despite the fact that I am running OS X on old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and Linux on relatively new hardware (6th Gen Intel Core i7-5500U).

We have boiled the problem down to code that doesn't involve databases -- just threads and ArrayBlockingQueues. Attached are 5 Java files which "approximate" the queueing approach by having each receive thread simply output numbers (rather than get values from a database) to an ArrayBlockingQueue, and each Join thread simply read its two input queues, adds the values together, and then output the sum to the output queue.

On the same hardware above this code runs in 1 minute 30 secs on OS X, and 2 minutes 13 secs on Linux!

The code is very simple -- just a bunch of threads and a bunch of ArrayBlockingQueues. So I am at a loss to explain the size-able performance differences noted above.

Again apologies if this is not the right forum to discuss this issue.

graham

?
------
Graham MATTHEWS, Ph.D.
Assistant Professor
Department of Computer Science |  California Lutheran University
60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
gmatthew at callutheran.edu<mailto:gmatthew at callutheran.edu>  | Office location: D19

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/5ade0745/attachment.html>

From bronee at gmail.com  Thu Jul 20 00:50:42 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Wed, 19 Jul 2017 21:50:42 -0700
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <1500523874644.85107@callutheran.edu>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
Message-ID: <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>

You also didn't mention CPU core count. I ran the test on two machines, 
with Java 8 and with Java 9. With Java 9 I explicitly selected the 
parallel GC, because the G1 collector in Java 9 is a CPU pig that slows 
everything down.

Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores

Machine 1, Java 8: 9.2 seconds
Machine 1, Java 9: 9.1 seconds
Machine 2, Java 8: 16.9 seconds
Machine 2, Java 9: 12.1 seconds

At first blush it looks like the problem is Linux, but I don't have a 
proper apples-to-apples comparison. I noticed that with Java 8, the 
number of context switches per second was about 2.5 million, and with 
Java 9 it was about 2.3 million. Either way, this is really high. On 
Windows, the context switch rate was about 1.9 million per second.

I also see a lot of variation between test runs, and when I run the code 
in a loop, the performance (on Windows) varies from 9 to 14 seconds per 
run. On Linux, I see 11 to 21 seconds when running in a loop. I also 
added an explicit System.gc between each test run.

When I run with -Xprof, I see the threads spending most of their time in 
Unsafe.unpark and Unsafe.park. I've never understood why unpark always 
comes up as a performance bottleneck. What does it do that's so expensive?


On 2017-07-19 09:11 PM, Matthews, Graham wrote:
> ​Ah yes, sorry I should have said we are working in Java 8.
> 
> graham
> 
> 
> ------
> Graham MATTHEWS, Ph.D.
> Assistant Professor
> Department of Computer Science |  California Lutheran University
> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
> gmatthew at callutheran.edu  | Office location: D19
> ------------------------------------------------------------------------
> *From:* Martin Buchholz <martinrb at google.com>
> *Sent:* Wednesday, July 19, 2017 8:57 PM
> *To:* Matthews, Graham
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] strange performance issue with 
> ArrayBlockingQueue on Linux
> One obvious variable is the version of ABQ you are using.  It was 
> modified in jdk9 and you should be doing all performance work with 
> latest jdk9 binaries e.g. from http://jdk.java.net/9/
> 
> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham 
> <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
> 
>     ​[apologies in advance if this is the wrong place to discuss this
>     issue. also apologies for the long setup -- I promise this is about
>     ArrayBlockingQueue, Java, and a performance issue with them]
> 
> 
>     My student and I have been benchmarking various ways to run cross
>     data source joins. The basic setup is as follows:
> 
> 
>                 J2
> 
>                 /  \
> 
>                /    \
> 
>              R3  J1
> 
>                    /  \
> 
>                   /    \
> 
>                 R2  R1
> 
>     R1, R2 and R3 are called receive operators as they receive data from
>     the databases. J1 and J2 are inner join operators joining values
>     from R2 with values from R1 and then the result with values from R3.
> 
>     One way to run these queries is the classic producers and consumers
>     approach -- so each operator is a Java thread, and there are
>     bounded queues (ArrayBlockingQueues) between the operators. So the
>     above example has 5 threads and 4 ArrayBlockingQueues. So here we
>     interleave I/O with computation.
> 
>     Another way to run this is to first load R3 into J2 in parallel with
>     loading R2 into J1 (the loads build hash maps in J1 and J2), and
>     then have a thread pool with N workers (where N is the number of
>     cores), where each worker takes a value from R1 and joins it "up the
>     spine" of the tree -- so matches against the hash map in J1 and then
>     J2. This approach (the phased approach) therefore has an I/O phase,
>     followed by a computation phase.
> 
> 
>     On OS X El Capitan (10.11.6), the queueing approach and the phased
>     approach perform roughly equally (more variation in the run times
>     for the queueing approach, but performance within 10% of each
>     other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>     three times slower than the phased approach!
> 
>     On top of that the queueing approach runs over twice as fast on OS X
>     as it is does on Linux, despite the fact that I am running OS X on
>     old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>     Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
> 
>     We have boiled the problem down to code that doesn't involve
>     databases -- just threads and ArrayBlockingQueues. Attached are
>     5 Java files which "approximate" the queueing approach by having
>     each receive thread simply output numbers (rather than get values
>     from a database) to an ArrayBlockingQueue, and
>     each Join thread simply read its two input queues, adds the values
>     together, and then output the sum to the output queue.
> 
>     Onthe same hardware above this code runs in 1 minute 30 secs on OS
>     X, and 2 minutes 13 secs on Linux!
> 
>     The code is very simple -- just a bunch of threads and a bunch of
>     ArrayBlockingQueues. So I am at a loss to explain the size-able
>     performance differences noted above.
> 
>     Again apologies if this is not the right forum to discuss this issue.
> 
>     graham
> 
>     ​
>     ------
>     Graham MATTHEWS, Ph.D.
>     Assistant Professor
>     Department of Computer Science |  California Lutheran University
>     60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>     gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>     location: D19
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From d.sannella at contemplateltd.com  Thu Jul 20 04:30:49 2017
From: d.sannella at contemplateltd.com (Don Sannella)
Date: Thu, 20 Jul 2017 09:30:49 +0100
Subject: [concurrency-interest] IntelliJ plug-in for ThreadSafe static
	analysis tool
Message-ID: <ade9691b-eb6c-4087-ec7d-f760d68873fd@contemplateltd.com>

I have previously written to this list about ThreadSafe, an advanced 
static analysis tool that specifically targets Java concurrency defects 
and includes some dedicated treatment for java.util.concurrent.  It 
handles enterprise-scale Java codebases and includes integration with 
Eclipse and SonarQube.  For those who didn't see those messages, you can 
get a free 2-week trial by filling out a simple webform at 
http://www.contemplateltd.com/try-buy/request-a-trial

I'm writing again now because we now finally have a prototype IntelliJ 
plug-in for ThreadSafe.  Please contact me if you would like to try it 
out.  This is a student project at the University of Edinburgh and the 
student needs feedback, so you would need to agree to fill out a short 
anonymous questionnaire after trying it out.  The trial would take place 
during the period 25 July - 8 August and the questionnaire is mainly 
about the quality of the user experience rather than about the quality 
of the analysis findings.

More information on ThreadSafe is available from Contemplate's website: 
www.contemplateltd.com

Regards,

Don Sannella

--
----------------------------------------------------------------------
Prof. Donald Sannella, Laboratory for Foundations of Computer Science,
School of Informatics, University of Edinburgh, Edinburgh EH8 9AB, UK
http://homepages.inf.ed.ac.uk/dts  dts at inf.ed.ac.uk  +44 131 650 5184

and

---------------------------------------------------------
Don Sannella                d.sannella at contemplateltd.com
Contemplate Ltd                    www.contemplateltd.com
tel +44 7939 132117                       skype dsannella

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/c8f73062/attachment-0001.html>

From martinrb at google.com  Thu Jul 20 10:44:24 2017
From: martinrb at google.com (Martin Buchholz)
Date: Thu, 20 Jul 2017 07:44:24 -0700
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
Message-ID: <CA+kOe09ROit85k1vOJQ28m3SvMY+_EyA019Rs-PSuPLs4=e8hw@mail.gmail.com>

I also play the benchmark game and like to produce many variations, in the
style of

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/jtreg/util/Collection/IteratorMicroBenchmark.java?view=co

One obvious thing to try is different BlockingQueue implementations.
(but it sounds like the key to the performance here is frequency and
overhead of context switch.)


On Wed, Jul 19, 2017 at 9:50 PM, Brian S O'Neill <bronee at gmail.com> wrote:

> You also didn't mention CPU core count. I ran the test on two machines,
> with Java 8 and with Java 9. With Java 9 I explicitly selected the parallel
> GC, because the G1 collector in Java 9 is a CPU pig that slows everything
> down.
>
> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>
> Machine 1, Java 8: 9.2 seconds
> Machine 1, Java 9: 9.1 seconds
> Machine 2, Java 8: 16.9 seconds
> Machine 2, Java 9: 12.1 seconds
>
> At first blush it looks like the problem is Linux, but I don't have a
> proper apples-to-apples comparison. I noticed that with Java 8, the number
> of context switches per second was about 2.5 million, and with Java 9 it
> was about 2.3 million. Either way, this is really high. On Windows, the
> context switch rate was about 1.9 million per second.
>
> I also see a lot of variation between test runs, and when I run the code
> in a loop, the performance (on Windows) varies from 9 to 14 seconds per
> run. On Linux, I see 11 to 21 seconds when running in a loop. I also added
> an explicit System.gc between each test run.
>
> When I run with -Xprof, I see the threads spending most of their time in
> Unsafe.unpark and Unsafe.park. I've never understood why unpark always
> comes up as a performance bottleneck. What does it do that's so expensive?
>
>
> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>
>> ​Ah yes, sorry I should have said we are working in Java 8.
>>
>> graham
>>
>>
>> ------
>> Graham MATTHEWS, Ph.D.
>> Assistant Professor
>> Department of Computer Science |  California Lutheran University
>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>> gmatthew at callutheran.edu  | Office location: D19
>> ------------------------------------------------------------------------
>> *From:* Martin Buchholz <martinrb at google.com>
>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>> *To:* Matthews, Graham
>> *Cc:* concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] strange performance issue with
>> ArrayBlockingQueue on Linux
>> One obvious variable is the version of ABQ you are using.  It was
>> modified in jdk9 and you should be doing all performance work with latest
>> jdk9 binaries e.g. from http://jdk.java.net/9/
>>
>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham <
>> gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>>
>>     ​[apologies in advance if this is the wrong place to discuss this
>>     issue. also apologies for the long setup -- I promise this is about
>>     ArrayBlockingQueue, Java, and a performance issue with them]
>>
>>
>>     My student and I have been benchmarking various ways to run cross
>>     data source joins. The basic setup is as follows:
>>
>>
>>                 J2
>>
>>                 /  \
>>
>>                /    \
>>
>>              R3  J1
>>
>>                    /  \
>>
>>                   /    \
>>
>>                 R2  R1
>>
>>     R1, R2 and R3 are called receive operators as they receive data from
>>     the databases. J1 and J2 are inner join operators joining values
>>     from R2 with values from R1 and then the result with values from R3.
>>
>>     One way to run these queries is the classic producers and consumers
>>     approach -- so each operator is a Java thread, and there are
>>     bounded queues (ArrayBlockingQueues) between the operators. So the
>>     above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>     interleave I/O with computation.
>>
>>     Another way to run this is to first load R3 into J2 in parallel with
>>     loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>     then have a thread pool with N workers (where N is the number of
>>     cores), where each worker takes a value from R1 and joins it "up the
>>     spine" of the tree -- so matches against the hash map in J1 and then
>>     J2. This approach (the phased approach) therefore has an I/O phase,
>>     followed by a computation phase.
>>
>>
>>     On OS X El Capitan (10.11.6), the queueing approach and the phased
>>     approach perform roughly equally (more variation in the run times
>>     for the queueing approach, but performance within 10% of each
>>     other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>     three times slower than the phased approach!
>>
>>     On top of that the queueing approach runs over twice as fast on OS X
>>     as it is does on Linux, despite the fact that I am running OS X on
>>     old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>     Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>
>>     We have boiled the problem down to code that doesn't involve
>>     databases -- just threads and ArrayBlockingQueues. Attached are
>>     5 Java files which "approximate" the queueing approach by having
>>     each receive thread simply output numbers (rather than get values
>>     from a database) to an ArrayBlockingQueue, and
>>     each Join thread simply read its two input queues, adds the values
>>     together, and then output the sum to the output queue.
>>
>>     Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>     X, and 2 minutes 13 secs on Linux!
>>
>>     The code is very simple -- just a bunch of threads and a bunch of
>>     ArrayBlockingQueues. So I am at a loss to explain the size-able
>>     performance differences noted above.
>>
>>     Again apologies if this is not the right forum to discuss this issue.
>>
>>     graham
>>
>>     ​
>>     ------
>>     Graham MATTHEWS, Ph.D.
>>     Assistant Professor
>>     Department of Computer Science |  California Lutheran University
>>     60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>     gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>>     location: D19
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/73fb766a/attachment.html>

From nathanila at gmail.com  Thu Jul 20 10:45:16 2017
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Thu, 20 Jul 2017 08:45:16 -0600
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
Message-ID: <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>

 > I've never understood why unpark always comes up as a performance 
bottleneck. What does it do that's so expensive?

A while ago, I talked with the engineer who has done a lot of 
optimization on LockSupport.unpark().  I can't remember if that implies 
Unsafe.unpark().

On Windows, LockSupport.unpark() goes into the kernel 1 time to set a 
Windows Event object.  On Linux, LockSupport.unpark() acquires a lock, 
sets a condition wait and releases a lock.  This *might* require 3 trips 
into the kernel.

Furthermore, the scheduler might let the unparked thread start running 
and unparking thread yield (if no logical cores are available).  Hence, 
unpark() will take even more time.

-Nathan

On 7/19/2017 10:50 PM, Brian S O'Neill wrote:
> You also didn't mention CPU core count. I ran the test on two 
> machines, with Java 8 and with Java 9. With Java 9 I explicitly 
> selected the parallel GC, because the G1 collector in Java 9 is a CPU 
> pig that slows everything down.
>
> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>
> Machine 1, Java 8: 9.2 seconds
> Machine 1, Java 9: 9.1 seconds
> Machine 2, Java 8: 16.9 seconds
> Machine 2, Java 9: 12.1 seconds
>
> At first blush it looks like the problem is Linux, but I don't have a 
> proper apples-to-apples comparison. I noticed that with Java 8, the 
> number of context switches per second was about 2.5 million, and with 
> Java 9 it was about 2.3 million. Either way, this is really high. On 
> Windows, the context switch rate was about 1.9 million per second.
>
> I also see a lot of variation between test runs, and when I run the 
> code in a loop, the performance (on Windows) varies from 9 to 14 
> seconds per run. On Linux, I see 11 to 21 seconds when running in a 
> loop. I also added an explicit System.gc between each test run.
>
> When I run with -Xprof, I see the threads spending most of their time 
> in Unsafe.unpark and Unsafe.park. I've never understood why unpark 
> always comes up as a performance bottleneck. What does it do that's so 
> expensive?
>
>
> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>> ​Ah yes, sorry I should have said we are working in Java 8.
>>
>> graham
>>
>>
>> ------
>> Graham MATTHEWS, Ph.D.
>> Assistant Professor
>> Department of Computer Science |  California Lutheran University
>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>> gmatthew at callutheran.edu  | Office location: D19
>> ------------------------------------------------------------------------
>> *From:* Martin Buchholz <martinrb at google.com>
>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>> *To:* Matthews, Graham
>> *Cc:* concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] strange performance issue with 
>> ArrayBlockingQueue on Linux
>> One obvious variable is the version of ABQ you are using.  It was 
>> modified in jdk9 and you should be doing all performance work with 
>> latest jdk9 binaries e.g. from http://jdk.java.net/9/
>>
>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham 
>> <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>>
>>     ​[apologies in advance if this is the wrong place to discuss this
>>     issue. also apologies for the long setup -- I promise this is about
>>     ArrayBlockingQueue, Java, and a performance issue with them]
>>
>>
>>     My student and I have been benchmarking various ways to run cross
>>     data source joins. The basic setup is as follows:
>>
>>
>>                 J2
>>
>>                 /  \
>>
>>                /    \
>>
>>              R3  J1
>>
>>                    /  \
>>
>>                   /    \
>>
>>                 R2  R1
>>
>>     R1, R2 and R3 are called receive operators as they receive data from
>>     the databases. J1 and J2 are inner join operators joining values
>>     from R2 with values from R1 and then the result with values from R3.
>>
>>     One way to run these queries is the classic producers and consumers
>>     approach -- so each operator is a Java thread, and there are
>>     bounded queues (ArrayBlockingQueues) between the operators. So the
>>     above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>     interleave I/O with computation.
>>
>>     Another way to run this is to first load R3 into J2 in parallel with
>>     loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>     then have a thread pool with N workers (where N is the number of
>>     cores), where each worker takes a value from R1 and joins it "up the
>>     spine" of the tree -- so matches against the hash map in J1 and then
>>     J2. This approach (the phased approach) therefore has an I/O phase,
>>     followed by a computation phase.
>>
>>
>>     On OS X El Capitan (10.11.6), the queueing approach and the phased
>>     approach perform roughly equally (more variation in the run times
>>     for the queueing approach, but performance within 10% of each
>>     other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>     three times slower than the phased approach!
>>
>>     On top of that the queueing approach runs over twice as fast on OS X
>>     as it is does on Linux, despite the fact that I am running OS X on
>>     old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>     Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>
>>     We have boiled the problem down to code that doesn't involve
>>     databases -- just threads and ArrayBlockingQueues. Attached are
>>     5 Java files which "approximate" the queueing approach by having
>>     each receive thread simply output numbers (rather than get values
>>     from a database) to an ArrayBlockingQueue, and
>>     each Join thread simply read its two input queues, adds the values
>>     together, and then output the sum to the output queue.
>>
>>     Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>     X, and 2 minutes 13 secs on Linux!
>>
>>     The code is very simple -- just a bunch of threads and a bunch of
>>     ArrayBlockingQueues. So I am at a loss to explain the size-able
>>     performance differences noted above.
>>
>>     Again apologies if this is not the right forum to discuss this 
>> issue.
>>
>>     graham
>>
>>     ​
>>     ------
>>     Graham MATTHEWS, Ph.D.
>>     Assistant Professor
>>     Department of Computer Science |  California Lutheran University
>>     60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>     gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>>     location: D19
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-- 
-Nathan


From bronee at gmail.com  Thu Jul 20 12:45:17 2017
From: bronee at gmail.com (Brian S O'Neill)
Date: Thu, 20 Jul 2017 09:45:17 -0700
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
 <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
Message-ID: <873db900-d2ed-d769-85a7-63407c10a15e@gmail.com>

In this particular test, the number of active threads was less than or 
equal to the number of logical cores. So any cost due to unpark possibly 
triggering a yield shouldn't apply. My understanding is that park/unpark 
on Linux relies on a futex, and so perhaps this is just one kernel call.

On 2017-07-20 07:45 AM, Nathan and Ila Reynolds wrote:
>  > I've never understood why unpark always comes up as a performance 
> bottleneck. What does it do that's so expensive?
> 
> A while ago, I talked with the engineer who has done a lot of 
> optimization on LockSupport.unpark().  I can't remember if that implies 
> Unsafe.unpark().
> 
> On Windows, LockSupport.unpark() goes into the kernel 1 time to set a 
> Windows Event object.  On Linux, LockSupport.unpark() acquires a lock, 
> sets a condition wait and releases a lock.  This *might* require 3 trips 
> into the kernel.
> 
> Furthermore, the scheduler might let the unparked thread start running 
> and unparking thread yield (if no logical cores are available).  Hence, 
> unpark() will take even more time.
> 
> -Nathan
> 


From oleksandr.otenko at gmail.com  Thu Jul 20 18:05:45 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 20 Jul 2017 23:05:45 +0100
Subject: [concurrency-interest] strange performance issue with
	ArrayBlockingQueue on Linux
In-Reply-To: <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
 <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
Message-ID: <2A543866-4C95-4F7E-A2F3-4E63A96FC4D5@gmail.com>

This particular case is not about the cost of a context switch, and not about the number of context switches per second. This is about the amount of work done per switch.


Consider J2. J2 moving data unblocks J1 and J3. If J1 gets on the CPU, the context switch allows J1 to move just one data item, then it gets blocked again. If J3 gets on the CPU, J2 moves as much data as possible - basically, emptying J1’s buffer, so when J2 is blocked, it created a lot of work for both J3 (kept feeding its input queue) and J1 (emptied its output queue), so when J1 does get on the core again, it can move a lot of items upstream to J2 (which in turn is better if J2 waits till there’s a lot of work available, instead of getting agitated the moment a single item is in its queue).

Example change in Join.java (synthetically biasing who gets blocked when) dramatically changed times for my Ubuntu (on Virtual Box):

    @Override
    public void run() {
        long [] arr = new long[1000];
        int pos = 0;
        try {
            while (true) {
                long lhsValue = this.lhsInput.take();
                long rhsValue = this.rhsInput.take();

                /* Check for end-of-stream markers. */
                if (lhsValue == Stream.EOS) {
                    this.eosCount++;
                }
                if (rhsValue == Stream.EOS) {
                    this.eosCount++;
                }

                /* Join values or send end-of-stream marker.*/
                if (this.eosCount == 2) {
                    for(int i = 0; i < pos; i++) {
                      this.put(arr[i]);
                    }
                    break;
                }
                else {
                    arr[pos++] = lhsValue + rhsValue;
                    if (pos == arr.length) {
                      for(int i = 0; i < pos; i++) {
                        this.put(arr[i]);
                      }
                      pos = 0;
                    }
                }
            }
            this.put(Stream.EOS);
            System.out.println(this + " : END");
        }
        catch (InterruptedException ex) {
            ex.printStackTrace(System.err);
        }
    }


Alex


> On 20 Jul 2017, at 15:45, Nathan and Ila Reynolds <nathanila at gmail.com> wrote:
> 
> > I've never understood why unpark always comes up as a performance bottleneck. What does it do that's so expensive?
> 
> A while ago, I talked with the engineer who has done a lot of optimization on LockSupport.unpark().  I can't remember if that implies Unsafe.unpark().
> 
> On Windows, LockSupport.unpark() goes into the kernel 1 time to set a Windows Event object.  On Linux, LockSupport.unpark() acquires a lock, sets a condition wait and releases a lock.  This *might* require 3 trips into the kernel.
> 
> Furthermore, the scheduler might let the unparked thread start running and unparking thread yield (if no logical cores are available).  Hence, unpark() will take even more time.
> 
> -Nathan
> 
> On 7/19/2017 10:50 PM, Brian S O'Neill wrote:
>> You also didn't mention CPU core count. I ran the test on two machines, with Java 8 and with Java 9. With Java 9 I explicitly selected the parallel GC, because the G1 collector in Java 9 is a CPU pig that slows everything down.
>> 
>> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
>> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>> 
>> Machine 1, Java 8: 9.2 seconds
>> Machine 1, Java 9: 9.1 seconds
>> Machine 2, Java 8: 16.9 seconds
>> Machine 2, Java 9: 12.1 seconds
>> 
>> At first blush it looks like the problem is Linux, but I don't have a proper apples-to-apples comparison. I noticed that with Java 8, the number of context switches per second was about 2.5 million, and with Java 9 it was about 2.3 million. Either way, this is really high. On Windows, the context switch rate was about 1.9 million per second.
>> 
>> I also see a lot of variation between test runs, and when I run the code in a loop, the performance (on Windows) varies from 9 to 14 seconds per run. On Linux, I see 11 to 21 seconds when running in a loop. I also added an explicit System.gc between each test run.
>> 
>> When I run with -Xprof, I see the threads spending most of their time in Unsafe.unpark and Unsafe.park. I've never understood why unpark always comes up as a performance bottleneck. What does it do that's so expensive?
>> 
>> 
>> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>>> ​Ah yes, sorry I should have said we are working in Java 8.
>>> 
>>> graham
>>> 
>>> 
>>> ------
>>> Graham MATTHEWS, Ph.D.
>>> Assistant Professor
>>> Department of Computer Science |  California Lutheran University
>>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>> gmatthew at callutheran.edu  | Office location: D19
>>> ------------------------------------------------------------------------
>>> *From:* Martin Buchholz <martinrb at google.com>
>>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>>> *To:* Matthews, Graham
>>> *Cc:* concurrency-interest at cs.oswego.edu
>>> *Subject:* Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux
>>> One obvious variable is the version of ABQ you are using.  It was modified in jdk9 and you should be doing all performance work with latest jdk9 binaries e.g. from http://jdk.java.net/9/
>>> 
>>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>>> 
>>>    ​[apologies in advance if this is the wrong place to discuss this
>>>    issue. also apologies for the long setup -- I promise this is about
>>>    ArrayBlockingQueue, Java, and a performance issue with them]
>>> 
>>> 
>>>    My student and I have been benchmarking various ways to run cross
>>>    data source joins. The basic setup is as follows:
>>> 
>>> 
>>>                J2
>>> 
>>>                /  \
>>> 
>>>               /    \
>>> 
>>>             R3  J1
>>> 
>>>                   /  \
>>> 
>>>                  /    \
>>> 
>>>                R2  R1
>>> 
>>>    R1, R2 and R3 are called receive operators as they receive data from
>>>    the databases. J1 and J2 are inner join operators joining values
>>>    from R2 with values from R1 and then the result with values from R3.
>>> 
>>>    One way to run these queries is the classic producers and consumers
>>>    approach -- so each operator is a Java thread, and there are
>>>    bounded queues (ArrayBlockingQueues) between the operators. So the
>>>    above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>>    interleave I/O with computation.
>>> 
>>>    Another way to run this is to first load R3 into J2 in parallel with
>>>    loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>>    then have a thread pool with N workers (where N is the number of
>>>    cores), where each worker takes a value from R1 and joins it "up the
>>>    spine" of the tree -- so matches against the hash map in J1 and then
>>>    J2. This approach (the phased approach) therefore has an I/O phase,
>>>    followed by a computation phase.
>>> 
>>> 
>>>    On OS X El Capitan (10.11.6), the queueing approach and the phased
>>>    approach perform roughly equally (more variation in the run times
>>>    for the queueing approach, but performance within 10% of each
>>>    other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>>    three times slower than the phased approach!
>>> 
>>>    On top of that the queueing approach runs over twice as fast on OS X
>>>    as it is does on Linux, despite the fact that I am running OS X on
>>>    old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>>    Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>> 
>>>    We have boiled the problem down to code that doesn't involve
>>>    databases -- just threads and ArrayBlockingQueues. Attached are
>>>    5 Java files which "approximate" the queueing approach by having
>>>    each receive thread simply output numbers (rather than get values
>>>    from a database) to an ArrayBlockingQueue, and
>>>    each Join thread simply read its two input queues, adds the values
>>>    together, and then output the sum to the output queue.
>>> 
>>>    Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>>    X, and 2 minutes 13 secs on Linux!
>>> 
>>>    The code is very simple -- just a bunch of threads and a bunch of
>>>    ArrayBlockingQueues. So I am at a loss to explain the size-able
>>>    performance differences noted above.
>>> 
>>>    Again apologies if this is not the right forum to discuss this issue.
>>> 
>>>    graham
>>> 
>>>    ​
>>>    ------
>>>    Graham MATTHEWS, Ph.D.
>>>    Assistant Professor
>>>    Department of Computer Science |  California Lutheran University
>>>    60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>>    gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>>>    location: D19
>>> 
>>>    _______________________________________________
>>>    Concurrency-interest mailing list
>>>    Concurrency-interest at cs.oswego.edu
>>>    <mailto:Concurrency-interest at cs.oswego.edu>
>>>    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> 
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> -- 
> -Nathan
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170720/c58c78dc/attachment-0001.html>

From oleksandr.otenko at gmail.com  Fri Jul 21 03:22:08 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Fri, 21 Jul 2017 08:22:08 +0100
Subject: [concurrency-interest] strange performance issue with
	ArrayBlockingQueue on Linux
In-Reply-To: <2A543866-4C95-4F7E-A2F3-4E63A96FC4D5@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
 <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
 <2A543866-4C95-4F7E-A2F3-4E63A96FC4D5@gmail.com>
Message-ID: <69729CF3-4EA8-43B5-9906-5A519FBD1B27@gmail.com>

Or, to make the claim more obvious (reduced the number of items to move):

Ubuntu:
JOIN 1 : END - avg moved = 15.522080166396762 stops: 193273
JOIN 3 : END - avg moved = 11.284180712332459 stops: 265859
JOIN 4 : END - avg moved = 5.261479667895535 stops: 570182
JOIN 6 : END - avg moved = 5.253905401713407 stops: 571004
Num results = 1000000
JOIN 5 : END - avg moved = 9.410645946522266 stops: 318788
JOIN 2 : END - avg moved = 4.980204145797066 stops: 594771
JOIN 7 : END - avg moved = 13.271463266813882 stops: 226049

Mac:
JOIN 2 : END - avg moved = 191.25074912336663 stops: 15685
JOIN 5 : END - avg moved = 194.36389554850084 stops: 15433
JOIN 6 : END - avg moved = 270.7480144404339 stops: 11080
JOIN 7 : END - avg moved = 259.14675168653486 stops: 10821
JOIN 1 : END - avg moved = 231.73393077873897 stops: 12944
JOIN 3 : END - avg moved = 171.97678284797118 stops: 17444
JOIN 4 : END - avg moved = 216.7288490715988 stops: 13841


For Join.java counting how many times take or put would block:
    @Override
    public void run() {
        int moved = 0;
        double avg = 0;
        int stops = 0;
        try {
            while (true) {
                Long v = this.lhsInput.poll();
                if (v == null) {
                  avg = (avg * stops + moved) / (stops + 1);
                  stops++;
                  moved = 0;
                  v = this.lhsInput.take();
                }
                moved++;

                long lhsValue = v;

                v = this.rhsInput.poll();
                if (v == null) {
                  avg = (avg * stops + moved) / (stops + 1);
                  stops++;
                  moved = 0;
                  v = this.rhsInput.take();
                }
                moved++;

                long rhsValue = v;

                /* Check for end-of-stream markers. */
                if (lhsValue == Stream.EOS) {
                    this.eosCount++;
                }
                if (rhsValue == Stream.EOS) {
                    this.eosCount++;
                }

                /* Join values or send end-of-stream marker.*/
                if (this.eosCount == 2) {
                    break;
                }
                else {
                    if (!this.offer(lhsValue + rhsValue)) {
                      avg = (avg * stops + moved) / (stops + 1);
                      stops++;
                      moved = 0;
                      this.put(lhsValue + rhsValue);
                    }
                    moved++;
                }
            }
            this.put(Stream.EOS);
            System.out.println(this + " : END - avg moved = " + avg + " stops: " + stops);
        }
        catch (InterruptedException ex) {
            ex.printStackTrace(System.err);
        }
    }

(and a corresponding change to Stream.java to expose offer())

Alex

> On 20 Jul 2017, at 23:05, Alex Otenko <oleksandr.otenko at gmail.com> wrote:
> 
> This particular case is not about the cost of a context switch, and not about the number of context switches per second. This is about the amount of work done per switch.
> 
> 
> Consider J2. J2 moving data unblocks J1 and J3. If J1 gets on the CPU, the context switch allows J1 to move just one data item, then it gets blocked again. If J3 gets on the CPU, J2 moves as much data as possible - basically, emptying J1’s buffer, so when J2 is blocked, it created a lot of work for both J3 (kept feeding its input queue) and J1 (emptied its output queue), so when J1 does get on the core again, it can move a lot of items upstream to J2 (which in turn is better if J2 waits till there’s a lot of work available, instead of getting agitated the moment a single item is in its queue).
> 
> Example change in Join.java (synthetically biasing who gets blocked when) dramatically changed times for my Ubuntu (on Virtual Box):
> 
>     @Override
>     public void run() {
>         long [] arr = new long[1000];
>         int pos = 0;
>         try {
>             while (true) {
>                 long lhsValue = this.lhsInput.take();
>                 long rhsValue = this.rhsInput.take();
> 
>                 /* Check for end-of-stream markers. */
>                 if (lhsValue == Stream.EOS) {
>                     this.eosCount++;
>                 }
>                 if (rhsValue == Stream.EOS) {
>                     this.eosCount++;
>                 }
> 
>                 /* Join values or send end-of-stream marker.*/
>                 if (this.eosCount == 2) {
>                     for(int i = 0; i < pos; i++) {
>                       this.put(arr[i]);
>                     }
>                     break;
>                 }
>                 else {
>                     arr[pos++] = lhsValue + rhsValue;
>                     if (pos == arr.length) {
>                       for(int i = 0; i < pos; i++) {
>                         this.put(arr[i]);
>                       }
>                       pos = 0;
>                     }
>                 }
>             }
>             this.put(Stream.EOS);
>             System.out.println(this + " : END");
>         }
>         catch (InterruptedException ex) {
>             ex.printStackTrace(System.err);
>         }
>     }
> 
> 
> Alex
> 
> 
>> On 20 Jul 2017, at 15:45, Nathan and Ila Reynolds <nathanila at gmail.com <mailto:nathanila at gmail.com>> wrote:
>> 
>> > I've never understood why unpark always comes up as a performance bottleneck. What does it do that's so expensive?
>> 
>> A while ago, I talked with the engineer who has done a lot of optimization on LockSupport.unpark().  I can't remember if that implies Unsafe.unpark().
>> 
>> On Windows, LockSupport.unpark() goes into the kernel 1 time to set a Windows Event object.  On Linux, LockSupport.unpark() acquires a lock, sets a condition wait and releases a lock.  This *might* require 3 trips into the kernel.
>> 
>> Furthermore, the scheduler might let the unparked thread start running and unparking thread yield (if no logical cores are available).  Hence, unpark() will take even more time.
>> 
>> -Nathan
>> 
>> On 7/19/2017 10:50 PM, Brian S O'Neill wrote:
>>> You also didn't mention CPU core count. I ran the test on two machines, with Java 8 and with Java 9. With Java 9 I explicitly selected the parallel GC, because the G1 collector in Java 9 is a CPU pig that slows everything down.
>>> 
>>> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
>>> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>>> 
>>> Machine 1, Java 8: 9.2 seconds
>>> Machine 1, Java 9: 9.1 seconds
>>> Machine 2, Java 8: 16.9 seconds
>>> Machine 2, Java 9: 12.1 seconds
>>> 
>>> At first blush it looks like the problem is Linux, but I don't have a proper apples-to-apples comparison. I noticed that with Java 8, the number of context switches per second was about 2.5 million, and with Java 9 it was about 2.3 million. Either way, this is really high. On Windows, the context switch rate was about 1.9 million per second.
>>> 
>>> I also see a lot of variation between test runs, and when I run the code in a loop, the performance (on Windows) varies from 9 to 14 seconds per run. On Linux, I see 11 to 21 seconds when running in a loop. I also added an explicit System.gc between each test run.
>>> 
>>> When I run with -Xprof, I see the threads spending most of their time in Unsafe.unpark and Unsafe.park. I've never understood why unpark always comes up as a performance bottleneck. What does it do that's so expensive?
>>> 
>>> 
>>> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>>>> ​Ah yes, sorry I should have said we are working in Java 8.
>>>> 
>>>> graham
>>>> 
>>>> 
>>>> ------
>>>> Graham MATTHEWS, Ph.D.
>>>> Assistant Professor
>>>> Department of Computer Science |  California Lutheran University
>>>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>>> gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office location: D19
>>>> ------------------------------------------------------------------------
>>>> *From:* Martin Buchholz <martinrb at google.com <mailto:martinrb at google.com>>
>>>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>>>> *To:* Matthews, Graham
>>>> *Cc:* concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
>>>> *Subject:* Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux
>>>> One obvious variable is the version of ABQ you are using.  It was modified in jdk9 and you should be doing all performance work with latest jdk9 binaries e.g. from http://jdk.java.net/9/ <http://jdk.java.net/9/>
>>>> 
>>>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu> <mailto:gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>>> wrote:
>>>> 
>>>>    ​[apologies in advance if this is the wrong place to discuss this
>>>>    issue. also apologies for the long setup -- I promise this is about
>>>>    ArrayBlockingQueue, Java, and a performance issue with them]
>>>> 
>>>> 
>>>>    My student and I have been benchmarking various ways to run cross
>>>>    data source joins. The basic setup is as follows:
>>>> 
>>>> 
>>>>                J2
>>>> 
>>>>                /  \
>>>> 
>>>>               /    \
>>>> 
>>>>             R3  J1
>>>> 
>>>>                   /  \
>>>> 
>>>>                  /    \
>>>> 
>>>>                R2  R1
>>>> 
>>>>    R1, R2 and R3 are called receive operators as they receive data from
>>>>    the databases. J1 and J2 are inner join operators joining values
>>>>    from R2 with values from R1 and then the result with values from R3.
>>>> 
>>>>    One way to run these queries is the classic producers and consumers
>>>>    approach -- so each operator is a Java thread, and there are
>>>>    bounded queues (ArrayBlockingQueues) between the operators. So the
>>>>    above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>>>    interleave I/O with computation.
>>>> 
>>>>    Another way to run this is to first load R3 into J2 in parallel with
>>>>    loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>>>    then have a thread pool with N workers (where N is the number of
>>>>    cores), where each worker takes a value from R1 and joins it "up the
>>>>    spine" of the tree -- so matches against the hash map in J1 and then
>>>>    J2. This approach (the phased approach) therefore has an I/O phase,
>>>>    followed by a computation phase.
>>>> 
>>>> 
>>>>    On OS X El Capitan (10.11.6), the queueing approach and the phased
>>>>    approach perform roughly equally (more variation in the run times
>>>>    for the queueing approach, but performance within 10% of each
>>>>    other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>>>    three times slower than the phased approach!
>>>> 
>>>>    On top of that the queueing approach runs over twice as fast on OS X
>>>>    as it is does on Linux, despite the fact that I am running OS X on
>>>>    old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>>>    Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>>> 
>>>>    We have boiled the problem down to code that doesn't involve
>>>>    databases -- just threads and ArrayBlockingQueues. Attached are
>>>>    5 Java files which "approximate" the queueing approach by having
>>>>    each receive thread simply output numbers (rather than get values
>>>>    from a database) to an ArrayBlockingQueue, and
>>>>    each Join thread simply read its two input queues, adds the values
>>>>    together, and then output the sum to the output queue.
>>>> 
>>>>    Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>>>    X, and 2 minutes 13 secs on Linux!
>>>> 
>>>>    The code is very simple -- just a bunch of threads and a bunch of
>>>>    ArrayBlockingQueues. So I am at a loss to explain the size-able
>>>>    performance differences noted above.
>>>> 
>>>>    Again apologies if this is not the right forum to discuss this issue.
>>>> 
>>>>    graham
>>>> 
>>>>    ​
>>>>    ------
>>>>    Graham MATTHEWS, Ph.D.
>>>>    Assistant Professor
>>>>    Department of Computer Science |  California Lutheran University
>>>>    60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>>>    gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu> <mailto:gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>>  | Office
>>>>    location: D19
>>>> 
>>>>    _______________________________________________
>>>>    Concurrency-interest mailing list
>>>>    Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>>    <mailto:Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>>
>>>>    http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>>
>>>> 
>>>> 
>>>> 
>>>> 
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> -- 
>> -Nathan
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170721/e9700a3d/attachment-0001.html>

From gmatthew at callutheran.edu  Fri Jul 21 14:29:27 2017
From: gmatthew at callutheran.edu (Matthews, Graham)
Date: Fri, 21 Jul 2017 18:29:27 +0000
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>,
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
Message-ID: <1500661769757.16632@callutheran.edu>

The core count on both machines is the same -- dual cores with hyper-threading, so 4 "cores".

I have repeated the test on the Mac on JDK 9, and get the same performance figures for the Mac (1 minute 30 secs).

I have also checked the context switching level, and OS X is running the code at about 50-100K context switches per second (so an order of magnitude fewer context switches per second than you report).

We have been unable to get JDK 9 running on our Linux box, but are working on it. I will post when I have the results for our Linux box.

We had previously run this code with profiling and like you found the unpark/park issue. We had also noticed that on OS X almost 1/2 as much time is spent in park/unpark as on Linux.

------
Graham MATTHEWS, Ph.D.
Assistant Professor
Department of Computer Science |  California Lutheran University
60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
gmatthew at callutheran.edu  | Office location: D19

________________________________________
From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> on behalf of Brian S O'Neill <bronee at gmail.com>
Sent: Wednesday, July 19, 2017 9:50 PM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux

You also didn't mention CPU core count. I ran the test on two machines,
with Java 8 and with Java 9. With Java 9 I explicitly selected the
parallel GC, because the G1 collector in Java 9 is a CPU pig that slows
everything down.

Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores

Machine 1, Java 8: 9.2 seconds
Machine 1, Java 9: 9.1 seconds
Machine 2, Java 8: 16.9 seconds
Machine 2, Java 9: 12.1 seconds

At first blush it looks like the problem is Linux, but I don't have a
proper apples-to-apples comparison. I noticed that with Java 8, the
number of context switches per second was about 2.5 million, and with
Java 9 it was about 2.3 million. Either way, this is really high. On
Windows, the context switch rate was about 1.9 million per second.

I also see a lot of variation between test runs, and when I run the code
in a loop, the performance (on Windows) varies from 9 to 14 seconds per
run. On Linux, I see 11 to 21 seconds when running in a loop. I also
added an explicit System.gc between each test run.

When I run with -Xprof, I see the threads spending most of their time in
Unsafe.unpark and Unsafe.park. I've never understood why unpark always
comes up as a performance bottleneck. What does it do that's so expensive?


On 2017-07-19 09:11 PM, Matthews, Graham wrote:
> ​Ah yes, sorry I should have said we are working in Java 8.
>
> graham
>
>
> ------
> Graham MATTHEWS, Ph.D.
> Assistant Professor
> Department of Computer Science |  California Lutheran University
> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
> gmatthew at callutheran.edu  | Office location: D19
> ------------------------------------------------------------------------
> *From:* Martin Buchholz <martinrb at google.com>
> *Sent:* Wednesday, July 19, 2017 8:57 PM
> *To:* Matthews, Graham
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] strange performance issue with
> ArrayBlockingQueue on Linux
> One obvious variable is the version of ABQ you are using.  It was
> modified in jdk9 and you should be doing all performance work with
> latest jdk9 binaries e.g. from http://jdk.java.net/9/
>
> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham
> <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>
>     ​[apologies in advance if this is the wrong place to discuss this
>     issue. also apologies for the long setup -- I promise this is about
>     ArrayBlockingQueue, Java, and a performance issue with them]
>
>
>     My student and I have been benchmarking various ways to run cross
>     data source joins. The basic setup is as follows:
>
>
>                 J2
>
>                 /  \
>
>                /    \
>
>              R3  J1
>
>                    /  \
>
>                   /    \
>
>                 R2  R1
>
>     R1, R2 and R3 are called receive operators as they receive data from
>     the databases. J1 and J2 are inner join operators joining values
>     from R2 with values from R1 and then the result with values from R3.
>
>     One way to run these queries is the classic producers and consumers
>     approach -- so each operator is a Java thread, and there are
>     bounded queues (ArrayBlockingQueues) between the operators. So the
>     above example has 5 threads and 4 ArrayBlockingQueues. So here we
>     interleave I/O with computation.
>
>     Another way to run this is to first load R3 into J2 in parallel with
>     loading R2 into J1 (the loads build hash maps in J1 and J2), and
>     then have a thread pool with N workers (where N is the number of
>     cores), where each worker takes a value from R1 and joins it "up the
>     spine" of the tree -- so matches against the hash map in J1 and then
>     J2. This approach (the phased approach) therefore has an I/O phase,
>     followed by a computation phase.
>
>
>     On OS X El Capitan (10.11.6), the queueing approach and the phased
>     approach perform roughly equally (more variation in the run times
>     for the queueing approach, but performance within 10% of each
>     other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>     three times slower than the phased approach!
>
>     On top of that the queueing approach runs over twice as fast on OS X
>     as it is does on Linux, despite the fact that I am running OS X on
>     old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>     Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>
>     We have boiled the problem down to code that doesn't involve
>     databases -- just threads and ArrayBlockingQueues. Attached are
>     5 Java files which "approximate" the queueing approach by having
>     each receive thread simply output numbers (rather than get values
>     from a database) to an ArrayBlockingQueue, and
>     each Join thread simply read its two input queues, adds the values
>     together, and then output the sum to the output queue.
>
>     Onthe same hardware above this code runs in 1 minute 30 secs on OS
>     X, and 2 minutes 13 secs on Linux!
>
>     The code is very simple -- just a bunch of threads and a bunch of
>     ArrayBlockingQueues. So I am at a loss to explain the size-able
>     performance differences noted above.
>
>     Again apologies if this is not the right forum to discuss this issue.
>
>     graham
>
>     ​
>     ------
>     Graham MATTHEWS, Ph.D.
>     Assistant Professor
>     Department of Computer Science |  California Lutheran University
>     60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>     gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>     location: D19
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From martinrb at google.com  Fri Jul 21 14:38:02 2017
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 21 Jul 2017 11:38:02 -0700
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <1500661769757.16632@callutheran.edu>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
 <1500661769757.16632@callutheran.edu>
Message-ID: <CA+kOe08R-PrGVP3eJH3dZ_5YUqoLMEZNdDfyQxPymkSUvw6_rw@mail.gmail.com>

On Fri, Jul 21, 2017 at 11:29 AM, Matthews, Graham <gmatthew at callutheran.edu
> wrote:

>
> We had previously run this code with profiling and like you found the
> unpark/park issue. We had also noticed that on OS X almost 1/2 as much time
> is spent in park/unpark as on Linux.
>

Through experience I am distrustful of profilers, but I am especially
distrustful of any measurements around park/unpark.  Profilers are often
deeply confused by thread suspension.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170721/2cc95cc6/attachment.html>

From gmatthew at callutheran.edu  Mon Jul 24 20:03:30 2017
From: gmatthew at callutheran.edu (Matthews, Graham)
Date: Tue, 25 Jul 2017 00:03:30 +0000
Subject: [concurrency-interest] strange performance issue with
 ArrayBlockingQueue on Linux
In-Reply-To: <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>,
 <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
Message-ID: <1500941010516.10976@callutheran.edu>

I would like to dig down further into this issue as I am studying whether or not the traditional "threads and queues" approach is really slower than modern approaches (like SEDA), or whether the supposed slowness of the traditional approach is simply a function of the underlying threading implementation.

The results on OS X, where the traditional and modern approach have similar performance, is food for thought in this respect.

Any suggestions as to who to contact next to understand/improve the Linux performance would me most welcome.

graham

PS: I have confirmed that switching to JDK 9 doesn't change anything. If anything the code is even slower on JDK 9 than 8.

------
Graham MATTHEWS, Ph.D.
Assistant Professor
Department of Computer Science |  California Lutheran University
60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
gmatthew at callutheran.edu  | Office location: D19

________________________________________
From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> on behalf of Nathan and Ila Reynolds <nathanila at gmail.com>
Sent: Thursday, July 20, 2017 7:45 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux

 > I've never understood why unpark always comes up as a performance
bottleneck. What does it do that's so expensive?

A while ago, I talked with the engineer who has done a lot of
optimization on LockSupport.unpark().  I can't remember if that implies
Unsafe.unpark().

On Windows, LockSupport.unpark() goes into the kernel 1 time to set a
Windows Event object.  On Linux, LockSupport.unpark() acquires a lock,
sets a condition wait and releases a lock.  This *might* require 3 trips
into the kernel.

Furthermore, the scheduler might let the unparked thread start running
and unparking thread yield (if no logical cores are available).  Hence,
unpark() will take even more time.

-Nathan

On 7/19/2017 10:50 PM, Brian S O'Neill wrote:
> You also didn't mention CPU core count. I ran the test on two
> machines, with Java 8 and with Java 9. With Java 9 I explicitly
> selected the parallel GC, because the G1 collector in Java 9 is a CPU
> pig that slows everything down.
>
> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>
> Machine 1, Java 8: 9.2 seconds
> Machine 1, Java 9: 9.1 seconds
> Machine 2, Java 8: 16.9 seconds
> Machine 2, Java 9: 12.1 seconds
>
> At first blush it looks like the problem is Linux, but I don't have a
> proper apples-to-apples comparison. I noticed that with Java 8, the
> number of context switches per second was about 2.5 million, and with
> Java 9 it was about 2.3 million. Either way, this is really high. On
> Windows, the context switch rate was about 1.9 million per second.
>
> I also see a lot of variation between test runs, and when I run the
> code in a loop, the performance (on Windows) varies from 9 to 14
> seconds per run. On Linux, I see 11 to 21 seconds when running in a
> loop. I also added an explicit System.gc between each test run.
>
> When I run with -Xprof, I see the threads spending most of their time
> in Unsafe.unpark and Unsafe.park. I've never understood why unpark
> always comes up as a performance bottleneck. What does it do that's so
> expensive?
>
>
> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>> ​Ah yes, sorry I should have said we are working in Java 8.
>>
>> graham
>>
>>
>> ------
>> Graham MATTHEWS, Ph.D.
>> Assistant Professor
>> Department of Computer Science |  California Lutheran University
>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>> gmatthew at callutheran.edu  | Office location: D19
>> ------------------------------------------------------------------------
>> *From:* Martin Buchholz <martinrb at google.com>
>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>> *To:* Matthews, Graham
>> *Cc:* concurrency-interest at cs.oswego.edu
>> *Subject:* Re: [concurrency-interest] strange performance issue with
>> ArrayBlockingQueue on Linux
>> One obvious variable is the version of ABQ you are using.  It was
>> modified in jdk9 and you should be doing all performance work with
>> latest jdk9 binaries e.g. from http://jdk.java.net/9/
>>
>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham
>> <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>>
>>     ​[apologies in advance if this is the wrong place to discuss this
>>     issue. also apologies for the long setup -- I promise this is about
>>     ArrayBlockingQueue, Java, and a performance issue with them]
>>
>>
>>     My student and I have been benchmarking various ways to run cross
>>     data source joins. The basic setup is as follows:
>>
>>
>>                 J2
>>
>>                 /  \
>>
>>                /    \
>>
>>              R3  J1
>>
>>                    /  \
>>
>>                   /    \
>>
>>                 R2  R1
>>
>>     R1, R2 and R3 are called receive operators as they receive data from
>>     the databases. J1 and J2 are inner join operators joining values
>>     from R2 with values from R1 and then the result with values from R3.
>>
>>     One way to run these queries is the classic producers and consumers
>>     approach -- so each operator is a Java thread, and there are
>>     bounded queues (ArrayBlockingQueues) between the operators. So the
>>     above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>     interleave I/O with computation.
>>
>>     Another way to run this is to first load R3 into J2 in parallel with
>>     loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>     then have a thread pool with N workers (where N is the number of
>>     cores), where each worker takes a value from R1 and joins it "up the
>>     spine" of the tree -- so matches against the hash map in J1 and then
>>     J2. This approach (the phased approach) therefore has an I/O phase,
>>     followed by a computation phase.
>>
>>
>>     On OS X El Capitan (10.11.6), the queueing approach and the phased
>>     approach perform roughly equally (more variation in the run times
>>     for the queueing approach, but performance within 10% of each
>>     other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>     three times slower than the phased approach!
>>
>>     On top of that the queueing approach runs over twice as fast on OS X
>>     as it is does on Linux, despite the fact that I am running OS X on
>>     old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>     Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>
>>     We have boiled the problem down to code that doesn't involve
>>     databases -- just threads and ArrayBlockingQueues. Attached are
>>     5 Java files which "approximate" the queueing approach by having
>>     each receive thread simply output numbers (rather than get values
>>     from a database) to an ArrayBlockingQueue, and
>>     each Join thread simply read its two input queues, adds the values
>>     together, and then output the sum to the output queue.
>>
>>     Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>     X, and 2 minutes 13 secs on Linux!
>>
>>     The code is very simple -- just a bunch of threads and a bunch of
>>     ArrayBlockingQueues. So I am at a loss to explain the size-able
>>     performance differences noted above.
>>
>>     Again apologies if this is not the right forum to discuss this
>> issue.
>>
>>     graham
>>
>>     ​
>>     ------
>>     Graham MATTHEWS, Ph.D.
>>     Assistant Professor
>>     Department of Computer Science |  California Lutheran University
>>     60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>     gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>>     location: D19
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu
>>     <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

--
-Nathan

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From oleksandr.otenko at gmail.com  Tue Jul 25 05:04:13 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 25 Jul 2017 10:04:13 +0100
Subject: [concurrency-interest] strange performance issue with
	ArrayBlockingQueue on Linux
In-Reply-To: <1500941010516.10976@callutheran.edu>
References: <1500522083051.77042@callutheran.edu>
 <CA+kOe092-FWnpMtq5WnJD03KWySXsMtSikXszKT6OAOv_GaPAA@mail.gmail.com>
 <1500523874644.85107@callutheran.edu>
 <3ff945ab-ef17-1f45-65f3-a696135eab8b@gmail.com>
 <0db58fca-d452-5009-f4b1-3774772dff3e@gmail.com>
 <1500941010516.10976@callutheran.edu>
Message-ID: <3B910AF6-B997-4175-A6D7-3CDA13962E34@gmail.com>

Are you studying scheduler performance for complex dependency graphs?

For example, when I look at my Linux behaviour, I see that J* threads move only a few items at a time before blocking, whereas Mac is able to move an order of magnitude more (and completes in my case an order of magnitude faster - your mileage varies, but maybe that’s also linked to how much the threads move before blocking).

Solving this problem is not easy, because the optimal scheduler needs to know that they do not need to schedule J3 or J1 too soon - that it is more profitable to schedule J1 when more space is freed in the queue by J2 (and in the mean time use the CPU to run something else), and to schedule J3 when more space is used up in the queue by J2 - so that J3 moves many items to J4, and J4 moves many items to J5, etc, instead of spending one context switch per one move. So the cost of context switch is not so much an impact as scheduling the threads *late* enough.

Steering scheduling here would be an interesting problem.


Alex

> On 25 Jul 2017, at 01:03, Matthews, Graham <gmatthew at callutheran.edu> wrote:
> 
> I would like to dig down further into this issue as I am studying whether or not the traditional "threads and queues" approach is really slower than modern approaches (like SEDA), or whether the supposed slowness of the traditional approach is simply a function of the underlying threading implementation.
> 
> The results on OS X, where the traditional and modern approach have similar performance, is food for thought in this respect.
> 
> Any suggestions as to who to contact next to understand/improve the Linux performance would me most welcome.
> 
> graham
> 
> PS: I have confirmed that switching to JDK 9 doesn't change anything. If anything the code is even slower on JDK 9 than 8.
> 
> ------
> Graham MATTHEWS, Ph.D.
> Assistant Professor
> Department of Computer Science |  California Lutheran University
> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
> gmatthew at callutheran.edu  | Office location: D19
> 
> ________________________________________
> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> on behalf of Nathan and Ila Reynolds <nathanila at gmail.com>
> Sent: Thursday, July 20, 2017 7:45 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] strange performance issue with ArrayBlockingQueue on Linux
> 
>> I've never understood why unpark always comes up as a performance
> bottleneck. What does it do that's so expensive?
> 
> A while ago, I talked with the engineer who has done a lot of
> optimization on LockSupport.unpark().  I can't remember if that implies
> Unsafe.unpark().
> 
> On Windows, LockSupport.unpark() goes into the kernel 1 time to set a
> Windows Event object.  On Linux, LockSupport.unpark() acquires a lock,
> sets a condition wait and releases a lock.  This *might* require 3 trips
> into the kernel.
> 
> Furthermore, the scheduler might let the unparked thread start running
> and unparking thread yield (if no logical cores are available).  Hence,
> unpark() will take even more time.
> 
> -Nathan
> 
> On 7/19/2017 10:50 PM, Brian S O'Neill wrote:
>> You also didn't mention CPU core count. I ran the test on two
>> machines, with Java 8 and with Java 9. With Java 9 I explicitly
>> selected the parallel GC, because the G1 collector in Java 9 is a CPU
>> pig that slows everything down.
>> 
>> Machine 1: Windows 10, Intel Xeon E31245 3.3GHz, 8 logical cores
>> Machine 2: Linux 4.10, AMD Ryzen 7 1700 3.0Ghz, 16 logical cores
>> 
>> Machine 1, Java 8: 9.2 seconds
>> Machine 1, Java 9: 9.1 seconds
>> Machine 2, Java 8: 16.9 seconds
>> Machine 2, Java 9: 12.1 seconds
>> 
>> At first blush it looks like the problem is Linux, but I don't have a
>> proper apples-to-apples comparison. I noticed that with Java 8, the
>> number of context switches per second was about 2.5 million, and with
>> Java 9 it was about 2.3 million. Either way, this is really high. On
>> Windows, the context switch rate was about 1.9 million per second.
>> 
>> I also see a lot of variation between test runs, and when I run the
>> code in a loop, the performance (on Windows) varies from 9 to 14
>> seconds per run. On Linux, I see 11 to 21 seconds when running in a
>> loop. I also added an explicit System.gc between each test run.
>> 
>> When I run with -Xprof, I see the threads spending most of their time
>> in Unsafe.unpark and Unsafe.park. I've never understood why unpark
>> always comes up as a performance bottleneck. What does it do that's so
>> expensive?
>> 
>> 
>> On 2017-07-19 09:11 PM, Matthews, Graham wrote:
>>> ​Ah yes, sorry I should have said we are working in Java 8.
>>> 
>>> graham
>>> 
>>> 
>>> ------
>>> Graham MATTHEWS, Ph.D.
>>> Assistant Professor
>>> Department of Computer Science |  California Lutheran University
>>> 60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>> gmatthew at callutheran.edu  | Office location: D19
>>> ------------------------------------------------------------------------
>>> *From:* Martin Buchholz <martinrb at google.com>
>>> *Sent:* Wednesday, July 19, 2017 8:57 PM
>>> *To:* Matthews, Graham
>>> *Cc:* concurrency-interest at cs.oswego.edu
>>> *Subject:* Re: [concurrency-interest] strange performance issue with
>>> ArrayBlockingQueue on Linux
>>> One obvious variable is the version of ABQ you are using.  It was
>>> modified in jdk9 and you should be doing all performance work with
>>> latest jdk9 binaries e.g. from http://jdk.java.net/9/
>>> 
>>> On Wed, Jul 19, 2017 at 8:41 PM, Matthews, Graham
>>> <gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>> wrote:
>>> 
>>>    ​[apologies in advance if this is the wrong place to discuss this
>>>    issue. also apologies for the long setup -- I promise this is about
>>>    ArrayBlockingQueue, Java, and a performance issue with them]
>>> 
>>> 
>>>    My student and I have been benchmarking various ways to run cross
>>>    data source joins. The basic setup is as follows:
>>> 
>>> 
>>>                J2
>>> 
>>>                /  \
>>> 
>>>               /    \
>>> 
>>>             R3  J1
>>> 
>>>                   /  \
>>> 
>>>                  /    \
>>> 
>>>                R2  R1
>>> 
>>>    R1, R2 and R3 are called receive operators as they receive data from
>>>    the databases. J1 and J2 are inner join operators joining values
>>>    from R2 with values from R1 and then the result with values from R3.
>>> 
>>>    One way to run these queries is the classic producers and consumers
>>>    approach -- so each operator is a Java thread, and there are
>>>    bounded queues (ArrayBlockingQueues) between the operators. So the
>>>    above example has 5 threads and 4 ArrayBlockingQueues. So here we
>>>    interleave I/O with computation.
>>> 
>>>    Another way to run this is to first load R3 into J2 in parallel with
>>>    loading R2 into J1 (the loads build hash maps in J1 and J2), and
>>>    then have a thread pool with N workers (where N is the number of
>>>    cores), where each worker takes a value from R1 and joins it "up the
>>>    spine" of the tree -- so matches against the hash map in J1 and then
>>>    J2. This approach (the phased approach) therefore has an I/O phase,
>>>    followed by a computation phase.
>>> 
>>> 
>>>    On OS X El Capitan (10.11.6), the queueing approach and the phased
>>>    approach perform roughly equally (more variation in the run times
>>>    for the queueing approach, but performance within 10% of each
>>>    other). On Linux (Ubuntu 16.04 LTS)the queueing approach is almost
>>>    three times slower than the phased approach!
>>> 
>>>    On top of that the queueing approach runs over twice as fast on OS X
>>>    as it is does on Linux, despite the fact that I am running OS X on
>>>    old hardware (mid 2012 Macbook Pro, 3rd Gen Intel Core i5 3210M) and
>>>    Linux on relatively new hardware (6th Gen Intel Core i7-5500U).
>>> 
>>>    We have boiled the problem down to code that doesn't involve
>>>    databases -- just threads and ArrayBlockingQueues. Attached are
>>>    5 Java files which "approximate" the queueing approach by having
>>>    each receive thread simply output numbers (rather than get values
>>>    from a database) to an ArrayBlockingQueue, and
>>>    each Join thread simply read its two input queues, adds the values
>>>    together, and then output the sum to the output queue.
>>> 
>>>    Onthe same hardware above this code runs in 1 minute 30 secs on OS
>>>    X, and 2 minutes 13 secs on Linux!
>>> 
>>>    The code is very simple -- just a bunch of threads and a bunch of
>>>    ArrayBlockingQueues. So I am at a loss to explain the size-able
>>>    performance differences noted above.
>>> 
>>>    Again apologies if this is not the right forum to discuss this
>>> issue.
>>> 
>>>    graham
>>> 
>>>    ​
>>>    ------
>>>    Graham MATTHEWS, Ph.D.
>>>    Assistant Professor
>>>    Department of Computer Science |  California Lutheran University
>>>    60 W. Olsen Rd.  |  Thousand Oaks, CA 91360
>>>    gmatthew at callutheran.edu <mailto:gmatthew at callutheran.edu>  | Office
>>>    location: D19
>>> 
>>>    _______________________________________________
>>>    Concurrency-interest mailing list
>>>    Concurrency-interest at cs.oswego.edu
>>>    <mailto:Concurrency-interest at cs.oswego.edu>
>>>    http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> 
>>> 
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> --
> -Nathan
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


