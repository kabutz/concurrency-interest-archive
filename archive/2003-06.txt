From michael.mattox@verideon.com  Fri Jun  6 16:31:30 2003
From: michael.mattox@verideon.com (Michael Mattox)
Date: Fri, 6 Jun 2003 17:31:30 +0200
Subject: [concurrency-interest] Example using TimedCallable with PooledExecutor
Message-ID: <CJEBLDCHAADCLAGIGCOOIELACIAA.michael.mattox@verideon.com>

I'm using a PooledExecuter but sometimes my threads hang forever and I want
to add a timeout.  I looked at the TimedCallable class but it's not clear
how to use it for my particular example (I tried the example in the
FutureResult class).  Can someone give me a hint on how to use this?

	private boolean addMonitorToQueue(String monitorId) {
		boolean success = false;
		DispatcherThread thread;
		try {
			thread = new DispatcherThread(monitorId);
			if (!queue.contains(thread)) {
				try {
					pool.execute(thread);
					success = true;
					log.debug("Added monitor " + monitorId + " to the queue.");
				} catch (InterruptedException e) {
					log.error("Could not add thread for monitor " + monitorId + " : ", e);
				}
			} else {
				log.debug("Did not add monitor " + monitorId + " to the queue because
it's already in the queue. ");
			}
		} catch (TechnicalException e) {
			log.error("Could not dispatch thread for monitor: " + monitorId, e);
		}
		return success;
	}

Thanks!
Michael





From cargill@profcon.com  Fri Jun  6 17:35:38 2003
From: cargill@profcon.com (Tom Cargill)
Date: Fri, 06 Jun 2003 10:35:38 -0600
Subject: [concurrency-interest] Swing translates InterruptedException to Error
Message-ID: <5.2.0.9.1.20030606103325.0c66b0b8@192.168.2.2>

[If this is off-topic, just ignore me.]

I just encountered the following code in

    javax/swing/text/AbstractDocument.java

The practice of translating an InterruptedException to an Error
strikes me as bizarre. Can anyone offer a rationale for this policy?

====================================================================

protected
synchronized
final
void writeLock() {
   try {
     while ((numReaders > 0) || (currWriter != null)) {
       if (Thread.currentThread() == currWriter) {
         if (notifyingListeners) {
           throw new IllegalStateException("Attempt to mutate in 
notification");
         }
         numWriters++;
         return;
       }
       wait();
     }
     currWriter = Thread.currentThread();
     numWriters = 1;
   } catch (InterruptedException e) {
     throw new Error("Interrupted attempt to aquire write lock");
   }
}
~~
http://www.profcon.com/cargill


From leou@us.ibm.com  Fri Jun  6 18:14:23 2003
From: leou@us.ibm.com (Leo Uzcategui)
Date: Fri, 6 Jun 2003 11:14:23 -0600
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OF469F989B.0B9755E0-ON87256D3D.005EB382-87256D3D.005EB383@us.ibm.com>




I will be out of the office starting May 30, 2003 and will not return until
June 16, 2003.

For assistance, please contact Robin Redden at (512) 838-1542.


From jozart@csi.com  Fri Jun  6 20:06:28 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Fri, 6 Jun 2003 12:06:28 -0700
Subject: [concurrency-interest] Swing translates InterruptedException to Error
References: <5.2.0.9.1.20030606103325.0c66b0b8@192.168.2.2>
Message-ID: <090101c32c5e$bc1f1f10$d0827cce@REPLICANT2>

Tom,

I reported some major problems with readLock and writeLock back in '99.

Originally, writeLock just ate the exception:

        } catch (InterruptedException e) {
            // safe to let this pass... write lock not
            // held if the thread lands here.
        }

This was later changed to a non-checked exception.  (Non-checked in order to
preserve the method signature.)

At the time, I believed there were other problems with the support for
asynchonous loading in AbstractDocument as well:

    "AbstractDocument supports reading the document asynchronously and then
sending the update events to DocumentListeners (in the reading thread).
Aside from the incomplete, fragile implemention, the design does not account
for the fact that the DocumentListeners are part of Swing's single-threaded
subsystem.  I see no extensible way to insert an asynchronous model into a
single-threaded subsystem (with stateless events) such as Swing's."

I can send more details if you'd like.


----- Original Message ----- 
From: "Tom Cargill" <cargill@profcon.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, June 06, 2003 9:35 AM
Subject: [concurrency-interest] Swing translates InterruptedException to
Error

[If this is off-topic, just ignore me.]

I just encountered the following code in

    javax/swing/text/AbstractDocument.java

The practice of translating an InterruptedException to an Error
strikes me as bizarre. Can anyone offer a rationale for this policy?

====================================================================

protected
synchronized
final
void writeLock() {
   try {
     while ((numReaders > 0) || (currWriter != null)) {
       if (Thread.currentThread() == currWriter) {
         if (notifyingListeners) {
           throw new IllegalStateException(
            "Attempt to mutate in notification");
         }
         numWriters++;
         return;
       }
       wait();
     }
     currWriter = Thread.currentThread();
     numWriters = 1;
   } catch (InterruptedException e) {
     throw new Error("Interrupted attempt to aquire write lock");
   }
}
~~
http://www.profcon.com/cargill



From jozart@csi.com  Fri Jun  6 22:26:30 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Fri, 6 Jun 2003 14:26:30 -0700
Subject: [concurrency-interest] Example using TimedCallable with PooledExecutor
References: <CJEBLDCHAADCLAGIGCOOIELACIAA.michael.mattox@verideon.com>
Message-ID: <09c401c32c72$4c4303a0$d0827cce@REPLICANT2>

This is a multi-part message in MIME format.

------=_NextPart_000_09C1_01C32C37.9F9CC260
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Michael,

TimedCallable is designed for Callables (which can be viewed as "super" =
Runnables).

For simple Runnables you can use thread.join() as follows:

  Thread thread =3D new Thread(runnable);
  thread.start();
  try {
    thread.join(timeout);
  } catch (InterruptedException ex) {
    /* Stop thread if we were interrupted or timed-out
     * while waiting for the result.
     */
    thread.interrupt();
    throw ex;
  }

This doubles the thread count in your system.  If you do this alot, I =
recommend handling the timeouts on a single timer thread.

Also, note that thread.interrupt() may not do anything -- depending on =
what the runnable is doing at the time and whether it was written to be =
responsive to interrupts.



----- Original Message -----=20
From: "Michael Mattox" <michael.mattox@verideon.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Friday, June 06, 2003 8:31 AM
Subject: [concurrency-interest] Example using TimedCallable with =
PooledExecutor



I'm using a PooledExecuter but sometimes my threads hang forever and I =
want
to add a timeout.  I looked at the TimedCallable class but it's not =
clear
how to use it for my particular example (I tried the example in the
FutureResult class).  Can someone give me a hint on how to use this?

private boolean addMonitorToQueue(String monitorId) {
boolean success =3D false;
DispatcherThread thread;
try {
thread =3D new DispatcherThread(monitorId);
if (!queue.contains(thread)) {
try {
pool.execute(thread);
success =3D true;
log.debug("Added monitor " + monitorId + " to the queue.");
} catch (InterruptedException e) {
log.error("Could not add thread for monitor " + monitorId + " : ", e);
}
} else {
log.debug("Did not add monitor " + monitorId + " to the queue because
it's already in the queue. ");
}
} catch (TechnicalException e) {
log.error("Could not dispatch thread for monitor: " + monitorId, e);
}
return success;
}

Thanks!
Michael

------=_NextPart_000_09C1_01C32C37.9F9CC260
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1170" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY>
<DIV><FONT face=3DArial size=3D2>
<DIV>Michael,</DIV>
<DIV>&nbsp;</DIV>
<DIV>TimedCallable is designed for Callables (which can be viewed as =
"super"=20
Runnables).</DIV>
<DIV>&nbsp;</DIV>
<DIV>For simple Runnables you can use thread.join() as follows:</DIV>
<DIV>&nbsp;</DIV></FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp; Thread thread =3D new=20
Thread(runnable);</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp; thread.start();</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp; try {</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;=20
thread.join(timeout);</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp; }&nbsp;</FONT><FONT face=3DArial =
size=3D2>catch=20
(InterruptedException ex) {</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; /* Stop thread if we =
were=20
interrupted or timed-out</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;&nbsp; * while =
waiting for the=20
result.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;&nbsp; =
*/</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; =
thread.interrupt();</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; throw =
ex;</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp; }</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>This doubles the thread count&nbsp;in =
your=20
system.&nbsp; If you do this alot, I recommend handling the timeouts on =
a single=20
timer thread.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Also, note that thread.interrupt() may =
not do=20
anything -- depending on what the runnable is doing at the time and =
whether it=20
was written to be responsive to interrupts.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>----- Original Message ----- </FONT>
<DIV><FONT face=3DArial size=3D2>From: "Michael Mattox" &lt;</FONT><A=20
href=3D"mailto:michael.mattox@verideon.com"><FONT face=3DArial=20
size=3D2>michael.mattox@verideon.com</FONT></A><FONT face=3DArial=20
size=3D2>&gt;</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>To: &lt;</FONT><A=20
href=3D"mailto:concurrency-interest@altair.cs.oswego.edu"><FONT =
face=3DArial=20
size=3D2>concurrency-interest@altair.cs.oswego.edu</FONT></A><FONT =
face=3DArial=20
size=3D2>&gt;</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>Sent: Friday, June 06, 2003 8:31 =
AM</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>Subject: [concurrency-interest] Example =
using=20
TimedCallable with PooledExecutor</FONT></DIV></DIV>
<DIV><FONT face=3DArial><BR><FONT size=3D2></FONT></FONT></DIV><BR><FONT =
face=3DArial=20
size=3D2>I'm using a PooledExecuter but sometimes my threads hang =
forever and I=20
want<BR>to add a timeout.&nbsp; I looked at the TimedCallable class but =
it's not=20
clear<BR>how to use it for my particular example (I tried the example in =

the<BR>FutureResult class).&nbsp; Can someone give me a hint on how to =
use=20
this?<BR><BR>private boolean addMonitorToQueue(String monitorId) =
{<BR>boolean=20
success =3D false;<BR>DispatcherThread thread;<BR>try {<BR>thread =3D =
new=20
DispatcherThread(monitorId);<BR>if (!queue.contains(thread)) {<BR>try=20
{<BR>pool.execute(thread);<BR>success =3D true;<BR>log.debug("Added =
monitor " +=20
monitorId + " to the queue.");<BR>} catch (InterruptedException e)=20
{<BR>log.error("Could not add thread for monitor " + monitorId + " : ",=20
e);<BR>}<BR>} else {<BR>log.debug("Did not add monitor " + monitorId + " =
to the=20
queue because<BR>it's already in the queue. ");<BR>}<BR>} catch=20
(TechnicalException e) {<BR>log.error("Could not dispatch thread for =
monitor: "=20
+ monitorId, e);<BR>}<BR>return=20
success;<BR>}<BR><BR>Thanks!<BR>Michael<BR></FONT></BODY></HTML>

------=_NextPart_000_09C1_01C32C37.9F9CC260--


From dl@cs.oswego.edu  Sat Jun  7 21:32:36 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 7 Jun 2003 16:32:36 -0400
Subject: [concurrency-interest] Preliminary test release 1 now available
Message-ID: <16098.19428.27778.845257@altair.cs.oswego.edu>

Check out the for-masochists-only preliminary test release page:
   http://gee.cs.oswego.edu/dl/concurrency-interest/jsr166/

Where it says...
  Preliminary versions of JSR166 concurrency utilities are available for
  you to try out on solaris-sparc and linux-x86 (only; sorry).  To run
  these, you need to get not only the classes, but also a set of hotspot
  add-ons for JDK1.4.1. (NOT 1.4.2; sorry) as well as the early-access
  1.5 compiler.  A shell script that you will fill out paths for will
  allow you to run a 1.4.1 server (not client; sorry) VM that also
  contains the new primitives that support new functionality.  

  This is the first of several planned preliminary test releases.
  There may be bugs. APIs will change. Etc. We appreciate your help in
  tracking down any problems; the earlier the better.

A few other notes:

This is a release-and-get-out-of-town-quick scheme :-). I will be out
at JavaOne, ACM FRC, and elsewhere for the next 10 days, So I will
probably not be able to reply to questions promptly.  This release
really is "preliminary". The javadocs need improvement, there are a
few small planned functionality improvements, and some functionality
has not been tested. You can help make it better.

As previously previewed, we are interested in gathering good test
cases, expecially code that exposes the package to unusual situations.
We'd especially like your help in this.  We may set up a mechanism to
coordinate this.

-Doug

From jozart@csi.com  Sun Jun  8 09:34:20 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Sun, 8 Jun 2003 01:34:20 -0700
Subject: [concurrency-interest] Example using TimedCallable with PooledExecutor
References: <CJEBLDCHAADCLAGIGCOOIELACIAA.michael.mattox@verideon.com> <09c401c32c72$4c4303a0$d0827cce@REPLICANT2>
Message-ID: <003f01c32d98$c219b750$29827cce@REPLICANT2>

This is a multi-part message in MIME format.

------=_NextPart_000_003C_01C32D5E.1545FD70
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Michael,

Here's a version that uses a single java.util.Timer thread to handle the =
cancellations.

Timer timer =3D new Timer();

Submit command to an executor.  When it runs, it schedules a timer task =
to interrupt it when the allotted time has expired.  When it finishes, =
it cancels the timer task and clears the interrupt flag (just in case an =
interrupt from the timer task went unnoticed).

This version creates fewer threads than TimedCallable, but relies more =
on the command to be responsive to interrupts.

Runnable command =3D new Runnable() {
    public void run() {
        TimerTask task =3D new TimerTask() {
            Thread thread =3D Thread.currentThread();
            public void run() {
                thread.interrupt(); // interrupt work
            }
        }
        timer.schedule(task, timeout);
        try {
            // do interruptible work ...
        } finally {
            task.cancel();
            Thread.interrupted(); // clear interrupt flag
        }
    }
}


  ----- Original Message -----=20
  From: Joseph Bowbeer=20
  To: michael.mattox@verideon.com ; =
concurrency-interest@altair.cs.oswego.edu=20
  Sent: Friday, June 06, 2003 2:26 PM
  Subject: Re: [concurrency-interest] Example using TimedCallable with =
PooledExecutor


  Michael,

  TimedCallable is designed for Callables (which can be viewed as =
"super" Runnables).

  For simple Runnables you can use thread.join() as follows:

    Thread thread =3D new Thread(runnable);
    thread.start();
    try {
      thread.join(timeout);
    } catch (InterruptedException ex) {
      /* Stop thread if we were interrupted or timed-out
       * while waiting for the result.
       */
      thread.interrupt();
      throw ex;
    }

  This doubles the thread count in your system.  If you do this a lot, I =
recommend handling the timeouts on a single timer thread.

  Also, note that thread.interrupt() may not do anything -- depending on =
what the runnable is doing at the time and whether it was written to be =
responsive to interrupts.



  ----- Original Message -----=20
  From: "Michael Mattox" <michael.mattox@verideon.com>
  To: <concurrency-interest@altair.cs.oswego.edu>
  Sent: Friday, June 06, 2003 8:31 AM
  Subject: [concurrency-interest] Example using TimedCallable with =
PooledExecutor



  I'm using a PooledExecuter but sometimes my threads hang forever and I =
want
  to add a timeout.  I looked at the TimedCallable class but it's not =
clear
  how to use it for my particular example (I tried the example in the
  FutureResult class).  Can someone give me a hint on how to use this?

  private boolean addMonitorToQueue(String monitorId) {
  boolean success =3D false;
  DispatcherThread thread;
  try {
  thread =3D new DispatcherThread(monitorId);
  if (!queue.contains(thread)) {
  try {
  pool.execute(thread);
  success =3D true;
  log.debug("Added monitor " + monitorId + " to the queue.");
  } catch (InterruptedException e) {
  log.error("Could not add thread for monitor " + monitorId + " : ", e);
  }
  } else {
  log.debug("Did not add monitor " + monitorId + " to the queue because
  it's already in the queue. ");
  }
  } catch (TechnicalException e) {
  log.error("Could not dispatch thread for monitor: " + monitorId, e);
  }
  return success;
  }

  Thanks!
  Michael

------=_NextPart_000_003C_01C32D5E.1545FD70
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1170" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>
<DIV><FONT face=3DArial size=3D2>Michael,</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Here's a version that uses a single =
java.util.Timer=20
thread to handle the cancellations.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Timer timer =3D new =
Timer();</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>
<DIV><FONT face=3DArial size=3D2>Submit command to an executor.&nbsp; =
When it runs,=20
it schedules a timer task to interrupt it when the allotted time has=20
expired.&nbsp; When it finishes, it cancels the timer task and clears =
the=20
interrupt flag (just in case an interrupt from the timer task went=20
unnoticed).</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV>This version creates&nbsp;fewer threads than TimedCallable, but =
relies more=20
on the command to be responsive to interrupts.</DIV>
<DIV><FONT face=3DArial =
size=3D2></FONT>&nbsp;</DIV>Runnable&nbsp;command =3D new=20
Runnable() {</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; public void run() =
{</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; =
TimerTask=20
task =3D new TimerTask() {</FONT></DIV>
<DIV><FONT face=3DArial=20
size=3D2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p; Thread=20
thread =3D Thread.currentThread();</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; public void run() {</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; thread.interrupt(); // interrupt=20
work</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; }</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
}</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
timer.schedule(task, timeout);</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; =
try=20
{</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; // do interruptible work ...</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } =
finally=20
{</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; task.cancel();</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;=20
&nbsp;&nbsp;&nbsp; Thread.interrupted(); // clear interrupt =
flag</FONT></DIV>
<DIV><FONT face=3DArial=20
size=3D2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; }</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>}</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV></FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<BLOCKQUOTE=20
style=3D"PADDING-RIGHT: 0px; PADDING-LEFT: 5px; MARGIN-LEFT: 5px; =
BORDER-LEFT: #000000 2px solid; MARGIN-RIGHT: 0px">
  <DIV style=3D"FONT: 10pt arial">----- Original Message ----- </DIV>
  <DIV=20
  style=3D"BACKGROUND: #e4e4e4; FONT: 10pt arial; font-color: =
black"><B>From:</B>=20
  <A title=3Djozart@csi.com href=3D"mailto:jozart@csi.com">Joseph =
Bowbeer</A> </DIV>
  <DIV style=3D"FONT: 10pt arial"><B>To:</B> <A =
title=3Dmichael.mattox@verideon.com=20
  =
href=3D"mailto:michael.mattox@verideon.com">michael.mattox@verideon.com</=
A> ; <A=20
  title=3Dconcurrency-interest@altair.cs.oswego.edu=20
  =
href=3D"mailto:concurrency-interest@altair.cs.oswego.edu">concurrency-int=
erest@altair.cs.oswego.edu</A>=20
  </DIV>
  <DIV style=3D"FONT: 10pt arial"><B>Sent:</B> Friday, June 06, 2003 =
2:26 PM</DIV>
  <DIV style=3D"FONT: 10pt arial"><B>Subject:</B> Re: =
[concurrency-interest]=20
  Example using TimedCallable with PooledExecutor</DIV>
  <DIV><BR></DIV>
  <DIV><FONT face=3DArial size=3D2>
  <DIV>Michael,</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>TimedCallable is designed for Callables (which can be viewed as =
"super"=20
  Runnables).</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>For simple Runnables you can use thread.join() as follows:</DIV>
  <DIV>&nbsp;</DIV></FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp; Thread thread =3D new=20
  Thread(runnable);</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp; thread.start();</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp; try {</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;=20
  thread.join(timeout);</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp; }&nbsp;</FONT><FONT =
face=3DArial=20
  size=3D2>catch (InterruptedException ex) {</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; /* Stop thread if =
we were=20
  interrupted or timed-out</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;&nbsp; * while =
waiting for the=20
  result.</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;&nbsp; =
*/</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp;=20
  thread.interrupt();</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; throw =
ex;</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>&nbsp; }</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
  <DIV><FONT face=3DArial size=3D2>This doubles the thread count&nbsp;in =
your=20
  system.&nbsp; If you do this a lot, I recommend handling the timeouts =
on a=20
  single timer thread.</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
  <DIV><FONT face=3DArial size=3D2>Also, note that thread.interrupt() =
may not do=20
  anything -- depending on what the runnable is doing at the time and =
whether it=20
  was written to be responsive to interrupts.</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
  <DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
  <DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
  <DIV><FONT face=3DArial size=3D2>----- Original Message ----- </FONT>
  <DIV><FONT face=3DArial size=3D2>From: "Michael Mattox" &lt;</FONT><A=20
  href=3D"mailto:michael.mattox@verideon.com"><FONT face=3DArial=20
  size=3D2>michael.mattox@verideon.com</FONT></A><FONT face=3DArial=20
  size=3D2>&gt;</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>To: &lt;</FONT><A=20
  href=3D"mailto:concurrency-interest@altair.cs.oswego.edu"><FONT =
face=3DArial=20
  size=3D2>concurrency-interest@altair.cs.oswego.edu</FONT></A><FONT =
face=3DArial=20
  size=3D2>&gt;</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>Sent: Friday, June 06, 2003 8:31 =
AM</FONT></DIV>
  <DIV><FONT face=3DArial size=3D2>Subject: [concurrency-interest] =
Example using=20
  TimedCallable with PooledExecutor</FONT></DIV></DIV>
  <DIV><FONT face=3DArial><BR><FONT =
size=3D2></FONT></FONT></DIV><BR><FONT=20
  face=3DArial size=3D2>I'm using a PooledExecuter but sometimes my =
threads hang=20
  forever and I want<BR>to add a timeout.&nbsp; I looked at the =
TimedCallable=20
  class but it's not clear<BR>how to use it for my particular example (I =
tried=20
  the example in the<BR>FutureResult class).&nbsp; Can someone give me a =
hint on=20
  how to use this?<BR><BR>private boolean addMonitorToQueue(String =
monitorId)=20
  {<BR>boolean success =3D false;<BR>DispatcherThread thread;<BR>try =
{<BR>thread =3D=20
  new DispatcherThread(monitorId);<BR>if (!queue.contains(thread)) =
{<BR>try=20
  {<BR>pool.execute(thread);<BR>success =3D true;<BR>log.debug("Added =
monitor " +=20
  monitorId + " to the queue.");<BR>} catch (InterruptedException e)=20
  {<BR>log.error("Could not add thread for monitor " + monitorId + " : =
",=20
  e);<BR>}<BR>} else {<BR>log.debug("Did not add monitor " + monitorId + =
" to=20
  the queue because<BR>it's already in the queue. ");<BR>}<BR>} catch=20
  (TechnicalException e) {<BR>log.error("Could not dispatch thread for =
monitor:=20
  " + monitorId, e);<BR>}<BR>return=20
success;<BR>}<BR><BR>Thanks!<BR>Michael<BR></BLOCKQUOTE></FONT></BODY></H=
TML>

------=_NextPart_000_003C_01C32D5E.1545FD70--


From michael.mattox@verideon.com  Wed Jun 18 08:45:03 2003
From: michael.mattox@verideon.com (Michael Mattox)
Date: Wed, 18 Jun 2003 09:45:03 +0200
Subject: [concurrency-interest] LinkedQueue extensions
Message-ID: <CJEBLDCHAADCLAGIGCOOCEGDCKAA.michael.mattox@verideon.com>

I need some extra functionality on the LinkedQueue method.  I extended the
class and I'd like to know if my new methods are OK.  I have very little
experience coding multithreaded code so I'd like to double check my code.
The methods I need are: contains, size, and getContents.  My app has been
hanging near the spot where I call the contains method and I wonder if there
could be a deadlock or something.

If these changes are OK, should I contribute them as a patch?

Thanks,
Michael

--

package com.verideon.veriguard.util;

import java.util.*;

import EDU.oswego.cs.dl.util.concurrent.*;

public class LinkedQueueWithContains extends
EDU.oswego.cs.dl.util.concurrent.LinkedQueue {

	public LinkedQueueWithContains() {
		super();
	}

	public boolean contains(Object o) {
		synchronized (head_) {
			if (head_ != null) {
				LinkedNode current = head_.next;
				while (current != null) {
					if (current.value.equals(o)) {
						return true;
					} else {
						current = current.next;
					}
				}
			}
			return false;
		}
	}

	public List getContents() {
		List contents = new LinkedList();

		synchronized (head_) {
			if (head_ != null) {
				LinkedNode current = head_.next;
				while (current != null) {
					contents.add(current.value);
					current = current.next;
				}
			}
		}
		return contents;
	}

	public int getSize() {
		int size = 0;
		synchronized (head_) {
			if (head_ != null) {
				LinkedNode current = head_.next;
				while (current != null) {
					size++;
					current = current.next;
				}
			}
		}
		return size;
	}
}



From leon@instagrade.com  Tue Jun 17 23:21:32 2003
From: leon@instagrade.com (Leon Chadwick)
Date: Tue, 17 Jun 2003 23:21:32 +0100
Subject: [concurrency-interest] Observability of Semaphore
Message-ID: <E2CE79A85B62AB4AB7DDE8E00578967F6E5C@dc02.instagrade.com>

Hello,
        I have been looking at the JSR166 specification API for java.util.concurrent and also your earlier (excellent by the way) release of the concurrency package.
I have a requirement that is partly fulfilled by the ObservableSync class, however I was concerned about whether this feature will be available in the java.util.concurrent package.

Basically, I am implementing a conditional tree where nodes in the tree have true/false values, and I need to support nodes whose value is derived from whether a lock style object has been acquired or not. (e.g. for a semaphore, have any of the permits been taken - note the semaphore allows me to get the current available permits but not the initial count of permits at construction, so I cannot even work this out using solely the semaphore object).


My specific application which will use this conditional tree allows a button on a gui to be enabled if and only if multiple conditions anded together evaluate to true, and one of these conditions is whether a lock has been obtained.
I want to use something like the observable pattern on my conditions so that when a condition changes the whole tree is re-evaluated, and in my application the button would become enabled if the conditions were met.

I know that I could have my application written using a style where all programming involving acquiring/releasing a lock also sets state on a condition object immediately before/after the acquire/release, however it would be a better design if I could make use of observability on the lock itself as then programming errors could be avoided.

Any thoughts you have on this subject would be much appreciated so I know which direction I should be working on for future compatability.

Regards

Leon Chadwick

Chief Technology Officer
Instagrade Limited



From jozart@csi.com  Wed Jun 18 11:36:20 2003
From: jozart@csi.com (Joseph Bowbeer)
Date: Wed, 18 Jun 2003 03:36:20 -0700
Subject: [concurrency-interest] LinkedQueue extensions
References: <CJEBLDCHAADCLAGIGCOOCEGDCKAA.michael.mattox@verideon.com>
Message-ID: <010201c33585$7721c450$bf9a7cce@REPLICANT2>

I'm not familiar with the Queue code in dl.util.concurrent, but I want to
point out that the proposed java.util.concurrent.LinkedQueue is a Collection
and therefore does provide contains, size, and toArray methods.


----- Original Message ----- 
From: "Michael Mattox" <michael.mattox@verideon.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Wednesday, June 18, 2003 12:45 AM
Subject: [concurrency-interest] LinkedQueue extensions



I need some extra functionality on the LinkedQueue method.  I extended the
class and I'd like to know if my new methods are OK.  I have very little
experience coding multithreaded code so I'd like to double check my code.
The methods I need are: contains, size, and getContents.  My app has been
hanging near the spot where I call the contains method and I wonder if there
could be a deadlock or something.

If these changes are OK, should I contribute them as a patch?

Thanks,
Michael

--

package com.verideon.veriguard.util;

import java.util.*;

import EDU.oswego.cs.dl.util.concurrent.*;

public class LinkedQueueWithContains extends
EDU.oswego.cs.dl.util.concurrent.LinkedQueue {

public LinkedQueueWithContains() {
super();
}

public boolean contains(Object o) {
synchronized (head_) {
if (head_ != null) {
LinkedNode current = head_.next;
while (current != null) {
if (current.value.equals(o)) {
return true;
} else {
current = current.next;
}
}
}
return false;
}
}

public List getContents() {
List contents = new LinkedList();

synchronized (head_) {
if (head_ != null) {
LinkedNode current = head_.next;
while (current != null) {
contents.add(current.value);
current = current.next;
}
}
}
return contents;
}

public int getSize() {
int size = 0;
synchronized (head_) {
if (head_ != null) {
LinkedNode current = head_.next;
while (current != null) {
size++;
current = current.next;
}
}
}
return size;
}
}


From dl@cs.oswego.edu  Wed Jun 18 11:55:00 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 18 Jun 2003 06:55:00 -0400
Subject: [concurrency-interest] Observability of Semaphore
In-Reply-To: <E2CE79A85B62AB4AB7DDE8E00578967F6E5C@dc02.instagrade.com>
References: <E2CE79A85B62AB4AB7DDE8E00578967F6E5C@dc02.instagrade.com>
Message-ID: <16112.17668.695327.669546@altair.cs.oswego.edu>

> Basically, I am implementing a conditional tree where nodes in the
> tree have true/false values, and I need to support nodes whose value
> is derived from whether a lock style object has been acquired or not

The JSR-166 ReentrantLock class, which we are strongly encouraging
people use for most "fancy" locking, contains an isLocked() method
that tells you if any thread holds the lock.  It provides only a
momentary snapshot. In general you do not know if the lock is about to
be released. So you have to be very careful when using it.  In most
cases, you are better off insted using a tryLock -- getting the lock
only if not already held, which tells you the same thing and enters
the lock if free so you can safely access at any fields the lock is
protecting and prevents others from getting lock until you release.

-Doug


From dl@cs.oswego.edu  Fri Jun 20 13:58:02 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 20 Jun 2003 08:58:02 -0400
Subject: [concurrency-interest] We need your help testing
Message-ID: <16115.1242.610150.399595@altair.cs.oswego.edu>

One of the next major tasks for JSR-166 is to provide a test suite for
API compliance (a TCK). To keep on JDK1.5 schedule, an initial version
of test suite is due by the end of July (i.e. SOON!).  Given the usual
problems in adequately testing concurrent code, we'd like to provide
something much better than the required minimal compliance tests, and
to include as diverse a set of tests as possible. The best way to get
diversity is to ask people using this code to help contribute. If you
have used dl.util.concurrent and/or anticipate using
java.util.concurrent, now is the best time to help ensure that you and
others can continue doing so in JDK1.5.

Among the easiest and best ways to help would be to take an existing
usage/application of these classes, and reduce it to something with a
yes/no result (or terminates-soon vs never-terminates).  If the tests
use dl.util.concurrent, we can convert to use new JSR-166 versions.
If you are using junit (http://junit.org), that would be great,
otherwise we can junit-ize or otherwise accommodate.

We'd like more tests of all kinds, from the simple to the esoteric.
These include:

* "Normative" tests. The include checks for whether documented
argument screening actually occurs and the expected exceptions are
thrown. For example, whether trying to make an ArrayBlockingQueue with
negative capacity fails in the specified way.

* Postcondition tests. Unit tests usually amounting to checks that
expected observable state changes in objects occur. For a simple
example does Cancellable.cancel cause isCancelled to be true.

* Liveness tests. Tests for common concurrency errors causing threads
to hang due to livelock, lockout, deadlock, missed signals, etc.  For
a simple example, a test in which many threads each lock and unlock a
number of ReentrantLocks exactly once should terminate.

* Race tests. Tests for insufficient synchronization, sometimes causing
bad field values to be accessed. For example, a test in which
a pair of values must always bear some known relationship, tested
with many threads continually reading and writing them.

* Performance anomaly tests. Tests that documented usage guidance
holds. For example, is LinkedBlockingQueue indeed on average
faster but with higher variance than ArrayBlockingQueue.

* Cancellation tests. Stopping actions (via "cancel" methods,
timeouts, interrupts, exceptions, JVM shutdown etc) cleanly and
correctly is among the hardest things to get right in concurrent
programming, and tends to hit the trickiest code. It is also difficult
to test for.  Any contrbutions aong these lines are especially
welcome.

* Feature interaction tests. For example, do the tuning methods in
ThreadPoolExecutor combine correctly? "Correctly" here is not always
spelled out well. One purpose of such tests is to help clarify API
specs about these issues.  (Aside: There were a few such feature
interaction problems in dl.u.c.PooledExecutor, for example, that
resetting keepAlive times could delay shutdown. I think these are
cleared up in j.u.c version.)

* Unexpected usage tests. Functionality or performance problems when
classes are used in unanticipated ways or applications. At this point,
lots of usages are unanticipated, so almost anything fits this
category.

* Stress tests.  Tests that check for performance degradation and
instability over long periods.

* Platform tests. Ensuring that documented properties hold
across uniprocessors and multiprocessors of various kinds.

* Least-astonishment tests. Intrinsically subjective tests that a
class/method does what it says it should do, but this isn't what you
think it should do. Plus related human-factors tests revealing awkward
or error-prone constructions that could be fixed with API changes.

* Code reviews. Walkthroughs of code looking for concurrency problems.
(See also a follow-up posting on this coming soon.)

* Code analysis. Analytic tools looking for concurrency problems.
(Note: This is even harder to do for JSR-166 code than it might be
otherwise because of the extensive use of from-the-ground-up
synch primitives, that are not amenable to checks based on the
use of "synchronized" methods. The goal of exposing ReentrantLock,
Atomics, etc., to as much internal reuse (hence internal testing) as
possible overrides ease-of-analysis concerns.)

We will of course make all appropriate tests freely avalaible as part
of the JSR-166 TCK. (If you have problems revealing code, and cannot
allow it to appear, we can probably work out something.) We'd be
very pleased to somehow give you credit for any contributions.

You can just send them directly to me <dl@cs.oswego.edu>. 
We'll figure out how to coordinate as needs arises.

Thanks very much for any help you can provide!

-- 
Doug Lea, Computer Science Department, SUNY Oswego, Oswego, NY 13126 USA
dl@cs.oswego.edu 315-312-2688 FAX:315-312-5424 http://gee.cs.oswego.edu/  

From michael.mattox@verideon.com  Fri Jun 20 17:43:18 2003
From: michael.mattox@verideon.com (Michael Mattox)
Date: Fri, 20 Jun 2003 18:43:18 +0200
Subject: [concurrency-interest] Design feedback on application using PooledExecutor to run threads that download webpages
Message-ID: <CJEBLDCHAADCLAGIGCOOMEIDCKAA.michael.mattox@verideon.com>

I'm hoping to get some feedback on my design to make sure I'm doing things
in the most optimal way.  I'm having some performance problems and I'm not
sure if I've just reached the limit of my server (I doubt it) or if my code
is not as efficient as it could be.  My application is simple, basically it
just connects to websites and downloads the contents, and stores the status
in the database (HTTP Status code for example).  I'm using the
PooledExecutor class for my thread pool, and the LinkedQueue as my queue.
For my stress testing I have 900 websites that are monitored, 500 of them
every 10 minutes and 400 every 5 minutes.  The code that downloads the
website (using Apache's HttpClient) blocks on the part that downloads the
code.  For this reason I'd like to have more threads running than
processors, that that when a thread blocks while waiting on the remote
server another thread can be run.  JProfiler reports that approximately 65%
of the CPU time is spent in the method that downloads the page.

I've deployed this to a 4 CPU Linux server.  I've been playing around with
the maximum number of threads to use.  So far I've been using 32.  That
means each CPU should be downloading 8 webpages at the same time, which is
reasonable for a server with plenty of bandwidth (burstable up to 100 megs
they tell me).  I've tried putting the threads up to 60 but the time it
takes to execute each one goes up unsuprisingly.  Is this just a matter of
trial and error to determine the optimum settings?  I'm having performance
problems where the websites are not monitored at the 5 minutes that I expect
(between 5-10 most of the time) and I'm trying to figure out how I can
optimize this even further.  When I run 'top' on the server it shows the CPU
utilization at 7% on average and I can't figure out why the CPUs aren't
being used 100%.  I guess it means they can't because the threads are
blocking, in which case, assuming I'm not maxing out the bandwidth, I'd
expect increasing the threads to 60 to use more of the CPU but it doesn't.

I hope all this makes sense, I'd be grateful for any input on this.

Thanks,
Michael



From Guy_Katz@icomverse.com  Mon Jun 23 13:10:38 2003
From: Guy_Katz@icomverse.com (Katz Guy)
Date: Mon, 23 Jun 2003 15:10:38 +0300
Subject: [concurrency-interest] Any preliminary spec for 166?
Message-ID: <385D702A9C11D511A9E90008C7160AD5045D230E@ISMAIL1>

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C33980.3EED2292
Content-Type: text/plain;
	charset="windows-1255"

Hi;
Is there a preliminary specification for this JSR 166 that I can read?
Any other material on JSR 166?
thanks
_______________________
Guy Katz
Software Architect, CAP-IFS
Comverse
guy.katz@comverse.com
+972 3 7663686


------_=_NextPart_001_01C33980.3EED2292
Content-Type: text/html;
	charset="windows-1255"

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1255">
<META NAME="Generator" CONTENT="MS Exchange Server version 5.5.2655.35">
<TITLE>Any preliminary spec for 166?</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=2 FACE="Arial">Hi;</FONT>
<BR><FONT SIZE=2 FACE="Arial">Is there a preliminary specification for this JSR 166 that I can read?</FONT>
<BR><FONT SIZE=2 FACE="Arial">Any other material on JSR 166?</FONT>
<BR><FONT SIZE=2 FACE="Arial">thanks</FONT>
<BR><B><FONT SIZE=2 FACE="Arial">_______________________</FONT></B>
<BR><B><FONT SIZE=2 FACE="Arial">Guy Katz</FONT></B>
<BR><B><FONT SIZE=2 FACE="Arial">Software Architect, CAP-IFS</FONT></B>
<BR><B><FONT SIZE=2 FACE="Arial">Comverse</FONT></B>
<BR><B><FONT SIZE=2 FACE="Arial">guy.katz@comverse.com</FONT></B>
<BR><B><FONT SIZE=2 FACE="Arial">+972 3 7663686</FONT></B>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C33980.3EED2292--

From dl@cs.oswego.edu  Wed Jun 25 13:43:22 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 25 Jun 2003 08:43:22 -0400
Subject: [concurrency-interest] "Lock" API and built-in locks
Message-ID: <16121.39146.345469.55541@altair.cs.oswego.edu>

Dear concurrency-interest list members,

As we head toward stabilizing specs and implementations, we (the
JSR-166 expert group) would like your opinions on another API issue.

JSR-166 provides a highly flexible framework for "fancy" locks --
supporting trylock, interruptibility, timeouts, multiple conditions
per lock, etc., using the Lock and Condition interfaces along with
concrete ReentrantLock and FairReentrantLock implementations. Plus
support for rolling your own special-purpose versions.

JSR-166 also currently includes support for a subset of these new
features on built-in monitors via the "Locks" class. The intent was to
provide relief for some of the most frequently complained about
problems with built-in monitors that could be accommodated without
changing the fundamental properties of "synchronized", wait, notify,
notifyAll: This basically amounts to Locks.attempt -- a way of
obtaining trylocks (passing in Runnables), and provision of a
Condition implementation that allows multiple Conditions per built-in
lock.

The question at hand is whether this subset is worth providing.
Here are some of the considerations making me think that it is NOT.

1. Adding ANY kind of extensions for built-in locks adds to
   their apparent complexity for novice and casual users.

2. j.u.c provides the approx ten most common kinds classes that people
   historically used clever locking and monitors for.  So, we hope,
   fewer and fewer application-level programmers will be using monitor
   methods anyway. Why bother making them only a little bit nicer to
   use now?

3. Conversely, any (systems/library level) developer creating a class
   that supports JSR-166's standard set of wait/try/timeout control
   policies for possibly-blocking methods (that are used consistently
   in all of our APIs) will almsot surely need to use a "fancy"
   version of a Lock (almost always ReentrantLock) to implement it
   anyway, so will not use extensions of built-ins.

4. Locks.attempt is a very heavy sledgehammer for obtaining trylock on
   builtins. It is suitable only for emergency maneuvers to wriggle out
   of tight corners that would be better avoided using Lock objects in
   the first place.

5. If we dropped support for built-in lock extensions, then it would make
   more sense to create a subpackage java.util.concurrent.locks (containing
   Lock, Condition, ReadWriteLock) that would better convey that these
   classes are at a lower level and designed for more advanced usage than
   the "everyday usage" APIs like Executor and BlockingQueue. (This is
   the reasoning behind the similar segregation of atomics.)

Does anyone have a compelling argument for keeping built-in lock
extensions?

Thanks very much for the help!!

-Doug

PS JSR-166 preliminary release #2, containing a bunch of clean-ups and
   bug-fixes, plus an emulation mode allowing (slow) use of most
   features on unadulterated JVMs, will be out within a day or
   so. I'll send out mail announcing.

From Curt at Tripos <ccox@tripos.com>  Wed Jun 25 15:43:18 2003
From: Curt at Tripos <ccox@tripos.com> (Curt at Tripos)
Date: Wed, 25 Jun 03 09:43:18 -0500
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <16121.39146.345469.55541@altair.cs.oswego.edu>
Message-ID: <200306251444.h5PEiUtB021469@altair.cs.oswego.edu>

Hi All,

The java.util.* collections have some concurrency support.
The collection implementations are unsynchronized.
Synchronization and protection against modification can
be added via several provided wrapper methods located in
java.util.Collections.

Collection synchronizedCollection(Collection c)
List       synchronizedList(List list)
Map        synchronizedMap(Map m)
Set        synchronizedSet(Set s)
SortedMap  synchronizedSortedMap(SortedMap m)
SortedSet  synchronizedSortedSet(SortedSet s)
Collection unmodifiableCollection(Collection c)
List       unmodifiableList(List list)
Map        unmodifiableMap(Map m)
Set        unmodifiableSet(Set s)
SortedMap  unmodifiableSortedMap(SortedMap m)
SortedSet  unmodifiableSortedSet(SortedSet s)

This pattern 
(interface + unsynchronized implementations + concurrency wrappers)
seems to work pretty well.  It allows testing different solutions
to concurrency problems by simply changing wrappers.

Given all of the new concurrency options about to be introduced,
I would welcome a factory class that generated an assortment of
concurrency wrappers.  I propose adding a wrapper class with at
least the following methods.   The goal is to make the most common
usage as simple as possible.

/**
Returns a synchronized (thread-safe) object backed
by the specified object.  The object returned implements the
same interfaces as the given object.
*/
public static Object synchronizedObject(Object object);

/**
Returns an object that is locked with the given lock and backed
by the specified object.  The object returned implements the
same interfaces as the given object.
*/
public static Object lockedObject(Lock lock, Object object);

Thanks,
Curt

 



From daniel_yokomiso@yahoo.com.br  Wed Jun 25 17:11:13 2003
From: daniel_yokomiso@yahoo.com.br (Daniel Yokomiso)
Date: Wed, 25 Jun 2003 13:11:13 -0300
Subject: [concurrency-interest] Concurrency Wrappers
References: <200306251444.h5PEiUtB021469@altair.cs.oswego.edu>
Message-ID: <00dc01c33b34$ebf0c970$fce39bc8@eonl9byru76yj2>

----- Original Message -----
From: "Curt at Tripos" <ccox@tripos.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Wednesday, June 25, 2003 11:43 AM
Subject: [concurrency-interest] Concurrency Wrappers


> Hi All,
>
> The java.util.* collections have some concurrency support.
> The collection implementations are unsynchronized.
> Synchronization and protection against modification can
> be added via several provided wrapper methods located in
> java.util.Collections.
>
> Collection synchronizedCollection(Collection c)
> List       synchronizedList(List list)
> Map        synchronizedMap(Map m)
> Set        synchronizedSet(Set s)
> SortedMap  synchronizedSortedMap(SortedMap m)
> SortedSet  synchronizedSortedSet(SortedSet s)
> Collection unmodifiableCollection(Collection c)
> List       unmodifiableList(List list)
> Map        unmodifiableMap(Map m)
> Set        unmodifiableSet(Set s)
> SortedMap  unmodifiableSortedMap(SortedMap m)
> SortedSet  unmodifiableSortedSet(SortedSet s)
>
> This pattern
> (interface + unsynchronized implementations + concurrency wrappers)
> seems to work pretty well.  It allows testing different solutions
> to concurrency problems by simply changing wrappers.
>
> Given all of the new concurrency options about to be introduced,
> I would welcome a factory class that generated an assortment of
> concurrency wrappers.  I propose adding a wrapper class with at
> least the following methods.   The goal is to make the most common
> usage as simple as possible.
>
> /**
> Returns a synchronized (thread-safe) object backed
> by the specified object.  The object returned implements the
> same interfaces as the given object.
> */
> public static Object synchronizedObject(Object object);
>
> /**
> Returns an object that is locked with the given lock and backed
> by the specified object.  The object returned implements the
> same interfaces as the given object.
> */
> public static Object lockedObject(Lock lock, Object object);
>
> Thanks,
> Curt

Hi,

    As it is very easy to do something similar using dynamic proxies (i.e.
regarding a known set of interfaces), I don't think it should be part of
this library. Otherwise it's very difficult to know how to implement such
methods using plain Java, because if you don't know the exact interfaces,
you can't easily (i.e. without heavy reflection usage + byte-code
generation) define the appropriate proxies. In the collections case the
interfaces are known at compile-time, so it isn't a problem.
    I'm also posting a pure Java solution to this, using dynamic proxies.

    Best regards,
    Daniel Yokomiso.

"Common sense is that layer of prejudices which we acquire before we are
sixteen."
 - Albert Einstein



/*
Originally written by Daniel Yokomiso and released into the public domain.
This may be used for any purposes whatsoever without acknowledgment.
*/

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.concurrent.Lock;

public class SynchronizationHelper {
    private SynchronizationHelper() {
    }
    public static Object synchronizedObject(Class[] interfaceClasses, Object
wrapped) {
        return create(interfaceClasses, new SynchronizingProxy(wrapped));
    }

    public static Object synchronizedObject(Class interfaceClass, Object
wrapped) {
        return create(interfaceClass, new SynchronizingProxy(wrapped));
    }
    public static Object lockedObject(Class[] interfaceClasses, Lock lock,
Object wrapped) {
        return create(interfaceClasses, new LockingProxy(lock, wrapped));
    }
    public static Object lockedObject(Class interfaceClass, Lock lock,
Object wrapped) {
        return create(interfaceClass, new LockingProxy(lock, wrapped));
    }
    private static Object create(Class interfaceClass, InvocationHandler
handler) {
        return create(new Class[] { interfaceClass }, handler);
    }
    private static Object create(Class[] interfaceClasses, InvocationHandler
handler) {
        return Proxy.newProxyInstance(
            interfaceClasses[0].getClassLoader(),
            interfaceClasses,
            handler);
    }
}
public class SynchronizingProxy implements InvocationHandler {
    private final Object wrapped;
    public SynchronizingProxy(Object wrapped) {
        this.wrapped = wrapped;
    }
    public synchronized Object invoke(Object proxy, Method method, Object[]
args)
        throws Throwable {
        return method.invoke(wrapped, args);
    }
}

public class LockingProxy implements InvocationHandler {
    private final Lock lock;
    private final Object wrapped;
    public LockingProxy(Lock lock, Object wrapped) {
        this.lock = lock;
        this.wrapped = wrapped;
    }
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
        lock.lock();
        try {
            return method.invoke(wrapped, args);
        } finally {
            lock.unlock();
        }
    }
}


---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.491 / Virus Database: 290 - Release Date: 18/6/2003


From leou@us.ibm.com  Wed Jun 25 18:39:35 2003
From: leou@us.ibm.com (Leo Uzcategui)
Date: Wed, 25 Jun 2003 11:39:35 -0600
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OF97681ACC.CC919CF5-ON87256D50.0061025D-87256D50.0061025D@us.ibm.com>




I will be out of the office starting June 23, 2003 and will not return
until June 30, 2003.

For assistance, please contact Robin Redden at (512) 838-1542.


From Curt at Tripos <ccox@tripos.com>  Wed Jun 25 18:45:48 2003
From: Curt at Tripos <ccox@tripos.com> (Curt at Tripos)
Date: Wed, 25 Jun 03 12:45:48 -0500
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <00dc01c33b34$ebf0c970$fce39bc8@eonl9byru76yj2>
Message-ID: <200306251746.h5PHkvtB005370@altair.cs.oswego.edu>

Daniel,
 
>     As it is very easy to do something similar
> using dynamic proxies (i.e.
> regarding a known set of interfaces), I don't
> think it should be part of
> this library.

I assert that "easy to implement" isn't a
strong enough argument to keep functionality out of
a utility.  java.lang.ThreadLocal is one example.

If it is generally useful, then there is
no sense in a large percentage of users writing their
own implementations, or finding someone elses.
In my experience, these would be generally useful.

Also, I didn't mean to limit the wrappers to just
those two.  They should be included, however, since
they are the simplest and most generically useful.
I would also argue for the inclusion of methods to
construct wrappers that apply different concurrency
mechanisms to different methods.

> Otherwise it's very difficult to
> know how to implement such
> methods using plain Java, because if you don't
> know the exact interfaces,
> you can't easily (i.e. without heavy reflection
> usage + byte-code
> generation) define the appropriate proxies. In
> the collections case the
> interfaces are known at compile-time, so it isn't
> a problem.

If factory methods for wrappers are put in place now,
any users will get a speed bump (without changing a single 
line of code), if and when the
reflection + byte-code-generation route is implemented.
Witness the evolution of ThreadLocal's implementation.

Thanks,
Curt


From Jacob.Solotaroff@evant.com  Wed Jun 25 19:19:53 2003
From: Jacob.Solotaroff@evant.com (Jacob Solotaroff)
Date: Wed, 25 Jun 2003 11:19:53 -0700
Subject: [concurrency-interest] Hanging Night Job with 100% CPU Usage
Message-ID: <C1B59B760D2C534B9A94AD93A6F0E25A62341C@sfoexc01.nonstop.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C33B46.5F953285
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

Hi,
We've had a problem for the last couple of months.  Our product involves
a batch job that is run every night.  At one of our client sites
(running Java 1.3.1 on AIX) the batch job hangs every 7-10 days.  We
have been unable to reproduce the problem either in house or on their
same box with the exact same data.  The difficulty in reproducing it
would suggest a threading problem.  We use the Oswego concurrency
libraries quite a bit.  However, when it hangs, the CPU usage goes to
100%.  We've checked and this is not due to paging.  Generally a
threading-related hang is due to deadlock and has 0% CPU usage.  Has
anyone seen a hang like this?  One that you can't reproduce but has 100%
CPU usage?

We've tried doing various kill -QUIT and kill -11 commands on it, but
the ascii javacore file gives us "Exception 2" instead of the stack
trace and the binary core file does not show up.  This could be due to
permission problems since the job is run through SUDO (we're looking
into this).

Thanks,
Jacob
Disclaimer:

This e-mail message, including any attachments,is for the sole use of =
the intended recipient(s) and may contain confidential and privileged =
information. Any unauthorized review, use, disclosure or distribution is =
prohibited. If you are not the intended recipient, please contact the =
sender by reply e-mail as well as admin@evant.com, and destroy all =
copies of the original message.
------_=_NextPart_001_01C33B46.5F953285
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.0.6249.1">
<TITLE>Hanging Night Job with 100% CPU Usage</TITLE>
</HEAD>
<BODY><FONT COLOR=3DBLACK>
<!-- Converted from text/rtf format -->

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Hi,</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">We</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">ve had a problem for the last couple of =
months.&nbsp;</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"> <FONT SIZE=3D2 FACE=3D"Arial">Our product involves a =
batch job that is run every night.&nbsp;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">At one of our client sites (running Java 1.3.1 on =
AIX)</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT =
SIZE=3D2 FACE=3D"Arial"> the batch job hangs every 7-10 days.&nbsp; We =
have been unable to reproduce the problem either in house or on their =
same box</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> =
<FONT SIZE=3D2 FACE=3D"Arial">with th</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">e exact same data.&nbsp;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">The difficulty in reproducing it would suggest a =
threading problem.&nbsp; We use the Oswego concurrency libraries quite a =
bit.&nbsp; However, when it han</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">gs, the CPU usage goes to 100%.&nbsp;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">We</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">ve check</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">ed</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial"> and t</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">his is not due to =
paging.&nbsp; Generally a threading-related hang</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial"> is due to deadlock and has 0% CPU usage.&nbsp; Has =
anyone seen a hang like this?&nbsp;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">One that you can</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">t reproduce but has 100% =
CPU usage?</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">We</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">ve tried doing various kill</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">&#8211;</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">QUIT and kill -11 commands =
on it, but the ascii javacore file gives us</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">&#8220;</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">Exception =
2</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT =
SIZE=3D2 FACE=3D"Arial">&#8221;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial"> instead of the stack trace and the binary core file does =
not show up.&nbsp; This could be</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT SIZE=3D2 =
FACE=3D"Arial">due to permission problems since the job is run through =
SUDO (we</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">re looking into this).</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Thanks,</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Jacob</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"></SPAN></P>

<br><font FACE=3D"Courier" SIZE=3D"2" >Disclaimer:<br> <br> This e-mail =
message, including any attachments,is for the sole use of the intended =
recipient(s) and may contain confidential and privileged information. =
Any unauthorized review, use, disclosure or distribution is prohibited. =
If you are not the intended recipient, please contact the sender by =
reply e-mail as well as <a =
href=3D"mailto:admin@evant.com">admin@evant.com</a>, and destroy all =
copies of the original message.
<br>
</font>
</BODY>
</HTML>
------_=_NextPart_001_01C33B46.5F953285--


From dawidk@mathcs.emory.edu  Wed Jun 25 19:22:42 2003
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 25 Jun 2003 14:22:42 -0400
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <200306251746.h5PHkvtB005370@altair.cs.oswego.edu>
References: <200306251746.h5PHkvtB005370@altair.cs.oswego.edu>
Message-ID: <200306251422.43155.dawidk@mathcs.emory.edu>

> I assert that "easy to implement" isn't a
> strong enough argument to keep functionality out of
> a utility.  java.lang.ThreadLocal is one example.
>
> If it is generally useful, then there is
> no sense in a large percentage of users writing their
> own implementations, or finding someone elses.
> In my experience, these would be generally useful.

Curt, 

I agree that such wrappers would be useful in simple cases, but I think they 
could as well be dangerous in more complex ones. Too much synchronization 
(e.g. blindly making all methods synchronized like in this case) can easily 
lead to liveness problems, not to mention performance degradation. See the 
Doug Lea's book for in-depth discussion of the matter. Presence of such 
wrappers in the library would create false impression that the proper way 
from thread-unsafe to thread-safe is by making all methods synchronized. This 
is the practice that many inexperienced programmers already are falling for, 
and I fell it should be discouraged rather than further encouraged.

>
> Also, I didn't mean to limit the wrappers to just
> those two.  They should be included, however, since
> they are the simplest and most generically useful.
> I would also argue for the inclusion of methods to
> construct wrappers that apply different concurrency
> mechanisms to different methods.

I think that concurrency control is so application-specific that it is simply 
impossible to embrace all (or even most) cases inside a single library. And 
even if it was, there would be many classes with a lot of configuration 
options, and I think that they would not save people much work as compared to 
the alternative of implementing their custom wrappers.

>
> > Otherwise it's very difficult to
> > know how to implement such
> > methods using plain Java, because if you don't
> > know the exact interfaces,
> > you can't easily (i.e. without heavy reflection
> > usage + byte-code
> > generation) define the appropriate proxies. In
> > the collections case the
> > interfaces are known at compile-time, so it isn't
> > a problem.
>
> If factory methods for wrappers are put in place now,
> any users will get a speed bump (without changing a single
> line of code), if and when the
> reflection + byte-code-generation route is implemented.
> Witness the evolution of ThreadLocal's implementation.

Considering the fact that the appropriate wrappers are very easy to write (and 
that it can be automated by a simple script if that's what you need), you are 
essentially requesting very heavy-weight mechanisms  (which would bloat the 
class libraries and require a lot of time to implement by people who could 
otherwise work on something more useful) to provide rather minor 
simplification for end-users. For that reasons, I would personally opt 
against it.

Regards,
Dawid


From daniel_yokomiso@yahoo.com.br  Wed Jun 25 19:44:40 2003
From: daniel_yokomiso@yahoo.com.br (Daniel Yokomiso)
Date: Wed, 25 Jun 2003 15:44:40 -0300
Subject: [concurrency-interest] Concurrency Wrappers
Message-ID: <016401c33b4a$ac0a9820$fce39bc8@eonl9byru76yj2>

----- Original Message -----
From: "Curt at Tripos" <ccox@tripos.com>
To: "Curt at Tripos" <ccox@tripos.com>;
<concurrency-interest@altair.cs.oswego.edu>; "Daniel Yokomiso"
<daniel_yokomiso@yahoo.com.br>
Sent: Wednesday, June 25, 2003 2:45 PM
Subject: Re: [concurrency-interest] Concurrency Wrappers


> Daniel,
>
> >     As it is very easy to do something similar
> > using dynamic proxies (i.e.
> > regarding a known set of interfaces), I don't
> > think it should be part of
> > this library.
>
> I assert that "easy to implement" isn't a
> strong enough argument to keep functionality out of
> a utility.  java.lang.ThreadLocal is one example.
>
> If it is generally useful, then there is
> no sense in a large percentage of users writing their
> own implementations, or finding someone elses.
> In my experience, these would be generally useful.
>
> Also, I didn't mean to limit the wrappers to just
> those two.  They should be included, however, since
> they are the simplest and most generically useful.
> I would also argue for the inclusion of methods to
> construct wrappers that apply different concurrency
> mechanisms to different methods.
>
> > Otherwise it's very difficult to
> > know how to implement such
> > methods using plain Java, because if you don't
> > know the exact interfaces,
> > you can't easily (i.e. without heavy reflection
> > usage + byte-code
> > generation) define the appropriate proxies. In
> > the collections case the
> > interfaces are known at compile-time, so it isn't
> > a problem.
>
> If factory methods for wrappers are put in place now,
> any users will get a speed bump (without changing a single
> line of code), if and when the
> reflection + byte-code-generation route is implemented.
> Witness the evolution of ThreadLocal's implementation.
>
> Thanks,
> Curt

Hi,

    There are some easy to implement features that won't be part of this
JSR. If you read the past threads you'll see the reasoning for this. I think
this feature is a quick hack, incoherent with the thoughtful design of the
rest of the API. Most classes in real world projects can't be made
concurrent through simplistic whole object synchronization strategies,
because synchronization is related to sets of methods, not them all. You
could create several interfaces, each representing a set of synchronizable
methods, and create combinations of proxy handlers to deal with different
synchronization strategies (e.g. in a BoundedBuffer create a general
Reader-Writer lock to deal with commands/queries, but use a wait/notify lock
to deal with empty/full signals), but this is requires quite a bunch lines
of code, not "without changing a single line of code". Sometimes we need
some quick hacks to debug a system or put out a prototype, but concurrency
is a complex issue that can't be dealt with some kind of patching.
    IMHO these kind of helper methods can lead to lot's of difficult to
track deadlock bugs. It would be very difficult to find a class with only
methods of mutually-exclusive access. There's always some method that could
be accessed by more than one thread at a time without harm, but when you
make it an all or nothing synchronization strategy you'll harm everyone who
makes this simples assumption.

    Best regards,
    Daniel Yokomiso.



---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.491 / Virus Database: 290 - Release Date: 18/6/2003


From Curt at Tripos <ccox@tripos.com>  Wed Jun 25 21:48:29 2003
From: Curt at Tripos <ccox@tripos.com> (Curt at Tripos)
Date: Wed, 25 Jun 03 15:48:29 -0500
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <200306251422.43155.dawidk@mathcs.emory.edu>
Message-ID: <200306252049.h5PKngtB011100@altair.cs.oswego.edu>

Dawid,

> I agree that such wrappers would be useful in
> simple cases, but I think they
> could as well be dangerous in more complex ones.
> Too much synchronization
> (e.g. blindly making all methods synchronized
> like in this case) can easily
> lead to liveness problems, not to mention
> performance degradation.

Obviously too much synchronization can be bad.
I don't eat and sleep concurrency, so my experiences
may be quite different than those of the average
reader of this list.

Most applications that I have worked on however,
have little if any concurrency design beyond that
implicitly dictated by working with Swing.
Concurrency issues usually manifest themselves as
bugs.  They are usually dealt with by changing either the
synchronization of the classes involved, or with
wrappers.  When that is inadequate, then other
measures can be sought.

>  you are essentially requesting very heavy-weight
> mechanisms 
I'm actually requesting an API.  The mechanism is up
to the implementors.

Thanks,
Curt


From Curt at Tripos <ccox@tripos.com>  Wed Jun 25 21:51:33 2003
From: Curt at Tripos <ccox@tripos.com> (Curt at Tripos)
Date: Wed, 25 Jun 03 15:51:33 -0500
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <016401c33b4a$ac0a9820$fce39bc8@eonl9byru76yj2>
Message-ID: <200306252052.h5PKqgtB011130@altair.cs.oswego.edu>

Daniel,

> I think this feature is a quick hack, incoherent with the
> thoughtful design of the rest of the API.
I prefer the term orthogonal.

> Most classes in real world
> projects can't be made
> concurrent through simplistic whole object
> synchronization strategies,
> because synchronization is related to sets of
> methods, not them all.
In my experience, many concurrency issues can be
handled through whole object synchronization strategies.
The existing wrappers in java.util.Collections go a long
way towards solving concurrency problems when you use
collections heavily.  When they are inadequate, other
measures need to be taken.

> Sometimes we need
> some quick hacks to debug a system or put out a
> prototype, but concurrency
> is a complex issue that can't be dealt with some
> kind of patching.
I guess that depends on what kind of program you
are writing.  Perhaps most Java programs should be
designed around concurrency.  My guess is that most
programmer deal with concurrency only after it
causes problems.

Just for a point of reference, my background as
a Java applications programmer is in writing stand-alone
desktop Swing apps and database driven JSP/Servlet apps.
I freely admit to being outclassed by the gurus on this
list, but that probably makes me a more typical user.

> IMHO these kind of helper methods can lead to
> lot's of difficult to track deadlock bugs.
Lots of testing helps discover deadlocks.
I've found the thread dump a relatively easy way
of pinpointing deadlocks.
http://java.sun.com/j2se/1.4.1/sample-output.html

Thanks,
Curt


From dl@cs.oswego.edu  Thu Jun 26 00:06:41 2003
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 25 Jun 2003 19:06:41 -0400
Subject: [concurrency-interest] Concurrency Wrappers
In-Reply-To: <200306252052.h5PKqgtB011130@altair.cs.oswego.edu>
References: <016401c33b4a$ac0a9820$fce39bc8@eonl9byru76yj2>
 <200306252052.h5PKqgtB011130@altair.cs.oswego.edu>
Message-ID: <16122.11009.331344.257552@altair.cs.oswego.edu>

Curt, thanks very much for your posts! Despite negative reactions to
your suggestions, they will lead to a couple of changes in JSR-166.

A naming issue that we hadn't dealt with well is to consistently
distinguish "concurrent" classes from "synchronized" ones. it took
a self-proclaimed non-expert to make us realize the problem here.

For example, Collections.synchronizedMap(new HashMap()) and Hashtable
are "synchronized" but the new j.u.c.ConcurrentHashMap is
"concurrent". A concurrent collection (among other kinds of classes)
is thread-safe, but not governed by a single exclusion lock. So, in
the particular case of ConcurrentHashMap, it safely permits any number
of concurrent reads as well as a tunable number of concurrent writes.
The main payoff is scalability -- performance remains good even when
the tables are read/written by many dozens of threads.  (Which is
absolutely not the case for Hashtable and synchronized-wrapped
HashMaps.) Also, while you can usually make a synchronized collection
from an unsynchronized one using a wrapper, concurrent collections
normally use completely different algorithms, so you need separate
classes.

Your posting brought to light that we haven't been very helpful in
communicating this distinction. But we will do some renamings (plus
documentation) to make it easier to figure out which collections are
designed for scalable concurrency by uniformly prefixing them with
"Concurrent". For example, LinkedQueue will become
ConcurrentLinkedQueue. (The BlockingQueues don't need such prefixing
since blocking implies multithreaded usage.)

(To anticipate follow-ups: Yes, we ARE considering introducing
ConcurrentArrayList and ConcurrentTreeMap classes, but under the
category of "stuff to consider after getting everything else in
JSR-166 ready for JDK1.5.)

-Doug

From daniel_yokomiso@yahoo.com.br  Thu Jun 26 00:27:35 2003
From: daniel_yokomiso@yahoo.com.br (Daniel Yokomiso)
Date: Wed, 25 Jun 2003 20:27:35 -0300
Subject: [concurrency-interest] Concurrency Wrappers
Message-ID: <008301c33b72$0d0be620$6be29bc8@eonl9byru76yj2>

Hi,

    Comments embedded.

----- Original Message -----
From: "Curt at Tripos" <ccox@tripos.com>
To: "Curt at Tripos" <ccox@tripos.com>;
<concurrency-interest@altair.cs.oswego.edu>; "Daniel Yokomiso"
<daniel_yokomiso@yahoo.com.br>
Sent: Wednesday, June 25, 2003 5:51 PM
Subject: Re: [concurrency-interest] Concurrency Wrappers


> Daniel,
>
> > I think this feature is a quick hack, incoherent with the
> > thoughtful design of the rest of the API.
> I prefer the term orthogonal.


    Orthogonality is a property of two unrelated traits of a system. Using a
example from this API would be executor and locks, each is independent from
the other, but they can be combined in a single system. When I said
incoherent I was was comparing "a quick hack" vs. "thoughtful design", both
are qualifiers for the same trait: design. Beauty isn't orthogonal to
uglyness, and adding a scar to a otherwise beautiful painting is incoherent.


> > Most classes in real world
> > projects can't be made
> > concurrent through simplistic whole object
> > synchronization strategies,
> > because synchronization is related to sets of
> > methods, not them all.
> In my experience, many concurrency issues can be
> handled through whole object synchronization strategies.
> The existing wrappers in java.util.Collections go a long
> way towards solving concurrency problems when you use
> collections heavily.  When they are inadequate, other
> measures need to be taken.


    Whole object synchronization strategies can cause deadlocks when you
don't expect, because unsuspect methods will be synchronized together.
There's always situations where this strategy works, but most objects aren't
simple and they usually collaborate with several other objects.


> > Sometimes we need
> > some quick hacks to debug a system or put out a
> > prototype, but concurrency
> > is a complex issue that can't be dealt with some
> > kind of patching.
> I guess that depends on what kind of program you
> are writing.  Perhaps most Java programs should be
> designed around concurrency.  My guess is that most
> programmer deal with concurrency only after it
> causes problems.


    That's the problem with such "helper" classes. They can introduce subtle
bugs very easily. It's against the Java "let's play safe" philosophy. I know
that there are other ways to create bugs (e.g. forgetting to unlock a lock)
but they're harder to produce, because they're harder to use.


> Just for a point of reference, my background as
> a Java applications programmer is in writing stand-alone
> desktop Swing apps and database driven JSP/Servlet apps.
> I freely admit to being outclassed by the gurus on this
> list, but that probably makes me a more typical user.
> > IMHO these kind of helper methods can lead to
> > lot's of difficult to track deadlock bugs.
> Lots of testing helps discover deadlocks.
> I've found the thread dump a relatively easy way
> of pinpointing deadlocks.
> http://java.sun.com/j2se/1.4.1/sample-output.html


    I agree that deadocks caused by monitor-based synchronization are
somewhat easy to find, but when we're using the Lock interface there's no
info on the thread dump. Also most kinds of deadlocks occurs once in a
while, because they require a particular set of conditions.


> Thanks,
> Curt


    As a side note I've used this kind of strategies some times to make
quick hacks and midnight patches, but ASAP I changed them to real working
designs. The Java library must be coherent and stable, so people would be
able to trust any given API. One of the most annoying bugs in the Bug Parade
is related to Date class being thread-unsafe, because of a quick hack to
cache the timezone (IIRC).

    Best regards,
    Daniel Yokomiso.

"There's no such thing as a tough child -- if you parboil them first for
seven hours, they always come out tender."
- W.C. Fields



---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.491 / Virus Database: 290 - Release Date: 18/6/2003


From Jacob.Solotaroff@evant.com  Fri Jun 27 22:25:55 2003
From: Jacob.Solotaroff@evant.com (Jacob Solotaroff)
Date: Fri, 27 Jun 2003 14:25:55 -0700
Subject: [concurrency-interest] RE: Hanging Night Job with 100% CPU Usage
Message-ID: <C1B59B760D2C534B9A94AD93A6F0E25A8A2F3E@sfoexc01.nonstop.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C33CF2.B19C6835
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

I won't bug anyone on this anymore, but we actually got this to happen
on Solaris a few days ago.  We called kill -11 on it and got a binary
core file.
I tried pstack, gdb, and a few other tools but can't get anything but
native stack traces.  Does anyone know how to get a java stack trace out
of a binary core file?

Thanks so much.

-----Original Message-----
From: Jacob Solotaroff=20
Sent: Wednesday, June 25, 2003 11:20 AM
To: 'concurrency-interest@altair.cs.oswego.edu'
Subject: Hanging Night Job with 100% CPU Usage

Hi,
We've had a problem for the last couple of months.  Our product involves
a batch job that is run every night.  At one of our client sites
(running Java 1.3.1 on AIX) the batch job hangs every 7-10 days.  We
have been unable to reproduce the problem either in house or on their
same box with the exact same data.  The difficulty in reproducing it
would suggest a threading problem.  We use the Oswego concurrency
libraries quite a bit.  However, when it hangs, the CPU usage goes to
100%.  We've checked and this is not due to paging.  Generally a
threading-related hang is due to deadlock and has 0% CPU usage.  Has
anyone seen a hang like this?  One that you can't reproduce but has 100%
CPU usage?

We've tried doing various kill -QUIT and kill -11 commands on it, but
the ascii javacore file gives us "Exception 2" instead of the stack
trace and the binary core file does not show up.  This could be due to
permission problems since the job is run through SUDO (we're looking
into this).

Thanks,
Jacob
Disclaimer:

This e-mail message, including any attachments,is for the sole use of =
the intended recipient(s) and may contain confidential and privileged =
information. Any unauthorized review, use, disclosure or distribution is =
prohibited. If you are not the intended recipient, please contact the =
sender by reply e-mail as well as admin@evant.com, and destroy all =
copies of the original message.
------_=_NextPart_001_01C33CF2.B19C6835
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Dus-ascii">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.0.6249.1">
<TITLE>RE: Hanging Night Job with 100% CPU Usage</TITLE>
</HEAD>
<BODY><FONT COLOR=3DBLACK>
<!-- Converted from text/rtf format -->

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 =
FACE=3D"Arial">I won</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 =
FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 FACE=3D"Arial">t bug =
anyone on this anymore, but we</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"> <FONT COLOR=3D"#000080" =
SIZE=3D2 FACE=3D"Arial">actually got this to happen on =
Solari</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 FACE=3D"Arial">s a few =
days ago</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 FACE=3D"Arial">.&nbsp; =
We called kill -11 on it and got a binary core file.</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 =
FACE=3D"Arial">I tried pstack, gdb, and a few other tools but =
can</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT =
COLOR=3D"#000080" SIZE=3D2 FACE=3D"Arial">&#8217;</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT COLOR=3D"#000080" =
SIZE=3D2 FACE=3D"Arial">t get anything but native stack traces.&nbsp; =
Does anyone know how to get a java stack trace out of a binary core =
file?</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT COLOR=3D"#000080" SIZE=3D2 =
FACE=3D"Arial">Thanks so much.</FONT></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Tahoma">-----Original Message-----<BR>
</FONT></SPAN><SPAN LANG=3D"en-us"><B></B></SPAN><SPAN =
LANG=3D"en-us"><B><FONT SIZE=3D2 =
FACE=3D"Tahoma">From:</FONT></B></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Tahoma"> Jacob Solotaroff<BR>
</FONT></SPAN><SPAN LANG=3D"en-us"><B></B></SPAN><SPAN =
LANG=3D"en-us"><B><FONT SIZE=3D2 =
FACE=3D"Tahoma">Sent:</FONT></B></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Tahoma"> Wednesday, June 25, 2003 =
11:20 AM<BR>
</FONT></SPAN><SPAN LANG=3D"en-us"><B></B></SPAN><SPAN =
LANG=3D"en-us"><B><FONT SIZE=3D2 =
FACE=3D"Tahoma">To:</FONT></B></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"><FONT SIZE=3D2 FACE=3D"Tahoma"> =
'concurrency-interest@altair.cs.oswego.edu'<BR>
</FONT></SPAN><SPAN LANG=3D"en-us"><B></B></SPAN><SPAN =
LANG=3D"en-us"><B><FONT SIZE=3D2 =
FACE=3D"Tahoma">Subject:</FONT></B></SPAN><SPAN =
LANG=3D"en-us"></SPAN><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Tahoma"> Hanging Night Job with 100% CPU =
Usage</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Hi,</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">We&#8217;ve had a problem for the last couple of =
months.&nbsp; Our product involves a batch job that is run every =
night.&nbsp; At one of our client sites (running Java 1.3.1 on AIX) the =
batch job hangs every 7-10 days.&nbsp; We have been unable to reproduce =
the problem either in house or on their same box with the exact same =
data.&nbsp; The difficulty in reproducing it would suggest a threading =
problem.&nbsp; We use the Oswego concurrency libraries quite a =
bit.&nbsp; However, when it hangs, the CPU usage goes to 100%.&nbsp; =
We&#8217;ve checked and this is not due to paging.&nbsp; Generally a =
threading-related hang is due to deadlock and has 0% CPU usage.&nbsp; =
Has anyone seen a hang like this?&nbsp; One that you can&#8217;t =
reproduce but has 100% CPU usage?</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">We&#8217;ve tried doing various kill &#8211;QUIT and kill =
-11 commands on it, but the ascii javacore file gives us =
&#8220;Exception 2&#8221; instead of the stack trace and the binary core =
file does not show up.&nbsp; This could be due to permission problems =
since the job is run through SUDO (we&#8217;re looking into =
this).</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Thanks,</FONT></SPAN></P>

<P ALIGN=3DLEFT><SPAN LANG=3D"en-us"><FONT SIZE=3D2 =
FACE=3D"Arial">Jacob</FONT></SPAN><SPAN LANG=3D"en-us"></SPAN><SPAN =
LANG=3D"en-us"></SPAN></P>

<br><font FACE=3D"Courier" SIZE=3D"2" >Disclaimer:<br> <br> This e-mail =
message, including any attachments,is for the sole use of the intended =
recipient(s) and may contain confidential and privileged information. =
Any unauthorized review, use, disclosure or distribution is prohibited. =
If you are not the intended recipient, please contact the sender by =
reply e-mail as well as <a =
href=3D"mailto:admin@evant.com">admin@evant.com</a>, and destroy all =
copies of the original message.
<br>
</font>
</BODY>
</HTML>
------_=_NextPart_001_01C33CF2.B19C6835--


