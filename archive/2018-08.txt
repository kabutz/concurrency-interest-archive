From davidstuebe at upserve.com  Mon Aug  6 10:10:33 2018
From: davidstuebe at upserve.com (David Stuebe)
Date: Mon, 6 Aug 2018 10:10:33 -0400
Subject: [concurrency-interest] =?utf-8?q?=28no_subject=29?=
Message-ID: <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ@mail.gmail.com>

Hey folks

Attempted to post this last week while I was joining the list. I think it
bounced. Please ignore if it is a repeat. I have not seen any responses and
I am sad.

I found some great discussion of a previous issue* with nested
Stream.parallel operations here and hoping I might find some answers to a
related question.
* http://cs.oswego.edu/pipermail/concurrency-interest/2014-May/012652.html

I am using a ConcurrentHashMap.compute operation in an outer
Stream.parallel forEach operation. A library used in the compute method
also uses Stream.parallel.

I have written a test that illustrates the issue and explores different
implementations in 215 lines of code.
https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java

The code deadlocks with the following stack trace:
https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt

I do not understand why line 87 (the compute block) appears to be called
recursively leading to deadlock when I use Stream.parallel for the outer
loop.

Best

David
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180806/543a8fb9/attachment.html>

From dl at cs.oswego.edu  Mon Aug  6 10:31:55 2018
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 6 Aug 2018 10:31:55 -0400
Subject: [concurrency-interest] CHM.compute restrictions (was: no
	subject)
In-Reply-To: <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ@mail.gmail.com>
References: <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ@mail.gmail.com>
Message-ID: <45511b57-3bb5-d3ec-d696-81086e7b389f@cs.oswego.edu>

On 08/06/2018 10:10 AM, David Stuebe via Concurrency-interest wrote:
> Hey folksÂ 
> 
> Attempted to post this last week while I was joining the list. 

To reduce spam, non-member posts are silently dropped. Sorry.

> 
> I am using a ConcurrentHashMap.compute operation in an outer
> Stream.parallel forEach operation. A library used in the compute method
> also uses Stream.parallel.
> 
> I have written a test that illustrates the issue and explores different
> implementations in 215 lines of code.
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
> 
> The code deadlocks with the following stack trace:
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
> 
> I do not understand why line 87 (the compute block) appears to be called
> recursively leading to deadlock when I use Stream.parallel for the outer
> loop.

A recursive CHM.compute call appears to invoked while trying to
initialize the contents of an element in the same map, which is
disallowed in general, but sometimes works anyway. In most other cases,
CHM successfully detects this and throws an exception, but it cannot
catch all of them.

-Doug





From davidstuebe at upserve.com  Tue Aug  7 10:39:53 2018
From: davidstuebe at upserve.com (David Stuebe)
Date: Tue, 7 Aug 2018 10:39:53 -0400
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
Message-ID: <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>

Hi Doug, Concurrency Interest

Sorry I lost the subject when I reposted.

I understand that updating other keys or recursively initializing the same
key is illegal in a CHM.compute. I don't understand how this example code
could be recursive though?

It seems to be a defect in parallel stream. Using a for loop to submit the
tasks in parallel for the out loop has no issue. These should be
effectively the same. There is some interaction between the outer parallel
stream that I don't understand.

I don't think Stream.parallel is expected to result in stream operators
executing recursively on stream elements?

Thanks

On Mon, Aug 6, 2018 at 12:01 PM <concurrency-interest-request at cs.oswego.edu>
wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. (no subject) (David Stuebe)
>    2. Re: CHM.compute restrictions (was: no     subject) (Doug Lea)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Mon, 6 Aug 2018 10:10:33 -0400
> From: David Stuebe <davidstuebe at upserve.com>
> To: "concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] (no subject)
> Message-ID:
>         <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=
> tSqyZDVQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hey folks
>
> Attempted to post this last week while I was joining the list. I think it
> bounced. Please ignore if it is a repeat. I have not seen any responses and
> I am sad.
>
> I found some great discussion of a previous issue* with nested
> Stream.parallel operations here and hoping I might find some answers to a
> related question.
> * http://cs.oswego.edu/pipermail/concurrency-interest/2014-May/012652.html
>
> I am using a ConcurrentHashMap.compute operation in an outer
> Stream.parallel forEach operation. A library used in the compute method
> also uses Stream.parallel.
>
> I have written a test that illustrates the issue and explores different
> implementations in 215 lines of code.
>
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
>
> The code deadlocks with the following stack trace:
>
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
>
> I do not understand why line 87 (the compute block) appears to be called
> recursively leading to deadlock when I use Stream.parallel for the outer
> loop.
>
> Best
>
> David
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180806/543a8fb9/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Mon, 6 Aug 2018 10:31:55 -0400
> From: Doug Lea <dl at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CHM.compute restrictions (was: no
>         subject)
> Message-ID: <45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu>
> Content-Type: text/plain; charset=utf-8
>
> On 08/06/2018 10:10 AM, David Stuebe via Concurrency-interest wrote:
> > Hey folks
> >
> > Attempted to post this last week while I was joining the list.
>
> To reduce spam, non-member posts are silently dropped. Sorry.
>
> >
> > I am using a ConcurrentHashMap.compute operation in an outer
> > Stream.parallel forEach operation. A library used in the compute method
> > also uses Stream.parallel.
> >
> > I have written a test that illustrates the issue and explores different
> > implementations in 215 lines of code.
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
> >
> > The code deadlocks with the following stack trace:
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
> >
> > I do not understand why line 87 (the compute block) appears to be called
> > recursively leading to deadlock when I use Stream.parallel for the outer
> > loop.
>
> A recursive CHM.compute call appears to invoked while trying to
> initialize the contents of an element in the same map, which is
> disallowed in general, but sometimes works anyway. In most other cases,
> CHM successfully detects this and throws an exception, but it cannot
> catch all of them.
>
> -Doug
>
>
>
>
>
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 162, Issue 1
> ****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/36af262f/attachment.html>

From peter.levart at gmail.com  Tue Aug  7 11:12:20 2018
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 7 Aug 2018 17:12:20 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
Message-ID: <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>

Hi David,

Doug can correct me if I'm wrong, but I think that the following is 
taking place:

If the CHM.compute is executed in a ForkJoinPool as a ForkJoinTask (as a 
consequence of invoking it from parallel Stream.forEach) and the 
remapping function passed to CHM.compute contains a computation that 
uses parallel Stream, then the ForkJoinWorkerThread executing the 
remapping function may help in execution of other pending ForkJoinTasks, 
meaning that other Stream.forEach tasks may get executed nested in the 
remapping function passed to CHM.compute - hence you get re-entry to 
CHM.compute from the same thread.

Am I right?

Regards, Peter

On 08/07/2018 04:39 PM, David Stuebe via Concurrency-interest wrote:
> Hi Doug, Concurrency Interest
>
> Sorry I lost the subject when I reposted.
>
> I understand that updating other keys or recursively initializing the 
> same key is illegal in a CHM.compute. I don't understand how this 
> example code could be recursive though?
>
> It seems to be a defect in parallel stream. Using a for loop to submit 
> the tasks in parallel for the out loop has no issue. These should be 
> effectively the same. There is some interaction between the outer 
> parallel stream that I don't understand.
>
> I don't think Stream.parallel is expected to result in stream 
> operators executing recursively on stream elements?
>
> Thanks
>
> On Mon, Aug 6, 2018 at 12:01 PM 
> <concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>> wrote:
>
>     Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>
>     To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>     <mailto:concurrency-interest-request at cs.oswego.edu>
>
>     You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>     <mailto:concurrency-interest-owner at cs.oswego.edu>
>
>     When replying, please edit your Subject line so it is more specific
>     than "Re: Contents of Concurrency-interest digest..."
>
>
>     Today's Topics:
>
>     Â  Â 1. (no subject) (David Stuebe)
>     Â  Â 2. Re: CHM.compute restrictions (was: noÂ  Â  Â subject) (Doug Lea)
>
>
>     ----------------------------------------------------------------------
>
>     Message: 1
>     Date: Mon, 6 Aug 2018 10:10:33 -0400
>     From: David Stuebe <davidstuebe at upserve.com
>     <mailto:davidstuebe at upserve.com>>
>     To: "concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>"
>     Â  Â  Â  Â  <concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>>
>     Subject: [concurrency-interest] (no subject)
>     Message-ID:
>     Â  Â  Â  Â 
>     <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ at mail.gmail.com
>     <mailto:tSqyZDVQ at mail.gmail.com>>
>     Content-Type: text/plain; charset="utf-8"
>
>     Hey folks
>
>     Attempted to post this last week while I was joining the list. I
>     think it
>     bounced. Please ignore if it is a repeat. I have not seen any
>     responses and
>     I am sad.
>
>     I found some great discussion of a previous issue* with nested
>     Stream.parallel operations here and hoping I might find some
>     answers to a
>     related question.
>     *
>     http://cs.oswego.edu/pipermail/concurrency-interest/2014-May/012652.html
>
>     I am using a ConcurrentHashMap.compute operation in an outer
>     Stream.parallel forEach operation. A library used in the compute
>     method
>     also uses Stream.parallel.
>
>     I have written a test that illustrates the issue and explores
>     different
>     implementations in 215 lines of code.
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
>
>     The code deadlocks with the following stack trace:
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
>
>     I do not understand why line 87 (the compute block) appears to be
>     called
>     recursively leading to deadlock when I use Stream.parallel for the
>     outer
>     loop.
>
>     Best
>
>     David
>     -------------- next part --------------
>     An HTML attachment was scrubbed...
>     URL:
>     <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180806/543a8fb9/attachment-0001.html>
>
>     ------------------------------
>
>     Message: 2
>     Date: Mon, 6 Aug 2018 10:31:55 -0400
>     From: Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>     To: concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>     Subject: Re: [concurrency-interest] CHM.compute restrictions (was: no
>     Â  Â  Â  Â  subject)
>     Message-ID: <45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu
>     <mailto:45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu>>
>     Content-Type: text/plain; charset=utf-8
>
>     On 08/06/2018 10:10 AM, David Stuebe via Concurrency-interest wrote:
>     > Hey folks
>     >
>     > Attempted to post this last week while I was joining the list.
>
>     To reduce spam, non-member posts are silently dropped. Sorry.
>
>     >
>     > I am using a ConcurrentHashMap.compute operation in an outer
>     > Stream.parallel forEach operation. A library used in the compute
>     method
>     > also uses Stream.parallel.
>     >
>     > I have written a test that illustrates the issue and explores
>     different
>     > implementations in 215 lines of code.
>     >
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
>     >
>     > The code deadlocks with the following stack trace:
>     >
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
>     >
>     > I do not understand why line 87 (the compute block) appears to
>     be called
>     > recursively leading to deadlock when I use Stream.parallel for
>     the outer
>     > loop.
>
>     A recursive CHM.compute call appears to invoked while trying to
>     initialize the contents of an element in the same map, which is
>     disallowed in general, but sometimes works anyway. In most other
>     cases,
>     CHM successfully detects this and throws an exception, but it cannot
>     catch all of them.
>
>     -Doug
>
>
>
>
>
>
>     ------------------------------
>
>     Subject: Digest Footer
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>     ------------------------------
>
>     End of Concurrency-interest Digest, Vol 162, Issue 1
>     ****************************************************
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/15945d04/attachment-0001.html>

From me at yawk.at  Tue Aug  7 11:13:24 2018
From: me at yawk.at (Jonas Konrad)
Date: Tue, 7 Aug 2018 17:13:24 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
Message-ID: <97d61d52-22eb-d429-3458-7d459c7f4c94@yawk.at>

How often is this supposed to deadlock? And in what environment? Because 
I can't get it to. Also, the code is *very* confusing.

- Jonas

On 08/07/2018 04:39 PM, David Stuebe via Concurrency-interest wrote:
> Hi Doug, Concurrency Interest
> 
> Sorry I lost the subject when I reposted.
> 
> I understand that updating other keys or recursively initializing the 
> same key is illegal in a CHM.compute. I don't understand how this 
> example code could be recursive though?
> 
> It seems to be a defect in parallel stream. Using a for loop to submit 
> the tasks in parallel for the out loop has no issue. These should be 
> effectively the same. There is some interaction between the outer 
> parallel stream that I don't understand.
> 
> I don't think Stream.parallel is expected to result in stream operators 
> executing recursively on stream elements?
> 
> Thanks
> 
> On Mon, Aug 6, 2018 at 12:01 PM 
> <concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>> wrote:
> 
>     Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
> 
>     To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>     <mailto:concurrency-interest-request at cs.oswego.edu>
> 
>     You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>     <mailto:concurrency-interest-owner at cs.oswego.edu>
> 
>     When replying, please edit your Subject line so it is more specific
>     than "Re: Contents of Concurrency-interest digest..."
> 
> 
>     Today's Topics:
> 
>      Â  Â 1. (no subject) (David Stuebe)
>      Â  Â 2. Re: CHM.compute restrictions (was: noÂ  Â  Â subject) (Doug Lea)
> 
> 
>     ----------------------------------------------------------------------
> 
>     Message: 1
>     Date: Mon, 6 Aug 2018 10:10:33 -0400
>     From: David Stuebe <davidstuebe at upserve.com
>     <mailto:davidstuebe at upserve.com>>
>     To: "concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>"
>      Â  Â  Â  Â  <concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>>
>     Subject: [concurrency-interest] (no subject)
>     Message-ID:
>             
>     <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ at mail.gmail.com
>     <mailto:tSqyZDVQ at mail.gmail.com>>
>     Content-Type: text/plain; charset="utf-8"
> 
>     Hey folks
> 
>     Attempted to post this last week while I was joining the list. I
>     think it
>     bounced. Please ignore if it is a repeat. I have not seen any
>     responses and
>     I am sad.
> 
>     I found some great discussion of a previous issue* with nested
>     Stream.parallel operations here and hoping I might find some answers
>     to a
>     related question.
>     *
>     http://cs.oswego.edu/pipermail/concurrency-interest/2014-May/012652.html
> 
>     I am using a ConcurrentHashMap.compute operation in an outer
>     Stream.parallel forEach operation. A library used in the compute method
>     also uses Stream.parallel.
> 
>     I have written a test that illustrates the issue and explores different
>     implementations in 215 lines of code.
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
> 
>     The code deadlocks with the following stack trace:
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
> 
>     I do not understand why line 87 (the compute block) appears to be called
>     recursively leading to deadlock when I use Stream.parallel for the outer
>     loop.
> 
>     Best
> 
>     David
>     -------------- next part --------------
>     An HTML attachment was scrubbed...
>     URL:
>     <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180806/543a8fb9/attachment-0001.html>
> 
>     ------------------------------
> 
>     Message: 2
>     Date: Mon, 6 Aug 2018 10:31:55 -0400
>     From: Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
>     To: concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>     Subject: Re: [concurrency-interest] CHM.compute restrictions (was: no
>      Â  Â  Â  Â  subject)
>     Message-ID: <45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu
>     <mailto:45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu>>
>     Content-Type: text/plain; charset=utf-8
> 
>     On 08/06/2018 10:10 AM, David Stuebe via Concurrency-interest wrote:
>      > Hey folks
>      >
>      > Attempted to post this last week while I was joining the list.
> 
>     To reduce spam, non-member posts are silently dropped. Sorry.
> 
>      >
>      > I am using a ConcurrentHashMap.compute operation in an outer
>      > Stream.parallel forEach operation. A library used in the compute
>     method
>      > also uses Stream.parallel.
>      >
>      > I have written a test that illustrates the issue and explores
>     different
>      > implementations in 215 lines of code.
>      >
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
>      >
>      > The code deadlocks with the following stack trace:
>      >
>     https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
>      >
>      > I do not understand why line 87 (the compute block) appears to be
>     called
>      > recursively leading to deadlock when I use Stream.parallel for
>     the outer
>      > loop.
> 
>     A recursive CHM.compute call appears to invoked while trying to
>     initialize the contents of an element in the same map, which is
>     disallowed in general, but sometimes works anyway. In most other cases,
>     CHM successfully detects this and throws an exception, but it cannot
>     catch all of them.
> 
>     -Doug
> 
> 
> 
> 
> 
> 
>     ------------------------------
> 
>     Subject: Digest Footer
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
>     ------------------------------
> 
>     End of Concurrency-interest Digest, Vol 162, Issue 1
>     ****************************************************
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From davidstuebe at upserve.com  Tue Aug  7 11:32:05 2018
From: davidstuebe at upserve.com (David Stuebe)
Date: Tue, 7 Aug 2018 11:32:05 -0400
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
Message-ID: <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>

Hi Peter, Doug

That is very interesting!

I am not sure I fully grok your explanation, but it did suggest changing
the inner task pool to be a fixed thread pool rather than a forkjoin pool.
This appears to alleviate the issue!

More experiments to follow.

David
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/19501b59/attachment.html>

From davidstuebe at upserve.com  Tue Aug  7 12:10:02 2018
From: davidstuebe at upserve.com (David Stuebe)
Date: Tue, 7 Aug 2018 12:10:02 -0400
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 162,
	Issue 3
In-Reply-To: <mailman.1.1533657601.4039.concurrency-interest@cs.oswego.edu>
References: <mailman.1.1533657601.4039.concurrency-interest@cs.oswego.edu>
Message-ID: <CAJh0pqGa=ohZ54Az9iMVBERxh22Uwcgu5Bk+U9gLi15tQzcijw@mail.gmail.com>

Hi Jonas

$ java --version
java 10.0.2 2018-07-17
Java(TM) SE Runtime Environment 18.3 (build 10.0.2+13)
Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.2+13, mixed mode)

$ uname -a
Darwin dstuebe 16.7.0 Darwin Kernel Version 16.7.0: Thu Jun 21 20:07:39 PDT
2018; root:xnu-3789.73.14~1/RELEASE_X86_64 x86_64

$ java -classpath out/production/efstress com.upserve.NestedParallel
starting
*** application hangs ***

Running jstack should dump a thread stack including a section like:

Found one Java-level deadlock:
=============================
"outer pool1":
  waiting to lock monitor 0x00007fbf02006800 (object 0x00000006cfa288d0, a
java.util.concurrent.ConcurrentHashMap$Node),
  which is held by "outer pool2"
"outer pool2":
  waiting to lock monitor 0x00007fbefe11ac00 (object 0x00000006cfaac488, a
java.util.concurrent.ConcurrentHashMap$Node),
  which is held by "outer pool1"

Please accept my apologies for the code structure. I did my best to
synthesize a simple repro case that demonstrates the issue and allows
experimentation with different implementations for the inner and outer loop.

Best

David


On Tue, Aug 7, 2018 at 12:00 PM <concurrency-interest-request at cs.oswego.edu>
wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Re: CHM.compute restrictions (Jonas Konrad)
>    2. Re: CHM.compute restrictions (David Stuebe)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Tue, 7 Aug 2018 17:13:24 +0200
> From: Jonas Konrad <me at yawk.at>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CHM.compute restrictions
> Message-ID: <97d61d52-22eb-d429-3458-7d459c7f4c94 at yawk.at>
> Content-Type: text/plain; charset=utf-8; format=flowed
>
> How often is this supposed to deadlock? And in what environment? Because
> I can't get it to. Also, the code is *very* confusing.
>
> - Jonas
>
> On 08/07/2018 04:39 PM, David Stuebe via Concurrency-interest wrote:
> > Hi Doug, Concurrency Interest
> >
> > Sorry I lost the subject when I reposted.
> >
> > I understand that updating other keys or recursively initializing the
> > same key is illegal in a CHM.compute. I don't understand how this
> > example code could be recursive though?
> >
> > It seems to be a defect in parallel stream. Using a for loop to submit
> > the tasks in parallel for the out loop has no issue. These should be
> > effectively the same. There is some interaction between the outer
> > parallel stream that I don't understand.
> >
> > I don't think Stream.parallel is expected to result in stream operators
> > executing recursively on stream elements?
> >
> > Thanks
> >
> > On Mon, Aug 6, 2018 at 12:01 PM
> > <concurrency-interest-request at cs.oswego.edu
> > <mailto:concurrency-interest-request at cs.oswego.edu>> wrote:
> >
> >     Send Concurrency-interest mailing list submissions to
> >     concurrency-interest at cs.oswego.edu
> >     <mailto:concurrency-interest at cs.oswego.edu>
> >
> >     To subscribe or unsubscribe via the World Wide Web, visit
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >     or, via email, send a message with subject or body 'help' to
> >     concurrency-interest-request at cs.oswego.edu
> >     <mailto:concurrency-interest-request at cs.oswego.edu>
> >
> >     You can reach the person managing the list at
> >     concurrency-interest-owner at cs.oswego.edu
> >     <mailto:concurrency-interest-owner at cs.oswego.edu>
> >
> >     When replying, please edit your Subject line so it is more specific
> >     than "Re: Contents of Concurrency-interest digest..."
> >
> >
> >     Today's Topics:
> >
> >         1. (no subject) (David Stuebe)
> >         2. Re: CHM.compute restrictions (was: no     subject) (Doug Lea)
> >
> >
> >
>  ----------------------------------------------------------------------
> >
> >     Message: 1
> >     Date: Mon, 6 Aug 2018 10:10:33 -0400
> >     From: David Stuebe <davidstuebe at upserve.com
> >     <mailto:davidstuebe at upserve.com>>
> >     To: "concurrency-interest at cs.oswego.edu
> >     <mailto:concurrency-interest at cs.oswego.edu>"
> >              <concurrency-interest at cs.oswego.edu
> >     <mailto:concurrency-interest at cs.oswego.edu>>
> >     Subject: [concurrency-interest] (no subject)
> >     Message-ID:
> >
> >     <CAJh0pqEVuzteLqiijAsFiVMFm1XL+KO7o12MzH5wu=tSqyZDVQ at mail.gmail.com
> >     <mailto:tSqyZDVQ at mail.gmail.com>>
> >     Content-Type: text/plain; charset="utf-8"
> >
> >     Hey folks
> >
> >     Attempted to post this last week while I was joining the list. I
> >     think it
> >     bounced. Please ignore if it is a repeat. I have not seen any
> >     responses and
> >     I am sad.
> >
> >     I found some great discussion of a previous issue* with nested
> >     Stream.parallel operations here and hoping I might find some answers
> >     to a
> >     related question.
> >     *
> >
> http://cs.oswego.edu/pipermail/concurrency-interest/2014-May/012652.html
> >
> >     I am using a ConcurrentHashMap.compute operation in an outer
> >     Stream.parallel forEach operation. A library used in the compute
> method
> >     also uses Stream.parallel.
> >
> >     I have written a test that illustrates the issue and explores
> different
> >     implementations in 215 lines of code.
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
> >
> >     The code deadlocks with the following stack trace:
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
> >
> >     I do not understand why line 87 (the compute block) appears to be
> called
> >     recursively leading to deadlock when I use Stream.parallel for the
> outer
> >     loop.
> >
> >     Best
> >
> >     David
> >     -------------- next part --------------
> >     An HTML attachment was scrubbed...
> >     URL:
> >     <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180806/543a8fb9/attachment-0001.html
> >
> >
> >     ------------------------------
> >
> >     Message: 2
> >     Date: Mon, 6 Aug 2018 10:31:55 -0400
> >     From: Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu>>
> >     To: concurrency-interest at cs.oswego.edu
> >     <mailto:concurrency-interest at cs.oswego.edu>
> >     Subject: Re: [concurrency-interest] CHM.compute restrictions (was: no
> >              subject)
> >     Message-ID: <45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu
> >     <mailto:45511b57-3bb5-d3ec-d696-81086e7b389f at cs.oswego.edu>>
> >     Content-Type: text/plain; charset=utf-8
> >
> >     On 08/06/2018 10:10 AM, David Stuebe via Concurrency-interest wrote:
> >      > Hey folks
> >      >
> >      > Attempted to post this last week while I was joining the list.
> >
> >     To reduce spam, non-member posts are silently dropped. Sorry.
> >
> >      >
> >      > I am using a ConcurrentHashMap.compute operation in an outer
> >      > Stream.parallel forEach operation. A library used in the compute
> >     method
> >      > also uses Stream.parallel.
> >      >
> >      > I have written a test that illustrates the issue and explores
> >     different
> >      > implementations in 215 lines of code.
> >      >
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-nestedparallel-java
> >      >
> >      > The code deadlocks with the following stack trace:
> >      >
> >
> https://gist.github.com/dstuebe/89361f64dc44a935e53d0a49f149317c#file-stacktrace-txt
> >      >
> >      > I do not understand why line 87 (the compute block) appears to be
> >     called
> >      > recursively leading to deadlock when I use Stream.parallel for
> >     the outer
> >      > loop.
> >
> >     A recursive CHM.compute call appears to invoked while trying to
> >     initialize the contents of an element in the same map, which is
> >     disallowed in general, but sometimes works anyway. In most other
> cases,
> >     CHM successfully detects this and throws an exception, but it cannot
> >     catch all of them.
> >
> >     -Doug
> >
> >
> >
> >
> >
> >
> >     ------------------------------
> >
> >     Subject: Digest Footer
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at cs.oswego.edu
> >     <mailto:Concurrency-interest at cs.oswego.edu>
> >     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >     ------------------------------
> >
> >     End of Concurrency-interest Digest, Vol 162, Issue 1
> >     ****************************************************
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> ------------------------------
>
> Message: 2
> Date: Tue, 7 Aug 2018 11:32:05 -0400
> From: David Stuebe <davidstuebe at upserve.com>
> To: Peter Levart <peter.levart at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] CHM.compute restrictions
> Message-ID:
>         <
> CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi Peter, Doug
>
> That is very interesting!
>
> I am not sure I fully grok your explanation, but it did suggest changing
> the inner task pool to be a fixed thread pool rather than a forkjoin pool.
> This appears to alleviate the issue!
>
> More experiments to follow.
>
> David
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/19501b59/attachment-0001.html
> >
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 162, Issue 3
> ****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/7141d102/attachment-0001.html>

From peter.levart at gmail.com  Tue Aug  7 12:12:04 2018
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 7 Aug 2018 18:12:04 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
 <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
Message-ID: <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>

Looking at stack trace, it can be seen that this is indeed taking the place:

 Â Â Â  at 
java.util.concurrent.ConcurrentHashMap.compute(java.base at 10.0.2/ConcurrentHashMap.java:1938)
 Â Â Â  - waiting to lock <0x00000006cfb30b58> (a 
java.util.concurrent.ConcurrentHashMap$ReservationNode)
 Â Â Â  at 
com.upserve.NestedParallel.lambda$streamParallelOuterTask$4(NestedParallel.java:87)
 Â Â Â  at com.upserve.NestedParallel$$Lambda$6/354291670.accept(Unknown 
Source)
 Â Â Â  at 
java.util.stream.ForEachOps$ForEachOp$OfLong.accept(java.base at 10.0.2/ForEachOps.java:225)
 Â Â Â  at 
java.util.Random$RandomLongsSpliterator.forEachRemaining(java.base at 10.0.2/Random.java:1099)
 Â Â Â  at 
java.util.Spliterator$OfLong.forEachRemaining(java.base at 10.0.2/Spliterator.java:763)
 Â Â Â  at 
java.util.stream.AbstractPipeline.copyInto(java.base at 10.0.2/AbstractPipeline.java:484)
 Â Â Â  at 
java.util.stream.ForEachOps$ForEachTask.compute(java.base at 10.0.2/ForEachOps.java:290)
 Â Â Â  at 
java.util.concurrent.CountedCompleter.exec(java.base at 10.0.2/CountedCompleter.java:746)
 Â Â Â  at 
java.util.concurrent.ForkJoinTask.doExec(java.base at 10.0.2/ForkJoinTask.java:290)
 Â Â Â  at 
java.util.concurrent.*ForkJoinPool.awaitJoin*(java.base at 10.0.2/ForkJoinPool.java:1713)
 Â Â Â  at 
java.util.concurrent.ForkJoinTask.doJoin(java.base at 10.0.2/ForkJoinTask.java:397)
 Â Â Â  at 
java.util.concurrent.ForkJoinTask.get(java.base at 10.0.2/ForkJoinTask.java:1004)
 Â Â Â  at 
com.upserve.NestedParallel.streamParallelInnerTask(NestedParallel.java:172)
 Â Â Â  at 
com.upserve.NestedParallel.lambda$biFunction$9(NestedParallel.java:147)
 Â Â Â  at com.upserve.NestedParallel$$Lambda$12/1333040169.apply(Unknown 
Source)
 Â Â Â  at 
java.util.concurrent.ConcurrentHashMap.compute(java.base at 10.0.2/ConcurrentHashMap.java:1922)

ForkJoinPool.awaitJoin - is a method that awaits for the task to 
complete while helping to execute other tasks so that the thread is not 
wasted. In above stack trace, the task executing awaitJoin is an inner 
task, while the task being executed by awaitJoin is an outer task.

To avoid that, outer and inner tasks should not share the same ForkJoinPool.

Regards, Peter

On 08/07/2018 05:32 PM, David Stuebe wrote:
>
> Hi Peter, Doug
>
> That is very interesting!
>
> I am not sure I fully grok your explanation, but it did suggest 
> changing the inner task pool to be a fixed thread pool rather than a 
> forkjoin pool. This appears to alleviate the issue!
>
> More experiments to follow.
>
> David

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180807/5283d8ab/attachment.html>

From peter.levart at gmail.com  Tue Aug  7 12:19:53 2018
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 7 Aug 2018 18:19:53 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
 <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
 <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>
Message-ID: <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>



On 08/07/2018 06:12 PM, Peter Levart wrote:
> To avoid that, outer and inner tasks should not share the same 
> ForkJoinPool.

But Stream(s) are currently not designed to work with anything else than 
default ForkJoinPool.

Would it make sense to extend the Stream API with an overloaded method like:

Stream.parallel(ForkJoinPool) ?


Regards, Peter


From me at yawk.at  Tue Aug  7 12:28:13 2018
From: me at yawk.at (Jonas Konrad)
Date: Tue, 7 Aug 2018 18:28:13 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
 <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
 <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>
 <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>
Message-ID: <5bfd5f54-e181-301b-92fc-9442b529257f@yawk.at>

Shouldn't streams use the current FJP when executed inside one? As in, 
if the current thread is a ForkJoinWorkerThread, it'll use that thread's 
pool.

- Jonas

On 08/07/2018 06:19 PM, Peter Levart via Concurrency-interest wrote:
> 
> 
> On 08/07/2018 06:12 PM, Peter Levart wrote:
>> To avoid that, outer and inner tasks should not share the same 
>> ForkJoinPool.
> 
> But Stream(s) are currently not designed to work with anything else than 
> default ForkJoinPool.
> 
> Would it make sense to extend the Stream API with an overloaded method 
> like:
> 
> Stream.parallel(ForkJoinPool) ?
> 
> 
> Regards, Peter
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From gpiwowarek at gmail.com  Tue Aug  7 16:42:28 2018
From: gpiwowarek at gmail.com (Grzegorz Piwowarek)
Date: Tue, 7 Aug 2018 22:42:28 +0200
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <5bfd5f54-e181-301b-92fc-9442b529257f@yawk.at>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
 <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
 <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>
 <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>
 <5bfd5f54-e181-301b-92fc-9442b529257f@yawk.at>
Message-ID: <8E5C7BCD-2F78-46FF-BDFE-A06CF2B39368@gmail.com>

They do - but thereâs no contract enforcing that - thatâs just an implementation trick and you should not rely on that

> On 07 Aug 2018, at 18:28, Jonas Konrad via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> Shouldn't streams use the current FJP when executed inside one? As in, if the current thread is a ForkJoinWorkerThread, it'll use that thread's pool.
> 
> - Jonas
> 
> On 08/07/2018 06:19 PM, Peter Levart via Concurrency-interest wrote:
>> On 08/07/2018 06:12 PM, Peter Levart wrote:
>>> To avoid that, outer and inner tasks should not share the same ForkJoinPool.
>> But Stream(s) are currently not designed to work with anything else than default ForkJoinPool.
>> Would it make sense to extend the Stream API with an overloaded method like:
>> Stream.parallel(ForkJoinPool) ?
>> Regards, Peter
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Wed Aug  8 08:35:39 2018
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 8 Aug 2018 08:35:39 -0400
Subject: [concurrency-interest] CHM.compute restrictions
In-Reply-To: <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>
References: <mailman.1.1533571201.17159.concurrency-interest@cs.oswego.edu>
 <CAJh0pqHkRjbCiWUyY5uO6Pa4xxFx9rCmYzM79LkrV9gzA=V09Q@mail.gmail.com>
 <3338cb05-7490-fafc-b884-f913130bb2ff@gmail.com>
 <CAJh0pqHYncVSJeXbXsmkjqx7Vppyybr7yMYHfsYX8sMcvcfDJg@mail.gmail.com>
 <6280bd32-e410-82d9-bfb3-e3d5dc03027d@gmail.com>
 <49b8476f-d4ec-39d5-4031-4299b1db8125@gmail.com>
Message-ID: <e5441fe8-1cff-b229-a2b7-935ceea69205@cs.oswego.edu>

On 08/07/2018 12:19 PM, Peter Levart via Concurrency-interest wrote:

> On 08/07/2018 06:12 PM, Peter Levart wrote:
>> To avoid that, outer and inner tasks should not share the same
>> ForkJoinPool.

This might happen to work. But the underlying issue is that the call to
CHM.compute causes a nested call to compute that may modify the same
map. This is is specifically disallowed for Map.compute,
See:
https://docs.oracle.com/javase/9/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-

The spec says "should not" vs "must not" because there are special cases
in which it may be OK. And also cases in which it is trapped as an
exception. Which does not happen here because the logically nested call
occurs in another thread, which evades CHM checks. Some execution
schedules will encounter lockup, some won't.

A better fix to the program would be to not nest parallelism within the
compute method itself (forcing reservation), but instead in another
method that finally sets the entry with result of call. Possibly using
CHM.replace for atomicity.

-Doug

From jeffhain at rocketmail.com  Wed Aug  8 17:14:45 2018
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Wed, 8 Aug 2018 21:14:45 +0000 (UTC)
Subject: [concurrency-interest] Atomic non-null then null
References: <996327361.6412765.1533762885173.ref@mail.yahoo.com>
Message-ID: <996327361.6412765.1533762885173@mail.yahoo.com>

Hello.

Could someone confirm (or invalidate :) that the following class works?

The "tricky part" is that get() is supposed to be callable concurrently.
If it always gets called by a same thread, it should obviously work
since only this thread would deal with the non-volatile reference.



/**
Â * When wanting to retrieve an object from an AtomicReference
Â * that is initially non-null and then is only set once and with null,
Â * this class allows to get rid of the volatile read overhead
Â * after the nullification has been detected.
Â */
public class AtomicNonNullThenNull<T> {

Â Â Â  private final AtomicReference<T> aRef;

Â Â Â  private Object ref = this;

Â Â Â  /**
Â Â Â Â  * @param aRef The initially non-null reference must be set into it
Â Â Â Â  *Â Â Â Â Â Â Â  early enough for first call to get() method to see it.
Â Â Â Â  */
Â Â Â  public AtomicNonNullThenNull(AtomicReference<T> aRef) {
Â Â Â Â Â Â Â  this.aRef = aRef;
Â Â Â  }

Â Â Â  /**
Â Â Â Â  * Must only be called from threads to which the initial state
Â Â Â Â  * of this instance has properly been made visible.
Â Â Â Â  * 
Â Â Â Â  * @return The reference retrieved from the AtomicReference specified
Â Â Â Â  *Â Â Â Â Â Â Â Â  to the constructor, until a call to this method detects that
Â Â Â Â  *Â Â Â Â Â Â Â Â  it became null, after which null is always returned,
Â Â Â Â  *Â Â Â Â Â Â Â Â  from a non-volatile read.
Â Â Â Â  */
Â Â Â  public T get() {
Â Â Â Â Â Â Â  final Object ref = this.ref;
Â Â Â Â Â Â Â  if (ref == null) {
Â Â Â Â Â Â Â Â Â Â Â  return null;
Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â  final T vRef = this.aRef.get();
Â Â Â Â Â Â Â Â Â Â Â  if (vRef == null) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Possibly done by multiple threads.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  this.ref = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return null;
Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return vRef;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
Â Â Â  }
}



NB1: I use it in a method that gets called a lot,
to do something once if it ever gets called,
as follows:
Â Â Â  final Runnable runnable = anntn.get();
Â Â Â  if ((runnable != null) && aRef.compareAndSet(runnable, null)) {
Â Â Â Â Â Â Â  runnable.run();
Â Â Â  }
I just read the discussion about "Unsynchronized lazy condition" from June,
and the "Effective Java" class load trick, which seems to solve a similar
problem.
The cons that I see for the class load trick are that you need one class per use case,
that it is always "slow" when it triggers (class load),
and that it can only "fire" once (with ANNTN you could do aRef.set(null) only after a few runs),
and the pro that in the long run the overhead is smaller due to the method being empty
(unless the JIT can see that once the value is null it can never get back to non-null,
and optimize the code away).



NB2: There is a dual "AtomicNullThenNonNull" using a similar idea,
but it only works with objects with final fields or such,
since it can make them visible without proper memory barriers.



-Jeff

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180808/df50d342/attachment.html>

From akarnokd at gmail.com  Wed Aug  8 17:36:46 2018
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 8 Aug 2018 23:36:46 +0200
Subject: [concurrency-interest] Atomic non-null then null
In-Reply-To: <996327361.6412765.1533762885173@mail.yahoo.com>
References: <996327361.6412765.1533762885173.ref@mail.yahoo.com>
 <996327361.6412765.1533762885173@mail.yahoo.com>
Message-ID: <CAAWwtm_ZgFzB9WRjx8HajN_2C-eqCJjBQugFq58mpig+B-osSA@mail.gmail.com>

Hi Jeff,

Why the complication? Just return the value of `aRef` all the time. All
those extra code there with the additional read of `ref` and the
conditional checks look redundant as you'd probably have to null check the
result of your `get()` method anyway. Are you targeting a platform with an
expensive volatile read operation?

Jeff Hain via Concurrency-interest <concurrency-interest at cs.oswego.edu> ezt
Ã­rta (idÅpont: 2018. aug. 8., Sze, 23:23):

> Hello.
>
> Could someone confirm (or invalidate :) that the following class works?
>
> The "tricky part" is that get() is supposed to be callable concurrently.
> If it always gets called by a same thread, it should obviously work
> since only this thread would deal with the non-volatile reference.
>
>
>
> /**
>  * When wanting to retrieve an object from an AtomicReference
>  * that is initially non-null and then is only set once and with null,
>  * this class allows to get rid of the volatile read overhead
>  * after the nullification has been detected.
>  */
> public class AtomicNonNullThenNull<T> {
>
>     private final AtomicReference<T> aRef;
>
>     private Object ref = this;
>
>     /**
>      * @param aRef The initially non-null reference must be set into it
>      *        early enough for first call to get() method to see it.
>      */
>     public AtomicNonNullThenNull(AtomicReference<T> aRef) {
>         this.aRef = aRef;
>     }
>
>     /**
>      * Must only be called from threads to which the initial state
>      * of this instance has properly been made visible.
>      *
>      * @return The reference retrieved from the AtomicReference specified
>      *         to the constructor, until a call to this method detects that
>      *         it became null, after which null is always returned,
>      *         from a non-volatile read.
>      */
>     public T get() {
>         final Object ref = this.ref;
>         if (ref == null) {
>             return null;
>         } else {
>             final T vRef = this.aRef.get();
>             if (vRef == null) {
>                 // Possibly done by multiple threads.
>                 this.ref = null;
>                 return null;
>             } else {
>                 return vRef;
>             }
>         }
>     }
> }
>
>
>
> NB1: I use it in a method that gets called a lot,
> to do something once if it ever gets called,
> as follows:
>     final Runnable runnable = anntn.get();
>     if ((runnable != null) && aRef.compareAndSet(runnable, null)) {
>         runnable.run();
>     }
> I just read the discussion about "Unsynchronized lazy condition" from June,
> and the "Effective Java" class load trick, which seems to solve a similar
> problem.
> The cons that I see for the class load trick are that you need one class
> per use case,
> that it is always "slow" when it triggers (class load),
> and that it can only "fire" once (with ANNTN you could do aRef.set(null)
> only after a few runs),
> and the pro that in the long run the overhead is smaller due to the method
> being empty
> (unless the JIT can see that once the value is null it can never get back
> to non-null,
> and optimize the code away).
>
>
>
> NB2: There is a dual "AtomicNullThenNonNull" using a similar idea,
> but it only works with objects with final fields or such,
> since it can make them visible without proper memory barriers.
>
>
>
> -Jeff
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180808/2a1ed891/attachment.html>

From jeffhain at rocketmail.com  Wed Aug  8 18:53:33 2018
From: jeffhain at rocketmail.com (Jeff Hain)
Date: Wed, 8 Aug 2018 22:53:33 +0000 (UTC)
Subject: [concurrency-interest] Atomic non-null then null
In-Reply-To: <CAAWwtm_ZgFzB9WRjx8HajN_2C-eqCJjBQugFq58mpig+B-osSA@mail.gmail.com>
References: <996327361.6412765.1533762885173.ref@mail.yahoo.com>
 <996327361.6412765.1533762885173@mail.yahoo.com>
 <CAAWwtm_ZgFzB9WRjx8HajN_2C-eqCJjBQugFq58mpig+B-osSA@mail.gmail.com>
Message-ID: <1057848887.6485314.1533768813180@mail.yahoo.com>

>Why the complication? Just return the value of `aRef` all the time.
>All those extra code there with the additional read of `ref` and the conditional checks
>look redundant as you'd probably have to null check the result of your `get()` method anyway.
>Are you targeting a platform with an expensive volatile read operation?

Hi DÃ¡vid,

I initially made ANNTN for this logging class (where it's called NullElseAtomicReference):
https://github.com/jeffhain/jodk/blob/master/src/net/jodk/threading/HeisenLogger.java

The idea of HeisenLogger is to be able to do logs with minimal memory barriers,
typically just a lazySet, to help debug concurrency issues (heisenbugs)
without making them go away with heavy memory barriers (and slow synchronous
logging code).
It served me well while developing variations around the Disruptor pattern.

I know that volatile reads can be quite fast (when uncontended), but I wanted to make sure
the code is always fast, in particular by avoiding the risk of false sharing without using
heavy and eventually unsufficient padding, and did not cause an avoidable memory barrier.

The complexity being mostly factored in a single class, it shouldn't hurt.
Could also increase the encapsulation by making the AtomicReference internal to it,
and have public methods to deal with it.

-Jeff


Jeff Hain via Concurrency-interest <concurrency-interest at cs.oswego.edu> ezt Ã­rta (idÅpont: 2018. aug. 8., Sze, 23:23):

Hello.

Could someone confirm (or invalidate :) that the following class works?

The "tricky part" is that get() is supposed to be callable concurrently.
If it always gets called by a same thread, it should obviously work
since only this thread would deal with the non-volatile reference.



/**
Â * When wanting to retrieve an object from an AtomicReference
Â * that is initially non-null and then is only set once and with null,
Â * this class allows to get rid of the volatile read overhead
Â * after the nullification has been detected.
Â */
public class AtomicNonNullThenNull<T> {

Â Â Â  private final AtomicReference<T> aRef;

Â Â Â  private Object ref = this;

Â Â Â  /**
Â Â Â Â  * @param aRef The initially non-null reference must be set into it
Â Â Â Â  *Â Â Â Â Â Â Â  early enough for first call to get() method to see it.
Â Â Â Â  */
Â Â Â  public AtomicNonNullThenNull(AtomicReference<T> aRef) {
Â Â Â Â Â Â Â  this.aRef = aRef;
Â Â Â  }

Â Â Â  /**
Â Â Â Â  * Must only be called from threads to which the initial state
Â Â Â Â  * of this instance has properly been made visible.
Â Â Â Â  * 
Â Â Â Â  * @return The reference retrieved from the AtomicReference specified
Â Â Â Â  *Â Â Â Â Â Â Â Â  to the constructor, until a call to this method detects that
Â Â Â Â  *Â Â Â Â Â Â Â Â  it became null, after which null is always returned,
Â Â Â Â  *Â Â Â Â Â Â Â Â  from a non-volatile read.
Â Â Â Â  */
Â Â Â  public T get() {
Â Â Â Â Â Â Â  final Object ref = this.ref;
Â Â Â Â Â Â Â  if (ref == null) {
Â Â Â Â Â Â Â Â Â Â Â  return null;
Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â  final T vRef = this.aRef.get();
Â Â Â Â Â Â Â Â Â Â Â  if (vRef == null) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Possibly done by multiple threads.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  this.ref = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return null;
Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return vRef;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
Â Â Â  }
}



NB1: I use it in a method that gets called a lot,
to do something once if it ever gets called,
as follows:
Â Â Â  final Runnable runnable = anntn.get();
Â Â Â  if ((runnable != null) && aRef.compareAndSet(runnable, null)) {
Â Â Â Â Â Â Â  runnable.run();
Â Â Â  }
I just read the discussion about "Unsynchronized lazy condition" from June,
and the "Effective Java" class load trick, which seems to solve a similar
problem.
The cons that I see for the class load trick are that you need one class per use case,
that it is always "slow" when it triggers (class load),
and that it can only "fire" once (with ANNTN you could do aRef.set(null) only after a few runs),
and the pro that in the long run the overhead is smaller due to the method being empty
(unless the JIT can see that once the value is null it can never get back to non-null,
and optimize the code away).



NB2: There is a dual "AtomicNullThenNonNull" using a similar idea,
but it only works with objects with final fields or such,
since it can make them visible without proper memory barriers.



-Jeff

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-- 
Best regards,David Karnok  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180808/bde4945b/attachment-0001.html>

From raphfrk at gmail.com  Sun Aug 12 10:29:20 2018
From: raphfrk at gmail.com (Raph Frank)
Date: Sun, 12 Aug 2018 15:29:20 +0100
Subject: [concurrency-interest] Visibility of array initialization
Message-ID: <CAN1xFdqG=5Os8dRREioLpmRymiYqzG4-480PZGx_hS1Ve7kQYA@mail.gmail.com>

I was wondering what are the visibility rules for array initialization.

If an array is initialized and then another thread gets access to a
reference to that array, are the elements guaranteed to be at least their
initial state (or could the array be all zeros)?


*Thread 1*
int[] array = new int[] {-1, -1, -1};
thread2.start();

......

array = new int[] {1, 2, 3};

*Thread 2*
System.out.println(array[2]);

Is it possible for the 2nd thread to print zero?  Is it guaranteed to print
-1 or 2?

The spec refers to final fields in the constructor of objects and also says
that arrays referenced by final fields are visible (including elements).

" It will also see versions of any object or array referenced by those final
fields that are at least as up-to-date as the final fields are. "

It doesn't give any indication of what happens when initializing raw
arrays.  Does the array initialization count as a constructor?

Is the logical process that arrays are set to all zeros at time zero and
then they are initialized when created?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/dfc942e3/attachment.html>

From jsampson at guidewire.com  Sun Aug 12 13:44:11 2018
From: jsampson at guidewire.com (Justin Sampson)
Date: Sun, 12 Aug 2018 17:44:11 +0000
Subject: [concurrency-interest] Visibility of array initialization
In-Reply-To: <CAN1xFdqG=5Os8dRREioLpmRymiYqzG4-480PZGx_hS1Ve7kQYA@mail.gmail.com>
References: <CAN1xFdqG=5Os8dRREioLpmRymiYqzG4-480PZGx_hS1Ve7kQYA@mail.gmail.com>
Message-ID: <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF@guidewire.com>

The spec explicitly calls out the length of an array as being a final field, so it's always guaranteed to be seen correctly:

https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5

But array elements are just regular heap variables, initialized to 0 before the initializer expression is evaluated:

https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1

So yeah, I'm pretty sure that means you could see 0's if the array isn't published safely.

Cheers,
Justin


From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> on behalf of "concurrency-interest at cs.oswego.edu" <concurrency-interest at cs.oswego.edu>
Reply-To: Raph Frank <raphfrk at gmail.com>
Date: Sunday, August 12, 2018 at 7:29 AM
To: "concurrency-interest at cs.oswego.edu" <concurrency-interest at cs.oswego.edu>
Subject: [concurrency-interest] Visibility of array initialization

I was wondering what are the visibility rules for array initialization.

If an array is initialized and then another thread gets access to a reference to that array, are the elements guaranteed to be at least their initial state (or could the array be all zeros)?

Thread 1
int[] array = new int[] {-1, -1, -1};
thread2.start();

......

array = new int[] {1, 2, 3};

Thread 2
System.out.println(array[2]);

Is it possible for the 2nd thread to print zero?  Is it guaranteed to print -1 or 2?

The spec refers to final fields in the constructor of objects and also says that arrays referenced by final fields are visible (including elements).

" It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are. "

It doesn't give any indication of what happens when initializing raw arrays.  Does the array initialization count as a constructor?

Is the logical process that arrays are set to all zeros at time zero and then they are initialized when created?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/8eaa907a/attachment.html>

From yankee.sierra at gmail.com  Sun Aug 12 14:21:01 2018
From: yankee.sierra at gmail.com (Yuval Shavit)
Date: Sun, 12 Aug 2018 14:21:01 -0400
Subject: [concurrency-interest] Visibility of array initialization
In-Reply-To: <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF@guidewire.com>
References: <CAN1xFdqG=5Os8dRREioLpmRymiYqzG4-480PZGx_hS1Ve7kQYA@mail.gmail.com>
 <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF@guidewire.com>
Message-ID: <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=eaw@mail.gmail.com>

I believe the value will be -1 or 2, but not 0 -- not for any special array
semantics, but because the call to Thread::start introduces a
happens-before (JLS 17.4.5).

On Sun, Aug 12, 2018 at 1:48 PM Justin Sampson via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> The spec explicitly calls out the *length* of an array as being a final
> field, so it's always guaranteed to be seen correctly:
>
>
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5
>
>
>
> But array elements are just regular heap variables, initialized to 0
> before the initializer expression is evaluated:
>
>
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1
>
>
>
> So yeah, I'm pretty sure that means you could see 0's if the array isn't
> published safely.
>
>
>
> Cheers,
>
> Justin
>
>
>
>
>
> *From: *Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu>
> on behalf of "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> *Reply-To: *Raph Frank <raphfrk at gmail.com>
> *Date: *Sunday, August 12, 2018 at 7:29 AM
> *To: *"concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> *Subject: *[concurrency-interest] Visibility of array initialization
>
>
>
> I was wondering what are the visibility rules for array initialization.
>
>
>
> If an array is initialized and then another thread gets access to a
> reference to that array, are the elements guaranteed to be at least their
> initial state (or could the array be all zeros)?
>
>
>
> *Thread 1*
>
> int[] array = new int[] {-1, -1, -1};
>
> thread2.start();
>
>
>
> ......
>
>
>
> array = new int[] {1, 2, 3};
>
>
>
> *Thread 2*
>
> System.out.println(array[2]);
>
>
>
> Is it possible for the 2nd thread to print zero?  Is it guaranteed to
> print -1 or 2?
>
>
>
> The spec refers to final fields in the constructor of objects and also
> says that arrays referenced by final fields are visible (including
> elements).
>
>
>
> " It will also see versions of any object or array referenced by those
> final fields that are at least as up-to-date as the final fields are. "
>
>
>
> It doesn't give any indication of what happens when initializing raw
> arrays.  Does the array initialization count as a constructor?
>
>
>
> Is the logical process that arrays are set to all zeros at time zero and
> then they are initialized when created?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/89a0c6e3/attachment-0001.html>

From valentin.male.kovalenko at gmail.com  Sun Aug 12 15:54:33 2018
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sun, 12 Aug 2018 13:54:33 -0600
Subject: [concurrency-interest] Visibility of array initialization (Raph
	Frank)
In-Reply-To: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
References: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
Message-ID: <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>

Hi Raph,

JMM does not make any difference between read/write actions from/to
static/non-static fields and to array elements: see "17.4.1. Shared
Variables" (
https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1)
which says "All instance fields, static fields, and array elements are
stored in heap memory. In this chapter, we use the term variable to refer
to both fields and array elements."

So when you think about read/write actions from/to array elements, treat
them the same way you treat read/write actions from/to other shared
variables.

Having said that, the anwser to your question "Is it possible for the 2nd
thread to print zero?  Is it guaranteed to print -1 or 2?" is: The second
thread is allowed to print either -1 or 3 and nothing else (NPE is also not
allowed).

Let's give letter names to some actions in executions of your program:

----------thread1
// array = null //_wa - an implicit write
///////////////////////of the default value,
///////////////////////which according to JMM
///////////////////////happens-before the first action
///////////////////////in every thread

// array[2] = 0 // _w0 - an implicit write
///////////////////////of the default value

int[] array = new int[] { //wa
  -1, -1,
  -1 //w(-1)
};
thread2.start();
array = new int[] { //wa'
  1, 2,
  3 //w3
};

----------thread2
System.out.println(
  array[ //ra, read array reference
    2 //r
  ]
);

<NPE> while dereferencing array is impossible.
  ra can't return null because the corresponding implicit write _wa is not
allowed to be observed by read ra:
    HB(_wa, wa) and HB(wa, ra), thus wa prevents ra from observing _wa.

<0> is not allowed to be observed.
  Because the corresponding implicit write _w0 is not allowed to be
observed by read r:
    HB(_w0, w(-1)) and HB(w(-1), r), thus w(-1) prevents r from observing
_w0.

<-1> is allowed to be printed
  Because the corresponding write w(-1) is allowed to be observed by read r:
    HB(w(-1), r) and there is no write wx such that (HB(w(-1), wx) and
HB(wx, r)), i.e. there is no write wx preventing read r from observing
write w(-1).

<3> is allowed to be printed
  Because the corresponding write w3 is allowed to be observed by read r:
    neither HB(w3, r) nor HB(r, w3).

<2> is not allowed to be printed
  Because no execution contains an action writing 2 in array[2]. I assume
this was a typo and you meant <3>.

It's also worth mentioning that JMM sais "The semantics of operations other
than inter-thread actions, such as reads of array lengths (Â§10.7),
executions of checked casts (Â§5.5, Â§15.16), and invocations of virtual
methods (Â§15.12), are not directly affected by data races. Therefore, a
data race cannot cause incorrect behavior such as returning the wrong
length for an array." So as Justin has already pointed out, you can treat
array.length as a final field.

Regards,
Valentin
[image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image: GitHub]
<https://github.com/stIncMale>   [image: YouTube]
<https://www.youtube.com/user/stIncMale>


On Sun, 12 Aug 2018 at 12:34, <concurrency-interest-request at cs.oswego.edu>
wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Re: Visibility of array initialization (Justin Sampson)
>    2. Re: Visibility of array initialization (Yuval Shavit)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sun, 12 Aug 2018 17:44:11 +0000
> From: Justin Sampson <jsampson at guidewire.com>
> To: Raph Frank <raphfrk at gmail.com>,
>         "concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Visibility of array initialization
> Message-ID: <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF at guidewire.com>
> Content-Type: text/plain; charset="utf-8"
>
> The spec explicitly calls out the length of an array as being a final
> field, so it's always guaranteed to be seen correctly:
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5
>
> But array elements are just regular heap variables, initialized to 0
> before the initializer expression is evaluated:
>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1
>
> So yeah, I'm pretty sure that means you could see 0's if the array isn't
> published safely.
>
> Cheers,
> Justin
>
>
> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu>
> on behalf of "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> Reply-To: Raph Frank <raphfrk at gmail.com>
> Date: Sunday, August 12, 2018 at 7:29 AM
> To: "concurrency-interest at cs.oswego.edu" <
> concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] Visibility of array initialization
>
> I was wondering what are the visibility rules for array initialization.
>
> If an array is initialized and then another thread gets access to a
> reference to that array, are the elements guaranteed to be at least their
> initial state (or could the array be all zeros)?
>
> Thread 1
> int[] array = new int[] {-1, -1, -1};
> thread2.start();
>
> ......
>
> array = new int[] {1, 2, 3};
>
> Thread 2
> System.out.println(array[2]);
>
> Is it possible for the 2nd thread to print zero?  Is it guaranteed to
> print -1 or 2?
>
> The spec refers to final fields in the constructor of objects and also
> says that arrays referenced by final fields are visible (including
> elements).
>
> " It will also see versions of any object or array referenced by those
> final fields that are at least as up-to-date as the final fields are. "
>
> It doesn't give any indication of what happens when initializing raw
> arrays.  Does the array initialization count as a constructor?
>
> Is the logical process that arrays are set to all zeros at time zero and
> then they are initialized when created?
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/8eaa907a/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Sun, 12 Aug 2018 14:21:01 -0400
> From: Yuval Shavit <yankee.sierra at gmail.com>
> To: jsampson at guidewire.com
> Cc: raphfrk at gmail.com,  "Concurrency-interest at cs.oswego.edu"
>         <concurrency-interest at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Visibility of array initialization
> Message-ID:
>         <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=
> eaw at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> I believe the value will be -1 or 2, but not 0 -- not for any special array
> semantics, but because the call to Thread::start introduces a
> happens-before (JLS 17.4.5).
>
> On Sun, Aug 12, 2018 at 1:48 PM Justin Sampson via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
> > The spec explicitly calls out the *length* of an array as being a final
> > field, so it's always guaranteed to be seen correctly:
> >
> >
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
> >
> >
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5
> >
> >
> >
> > But array elements are just regular heap variables, initialized to 0
> > before the initializer expression is evaluated:
> >
> >
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
> >
> >
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1
> >
> >
> >
> > So yeah, I'm pretty sure that means you could see 0's if the array isn't
> > published safely.
> >
> >
> >
> > Cheers,
> >
> > Justin
> >
> >
> >
> >
> >
> > *From: *Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu
> >
> > on behalf of "concurrency-interest at cs.oswego.edu" <
> > concurrency-interest at cs.oswego.edu>
> > *Reply-To: *Raph Frank <raphfrk at gmail.com>
> > *Date: *Sunday, August 12, 2018 at 7:29 AM
> > *To: *"concurrency-interest at cs.oswego.edu" <
> > concurrency-interest at cs.oswego.edu>
> > *Subject: *[concurrency-interest] Visibility of array initialization
> >
> >
> >
> > I was wondering what are the visibility rules for array initialization.
> >
> >
> >
> > If an array is initialized and then another thread gets access to a
> > reference to that array, are the elements guaranteed to be at least their
> > initial state (or could the array be all zeros)?
> >
> >
> >
> > *Thread 1*
> >
> > int[] array = new int[] {-1, -1, -1};
> >
> > thread2.start();
> >
> >
> >
> > ......
> >
> >
> >
> > array = new int[] {1, 2, 3};
> >
> >
> >
> > *Thread 2*
> >
> > System.out.println(array[2]);
> >
> >
> >
> > Is it possible for the 2nd thread to print zero?  Is it guaranteed to
> > print -1 or 2?
> >
> >
> >
> > The spec refers to final fields in the constructor of objects and also
> > says that arrays referenced by final fields are visible (including
> > elements).
> >
> >
> >
> > " It will also see versions of any object or array referenced by those
> > final fields that are at least as up-to-date as the final fields are. "
> >
> >
> >
> > It doesn't give any indication of what happens when initializing raw
> > arrays.  Does the array initialization count as a constructor?
> >
> >
> >
> > Is the logical process that arrays are set to all zeros at time zero and
> > then they are initialized when created?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/89a0c6e3/attachment.html
> >
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 162, Issue 8
> ****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/c37204de/attachment-0001.html>

From oleksandr.otenko at gmail.com  Sun Aug 12 16:30:38 2018
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Sun, 12 Aug 2018 21:30:38 +0100
Subject: [concurrency-interest] Visibility of array initialization (Raph
 Frank)
In-Reply-To: <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
References: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
 <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
Message-ID: <117C4AF1-C97A-47E3-8180-EB8E1A7AC037@gmail.com>

All these responses miss the important aspect: the creation of the second array is not atomic, and it is not guaranteed that the assignment of a new reference to array to be observable after a write of 3 to array[2].

It is allowed that array = new int[3]; is observed first, and only then array[2]=3 is observed.

So, array[2] = 0 is observable.

Alex

> On 12 Aug 2018, at 20:54, Valentin Kovalenko via Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:
> 
> Hi Raph,
> 
> JMM does not make any difference between read/write actions from/to static/non-static fields and to array elements: see "17.4.1. Shared Variables" (https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1>) which says "All instance fields, static fields, and array elements are stored in heap memory. In this chapter, we use the term variable to refer to both fields and array elements."
> 
> So when you think about read/write actions from/to array elements, treat them the same way you treat read/write actions from/to other shared variables.
> 
> Having said that, the anwser to your question "Is it possible for the 2nd thread to print zero?  Is it guaranteed to print -1 or 2?" is: The second thread is allowed to print either -1 or 3 and nothing else (NPE is also not allowed).
> 
> Let's give letter names to some actions in executions of your program:
> 
> ----------thread1
> // array = null //_wa - an implicit write
> ///////////////////////of the default value,
> ///////////////////////which according to JMM
> ///////////////////////happens-before the first action
> ///////////////////////in every thread
> 
> // array[2] = 0 // _w0 - an implicit write
> ///////////////////////of the default value
> 
> int[] array = new int[] { //wa
>   -1, -1,
>   -1 //w(-1)
> };
> thread2.start();
> array = new int[] { //wa'
>   1, 2,
>   3 //w3
> };
> 
> ----------thread2
> System.out.println(
>   array[ //ra, read array reference
>     2 //r
>   ]
> );
> 
> <NPE> while dereferencing array is impossible.
>   ra can't return null because the corresponding implicit write _wa is not allowed to be observed by read ra:
>     HB(_wa, wa) and HB(wa, ra), thus wa prevents ra from observing _wa.
> 
> <0> is not allowed to be observed.
>   Because the corresponding implicit write _w0 is not allowed to be observed by read r:
>     HB(_w0, w(-1)) and HB(w(-1), r), thus w(-1) prevents r from observing _w0.
> 
> <-1> is allowed to be printed
>   Because the corresponding write w(-1) is allowed to be observed by read r:
>     HB(w(-1), r) and there is no write wx such that (HB(w(-1), wx) and HB(wx, r)), i.e. there is no write wx preventing read r from observing write w(-1).
> 
> <3> is allowed to be printed
>   Because the corresponding write w3 is allowed to be observed by read r:
>     neither HB(w3, r) nor HB(r, w3).
> 
> <2> is not allowed to be printed
>   Because no execution contains an action writing 2 in array[2]. I assume this was a typo and you meant <3>.
> 
> It's also worth mentioning that JMM sais "The semantics of operations other than inter-thread actions, such as reads of array lengths (Â§10.7), executions of checked casts (Â§5.5, Â§15.16), and invocations of virtual methods (Â§15.12), are not directly affected by data races. Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array." So as Justin has already pointed out, you can treat array.length as a final field.
> 
> Regards,
> Valentin
>  <https://www.linkedin.com/in/stIncMale>    <https://github.com/stIncMale>    <https://www.youtube.com/user/stIncMale>
> 
> 
> On Sun, 12 Aug 2018 at 12:34, <concurrency-interest-request at cs.oswego.edu <mailto:concurrency-interest-request at cs.oswego.edu>> wrote:
> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>
> 
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu <mailto:concurrency-interest-request at cs.oswego.edu>
> 
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu <mailto:concurrency-interest-owner at cs.oswego.edu>
> 
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
> 
> 
> Today's Topics:
> 
>    1. Re: Visibility of array initialization (Justin Sampson)
>    2. Re: Visibility of array initialization (Yuval Shavit)
> 
> 
> ----------------------------------------------------------------------
> 
> Message: 1
> Date: Sun, 12 Aug 2018 17:44:11 +0000
> From: Justin Sampson <jsampson at guidewire.com <mailto:jsampson at guidewire.com>>
> To: Raph Frank <raphfrk at gmail.com <mailto:raphfrk at gmail.com>>,
>         "concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>"
>         <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] Visibility of array initialization
> Message-ID: <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF at guidewire.com <mailto:0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF at guidewire.com>>
> Content-Type: text/plain; charset="utf-8"
> 
> The spec explicitly calls out the length of an array as being a final field, so it's always guaranteed to be seen correctly:
> 
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5>
> 
> But array elements are just regular heap variables, initialized to 0 before the initializer expression is evaluated:
> 
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6>
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1>
> 
> So yeah, I'm pretty sure that means you could see 0's if the array isn't published safely.
> 
> Cheers,
> Justin
> 
> 
> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>> on behalf of "concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>" <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> Reply-To: Raph Frank <raphfrk at gmail.com <mailto:raphfrk at gmail.com>>
> Date: Sunday, August 12, 2018 at 7:29 AM
> To: "concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>" <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: [concurrency-interest] Visibility of array initialization
> 
> I was wondering what are the visibility rules for array initialization.
> 
> If an array is initialized and then another thread gets access to a reference to that array, are the elements guaranteed to be at least their initial state (or could the array be all zeros)?
> 
> Thread 1
> int[] array = new int[] {-1, -1, -1};
> thread2.start();
> 
> ......
> 
> array = new int[] {1, 2, 3};
> 
> Thread 2
> System.out.println(array[2]);
> 
> Is it possible for the 2nd thread to print zero?  Is it guaranteed to print -1 or 2?
> 
> The spec refers to final fields in the constructor of objects and also says that arrays referenced by final fields are visible (including elements).
> 
> " It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are. "
> 
> It doesn't give any indication of what happens when initializing raw arrays.  Does the array initialization count as a constructor?
> 
> Is the logical process that arrays are set to all zeros at time zero and then they are initialized when created?
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/8eaa907a/attachment-0001.html <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/8eaa907a/attachment-0001.html>>
> 
> ------------------------------
> 
> Message: 2
> Date: Sun, 12 Aug 2018 14:21:01 -0400
> From: Yuval Shavit <yankee.sierra at gmail.com <mailto:yankee.sierra at gmail.com>>
> To: jsampson at guidewire.com <mailto:jsampson at guidewire.com>
> Cc: raphfrk at gmail.com <mailto:raphfrk at gmail.com>,  "Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>"
>         <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> Subject: Re: [concurrency-interest] Visibility of array initialization
> Message-ID:
>         <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=eaw at mail.gmail.com <mailto:eaw at mail.gmail.com>>
> Content-Type: text/plain; charset="utf-8"
> 
> I believe the value will be -1 or 2, but not 0 -- not for any special array
> semantics, but because the call to Thread::start introduces a
> happens-before (JLS 17.4.5).
> 
> On Sun, Aug 12, 2018 at 1:48 PM Justin Sampson via Concurrency-interest <
> concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>> wrote:
> 
> > The spec explicitly calls out the *length* of an array as being a final
> > field, so it's always guaranteed to be seen correctly:
> >
> >
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7>
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5>
> >
> >
> >
> > But array elements are just regular heap variables, initialized to 0
> > before the initializer expression is evaluated:
> >
> >
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6>
> >
> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1 <https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1>
> >
> >
> >
> > So yeah, I'm pretty sure that means you could see 0's if the array isn't
> > published safely.
> >
> >
> >
> > Cheers,
> >
> > Justin
> >
> >
> >
> >
> >
> > *From: *Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu <mailto:concurrency-interest-bounces at cs.oswego.edu>>
> > on behalf of "concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>" <
> > concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> > *Reply-To: *Raph Frank <raphfrk at gmail.com <mailto:raphfrk at gmail.com>>
> > *Date: *Sunday, August 12, 2018 at 7:29 AM
> > *To: *"concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>" <
> > concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu>>
> > *Subject: *[concurrency-interest] Visibility of array initialization
> >
> >
> >
> > I was wondering what are the visibility rules for array initialization.
> >
> >
> >
> > If an array is initialized and then another thread gets access to a
> > reference to that array, are the elements guaranteed to be at least their
> > initial state (or could the array be all zeros)?
> >
> >
> >
> > *Thread 1*
> >
> > int[] array = new int[] {-1, -1, -1};
> >
> > thread2.start();
> >
> >
> >
> > ......
> >
> >
> >
> > array = new int[] {1, 2, 3};
> >
> >
> >
> > *Thread 2*
> >
> > System.out.println(array[2]);
> >
> >
> >
> > Is it possible for the 2nd thread to print zero?  Is it guaranteed to
> > print -1 or 2?
> >
> >
> >
> > The spec refers to final fields in the constructor of objects and also
> > says that arrays referenced by final fields are visible (including
> > elements).
> >
> >
> >
> > " It will also see versions of any object or array referenced by those
> > final fields that are at least as up-to-date as the final fields are. "
> >
> >
> >
> > It doesn't give any indication of what happens when initializing raw
> > arrays.  Does the array initialization count as a constructor?
> >
> >
> >
> > Is the logical process that arrays are set to all zeros at time zero and
> > then they are initialized when created?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/89a0c6e3/attachment.html <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/89a0c6e3/attachment.html>>
> 
> ------------------------------
> 
> Subject: Digest Footer
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> ------------------------------
> 
> End of Concurrency-interest Digest, Vol 162, Issue 8
> ****************************************************
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/488c74b4/attachment-0001.html>

From valentin.male.kovalenko at gmail.com  Sun Aug 12 16:33:26 2018
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sun, 12 Aug 2018 14:33:26 -0600
Subject: [concurrency-interest] Visibility of array initialization (Raph
	Frank)
In-Reply-To: <117C4AF1-C97A-47E3-8180-EB8E1A7AC037@gmail.com>
References: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
 <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
 <117C4AF1-C97A-47E3-8180-EB8E1A7AC037@gmail.com>
Message-ID: <CAO-wXw+TghWuugLCV+twcvm3wz0QHodXyZKuYu1rT1c9a_HtOA@mail.gmail.com>

Alex,

You are 100% right, thanks for pointing this out!

Regards,
Valentin
[image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image: GitHub]
<https://github.com/stIncMale>   [image: YouTube]
<https://www.youtube.com/user/stIncMale>


On Sun, 12 Aug 2018 at 14:30, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> All these responses miss the important aspect: the creation of the second
> array is not atomic, and it is not guaranteed that the assignment of a new
> reference to array to be observable after a write of 3 to array[2].
>
> It is allowed that array = new int[3]; is observed first, and only then
> array[2]=3 is observed.
>
> So, array[2] = 0 is observable.
>
> Alex
>
> On 12 Aug 2018, at 20:54, Valentin Kovalenko via Concurrency-interest <
> concurrency-interest at cs.oswego.edu> wrote:
>
> Hi Raph,
>
> JMM does not make any difference between read/write actions from/to
> static/non-static fields and to array elements: see "17.4.1. Shared
> Variables" (
> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1)
> which says "All instance fields, static fields, and array elements are
> stored in heap memory. In this chapter, we use the term variable to refer
> to both fields and array elements."
>
> So when you think about read/write actions from/to array elements, treat
> them the same way you treat read/write actions from/to other shared
> variables.
>
> Having said that, the anwser to your question "Is it possible for the 2nd
> thread to print zero?  Is it guaranteed to print -1 or 2?" is: The second
> thread is allowed to print either -1 or 3 and nothing else (NPE is also not
> allowed).
>
> Let's give letter names to some actions in executions of your program:
>
> ----------thread1
> // array = null //_wa - an implicit write
> ///////////////////////of the default value,
> ///////////////////////which according to JMM
> ///////////////////////happens-before the first action
> ///////////////////////in every thread
>
> // array[2] = 0 // _w0 - an implicit write
> ///////////////////////of the default value
>
> int[] array = new int[] { //wa
>   -1, -1,
>   -1 //w(-1)
> };
> thread2.start();
> array = new int[] { //wa'
>   1, 2,
>   3 //w3
> };
>
> ----------thread2
> System.out.println(
>   array[ //ra, read array reference
>     2 //r
>   ]
> );
>
> <NPE> while dereferencing array is impossible.
>   ra can't return null because the corresponding implicit write _wa is
> not allowed to be observed by read ra:
>     HB(_wa, wa) and HB(wa, ra), thus wa prevents ra from observing _wa.
>
> <0> is not allowed to be observed.
>   Because the corresponding implicit write _w0 is not allowed to be
> observed by read r:
>     HB(_w0, w(-1)) and HB(w(-1), r), thus w(-1) prevents r from observing
> _w0.
>
> <-1> is allowed to be printed
>   Because the corresponding write w(-1) is allowed to be observed by read
>  r:
>     HB(w(-1), r) and there is no write wx such that (HB(w(-1), wx) and
> HB(wx, r)), i.e. there is no write wx preventing read r from observing
> write w(-1).
>
> <3> is allowed to be printed
>   Because the corresponding write w3 is allowed to be observed by read r:
>     neither HB(w3, r) nor HB(r, w3).
>
> <2> is not allowed to be printed
>   Because no execution contains an action writing 2 in array[2]. I assume
> this was a typo and you meant <3>.
>
> It's also worth mentioning that JMM sais "The semantics of operations
> other than inter-thread actions, such as reads of array lengths (Â§10.7),
> executions of checked casts (Â§5.5, Â§15.16), and invocations of virtual
> methods (Â§15.12), are not directly affected by data races. Therefore, a
> data race cannot cause incorrect behavior such as returning the wrong
> length for an array." So as Justin has already pointed out, you can treat
> array.length as a final field.
>
> Regards,
> Valentin
> [image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image:
> GitHub] <https://github.com/stIncMale>   [image: YouTube]
> <https://www.youtube.com/user/stIncMale>
>
>
> On Sun, 12 Aug 2018 at 12:34, <concurrency-interest-request at cs.oswego.edu>
> wrote:
>
>> Send Concurrency-interest mailing list submissions to
>>         concurrency-interest at cs.oswego.edu
>>
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> or, via email, send a message with subject or body 'help' to
>>         concurrency-interest-request at cs.oswego.edu
>>
>> You can reach the person managing the list at
>>         concurrency-interest-owner at cs.oswego.edu
>>
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of Concurrency-interest digest..."
>>
>>
>> Today's Topics:
>>
>>    1. Re: Visibility of array initialization (Justin Sampson)
>>    2. Re: Visibility of array initialization (Yuval Shavit)
>>
>>
>> ----------------------------------------------------------------------
>>
>> Message: 1
>> Date: Sun, 12 Aug 2018 17:44:11 +0000
>> From: Justin Sampson <jsampson at guidewire.com>
>> To: Raph Frank <raphfrk at gmail.com>,
>>         "concurrency-interest at cs.oswego.edu"
>>         <concurrency-interest at cs.oswego.edu>
>> Subject: Re: [concurrency-interest] Visibility of array initialization
>> Message-ID: <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF at guidewire.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> The spec explicitly calls out the length of an array as being a final
>> field, so it's always guaranteed to be seen correctly:
>>
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5
>>
>> But array elements are just regular heap variables, initialized to 0
>> before the initializer expression is evaluated:
>>
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1
>>
>> So yeah, I'm pretty sure that means you could see 0's if the array isn't
>> published safely.
>>
>> Cheers,
>> Justin
>>
>>
>> From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu>
>> on behalf of "concurrency-interest at cs.oswego.edu" <
>> concurrency-interest at cs.oswego.edu>
>> Reply-To: Raph Frank <raphfrk at gmail.com>
>> Date: Sunday, August 12, 2018 at 7:29 AM
>> To: "concurrency-interest at cs.oswego.edu" <
>> concurrency-interest at cs.oswego.edu>
>> Subject: [concurrency-interest] Visibility of array initialization
>>
>> I was wondering what are the visibility rules for array initialization.
>>
>> If an array is initialized and then another thread gets access to a
>> reference to that array, are the elements guaranteed to be at least their
>> initial state (or could the array be all zeros)?
>>
>> Thread 1
>> int[] array = new int[] {-1, -1, -1};
>> thread2.start();
>>
>> ......
>>
>> array = new int[] {1, 2, 3};
>>
>> Thread 2
>> System.out.println(array[2]);
>>
>> Is it possible for the 2nd thread to print zero?  Is it guaranteed to
>> print -1 or 2?
>>
>> The spec refers to final fields in the constructor of objects and also
>> says that arrays referenced by final fields are visible (including
>> elements).
>>
>> " It will also see versions of any object or array referenced by those
>> final fields that are at least as up-to-date as the final fields are. "
>>
>> It doesn't give any indication of what happens when initializing raw
>> arrays.  Does the array initialization count as a constructor?
>>
>> Is the logical process that arrays are set to all zeros at time zero and
>> then they are initialized when created?
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <
>> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/8eaa907a/attachment-0001.html
>> >
>>
>> ------------------------------
>>
>> Message: 2
>> Date: Sun, 12 Aug 2018 14:21:01 -0400
>> From: Yuval Shavit <yankee.sierra at gmail.com>
>> To: jsampson at guidewire.com
>> Cc: raphfrk at gmail.com,  "Concurrency-interest at cs.oswego.edu"
>>         <concurrency-interest at cs.oswego.edu>
>> Subject: Re: [concurrency-interest] Visibility of array initialization
>> Message-ID:
>>         <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=
>> eaw at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> I believe the value will be -1 or 2, but not 0 -- not for any special
>> array
>> semantics, but because the call to Thread::start introduces a
>> happens-before (JLS 17.4.5).
>>
>> On Sun, Aug 12, 2018 at 1:48 PM Justin Sampson via Concurrency-interest <
>> concurrency-interest at cs.oswego.edu> wrote:
>>
>> > The spec explicitly calls out the *length* of an array as being a final
>> > field, so it's always guaranteed to be seen correctly:
>> >
>> >
>> >
>> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.7
>> >
>> >
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.5
>> >
>> >
>> >
>> > But array elements are just regular heap variables, initialized to 0
>> > before the initializer expression is evaluated:
>> >
>> >
>> >
>> > https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html#jls-10.6
>> >
>> >
>> https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1
>> >
>> >
>> >
>> > So yeah, I'm pretty sure that means you could see 0's if the array isn't
>> > published safely.
>> >
>> >
>> >
>> > Cheers,
>> >
>> > Justin
>> >
>> >
>> >
>> >
>> >
>> > *From: *Concurrency-interest <
>> concurrency-interest-bounces at cs.oswego.edu>
>> > on behalf of "concurrency-interest at cs.oswego.edu" <
>> > concurrency-interest at cs.oswego.edu>
>> > *Reply-To: *Raph Frank <raphfrk at gmail.com>
>> > *Date: *Sunday, August 12, 2018 at 7:29 AM
>> > *To: *"concurrency-interest at cs.oswego.edu" <
>> > concurrency-interest at cs.oswego.edu>
>> > *Subject: *[concurrency-interest] Visibility of array initialization
>> >
>> >
>> >
>> > I was wondering what are the visibility rules for array initialization.
>> >
>> >
>> >
>> > If an array is initialized and then another thread gets access to a
>> > reference to that array, are the elements guaranteed to be at least
>> their
>> > initial state (or could the array be all zeros)?
>> >
>> >
>> >
>> > *Thread 1*
>> >
>> > int[] array = new int[] {-1, -1, -1};
>> >
>> > thread2.start();
>> >
>> >
>> >
>> > ......
>> >
>> >
>> >
>> > array = new int[] {1, 2, 3};
>> >
>> >
>> >
>> > *Thread 2*
>> >
>> > System.out.println(array[2]);
>> >
>> >
>> >
>> > Is it possible for the 2nd thread to print zero?  Is it guaranteed to
>> > print -1 or 2?
>> >
>> >
>> >
>> > The spec refers to final fields in the constructor of objects and also
>> > says that arrays referenced by final fields are visible (including
>> > elements).
>> >
>> >
>> >
>> > " It will also see versions of any object or array referenced by those
>> > final fields that are at least as up-to-date as the final fields are. "
>> >
>> >
>> >
>> > It doesn't give any indication of what happens when initializing raw
>> > arrays.  Does the array initialization count as a constructor?
>> >
>> >
>> >
>> > Is the logical process that arrays are set to all zeros at time zero and
>> > then they are initialized when created?
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <
>> http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/89a0c6e3/attachment.html
>> >
>>
>> ------------------------------
>>
>> Subject: Digest Footer
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>> ------------------------------
>>
>> End of Concurrency-interest Digest, Vol 162, Issue 8
>> ****************************************************
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/d88169a3/attachment-0001.html>

From sitnikov.vladimir at gmail.com  Sun Aug 12 16:36:37 2018
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Sun, 12 Aug 2018 23:36:37 +0300
Subject: [concurrency-interest] Visibility of array initialization (Raph
	Frank)
In-Reply-To: <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
References: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
 <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
Message-ID: <CAB=Je-FvRXLhkOf6HGtx_sw6f2FGUixyQcf7Ukk8mEiUTG9PWQ@mail.gmail.com>

Valentin>Having said that, the anwser to your question "Is it possible for
the 2nd thread to print zero?  Is it guaranteed to print -1 or 2?" is: The
second thread is allowed to print either -1 or 3 and nothing else (NPE is
also not allowed).

I would argue there.

TL;DR: -1, 0, 3 are allowed. NPE is forbidden.


1) NPE is not allowed (since there's only one write of null to `array`
field which is implicit write of default value).

2) 0 is also allowed since Thread 2 could see updated value of `array`
(that is it could see the reference to the array that was set after the
thread started).
Apparently, there are "implicit writes of 0 values of the elements in the
new array", and nothing prevents Thread 2 from observing those writes.

I'm not a lawyer, but
https://docs.oracle.com/javase/specs/jls/se6/html/expressions.html#15.10.1
seems to address that:

JLS6> and each component of the array is initialized to its default value
(Â§4.12.5).

In other words, new int[] {1, 2, 3}; does not mean the array is created
"atomically".
It is equivalent to the   x=new int[3]; x[0]=1; x[1]=2; x[2]=3;
Obviously that can cause Thread2 to observe 0 as well.


Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/fffb8bf5/attachment.html>

From raphfrk at gmail.com  Sun Aug 12 16:55:53 2018
From: raphfrk at gmail.com (Raph Frank)
Date: Sun, 12 Aug 2018 21:55:53 +0100
Subject: [concurrency-interest] Visibility of array initialization
In-Reply-To: <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=eaw@mail.gmail.com>
References: <CAN1xFdqG=5Os8dRREioLpmRymiYqzG4-480PZGx_hS1Ve7kQYA@mail.gmail.com>
 <0801B8EC-BDA5-4AFF-97F6-EE483A0AD2AF@guidewire.com>
 <CAE+h5-B6VpOeXiz-bgNGn=p32r-uiDhzZL5y1p+y21jE1f=eaw@mail.gmail.com>
Message-ID: <CAN1xFdqTJ+EALVz73+cbok3zDSWG7FgpRBHVguL7G=Y_a7PDGg@mail.gmail.com>

On Sun, Aug 12, 2018 at 7:21 PM, Yuval Shavit <yankee.sierra at gmail.com>
wrote:

> I believe the value will be -1 or 2, but not 0 -- not for any special
> array semantics, but because the call to Thread::start introduces a
> happens-before (JLS 17.4.5).
>
> I think it could generate a zero since the 2nd array is a new array.  This
is potentially zero.


On Sun, Aug 12, 2018 at 8:54 PM, Valentin Kovalenko via
Concurrency-interest <concurrency-interest at cs.oswego.edu> wrote:

> Let's give letter names to some actions in executions of your program:
>

I tried to re-write based on your notation.


*Thread 1*
int[] array = new int[] {-1, -1, -1};  // INIT (Involves a W0, WE and WA
but is all synced by thread2.start() anyway)

thread2.start();
// This acts as the point of forking for the 2 threads.

......

array = new int[] {1, 2, 3};
//  Based on your comments, this line can be split
//
// W0:  set all elements to zeros (time zero operation)
//
// WE:  Initialize [2] element to 3
// WA:  Set array to reference the new array


*Thread 2*
System.out.println(array[2]);

INIT happens before everything, since it happens before the .start() call
of thread 2.

W0 happens before the System.out.println call, since it is default
initialization.

WE & WA have no happens before relationship with the System.out call.

This means that the System.out could see WE or WA.  If it doesn't see
either of them, then it would see the result of W(0).

This means that 3, 0 and -1 are possible.  Is this correct?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/a8ef2df6/attachment.html>

From valentin.male.kovalenko at gmail.com  Sun Aug 12 16:56:46 2018
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sun, 12 Aug 2018 14:56:46 -0600
Subject: [concurrency-interest] Visibility of array initialization (Raph
	Frank)
In-Reply-To: <CAB=Je-FvRXLhkOf6HGtx_sw6f2FGUixyQcf7Ukk8mEiUTG9PWQ@mail.gmail.com>
References: <mailman.112.1534098080.2960.concurrency-interest@cs.oswego.edu>
 <CAO-wXw+bdTTyVEa0dKaseSDALM_bjMzPcfMfuescZg0bC106kQ@mail.gmail.com>
 <CAB=Je-FvRXLhkOf6HGtx_sw6f2FGUixyQcf7Ukk8mEiUTG9PWQ@mail.gmail.com>
Message-ID: <CAO-wXwLNRooCS1M9bqwLwmOtLZ4Mu2v3c4QnhketAu6xYaD4RQ@mail.gmail.com>

Vladimir,

Yes, I have missed this part :( Thank you! This is a good reminder of how
careful one should be when thinking about which writes are there, and which
writes are allowed to be observed.

Regards,
Valentin
[image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image: GitHub]
<https://github.com/stIncMale>   [image: YouTube]
<https://www.youtube.com/user/stIncMale>


On Sun, 12 Aug 2018 at 14:36, Vladimir Sitnikov <sitnikov.vladimir at gmail.com>
wrote:

> Valentin>Having said that, the anwser to your question "Is it possible
> for the 2nd thread to print zero?  Is it guaranteed to print -1 or 2?" is:
> The second thread is allowed to print either -1 or 3 and nothing else (NPE
> is also not allowed).
>
> I would argue there.
>
> TL;DR: -1, 0, 3 are allowed. NPE is forbidden.
>
>
> 1) NPE is not allowed (since there's only one write of null to `array`
> field which is implicit write of default value).
>
> 2) 0 is also allowed since Thread 2 could see updated value of `array`
> (that is it could see the reference to the array that was set after the
> thread started).
> Apparently, there are "implicit writes of 0 values of the elements in the
> new array", and nothing prevents Thread 2 from observing those writes.
>
> I'm not a lawyer, but
> https://docs.oracle.com/javase/specs/jls/se6/html/expressions.html#15.10.1
> seems to address that:
>
> JLS6> and each component of the array is initialized to its default value
> (Â§4.12.5).
>
> In other words, new int[] {1, 2, 3}; does not mean the array is created
> "atomically".
> It is equivalent to the   x=new int[3]; x[0]=1; x[1]=2; x[2]=3;
> Obviously that can cause Thread2 to observe 0 as well.
>
>
> Vladimir
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180812/e943079f/attachment.html>

From tg at freigmbh.de  Fri Aug 24 05:10:20 2018
From: tg at freigmbh.de (Thorsten Goetzke)
Date: Fri, 24 Aug 2018 11:10:20 +0200
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
Message-ID: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>

Hello,

There are multiple Classes that let you wait or sleep for a specified 
amount of time. My current understanding is:
Thread.sleep and Object.wait can wake up earlier than specified so code 
that also uses System.currentTimeMillies can break because wakeups 
happen to early.
On the other side code that uses higher level Abstraction such as
ScheduledExecutorService or CountDownLatch.await will always at least 
wait for the specified time and it will be consistent with 
System.currentTimeMillies. Is that actually correct and guaranteed or is 
is just implementation dependent?

Best regards,
Thorsten Goetzke

From valentin.male.kovalenko at gmail.com  Fri Aug 24 13:38:42 2018
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Fri, 24 Aug 2018 11:38:42 -0600
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
In-Reply-To: <mailman.3.1535126402.20464.concurrency-interest@cs.oswego.edu>
References: <mailman.3.1535126402.20464.concurrency-interest@cs.oswego.edu>
Message-ID: <CAO-wXwL1_++8tQSaQFtUoZyyikennmncZBEumUSpVNQMtgS9OQ@mail.gmail.com>

Hi Thorsten,

Why do you think that Thread.sleep can wake up earlier than was requested?
There is no mention of this in the spec. Thread.sleep will never wake up
earlier, but besides that, you have no guarantees except "the best effort
to not exceed the specified time interval by much".

>code that also uses System.currentTimeMillies can break because wakeups
happen to early
Thread.sleed definitely can't use System.currentTimeMillies, because
currentTimeMillies
is not monotonic (it's just a system time, which can easily go backwards).
If you are trying to reliably measure an interval of time, use
System.nanoTime because it is monotonic (this method is specifically there
to provide a tool for measuring time intervals).

Regards,
Valentin
[image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image: GitHub]
<https://github.com/stIncMale>   [image: YouTube]
<https://www.youtube.com/user/stIncMale>


On Fri, 24 Aug 2018 at 10:02, <concurrency-interest-request at cs.oswego.edu>
wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Sleep time consistency compared to        System.currentTimeMillis
>       (Thorsten Goetzke)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Fri, 24 Aug 2018 11:10:20 +0200
> From: Thorsten Goetzke <tg at freigmbh.de>
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Sleep time consistency compared to
>         System.currentTimeMillis
> Message-ID: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36 at freigmbh.de>
> Content-Type: text/plain; charset=utf-8; format=flowed
>
> Hello,
>
> There are multiple Classes that let you wait or sleep for a specified
> amount of time. My current understanding is:
> Thread.sleep and Object.wait can wake up earlier than specified so code
> that also uses System.currentTimeMillies can break because wakeups
> happen to early.
> On the other side code that uses higher level Abstraction such as
> ScheduledExecutorService or CountDownLatch.await will always at least
> wait for the specified time and it will be consistent with
> System.currentTimeMillies. Is that actually correct and guaranteed or is
> is just implementation dependent?
>
> Best regards,
> Thorsten Goetzke
>
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 162, Issue 12
> *****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180824/6acb2b0e/attachment.html>

From nathanila at gmail.com  Sat Aug 25 09:37:51 2018
From: nathanila at gmail.com (Nathan and Ila Reynolds)
Date: Sat, 25 Aug 2018 07:37:51 -0600
Subject: [concurrency-interest] Sleep time consistency compared to
 System.currentTimeMillis
In-Reply-To: <CAO-wXwL1_++8tQSaQFtUoZyyikennmncZBEumUSpVNQMtgS9OQ@mail.gmail.com>
References: <mailman.3.1535126402.20464.concurrency-interest@cs.oswego.edu>
 <CAO-wXwL1_++8tQSaQFtUoZyyikennmncZBEumUSpVNQMtgS9OQ@mail.gmail.com>
Message-ID: <e3b2aa5c-786b-03fc-12a8-21b826e9fd9c@gmail.com>

I do not have an answer for you.Â  However, I do not think Java is 
completely in control.Â  I recommend you look at the source code for 
Thread.sleep() including the JVM code.Â  This will show you what system 
APIs are called.Â  You can then look at the documentation for the system 
APIs.

Here is some anecdotal information.Â  We recently started using Netdata 
to track resource usage.Â  One metric that Netdata tracks is idle 
jitter.Â  Here's the Netdata description.


Idle jitter is calculated by netdata. A thread is spawned that requests 
to sleep for a few microseconds. When the system wakes it up, it 
measures how many microseconds have passed. The difference between the 
requested and the actual duration of the sleep, is the idle jitter. This 
number is useful in real-time environments, where CPU jitter can affect 
the quality of the service (like VoIP media gateways).

I have not tuned the machine to minimize idle jitter.Â  I am seeing an 
idle jitter of up to 10 ms!Â  This suggests to me that Thread.sleep(1) 
could return up to 10 ms later.Â  For my application, I do not think this 
is a big deal.Â  I am not doing any time sensitive operations.Â  I pasted 
in the idle jitter graph.Â  I hope it makes it through the mail.

-Nathan

On 8/24/2018 11:38 AM, Valentin Kovalenko via Concurrency-interest wrote:
> Hi Thorsten,
>
> Why do you think that Thread.sleep can wake up earlier than was 
> requested? There is no mention of this in the spec. Thread.sleep will 
> never wake up earlier, but besides that, you have no guarantees except 
> "the best effort to not exceed the specified time interval by much".
>
> >code that also uses System.currentTimeMillies can break because 
> wakeups happen to early
> Thread.sleed definitely can't use System.currentTimeMillies, because 
> currentTimeMillies is not monotonicÂ (it's just a system time, which 
> can easily go backwards). If you are trying to reliably measure an 
> interval of time, use System.nanoTime because it is monotonic (this 
> method is specifically there to provide a tool for measuring time 
> intervals).
>
> Regards,
> Valentin
> LinkedIn <https://www.linkedin.com/in/stIncMale>GitHub 
> <https://github.com/stIncMale>YouTube 
> <https://www.youtube.com/user/stIncMale>
>
>
> On Fri, 24 Aug 2018 at 10:02, 
> <concurrency-interest-request at cs.oswego.edu 
> <mailto:concurrency-interest-request at cs.oswego.edu>> wrote:
>
>     Send Concurrency-interest mailing list submissions to
>     concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>
>     To subscribe or unsubscribe via the World Wide Web, visit
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     or, via email, send a message with subject or body 'help' to
>     concurrency-interest-request at cs.oswego.edu
>     <mailto:concurrency-interest-request at cs.oswego.edu>
>
>     You can reach the person managing the list at
>     concurrency-interest-owner at cs.oswego.edu
>     <mailto:concurrency-interest-owner at cs.oswego.edu>
>
>     When replying, please edit your Subject line so it is more specific
>     than "Re: Contents of Concurrency-interest digest..."
>
>
>     Today's Topics:
>
>     Â  Â 1. Sleep time consistency compared to System.currentTimeMillis
>     Â  Â  Â  (Thorsten Goetzke)
>
>
>     ----------------------------------------------------------------------
>
>     Message: 1
>     Date: Fri, 24 Aug 2018 11:10:20 +0200
>     From: Thorsten Goetzke <tg at freigmbh.de <mailto:tg at freigmbh.de>>
>     To: concurrency-interest at cs.oswego.edu
>     <mailto:concurrency-interest at cs.oswego.edu>
>     Subject: [concurrency-interest] Sleep time consistency compared to
>     Â  Â  Â  Â  System.currentTimeMillis
>     Message-ID: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36 at freigmbh.de
>     <mailto:ffbde00d-268c-7ff5-ab1a-cd2499cadd36 at freigmbh.de>>
>     Content-Type: text/plain; charset=utf-8; format=flowed
>
>     Hello,
>
>     There are multiple Classes that let you wait or sleep for a specified
>     amount of time. My current understanding is:
>     Thread.sleep and Object.wait can wake up earlier than specified so
>     code
>     that also uses System.currentTimeMillies can break because wakeups
>     happen to early.
>     On the other side code that uses higher level Abstraction such as
>     ScheduledExecutorService or CountDownLatch.await will always at least
>     wait for the specified time and it will be consistent with
>     System.currentTimeMillies. Is that actually correct and guaranteed
>     or is
>     is just implementation dependent?
>
>     Best regards,
>     Thorsten Goetzke
>
>
>     ------------------------------
>
>     Subject: Digest Footer
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>     ------------------------------
>
>     End of Concurrency-interest Digest, Vol 162, Issue 12
>     *****************************************************
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180825/b31619ee/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: halphagbncmpejej.png
Type: image/png
Size: 78826 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180825/b31619ee/attachment-0001.png>

From dl at cs.oswego.edu  Sat Aug 25 09:57:46 2018
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 25 Aug 2018 09:57:46 -0400
Subject: [concurrency-interest] Sleep time consistency compared to
 System.currentTimeMillis
In-Reply-To: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
Message-ID: <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>

On 08/24/2018 05:10 AM, Thorsten Goetzke via Concurrency-interest wrote:
> Hello,
> 
> There are multiple Classes that let you wait or sleep for a specified
> amount of time. My current understanding is:
> Thread.sleep and Object.wait can wake up earlier than specified so code
> that also uses System.currentTimeMillies can break because wakeups
> happen to early.

Yes, and the JDK API specs for these methods include disclaimers,
including: "The specified amount of real time has elapsed, more or less."

> On the other side code that uses higher level Abstraction such as
> ScheduledExecutorService or CountDownLatch.await will always at least
> wait for the specified time and it will be consistent with
> System.currentTimeMillies. Is that actually correct and guaranteed


Yes, java.util.concurrent time-based API specs do not include any such
disclaimers, so you will never get a too-short wait. Delays may be
arbitrarily longer than you'd like though. Imagine millions of threads
waiting for a millisecond. Not all of them will start running after a
millisecond.

-Doug

From valentin.male.kovalenko at gmail.com  Sun Aug 26 14:25:44 2018
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sun, 26 Aug 2018 12:25:44 -0600
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
In-Reply-To: <mailman.3.1535212824.13547.concurrency-interest@cs.oswego.edu>
References: <mailman.3.1535212824.13547.concurrency-interest@cs.oswego.edu>
Message-ID: <CAO-wXw+xwUCREq5E=U4J80qOd3MCWrTJFGYfwL7ts4vz_=u3yA@mail.gmail.com>

As Carl Mastrangelo <notcarl at google.com> pointed out (he accidentally
replied not to the whole group, but just me):
Thread.join uses System.currentTimeMillis (see
http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/Thread.java#l1294
).

Apparently, there is a corresponding bug report:
https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8098798
But since the priority is P4, I am assuming it will hardly be fixed in the
observable future.

There is also a bug report about the wording "Waits at most millis
milliseconds for this thread to die" in the Thread.join docs:
https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4132653
Unfortunately, this one was rejected with the phrase "Changing the
specification is no longer possible to the extent proposed" (I am not sure
what this is supposed to mean).

Regards,
Valentin
[image: LinkedIn] <https://www.linkedin.com/in/stIncMale>   [image: GitHub]
<https://github.com/stIncMale>   [image: YouTube]
<https://www.youtube.com/user/stIncMale>


On Sat, 25 Aug 2018 at 10:01, <concurrency-interest-request at cs.oswego.edu>
wrote:

> Send Concurrency-interest mailing list submissions to
>         concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
>         concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
>         concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
>    1. Re: Sleep time consistency compared to
>       System.currentTimeMillis (Doug Lea)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sat, 25 Aug 2018 09:57:46 -0400
> From: Doug Lea <dl at cs.oswego.edu>
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Sleep time consistency compared to
>         System.currentTimeMillis
> Message-ID: <0593feb8-924f-9e99-dc0e-a31ced2370a0 at cs.oswego.edu>
> Content-Type: text/plain; charset=utf-8
>
> On 08/24/2018 05:10 AM, Thorsten Goetzke via Concurrency-interest wrote:
> > Hello,
> >
> > There are multiple Classes that let you wait or sleep for a specified
> > amount of time. My current understanding is:
> > Thread.sleep and Object.wait can wake up earlier than specified so code
> > that also uses System.currentTimeMillies can break because wakeups
> > happen to early.
>
> Yes, and the JDK API specs for these methods include disclaimers,
> including: "The specified amount of real time has elapsed, more or less."
>
> > On the other side code that uses higher level Abstraction such as
> > ScheduledExecutorService or CountDownLatch.await will always at least
> > wait for the specified time and it will be consistent with
> > System.currentTimeMillies. Is that actually correct and guaranteed
>
>
> Yes, java.util.concurrent time-based API specs do not include any such
> disclaimers, so you will never get a too-short wait. Delays may be
> arbitrarily longer than you'd like though. Imagine millions of threads
> waiting for a millisecond. Not all of them will start running after a
> millisecond.
>
> -Doug
>
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------
>
> End of Concurrency-interest Digest, Vol 162, Issue 14
> *****************************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180826/57a6d459/attachment.html>

From davidcholmes at aapt.net.au  Sun Aug 26 17:40:02 2018
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 27 Aug 2018 07:40:02 +1000
Subject: [concurrency-interest] Sleep time consistency compared
	to	System.currentTimeMillis
In-Reply-To: <CAO-wXw+xwUCREq5E=U4J80qOd3MCWrTJFGYfwL7ts4vz_=u3yA@mail.gmail.com>
References: <mailman.3.1535212824.13547.concurrency-interest@cs.oswego.edu>
 <CAO-wXw+xwUCREq5E=U4J80qOd3MCWrTJFGYfwL7ts4vz_=u3yA@mail.gmail.com>
Message-ID: <031c01d43d85$59139fb0$0b3adf10$@aapt.net.au>

Hi Valentin,

 

It seems 8098798 slipped past the notice of those of us who have a keen interest in such matters. It should be fixed and Iâve already updated the bug.

 

4132653 is a non-issue. It was closed simply because it was 20 years old (I agree the chosen text is a little strange ð ). The suggestion in the bug report is not right (no blocking time should ever be interpreted as meaning a time when the thread actually gets a CPU again â it only affects eligibility to get a CPU) and we donât always wait âat leastâ the timeout because the thread may die sooner. The intent is quite clear that join(ms) while wait for up to ms milliseconds for the thread to die.

 

Cheers,

David

 

From: Concurrency-interest <concurrency-interest-bounces at cs.oswego.edu> On Behalf Of Valentin Kovalenko via Concurrency-interest
Sent: Monday, August 27, 2018 4:26 AM
To: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Sleep time consistency compared to System.currentTimeMillis

 

As Carl Mastrangelo <notcarl at google.com <mailto:notcarl at google.com> > pointed out (he accidentally replied not to the whole group, but just me):

Thread.join uses System.currentTimeMillis (see http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/Thread.java#l1294).

 

Apparently, there is a corresponding bug report: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8098798

But since the priority is P4, I am assuming it will hardly be fixed in the observable future.

 

There is also a bug report about the wording "Waits at most millis milliseconds for this thread to die" in the Thread.join docs: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4132653

Unfortunately, this one was rejected with the phrase "Changing the specification is no longer possible to the extent proposed" (I am not sure what this is supposed to mean).




Regards,

Valentin

 <https://www.linkedin.com/in/stIncMale>     <https://github.com/stIncMale>     <https://www.youtube.com/user/stIncMale> 

 

On Sat, 25 Aug 2018 at 10:01, <concurrency-interest-request at cs.oswego.edu <mailto:concurrency-interest-request at cs.oswego.edu> > wrote:

Send Concurrency-interest mailing list submissions to
        concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 

To subscribe or unsubscribe via the World Wide Web, visit
        http://cs.oswego.edu/mailman/listinfo/concurrency-interest
or, via email, send a message with subject or body 'help' to
        concurrency-interest-request at cs.oswego.edu <mailto:concurrency-interest-request at cs.oswego.edu> 

You can reach the person managing the list at
        concurrency-interest-owner at cs.oswego.edu <mailto:concurrency-interest-owner at cs.oswego.edu> 

When replying, please edit your Subject line so it is more specific
than "Re: Contents of Concurrency-interest digest..."


Today's Topics:

   1. Re: Sleep time consistency compared to
      System.currentTimeMillis (Doug Lea)


----------------------------------------------------------------------

Message: 1
Date: Sat, 25 Aug 2018 09:57:46 -0400
From: Doug Lea <dl at cs.oswego.edu <mailto:dl at cs.oswego.edu> >
To: concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> 
Subject: Re: [concurrency-interest] Sleep time consistency compared to
        System.currentTimeMillis
Message-ID: <0593feb8-924f-9e99-dc0e-a31ced2370a0 at cs.oswego.edu <mailto:0593feb8-924f-9e99-dc0e-a31ced2370a0 at cs.oswego.edu> >
Content-Type: text/plain; charset=utf-8

On 08/24/2018 05:10 AM, Thorsten Goetzke via Concurrency-interest wrote:
> Hello,
> 
> There are multiple Classes that let you wait or sleep for a specified
> amount of time. My current understanding is:
> Thread.sleep and Object.wait can wake up earlier than specified so code
> that also uses System.currentTimeMillies can break because wakeups
> happen to early.

Yes, and the JDK API specs for these methods include disclaimers,
including: "The specified amount of real time has elapsed, more or less."

> On the other side code that uses higher level Abstraction such as
> ScheduledExecutorService or CountDownLatch.await will always at least
> wait for the specified time and it will be consistent with
> System.currentTimeMillies. Is that actually correct and guaranteed


Yes, java.util.concurrent time-based API specs do not include any such
disclaimers, so you will never get a too-short wait. Delays may be
arbitrarily longer than you'd like though. Imagine millions of threads
waiting for a millisecond. Not all of them will start running after a
millisecond.

-Doug


------------------------------

Subject: Digest Footer

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


------------------------------

End of Concurrency-interest Digest, Vol 162, Issue 14
*****************************************************

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180827/6d359cdd/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ~WRD000.jpg
Type: image/jpeg
Size: 823 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180827/6d359cdd/attachment-0001.jpg>

From tg at freigmbh.de  Mon Aug 27 04:30:27 2018
From: tg at freigmbh.de (Thorsten Goetzke)
Date: Mon, 27 Aug 2018 10:30:27 +0200
Subject: [concurrency-interest] Sleep time consistency compared to
 System.currentTimeMillis
In-Reply-To: <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
 <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
Message-ID: <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>

> On 08/24/2018 05:10 AM, Thorsten Goetzke via Concurrency-interest wrote:
>> Hello,
>>
>> There are multiple Classes that let you wait or sleep for a specified
>> amount of time. My current understanding is:
>> Thread.sleep and Object.wait can wake up earlier than specified so code
>> that also uses System.currentTimeMillies can break because wakeups
>> happen to early.
> 
> Yes, and the JDK API specs for these methods include disclaimers,
> including: "The specified amount of real time has elapsed, more or less."
> 

I think in case of Thread.sleep the javadoc should be clarified so it 
explicitly contains the word "less".
It just says "subject to the precision and accuracy of system timers and 
schedulers" which can be missunderstood as "at least sleep time + the 
jvm does it's best to reduce additional sleep time but it obviosly cant 
magically make the undlerying system more precise".

https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.html#sleep(long)



From heinz at javaspecialists.eu  Mon Aug 27 05:05:36 2018
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Mon, 27 Aug 2018 12:05:36 +0300
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
In-Reply-To: <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
 <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
 <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>
Message-ID: <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>

IMHO if your code breaks because Thread.sleep woke up too early or too
late, your code was incorrect to start with.  Same with wait(), which can
be subject to spurious wakeups apparently.  But even if that happens,
correct code would still work :-)

My thumb rule with wait() is to always write it in such a way that it would
also work with notifyAll(), whether you use that or notify().  If you do,
it will still work with spurious wake ups or lost races for the lock.

For time sensitive waiting, I prefer Condition.awaitMillis().

It is of course neither precise nor real-time.

Heinz

On Mon, 27 Aug 2018 at 11:38, Thorsten Goetzke via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> > On 08/24/2018 05:10 AM, Thorsten Goetzke via Concurrency-interest wrote:
> >> Hello,
> >>
> >> There are multiple Classes that let you wait or sleep for a specified
> >> amount of time. My current understanding is:
> >> Thread.sleep and Object.wait can wake up earlier than specified so code
> >> that also uses System.currentTimeMillies can break because wakeups
> >> happen to early.
> >
> > Yes, and the JDK API specs for these methods include disclaimers,
> > including: "The specified amount of real time has elapsed, more or less."
> >
>
> I think in case of Thread.sleep the javadoc should be clarified so it
> explicitly contains the word "less".
> It just says "subject to the precision and accuracy of system timers and
> schedulers" which can be missunderstood as "at least sleep time + the
> jvm does it's best to reduce additional sleep time but it obviosly cant
> magically make the undlerying system more precise".
>
>
> https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.html#sleep(long)
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion
JavaOne Rockstar Speaker
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180827/7aabd0e6/attachment.html>

From tg at freigmbh.de  Mon Aug 27 05:23:53 2018
From: tg at freigmbh.de (Thorsten Goetzke)
Date: Mon, 27 Aug 2018 11:23:53 +0200
Subject: [concurrency-interest] Sleep time consistency compared to
 System.currentTimeMillis
In-Reply-To: <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
 <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
 <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>
 <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>
Message-ID: <742d2903-1653-367f-b250-42677385cc99@freigmbh.de>

> IMHO if your code breaks because Thread.sleep woke up too early or too 
> late, your code was incorrect to start with.Â  Same with wait(), which 
> can be subject to spurious wakeups apparently.

Well it's not productive code, the situation is: We want to  simulate 
code, (for testing purpose) that does't return for 123 (or whatever) 
millisecends or more (for example to simulate a query-timeout). It just 
a bit sad that the most simple, straightforward approach sleep(123) 
breaks on some machines because it doesn't actually sleeps as long as 
needed. It's easily fixable when you know what's going on, but you have 
to be aware.


From martinrb at google.com  Mon Aug 27 10:03:49 2018
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 27 Aug 2018 07:03:49 -0700
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
In-Reply-To: <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
 <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
 <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>
 <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>
Message-ID: <CA+kOe0-1CLPK9bYfbSGvw3VzgZ6m1NzD2v5yGP9rY9oWnOzYQg@mail.gmail.com>

Thread.jjoin(long) should be fixed to use nanoTime instead of
currentTimeMillis.

Thread.wait's spec should be fixed to remove the "more or less" (although
spurious wakeup remains possible).

Thread.sleep should be fixed to not wake up early due to rounding of nanos
(as Object.wait was fixed).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180827/6a1d5aca/attachment.html>

From notcarl at google.com  Mon Aug 27 13:23:45 2018
From: notcarl at google.com (Carl Mastrangelo)
Date: Mon, 27 Aug 2018 10:23:45 -0700
Subject: [concurrency-interest] Sleep time consistency compared to
	System.currentTimeMillis
In-Reply-To: <CA+kOe0-1CLPK9bYfbSGvw3VzgZ6m1NzD2v5yGP9rY9oWnOzYQg@mail.gmail.com>
References: <ffbde00d-268c-7ff5-ab1a-cd2499cadd36@freigmbh.de>
 <0593feb8-924f-9e99-dc0e-a31ced2370a0@cs.oswego.edu>
 <b1e44afb-59a2-5fc1-181c-b13b08c03021@freigmbh.de>
 <CACLL95oU9=dfQ2isB14u8r9EuC7ug0qjxJEJVE9rSa4Ad4D_KQ@mail.gmail.com>
 <CA+kOe0-1CLPK9bYfbSGvw3VzgZ6m1NzD2v5yGP9rY9oWnOzYQg@mail.gmail.com>
Message-ID: <CAAcqB+tyMpCsAsNYAhtz=kdMj4Nymc==d4hyP5k44WSgp5vaag@mail.gmail.com>

That's good to hear it was a bug.  I had asked about in on Stack Overflow*
a while ago, and no one seemed to recognize it should be fixed.


*
https://stackoverflow.com/questions/42544387/why-does-thread-join-use-currenttimemillis


On Mon, Aug 27, 2018 at 7:06 AM Martin Buchholz via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Thread.jjoin(long) should be fixed to use nanoTime instead of
> currentTimeMillis.
>
> Thread.wait's spec should be fixed to remove the "more or less" (although
> spurious wakeup remains possible).
>
> Thread.sleep should be fixed to not wake up early due to rounding of nanos
> (as Object.wait was fixed).
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20180827/a042c5fe/attachment.html>

