From viktor.klang at gmail.com  Sat Jul  2 18:48:14 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Sun, 3 Jul 2011 00:48:14 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
Message-ID: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>

Ladies(?) and Gentlemen,

I recently (yesterday) attempted to create an Akka Actor Dispatcher using
the Scala embedded version of the ForkJoin library, just wanted to verify
that I'm doing the Right Thing?

Here's a link to the code:
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala

The design:

Since I'm just forking and never doing any joining, I've done
"setAsyncMode(true)" on the ForkJoinPool.
Each Actors mailbox is a Runnable, and to avoid extra allocations I'm
weaving in FJMailbox that wraps the mailbox as a ForkJoinTask so I can reuse
it.

The mailbox is only available in the pool in a binary fashion (it's added to
the pool when a message is added, if messages are added and it's already in
the pool it just adds the message to the mailbox,  and it's removed from the
pool when the processing is completed).

If a mailbox is added to the pool, and it's done so by a
ForkJoinWorkerThread, I use ForkJoinTask.fork(), and if not, I simply add it
to the pool. (I always reinitialize it before doing so), here's the code for
that:
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L73

At the end of processing a mailbox, it will, if it's done by a
ForkJoinWorkerThread, it will call helpQuiesce() to make sure that things
are getting processed. (It wasn't working until I found out I needed to call
helpQuiesce)

Am I on the right track here?

Cheers,
?


-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110703/d3e78102/attachment.html>

From dmitry.miltsov at oracle.com  Sun Jul  3 12:03:43 2011
From: dmitry.miltsov at oracle.com (dmitry.miltsov at oracle.com)
Date: Sun, 3 Jul 2011 09:03:43 -0700 (PDT)
Subject: [concurrency-interest] Auto Reply: Concurrency-interest Digest,
	Vol 78, Issue 1
Message-ID: <4204d18a-6da2-421a-881a-75cbc9c28a9e@default>

This is an auto-replied message.
I'm on vacation from July 1, returning to the office on July 11.

My backup persons are:
java.lang - Victor Rudometov;
java.security, javax.security - Paul Rank;
java.text, java.util - Yuri Gaevsky.

Please contact my manager Pavel Klodin regarding other issues. 

Thanks,
Dmitry Miltsov


From vgrazi at gmail.com  Mon Jul  4 11:32:17 2011
From: vgrazi at gmail.com (Victor Grazi)
Date: Mon, 4 Jul 2011 11:32:17 -0400
Subject: [concurrency-interest] JSR166Y for Java SE 5
Message-ID: <CA+y1Pu_jCcRXM9PLFL_fhUpbaJ9C4PcWoavaXZ1OHq_yoC-Oog@mail.gmail.com>

Does anyone know if there is a version of JSR166Y for Java 5?
I would like to keep Java Concurrent
Animated<https://sourceforge.net/projects/javaconcurrenta/> compatible
with Java 5 but in order to illustrate Fork and Join I need JSR 166Y which I
am only finding built using Java 6
Any advice?
Thanks, Victor
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110704/16e5fa1d/attachment.html>

From dl at cs.oswego.edu  Mon Jul  4 11:53:45 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 04 Jul 2011 11:53:45 -0400
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
Message-ID: <4E11E209.9060907@cs.oswego.edu>

On 07/02/11 18:48, ?iktor ?lang wrote:
> I recently (yesterday) attempted to create an Akka Actor Dispatcher using the
> Scala embedded version of the ForkJoin library,

First off, you should probably target/use/test with the
current versions, either in jdk7 (snapshots but apparently
to be released soon) or the jsr166y equivalents. Hopefully
the Scala releases will adjust to do this soon rather than
carrying around outdated ones.

>
> Here's a link to the code:
> https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala
>
> The design:
>
> Since I'm just forking and never doing any joining, I've done
> "setAsyncMode(true)" on the ForkJoinPool.

This is probably the right approach for messaging, since it
processes tasks in per-thread-FIFO order. Beware that there
is much less builtin support for this mode than normal
recursive-task-based mode.

> Each Actors mailbox is a Runnable, and to avoid extra allocations I'm weaving in
> FJMailbox that wraps the mailbox as a ForkJoinTask so I can reuse it.
>
> If a mailbox is added to the pool, and it's done so by a ForkJoinWorkerThread, I
> use ForkJoinTask.fork(), and if not, I simply add it to the pool. (I always
> reinitialize it before doing so),

Make sure you don't reinitialize if the task was ever cancelled
or completed with an exception, since in those cases other threads
may not see completion before the reset.


> here's the code for that:
> https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L73
>

In current ForkJoinPool, the submit/execute methods already automate
the internal-fork vs external-submission decision so you can/should skip
this.

> At the end of processing a mailbox, it will, if it's done by a
> ForkJoinWorkerThread, it will call helpQuiesce() to make sure that things are
> getting processed.

Yes, helpQuiesce is possible here. There are also the protected
methods pollNextLocalTask and related support for locally
processing tasks. If tasks are never joined, then the pool
mechanics don't otherwise help ensure timely completion.

-Doug



From dl at cs.oswego.edu  Mon Jul  4 12:00:15 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 04 Jul 2011 12:00:15 -0400
Subject: [concurrency-interest] JSR166Y for Java SE 5
In-Reply-To: <CA+y1Pu_jCcRXM9PLFL_fhUpbaJ9C4PcWoavaXZ1OHq_yoC-Oog@mail.gmail.com>
References: <CA+y1Pu_jCcRXM9PLFL_fhUpbaJ9C4PcWoavaXZ1OHq_yoC-Oog@mail.gmail.com>
Message-ID: <4E11E38F.4020703@cs.oswego.edu>

On 07/04/11 11:32, Victor Grazi wrote:
> Does anyone know if there is a version of JSR166Y for Java 5?

The main Java5 incompatibility is reliance on some new intrinsics
that were added in Java6. It is possible to work around these
(mainly by using putVolatileX instead of putOrderedX), with
a fair amount of performance loss. I know people have done this
(including in some of the embedded Scala versions mentioned in
my last mail), but don't know of general availability. (Plus I
don't want to go on record as doing anything that would
encourage anyone not upgrade from Java5!)

-Doug


From szegedia at gmail.com  Mon Jul  4 12:33:00 2011
From: szegedia at gmail.com (Attila Szegedi)
Date: Mon, 4 Jul 2011 09:33:00 -0700
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
Message-ID: <D322E64C-BDBA-4B03-B44A-3D7FDC0A0985@gmail.com>

Out of curiosity, since you're just forking and never joining, what is the benefit of using the forkjoin classes instead of a plain thread pool executor with a queue? Do you get some additional efficiency benefits from work stealing behavior?

Attila.

On Jul 2, 2011, at 3:48 PM, ?iktor ?lang wrote:

> Ladies(?) and Gentlemen,
> 
> I recently (yesterday) attempted to create an Akka Actor Dispatcher using the Scala embedded version of the ForkJoin library, just wanted to verify that I'm doing the Right Thing?
> 
> Here's a link to the code: https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala
> 
> The design:
> 
> Since I'm just forking and never doing any joining, I've done "setAsyncMode(true)" on the ForkJoinPool.
> Each Actors mailbox is a Runnable, and to avoid extra allocations I'm weaving in FJMailbox that wraps the mailbox as a ForkJoinTask so I can reuse it.
> 
> The mailbox is only available in the pool in a binary fashion (it's added to the pool when a message is added, if messages are added and it's already in the pool it just adds the message to the mailbox,  and it's removed from the pool when the processing is completed).
> 
> If a mailbox is added to the pool, and it's done so by a ForkJoinWorkerThread, I use ForkJoinTask.fork(), and if not, I simply add it to the pool. (I always reinitialize it before doing so), here's the code for that: https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L73
> 
> At the end of processing a mailbox, it will, if it's done by a ForkJoinWorkerThread, it will call helpQuiesce() to make sure that things are getting processed. (It wasn't working until I found out I needed to call helpQuiesce)
> 
> Am I on the right track here?
> 
> Cheers,
> ?
> 
> 
> -- 
> Viktor Klang
> 
> Akka Tech Lead
> Typesafe - Enterprise-Grade Scala from the Experts
> 
> Twitter: @viktorklang
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110704/1d558528/attachment.html>

From viktor.klang at gmail.com  Mon Jul  4 15:10:13 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 4 Jul 2011 21:10:13 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <4E11E209.9060907@cs.oswego.edu>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
Message-ID: <CANPzfU8oiu2dS10bMmCC6bpT5eHUepXXQf8rNwBke_pU1U+rCg@mail.gmail.com>

On Jul 4, 2011 6:00 PM, "Doug Lea" <dl at cs.oswego.edu> wrote:
>
> On 07/02/11 18:48, ?iktor ?lang wrote:
>>
>> I recently (yesterday) attempted to create an Akka Actor Dispatcher using
the
>> Scala embedded version of the ForkJoin library,
>
>
> First off, you should probably target/use/test with the
> current versions, either in jdk7 (snapshots but apparently
> to be released soon) or the jsr166y equivalents. Hopefully
> the Scala releases will adjust to do this soon rather than
> carrying around outdated ones.

Indeed, unfortunately I have a 0 external dependency restriction for this,
so hopefully it'll be updated in Scala library for 2.10

>
>
>>
>> Here's a link to the code:
>>
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala
>>
>> The design:
>>
>> Since I'm just forking and never doing any joining, I've done
>> "setAsyncMode(true)" on the ForkJoinPool.
>
>
> This is probably the right approach for messaging, since it
> processes tasks in per-thread-FIFO order. Beware that there
> is much less builtin support for this mode than normal
> recursive-task-based mode.

Yeah, I can imagine. I'm not fully clear on priorities of other workers,
they'll only steal work when quiscing?

>
>> Each Actors mailbox is a Runnable, and to avoid extra allocations I'm
weaving in
>> FJMailbox that wraps the mailbox as a ForkJoinTask so I can reuse it.
>>
>> If a mailbox is added to the pool, and it's done so by a
ForkJoinWorkerThread, I
>> use ForkJoinTask.fork(), and if not, I simply add it to the pool. (I
always
>> reinitialize it before doing so),
>
>
> Make sure you don't reinitialize if the task was ever cancelled
> or completed with an exception, since in those cases other threads
> may not see completion before the reset.

Ouch, that sounds nasty, what's the recommended work-around?

>
>
>
>> here's the code for that:
>>
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L73
>>
>
> In current ForkJoinPool, the submit/execute methods already automate
> the internal-fork vs external-submission decision so you can/should skip
> this.

Yeah, I was unsure on the behavior of the Scala Library embedded version.

Also, there can logically be several distinct dispatchers, so I need to make
sure that it's not only a FJWorkerThread, but that the current thread
belongs to the pool of the mailbox FJTask, is that done by auto?


>
>
>> At the end of processing a mailbox, it will, if it's done by a
>> ForkJoinWorkerThread, it will call helpQuiesce() to make sure that things
are
>> getting processed.
>
>
> Yes, helpQuiesce is possible here. There are also the protected
> methods pollNextLocalTask and related support for locally
> processing tasks.

Alright, but what about stealing? Because it's important that Stealing is
done so that other workers can help out

If tasks are never joined, then the pool
> mechanics don't otherwise help ensure timely completion.

Thanks for helping me sort this out,


Cheers,

?



>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110704/3549329d/attachment.html>

From vgrazi at gmail.com  Mon Jul  4 17:50:34 2011
From: vgrazi at gmail.com (Victor Grazi)
Date: Mon, 4 Jul 2011 17:50:34 -0400
Subject: [concurrency-interest] Java Concurrent Animated update
Message-ID: <CA+y1Pu_2xvHg04=P5J_rhvFvWm+uLCuZSR1QM4VBSwnMS75vFw@mail.gmail.com>

I wanted to announce that Java Concurrent
Animated<https://sourceforge.net/projects/javaconcurrenta/> now
contains some new animations.
Fork and Join and ConcurrentHashMap have been added.

Also ReentrantLock has LockInterruptibly and interrupt buttons.

Besides that are a few bug fixes an better organization.

I would appreciate any feedback, especially on the new features

Thanks, Victor Grazi
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110704/b09c8f0b/attachment.html>

From dl at cs.oswego.edu  Tue Jul  5 07:58:30 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 05 Jul 2011 07:58:30 -0400
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <D322E64C-BDBA-4B03-B44A-3D7FDC0A0985@gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<D322E64C-BDBA-4B03-B44A-3D7FDC0A0985@gmail.com>
Message-ID: <4E12FC66.9020400@cs.oswego.edu>

On 07/04/11 12:33, Attila Szegedi wrote:
> Out of curiosity, since you're just forking and never joining, what is the
> benefit of using the forkjoin classes instead of a plain thread pool executor
> with a queue? Do you get some additional efficiency benefits from work stealing
> behavior?
>

Even though the primary design point of ForkJoin was
supporting efficient data-parallel operations,
I've heard increasing reports from people that it
seems to work well for some middleware applications.
The combination of cheap "fork" operations,
bundling of control and actions within ForkJoinTask,
decentralized work-stealing, automation of (some)
starvation avoidance, and so on, together can lead to much
better throughput than ThreadPoolExecutor. But sometimes
does not, mainly because FJ tends to require more
per-core/thread CPU activity.

Since middleware applications were not our main
focus (we even tried to rule some out by for example
not allowing IOExceptions), there isn't yet very
much support for them. (And at this point, not much
good guidance about when they are worth considering.)
But we plan to add some, probably at first with
some misc utilities, including some ManagedBlocker
adaptors for performing more kinds of blocking IO/sync,
plus a form of ForkJoinTask that better tolerates
one subtask being "stuck" in IO/sync that other workers
in computation trees are unable to help with.
And probably more. Stay tuned...

-Doug






From dl at cs.oswego.edu  Tue Jul  5 08:12:53 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 05 Jul 2011 08:12:53 -0400
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <CANPzfU8oiu2dS10bMmCC6bpT5eHUepXXQf8rNwBke_pU1U+rCg@mail.gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8oiu2dS10bMmCC6bpT5eHUepXXQf8rNwBke_pU1U+rCg@mail.gmail.com>
Message-ID: <4E12FFC5.1070702@cs.oswego.edu>

On 07/04/11 15:10, ?iktor ?lang wrote:
>  > This is probably the right approach for messaging, since it
>  > processes tasks in per-thread-FIFO order. Beware that there
>  > is much less builtin support for this mode than normal
>  > recursive-task-based mode.
>
> Yeah, I can imagine. I'm not fully clear on priorities of other workers, they'll
> only steal work when quiscing?

When a task completes, the thread first tries to exec the next task
in its local queue, then tries to steal, then tries to start on
a new pool submission, then eventually (after various retry
and consensus mechanics) gives up and blocks waiting
for work.

>  > Make sure you don't reinitialize if the task was ever cancelled
>  > or completed with an exception, since in those cases other threads
>  > may not see completion before the reset.
>
> Ouch, that sounds nasty, what's the recommended work-around?


You probably want to do something like:
   if (task.isCompletedNormally())
      task.reinitialize();
   else
       task = new ...Task(...); // clone


>
> Also, there can logically be several distinct dispatchers, so I need to make
> sure that it's not only a FJWorkerThread, but that the current thread belongs to
> the pool of the mailbox FJTask, is that done by auto?

Yes.


>  > Yes, helpQuiesce is possible here. There are also the protected
>  > methods pollNextLocalTask and related support for locally
>  > processing tasks.
>
> Alright, but what about stealing?

Yes, see ForkJoinTask.pollTask(). We don't directly support polling
new submissions from ForkJoinTask, but see ForkJoinPool.pollSubmission.
We don't especially recommend using most of these for casual use though.
They are mainly meant to enable creating new abstract ForkJoinTask types
(like the ones already supplied in RecursiveAction and RecursiveTask).

-Doug




From partha.net at gmail.com  Tue Jul  5 11:57:19 2011
From: partha.net at gmail.com (Partha Pal)
Date: Tue, 5 Jul 2011 21:27:19 +0530
Subject: [concurrency-interest] Java Concurrent Animated update
In-Reply-To: <CA+y1Pu_2xvHg04=P5J_rhvFvWm+uLCuZSR1QM4VBSwnMS75vFw@mail.gmail.com>
References: <CA+y1Pu_2xvHg04=P5J_rhvFvWm+uLCuZSR1QM4VBSwnMS75vFw@mail.gmail.com>
Message-ID: <CAMpNZaUg=r2hwP_FQo5dJLz4GsHNcyxD6dPAB=uJZfo1trTrJw@mail.gmail.com>

Victor ,

I think its a pretty good work, it helped me a lot while explaining new
concurrency constructs from JDK 5 onward to people at my workplace and how
helpful it would be to adopt those, as you know seeing is believing :-).

Thanks.

On 5 July 2011 03:20, Victor Grazi <vgrazi at gmail.com> wrote:

> I wanted to announce that Java Concurrent Animated<https://sourceforge.net/projects/javaconcurrenta/> now
> contains some new animations.
> Fork and Join and ConcurrentHashMap have been added.
>
> Also ReentrantLock has LockInterruptibly and interrupt buttons.
>
> Besides that are a few bug fixes an better organization.
>
> I would appreciate any feedback, especially on the new features
>
> Thanks, Victor Grazi
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110705/c2d67e19/attachment-0001.html>

From viktor.klang at gmail.com  Tue Jul  5 13:19:08 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Tue, 5 Jul 2011 19:19:08 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <4E12FFC5.1070702@cs.oswego.edu>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8oiu2dS10bMmCC6bpT5eHUepXXQf8rNwBke_pU1U+rCg@mail.gmail.com>
	<4E12FFC5.1070702@cs.oswego.edu>
Message-ID: <CANPzfU9nmUm++U-bA2RkyRwqB5dF96DXH7XcsAcwDgQ8XhZuqA@mail.gmail.com>

On Tue, Jul 5, 2011 at 2:12 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/04/11 15:10, ?iktor ?lang wrote:
>
>>  > This is probably the right approach for messaging, since it
>>  > processes tasks in per-thread-FIFO order. Beware that there
>>  > is much less builtin support for this mode than normal
>>  > recursive-task-based mode.
>>
>> Yeah, I can imagine. I'm not fully clear on priorities of other workers,
>> they'll
>> only steal work when quiscing?
>>
>
> When a task completes, the thread first tries to exec the next task
> in its local queue, then tries to steal, then tries to start on
> a new pool submission, then eventually (after various retry
> and consensus mechanics) gives up and blocks waiting
> for work.


Alright, great, this will probably work out just fine for me. :-)


>
>
>   > Make sure you don't reinitialize if the task was ever cancelled
>>  > or completed with an exception, since in those cases other threads
>>  > may not see completion before the reset.
>>
>> Ouch, that sounds nasty, what's the recommended work-around?
>>
>
>
> You probably want to do something like:
>  if (task.isCompletedNormally())
>     task.reinitialize();
>  else
>      task = new ...Task(...); // clone


Yeah, unfortunately that means I'll have to make the fjTask in the Mailbox a
variable, or an atomic reference, which is a bit of a shame, but if that's
the way to go I'll do it.


>
>
>
>
>> Also, there can logically be several distinct dispatchers, so I need to
>> make
>> sure that it's not only a FJWorkerThread, but that the current thread
>> belongs to
>> the pool of the mailbox FJTask, is that done by auto?
>>
>
> Yes.


Great


>
>
>
>   > Yes, helpQuiesce is possible here. There are also the protected
>>  > methods pollNextLocalTask and related support for locally
>>  > processing tasks.
>>
>> Alright, but what about stealing?
>>
>
> Yes, see ForkJoinTask.pollTask(). We don't directly support polling
> new submissions from ForkJoinTask, but see ForkJoinPool.pollSubmission.
> We don't especially recommend using most of these for casual use though.
> They are mainly meant to enable creating new abstract ForkJoinTask types
> (like the ones already supplied in RecursiveAction and RecursiveTask).


It's good that it exists, but I'll try to refrain from using it unless I
really have to (i.e. I want to make sure that new submissions aren't
downprioritized compared to locals etc)

Thanks for taking your time to explain this,

Cheers,
?


>
>
> -Doug
>
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110705/fbd352e1/attachment.html>

From viktor.klang at gmail.com  Wed Jul  6 08:42:47 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 6 Jul 2011 14:42:47 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <4E12FFC5.1070702@cs.oswego.edu>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8oiu2dS10bMmCC6bpT5eHUepXXQf8rNwBke_pU1U+rCg@mail.gmail.com>
	<4E12FFC5.1070702@cs.oswego.edu>
Message-ID: <CANPzfU_j9za7SJBxJ81DKr98R8hg3e84xpeO+KJeJ_bkY6yPqw@mail.gmail.com>

On Tue, Jul 5, 2011 at 2:12 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/04/11 15:10, ?iktor ?lang wrote:
>
>>  > This is probably the right approach for messaging, since it
>>  > processes tasks in per-thread-FIFO order. Beware that there
>>  > is much less builtin support for this mode than normal
>>  > recursive-task-based mode.
>>
>> Yeah, I can imagine. I'm not fully clear on priorities of other workers,
>> they'll
>> only steal work when quiscing?
>>
>
> When a task completes, the thread first tries to exec the next task
> in its local queue, then tries to steal, then tries to start on
> a new pool submission, then eventually (after various retry
> and consensus mechanics) gives up and blocks waiting
> for work.
>
>
>   > Make sure you don't reinitialize if the task was ever cancelled
>>  > or completed with an exception, since in those cases other threads
>>  > may not see completion before the reset.
>>
>> Ouch, that sounds nasty, what's the recommended work-around?
>>
>
>
> You probably want to do something like:
>  if (task.isCompletedNormally())
>     task.reinitialize();
>  else
>      task = new ...Task(...); // clone
>
>
Is reinitialize() thread-safe?
I really need to avoid allocations since it completely hoses both latency
and throughput in a highly multithreaded scenario, so that's why I reuse the
FJTask, otherwise I could just submit the mailbox for execution, since it's
a runnable, but unfortunately that'd allocate quite a few objects for each
submission.

I think there'd be substantial value in having a layer of abstraction below
the FJPool that handles the workstealing etc, and then build the FJPool on
top of that, as I am expecting the workstealing approach and the
thread-local queues to have significantly better scalability than
ThreadPoolExecutor.

What do you think, Doug?

Cheers,
?


>
>
>
>> Also, there can logically be several distinct dispatchers, so I need to
>> make
>> sure that it's not only a FJWorkerThread, but that the current thread
>> belongs to
>> the pool of the mailbox FJTask, is that done by auto?
>>
>
> Yes.
>
>
>
>   > Yes, helpQuiesce is possible here. There are also the protected
>>  > methods pollNextLocalTask and related support for locally
>>  > processing tasks.
>>
>> Alright, but what about stealing?
>>
>
> Yes, see ForkJoinTask.pollTask(). We don't directly support polling
> new submissions from ForkJoinTask, but see ForkJoinPool.pollSubmission.
> We don't especially recommend using most of these for casual use though.
> They are mainly meant to enable creating new abstract ForkJoinTask types
> (like the ones already supplied in RecursiveAction and RecursiveTask).
>
>
> -Doug
>
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110706/e4293db2/attachment.html>

From gdenys at yahoo.com  Wed Jul  6 09:00:43 2011
From: gdenys at yahoo.com (Geert Denys)
Date: Wed, 6 Jul 2011 06:00:43 -0700 (PDT)
Subject: [concurrency-interest] JSR166Y for Java SE 5
In-Reply-To: <CA+y1Pu_jCcRXM9PLFL_fhUpbaJ9C4PcWoavaXZ1OHq_yoC-Oog@mail.gmail.com>
References: <CA+y1Pu_jCcRXM9PLFL_fhUpbaJ9C4PcWoavaXZ1OHq_yoC-Oog@mail.gmail.com>
Message-ID: <1309957243.73736.YahooMailNeo@web161204.mail.bf1.yahoo.com>

Victor,

We have maintained a jsr166y version for Java 5 over the last year (now abandoned). Adapting the jsr166y code base to Java 5 is quite straight forward and requires only small changes, in line with Doug's remarks.?

From our experiments, as long as the number of tasks is less than 10,000/s the performance impact is quite small (less than 5%).

Regards,
Geert.


________________________________
From: Victor Grazi <vgrazi at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Monday, July 4, 2011 5:32 PM
Subject: [concurrency-interest] JSR166Y for Java SE 5


Does anyone know if there is a version of JSR166Y for Java 5?
I would like to keep Java Concurrent Animated?compatible with Java 5 but in order to illustrate Fork and Join I need JSR 166Y which I am only finding built using Java 6
Any advice?
Thanks, Victor
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110706/ebcf1cec/attachment.html>

From viktor.klang at gmail.com  Wed Jul  6 11:42:15 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 6 Jul 2011 17:42:15 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <4E11E209.9060907@cs.oswego.edu>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
Message-ID: <CANPzfU8UnQaqyMDzg4tsXPzU0T6CWfSCQpV7DiU3qC-TD_Fvhw@mail.gmail.com>

On Mon, Jul 4, 2011 at 5:53 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/02/11 18:48, ?iktor ?lang wrote:
>
>> At the end of processing a mailbox, it will, if it's done by a
>> ForkJoinWorkerThread, it will call helpQuiesce() to make sure that things
>> are
>> getting processed.
>>
>
> Yes, helpQuiesce is possible here. There are also the protected
> methods pollNextLocalTask and related support for locally
> processing tasks. If tasks are never joined, then the pool
> mechanics don't otherwise help ensure timely completion.
>

Is it really OK to call helpQuiesce as a part of exec()?
Because it means the setNormalCompleted isn't called until helpQuiesce is
done, which means that there could be a race where the mailbox is scheduled
for execution by someone else before setNormalCompleted is called, which
means that reinitialize() might or might not be called on a completed task.

*scratches head*


>
> -Doug
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110706/ef26caf9/attachment-0001.html>

From dl at cs.oswego.edu  Wed Jul  6 16:02:41 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 06 Jul 2011 16:02:41 -0400
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <CANPzfU8UnQaqyMDzg4tsXPzU0T6CWfSCQpV7DiU3qC-TD_Fvhw@mail.gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8UnQaqyMDzg4tsXPzU0T6CWfSCQpV7DiU3qC-TD_Fvhw@mail.gmail.com>
Message-ID: <4E14BF61.7090904@cs.oswego.edu>

On 07/06/11 11:42, ?iktor ?lang wrote:
>
> Is it really OK to call helpQuiesce as a part of exec()?

For an example of use, see the spanning tree demo:
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/TorusSpanningTree.java?view=log

Which is probably not very close to what you are doing.
Could you send me more code context off-list so I can
make a better recommendation?

-Doug





From viktor.klang at gmail.com  Wed Jul  6 16:24:51 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 6 Jul 2011 22:24:51 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <4E14BF61.7090904@cs.oswego.edu>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8UnQaqyMDzg4tsXPzU0T6CWfSCQpV7DiU3qC-TD_Fvhw@mail.gmail.com>
	<4E14BF61.7090904@cs.oswego.edu>
Message-ID: <CANPzfU-e02_j14mAWzauehRYJUPDKYhJivQ9cDaVKiT=NTt2NA@mail.gmail.com>

On Wed, Jul 6, 2011 at 10:02 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/06/11 11:42, ?iktor ?lang wrote:
>
>>
>> Is it really OK to call helpQuiesce as a part of exec()?
>>
>
> For an example of use, see the spanning tree demo:
> http://gee.cs.oswego.edu/cgi-**bin/viewcvs.cgi/jsr166/src/**
> test/loops/TorusSpanningTree.**java?view=log<http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/TorusSpanningTree.java?view=log>
>
> Which is probably not very close to what you are doing.
> Could you send me more code context off-list so I can
> make a better recommendation?
>
>
There's not really much more context to serve, the idea is as follows:

An Actor has a Mailbox, it can contain 0.. messages
When a mailbox receives a message, if it's not already scheduled to be
executed, it will be scheduled to be executed
When a mailbox is executed, messages will be popped off the mailbox and some
behavior will be applied to the message
As a consequence of applying behavior towards a message, other messages can
be sent, to other actors and/or the actor who owns the mailbox which is
currently under execution

Each mailbox contains a ForkJoinTask representation of itself:
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L102

This is the implementation of ExecutorService.execute(Runnable):
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L72

execute is called when a mailbox should be added for execution (which means
that there is 1 or more messages in it),
if the current thread is a FJWorkerThread, and it's pool is the same pool,
we're already executing some mailbox, so we issue FJTask.fork() to submit
the mailbox to the currently executing thread.

The problem is that I need to use helpQuiesce() otherwise it won't execute
the locally submitted mailboxes, but the only place I found to place
helpQuiesce() was in the fjTask of the mailbox, just after the mailbox is
done processing, but before "exec()" returns true, which means that the
current mailbox fjTask isn't really completed before helpQuiesce() is
called, which means that there can be a stack explosion since it starts to
treat other mailboxes, and calls helpQuiesce() before their exec() is
finished, and so the loop of badness starts.

So I guess what I'd like is for the FJWorkerThread to continue to process
it's own locally submitted tasks after it's done with the current one, and
I'd like for other FJWorkerThreads in the same pool to start stealing to
help the FJWorkerThread out.

Makes any sense?

Cheers,
?


>
> -Doug
>
>
>
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110706/a15b3d5a/attachment.html>

From viktor.klang at gmail.com  Wed Jul  6 17:16:15 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Wed, 6 Jul 2011 23:16:15 +0200
Subject: [concurrency-interest] ForkJoin and Akka Actors
In-Reply-To: <CANPzfU-e02_j14mAWzauehRYJUPDKYhJivQ9cDaVKiT=NTt2NA@mail.gmail.com>
References: <CANPzfU9uYLkYrmG3O-3GNrbogoWkCh0TUKUjocBw=rQvpOZAyg@mail.gmail.com>
	<4E11E209.9060907@cs.oswego.edu>
	<CANPzfU8UnQaqyMDzg4tsXPzU0T6CWfSCQpV7DiU3qC-TD_Fvhw@mail.gmail.com>
	<4E14BF61.7090904@cs.oswego.edu>
	<CANPzfU-e02_j14mAWzauehRYJUPDKYhJivQ9cDaVKiT=NTt2NA@mail.gmail.com>
Message-ID: <CANPzfU9w_NYaoxvKgrFq8gmg3Eh5dOA8+L9pzX_vBEwQceCtqw@mail.gmail.com>

So to summarize, I am trying to work around the Single Point Of Bottleneck
that is the BlockingQueue of ThreadPoolExecutor, by the local submissions
and workstealing.
On Jul 6, 2011 10:24 PM, "?iktor ?lang" <viktor.klang at gmail.com> wrote:
> On Wed, Jul 6, 2011 at 10:02 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 07/06/11 11:42, ?iktor ?lang wrote:
>>
>>>
>>> Is it really OK to call helpQuiesce as a part of exec()?
>>>
>>
>> For an example of use, see the spanning tree demo:
>> http://gee.cs.oswego.edu/cgi-**bin/viewcvs.cgi/jsr166/src/**
>> test/loops/TorusSpanningTree.**java?view=log<
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/loops/TorusSpanningTree.java?view=log
>
>>
>> Which is probably not very close to what you are doing.
>> Could you send me more code context off-list so I can
>> make a better recommendation?
>>
>>
> There's not really much more context to serve, the idea is as follows:
>
> An Actor has a Mailbox, it can contain 0.. messages
> When a mailbox receives a message, if it's not already scheduled to be
> executed, it will be scheduled to be executed
> When a mailbox is executed, messages will be popped off the mailbox and
some
> behavior will be applied to the message
> As a consequence of applying behavior towards a message, other messages
can
> be sent, to other actors and/or the actor who owns the mailbox which is
> currently under execution
>
> Each mailbox contains a ForkJoinTask representation of itself:
>
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L102
>
> This is the implementation of ExecutorService.execute(Runnable):
>
https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/dispatch/FJDispatcher.scala#L72
>
> execute is called when a mailbox should be added for execution (which
means
> that there is 1 or more messages in it),
> if the current thread is a FJWorkerThread, and it's pool is the same pool,
> we're already executing some mailbox, so we issue FJTask.fork() to submit
> the mailbox to the currently executing thread.
>
> The problem is that I need to use helpQuiesce() otherwise it won't execute
> the locally submitted mailboxes, but the only place I found to place
> helpQuiesce() was in the fjTask of the mailbox, just after the mailbox is
> done processing, but before "exec()" returns true, which means that the
> current mailbox fjTask isn't really completed before helpQuiesce() is
> called, which means that there can be a stack explosion since it starts to
> treat other mailboxes, and calls helpQuiesce() before their exec() is
> finished, and so the loop of badness starts.
>
> So I guess what I'd like is for the FJWorkerThread to continue to process
> it's own locally submitted tasks after it's done with the current one, and
> I'd like for other FJWorkerThreads in the same pool to start stealing to
> help the FJWorkerThread out.
>
> Makes any sense?
>
> Cheers,
> ?
>
>
>>
>> -Doug
>>
>>
>>
>>
>> ______________________________**_________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<
http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>
>
>
>
> --
> Viktor Klang
>
> Akka Tech Lead
> Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
> Experts
>
> Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110706/a1ecd9de/attachment.html>

From vgrazi at gmail.com  Fri Jul  8 00:18:06 2011
From: vgrazi at gmail.com (Victor Grazi)
Date: Fri, 8 Jul 2011 00:18:06 -0400
Subject: [concurrency-interest] # of threads in fork join
Message-ID: <CA+y1Pu-8BJ3HgBik-Dd1BiA8Vv4hBQt8JogdKxDk-Dm41oUhNw@mail.gmail.com>

Someone asked me why - in Java Concurrent Animated fork and join - when you
allocate 3 threads we see a 4th thread being introduced. (The particular
threads are color coded so if you see a yellow thread working here and then
a yellow working somewhere else they are the same thread. )

I believe this is not a bug in the animation. It appears that the F&J
framework itself from time to time replaces one or more threads. Also for a
very brief period there are 4 active threads at the same time.

When I try the same experiment starting with 4 threads it (correctly) only
allocates a maximum of 4 threads.

Any idea why this happens?
(I am on a new Macbook pro)
Thanks Victor
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110708/53a5d723/attachment.html>

From davidcholmes at aapt.net.au  Fri Jul  8 00:23:46 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 8 Jul 2011 14:23:46 +1000
Subject: [concurrency-interest] # of threads in fork join
In-Reply-To: <CA+y1Pu-8BJ3HgBik-Dd1BiA8Vv4hBQt8JogdKxDk-Dm41oUhNw@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEGCIOAA.davidcholmes@aapt.net.au>

The number of threads you specify is not a hard limit. The framework will
create additional threads to maintain the desired concurrency level if it
deems it necessary. I can't say under what conditions it would deem it
necessary for any given application.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Victor Grazi
  Sent: Friday, 8 July 2011 2:18 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] # of threads in fork join


  Someone asked me why - in Java Concurrent Animated fork and join - when
you allocate 3 threads we see a 4th thread being introduced. (The particular
threads are color coded so if you see a yellow thread working here and then
a yellow working somewhere else they are the same thread. )

  I believe this is not a bug in the animation. It appears that the F&J
framework itself from time to time replaces one or more threads. Also for a
very brief period there are 4 active threads at the same time.

  When I try the same experiment starting with 4 threads it (correctly) only
allocates a maximum of 4 threads.

  Any idea why this happens?
  (I am on a new Macbook pro)
  Thanks Victor
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110708/868384d7/attachment.html>

From cpovirk at google.com  Thu Jul 14 19:27:07 2011
From: cpovirk at google.com (Chris Povirk)
Date: Thu, 14 Jul 2011 16:27:07 -0700
Subject: [concurrency-interest] Future.get exception mapping
Message-ID: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>

In the spirit of my earlier thread on InterruptedException-free wrappers for
interruptible methods <http://markmail.org/message/bvh2yt3frtwpt45a>
(digression:
I'm now convinced that they shouldn't be used as widely as I thought, so
thanks), I'm trying to simplify exception management in some common uses of
concurrency utilities.  Right now, I'm looking at Future.get, which requires
separate handling of at least two exception types -- as well it should for
maximum generality, but that isn't much consolation for people who just want
to know "Did it work or not?"  In my experience, in a typical webapp, I
would often by happier with code like this:

public Result getResult() throws MyException {
  return Futures.get(future,
MyException.class)<http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/util/concurrent/Futures.html#get%28java.util.concurrent.Future,%20java.lang.Class%29>
;
}

So, we're trying out such a method in Guava.  To quote from the Javadoc
(though I'd recommend following the link above for the whole thing):

Exceptions from Future.get are treated as follows:

   - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true>
is
   wrapped in an X (after restoring the interrupt).
   - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true>
is
   propagated untouched.
   - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true>
has
   its *cause* wrapped in an X.
   - Any RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true>
other
   than CancellationException (get implementations are discouraged from
   throwing such exceptions) is wrapped in an X.

In broad strokes, I'm happy with this.  But I can imagine some tweaks around
the edges:

   - Is there any reason to wrap a raw RuntimeException thrown by get?
    Probably it comes from the calling thread, so we don't need to wrap it to
   give a proper stack trace.  Meanwhile, we're converting an unchecked
   exception to a checked exception unnecessarily.  Then again, is there any
   great harm, since the type we're converting to is a type that the caller
   already must handle?  Still, we're converting between unchecked exceptions
   ("the programmer's fault") and checked exceptions ("not the programmer's
   fault").  Future.get already does this by wrapping any unchecked
   exception from the task itself in a checked ExecutionException, but
   should we follow that example if it's bad?
   - The previous point, though, addresses only a small issue: a raw
   RuntimeException thrown by get, which shouldn't even occur.  More
   interesting is the question of what to do if an ExecutionException wraps
   an unchecked cause.  Why wrap that cause in a checked exception when we
   could wrap it in an unchecked exception?  As it turns out, for unrelated
   reasons, we are adding an UncheckedExecutionException class, which would
   be the perfect wrapper here.
   - We could do something similar when an ExecutionException wraps an
Errorcause if we added an
   ExecutionError class (even a private one, or we could use Error itself if
   the new type is objectionable).  It seems bad that an Error is downgraded
   to a boring Exception when it occurs in an executor-spawned task.  In
   principle, we should check whether every ExecutionException is caused by
   an Error, but I admit I've never done this, and I don't think I've never
   seen anyone else do it, either.

That would give us this revised policy:

Exceptions from Future.get are treated as follows:

   - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true>
is
   wrapped in an X (after restoring the interrupt).
   - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true>
or
   other raw RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true>
is
   propagated untouched.
   - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true>
has
   its *cause* unwrapped and rewrapped, with the new type depending on the
   type of the cause:
      - If the cause was a checked exception, it is wrapped in an X.
      - If the cause was an unchecked exception, it is wrapped in an
      UncheckedExecutionException.
      - If the cause was an error, it is wrapped in an ExecutionError.

That's just a discussion starter, though.  I'd be happy to hear comments on
any part of this.  Thanks.

(For the source, see
Futures.java<http://guava-libraries.googlecode.com/svn/trunk/guava/src/com/google/common/util/concurrent/Futures.java>.
 Search for "converting most exceptions.")
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/11cf29b6/attachment.html>

From joe.bowbeer at gmail.com  Thu Jul 14 20:55:02 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 14 Jul 2011 17:55:02 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
Message-ID: <CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>

Re-wrapping un/checked exceptions doesn't concern me as much as I am
concerned by mixing remote "execution" exceptions with local (non-execution)
exceptions, where execution exceptions were thrown by the future's callable
executing on the executor thread, and local exceptions were thrown by the
calling thread.

I like the idea of allowing the caller to provide their own custom
ExecutionException, but I would prefer if it were used only for execution
exceptions...

> Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
wrapped in an X (after restoring the interrupt).

I don't like this because it mixes remote and local.  And isn't the
InterruptedException already handled by your Uninterruptible form of Future?

(I don't want all Future.gets to be uninterruptible -- what's the point of
interrupting if nothing actually responds to it?)

> Is there any reason to wrap a raw RuntimeException thrown by get?

No.

Thoughts on revised policy:

Your revised policy only allows the programmer to provide a custom class for
an ExecutionException whose cause was checked.  But it's not clear to me
that a checked/unchecked exception in the context of the executor is also a
checked/unchecked exception in the context of the caller.  In some ways, the
revised policy is making it more difficult for the programmer who cares
about such things.

How about providing a form of Future.get where the caller supplies an
exception factory (or listener)?  Then they can decide on the execution
class at the point of failure.

Joe

On Thu, Jul 14, 2011 at 4:27 PM, Chris Povirk wrote:

> In the spirit of my earlier thread on InterruptedException-free wrappers
> for interruptible methods <http://markmail.org/message/bvh2yt3frtwpt45a> (digression:
> I'm now convinced that they shouldn't be used as widely as I thought, so
> thanks), I'm trying to simplify exception management in some common uses of
> concurrency utilities.  Right now, I'm looking at Future.get, which
> requires separate handling of at least two exception types -- as well it
> should for maximum generality, but that isn't much consolation for people
> who just want to know "Did it work or not?"  In my experience, in a typical
> webapp, I would often by happier with code like this:
>
> public Result getResult() throws MyException {
>   return Futures.get(future, MyException.class)<http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/util/concurrent/Futures.html#get%28java.util.concurrent.Future,%20java.lang.Class%29>
> ;
> }
>
> So, we're trying out such a method in Guava.  To quote from the Javadoc
> (though I'd recommend following the link above for the whole thing):
>
> Exceptions from Future.get are treated as follows:
>
>    - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>    wrapped in an X (after restoring the interrupt).
>    - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> is
>    propagated untouched.
>    - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>    its *cause* wrapped in an X.
>    - Any RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> other
>    than CancellationException (get implementations are discouraged from
>    throwing such exceptions) is wrapped in an X.
>
> In broad strokes, I'm happy with this.  But I can imagine some tweaks
> around the edges:
>
>    - Is there any reason to wrap a raw RuntimeException thrown by get?
>     Probably it comes from the calling thread, so we don't need to wrap it to
>    give a proper stack trace.  Meanwhile, we're converting an unchecked
>    exception to a checked exception unnecessarily.  Then again, is there any
>    great harm, since the type we're converting to is a type that the caller
>    already must handle?  Still, we're converting between unchecked exceptions
>    ("the programmer's fault") and checked exceptions ("not the programmer's
>    fault").  Future.get already does this by wrapping any unchecked
>    exception from the task itself in a checked ExecutionException, but
>    should we follow that example if it's bad?
>    - The previous point, though, addresses only a small issue: a raw
>    RuntimeException thrown by get, which shouldn't even occur.  More
>    interesting is the question of what to do if an ExecutionExceptionwraps an unchecked cause.  Why wrap that cause in a checked exception when
>    we could wrap it in an unchecked exception?  As it turns out, for unrelated
>    reasons, we are adding an UncheckedExecutionException class, which
>    would be the perfect wrapper here.
>    - We could do something similar when an ExecutionException wraps an
>    Error cause if we added an ExecutionError class (even a private one, or
>    we could use Error itself if the new type is objectionable).  It seems
>    bad that an Error is downgraded to a boring Exception when it occurs in
>    an executor-spawned task.  In principle, we should check whether every
>    ExecutionException is caused by an Error, but I admit I've never done
>    this, and I don't think I've never seen anyone else do it, either.
>
> That would give us this revised policy:
>
> Exceptions from Future.get are treated as follows:
>
>    - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>    wrapped in an X (after restoring the interrupt).
>    - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> or
>    other raw RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> is
>    propagated untouched.
>    - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>    its *cause* unwrapped and rewrapped, with the new type depending on the
>    type of the cause:
>       - If the cause was a checked exception, it is wrapped in an X.
>       - If the cause was an unchecked exception, it is wrapped in an
>       UncheckedExecutionException.
>       - If the cause was an error, it is wrapped in an ExecutionError.
>
> That's just a discussion starter, though.  I'd be happy to hear comments on
> any part of this.  Thanks.
>
> (For the source, see Futures.java<http://guava-libraries.googlecode.com/svn/trunk/guava/src/com/google/common/util/concurrent/Futures.java>.
>  Search for "converting most exceptions.")
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/8b076841/attachment-0001.html>

From joe.bowbeer at gmail.com  Thu Jul 14 20:58:48 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 14 Jul 2011 17:58:48 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
Message-ID: <CAHzJPEq9S9OO7tdAxyxfa79piX7pWSQCZEYJqkEDw18cnTdgnA@mail.gmail.com>

Correction:

Then they can decide on the [exception] class at the point of failure.

On Thu, Jul 14, 2011 at 5:55 PM, Joe Bowbeer wrote:

> Re-wrapping un/checked exceptions doesn't concern me as much as I am
> concerned by mixing remote "execution" exceptions with local (non-execution)
> exceptions, where execution exceptions were thrown by the future's callable
> executing on the executor thread, and local exceptions were thrown by the
> calling thread.
>
> I like the idea of allowing the caller to provide their own custom
> ExecutionException, but I would prefer if it were used only for execution
> exceptions...
>
> > Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
> wrapped in an X (after restoring the interrupt).
>
> I don't like this because it mixes remote and local.  And isn't the
> InterruptedException already handled by your Uninterruptible form of Future?
>
> (I don't want all Future.gets to be uninterruptible -- what's the point of
> interrupting if nothing actually responds to it?)
>
> > Is there any reason to wrap a raw RuntimeException thrown by get?
>
> No.
>
> Thoughts on revised policy:
>
> Your revised policy only allows the programmer to provide a custom class
> for an ExecutionException whose cause was checked.  But it's not clear to me
> that a checked/unchecked exception in the context of the executor is also a
> checked/unchecked exception in the context of the caller.  In some ways, the
> revised policy is making it more difficult for the programmer who cares
> about such things.
>
> How about providing a form of Future.get where the caller supplies an
> exception factory (or listener)?  Then they can decide on the execution
> class at the point of failure.
>
> Joe
>
> On Thu, Jul 14, 2011 at 4:27 PM, Chris Povirk wrote:
>
>> In the spirit of my earlier thread on InterruptedException-free wrappers
>> for interruptible methods <http://markmail.org/message/bvh2yt3frtwpt45a> (digression:
>> I'm now convinced that they shouldn't be used as widely as I thought, so
>> thanks), I'm trying to simplify exception management in some common uses of
>> concurrency utilities.  Right now, I'm looking at Future.get, which
>> requires separate handling of at least two exception types -- as well it
>> should for maximum generality, but that isn't much consolation for people
>> who just want to know "Did it work or not?"  In my experience, in a typical
>> webapp, I would often by happier with code like this:
>>
>> public Result getResult() throws MyException {
>>   return Futures.get(future, MyException.class)<http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/util/concurrent/Futures.html#get%28java.util.concurrent.Future,%20java.lang.Class%29>
>> ;
>> }
>>
>> So, we're trying out such a method in Guava.  To quote from the Javadoc
>> (though I'd recommend following the link above for the whole thing):
>>
>> Exceptions from Future.get are treated as follows:
>>
>>    - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>>    wrapped in an X (after restoring the interrupt).
>>    - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> is
>>    propagated untouched.
>>    - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>>    its *cause* wrapped in an X.
>>    - Any RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> other
>>    than CancellationException (get implementations are discouraged from
>>    throwing such exceptions) is wrapped in an X.
>>
>> In broad strokes, I'm happy with this.  But I can imagine some tweaks
>> around the edges:
>>
>>    - Is there any reason to wrap a raw RuntimeException thrown by get?
>>     Probably it comes from the calling thread, so we don't need to wrap it to
>>    give a proper stack trace.  Meanwhile, we're converting an unchecked
>>    exception to a checked exception unnecessarily.  Then again, is there any
>>    great harm, since the type we're converting to is a type that the caller
>>    already must handle?  Still, we're converting between unchecked exceptions
>>    ("the programmer's fault") and checked exceptions ("not the programmer's
>>    fault").  Future.get already does this by wrapping any unchecked
>>    exception from the task itself in a checked ExecutionException, but
>>    should we follow that example if it's bad?
>>    - The previous point, though, addresses only a small issue: a raw
>>    RuntimeException thrown by get, which shouldn't even occur.  More
>>    interesting is the question of what to do if an ExecutionExceptionwraps an unchecked cause.  Why wrap that cause in a checked exception when
>>    we could wrap it in an unchecked exception?  As it turns out, for unrelated
>>    reasons, we are adding an UncheckedExecutionException class, which
>>    would be the perfect wrapper here.
>>    - We could do something similar when an ExecutionException wraps an
>>    Error cause if we added an ExecutionError class (even a private one,
>>    or we could use Error itself if the new type is objectionable).  It
>>    seems bad that an Error is downgraded to a boring Exception when it
>>    occurs in an executor-spawned task.  In principle, we should check whether
>>    every ExecutionException is caused by an Error, but I admit I've never
>>    done this, and I don't think I've never seen anyone else do it, either.
>>
>> That would give us this revised policy:
>>
>> Exceptions from Future.get are treated as follows:
>>
>>    - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>>    wrapped in an X (after restoring the interrupt).
>>    - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> or
>>    other raw RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> is
>>    propagated untouched.
>>    - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>>    its *cause* unwrapped and rewrapped, with the new type depending on
>>    the type of the cause:
>>       - If the cause was a checked exception, it is wrapped in an X.
>>       - If the cause was an unchecked exception, it is wrapped in an
>>       UncheckedExecutionException.
>>       - If the cause was an error, it is wrapped in an ExecutionError.
>>
>> That's just a discussion starter, though.  I'd be happy to hear comments
>> on any part of this.  Thanks.
>>
>> (For the source, see Futures.java<http://guava-libraries.googlecode.com/svn/trunk/guava/src/com/google/common/util/concurrent/Futures.java>.
>>  Search for "converting most exceptions.")
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/829a0b45/attachment.html>

From cpovirk at google.com  Thu Jul 14 21:51:51 2011
From: cpovirk at google.com (Chris Povirk)
Date: Thu, 14 Jul 2011 18:51:51 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
Message-ID: <CAEvq2nowdpLJjn8H2tZUZCOU02bV4Jh6xdb6m2yVB48=3Ci4Rw@mail.gmail.com>

> Re-wrapping un/checked exceptions doesn't concern me as much as I am
> concerned by mixing remote "execution" exceptions with local (non-execution)
> exceptions, where execution exceptions were thrown by the future's callable
> executing on the executor thread, and local exceptions were thrown by the
> calling thread.
> I like the idea of allowing the caller to provide their own custom
> ExecutionException, but I would prefer if it were used only for execution
> exceptions...
>>?Any?InterruptedException?is wrapped in an?X?(after restoring the
>> interrupt).
> I don't like this because it mixes remote and local.

This is simultaneously the heart of the method and the part I least
want to talk about :)  By that, I basically mean that I have my heart
set on adding a method that mixes remote and local exceptions.  (So
really I'm happy to talk about, but I may be a poor listener :))
That's because my primary goal is to collapse all the Future.get
exceptions into one exception type.  Many users of Future won't want
this, of course, but writing 2-3 catch blocks when all I care about it
success vs. failure drives me crazy, so I just want to solve that
case.  One way to do this is to change getUninterruptibly to also
accept an exception mapper for ExecutionException only.  This solves
the problem at the cost of messing with the interrupt system (see
below) -- at least if you don't use the timed get() and introduce
TimeoutException.

> And isn't the
> InterruptedException already handled by your Uninterruptible form of Future?
> (I don't want all Future.gets to be uninterruptible -- what's the point of
> interrupting if nothing actually responds to it?)

The new method would be a competitor to getUninterruptibly, and this
is by design: I'm hoping that it will eat into getUninterruptibly's
market share so that more Future uses remain interruptible.

Setting aside the question of the new Guava method, I'm wondering what
you do with InterruptedException when calling Future.get in MyService:

1. use getUninterruptibly
2. catch it, restore interrupt, and throw MyServiceException
3. declare each MyService method to throw both MyServiceException and
InterruptedException[*]
4. something else?

If there's another option out there, maybe the new Guava method should
do it instead.  Ideas, anyone?

[*] Of course, (3) is an option, but it feels like an abstraction
violation in some cases (in the same way that throwing IOException
from MyDatabaseService would be: Why should my callers care if I use
threads internally and in such a way that allows for interruption?).
Further, because interruption means cancellation for all practical
purposes, it _kind of_ doesn't matter what we do when we're
interrupted, as long as we stop doing it quickly.  Sure, if I'm
writing low-level concurrency code, I might need to catch
InterruptedException specifically so that I can restore some
invariants before blowing up, but if I'm writing MyDatabaseService, my
users already expect for me to throw exceptions, so they either won't
have these invariants or will already have a try-finally to deal with
them.  The Guava method exists for the MyDatabaseService guy.  (And
here comes my secret motivation: A lot of MyDatabaseService guys are
going to write "catch (InterruptedException e) {}" and thus neither
abort quickly nor finish the job.  Interruption is complicated :( ...
)

> Thoughts on revised policy:
> Your revised policy only allows the programmer to provide a custom class for
> an ExecutionException whose cause was checked. ?But it's not clear to me
> that a checked/unchecked exception in the context of the executor is also a
> checked/unchecked exception in the context of the caller. ?In some ways, the
> revised policy is making it more difficult for the programmer who cares
> about such things.

True, the caller might well want to convert unchecked exceptions to
checked.  I've often wanted to convert a NumberFormatException into
some kind of checked exception, for instance, and it might be better
overall if MyDataService threw only MyDataServiceException (instead of
NPE, etc.) so that, when it failed, I could treat a NPE like any other
"I couldn't get data" failure, rather than as a failure of unknown
source that causes us to abort rendering the web app entirely.  Then
again, I probably track statistics for MyDataServiceExceptions
separately from RuntimeExceptions, since the former may indicate
transient timeouts but the latter bugs, so I don't necessarily want to
convert the latter to the former.

Overall, I guess I view "exception came from another thread" as an
implementation detail that shouldn't affect whether it's checked or
unchecked from the perspective of the caller.  I would find it equally
useful (and equally dangerous) to be able to automatically convert
from unchecked to checked exceptions for in-thread operations.
Ultimately, such conversions feel more dangerous than useful to me,
but I'm far from certain.

> How about providing a form of Future.get where the caller supplies an
> exception factory (or listener)? ?Then they can decide on the execution
> class at the point of failure.

If you mean what I think you mean, the answer is that I haven't found
a library to save a lot of code over the manual approach.  Compare:

 public static <V> V getWithMyException(Future<V> future) throws MyException {
   checkNotNull(future);
   try {
     return future.get();
   } catch (InterruptedException e) {
     currentThread().interrupt();
     throw new MyException(e);
   } catch (CancellationException e) {
     throw e;
   } catch (ExecutionException e) {
     throw new MyException(e.getCause());
   }
 }

 public static <V> V getWithMyException(Future<V> future) throws MyException {
   return Futures.get(future, new Thrower<MyException>() {
     @Override public void convertAndThrow(Throwable e) throws MyException {
       if (e instanceof InterruptedException) {
         throw new MyException(e); // library will call interrupt() for you
       } else if (e instanceof CancellationException) {
         throw (CancellationException) e;
       } else {
         throw new MyException(e); // library will have unwrapped for you
       }
     }
   });
 }

I do think that such manual conversions can play a role in the overall
mission of taming Future.get's exceptions.

Thanks for the comments!


From joe.bowbeer at gmail.com  Thu Jul 14 23:04:43 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 14 Jul 2011 20:04:43 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAEvq2nowdpLJjn8H2tZUZCOU02bV4Jh6xdb6m2yVB48=3Ci4Rw@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
	<CAEvq2nowdpLJjn8H2tZUZCOU02bV4Jh6xdb6m2yVB48=3Ci4Rw@mail.gmail.com>
Message-ID: <CAHzJPEq22g0=0YUu7AUoUNJbSPy1Y1udTF8f=kwdKOvXK1DUWQ@mail.gmail.com>

I think we both agree that there is no perfect way to compress remote and
local exceptions.

I think the programmer-friendly answer depends on the problem domain.  I
assume your problem domain is in-lining of RPCs?

> I'm wondering what you do with InterruptedException when calling
Future.get in MyService:

I would declare that it throws InterruptedException and let it propagate to
the (higher) level in my code where interrupts are dealt with.

A very common case however is that the caller will never be interrupted, and
I think it would be convenient to have a form that operated under this
assumption -- in which case I would throw an AssertionError if an
InterruptedException were thrown.  If the assumption really is that the code
will not be interrupted, why *not* hide the exception and enforce the
assumption with an assertion?

Here are more comments on your revised policy:

* Any InterruptedException is wrapped in an X (after restoring the
interrupt).

Why not rethrow as UncheckedInterruptedException?  If you want the
programmers to deal with interrupt, then leave the exception alone...  But
if you don't want them to deal with it (or interrupts will never happen),
then convert to an unchecked exception or an error.  Either of these seems
preferable than combining the interrupt with an execution-specific
exception.

* Any CancellationException or other raw RuntimeException is propagated
untouched.

OK - they're all local exceptions.

* Any ExecutionException has its cause unwrapped and rewrapped, with the new
type depending on the type of the cause:
** If the cause was a checked exception, it is wrapped in an X.
** If the cause was an unchecked exception, it is wrapped in
an UncheckedExecutionException.
** If the cause was an error, it is wrapped in an ExecutionError.

I would re-wrap everything in X.  Let the user decide if they want to make X
checked or unchecked.

I can see some utility to the UncheckedExceptionException and
ExecutionError, but I'm also concerned about confusion between remote and
local instances of these.  Consider chained RPCs and what happens to their
exceptions...

Joe

On Thu, Jul 14, 2011 at 6:51 PM, Chris Povirk wrote:

> > Re-wrapping un/checked exceptions doesn't concern me as much as I am
> > concerned by mixing remote "execution" exceptions with local
> (non-execution)
> > exceptions, where execution exceptions were thrown by the future's
> callable
> > executing on the executor thread, and local exceptions were thrown by the
> > calling thread.
> > I like the idea of allowing the caller to provide their own custom
> > ExecutionException, but I would prefer if it were used only for execution
> > exceptions...
> >> Any InterruptedException is wrapped in an X (after restoring the
> >> interrupt).
> > I don't like this because it mixes remote and local.
>
> This is simultaneously the heart of the method and the part I least
> want to talk about :)  By that, I basically mean that I have my heart
> set on adding a method that mixes remote and local exceptions.  (So
> really I'm happy to talk about, but I may be a poor listener :))
> That's because my primary goal is to collapse all the Future.get
> exceptions into one exception type.  Many users of Future won't want
> this, of course, but writing 2-3 catch blocks when all I care about it
> success vs. failure drives me crazy, so I just want to solve that
> case.  One way to do this is to change getUninterruptibly to also
> accept an exception mapper for ExecutionException only.  This solves
> the problem at the cost of messing with the interrupt system (see
> below) -- at least if you don't use the timed get() and introduce
> TimeoutException.
>
> > And isn't the
> > InterruptedException already handled by your Uninterruptible form of
> Future?
> > (I don't want all Future.gets to be uninterruptible -- what's the point
> of
> > interrupting if nothing actually responds to it?)
>
> The new method would be a competitor to getUninterruptibly, and this
> is by design: I'm hoping that it will eat into getUninterruptibly's
> market share so that more Future uses remain interruptible.
>
> Setting aside the question of the new Guava method, I'm wondering what
> you do with InterruptedException when calling Future.get in MyService:
>
> 1. use getUninterruptibly
> 2. catch it, restore interrupt, and throw MyServiceException
> 3. declare each MyService method to throw both MyServiceException and
> InterruptedException[*]
> 4. something else?
>
> If there's another option out there, maybe the new Guava method should
> do it instead.  Ideas, anyone?
>
> [*] Of course, (3) is an option, but it feels like an abstraction
> violation in some cases (in the same way that throwing IOException
> from MyDatabaseService would be: Why should my callers care if I use
> threads internally and in such a way that allows for interruption?).
> Further, because interruption means cancellation for all practical
> purposes, it _kind of_ doesn't matter what we do when we're
> interrupted, as long as we stop doing it quickly.  Sure, if I'm
> writing low-level concurrency code, I might need to catch
> InterruptedException specifically so that I can restore some
> invariants before blowing up, but if I'm writing MyDatabaseService, my
> users already expect for me to throw exceptions, so they either won't
> have these invariants or will already have a try-finally to deal with
> them.  The Guava method exists for the MyDatabaseService guy.  (And
> here comes my secret motivation: A lot of MyDatabaseService guys are
> going to write "catch (InterruptedException e) {}" and thus neither
> abort quickly nor finish the job.  Interruption is complicated :( ...
> )
>
> > Thoughts on revised policy:
> > Your revised policy only allows the programmer to provide a custom class
> for
> > an ExecutionException whose cause was checked.  But it's not clear to me
> > that a checked/unchecked exception in the context of the executor is also
> a
> > checked/unchecked exception in the context of the caller.  In some ways,
> the
> > revised policy is making it more difficult for the programmer who cares
> > about such things.
>
> True, the caller might well want to convert unchecked exceptions to
> checked.  I've often wanted to convert a NumberFormatException into
> some kind of checked exception, for instance, and it might be better
> overall if MyDataService threw only MyDataServiceException (instead of
> NPE, etc.) so that, when it failed, I could treat a NPE like any other
> "I couldn't get data" failure, rather than as a failure of unknown
> source that causes us to abort rendering the web app entirely.  Then
> again, I probably track statistics for MyDataServiceExceptions
> separately from RuntimeExceptions, since the former may indicate
> transient timeouts but the latter bugs, so I don't necessarily want to
> convert the latter to the former.
>
> Overall, I guess I view "exception came from another thread" as an
> implementation detail that shouldn't affect whether it's checked or
> unchecked from the perspective of the caller.  I would find it equally
> useful (and equally dangerous) to be able to automatically convert
> from unchecked to checked exceptions for in-thread operations.
> Ultimately, such conversions feel more dangerous than useful to me,
> but I'm far from certain.
>
> > How about providing a form of Future.get where the caller supplies an
> > exception factory (or listener)?  Then they can decide on the execution
> > class at the point of failure.
>
> If you mean what I think you mean, the answer is that I haven't found
> a library to save a lot of code over the manual approach.  Compare:
>
>  public static <V> V getWithMyException(Future<V> future) throws
> MyException {
>   checkNotNull(future);
>   try {
>     return future.get();
>   } catch (InterruptedException e) {
>     currentThread().interrupt();
>     throw new MyException(e);
>   } catch (CancellationException e) {
>     throw e;
>   } catch (ExecutionException e) {
>     throw new MyException(e.getCause());
>   }
>  }
>
>  public static <V> V getWithMyException(Future<V> future) throws
> MyException {
>   return Futures.get(future, new Thrower<MyException>() {
>     @Override public void convertAndThrow(Throwable e) throws MyException {
>       if (e instanceof InterruptedException) {
>         throw new MyException(e); // library will call interrupt() for you
>       } else if (e instanceof CancellationException) {
>         throw (CancellationException) e;
>       } else {
>         throw new MyException(e); // library will have unwrapped for you
>       }
>     }
>   });
>  }
>
> I do think that such manual conversions can play a role in the overall
> mission of taming Future.get's exceptions.
>
> Thanks for the comments!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/398da9c9/attachment.html>

From tim at peierls.net  Thu Jul 14 23:21:18 2011
From: tim at peierls.net (Tim Peierls)
Date: Thu, 14 Jul 2011 23:21:18 -0400
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAHzJPEq22g0=0YUu7AUoUNJbSPy1Y1udTF8f=kwdKOvXK1DUWQ@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<CAHzJPEqbqJZRwAy1P=p-z4BbKavmwnWTDGLYZ0ZiiGeRRgN2xA@mail.gmail.com>
	<CAEvq2nowdpLJjn8H2tZUZCOU02bV4Jh6xdb6m2yVB48=3Ci4Rw@mail.gmail.com>
	<CAHzJPEq22g0=0YUu7AUoUNJbSPy1Y1udTF8f=kwdKOvXK1DUWQ@mail.gmail.com>
Message-ID: <CA+F8eeS7ggvg9mmFEkU_qiWL4bsxOxsLmOYeHWrri6ddwsS9RA@mail.gmail.com>

Orthogonally to Joe's comments, I'd like to suggest that whatever
flexibility you ultimately allow be expressed as a DSL/builder-style API so
that users can define a policy for handling exceptions during get and apply
it in lots of places.

    final FutureGetter fget = FutureGetter
        .wrapping(YourException.class)
        .throwingUncheckedInterruptedException();

    ...
    return fget.apply(future);

--tim


On Thu, Jul 14, 2011 at 11:04 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> I think we both agree that there is no perfect way to compress remote and
> local exceptions.
>
> I think the programmer-friendly answer depends on the problem domain.  I
> assume your problem domain is in-lining of RPCs?
>
> > I'm wondering what you do with InterruptedException when calling
> Future.get in MyService:
>
> I would declare that it throws InterruptedException and let it propagate to
> the (higher) level in my code where interrupts are dealt with.
>
> A very common case however is that the caller will never be interrupted,
> and I think it would be convenient to have a form that operated under this
> assumption -- in which case I would throw an AssertionError if an
> InterruptedException were thrown.  If the assumption really is that the code
> will not be interrupted, why *not* hide the exception and enforce the
> assumption with an assertion?
>
> Here are more comments on your revised policy:
>
> * Any InterruptedException is wrapped in an X (after restoring the
> interrupt).
>
> Why not rethrow as UncheckedInterruptedException?  If you want the
> programmers to deal with interrupt, then leave the exception alone...  But
> if you don't want them to deal with it (or interrupts will never happen),
> then convert to an unchecked exception or an error.  Either of these seems
> preferable than combining the interrupt with an execution-specific
> exception.
>
> * Any CancellationException or other raw RuntimeException is propagated
> untouched.
>
> OK - they're all local exceptions.
>
> * Any ExecutionException has its cause unwrapped and rewrapped, with the
> new type depending on the type of the cause:
> ** If the cause was a checked exception, it is wrapped in an X.
> ** If the cause was an unchecked exception, it is wrapped in
> an UncheckedExecutionException.
>
> ** If the cause was an error, it is wrapped in an ExecutionError.
>
> I would re-wrap everything in X.  Let the user decide if they want to make
> X checked or unchecked.
>
> I can see some utility to the UncheckedExceptionException and
> ExecutionError, but I'm also concerned about confusion between remote and
> local instances of these.  Consider chained RPCs and what happens to their
> exceptions...
>
> Joe
>
> On Thu, Jul 14, 2011 at 6:51 PM, Chris Povirk wrote:
>
>> > Re-wrapping un/checked exceptions doesn't concern me as much as I am
>> > concerned by mixing remote "execution" exceptions with local
>> (non-execution)
>> > exceptions, where execution exceptions were thrown by the future's
>> callable
>> > executing on the executor thread, and local exceptions were thrown by
>> the
>> > calling thread.
>> > I like the idea of allowing the caller to provide their own custom
>> > ExecutionException, but I would prefer if it were used only for
>> execution
>> > exceptions...
>> >> Any InterruptedException is wrapped in an X (after restoring the
>> >> interrupt).
>> > I don't like this because it mixes remote and local.
>>
>> This is simultaneously the heart of the method and the part I least
>> want to talk about :)  By that, I basically mean that I have my heart
>> set on adding a method that mixes remote and local exceptions.  (So
>> really I'm happy to talk about, but I may be a poor listener :))
>> That's because my primary goal is to collapse all the Future.get
>> exceptions into one exception type.  Many users of Future won't want
>> this, of course, but writing 2-3 catch blocks when all I care about it
>> success vs. failure drives me crazy, so I just want to solve that
>> case.  One way to do this is to change getUninterruptibly to also
>> accept an exception mapper for ExecutionException only.  This solves
>> the problem at the cost of messing with the interrupt system (see
>> below) -- at least if you don't use the timed get() and introduce
>> TimeoutException.
>>
>> > And isn't the
>> > InterruptedException already handled by your Uninterruptible form of
>> Future?
>> > (I don't want all Future.gets to be uninterruptible -- what's the point
>> of
>> > interrupting if nothing actually responds to it?)
>>
>> The new method would be a competitor to getUninterruptibly, and this
>> is by design: I'm hoping that it will eat into getUninterruptibly's
>> market share so that more Future uses remain interruptible.
>>
>> Setting aside the question of the new Guava method, I'm wondering what
>> you do with InterruptedException when calling Future.get in MyService:
>>
>> 1. use getUninterruptibly
>> 2. catch it, restore interrupt, and throw MyServiceException
>> 3. declare each MyService method to throw both MyServiceException and
>> InterruptedException[*]
>> 4. something else?
>>
>> If there's another option out there, maybe the new Guava method should
>> do it instead.  Ideas, anyone?
>>
>> [*] Of course, (3) is an option, but it feels like an abstraction
>> violation in some cases (in the same way that throwing IOException
>> from MyDatabaseService would be: Why should my callers care if I use
>> threads internally and in such a way that allows for interruption?).
>> Further, because interruption means cancellation for all practical
>> purposes, it _kind of_ doesn't matter what we do when we're
>> interrupted, as long as we stop doing it quickly.  Sure, if I'm
>> writing low-level concurrency code, I might need to catch
>> InterruptedException specifically so that I can restore some
>> invariants before blowing up, but if I'm writing MyDatabaseService, my
>> users already expect for me to throw exceptions, so they either won't
>> have these invariants or will already have a try-finally to deal with
>> them.  The Guava method exists for the MyDatabaseService guy.  (And
>> here comes my secret motivation: A lot of MyDatabaseService guys are
>> going to write "catch (InterruptedException e) {}" and thus neither
>> abort quickly nor finish the job.  Interruption is complicated :( ...
>> )
>>
>> > Thoughts on revised policy:
>> > Your revised policy only allows the programmer to provide a custom class
>> for
>> > an ExecutionException whose cause was checked.  But it's not clear to me
>> > that a checked/unchecked exception in the context of the executor is
>> also a
>> > checked/unchecked exception in the context of the caller.  In some ways,
>> the
>> > revised policy is making it more difficult for the programmer who cares
>> > about such things.
>>
>> True, the caller might well want to convert unchecked exceptions to
>> checked.  I've often wanted to convert a NumberFormatException into
>> some kind of checked exception, for instance, and it might be better
>> overall if MyDataService threw only MyDataServiceException (instead of
>> NPE, etc.) so that, when it failed, I could treat a NPE like any other
>> "I couldn't get data" failure, rather than as a failure of unknown
>> source that causes us to abort rendering the web app entirely.  Then
>> again, I probably track statistics for MyDataServiceExceptions
>> separately from RuntimeExceptions, since the former may indicate
>> transient timeouts but the latter bugs, so I don't necessarily want to
>> convert the latter to the former.
>>
>> Overall, I guess I view "exception came from another thread" as an
>> implementation detail that shouldn't affect whether it's checked or
>> unchecked from the perspective of the caller.  I would find it equally
>> useful (and equally dangerous) to be able to automatically convert
>> from unchecked to checked exceptions for in-thread operations.
>> Ultimately, such conversions feel more dangerous than useful to me,
>> but I'm far from certain.
>>
>> > How about providing a form of Future.get where the caller supplies an
>> > exception factory (or listener)?  Then they can decide on the execution
>> > class at the point of failure.
>>
>> If you mean what I think you mean, the answer is that I haven't found
>> a library to save a lot of code over the manual approach.  Compare:
>>
>>  public static <V> V getWithMyException(Future<V> future) throws
>> MyException {
>>   checkNotNull(future);
>>   try {
>>     return future.get();
>>   } catch (InterruptedException e) {
>>     currentThread().interrupt();
>>     throw new MyException(e);
>>   } catch (CancellationException e) {
>>     throw e;
>>   } catch (ExecutionException e) {
>>     throw new MyException(e.getCause());
>>   }
>>  }
>>
>>  public static <V> V getWithMyException(Future<V> future) throws
>> MyException {
>>   return Futures.get(future, new Thrower<MyException>() {
>>     @Override public void convertAndThrow(Throwable e) throws MyException
>> {
>>       if (e instanceof InterruptedException) {
>>         throw new MyException(e); // library will call interrupt() for you
>>       } else if (e instanceof CancellationException) {
>>         throw (CancellationException) e;
>>       } else {
>>         throw new MyException(e); // library will have unwrapped for you
>>       }
>>     }
>>   });
>>  }
>>
>> I do think that such manual conversions can play a role in the overall
>> mission of taming Future.get's exceptions.
>>
>> Thanks for the comments!
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/91de6898/attachment-0001.html>

From mohanr at fss.co.in  Fri Jul 15 03:49:06 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Fri, 15 Jul 2011 13:19:06 +0530
Subject: [concurrency-interest] Difference between FJ and kernel tuning
Message-ID: <025153D79DA9884ABDF85638747FD4970886C2@fssbemail.fss.india>

Hi,

 

         I have come across an offer to tune the HP-UX kernel to
parallelize the threads across the available cores for a normal threaded
Java program. Not being an expert the meaning of 'parallelize' is not
obvious to me. I think it means something like apparent parallelization.

 

How does FJ and this type of kernel tuning compare with each other ? Do
some OS's obviate the need for FJ using kernel facilities ? I really
don't know what type of OS theads are being referred to here ?

 

Are there any helpful references ?

 

Thanks.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110715/15e975e4/attachment.html>

From dl at cs.oswego.edu  Fri Jul 15 07:51:03 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 15 Jul 2011 07:51:03 -0400
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
Message-ID: <4E2029A7.7060401@cs.oswego.edu>

On 07/14/11 19:27, Chris Povirk wrote:
> I'm trying to
> simplify exception management in some common uses of concurrency utilities.

Deja vu. We faced the same issues with ForkJoinTask, which
are Futures, but unlike arbitrary Futures, are designed for
uses in which checked exceptions rarely apply. We mainly solved
this by adding method join(),
(http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/ForkJoinTask.html) 
that differs from get() in that it only throws
unchecked exceptions. We then designed all the ForkJoin execution
mechanics to play along, including, when necessary,
wrapping in RuntimeException. This was easier for us inside JDK
library classes vs user-level because we could arrange the
JVM to just rethrow Throwables that are sure to be either
Errors or RuntimeExceptions (the two forms of unchecked
exceptions), but there is no associated static type.

If I were to do this over again, I would probably do
the same for ALL Futures (and not even parameterize
over Exception types). If you glance through hits
of "catch (ExecutionException" on google code
search (http://www.google.com/codesearch), most
usages would have been easier and probably closer
to being correct if we had done so. It is too late now,
but as people tend to start using ForkJoinTask more than
other forms of Futures, maybe this problem will slowly go away.

-Doug

From viktor.klang at gmail.com  Fri Jul 15 09:29:43 2011
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Fri, 15 Jul 2011 15:29:43 +0200
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <4E2029A7.7060401@cs.oswego.edu>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<4E2029A7.7060401@cs.oswego.edu>
Message-ID: <CANPzfU_c68Dr=h4LJmBk_iUHyNtH7HSKQhfhfDL9ZwuLjmVrfQ@mail.gmail.com>

Not to forget would be that it would be very nice to have
onComplete/onTimeout/onCancel callbacks so one could use promise pipelining
and have full asynchronizity instead of introducing blocking. :-)

Cheers,
?

On Fri, Jul 15, 2011 at 1:51 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 07/14/11 19:27, Chris Povirk wrote:
>
>> I'm trying to
>> simplify exception management in some common uses of concurrency
>> utilities.
>>
>
> Deja vu. We faced the same issues with ForkJoinTask, which
> are Futures, but unlike arbitrary Futures, are designed for
> uses in which checked exceptions rarely apply. We mainly solved
> this by adding method join(),
> (http://gee.cs.oswego.edu/dl/**jsr166/dist/docs/java/util/**
> concurrent/ForkJoinTask.html<http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/ForkJoinTask.html>)
> that differs from get() in that it only throws
> unchecked exceptions. We then designed all the ForkJoin execution
> mechanics to play along, including, when necessary,
> wrapping in RuntimeException. This was easier for us inside JDK
> library classes vs user-level because we could arrange the
> JVM to just rethrow Throwables that are sure to be either
> Errors or RuntimeExceptions (the two forms of unchecked
> exceptions), but there is no associated static type.
>
> If I were to do this over again, I would probably do
> the same for ALL Futures (and not even parameterize
> over Exception types). If you glance through hits
> of "catch (ExecutionException" on google code
> search (http://www.google.com/**codesearch<http://www.google.com/codesearch>),
> most
> usages would have been easier and probably closer
> to being correct if we had done so. It is too late now,
> but as people tend to start using ForkJoinTask more than
> other forms of Futures, maybe this problem will slowly go away.
>
> -Doug
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Viktor Klang

Akka Tech Lead
Typesafe <http://www.typesafe.com/> - Enterprise-Grade Scala from the
Experts

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110715/76bd39fa/attachment.html>

From joe.bowbeer at gmail.com  Fri Jul 15 13:15:55 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 15 Jul 2011 10:15:55 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <4E2029A7.7060401@cs.oswego.edu>
References: <CAEvq2nqzdTGPsSw_OgqsTRBAo5-_akpPW-Nhn=z5YuKANgnf+g@mail.gmail.com>
	<4E2029A7.7060401@cs.oswego.edu>
Message-ID: <CAHzJPErkEStJ-ownxZ1P6Rd5miTkacrPqrQavgr4G_-PUz+2ww@mail.gmail.com>

On Fri, Jul 15, 2011 at 4:51 AM, Doug Lea wrote:

> On 07/14/11 19:27, Chris Povirk wrote:
>
>> I'm trying to
>> simplify exception management in some common uses of concurrency
>> utilities.
>
>
> If I were to do this over again, I would probably do
> the same for ALL Futures (and not even parameterize
> over Exception types). If you glance through hits
> of "catch (ExecutionException" on google code
> search (http://www.google.com/**codesearch<http://www.google.com/codesearch>),
> most
> usages would have been easier and probably closer
> to being correct if we had done so. It is too late now,
> but as people tend to start using ForkJoinTask more than
> other forms of Futures, maybe this problem will slowly go away.


Glancing through hits of "catch (*Exception" on google code might lead one
to believe that things would have been easier and probably closer to being
correct if ALL checked exceptions had been removed from Java... but that
doesn't convince me that this extra bit of imposed rigor is a bad thing.
 (Grepping code can point out difficulties, but does it make a good
designer?)

I would attack InterruptedException first, and probably stop there.

In the Future/Executor framework I've been using in mobile handset apps for
the past decade -- when j.u.c. was unavailable on mobile handsets(!) -- I
settled on a basic FutureTask that looked very much like j.u.c.'s but I
added an abstract Worker subclass in order to provide listeners for
completion, failure, and progress.

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110715/4d4506f0/attachment.html>

From ashwin.jayaprakash at gmail.com  Fri Jul 15 14:22:48 2011
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Fri, 15 Jul 2011 11:22:48 -0700
Subject: [concurrency-interest] LMAX/Disruptor
Message-ID: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>

Just an FYI - in case you guys haven't heard about the ultra-low latency
data structure: http://www.infoq.com/presentations/LMAX -
http://code.google.com/p/disruptor/


Ashwin (http://www.ashwinjayaprakash.com)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110715/fce5fbcb/attachment.html>

From davidcholmes at aapt.net.au  Sat Jul 16 06:34:32 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 16 Jul 2011 20:34:32 +1000
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <025153D79DA9884ABDF85638747FD4970886C2@fssbemail.fss.india>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEJOIOAA.davidcholmes@aapt.net.au>

I have no idea what kind of kernel tuning you are referring to, so I have no
idea what possible relationship it has to FJ. FJ is "simply" a fine-grained
fork/join framework that employs work stealing.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mohan
Radhakrishnan
  Sent: Friday, 15 July 2011 5:49 PM
  To: concurrency-interest
  Subject: [concurrency-interest] Difference between FJ and kernel tuning


  Hi,



           I have come across an offer to tune the HP-UX kernel to
parallelize the threads across the available cores for a normal threaded
Java program. Not being an expert the meaning of 'parallelize' is not
obvious to me. I think it means something like apparent parallelization.



  How does FJ and this type of kernel tuning compare with each other ? Do
some OS's obviate the need for FJ using kernel facilities ? I really don't
know what type of OS theads are being referred to here ?



  Are there any helpful references ?



  Thanks.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110716/6161241e/attachment.html>

From nichole.king at gmail.com  Sat Jul 16 07:02:19 2011
From: nichole.king at gmail.com (Nichole King)
Date: Sat, 16 Jul 2011 04:02:19 -0700
Subject: [concurrency-interest]  Future.get exception mapping
In-Reply-To: <mailman.30.1310694715.3597.concurrency-interest@cs.oswego.edu>
References: <mailman.30.1310694715.3597.concurrency-interest@cs.oswego.edu>
Message-ID: <4E417918-D4BD-491C-BB56-308E24134EB0@gmail.com>

Using a parameterized type for an exception, that is <E extends Exception> is possible in
class and method signatures and is usable just about everywhere *except* in the
catch block where you would want to check for the type.
The exception parameter type E is erased to Exception at runtime so you can't
use it in the catch block ( can't use  } catch (E exception) { )

If you wanted to use a specialized exception, you would have to offer that
as a concrete class in your API.  And your suggestions on testing for that in try/catch along
with CancellationException, InterruptedException, and ExecutionException 
would be necessary.

If you wanted to supply a constructor or other method that takes an argument for Callable
like FutureTask does, then you could provide an interface that uses the new exception class
also to make it slightly more typed:

   Extend Callable:
        interface ICustomCallable<V> extends Callable<V> { 
            @Override
            V call() throws CustomException;
       }


On Jul 14, 2011, at 6:51 PM, concurrency-interest-request at cs.oswego.edu wrote:

> Send Concurrency-interest mailing list submissions to
> 	concurrency-interest at cs.oswego.edu
> 
> To subscribe or unsubscribe via the World Wide Web, visit
> 	http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> 	concurrency-interest-request at cs.oswego.edu
> 
> You can reach the person managing the list at
> 	concurrency-interest-owner at cs.oswego.edu
> 
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
> 
> 
> Today's Topics:
> 
>   1. Re: Future.get exception mapping (Joe Bowbeer)
>   2. Re: Future.get exception mapping (Chris Povirk)
> 
> 
> ----------------------------------------------------------------------
> 
> Message: 1
> Date: Thu, 14 Jul 2011 17:58:48 -0700
> From: Joe Bowbeer <joe.bowbeer at gmail.com>
> Subject: Re: [concurrency-interest] Future.get exception mapping
> To: concurrency-interest at cs.oswego.edu
> Message-ID:
> 	<CAHzJPEq9S9OO7tdAxyxfa79piX7pWSQCZEYJqkEDw18cnTdgnA at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
> 
> Correction:
> 
> Then they can decide on the [exception] class at the point of failure.
> 
> On Thu, Jul 14, 2011 at 5:55 PM, Joe Bowbeer wrote:
> 
>> Re-wrapping un/checked exceptions doesn't concern me as much as I am
>> concerned by mixing remote "execution" exceptions with local (non-execution)
>> exceptions, where execution exceptions were thrown by the future's callable
>> executing on the executor thread, and local exceptions were thrown by the
>> calling thread.
>> 
>> I like the idea of allowing the caller to provide their own custom
>> ExecutionException, but I would prefer if it were used only for execution
>> exceptions...
>> 
>>> Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>> wrapped in an X (after restoring the interrupt).
>> 
>> I don't like this because it mixes remote and local.  And isn't the
>> InterruptedException already handled by your Uninterruptible form of Future?
>> 
>> (I don't want all Future.gets to be uninterruptible -- what's the point of
>> interrupting if nothing actually responds to it?)
>> 
>>> Is there any reason to wrap a raw RuntimeException thrown by get?
>> 
>> No.
>> 
>> Thoughts on revised policy:
>> 
>> Your revised policy only allows the programmer to provide a custom class
>> for an ExecutionException whose cause was checked.  But it's not clear to me
>> that a checked/unchecked exception in the context of the executor is also a
>> checked/unchecked exception in the context of the caller.  In some ways, the
>> revised policy is making it more difficult for the programmer who cares
>> about such things.
>> 
>> How about providing a form of Future.get where the caller supplies an
>> exception factory (or listener)?  Then they can decide on the execution
>> class at the point of failure.
>> 
>> Joe
>> 
>> On Thu, Jul 14, 2011 at 4:27 PM, Chris Povirk wrote:
>> 
>>> In the spirit of my earlier thread on InterruptedException-free wrappers
>>> for interruptible methods <http://markmail.org/message/bvh2yt3frtwpt45a> (digression:
>>> I'm now convinced that they shouldn't be used as widely as I thought, so
>>> thanks), I'm trying to simplify exception management in some common uses of
>>> concurrency utilities.  Right now, I'm looking at Future.get, which
>>> requires separate handling of at least two exception types -- as well it
>>> should for maximum generality, but that isn't much consolation for people
>>> who just want to know "Did it work or not?"  In my experience, in a typical
>>> webapp, I would often by happier with code like this:
>>> 
>>> public Result getResult() throws MyException {
>>>  return Futures.get(future, MyException.class)<http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/util/concurrent/Futures.html#get%28java.util.concurrent.Future,%20java.lang.Class%29>
>>> ;
>>> }
>>> 
>>> So, we're trying out such a method in Guava.  To quote from the Javadoc
>>> (though I'd recommend following the link above for the whole thing):
>>> 
>>> Exceptions from Future.get are treated as follows:
>>> 
>>>   - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>>>   wrapped in an X (after restoring the interrupt).
>>>   - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> is
>>>   propagated untouched.
>>>   - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>>>   its *cause* wrapped in an X.
>>>   - Any RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> other
>>>   than CancellationException (get implementations are discouraged from
>>>   throwing such exceptions) is wrapped in an X.
>>> 
>>> In broad strokes, I'm happy with this.  But I can imagine some tweaks
>>> around the edges:
>>> 
>>>   - Is there any reason to wrap a raw RuntimeException thrown by get?
>>>    Probably it comes from the calling thread, so we don't need to wrap it to
>>>   give a proper stack trace.  Meanwhile, we're converting an unchecked
>>>   exception to a checked exception unnecessarily.  Then again, is there any
>>>   great harm, since the type we're converting to is a type that the caller
>>>   already must handle?  Still, we're converting between unchecked exceptions
>>>   ("the programmer's fault") and checked exceptions ("not the programmer's
>>>   fault").  Future.get already does this by wrapping any unchecked
>>>   exception from the task itself in a checked ExecutionException, but
>>>   should we follow that example if it's bad?
>>>   - The previous point, though, addresses only a small issue: a raw
>>>   RuntimeException thrown by get, which shouldn't even occur.  More
>>>   interesting is the question of what to do if an ExecutionExceptionwraps an unchecked cause.  Why wrap that cause in a checked exception when
>>>   we could wrap it in an unchecked exception?  As it turns out, for unrelated
>>>   reasons, we are adding an UncheckedExecutionException class, which
>>>   would be the perfect wrapper here.
>>>   - We could do something similar when an ExecutionException wraps an
>>>   Error cause if we added an ExecutionError class (even a private one,
>>>   or we could use Error itself if the new type is objectionable).  It
>>>   seems bad that an Error is downgraded to a boring Exception when it
>>>   occurs in an executor-spawned task.  In principle, we should check whether
>>>   every ExecutionException is caused by an Error, but I admit I've never
>>>   done this, and I don't think I've never seen anyone else do it, either.
>>> 
>>> That would give us this revised policy:
>>> 
>>> Exceptions from Future.get are treated as follows:
>>> 
>>>   - Any InterruptedException<http://download.oracle.com/javase/6/docs/api/java/lang/InterruptedException.html?is-external=true> is
>>>   wrapped in an X (after restoring the interrupt).
>>>   - Any CancellationException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CancellationException.html?is-external=true> or
>>>   other raw RuntimeException<http://download.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true> is
>>>   propagated untouched.
>>>   - Any ExecutionException<http://download.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutionException.html?is-external=true> has
>>>   its *cause* unwrapped and rewrapped, with the new type depending on
>>>   the type of the cause:
>>>      - If the cause was a checked exception, it is wrapped in an X.
>>>      - If the cause was an unchecked exception, it is wrapped in an
>>>      UncheckedExecutionException.
>>>      - If the cause was an error, it is wrapped in an ExecutionError.
>>> 
>>> That's just a discussion starter, though.  I'd be happy to hear comments
>>> on any part of this.  Thanks.
>>> 
>>> (For the source, see Futures.java<http://guava-libraries.googlecode.com/svn/trunk/guava/src/com/google/common/util/concurrent/Futures.java>.
>>> Search for "converting most exceptions.")
>>> 
>> 
>> 
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110714/829a0b45/attachment-0001.html>
> 
> ------------------------------
> 
> Message: 2
> Date: Thu, 14 Jul 2011 18:51:51 -0700
> From: Chris Povirk <cpovirk at google.com>
> Subject: Re: [concurrency-interest] Future.get exception mapping
> To: Joe Bowbeer <joe.bowbeer at gmail.com>
> Cc: concurrency-interest at cs.oswego.edu
> Message-ID:
> 	<CAEvq2nowdpLJjn8H2tZUZCOU02bV4Jh6xdb6m2yVB48=3Ci4Rw at mail.gmail.com>
> Content-Type: text/plain; charset=ISO-8859-1
> 
>> Re-wrapping un/checked exceptions doesn't concern me as much as I am
>> concerned by mixing remote "execution" exceptions with local (non-execution)
>> exceptions, where execution exceptions were thrown by the future's callable
>> executing on the executor thread, and local exceptions were thrown by the
>> calling thread.
>> I like the idea of allowing the caller to provide their own custom
>> ExecutionException, but I would prefer if it were used only for execution
>> exceptions...
>>> ?Any?InterruptedException?is wrapped in an?X?(after restoring the
>>> interrupt).
>> I don't like this because it mixes remote and local.
> 
> This is simultaneously the heart of the method and the part I least
> want to talk about :)  By that, I basically mean that I have my heart
> set on adding a method that mixes remote and local exceptions.  (So
> really I'm happy to talk about, but I may be a poor listener :))
> That's because my primary goal is to collapse all the Future.get
> exceptions into one exception type.  Many users of Future won't want
> this, of course, but writing 2-3 catch blocks when all I care about it
> success vs. failure drives me crazy, so I just want to solve that
> case.  One way to do this is to change getUninterruptibly to also
> accept an exception mapper for ExecutionException only.  This solves
> the problem at the cost of messing with the interrupt system (see
> below) -- at least if you don't use the timed get() and introduce
> TimeoutException.
> 
>> And isn't the
>> InterruptedException already handled by your Uninterruptible form of Future?
>> (I don't want all Future.gets to be uninterruptible -- what's the point of
>> interrupting if nothing actually responds to it?)
> 
> The new method would be a competitor to getUninterruptibly, and this
> is by design: I'm hoping that it will eat into getUninterruptibly's
> market share so that more Future uses remain interruptible.
> 
> Setting aside the question of the new Guava method, I'm wondering what
> you do with InterruptedException when calling Future.get in MyService:
> 
> 1. use getUninterruptibly
> 2. catch it, restore interrupt, and throw MyServiceException
> 3. declare each MyService method to throw both MyServiceException and
> InterruptedException[*]
> 4. something else?
> 
> If there's another option out there, maybe the new Guava method should
> do it instead.  Ideas, anyone?
> 
> [*] Of course, (3) is an option, but it feels like an abstraction
> violation in some cases (in the same way that throwing IOException
> from MyDatabaseService would be: Why should my callers care if I use
> threads internally and in such a way that allows for interruption?).
> Further, because interruption means cancellation for all practical
> purposes, it _kind of_ doesn't matter what we do when we're
> interrupted, as long as we stop doing it quickly.  Sure, if I'm
> writing low-level concurrency code, I might need to catch
> InterruptedException specifically so that I can restore some
> invariants before blowing up, but if I'm writing MyDatabaseService, my
> users already expect for me to throw exceptions, so they either won't
> have these invariants or will already have a try-finally to deal with
> them.  The Guava method exists for the MyDatabaseService guy.  (And
> here comes my secret motivation: A lot of MyDatabaseService guys are
> going to write "catch (InterruptedException e) {}" and thus neither
> abort quickly nor finish the job.  Interruption is complicated :( ...
> )
> 
>> Thoughts on revised policy:
>> Your revised policy only allows the programmer to provide a custom class for
>> an ExecutionException whose cause was checked. ?But it's not clear to me
>> that a checked/unchecked exception in the context of the executor is also a
>> checked/unchecked exception in the context of the caller. ?In some ways, the
>> revised policy is making it more difficult for the programmer who cares
>> about such things.
> 
> True, the caller might well want to convert unchecked exceptions to
> checked.  I've often wanted to convert a NumberFormatException into
> some kind of checked exception, for instance, and it might be better
> overall if MyDataService threw only MyDataServiceException (instead of
> NPE, etc.) so that, when it failed, I could treat a NPE like any other
> "I couldn't get data" failure, rather than as a failure of unknown
> source that causes us to abort rendering the web app entirely.  Then
> again, I probably track statistics for MyDataServiceExceptions
> separately from RuntimeExceptions, since the former may indicate
> transient timeouts but the latter bugs, so I don't necessarily want to
> convert the latter to the former.
> 
> Overall, I guess I view "exception came from another thread" as an
> implementation detail that shouldn't affect whether it's checked or
> unchecked from the perspective of the caller.  I would find it equally
> useful (and equally dangerous) to be able to automatically convert
> from unchecked to checked exceptions for in-thread operations.
> Ultimately, such conversions feel more dangerous than useful to me,
> but I'm far from certain.
> 
>> How about providing a form of Future.get where the caller supplies an
>> exception factory (or listener)? ?Then they can decide on the execution
>> class at the point of failure.
> 
> If you mean what I think you mean, the answer is that I haven't found
> a library to save a lot of code over the manual approach.  Compare:
> 
> public static <V> V getWithMyException(Future<V> future) throws MyException {
>   checkNotNull(future);
>   try {
>     return future.get();
>   } catch (InterruptedException e) {
>     currentThread().interrupt();
>     throw new MyException(e);
>   } catch (CancellationException e) {
>     throw e;
>   } catch (ExecutionException e) {
>     throw new MyException(e.getCause());
>   }
> }
> 
> public static <V> V getWithMyException(Future<V> future) throws MyException {
>   return Futures.get(future, new Thrower<MyException>() {
>     @Override public void convertAndThrow(Throwable e) throws MyException {
>       if (e instanceof InterruptedException) {
>         throw new MyException(e); // library will call interrupt() for you
>       } else if (e instanceof CancellationException) {
>         throw (CancellationException) e;
>       } else {
>         throw new MyException(e); // library will have unwrapped for you
>       }
>     }
>   });
> }
> 
> I do think that such manual conversions can play a role in the overall
> mission of taming Future.get's exceptions.
> 
> Thanks for the comments!
> 
> 
> 
> ------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> End of Concurrency-interest Digest, Vol 78, Issue 8
> ***************************************************



From mbien at fh-landshut.de  Sat Jul 16 17:15:08 2011
From: mbien at fh-landshut.de (Michael Bien)
Date: Sat, 16 Jul 2011 23:15:08 +0200
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
Message-ID: <4E21FF5C.4050000@fh-landshut.de>

On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
> Just an FYI - in case you guys haven't heard about the ultra-low 
> latency data structure: http://www.infoq.com/presentations/LMAX - 
> http://code.google.com/p/disruptor/
>
>
> Ashwin (http://www.ashwinjayaprakash.com)
yep, nothing entirely new in it but that makes it even more interesting :)
direct link to the paper: 
http://disruptor.googlecode.com/files/Disruptor-1.0.pdf

regards,
michael

From joe.bowbeer at gmail.com  Sat Jul 16 20:31:49 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 16 Jul 2011 17:31:49 -0700
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <4E21FF5C.4050000@fh-landshut.de>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
	<4E21FF5C.4050000@fh-landshut.de>
Message-ID: <CAHzJPEqXgDv=xbuSMxYvFEptRPg5+bYNYC2yP5PrBrj83Fk-UQ@mail.gmail.com>

Recent article by Martin Fowler:

http://martinfowler.com/articles/lmax.html

On Sat, Jul 16, 2011 at 2:15 PM, Michael Bien wrote:

> On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
>
>> Just an FYI - in case you guys haven't heard about the ultra-low latency
>> data structure: http://www.infoq.com/**presentations/LMAX<http://www.infoq.com/presentations/LMAX>-
>> http://code.google.com/p/**disruptor/<http://code.google.com/p/disruptor/>
>>
>>
>> Ashwin (http://www.ashwinjayaprakash.**com<http://www.ashwinjayaprakash.com>
>> )
>>
> yep, nothing entirely new in it but that makes it even more interesting :)
> direct link to the paper: http://disruptor.googlecode.**
> com/files/Disruptor-1.0.pdf<http://disruptor.googlecode.com/files/Disruptor-1.0.pdf>
>
> regards,
> michael
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110716/0124111b/attachment.html>

From nichole.king at gmail.com  Sat Jul 16 21:14:02 2011
From: nichole.king at gmail.com (Nichole King)
Date: Sat, 16 Jul 2011 18:14:02 -0700
Subject: [concurrency-interest]   Future.get exception mapping
In-Reply-To: <mailman.39.1310814157.3597.concurrency-interest@cs.oswego.edu>
References: <mailman.39.1310814157.3597.concurrency-interest@cs.oswego.edu>
Message-ID: <BCE1724E-9EF2-45A6-A718-F515ACAD3F72@gmail.com>


Wanted to clarify that if the JDK did allow parameterized exceptions without erasure, that supplying a list
of exceptions to your concurrent API would be even better as JDK 7 allows for multiple exceptions in a single catch
so you'd be able to code for those in your try/catch on one block and then cancel, interrupted, and execution
in their own.   

The existing structure in FutureTask allows you to recover any exception you're interested in via executionexception's
getcause as you mentioned by the way.

But, back to the main question, can you recycle all exceptions that are not cancel, interrupted, and execution
into one exception specified by the developer if you wanted to?  And that again points me right back to the previous
paragraph, but continuing on the track of other solutions:
     Specializing Callable and the exception of interest as an argument to a class like FutureTask is one part
of a solution, but it still requires that the try/catch structure around running the injected callable be handled
in specialized manner too.  FutureTask's implementation of that section of logic is in FutureTask$Sync.innerRun().
Redesigning those 2 elements to be injectable as one in a thread safe manner?  









From joe.bowbeer at gmail.com  Sun Jul 17 00:21:04 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sat, 16 Jul 2011 21:21:04 -0700
Subject: [concurrency-interest] Future.get exception mapping
In-Reply-To: <4E417918-D4BD-491C-BB56-308E24134EB0@gmail.com>
References: <mailman.30.1310694715.3597.concurrency-interest@cs.oswego.edu>
	<4E417918-D4BD-491C-BB56-308E24134EB0@gmail.com>
Message-ID: <CAHzJPEo-5xrVjS=ew0QPQfPmQtiusT3oTArHuEqranyPK+Vf8Q@mail.gmail.com>

I like the idea of attacking this at the Callable site.

In this way, I view the goal as in-lining the remote execution of a
Callable.  That is: treating a RPC as if it were performed inline.

In this case, the InterruptedException (and CancellationException and
TimeoutException) should not concern the caller, so let them be unchecked
exceptions or errors, and what remains is to devise a way to tunnel the
Callable's exception through the Future API, to the caller's thread.

(http://www.c2.com/cgi/wiki?ExceptionTunneling)

On Sat, Jul 16, 2011 at 4:02 AM, Nichole King wrote:

> Using a parameterized type for an exception, that is <E extends Exception>
> is possible in
> class and method signatures and is usable just about everywhere *except* in
> the
> catch block where you would want to check for the type.
> The exception parameter type E is erased to Exception at runtime so you
> can't
> use it in the catch block ( can't use  } catch (E exception) { )
>
> If you wanted to use a specialized exception, you would have to offer that
> as a concrete class in your API.  And your suggestions on testing for that
> in try/catch along
> with CancellationException, InterruptedException, and ExecutionException
> would be necessary.
>
> If you wanted to supply a constructor or other method that takes an
> argument for Callable
> like FutureTask does, then you could provide an interface that uses the new
> exception class
> also to make it slightly more typed:
>
>   Extend Callable:
>        interface ICustomCallable<V> extends Callable<V> {
>            @Override
>            V call() throws CustomException;
>       }
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110716/2dbd3754/attachment.html>

From mohanr at fss.co.in  Mon Jul 18 04:07:31 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Mon, 18 Jul 2011 13:37:31 +0530
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEJOIOAA.davidcholmes@aapt.net.au>
Message-ID: <025153D79DA9884ABDF85638747FD497088971@fssbemail.fss.india>

Hi David,

                 Maybe I should work out FJ examples which I haven't but
I have used j.u.c. I am still not able to understand how multiple cores
are being used better if the software does not make use of them.  Does
the Java threading API/FJ or the way the JVM is written for a platform
make use of cores better ?

 

 

Thanks,

Mohan

 

________________________________

From: David Holmes [mailto:davidcholmes at aapt.net.au] 
Sent: Saturday, July 16, 2011 4:05 PM
To: Mohan Radhakrishnan; concurrency-interest
Subject: RE: [concurrency-interest] Difference between FJ and kernel
tuning

 

I have no idea what kind of kernel tuning you are referring to, so I
have no idea what possible relationship it has to FJ. FJ is "simply" a
fine-grained fork/join framework that employs work stealing.

 

David Holmes

	-----Original Message-----
	From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mohan
Radhakrishnan
	Sent: Friday, 15 July 2011 5:49 PM
	To: concurrency-interest
	Subject: [concurrency-interest] Difference between FJ and kernel
tuning

	Hi,

	 

	         I have come across an offer to tune the HP-UX kernel to
parallelize the threads across the available cores for a normal threaded
Java program. Not being an expert the meaning of 'parallelize' is not
obvious to me. I think it means something like apparent parallelization.

	 

	How does FJ and this type of kernel tuning compare with each
other ? Do some OS's obviate the need for FJ using kernel facilities ? I
really don't know what type of OS theads are being referred to here ?

	 

	Are there any helpful references ?

	 

	Thanks.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110718/ce300d20/attachment.html>

From davidcholmes at aapt.net.au  Mon Jul 18 05:35:00 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 18 Jul 2011 19:35:00 +1000
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <025153D79DA9884ABDF85638747FD497088971@fssbemail.fss.india>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEKMIOAA.davidcholmes@aapt.net.au>

Hi Mohan,

The Sun/Oracle JDK uses native threads on all platforms and so automatically
makes use of multiple cores and processors.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mohan
Radhakrishnan
  Sent: Monday, 18 July 2011 6:08 PM
  To: concurrency-interest
  Subject: Re: [concurrency-interest] Difference between FJ and kernel
tuning


  Hi David,

                   Maybe I should work out FJ examples which I haven't but I
have used j.u.c. I am still not able to understand how multiple cores are
being used better if the software does not make use of them.  Does the Java
threading API/FJ or the way the JVM is written for a platform make use of
cores better ?





  Thanks,

  Mohan




----------------------------------------------------------------------------
--

  From: David Holmes [mailto:davidcholmes at aapt.net.au]
  Sent: Saturday, July 16, 2011 4:05 PM
  To: Mohan Radhakrishnan; concurrency-interest
  Subject: RE: [concurrency-interest] Difference between FJ and kernel
tuning



  I have no idea what kind of kernel tuning you are referring to, so I have
no idea what possible relationship it has to FJ. FJ is "simply" a
fine-grained fork/join framework that employs work stealing.



  David Holmes

    -----Original Message-----
    From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mohan
Radhakrishnan
    Sent: Friday, 15 July 2011 5:49 PM
    To: concurrency-interest
    Subject: [concurrency-interest] Difference between FJ and kernel tuning

    Hi,



             I have come across an offer to tune the HP-UX kernel to
parallelize the threads across the available cores for a normal threaded
Java program. Not being an expert the meaning of 'parallelize' is not
obvious to me. I think it means something like apparent parallelization.



    How does FJ and this type of kernel tuning compare with each other ? Do
some OS's obviate the need for FJ using kernel facilities ? I really don't
know what type of OS theads are being referred to here ?



    Are there any helpful references ?



    Thanks.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110718/3a507694/attachment.html>

From gregg at cytetech.com  Mon Jul 18 13:42:32 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Mon, 18 Jul 2011 12:42:32 -0500
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <4E21FF5C.4050000@fh-landshut.de>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
	<4E21FF5C.4050000@fh-landshut.de>
Message-ID: <4E247088.7090504@cytetech.com>

On 7/16/2011 4:15 PM, Michael Bien wrote:
> On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
>> Just an FYI - in case you guys haven't heard about the ultra-low latency data
>> structure: http://www.infoq.com/presentations/LMAX -
>> http://code.google.com/p/disruptor/
>>
>>
>> Ashwin (http://www.ashwinjayaprakash.com)
> yep, nothing entirely new in it but that makes it even more interesting :)
> direct link to the paper: http://disruptor.googlecode.com/files/Disruptor-1.0.pdf

The one new thing which I see is that your CPU usage will stay at 100%.  Without 
out "wait" based locks, the continuous spinning will peg CPU usage.

The work stealing ideas of FJ are about making sure CPUs stay used.  I wonder if 
the flow through this system, and others which might use disruptors will be 
balanced in such a way that all cores will be fully utilized.  This looks like a 
fine system for data flows that are "busy", and balanced.  But what happens when 
there is an imbalance in data flow?

Gregg Wonderly

From gergg at cox.net  Mon Jul 18 13:58:02 2011
From: gergg at cox.net (Gregg Wonderly)
Date: Mon, 18 Jul 2011 12:58:02 -0500
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEKMIOAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAEKMIOAA.davidcholmes@aapt.net.au>
Message-ID: <4E24742A.1000604@cox.net>

On 7/18/2011 4:35 AM, David Holmes wrote:
> Hi Mohan,
> The Sun/Oracle JDK uses native threads on all platforms and so automatically
> makes use of multiple cores and processors.

In operating systems and programming language libraries where the large majority 
of "work" is done by "calling to wait", it is very difficult to make effective 
use of concurrency.  On the other hand, in OSes and programming language 
libraries where "work is initiated" and "callbacks signal success", it would be 
much easier for the "kernel" to be the thread manager for everything, instead of 
having to invent things like the Fork-Join framework.

VMS, in particular (perhaps why HP is mentioned), can do all I/O and kernel 
interaction this way.  It makes it very easy to write focused code where "tasks" 
are always just functions/methods, instead of sequences of calls.

On MacOS-X and iOS, networking can be done this way (the RunLoop is really where 
the mechanism is, but never the less, tasks on the RunLoop are dispatched 
without programmer directed "waiting").

In the world of Java, the tie to "Solaris"/Unix and poll/select, system-5 IPC, 
conventional open, close, read/write all tie us into this programmer controlled 
concurrency which can create the completely wrong parallel to the hardware 
mechanisms, as this project points out.

I hope HP does something which help stimulates a drive to completely reverse the 
mechanisms of how programmers interact with concurrency.

Gregg

> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Mohan
>     Radhakrishnan
>     *Sent:* Monday, 18 July 2011 6:08 PM
>     *To:* concurrency-interest
>     *Subject:* Re: [concurrency-interest] Difference between FJ and kernel tuning
>
>     Hi David,
>
>     Maybe I should work out FJ examples which I haven?t but I have used j.u.c. I
>     am still not able to understand how multiple cores are being used better if
>     the software does not make use of them. Does the Java threading API/FJ or
>     the way the JVM is written for a platform make use of cores better ?
>
>     Thanks,
>
>     Mohan
>
>     --------------------------------------------------------------------------------
>
>     *From:*David Holmes [mailto:davidcholmes at aapt.net.au]
>     *Sent:* Saturday, July 16, 2011 4:05 PM
>     *To:* Mohan Radhakrishnan; concurrency-interest
>     *Subject:* RE: [concurrency-interest] Difference between FJ and kernel tuning
>
>     I have no idea what kind of kernel tuning you are referring to, so I have no
>     idea what possible relationship it has to FJ. FJ is "simply" a fine-grained
>     fork/join framework that employs work stealing.
>
>     David Holmes
>
>         -----Original Message-----
>         *From:* concurrency-interest-bounces at cs.oswego.edu
>         [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Mohan
>         Radhakrishnan
>         *Sent:* Friday, 15 July 2011 5:49 PM
>         *To:* concurrency-interest
>         *Subject:* [concurrency-interest] Difference between FJ and kernel tuning
>
>         Hi,
>
>         I have come across an offer to tune the HP-UX kernel to parallelize the
>         threads across the available cores for a normal threaded Java program.
>         Not being an expert the meaning of ?parallelize? is not obvious to me. I
>         think it means something like apparent parallelization.
>
>         How does FJ and this type of kernel tuning compare with each other ? Do
>         some OS?s obviate the need for FJ using kernel facilities ? I really
>         don?t know what type of OS theads are being referred to here ?
>
>         Are there any helpful references ?
>
>         Thanks.
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From jallen at chariotsolutions.com  Mon Jul 18 14:02:02 2011
From: jallen at chariotsolutions.com (Jamie Allen)
Date: Mon, 18 Jul 2011 14:02:02 -0400
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <4E247088.7090504@cytetech.com>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
	<4E21FF5C.4050000@fh-landshut.de> <4E247088.7090504@cytetech.com>
Message-ID: <CACfx=ZTKprgmN4n74dbqfJRx6PVFotOn7bYV==aSm8Nag29wXg@mail.gmail.com>

Gregg - agreed, this is a specialized architecture for handling data that is
always coming in.  And I think they're trading off the ability to re-use
that core to maintain cache locality.  When the system has to handle high
throughput, they can't afford the performance cost of rebuilding that cache
for another core and/or synching it.

This is definitely a solution for a specific problem set, not a
one-size-fits-all kind of thing.

On Mon, Jul 18, 2011 at 1:42 PM, Gregg Wonderly <gregg at cytetech.com> wrote:

> On 7/16/2011 4:15 PM, Michael Bien wrote:
>
>> On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
>>
>>> Just an FYI - in case you guys haven't heard about the ultra-low latency
>>> data
>>> structure: http://www.infoq.com/**presentations/LMAX<http://www.infoq.com/presentations/LMAX>-
>>> http://code.google.com/p/**disruptor/<http://code.google.com/p/disruptor/>
>>>
>>>
>>> Ashwin (http://www.ashwinjayaprakash.**com<http://www.ashwinjayaprakash.com>
>>> )
>>>
>> yep, nothing entirely new in it but that makes it even more interesting :)
>> direct link to the paper: http://disruptor.googlecode.**
>> com/files/Disruptor-1.0.pdf<http://disruptor.googlecode.com/files/Disruptor-1.0.pdf>
>>
>
> The one new thing which I see is that your CPU usage will stay at 100%.
>  Without out "wait" based locks, the continuous spinning will peg CPU usage.
>
> The work stealing ideas of FJ are about making sure CPUs stay used.  I
> wonder if the flow through this system, and others which might use
> disruptors will be balanced in such a way that all cores will be fully
> utilized.  This looks like a fine system for data flows that are "busy", and
> balanced.  But what happens when there is an imbalance in data flow?
>
> Gregg Wonderly
>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Jamie Allen
Chariot Solutions
515 Pennsylvania Ave., Suite 202
Fort Washington, PA 19034
O: 215-358-1780, x481
M: 610-739-9445
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110718/b523dd20/attachment.html>

From mbien at fh-landshut.de  Mon Jul 18 14:01:35 2011
From: mbien at fh-landshut.de (Michael Bien)
Date: Mon, 18 Jul 2011 20:01:35 +0200
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <4E247088.7090504@cytetech.com>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
	<4E21FF5C.4050000@fh-landshut.de> <4E247088.7090504@cytetech.com>
Message-ID: <4E2474FF.3030209@fh-landshut.de>


On 07/18/2011 07:42 PM, Gregg Wonderly wrote:
> On 7/16/2011 4:15 PM, Michael Bien wrote:
>> On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
>>> Just an FYI - in case you guys haven't heard about the ultra-low 
>>> latency data
>>> structure: http://www.infoq.com/presentations/LMAX -
>>> http://code.google.com/p/disruptor/
>>>
>>>
>>> Ashwin (http://www.ashwinjayaprakash.com)
>> yep, nothing entirely new in it but that makes it even more 
>> interesting :)
>> direct link to the paper: 
>> http://disruptor.googlecode.com/files/Disruptor-1.0.pdf
>
> The one new thing which I see is that your CPU usage will stay at 
> 100%.  Without out "wait" based locks, the continuous spinning will 
> peg CPU usage.
>
> The work stealing ideas of FJ are about making sure CPUs stay used.  I 
> wonder if the flow through this system, and others which might use 
> disruptors will be balanced in such a way that all cores will be fully 
> utilized.  This looks like a fine system for data flows that are 
> "busy", and balanced.  But what happens when there is an imbalance in 
> data flow?
>
> Gregg Wonderly
>

sure its only applicable for a small subset of usecases. Not only 
balance in tasksize is needed, all tasks of one stage must be of the 
same type. It really is a dedicated pipeline not a pool. I can imagine 
gameservers or multimedia servers could benefit from this kind of 
architecture.

regards,
michael bien

From davidcholmes at aapt.net.au  Mon Jul 18 21:41:22 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 19 Jul 2011 11:41:22 +1000
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <4E24742A.1000604@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCAELCIOAA.davidcholmes@aapt.net.au>

Gregg,

Gregg Wonderly wrote on Tuesday, 19 July 2011 3:58 AM:
> On 7/18/2011 4:35 AM, David Holmes wrote:
> > Hi Mohan,
> > The Sun/Oracle JDK uses native threads on all platforms and so
> > automatically makes use of multiple cores and processors.
>
> In operating systems and programming language libraries where the
> large majority of "work" is done by "calling to wait", it is very
> difficult to make effective use of concurrency.  On the other hand,
> in OSes and programming language libraries where "work is initiated"
> and "callbacks signal success", it would be much easier for the
> "kernel" to be the thread manager for everything, instead of
> having to invent things like the Fork-Join framework.

I fail to see what the connection is between Fork-Join and whether you use
blocking-synchronous, or non-blocking-asynchronous APIs ??? FJ is about
compute-intensive tasks.

While I really don't understand what Mohan is asking about, I have trouble
making the connection to your sync/async I/O commentary.

Cheers,
David
-----

> VMS, in particular (perhaps why HP is mentioned), can do all I/O
> and kernel
> interaction this way.  It makes it very easy to write focused
> code where "tasks"
> are always just functions/methods, instead of sequences of calls.
>
> On MacOS-X and iOS, networking can be done this way (the RunLoop
> is really where
> the mechanism is, but never the less, tasks on the RunLoop are dispatched
> without programmer directed "waiting").
>
> In the world of Java, the tie to "Solaris"/Unix and poll/select,
> system-5 IPC,
> conventional open, close, read/write all tie us into this
> programmer controlled
> concurrency which can create the completely wrong parallel to the
> hardware
> mechanisms, as this project points out.
>
> I hope HP does something which help stimulates a drive to
> completely reverse the
> mechanisms of how programmers interact with concurrency.
>
> Gregg
>
> > David
> >
> >     -----Original Message-----
> >     *From:* concurrency-interest-bounces at cs.oswego.edu
> >     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
> Behalf Of *Mohan
> >     Radhakrishnan
> >     *Sent:* Monday, 18 July 2011 6:08 PM
> >     *To:* concurrency-interest
> >     *Subject:* Re: [concurrency-interest] Difference between FJ
> and kernel tuning
> >
> >     Hi David,
> >
> >     Maybe I should work out FJ examples which I haven?t but I
> have used j.u.c. I
> >     am still not able to understand how multiple cores are
> being used better if
> >     the software does not make use of them. Does the Java
> threading API/FJ or
> >     the way the JVM is written for a platform make use of cores better ?
> >
> >     Thanks,
> >
> >     Mohan
> >
> >
> ------------------------------------------------------------------
> --------------
> >
> >     *From:*David Holmes [mailto:davidcholmes at aapt.net.au]
> >     *Sent:* Saturday, July 16, 2011 4:05 PM
> >     *To:* Mohan Radhakrishnan; concurrency-interest
> >     *Subject:* RE: [concurrency-interest] Difference between FJ
> and kernel tuning
> >
> >     I have no idea what kind of kernel tuning you are referring
> to, so I have no
> >     idea what possible relationship it has to FJ. FJ is
> "simply" a fine-grained
> >     fork/join framework that employs work stealing.
> >
> >     David Holmes
> >
> >         -----Original Message-----
> >         *From:* concurrency-interest-bounces at cs.oswego.edu
> >         [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
> Behalf Of *Mohan
> >         Radhakrishnan
> >         *Sent:* Friday, 15 July 2011 5:49 PM
> >         *To:* concurrency-interest
> >         *Subject:* [concurrency-interest] Difference between FJ
> and kernel tuning
> >
> >         Hi,
> >
> >         I have come across an offer to tune the HP-UX kernel to
> parallelize the
> >         threads across the available cores for a normal
> threaded Java program.
> >         Not being an expert the meaning of ?parallelize? is not
> obvious to me. I
> >         think it means something like apparent parallelization.
> >
> >         How does FJ and this type of kernel tuning compare with
> each other ? Do
> >         some OS?s obviate the need for FJ using kernel
> facilities ? I really
> >         don?t know what type of OS theads are being referred to here ?
> >
> >         Are there any helpful references ?
> >
> >         Thanks.
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>



From mohanr at fss.co.in  Tue Jul 19 01:37:15 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Tue, 19 Jul 2011 11:07:15 +0530
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <4E24742A.1000604@cox.net>
Message-ID: <025153D79DA9884ABDF85638747FD497088BD9@fssbemail.fss.india>

Hi,

    My question could be based on the misconception ? that FJ's
algorithms  are relevant to multiple cores and their effective
utilization. It now looks like that is not the case.
       
>VMS, in particular (perhaps why HP is mentioned), can do all I/O and
kernel 
>interaction this way.  It makes it very easy to write focused code
where >"tasks" 
>are always just functions/methods, instead of sequences of calls.

I shouldn't have mentioned HP. It is mentioned only because we are using
HP-UX.

This was actually a question about FJ to understand the foundation.

Thanks,
Mohan

-----Original Message-----
From: Gregg Wonderly [mailto:gergg at cox.net] 
Sent: Monday, July 18, 2011 11:28 PM
To: dholmes at ieee.org
Cc: David Holmes; Mohan Radhakrishnan; concurrency-interest
Subject: Re: [concurrency-interest] Difference between FJ and kernel
tuning

On 7/18/2011 4:35 AM, David Holmes wrote:
> Hi Mohan,
> The Sun/Oracle JDK uses native threads on all platforms and so
automatically
> makes use of multiple cores and processors.

In operating systems and programming language libraries where the large
majority 
of "work" is done by "calling to wait", it is very difficult to make
effective 
use of concurrency.  On the other hand, in OSes and programming language

libraries where "work is initiated" and "callbacks signal success", it
would be 
much easier for the "kernel" to be the thread manager for everything,
instead of 
having to invent things like the Fork-Join framework.

VMS, in particular (perhaps why HP is mentioned), can do all I/O and
kernel 
interaction this way.  It makes it very easy to write focused code where
"tasks" 
are always just functions/methods, instead of sequences of calls.

On MacOS-X and iOS, networking can be done this way (the RunLoop is
really where 
the mechanism is, but never the less, tasks on the RunLoop are
dispatched 
without programmer directed "waiting").

In the world of Java, the tie to "Solaris"/Unix and poll/select,
system-5 IPC, 
conventional open, close, read/write all tie us into this programmer
controlled 
concurrency which can create the completely wrong parallel to the
hardware 
mechanisms, as this project points out.

I hope HP does something which help stimulates a drive to completely
reverse the 
mechanisms of how programmers interact with concurrency.

Gregg

> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
*Mohan
>     Radhakrishnan
>     *Sent:* Monday, 18 July 2011 6:08 PM
>     *To:* concurrency-interest
>     *Subject:* Re: [concurrency-interest] Difference between FJ and
kernel tuning
>
>     Hi David,
>
>     Maybe I should work out FJ examples which I haven't but I have
used j.u.c. I
>     am still not able to understand how multiple cores are being used
better if
>     the software does not make use of them. Does the Java threading
API/FJ or
>     the way the JVM is written for a platform make use of cores better
?
>
>     Thanks,
>
>     Mohan
>
>
------------------------------------------------------------------------
--------
>
>     *From:*David Holmes [mailto:davidcholmes at aapt.net.au]
>     *Sent:* Saturday, July 16, 2011 4:05 PM
>     *To:* Mohan Radhakrishnan; concurrency-interest
>     *Subject:* RE: [concurrency-interest] Difference between FJ and
kernel tuning
>
>     I have no idea what kind of kernel tuning you are referring to, so
I have no
>     idea what possible relationship it has to FJ. FJ is "simply" a
fine-grained
>     fork/join framework that employs work stealing.
>
>     David Holmes
>
>         -----Original Message-----
>         *From:* concurrency-interest-bounces at cs.oswego.edu
>         [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf
Of *Mohan
>         Radhakrishnan
>         *Sent:* Friday, 15 July 2011 5:49 PM
>         *To:* concurrency-interest
>         *Subject:* [concurrency-interest] Difference between FJ and
kernel tuning
>
>         Hi,
>
>         I have come across an offer to tune the HP-UX kernel to
parallelize the
>         threads across the available cores for a normal threaded Java
program.
>         Not being an expert the meaning of 'parallelize' is not
obvious to me. I
>         think it means something like apparent parallelization.
>
>         How does FJ and this type of kernel tuning compare with each
other ? Do
>         some OS's obviate the need for FJ using kernel facilities ? I
really
>         don't know what type of OS theads are being referred to here ?
>
>         Are there any helpful references ?
>
>         Thanks.
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From gregg at cytetech.com  Tue Jul 19 10:16:08 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 19 Jul 2011 09:16:08 -0500
Subject: [concurrency-interest] Difference between FJ and kernel tuning
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAELCIOAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCAELCIOAA.davidcholmes@aapt.net.au>
Message-ID: <4E2591A8.3090508@cytetech.com>

On 7/18/2011 8:41 PM, David Holmes wrote:
> Gregg,
>
> Gregg Wonderly wrote on Tuesday, 19 July 2011 3:58 AM:
>> On 7/18/2011 4:35 AM, David Holmes wrote:
>>> Hi Mohan,
>>> The Sun/Oracle JDK uses native threads on all platforms and so
>>> automatically makes use of multiple cores and processors.
>>
>> In operating systems and programming language libraries where the
>> large majority of "work" is done by "calling to wait", it is very
>> difficult to make effective use of concurrency.  On the other hand,
>> in OSes and programming language libraries where "work is initiated"
>> and "callbacks signal success", it would be much easier for the
>> "kernel" to be the thread manager for everything, instead of
>> having to invent things like the Fork-Join framework.
>
> I fail to see what the connection is between Fork-Join and whether you use
> blocking-synchronous, or non-blocking-asynchronous APIs ??? FJ is about
> compute-intensive tasks.

Yes, it is true that the target for FJ is interdependent, compute bound tasks 
(the join part) where "waiting" is a convenient point to "do some other 
dependent work" (the fork part and/with work stealing).

My point is that if he thought there was some relationship to kernel based 
threading optimization, that one of the things already done in kernels is 
rescheduling at "wait".  For me, that's a strong parallel to FJ's behavior 
outside of the kernel.  Inside the kernel is perhaps not as efficient, for 
today's processors...

I was also pointing out, my experience with callback and other async mechanisms 
being a simplifying mechanism for complex applications, such as network based 
communications or other high latency more asynchronous in behavior.

Calling into the kernel, to wait for a condition and then returning, is 
essentially twice as expensive as just having the kernel call out to you.  That 
latency is usually burned away in networking applications via multi-threading so 
that with enough threads doing the same thing, the latency disappears as a 
"wait" at the beginning and a "delay" at the end.

> While I really don't understand what Mohan is asking about, I have trouble
> making the connection to your sync/async I/O commentary.

I'm assuming some things about what I read into the question.  It sounds like 
he's still unsure of the FJ design domain.

Gregg

> Cheers,
> David
> -----
>
>> VMS, in particular (perhaps why HP is mentioned), can do all I/O
>> and kernel
>> interaction this way.  It makes it very easy to write focused
>> code where "tasks"
>> are always just functions/methods, instead of sequences of calls.
>>
>> On MacOS-X and iOS, networking can be done this way (the RunLoop
>> is really where
>> the mechanism is, but never the less, tasks on the RunLoop are dispatched
>> without programmer directed "waiting").
>>
>> In the world of Java, the tie to "Solaris"/Unix and poll/select,
>> system-5 IPC,
>> conventional open, close, read/write all tie us into this
>> programmer controlled
>> concurrency which can create the completely wrong parallel to the
>> hardware
>> mechanisms, as this project points out.
>>
>> I hope HP does something which help stimulates a drive to
>> completely reverse the
>> mechanisms of how programmers interact with concurrency.
>>
>> Gregg
>>
>>> David
>>>
>>>      -----Original Message-----
>>>      *From:* concurrency-interest-bounces at cs.oswego.edu
>>>      [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
>> Behalf Of *Mohan
>>>      Radhakrishnan
>>>      *Sent:* Monday, 18 July 2011 6:08 PM
>>>      *To:* concurrency-interest
>>>      *Subject:* Re: [concurrency-interest] Difference between FJ
>> and kernel tuning
>>>
>>>      Hi David,
>>>
>>>      Maybe I should work out FJ examples which I haven?t but I
>> have used j.u.c. I
>>>      am still not able to understand how multiple cores are
>> being used better if
>>>      the software does not make use of them. Does the Java
>> threading API/FJ or
>>>      the way the JVM is written for a platform make use of cores better ?
>>>
>>>      Thanks,
>>>
>>>      Mohan
>>>
>>>
>> ------------------------------------------------------------------
>> --------------
>>>
>>>      *From:*David Holmes [mailto:davidcholmes at aapt.net.au]
>>>      *Sent:* Saturday, July 16, 2011 4:05 PM
>>>      *To:* Mohan Radhakrishnan; concurrency-interest
>>>      *Subject:* RE: [concurrency-interest] Difference between FJ
>> and kernel tuning
>>>
>>>      I have no idea what kind of kernel tuning you are referring
>> to, so I have no
>>>      idea what possible relationship it has to FJ. FJ is
>> "simply" a fine-grained
>>>      fork/join framework that employs work stealing.
>>>
>>>      David Holmes
>>>
>>>          -----Original Message-----
>>>          *From:* concurrency-interest-bounces at cs.oswego.edu
>>>          [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
>> Behalf Of *Mohan
>>>          Radhakrishnan
>>>          *Sent:* Friday, 15 July 2011 5:49 PM
>>>          *To:* concurrency-interest
>>>          *Subject:* [concurrency-interest] Difference between FJ
>> and kernel tuning
>>>
>>>          Hi,
>>>
>>>          I have come across an offer to tune the HP-UX kernel to
>> parallelize the
>>>          threads across the available cores for a normal
>> threaded Java program.
>>>          Not being an expert the meaning of ?parallelize? is not
>> obvious to me. I
>>>          think it means something like apparent parallelization.
>>>
>>>          How does FJ and this type of kernel tuning compare with
>> each other ? Do
>>>          some OS?s obviate the need for FJ using kernel
>> facilities ? I really
>>>          don?t know what type of OS theads are being referred to here ?
>>>
>>>          Are there any helpful references ?
>>>
>>>          Thanks.
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From dl at cs.oswego.edu  Wed Jul 20 12:39:45 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 20 Jul 2011 12:39:45 -0400
Subject: [concurrency-interest] Package jsr166e
Message-ID: <4E2704D1.2000208@cs.oswego.edu>


We've created package jsr166e of classes ultimately targeted for jdk8
("e" for "eight"). Jars will also contain subpackage jsr166e.extra,
that includes possibly useful classes that rely on jsr166e, but
aren't currently planned for integration into java.util.concurrent.

The initial contents include preliminary forms of two classes that
for one reason or another have been left incompletely developed and
unreleased for too long:
   * SequenceLock -- a Lock that in some applications is usable as a
     cheaper alternative to ReadWriteLocks
   * StripedAdder -- an adder (often used as a counter) that
     greatly reduces contention when updated concurrently in many threads

There is also a jsr166e.extra.ReadMostlyVector class that
is an application of SequenceLocks -- covering a middle
ground between Vector (or Collections.synchronizedList(ArrayList))
versus CopyOnWriteArrayList.

Suggestions and especially usage reports about these would
be very welcome.

Get them in the usual way. Pasting from:
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

API specs:  http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/
jar file: http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166e.jar (compiled using 
Java7 javac).
Browsable CVS sources: 
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/

(test file sources and other related stuff still forthcoming.)

-Doug





From ktlam at cs.hku.hk  Thu Jul 21 14:00:07 2011
From: ktlam at cs.hku.hk (King Tin Lam)
Date: Fri, 22 Jul 2011 02:00:07 +0800
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why the
	'table' field of Segment has to be volatile?
In-Reply-To: <025153D79DA9884ABDF85638747FD497088BD9@fssbemail.fss.india>
References: <4E24742A.1000604@cox.net>
	<025153D79DA9884ABDF85638747FD497088BD9@fssbemail.fss.india>
Message-ID: <01ba01cc47d0$0890aa90$f8b10893@ktlampc>

Dear all,

For ConcurrentHashMap, I have difficulty in understanding why the 'table'
field of Segment needs to be declared volatile. It seems to me that reads /
writes on the volatile 'count' field have set up the necessary
happens-before edges for visibility.

Thanks a lot for your time.

Best regards,
King Tin
 


From davidcholmes at aapt.net.au  Thu Jul 21 19:38:03 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 22 Jul 2011 09:38:03 +1000
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
	the'table' field of Segment has to be volatile?
In-Reply-To: <01ba01cc47d0$0890aa90$f8b10893@ktlampc>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>

I don't see a volatile count field in ConcurrentHashMap.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King Tin
> Lam
> Sent: Friday, 22 July 2011 4:00 AM
> To: 'concurrency-interest'
> Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
> the'table' field of Segment has to be volatile?
> 
> 
> Dear all,
> 
> For ConcurrentHashMap, I have difficulty in understanding why the 'table'
> field of Segment needs to be declared volatile. It seems to me 
> that reads /
> writes on the volatile 'count' field have set up the necessary
> happens-before edges for visibility.
> 
> Thanks a lot for your time.
> 
> Best regards,
> King Tin
>  
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From kasper at kav.dk  Thu Jul 21 20:13:25 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Fri, 22 Jul 2011 02:13:25 +0200
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
 the'table' field of Segment has to be volatile?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
Message-ID: <4E28C0A5.4010208@kav.dk>

I think King is referring to the version of ConcurrentHashMap that was 
included in JDK 5+6 before Dougs latest changes.

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?revision=1.98&view=markup

Cheers
   Kasper

On 22-07-2011 01:38, David Holmes wrote:
> I don't see a volatile count field in ConcurrentHashMap.
>
> David Holmes
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King Tin
>> Lam
>> Sent: Friday, 22 July 2011 4:00 AM
>> To: 'concurrency-interest'
>> Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
>> the'table' field of Segment has to be volatile?
>>
>>
>> Dear all,
>>
>> For ConcurrentHashMap, I have difficulty in understanding why the 'table'
>> field of Segment needs to be declared volatile. It seems to me
>> that reads /
>> writes on the volatile 'count' field have set up the necessary
>> happens-before edges for visibility.
>>
>> Thanks a lot for your time.
>>
>> Best regards,
>> King Tin
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From ktlam at cs.hku.hk  Thu Jul 21 21:00:06 2011
From: ktlam at cs.hku.hk (King Tin Lam)
Date: Fri, 22 Jul 2011 09:00:06 +0800
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
	the'table' field of Segment has to be volatile?
In-Reply-To: <4E28C0A5.4010208@kav.dk>
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
	<4E28C0A5.4010208@kav.dk>
Message-ID: <01be01cc480a$b509c150$f8b10893@ktlampc>

Yes, yes, I am referring to JDK 5 or 6. 

That version of CHM contains three volatile fields:

// for Segment

transient volatile int count;

transient volatile HashEntry<K,V>[] table;

// for HashEntry

volatile V value;  

And I doubt why the second is needed. 

Best regards,
King Tin
 

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Kasper Nielsen
> Sent: Friday, July 22, 2011 8:13 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Question on ConcurrentHashMap: Why
> the'table' field of Segment has to be volatile?
> 
> I think King is referring to the version of ConcurrentHashMap that was
> included in JDK 5+6 before Dougs latest changes.
> 
> http://gee.cs.oswego.edu/cgi-
> bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.jav
> a?revision=1.98&view=markup
> 
> Cheers
>    Kasper
> 
> On 22-07-2011 01:38, David Holmes wrote:
> > I don't see a volatile count field in ConcurrentHashMap.
> >
> > David Holmes
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King
> Tin
> >> Lam
> >> Sent: Friday, 22 July 2011 4:00 AM
> >> To: 'concurrency-interest'
> >> Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
> >> the'table' field of Segment has to be volatile?
> >>
> >>
> >> Dear all,
> >>
> >> For ConcurrentHashMap, I have difficulty in understanding why the
> 'table'
> >> field of Segment needs to be declared volatile. It seems to me
> >> that reads /
> >> writes on the volatile 'count' field have set up the necessary
> >> happens-before edges for visibility.
> >>
> >> Thanks a lot for your time.
> >>
> >> Best regards,
> >> King Tin
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From ktlam at cs.hku.hk  Thu Jul 21 21:10:14 2011
From: ktlam at cs.hku.hk (King Tin Lam)
Date: Fri, 22 Jul 2011 09:10:14 +0800
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
	the'table' field of Segment has to be volatile?
In-Reply-To: <4E28C0A5.4010208@kav.dk>
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
	<4E28C0A5.4010208@kav.dk>
Message-ID: <01bf01cc480c$1ea48e50$f8b10893@ktlampc>

And by the way, sorry for a dummy question to confirm:

In put() method, 

  HashEntry[] tab = table;
  ...
  tab[index] = new HashEntry(key, hash, first, value);


I think the write on tab[index] is NOT a volatile write. 
The reference field 'table' is declared volatile, but writing the array
pointed by a volatile reference has nothing to relate with volatile. Am I
right?  

The line "tab = table" is a volatile read. Would it have anything useful?

Best regards,
King Tin
 

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Kasper Nielsen
> Sent: Friday, July 22, 2011 8:13 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Question on ConcurrentHashMap: Why
> the'table' field of Segment has to be volatile?
> 
> I think King is referring to the version of ConcurrentHashMap that was
> included in JDK 5+6 before Dougs latest changes.
> 
> http://gee.cs.oswego.edu/cgi-
> bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.jav
> a?revision=1.98&view=markup
> 
> Cheers
>    Kasper
> 
> On 22-07-2011 01:38, David Holmes wrote:
> > I don't see a volatile count field in ConcurrentHashMap.
> >
> > David Holmes
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King
> Tin
> >> Lam
> >> Sent: Friday, 22 July 2011 4:00 AM
> >> To: 'concurrency-interest'
> >> Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
> >> the'table' field of Segment has to be volatile?
> >>
> >>
> >> Dear all,
> >>
> >> For ConcurrentHashMap, I have difficulty in understanding why the
> 'table'
> >> field of Segment needs to be declared volatile. It seems to me
> >> that reads /
> >> writes on the volatile 'count' field have set up the necessary
> >> happens-before edges for visibility.
> >>
> >> Thanks a lot for your time.
> >>
> >> Best regards,
> >> King Tin
> >>
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Thu Jul 21 21:21:46 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 22 Jul 2011 11:21:46 +1000
Subject: [concurrency-interest] Question on ConcurrentHashMap:
	Whythe'table' field of Segment has to be volatile?
In-Reply-To: <01bf01cc480c$1ea48e50$f8b10893@ktlampc>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEMHIOAA.davidcholmes@aapt.net.au>



> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King Tin
> Lam
> Sent: Friday, 22 July 2011 11:10 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Question on ConcurrentHashMap:
> Whythe'table' field of Segment has to be volatile?
>
>
> And by the way, sorry for a dummy question to confirm:
>
> In put() method,
>
>   HashEntry[] tab = table;
>   ...
>   tab[index] = new HashEntry(key, hash, first, value);
>
>
> I think the write on tab[index] is NOT a volatile write.

Correct.

> The reference field 'table' is declared volatile, but writing the array
> pointed by a volatile reference has nothing to relate with volatile. Am I
> right?

Right.

> The line "tab = table" is a volatile read. Would it have anything useful?

It will ensure it reads the current value of table, and that segment will be
the one used for the rest of the operation via the tab reference.

David

> Best regards,
> King Tin
>
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> > interest-bounces at cs.oswego.edu] On Behalf Of Kasper Nielsen
> > Sent: Friday, July 22, 2011 8:13 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Question on ConcurrentHashMap: Why
> > the'table' field of Segment has to be volatile?
> >
> > I think King is referring to the version of ConcurrentHashMap that was
> > included in JDK 5+6 before Dougs latest changes.
> >
> > http://gee.cs.oswego.edu/cgi-
> >
> bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.jav
> > a?revision=1.98&view=markup
> >
> > Cheers
> >    Kasper
> >
> > On 22-07-2011 01:38, David Holmes wrote:
> > > I don't see a volatile count field in ConcurrentHashMap.
> > >
> > > David Holmes
> > >
> > >> -----Original Message-----
> > >> From: concurrency-interest-bounces at cs.oswego.edu
> > >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of King
> > Tin
> > >> Lam
> > >> Sent: Friday, 22 July 2011 4:00 AM
> > >> To: 'concurrency-interest'
> > >> Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
> > >> the'table' field of Segment has to be volatile?
> > >>
> > >>
> > >> Dear all,
> > >>
> > >> For ConcurrentHashMap, I have difficulty in understanding why the
> > 'table'
> > >> field of Segment needs to be declared volatile. It seems to me
> > >> that reads /
> > >> writes on the volatile 'count' field have set up the necessary
> > >> happens-before edges for visibility.
> > >>
> > >> Thanks a lot for your time.
> > >>
> > >> Best regards,
> > >> King Tin
> > >>
> > >>
> > >> _______________________________________________
> > >> Concurrency-interest mailing list
> > >> Concurrency-interest at cs.oswego.edu
> > >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >>
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at cs.oswego.edu
> > > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From crazybob at crazybob.org  Thu Jul 21 21:42:15 2011
From: crazybob at crazybob.org (Bob Lee)
Date: Thu, 21 Jul 2011 18:42:15 -0700
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
 the'table' field of Segment has to be volatile?
In-Reply-To: <01bf01cc480c$1ea48e50$f8b10893@ktlampc>
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
	<4E28C0A5.4010208@kav.dk> <01bf01cc480c$1ea48e50$f8b10893@ktlampc>
Message-ID: <CAGmsiP6Vuc=rm4UsyLHUVyEjBYQ4TzKBekRNEisUw=Jiiw9rNw@mail.gmail.com>

On Thu, Jul 21, 2011 at 6:10 PM, King Tin Lam <ktlam at cs.hku.hk> wrote:

> I think the write on tab[index] is NOT a volatile write.
>

That's correct. Writes to array entries are not volatile, and CHM does not
intend for this to be the case.

It looks like table needs to be volatile so a read sees the table in a
consistent state after a rehash(). put() can sometimes rehash without
setting count. Even when put() does set count, there's still a window
between the rehash and the set to count where a read could see an
inconsistent table.

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110721/19b8360e/attachment.html>

From ktlam at cs.hku.hk  Thu Jul 21 21:54:08 2011
From: ktlam at cs.hku.hk (King Tin Lam)
Date: Fri, 22 Jul 2011 09:54:08 +0800
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
	the'table' field of Segment has to be volatile?
In-Reply-To: <CAGmsiP6Vuc=rm4UsyLHUVyEjBYQ4TzKBekRNEisUw=Jiiw9rNw@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
	<4E28C0A5.4010208@kav.dk> <01bf01cc480c$1ea48e50$f8b10893@ktlampc>
	<CAGmsiP6Vuc=rm4UsyLHUVyEjBYQ4TzKBekRNEisUw=Jiiw9rNw@mail.gmail.com>
Message-ID: <01c301cc4812$426d1cc0$f8b10893@ktlampc>

Thank you David and Bob,

But not the put method has already acquired a lock over the segment from the
method beginning? So puts to the same segment should have been serialized.
The lock acquire and release among them should have ensured the
happens-before relation and required visibility including the update that
sets table to a new one due to rehashing. Also, rehashing is called by the
current thread calling put() but seeing the entry count is above threshold.
After the completion of rehash by the thread, it continues on the put. Then
why it could see an inconsistent table rehashed by itself under
synchronizing over the segment? 

Sorry for my misunderstanding.

Best regards,
King Tin
 

> -----Original Message-----
> From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of
> Bob Lee
> Sent: Friday, July 22, 2011 9:42 AM
> To: King Tin Lam
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Question on ConcurrentHashMap: Why
> the'table' field of Segment has to be volatile?
> 
> On Thu, Jul 21, 2011 at 6:10 PM, King Tin Lam <ktlam at cs.hku.hk> wrote:
> 
> 	I think the write on tab[index] is NOT a volatile write.
> 
> 
> 
> That's correct. Writes to array entries are not volatile, and CHM does not
> intend for this to be the case.
> 
> It looks like table needs to be volatile so a read sees the table in a
> consistent state after a rehash(). put() can sometimes rehash without
> setting count. Even when put() does set count, there's still a window
> between the rehash and the set to count where a read could see an
> inconsistent table.
> 
> Bob


From ktlam at cs.hku.hk  Thu Jul 21 21:56:34 2011
From: ktlam at cs.hku.hk (King Tin Lam)
Date: Fri, 22 Jul 2011 09:56:34 +0800
Subject: [concurrency-interest] Question on ConcurrentHashMap: Why
	the'table' field of Segment has to be volatile?
References: <NFBBKALFDCPFIDBNKAPCIEMFIOAA.davidcholmes@aapt.net.au>
	<4E28C0A5.4010208@kav.dk> <01bf01cc480c$1ea48e50$f8b10893@ktlampc>
	<CAGmsiP6Vuc=rm4UsyLHUVyEjBYQ4TzKBekRNEisUw=Jiiw9rNw@mail.gmail.com>
Message-ID: <01c401cc4812$96fff5f0$f8b10893@ktlampc>

Oh Sorry, please ignore my previous post. 
I overlooked Bob's reply. 
You are right; it is for read operations to see a consistent hash table. 
Thank you so much.  

Best regards,
King Tin
 

> -----Original Message-----
> From: King Tin Lam [mailto:ktlam at cs.hku.hk]
> Sent: Friday, July 22, 2011 9:54 AM
> To: 'Bob Lee'
> Cc: 'concurrency-interest at cs.oswego.edu'
> Subject: RE: [concurrency-interest] Question on ConcurrentHashMap: Why
> the'table' field of Segment has to be volatile?
> 
> Thank you David and Bob,
> 
> But not the put method has already acquired a lock over the segment from
> the method beginning? So puts to the same segment should have been
> serialized. The lock acquire and release among them should have ensured
> the happens-before relation and required visibility including the update
> that sets table to a new one due to rehashing. Also, rehashing is called
> by the current thread calling put() but seeing the entry count is above
> threshold. After the completion of rehash by the thread, it continues on
> the put. Then why it could see an inconsistent table rehashed by itself
> under synchronizing over the segment?
> 
> Sorry for my misunderstanding.
> 
> Best regards,
> King Tin
> 
> 
> > -----Original Message-----
> > From: crazyboblee at gmail.com [mailto:crazyboblee at gmail.com] On Behalf Of
> > Bob Lee
> > Sent: Friday, July 22, 2011 9:42 AM
> > To: King Tin Lam
> > Cc: concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Question on ConcurrentHashMap: Why
> > the'table' field of Segment has to be volatile?
> >
> > On Thu, Jul 21, 2011 at 6:10 PM, King Tin Lam <ktlam at cs.hku.hk> wrote:
> >
> > 	I think the write on tab[index] is NOT a volatile write.
> >
> >
> >
> > That's correct. Writes to array entries are not volatile, and CHM does
> not
> > intend for this to be the case.
> >
> > It looks like table needs to be volatile so a read sees the table in a
> > consistent state after a rehash(). put() can sometimes rehash without
> > setting count. Even when put() does set count, there's still a window
> > between the rehash and the set to count where a read could see an
> > inconsistent table.
> >
> > Bob


From aleksey.shipilev at gmail.com  Fri Jul 22 14:03:09 2011
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Fri, 22 Jul 2011 19:03:09 +0100
Subject: [concurrency-interest] LMAX/Disruptor
In-Reply-To: <4E247088.7090504@cytetech.com>
References: <CAF9YjSCKY0AXDO7wf=V_mGEf_3TG-gCOj0_tyb2d61GUHjV9yw@mail.gmail.com>
	<4E21FF5C.4050000@fh-landshut.de> <4E247088.7090504@cytetech.com>
Message-ID: <CA+1LWGFfrLUubATpSCDB0hWhyau1BwdgdSHsQ6jG3arLcNewYg@mail.gmail.com>

On Mon, Jul 18, 2011 at 6:42 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
> On 7/16/2011 4:15 PM, Michael Bien wrote:
>>
>> On 07/15/2011 08:22 PM, Ashwin Jayaprakash wrote:
>>>
>>> Just an FYI - in case you guys haven't heard about the ultra-low latency
>>> data
>>> structure: http://www.infoq.com/presentations/LMAX -
>>> http://code.google.com/p/disruptor/
>>>
>>>
>>> Ashwin (http://www.ashwinjayaprakash.com)
>>
>> yep, nothing entirely new in it but that makes it even more interesting :)
>> direct link to the paper:
>> http://disruptor.googlecode.com/files/Disruptor-1.0.pdf
>
> The one new thing which I see is that your CPU usage will stay at 100%.
> ?Without out "wait" based locks, the continuous spinning will peg CPU usage.

To be fair, they should have tried ABQ with infinite-spinning locks
for comparison. Comparing busy-looped "locking" in Disruptor and
locked condvars in ABQ is useless: for "do only transfer via
queue"-style benchmark Disruptor will always win. Also, I really doubt
common TTAS spinlock suffer from too much coherence traffic.

-Aleksey.


From ashwin.jayaprakash at gmail.com  Fri Jul 22 17:22:01 2011
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Fri, 22 Jul 2011 14:22:01 -0700
Subject: [concurrency-interest] Clarification on jsr166e SequenceLock
Message-ID: <CAF9YjSCHrWdNcrVe+7yYPeKfbf438vDNS4Brc9-OE5evw76oHQ@mail.gmail.com>

I tried reading the doc on
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/SequenceLock.htmlbut
I'm still not clear on what purpose this serves.

Why does the distanceFromOriginV1 method check for seq again after awaiting?
Is this supposed to demonstrate a "lock-less read of multiple volatile
fields" like a "read-committed" transaction?

If you do not have the do-while loop wouldn't it still be safe to read x and
y after awaiting only once? Or would that result in a case where x gets read
and by the time y gets read the next lock holder changes both x and y thus
resulting in an old currentX and a newer currentY?

I'm just wondering if the example/doc/feature is obvious enough for us
ordinary users to use properly :)

 double distanceFromOriginV1() { // A read-only method
      double currentX, currentY;
      long seq;
      do {
          seq = sl.awaitAvailability();
          currentX = x;
          currentY = y;
      } while (sl.getSequence() != seq); // retry if sequence changed
      return Math.sqrt(currentX * currentX + currentY * currentY);
  }



Ashwin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110722/26e0ea80/attachment.html>

From vitalyd at gmail.com  Fri Jul 22 18:29:03 2011
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Fri, 22 Jul 2011 18:29:03 -0400
Subject: [concurrency-interest] Clarification on jsr166e SequenceLock
In-Reply-To: <CAF9YjSCHrWdNcrVe+7yYPeKfbf438vDNS4Brc9-OE5evw76oHQ@mail.gmail.com>
References: <CAF9YjSCHrWdNcrVe+7yYPeKfbf438vDNS4Brc9-OE5evw76oHQ@mail.gmail.com>
Message-ID: <CAHjP37HH6g6NV1ZW-3Nr3wmx7SbtnZ13wH9LGQO5v36-9ASRJA@mail.gmail.com>

The idea of a seqlock is that you'd use it when you don't expect a lot of
contention and hence you get a lower lock/unlock penalty.  However, as you
mentioned, you need to guard against a case where someone updates the value
in between your reads and you'd read an inconsistent x/y pair otherwise.
On Jul 22, 2011 5:24 PM, "Ashwin Jayaprakash" <ashwin.jayaprakash at gmail.com>
wrote:
> I tried reading the doc on
>
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/SequenceLock.htmlbut
> I'm still not clear on what purpose this serves.
>
> Why does the distanceFromOriginV1 method check for seq again after
awaiting?
> Is this supposed to demonstrate a "lock-less read of multiple volatile
> fields" like a "read-committed" transaction?
>
> If you do not have the do-while loop wouldn't it still be safe to read x
and
> y after awaiting only once? Or would that result in a case where x gets
read
> and by the time y gets read the next lock holder changes both x and y thus
> resulting in an old currentX and a newer currentY?
>
> I'm just wondering if the example/doc/feature is obvious enough for us
> ordinary users to use properly :)
>
> double distanceFromOriginV1() { // A read-only method
> double currentX, currentY;
> long seq;
> do {
> seq = sl.awaitAvailability();
> currentX = x;
> currentY = y;
> } while (sl.getSequence() != seq); // retry if sequence changed
> return Math.sqrt(currentX * currentX + currentY * currentY);
> }
>
>
>
> Ashwin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110722/9db1bd57/attachment.html>

From edharned2002 at yahoo.com  Mon Jul 25 16:32:14 2011
From: edharned2002 at yahoo.com (Edward Harned)
Date: Mon, 25 Jul 2011 13:32:14 -0700 (PDT)
Subject: [concurrency-interest] Try to change your life to better with
	our on-line drugstore!
Message-ID: <1311625934.95467.yint-ygo-j2me@web35503.mail.mud.yahoo.com>

...Stop counting money on dear drugs. This is a place where you can find everything you need and cheaply.  http://mikeyjetadore.free.fr/friends.page.php?bfriend_id=02y5

From linzuxiong1988 at gmail.com  Wed Jul 27 23:01:04 2011
From: linzuxiong1988 at gmail.com (zuxiong lin)
Date: Thu, 28 Jul 2011 11:01:04 +0800
Subject: [concurrency-interest] JMS and ThreadPool problem?
Message-ID: <CACSA5wbZ7_ktgD+HTd6731UxDr=0hMy0-zkjsH3DYr8TZpcovQ@mail.gmail.com>

I want that jms receive a msg when one thread have handled a message
(threadPool submit a callable).
The messages are received in Master thread.
Which way is better below:

I use spring 3.0.5  :
        ApplicationContext context = new ClassPathXmlApplicationContext(
                "application-context.xml");
        jmsTemplate = (JmsTemplate) context.getBean("jmsTemplate");
        destination = (Destination) context.getBean("destination");
        _log4j.debug("ThreadSize in xml\t"
                + appConfig.getThumbCreatorThreadSize());
in master thread Way 1:
        while (countFlag < 0) {
            try {
                TextMessage msg = (TextMessage) jmsTemplate
                        .receive(destination);
                // prehandle ,then give to sub workers.
                if (msg != null) {
                    _log4j.debug("JMSMessageID:\t" + msg.getJMSMessageID()
                            + "\t" + msg.getText());
                    IConsumer thumbConsumerImpl = null;
                    thumbConsumerImpl = new ThumbConsumerTaskImpl(msg);
                    Future<List<ThumbCreatorInfo>> result = threadPool
                            .submit((Callable<List<ThumbCreatorInfo>>)
thumbConsumerImpl);
                }
            } catch (IllegalArgumentException e) {
                _log4j.warn(e.getMessage(), e);
            } catch (JMSException e) {
                _log4j.error("Please check the queue server!JMSException!",
e);
            } catch (Exception e) {
                _log4j.error("", e);
            }
        }


in master thread Way 2:
        TextMessage msg = (TextMessage) jmsTemplate.receive(destination);
        do {
            try {
                // prehandle ,then give to sub workers.
                if (msg != null) {
                    _log4j.debug("JMSMessageID:\t" + msg.getJMSMessageID()
                            + "\t" + msg.getText());
                    IConsumer thumbConsumerImpl = null;
                    thumbConsumerImpl = new ThumbConsumerTaskImpl(msg);
                    Future<List<ThumbCreatorInfo>> result = threadPool
                            .submit((Callable<List<ThumbCreatorInfo>>)
thumbConsumerImpl);
                }
                msg = (TextMessage) jmsTemplate.receive(destination);
            } catch (IllegalArgumentException e) {
                _log4j.warn(e.getMessage(), e);
            } catch (JMSException e) {
                _log4j.error("Please check the queue server!JMSException!",
e);
            } catch (Exception e) {
                _log4j.error("", e);
            }
        } while (countFlag < 0);



Thanks~~~
Regards.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110728/0cf148c3/attachment.html>

From ashwin.jayaprakash at gmail.com  Fri Jul 29 13:29:30 2011
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Fri, 29 Jul 2011 10:29:30 -0700
Subject: [concurrency-interest] j.u.c.Phaser tutorial?
Message-ID: <CAF9YjSBvncGzCbK6g3-ofyQL-0jFYGAS_baFPEQC7ZRkU-xQvw@mail.gmail.com>

Is there a simpler/easier tutorial that explains the Phaser introduced in
Java 7? Yes, I did read the Javadoc example (
http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html)
but I didn't quite follow it.


Thanks,
Ashwin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110729/6a751633/attachment.html>

From vgrazi at gmail.com  Sat Jul 30 22:06:05 2011
From: vgrazi at gmail.com (Victor Grazi)
Date: Sat, 30 Jul 2011 22:06:05 -0400
Subject: [concurrency-interest] phaser tutorial
Message-ID: <CA+y1Pu-=Tk-yvNy2EFsOOxFdTxEr35LK0hs4kQ0+5kONm+z=SA@mail.gmail.com>

Download java concurrent animated from source forge. There is a Phaser
animation that makes it very clear.

It will br especially helpful if you try it along with the java tutorial

Best of luck
Victor
On Jul 30, 2011 12:02 PM, <concurrency-interest-request at cs.oswego.edu>
wrote:
> Send Concurrency-interest mailing list submissions to
> concurrency-interest at cs.oswego.edu
>
> To subscribe or unsubscribe via the World Wide Web, visit
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> or, via email, send a message with subject or body 'help' to
> concurrency-interest-request at cs.oswego.edu
>
> You can reach the person managing the list at
> concurrency-interest-owner at cs.oswego.edu
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of Concurrency-interest digest..."
>
>
> Today's Topics:
>
> 1. j.u.c.Phaser tutorial? (Ashwin Jayaprakash)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Fri, 29 Jul 2011 10:29:30 -0700
> From: Ashwin Jayaprakash <ashwin.jayaprakash at gmail.com>
> Subject: [concurrency-interest] j.u.c.Phaser tutorial?
> To: concurrency-interest at cs.oswego.edu
> Message-ID:
> <CAF9YjSBvncGzCbK6g3-ofyQL-0jFYGAS_baFPEQC7ZRkU-xQvw at mail.gmail.com>
> Content-Type: text/plain; charset="iso-8859-1"
>
> Is there a simpler/easier tutorial that explains the Phaser introduced in
> Java 7? Yes, I did read the Javadoc example (
>
http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html
)
> but I didn't quite follow it.
>
>
> Thanks,
> Ashwin.
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110729/6a751633/attachment-0001.html
>
>
> ------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> End of Concurrency-interest Digest, Vol 78, Issue 22
> ****************************************************
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110730/9227c2f9/attachment.html>

From dl at cs.oswego.edu  Sun Jul 31 10:55:43 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 31 Jul 2011 10:55:43 -0400
Subject: [concurrency-interest] LongAdder (was: StripedAdder) and
	LongAdderTable
Message-ID: <4E356CEF.6050003@cs.oswego.edu>

It is much nicer not to have to decide ahead of time that
a program will have enough threads updating a variable
to need a class that can adaptively spread out contention.
So a reworked version of StripedAdder is now known as "LongAdder".
It is a variant of AtomicLong with a stripped-down API (suitable
only for adding and counting), that expands to use striping
when needed while avoiding noticeable overhead when not needed.

As the cost of contended atomic operations increases
(even as the cost of uncontended ones decreases on
some platforms), this will probably become a more commonly
useful class.

If you are curious, try out LongAdderDemo in the jsr166e tests.
On machines with more than a few cores LongAdder vastly outperforms
AtomicLong (sometimes by more than a factor of 100)
when all cores are trying to update.  (Please let us know if
you see different or surprising results.)

This class is currently in jsr166e but is targeted to
go into java.util.concurrent.atomic. APIs and implementations
are still subject to change.

Also, because it is likely to be among the more
common uses of LongAdders, we created AtomicLongTable,
that maintains a hash map of adders with arbitrary keys,
supporting usages including table.increment(key)

Links:
*  API specs:  http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/
* jar file: http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166e.jar (compiled using 
Java7 javac).
* Browsable CVS sources: 
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/
* Browsable CVS test file sources: 
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/jsr166e/

From karmazilla at gmail.com  Sun Jul 31 12:39:17 2011
From: karmazilla at gmail.com (Christian Vest Hansen)
Date: Sun, 31 Jul 2011 18:39:17 +0200
Subject: [concurrency-interest] LongAdder (was: StripedAdder) and
	LongAdderTable
In-Reply-To: <4E356CEF.6050003@cs.oswego.edu>
References: <4E356CEF.6050003@cs.oswego.edu>
Message-ID: <CACyP5Pdc-5b32bfpCBjCRC=oF=-4AXo6j9mpmL4xZrVpO+yGkg@mail.gmail.com>

Some interfaces for these things might be a good idea, as I can imagine data
grid libraries might want to provide distributed implementations. Counter
and CounterTable comes to mind as possible names.

On Sun, Jul 31, 2011 at 16:55, Doug Lea <dl at cs.oswego.edu> wrote:

> It is much nicer not to have to decide ahead of time that
> a program will have enough threads updating a variable
> to need a class that can adaptively spread out contention.
> So a reworked version of StripedAdder is now known as "LongAdder".
> It is a variant of AtomicLong with a stripped-down API (suitable
> only for adding and counting), that expands to use striping
> when needed while avoiding noticeable overhead when not needed.
>
> As the cost of contended atomic operations increases
> (even as the cost of uncontended ones decreases on
> some platforms), this will probably become a more commonly
> useful class.
>
> If you are curious, try out LongAdderDemo in the jsr166e tests.
> On machines with more than a few cores LongAdder vastly outperforms
> AtomicLong (sometimes by more than a factor of 100)
> when all cores are trying to update.  (Please let us know if
> you see different or surprising results.)
>
> This class is currently in jsr166e but is targeted to
> go into java.util.concurrent.atomic. APIs and implementations
> are still subject to change.
>
> Also, because it is likely to be among the more
> common uses of LongAdders, we created AtomicLongTable,
> that maintains a hash map of adders with arbitrary keys,
> supporting usages including table.increment(key)
>
> Links:
> *  API specs:  http://gee.cs.oswego.edu/dl/**jsr166/dist/jsr166edocs/<http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/>
> * jar file: http://gee.cs.oswego.edu/dl/**jsr166/dist/jsr166e.jar<http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166e.jar>(compiled using Java7 javac).
> * Browsable CVS sources: http://gee.cs.oswego.edu/cgi-**
> bin/viewcvs.cgi/jsr166/src/**jsr166e/<http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/>
> * Browsable CVS test file sources: http://gee.cs.oswego.edu/cgi-**
> bin/viewcvs.cgi/jsr166/src/**test/jsr166e/<http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/jsr166e/>
> ______________________________**_________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.**oswego.edu <Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/**listinfo/concurrency-interest<http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>



-- 
Venlig hilsen / Kind regards,
Christian Vest Hansen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110731/367a6f0e/attachment.html>

From dl at cs.oswego.edu  Sun Jul 31 14:56:12 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 31 Jul 2011 14:56:12 -0400
Subject: [concurrency-interest] LongAdder (was: StripedAdder) and
	LongAdderTable
In-Reply-To: <CACyP5Pdc-5b32bfpCBjCRC=oF=-4AXo6j9mpmL4xZrVpO+yGkg@mail.gmail.com>
References: <4E356CEF.6050003@cs.oswego.edu>
	<CACyP5Pdc-5b32bfpCBjCRC=oF=-4AXo6j9mpmL4xZrVpO+yGkg@mail.gmail.com>
Message-ID: <4E35A54C.9020300@cs.oswego.edu>

On 07/31/11 12:39, Christian Vest Hansen wrote:
> Some interfaces for these things might be a good idea, as I can imagine data
> grid libraries might want to provide distributed implementations. Counter and
> CounterTable comes to mind as possible names.

I had proposed this, but talked myself out of it.
The APIs are tied to a particular scalar type (long),
and might grow to include others (in particular, a
DoubleAdder class). It may be that the only
commonality is that they extend java.lang.Number. Which
we declared for the AtomicX classes, but even that was not
obviously helpful.

> On Sun, Jul 31, 2011 at 16:55, Doug Lea <dl at cs.oswego.edu
> <mailto:dl at cs.oswego.edu>> wrote:

>     Also, because it is likely to be among the more
>     common uses of LongAdders, we created AtomicLongTable,

Oops. I meant LongAdderTable. (The names changed several times
times before check-in.)

-Doug


From william.louth at jinspired.com  Sun Jul 31 15:22:19 2011
From: william.louth at jinspired.com (William Louth (JINSPIRED.COM))
Date: Sun, 31 Jul 2011 21:22:19 +0200
Subject: [concurrency-interest] LongAdder (was: StripedAdder) and
	LongAdderTable
In-Reply-To: <4E35A54C.9020300@cs.oswego.edu>
References: <4E356CEF.6050003@cs.oswego.edu>
	<CACyP5Pdc-5b32bfpCBjCRC=oF=-4AXo6j9mpmL4xZrVpO+yGkg@mail.gmail.com>
	<4E35A54C.9020300@cs.oswego.edu>
Message-ID: <4E35AB6B.3080108@jinspired.com>

I am currently writing up a proposal (will be posted on blog next week 
hopefully) for having an intrinsic (long) counter data type in the Java 
that would be thread local (though not access through this interface) 
and optimized by the JVM whilst affording the ability to introspect the 
current set of named counters in the JVM as well as their instance (and 
value) on a per thread basis (preferably within the thread itself) via 
an API. I think we should be encouraging developers to move away from 
process level JMX like counters and instead thread specific & event 
based (without state) which could be in turn be accessed at a process 
level if need be but more so at the thread level and from a caller/chain 
perspective forming a foundation for the ultimate feedback loop between 
callers and callees.

This a part of a much bigger proposal for software activity metering to 
be a core aspect of the runtime, library and possibly language (via 
event counters)

OpenCore Metering Runtime Actors
http://opencore.jinspired.com/?p=1888

Activity Based Costing & Metering (ABC/M) ? The Ultimate Feedback Loop
http://opencore.jinspired.com/?p=4052

Automated Performance Management starts with Software?s Self Observation
http://opencore.jinspired.com/?p=2709

Metering (Probes) Open API
http://opencore.jinspired.com/?page_id=715

On 31/07/2011 20:56, Doug Lea wrote:
> On 07/31/11 12:39, Christian Vest Hansen wrote:
>> Some interfaces for these things might be a good idea, as I can 
>> imagine data
>> grid libraries might want to provide distributed implementations. 
>> Counter and
>> CounterTable comes to mind as possible names.
>
> I had proposed this, but talked myself out of it.
> The APIs are tied to a particular scalar type (long),
> and might grow to include others (in particular, a
> DoubleAdder class). It may be that the only
> commonality is that they extend java.lang.Number. Which
> we declared for the AtomicX classes, but even that was not
> obviously helpful.
>
>> On Sun, Jul 31, 2011 at 16:55, Doug Lea <dl at cs.oswego.edu
>> <mailto:dl at cs.oswego.edu>> wrote:
>
>> Also, because it is likely to be among the more
>> common uses of LongAdders, we created AtomicLongTable,
>
> Oops. I meant LongAdderTable. (The names changed several times
> times before check-in.)
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From ashwin.jayaprakash at gmail.com  Sun Jul 31 15:41:03 2011
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Sun, 31 Jul 2011 12:41:03 -0700
Subject: [concurrency-interest] j.u.c.Phaser tutorial?
In-Reply-To: <CAF9YjSBvncGzCbK6g3-ofyQL-0jFYGAS_baFPEQC7ZRkU-xQvw@mail.gmail.com>
References: <CAF9YjSBvncGzCbK6g3-ofyQL-0jFYGAS_baFPEQC7ZRkU-xQvw@mail.gmail.com>
Message-ID: <CAF9YjSDjbg9=0L1kUUQGf2uhxkMa6NVrKasBSo9zLrUE5=waXg@mail.gmail.com>

Victor, thanks for telling me about your animated framework (
http://sourceforge.net/projects/javaconcurrenta/)

It was useful. I learned later that the arriveAndDeregister() method makes
sense only when you create a hierarchy of phasers which you have not
illustrated - so it looks just like arrive().

Still, nice work!

Off topic - about "Animated concurrent":
Another pointer - the UI for Executors is confusing. All the screens have a
"threadcount" spinner which is not very intuitive for showing
singleThreadedExecutor, cached.. etc. Is that for submitting threads or
pooled threads?


On Fri, Jul 29, 2011 at 10:29 AM, Ashwin Jayaprakash <
ashwin.jayaprakash at gmail.com> wrote:

> Is there a simpler/easier tutorial that explains the Phaser introduced in
> Java 7? Yes, I did read the Javadoc example (
> http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.html)
> but I didn't quite follow it.
>
>
> Thanks,
> Ashwin.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110731/525c700a/attachment.html>

From davidcholmes at aapt.net.au  Sun Jul 31 18:47:50 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 1 Aug 2011 08:47:50 +1000
Subject: [concurrency-interest] j.u.c.Phaser tutorial?
In-Reply-To: <CAF9YjSDjbg9=0L1kUUQGf2uhxkMa6NVrKasBSo9zLrUE5=waXg@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEABIPAA.davidcholmes@aapt.net.au>

Ashwin,

> I learned later that the arriveAndDeregister() method makes sense only
when you create a hierarchy of phasers

Not so. arriveAndDeregister is typically used by the main thread when the
phaser acts as both a cyclic barrier and a starting latch. You create the
phaser for N+1 threads and have all workers wait on the phaser in a loop.
The main thread is needed to release the phaser the first time so that all
workers have been created but thereafter is not needed so it can arrive and
deregister.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Ashwin
Jayaprakash
  Sent: Monday, 1 August 2011 5:41 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] j.u.c.Phaser tutorial?


  Victor, thanks for telling me about your animated framework
(http://sourceforge.net/projects/javaconcurrenta/)

  It was useful. I learned later that the arriveAndDeregister() method makes
sense only when you create a hierarchy of phasers which you have not
illustrated - so it looks just like arrive().

  Still, nice work!

  Off topic - about "Animated concurrent":
  Another pointer - the UI for Executors is confusing. All the screens have
a "threadcount" spinner which is not very intuitive for showing
singleThreadedExecutor, cached.. etc. Is that for submitting threads or
pooled threads?



  On Fri, Jul 29, 2011 at 10:29 AM, Ashwin Jayaprakash
<ashwin.jayaprakash at gmail.com> wrote:

    Is there a simpler/easier tutorial that explains the Phaser introduced
in Java 7? Yes, I did read the Javadoc example
(http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Phaser.ht
ml) but I didn't quite follow it.


    Thanks,
    Ashwin.


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110801/ec16acce/attachment.html>

