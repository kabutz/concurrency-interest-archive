From sitnikov.vladimir at gmail.com  Sat Mar  1 11:47:48 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Sat, 1 Mar 2014 20:47:48 +0400
Subject: [concurrency-interest] Writing final fields via reflection vs
	safe-visibility of new contents
Message-ID: <CAB=Je-E7JeHpcBCvw1yKXMD6JrfWxKY8bR8wOY3z47jcL7w9wA@mail.gmail.com>

Hi,

I would like to add new test to jcstress on observable state after updating
of final field via reflection.
The question is: "does final modifier ensure safe publication when writing
to a final field via reflection?"

I know the way to cast freeze action (down, forward, low punch for
Sub-Zero), however I have no idea how to cast memory chain, dereference
chain and other ingredients, thus I beg on your skills to validate my
conclusions.

I understand that other threads might not see newly written value due to
compiler optimizations, however I wonder if the publication is safe
provided read opeartion did observe new value.

Please find attached ObjectFinalReflectTest.java that implements the
required test via jcstress framework.

As far as I can understand, only the following outcomes are acceptable:
42 -- actor2 does not yet see Shell
1 -- actor2 sees the value that is set in constructor
2 -- actor2 sees value set via reflection after construction

The following outcomes are forbidden:
0 -- actor2 should not see default value of IntHolder.x since the only way
IntHolder is visible to actor2 is through freeze action.
NPE -- actor2 should not see default value of final field Shell.x as Shell
constructor does not leak "this" reference

-- 
Regards,
Vladimir Sitnikov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140301/312755f3/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ObjectFinalReflectTest.java
Type: application/octet-stream
Size: 1588 bytes
Desc: not available
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140301/312755f3/attachment.obj>

From sitnikov.vladimir at gmail.com  Sat Mar  1 12:54:16 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Sat, 1 Mar 2014 21:54:16 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor vs
	safe publication via race
Message-ID: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>

Hi,

There was a discussion in c-i [1] that resulted in conclusion that the
contents of volatile field is not safe when object is published via race
[2].
I would like to extend that testcase, gather validated outcomes, and
incorporate the test to jcstress.

The difference from [1] is the constructor perform multiple load/stores.
Multiple volatile actions in constructor might be confusing for the reader,
thus having peer validated testcase is vital for mind-blowing discussions
during coffee breaks.
Recently, Gil Tene suggeed that if we perform the required number of
volatile writes/loads in constuctor, we are safe that newly created object
is fully safe even for publication via race [3].

The test comes in two flavors: [4] (more volatiles) and [5] (less
volatiles).
As far as I understand, this test is equal to [1] in terms of acceptable
outcomes, in other words only 42, 0, -1 are acceptable.
I guess the reasoning is the same as Andreas suggests in [2].

I posted the same question to jcstress-dev [6], however got no answer yet.

Can you please validate if 0 is allowable in [4] and [5]?

[1]:
http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011951.html
[2]:
http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011954.html
[3]:
https://groups.google.com/forum/#!msg/mechanical-sympathy/4EDCX0F_3ow/RlDZq1MjgiMJ

[4]:
public class IntVolatileStoreLoadStoreTest implements
Actor2_Test<IntVolatileTest.State, IntResult1> {

    public static class State {
        Shell shell;
    }

    public static class Shell {
        volatile int x;
        volatile int y;

        public Shell() {
            this.x = 0xFFFFFFFF;
            this.y = this.x;
            this.x = this.y;
        }
    }

    @Override
    public State newState() {
        return new State();
    }

    @Override
    public void actor1(State s, IntResult1 r) {
        s.shell = new Shell();
    }

    @Override
    public void actor2(State s, IntResult1 r) {
        Shell sh = s.shell;
        r.r1 = (sh == null) ? 42 : sh.x;
    }

    @Override
    public IntResult1 newResult() {
        return new IntResult1();
    }

}

[5]: variation by Gil:
https://groups.google.com/d/msg/mechanical-sympathy/4EDCX0F_3ow/PwJOY8E1Be4J

    public static class Shell {
        int x;
        volatile int y;

        int z;


        public Shell() {
            this.x = 0xFFFFFFFF;
            this.y = this.x;
            this.z = this.y;
        }
    }

[6]:
http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012434.html

-- 
Regards,
Vladimir Sitnikov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140301/a314e8ab/attachment.html>

From oleksandr.otenko at oracle.com  Mon Mar  3 17:54:18 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 03 Mar 2014 22:54:18 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
Message-ID: <5315081A.4040600@oracle.com>

Gil's reasoning [3] is correct on [4] and [5] - 0 is not allowable as 
the value of x there.

Because of program order, a store to x and a store of the reference 
being published will be observed before the store to y and load from y 
respectively. These two are volatiles, so will appear in program order 
to all threads.

Technically, in example [4] you could observe either of the stores to x, 
but since they both store the same value, the stores are 
indistinguishable to any thread. But the consequence of having two 
stores is that if any other thread mutates x after observing the 
published reference, this modification may not be observed by any thread 
ever - because there is no ordering between the store publishing the 
reference and the last store to x.

Alex

On 01/03/2014 17:54, Vladimir Sitnikov wrote:
> Hi,
>
> There was a discussion in c-i [1] that resulted in conclusion that the 
> contents of volatile field is not safe when object is published via 
> race [2].
> I would like to extend that testcase, gather validated outcomes, and 
> incorporate the test to jcstress.
>
> The difference from [1] is the constructor perform multiple load/stores.
> Multiple volatile actions in constructor might be confusing for the 
> reader, thus having peer validated testcase is vital for mind-blowing 
> discussions during coffee breaks.
> Recently, Gil Tene suggeed that if we perform the required number of 
> volatile writes/loads in constuctor, we are safe that newly created 
> object is fully safe even for publication via race [3].
>
> The test comes in two flavors: [4] (more volatiles) and [5] (less 
> volatiles).
> As far as I understand, this test is equal to [1] in terms of 
> acceptable outcomes, in other words only 42, 0, -1 are acceptable.
> I guess the reasoning is the same as Andreas suggests in [2].
>
> I posted the same question to jcstress-dev [6], however got no answer yet.
>
> Can you please validate if 0 is allowable in [4] and [5]?
>
> [1]: 
> http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011951.html
> [2]: 
> http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011954.html
> [3]: 
> https://groups.google.com/forum/#!msg/mechanical-sympathy/4EDCX0F_3ow/RlDZq1MjgiMJ 
> <https://groups.google.com/forum/#%21msg/mechanical-sympathy/4EDCX0F_3ow/RlDZq1MjgiMJ>
> [4]:
> public class IntVolatileStoreLoadStoreTest implements
> Actor2_Test<IntVolatileTest.State, IntResult1> {
>
>      public static class State {
>          Shell shell;
>      }
>
>      public static class Shell {
>          volatile int x;
>          volatile int y;
>
>          public Shell() {
>              this.x = 0xFFFFFFFF;
>              this.y = this.x;
>              this.x = this.y;
>          }
>      }
>
>      @Override
>      public State newState() {
>          return new State();
>      }
>
>      @Override
>      public void actor1(State s, IntResult1 r) {
>          s.shell = new Shell();
>      }
>
>      @Override
>      public void actor2(State s, IntResult1 r) {
>          Shell sh = s.shell;
>          r.r1 = (sh == null) ? 42 : sh.x;
>      }
>
>      @Override
>      public IntResult1 newResult() {
>          return new IntResult1();
>      }
>
> }
> [5]: variation by Gil: 
> https://groups.google.com/d/msg/mechanical-sympathy/4EDCX0F_3ow/PwJOY8E1Be4J
>      public static class Shell {
>          int x;
>          volatile int y;
>          int z;
>          public Shell() {
>              this.x = 0xFFFFFFFF;
>              this.y = this.x;
>              this.z = this.y;
>          }
>      }
> [6]: 
> http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012434.html
>
> -- 
> Regards,
> Vladimir Sitnikov
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140303/f74932c2/attachment.html>

From oleksandr.otenko at oracle.com  Mon Mar  3 17:57:27 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 03 Mar 2014 22:57:27 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <5315081A.4040600@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com>
Message-ID: <531508D7.6020808@oracle.com>

On 03/03/2014 22:54, Oleksandr Otenko wrote:
> Gil's reasoning [3] is correct on [4] and [5] - 0 is not allowable as 
> the value of x there.
>
> Because of program order, a store to x and a store of the reference 
> being published will be observed before the store to y and load from y 
> respectively.

(typo: "after load from y respectively")

Alex

> These two are volatiles, so will appear in program order to all threads.
>
> Technically, in example [4] you could observe either of the stores to 
> x, but since they both store the same value, the stores are 
> indistinguishable to any thread. But the consequence of having two 
> stores is that if any other thread mutates x after observing the 
> published reference, this modification may not be observed by any 
> thread ever - because there is no ordering between the store 
> publishing the reference and the last store to x.
>
> Alex
>
> On 01/03/2014 17:54, Vladimir Sitnikov wrote:
>> Hi,
>>
>> There was a discussion in c-i [1] that resulted in conclusion that 
>> the contents of volatile field is not safe when object is published 
>> via race [2].
>> I would like to extend that testcase, gather validated outcomes, and 
>> incorporate the test to jcstress.
>>
>> The difference from [1] is the constructor perform multiple load/stores.
>> Multiple volatile actions in constructor might be confusing for the 
>> reader, thus having peer validated testcase is vital for mind-blowing 
>> discussions during coffee breaks.
>> Recently, Gil Tene suggeed that if we perform the required number of 
>> volatile writes/loads in constuctor, we are safe that newly created 
>> object is fully safe even for publication via race [3].
>>
>> The test comes in two flavors: [4] (more volatiles) and [5] (less 
>> volatiles).
>> As far as I understand, this test is equal to [1] in terms of 
>> acceptable outcomes, in other words only 42, 0, -1 are acceptable.
>> I guess the reasoning is the same as Andreas suggests in [2].
>>
>> I posted the same question to jcstress-dev [6], however got no answer 
>> yet.
>>
>> Can you please validate if 0 is allowable in [4] and [5]?
>>
>> [1]: 
>> http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011951.html
>> [2]: 
>> http://cs.oswego.edu/pipermail/concurrency-interest/2013-November/011954.html
>> [3]: 
>> https://groups.google.com/forum/#!msg/mechanical-sympathy/4EDCX0F_3ow/RlDZq1MjgiMJ 
>> <https://groups.google.com/forum/#%21msg/mechanical-sympathy/4EDCX0F_3ow/RlDZq1MjgiMJ>
>> [4]:
>> public class IntVolatileStoreLoadStoreTest implements
>> Actor2_Test<IntVolatileTest.State, IntResult1> {
>>
>>      public static class State {
>>          Shell shell;
>>      }
>>
>>      public static class Shell {
>>          volatile int x;
>>          volatile int y;
>>
>>          public Shell() {
>>              this.x = 0xFFFFFFFF;
>>              this.y = this.x;
>>              this.x = this.y;
>>          }
>>      }
>>
>>      @Override
>>      public State newState() {
>>          return new State();
>>      }
>>
>>      @Override
>>      public void actor1(State s, IntResult1 r) {
>>          s.shell = new Shell();
>>      }
>>
>>      @Override
>>      public void actor2(State s, IntResult1 r) {
>>          Shell sh = s.shell;
>>          r.r1 = (sh == null) ? 42 : sh.x;
>>      }
>>
>>      @Override
>>      public IntResult1 newResult() {
>>          return new IntResult1();
>>      }
>>
>> }
>> [5]: variation by Gil: 
>> https://groups.google.com/d/msg/mechanical-sympathy/4EDCX0F_3ow/PwJOY8E1Be4J
>>      public static class Shell {
>>          int x;
>>          volatile int y;
>>          int z;
>>          public Shell() {
>>              this.x = 0xFFFFFFFF;
>>              this.y = this.x;
>>              this.z = this.y;
>>          }
>>      }
>> [6]: 
>> http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012434.html
>>
>> -- 
>> Regards,
>> Vladimir Sitnikov
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140303/f7084ccd/attachment.html>

From sitnikov.vladimir at gmail.com  Tue Mar  4 00:35:59 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Tue, 4 Mar 2014 09:35:59 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <531508D7.6020808@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
Message-ID: <CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>

>
> On 03/03/2014 22:54, Oleksandr Otenko wrote:
>
> Gil's reasoning [3] is correct on [4] and [5] - 0 is not allowable as the
> value of x there.
>
> Can you please refer to JMM and/or peer-reviewed case study?


These two are volatiles, so will appear in program order to all threads.

I am afraid this does not explain much.
If your reasoning "volatiles appear in program order" were applied to [1],
then it would result that 0 is not allowable in [1].
On contrary, 0 *is* acceptable in [1] (see [2]), thus "volatiles appear in
program order" is *not* always true.

-- 
Regards,
Vladimir Sitnikov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/25eda598/attachment-0001.html>

From peter.levart at gmail.com  Tue Mar  4 07:59:48 2014
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 04 Mar 2014 13:59:48 +0100
Subject: [concurrency-interest] Comparing semantics of
	j.l.c.l.Condition.await/signal with j.l.Object.wait/notify
Message-ID: <5315CE44.8020905@gmail.com>

Hi,

I'm reading the javadoc for java.lang.concurrent.locks.Condition.await() 
method which states:

/"An implementation can favor responding to an interrupt over normal 
method return in response to a signal. In that case the implementation 
must ensure that the signal is redirected to another waiting thread, if 
there is one.//"/

This could be interpreted as "reliable signal delivery". So one could 
write code like:

     try {
         condition.await();
     } catch (InterruptedException e) {
         // need not check the condition here, just handle the interrupt 
since
         // the signal will be delivered to some other waiting thread if 
there is one
     }

...is this really the semantics that can be relied upon?

What about Object.wait() when paired with Object.notify()? The javadoc 
does not specify exactly that an exceptional return could also mean that 
the same thread might have also been chosen by concurrent 
Object.notify(), but does not specify a similar guarantee as 
Condition.await() either...

Does anybody know what guarantees does Object.wait/notify provide when 
faced with concurrent thread interruptions?


Regards, Peter

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/b998d6a5/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar  4 09:33:20 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 04 Mar 2014 14:33:20 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
Message-ID: <5315E430.5020503@oracle.com>

In [1] reference publication is unrelated to actions observing the 
volatile store, so may appear before volatile store to other observers.

Like so:

tmp.x=-1; // volatile store
shared=tmp; // non-volatile store

another thread:

tmp=shared; // non-volatile load
r1=tmp.x; // volatile load


So, here you have program order between "tmp.x=-1;" and "shared=tmp;", 
and you have program order between "tmp=shared;" and "r1=tmp.x;". You 
also have synchronization order between "tmp.x=-1;" and "r1=tmp.x;".

What order do you have between "r1=tmp.x;" and "shared=tmp;"? None. But 
a prerequisite for always observing "-1" is a edge proving that 
"r1=tmp.x;" can only occur after "shared=tmp;".


In terms of cookbook Gil refers to, this is equivalent to saying that a 
normal store "shared=tmp;" can go ahead of a volatile store "tmp.x=-1;", 
which means "tmp=shared;" may observe non-null value before "tmp.x=-1;" 
completes.


[4] is different.

tmp.x=-1; // volatile store
tmp.y=-1; // volatile store
tmp.x=tmp.y; // volatile load, then volatile store
shared=tmp; // non-volatile store

Assuming there is another thread:

tmp=shared; // non-volatile load
tmp.y=-1; // volatile store; extra line
r1=tmp.x; // volatile load

The proof that r1==0 is impossible is a proof by contradiction.

Forget for a moment that this is a constructor and that "shared==null" 
until "shared=tmp;" can be observed. Here we have program order between 
each line of the corresponding threads, and a synchronization order 
between "tmp.y=-1;" and " tmp.x=tmp.y;" in addition to the 
synchronization order like in [1] between "tmp.x=-1;" and "r1=tmp.x;". 
The important consequence of this code is mutual exclusion of certain 
outcomes: if thread 1 observes "tmp.y=-1;", thread 2 /has/ to observe 
"tmp.x=-1;". Then due to program order of "r1=tmp.x;" it cannot observe 
"tmp.x==0;", therefore, cannot observe "shared=tmp;" before "tmp.y=-1;". 
There still is no edge between "r1=tmp.x;" and "shared=tmp;", like in 
[1], but by contradiction there is no possible way to allow observing 
"shared=tmp;" before "tmp.x=-1;".

The consequence is that "shared=tmp;" must be ordered in such a way that 
precludes thread 2 to observe it before load of tmp.y finishes. This is 
why Gil's reference to the cookbook is correct - nothing (normal store 
in this case) is allowed to go ahead of a volatile load (tmp.y loaded by 
"tmp.x=tmp.y;").

Now recall that this is a constructor and that loading tmp.y in thread 1 
cannot observe "tmp.y=-1;" before thread 2 can observe "shared=tmp;". So 
thread 2 cannot ever construct the code that can have a volatile store 
observable from constructor. So you should be allowed to eliminate the 
actual loading of tmp.y in the constructor, but you should never 
eliminate the edge, the barriers that preclude reordering of 
"shared=tmp;" with the place of the instruction loading tmp.y in program 
order - because then observing "tmp.y=-1;" will become possible again, 
and we arrive at contradiction as before.


Since the instruction for the actual loading is not needed, and since 
there is no case where it would be desirable to not have the volatile 
load after the last volatile store in the constructor, the discussion in 
[1] seems to have ended with a consensus that JMM must be rectified to 
explicitly explain this case, and demand final-field semantics for 
volatile stores in the constructor.


Now recall that the actual code is:

tmp=shared; // non-volatile load
r1=tmp.x; // volatile load


A mega-mind can figure out that now no contradiction arises from 
reordering "shared=tmp;" and "tmp.x=-1;". But in practice there is no 
way to determine that an arbitrary program will /*not*/ arrive at a 
contradiction of some non-trivial kind (hello, Halting problem), so the 
ordering of "shared=tmp;" will obey the laws that preclude the 
contradiction /as if/ the code like that existed. This last bit is my 
speculation about the reasons you will expect the volatile loads to 
behave like expected even in the absence of a volatile store that it can 
possibly observe.


Alex


On 04/03/2014 05:35, Vladimir Sitnikov wrote:
>
>     On 03/03/2014 22:54, Oleksandr Otenko wrote:
>>     Gil's reasoning [3] is correct on [4] and [5] - 0 is not
>>     allowable as the value of x there.
>>
> Can you please refer to JMM and/or peer-reviewed case study?
>
>
>> These two are volatiles, so will appear in program order to all threads.
> I am afraid this does not explain much.
> If your reasoning "volatiles appear in program order" were applied to 
> [1], then it would result that 0 is not allowable in [1].
> On contrary, 0 *is* acceptable in [1] (see [2]), thus "volatiles 
> appear in program order" is *not* always true.
>
> -- 
> Regards,
> Vladimir Sitnikov

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/bb3c2d35/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar  4 10:18:27 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 04 Mar 2014 15:18:27 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <5315E430.5020503@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com>
Message-ID: <5315EEC3.5090908@oracle.com>

Another reason to recommend final-field semantics is that the code here:

tmp=shared; // non-volatile load
r1=tmp.x; // volatile load

would need a LoadLoad barrier between the two loads to ensure 
data-dependent loads occur in program order. This barrier is available 
in the example where contradiction from reordering "shared=tmp;" would 
occur:

tmp=shared; // non-volatile load
tmp.y=-1; // volatile store - even if eliminated as a store that cannot 
be observed, must keep at least the load-load barrier to keep the semantics
r1=tmp.x; // volatile load

But this is the question for the code accessing the fields, not the 
constructor.

Alex

On 04/03/2014 14:33, Oleksandr Otenko wrote:
> In [1] reference publication is unrelated to actions observing the 
> volatile store, so may appear before volatile store to other observers.
>
> Like so:
>
> tmp.x=-1; // volatile store
> shared=tmp; // non-volatile store
>
> another thread:
>
> tmp=shared; // non-volatile load
> r1=tmp.x; // volatile load
>
>
> So, here you have program order between "tmp.x=-1;" and "shared=tmp;", 
> and you have program order between "tmp=shared;" and "r1=tmp.x;". You 
> also have synchronization order between "tmp.x=-1;" and "r1=tmp.x;".
>
> What order do you have between "r1=tmp.x;" and "shared=tmp;"? None. 
> But a prerequisite for always observing "-1" is a edge proving that 
> "r1=tmp.x;" can only occur after "shared=tmp;".
>
>
> In terms of cookbook Gil refers to, this is equivalent to saying that 
> a normal store "shared=tmp;" can go ahead of a volatile store 
> "tmp.x=-1;", which means "tmp=shared;" may observe non-null value 
> before "tmp.x=-1;" completes.
>
>
> [4] is different.
>
> tmp.x=-1; // volatile store
> tmp.y=-1; // volatile store
> tmp.x=tmp.y; // volatile load, then volatile store
> shared=tmp; // non-volatile store
>
> Assuming there is another thread:
>
> tmp=shared; // non-volatile load
> tmp.y=-1; // volatile store; extra line
> r1=tmp.x; // volatile load
>
> The proof that r1==0 is impossible is a proof by contradiction.
>
> Forget for a moment that this is a constructor and that "shared==null" 
> until "shared=tmp;" can be observed. Here we have program order 
> between each line of the corresponding threads, and a synchronization 
> order between "tmp.y=-1;" and " tmp.x=tmp.y;" in addition to the 
> synchronization order like in [1] between "tmp.x=-1;" and "r1=tmp.x;". 
> The important consequence of this code is mutual exclusion of certain 
> outcomes: if thread 1 observes "tmp.y=-1;", thread 2 /has/ to observe 
> "tmp.x=-1;". Then due to program order of "r1=tmp.x;" it cannot 
> observe "tmp.x==0;", therefore, cannot observe "shared=tmp;" before 
> "tmp.y=-1;". There still is no edge between "r1=tmp.x;" and 
> "shared=tmp;", like in [1], but by contradiction there is no possible 
> way to allow observing "shared=tmp;" before "tmp.x=-1;".
>
> The consequence is that "shared=tmp;" must be ordered in such a way 
> that precludes thread 2 to observe it before load of tmp.y finishes. 
> This is why Gil's reference to the cookbook is correct - nothing 
> (normal store in this case) is allowed to go ahead of a volatile load 
> (tmp.y loaded by "tmp.x=tmp.y;").
>
> Now recall that this is a constructor and that loading tmp.y in thread 
> 1 cannot observe "tmp.y=-1;" before thread 2 can observe 
> "shared=tmp;". So thread 2 cannot ever construct the code that can 
> have a volatile store observable from constructor. So you should be 
> allowed to eliminate the actual loading of tmp.y in the constructor, 
> but you should never eliminate the edge, the barriers that preclude 
> reordering of "shared=tmp;" with the place of the instruction loading 
> tmp.y in program order - because then observing "tmp.y=-1;" will 
> become possible again, and we arrive at contradiction as before.
>
>
> Since the instruction for the actual loading is not needed, and since 
> there is no case where it would be desirable to not have the volatile 
> load after the last volatile store in the constructor, the discussion 
> in [1] seems to have ended with a consensus that JMM must be rectified 
> to explicitly explain this case, and demand final-field semantics for 
> volatile stores in the constructor.
>
>
> Now recall that the actual code is:
>
> tmp=shared; // non-volatile load
> r1=tmp.x; // volatile load
>
>
> A mega-mind can figure out that now no contradiction arises from 
> reordering "shared=tmp;" and "tmp.x=-1;". But in practice there is no 
> way to determine that an arbitrary program will /*not*/ arrive at a 
> contradiction of some non-trivial kind (hello, Halting problem), so 
> the ordering of "shared=tmp;" will obey the laws that preclude the 
> contradiction /as if/ the code like that existed. This last bit is my 
> speculation about the reasons you will expect the volatile loads to 
> behave like expected even in the absence of a volatile store that it 
> can possibly observe.
>
>
> Alex
>
>
> On 04/03/2014 05:35, Vladimir Sitnikov wrote:
>>
>>     On 03/03/2014 22:54, Oleksandr Otenko wrote:
>>>     Gil's reasoning [3] is correct on [4] and [5] - 0 is not
>>>     allowable as the value of x there.
>>>
>> Can you please refer to JMM and/or peer-reviewed case study?
>>
>>
>>> These two are volatiles, so will appear in program order to all threads.
>> I am afraid this does not explain much.
>> If your reasoning "volatiles appear in program order" were applied to 
>> [1], then it would result that 0 is not allowable in [1].
>> On contrary, 0 *is* acceptable in [1] (see [2]), thus "volatiles 
>> appear in program order" is *not* always true.
>>
>> -- 
>> Regards,
>> Vladimir Sitnikov
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/1944f399/attachment-0001.html>

From david.lloyd at redhat.com  Tue Mar  4 10:20:39 2014
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Tue, 04 Mar 2014 09:20:39 -0600
Subject: [concurrency-interest] Comparing semantics of
 j.l.c.l.Condition.await/signal with j.l.Object.wait/notify
In-Reply-To: <5315CE44.8020905@gmail.com>
References: <5315CE44.8020905@gmail.com>
Message-ID: <5315EF47.7080508@redhat.com>

On 03/04/2014 06:59 AM, Peter Levart wrote:
> Hi,
>
> I'm reading the javadoc for java.lang.concurrent.locks.Condition.await()
> method which states:
>
> /"An implementation can favor responding to an interrupt over normal
> method return in response to a signal. In that case the implementation
> must ensure that the signal is redirected to another waiting thread, if
> there is one.//"/
>
> This could be interpreted as "reliable signal delivery". So one could
> write code like:
>
>      try {
>          condition.await();
>      } catch (InterruptedException e) {
>          // need not check the condition here, just handle the interrupt
> since
>          // the signal will be delivered to some other waiting thread if
> there is one
>      }
>
> ...is this really the semantics that can be relied upon?
>
> What about Object.wait() when paired with Object.notify()? The javadoc
> does not specify exactly that an exceptional return could also mean that
> the same thread might have also been chosen by concurrent
> Object.notify(), but does not specify a similar guarantee as
> Condition.await() either...
>
> Does anybody know what guarantees does Object.wait/notify provide when
> faced with concurrent thread interruptions?

Yikes.  I have always assumed that signal notification would be 
reliable... really a lot of JBoss code will be potentially broken if 
this is not true. :-(

Worth noting is that JLS 17.2.1 [1] talks about the behavior of wait:

"If the interrupt is deemed to have occurred first, then t will 
eventually return from wait by throwing InterruptedException, and some 
other thread in the wait set for m (if any exist at the time of the 
notification) must receive the notification. If the notification is 
deemed to have occurred first, then t will eventually return normally 
from wait with an interrupt still pending."

So this seems to match my assumption that signal delivery is in fact 
reliable in the face of interruption.

[1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.2.1

-- 
- DML

From martinrb at google.com  Tue Mar  4 10:43:59 2014
From: martinrb at google.com (Martin Buchholz)
Date: Tue, 4 Mar 2014 07:43:59 -0800
Subject: [concurrency-interest] Comparing semantics of
 j.l.c.l.Condition.await/signal with j.l.Object.wait/notify
In-Reply-To: <5315CE44.8020905@gmail.com>
References: <5315CE44.8020905@gmail.com>
Message-ID: <CA+kOe08eL_g5OEQ4z7gC2FLT4sSr+NB_Qkf-1LrYN_ierK2vLA@mail.gmail.com>

This sort of issue has been discussed on this list in the past, sometimes
with a bit of friendly sparring between myself and David Holmes.  We have
modified j.u.c. code so that it always assumes that signals are never lost
by j.u.c. classes, and I have advocated for more guarantees in javadoc, but
not succeeded.

http://markmail.org/search/?q=signal%20interrupt%20list%3Aconcurrency-interest%20buchholz#query:signal%20interrupt%20buchholz%20list%3Aedu.oswego.cs.concurrency-interest%20from%3A%22Martin%20Buchholz%22+page:1+mid:sqrxwram37hg3xq3+state:results


On Tue, Mar 4, 2014 at 4:59 AM, Peter Levart <peter.levart at gmail.com> wrote:

>  Hi,
>
> I'm reading the javadoc for java.lang.concurrent.locks.Condition.await()
> method which states:
>
> *"An implementation can favor responding to an interrupt over normal
> method return in response to a signal. In that case the implementation must
> ensure that the signal is redirected to another waiting thread, if there is
> one.**"*
>
> This could be interpreted as "reliable signal delivery". So one could
> write code like:
>
>     try {
>         condition.await();
>     } catch (InterruptedException e) {
>         // need not check the condition here, just handle the interrupt
> since
>         // the signal will be delivered to some other waiting thread if
> there is one
>     }
>
> ...is this really the semantics that can be relied upon?
>
> What about Object.wait() when paired with Object.notify()? The javadoc
> does not specify exactly that an exceptional return could also mean that
> the same thread might have also been chosen by concurrent Object.notify(),
> but does not specify a similar guarantee as Condition.await() either...
>
> Does anybody know what guarantees does Object.wait/notify provide when
> faced with concurrent thread interruptions?
>
>
> Regards, Peter
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/62b1cc4a/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar  4 11:14:14 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 04 Mar 2014 16:14:14 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <5315E430.5020503@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com>
Message-ID: <5315FBD6.5040800@oracle.com>

clarification: " if thread 1 observes "tmp.y=-1;", thread 2 /has/ to 
observe "tmp.x=-1;"."

There may be confusion which tmp.y=-1 I mean. Here I mean the volatile 
store of thread 1. It would be better to put it as "if tmp.y=-1 executed 
by thread 2 appears after the volatile load of tmp.y by thread 1 in 
synchronization order, thread 2 has to observe "tmp.x=-1;"".

Alex

On 04/03/2014 14:33, Oleksandr Otenko wrote:
> In [1] reference publication is unrelated to actions observing the 
> volatile store, so may appear before volatile store to other observers.
>
> Like so:
>
> tmp.x=-1; // volatile store
> shared=tmp; // non-volatile store
>
> another thread:
>
> tmp=shared; // non-volatile load
> r1=tmp.x; // volatile load
>
>
> So, here you have program order between "tmp.x=-1;" and "shared=tmp;", 
> and you have program order between "tmp=shared;" and "r1=tmp.x;". You 
> also have synchronization order between "tmp.x=-1;" and "r1=tmp.x;".
>
> What order do you have between "r1=tmp.x;" and "shared=tmp;"? None. 
> But a prerequisite for always observing "-1" is a edge proving that 
> "r1=tmp.x;" can only occur after "shared=tmp;".
>
>
> In terms of cookbook Gil refers to, this is equivalent to saying that 
> a normal store "shared=tmp;" can go ahead of a volatile store 
> "tmp.x=-1;", which means "tmp=shared;" may observe non-null value 
> before "tmp.x=-1;" completes.
>
>
> [4] is different.
>
> tmp.x=-1; // volatile store
> tmp.y=-1; // volatile store
> tmp.x=tmp.y; // volatile load, then volatile store
> shared=tmp; // non-volatile store
>
> Assuming there is another thread:
>
> tmp=shared; // non-volatile load
> tmp.y=-1; // volatile store; extra line
> r1=tmp.x; // volatile load
>
> The proof that r1==0 is impossible is a proof by contradiction.
>
> Forget for a moment that this is a constructor and that "shared==null" 
> until "shared=tmp;" can be observed. Here we have program order 
> between each line of the corresponding threads, and a synchronization 
> order between "tmp.y=-1;" and " tmp.x=tmp.y;" in addition to the 
> synchronization order like in [1] between "tmp.x=-1;" and "r1=tmp.x;". 
> The important consequence of this code is mutual exclusion of certain 
> outcomes: if thread 1 observes "tmp.y=-1;", thread 2 /has/ to observe 
> "tmp.x=-1;". Then due to program order of "r1=tmp.x;" it cannot 
> observe "tmp.x==0;", therefore, cannot observe "shared=tmp;" before 
> "tmp.y=-1;". There still is no edge between "r1=tmp.x;" and 
> "shared=tmp;", like in [1], but by contradiction there is no possible 
> way to allow observing "shared=tmp;" before "tmp.x=-1;".
>
> The consequence is that "shared=tmp;" must be ordered in such a way 
> that precludes thread 2 to observe it before load of tmp.y finishes. 
> This is why Gil's reference to the cookbook is correct - nothing 
> (normal store in this case) is allowed to go ahead of a volatile load 
> (tmp.y loaded by "tmp.x=tmp.y;").
>
> Now recall that this is a constructor and that loading tmp.y in thread 
> 1 cannot observe "tmp.y=-1;" before thread 2 can observe 
> "shared=tmp;". So thread 2 cannot ever construct the code that can 
> have a volatile store observable from constructor. So you should be 
> allowed to eliminate the actual loading of tmp.y in the constructor, 
> but you should never eliminate the edge, the barriers that preclude 
> reordering of "shared=tmp;" with the place of the instruction loading 
> tmp.y in program order - because then observing "tmp.y=-1;" will 
> become possible again, and we arrive at contradiction as before.
>
>
> Since the instruction for the actual loading is not needed, and since 
> there is no case where it would be desirable to not have the volatile 
> load after the last volatile store in the constructor, the discussion 
> in [1] seems to have ended with a consensus that JMM must be rectified 
> to explicitly explain this case, and demand final-field semantics for 
> volatile stores in the constructor.
>
>
> Now recall that the actual code is:
>
> tmp=shared; // non-volatile load
> r1=tmp.x; // volatile load
>
>
> A mega-mind can figure out that now no contradiction arises from 
> reordering "shared=tmp;" and "tmp.x=-1;". But in practice there is no 
> way to determine that an arbitrary program will /*not*/ arrive at a 
> contradiction of some non-trivial kind (hello, Halting problem), so 
> the ordering of "shared=tmp;" will obey the laws that preclude the 
> contradiction /as if/ the code like that existed. This last bit is my 
> speculation about the reasons you will expect the volatile loads to 
> behave like expected even in the absence of a volatile store that it 
> can possibly observe.
>
>
> Alex
>
>
> On 04/03/2014 05:35, Vladimir Sitnikov wrote:
>>
>>     On 03/03/2014 22:54, Oleksandr Otenko wrote:
>>>     Gil's reasoning [3] is correct on [4] and [5] - 0 is not
>>>     allowable as the value of x there.
>>>
>> Can you please refer to JMM and/or peer-reviewed case study?
>>
>>
>>> These two are volatiles, so will appear in program order to all threads.
>> I am afraid this does not explain much.
>> If your reasoning "volatiles appear in program order" were applied to 
>> [1], then it would result that 0 is not allowable in [1].
>> On contrary, 0 *is* acceptable in [1] (see [2]), thus "volatiles 
>> appear in program order" is *not* always true.
>>
>> -- 
>> Regards,
>> Vladimir Sitnikov
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/8d5f3337/attachment.html>

From sitnikov.vladimir at gmail.com  Tue Mar  4 12:55:19 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Tue, 4 Mar 2014 21:55:19 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <5315FBD6.5040800@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
Message-ID: <CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>

>
> [4] is different

tmp.y=-1; // volatile store; extra line

Why do you add extra line?
It does not exist in the original case.

in addition to the synchronization order like in [1] between "tmp.x=-1;"
> and "r1=tmp.x;"

Why do you think we always have synchronization order here?
In executions when tmp.x is not subsequent to tmp.x=1 no synchronization
order appear between these actions.

It would be better to put it as "if tmp.y=-1 executed by thread 2 appears
> after the volatile load of tmp.y by thread 1 in synchronization order,
> thread 2 has to observe "tmp.x=-1;"".

Can you please perform reasoning when thread2 does not perform any
additional loads and stores?


> A mega-mind can figure out that now no contradiction arises from
> reordering "shared=tmp;" and "tmp.x=-1;". But in practice there is no way
> to determine that an arbitrary program will *not* arrive at a
> contradiction of some non-trivial kind (hello, Halting problem), so the
> ordering of "shared=tmp;" will obey the laws that preclude the
> contradiction *as if* the code like that existed. This last bit is my
> speculation about the reasons you will expect the volatile loads to behave
> like expected even in the absence of a volatile store that it can possibly
> observe.
>
That is clear.
However, say we launch Graal compiler and feed it with test [4]. It might
be powerful enough to solve the particular case.
The question is if it is allowable to "reorder" shared=tmp for a particular
program [4] and [5] to the very top of constructor.

Even cookbook allows demoting volatile to non-volatile:

> Similarly, a volatile field provably accessible from only a single thread
> acts as a normal field.


--
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/d49ac5be/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar  4 14:31:55 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 04 Mar 2014 19:31:55 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
Message-ID: <53162A2B.3060409@oracle.com>

On 04/03/2014 17:55, Vladimir Sitnikov wrote:
>
>     [4] is different
>
>     tmp.y=-1; // volatile store; extra line 
>
> Why do you add extra line?
> It does not exist in the original case.

I know. This extra line is needed to show for which case the ordering 
must be preserved in such a way that another thread can tell whether 
publishing of reference went ahead of loading tmp.y in thread 1.

Without this line there are two problems: data dependency does not 
guarantee the order in which the operations are observed; and there is 
no ordering of reference publishing with respect to any instructions in 
thread 2.

>
>     in addition to the synchronization order like in [1] between
>     "tmp.x=-1;" and "r1=tmp.x;"
>
> Why do you think we always have synchronization order here?
> In executions when tmp.x is not subsequent to tmp.x=1 no 
> synchronization order appear between these actions.
I meant synchronizes-with.


>
>     It would be better to put it as "if tmp.y=-1 executed by thread 2
>     appears after the volatile load of tmp.y by thread 1 in
>     synchronization order, thread 2 has to observe "tmp.x=-1;"".
>
> Can you please perform reasoning when thread2 does not perform any 
> additional loads and stores?
>
>     A mega-mind can figure out that now no contradiction arises from
>     reordering "shared=tmp;" and "tmp.x=-1;". But in practice there is
>     no way to determine that an arbitrary program will /*not*/ arrive
>     at a contradiction of some non-trivial kind (hello, Halting
>     problem), so the ordering of "shared=tmp;" will obey the laws that
>     preclude the contradiction /as if/ the code like that existed.
>     This last bit is my speculation about the reasons you will expect
>     the volatile loads to behave like expected even in the absence of
>     a volatile store that it can possibly observe.
>
> That is clear.
> However, say we launch Graal compiler and feed it with test [4]. It 
> might be powerful enough to solve the particular case.
> The question is if it is allowable to "reorder" shared=tmp for a 
> particular program [4] and [5] to the very top of constructor.
>
> Even cookbook allows demoting volatile to non-volatile:
>
>     Similarly, a volatile field provably accessible from only a single
>     thread acts as a normal field. 
>
>
Well, all optimizations are subject to the proof that it does not 
deviate from the semantics of the code without this optimization.

With the extra line:
W, R - volatile write and read
w, r - non-volatile write and read
X, Y, S - x, y and shared respectively

The program order and synchronizes-with edges essentially are:

W X    r S
  | |    |
  ^  ^   ^
  |  |   |
R Y->--W Y
  |   |  |
  ^    | ^
  |     ||
w S    R X

With the extra line we have the edge RY->WY. This way we can reason that 
w S must be ordered in such a way that a thread observing that R Y was 
after W Y should conclude that r S was before w S. This means those 
threads must also conclude that w S could not occur before W X, even 
though they don't see w S in synchronization order. This is the reason 
non-volatiles are not allowed to go ahead of volatile load in practice, 
even though it really concerns only the threads that do have W Y in theory.

With W Y not there (the original problem) there are two things to look 
out for: now there is no longer the contradiction that reordering of w S 
with R Y would yield - no order between w S and r S can be established 
in any thread; but this requires a mega-mind to optimize away R Y /and/ 
its barrier. And, secondly, R X no longer is observed after r S by 
others, because the barrier is gone. This point is much more pressing, 
because it does not require a mega-mind to conclude no ordering is 
required there.

So I believe theoretically there is a problem with the absence of 
RY->WY, but in practice the bigger problem is the absence of a barrier 
between r S and R X. Whether theoretically the first problem is still 
there depends on how you introduce the load-load barrier in practice. :-)

And, amending JMM to treat volatiles in constructors as final field 
assignments w.r.t visibility guarantees, solves both problems.


Alex


> --
> Vladimir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/6f8f7266/attachment.html>

From sitnikov.vladimir at gmail.com  Tue Mar  4 15:03:16 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Wed, 5 Mar 2014 00:03:16 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53162A2B.3060409@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
Message-ID: <CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>

>
> Without this line there are two problems: data dependency does not
> guarantee the order in which the operations are observed; and there is no
> ordering of reference publishing with respect to any instructions in thread
> 2.

In other words, you accept that cases [4] and [5] allow observing of
default value in actor2?

With the extra line

With extra line the runtime might want to deoptimize (i.e. initially
compile speculative code and hotswap it later).
Any chance there is a valid reasoning regarding the original example
without introducing extra variables?

in addition to the synchronization order like in [1] between "tmp.x=-1;"
> and "r1=tmp.x;"

I meant synchronizes-with.

Why?

Quote from JSR-133

> A write to a volatile variable v synchronizes-with all subsequent reads of
> v by any thread (where subsequent is de?ned according to the
> synchronization order).

Volatile write does not synchronize-with read if the read is not subsequent
(in terms of synchronization order)

Write of default values does synchronize-with "volatile read" (JSR-133
quote "The write of the default value (zero, false or null) to each
variable synchronizes-with to the ?rst action in every thread").
However it might be the case that volatile write does not synchronize-with
volatile read of the same variable.

--
Vladimir?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/3975c1b5/attachment-0001.html>

From davidcholmes at aapt.net.au  Tue Mar  4 17:35:40 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 5 Mar 2014 08:35:40 +1000
Subject: [concurrency-interest] Comparing semantics
	ofj.l.c.l.Condition.await/signal with j.l.Object.wait/notify
In-Reply-To: <5315CE44.8020905@gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEOGKEAA.davidcholmes@aapt.net.au>

Hi Peter,

The basic rule that we documented for Condition.await, and that we ensure is
implemented in hotspot for both Conditions and Object.wait, is that
"signals" must never be lost. A waiting thread either "consumes" a "signal"
or else returns due to timeout, interrupt or spurious.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter Levart
  Sent: Tuesday, 4 March 2014 11:00 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Comparing semantics
ofj.l.c.l.Condition.await/signal with j.l.Object.wait/notify


  Hi,

  I'm reading the javadoc for java.lang.concurrent.locks.Condition.await()
method which states:

  "An implementation can favor responding to an interrupt over normal method
return in response to a signal. In that case the implementation must ensure
that the signal is redirected to another waiting thread, if there is one."

  This could be interpreted as "reliable signal delivery". So one could
write code like:

      try {
          condition.await();
      } catch (InterruptedException e) {
          // need not check the condition here, just handle the interrupt
since
          // the signal will be delivered to some other waiting thread if
there is one
      }

  ...is this really the semantics that can be relied upon?

  What about Object.wait() when paired with Object.notify()? The javadoc
does not specify exactly that an exceptional return could also mean that the
same thread might have also been chosen by concurrent Object.notify(), but
does not specify a similar guarantee as Condition.await() either...

  Does anybody know what guarantees does Object.wait/notify provide when
faced with concurrent thread interruptions?


  Regards, Peter

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/88b24ca5/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar  4 17:51:13 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 04 Mar 2014 22:51:13 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
Message-ID: <531658E1.1080709@oracle.com>

You need to remember the context of discussion in [1] was assigning a 
value to a volatile variable that does get used as a volatile, so you 
will expect W Y somewhere after r S, and the most the compiler can do in 
this case in [4], is eliminate a R Y, but not the barrier.

[4] and [5] have far less clear objectives.


On 04/03/2014 20:03, Vladimir Sitnikov wrote:
>
>     Without this line there are two problems: data dependency does not
>     guarantee the order in which the operations are observed; and
>     there is no ordering of reference publishing with respect to any
>     instructions in thread 2.
>
> In other words, you accept that cases [4] and [5] allow observing of 
> default value in actor2?
>
>     With the extra line
>
> With extra line the runtime might want to deoptimize (i.e. initially 
> compile speculative code and hotswap it later).
> Any chance there is a valid reasoning regarding the original example 
> without introducing extra variables?
>
>>     in addition to the synchronization order like in [1] between
>>     "tmp.x=-1;" and "r1=tmp.x;"
>>
>>     I meant synchronizes-with.
>>
> Why?
>
> Quote from JSR-133
>
>     A write to a volatile variable v synchronizes-with all subsequent
>     reads of v by any thread (where subsequent is de?ned according to
>     the synchronization order).
>
> Volatile write does not synchronize-with read if the read is not 
> subsequent (in terms of synchronization order)
>
> Write of default values does synchronize-with "volatile read" (JSR-133 
> quote "The write of the default value (zero, false or null) to each 
> variable synchronizes-with to the ?rst action in every thread").
> However it might be the case that volatile write does not 
> synchronize-with volatile read of the same variable.

I don't understand the objection. "r1=tmp.x" may or may not observe the 
effects of "tmp.x=-1". This is no different to a normal read or write. 
The difference with volatiles is that if it does observe "tmp.x=-1", 
then we can prove the operations preceding "tmp.x=-1" in program order 
have occurred before "r1=tmp.x", whereas normal reads don't provide 
proofs of order of other operations in the thread whose write we 
observe, including that the same operations may be witnessed in 
different orders by different threads for unspecified reasons.


Alex


>
> -- 
> Vladimir?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140304/02771584/attachment.html>

From sitnikov.vladimir at gmail.com  Wed Mar  5 01:37:45 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Wed, 5 Mar 2014 10:37:45 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <531658E1.1080709@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
Message-ID: <CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>

>
> the context of discussion in [1] was assigning a value to a volatile
> variable that does get used as a volatile

I do not follow you. No unsafe is used, thus volatile variable is always
used as volatile.

Here is the trace that results in 0 observed in actor2:

   read(s.shell, !null)
     \-po-> vread(sh.x, 0)
              \-so-> vstore(this.x, -1)
                        \-po-> vread(this.x, -1)
                                 \-po-> vstore(this.y, -1)
                                           \-po-> vread(this.y, -1)
                                                    \-po-> vstore(this.x, -1)
                                                             \-po->
vstore(s.shell)

The first two actions (in the listed above order) are the actions of
actor2, the rest is actor1.

Let us pick synchronization order as above: vstore(this.x, 0) -so->
vread(sh.x, 0) -so-> vstore(this.x, -1) -so-> vread(this.x, -1)
-so->...

Note that we don't get vread(sh.x, 0) --hb--> vstore(this.x, -1), so
there is no read(s.shell, !null) --hb--> vstore(s.shell), so there is
no violation of happens-before and write-seen.

So we commit the trace as follows:

1. C1: commit initializations s.shell=null, shell.x=0, and vstore(s.shell)

2. C2: commit read(s.shell, !null)

3. C3: commit read(sh.x, 0). The read sees the default value: it is
the only write to x yet committed.

4. commit all the remaining actions

--
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/a602a909/attachment.html>

From peter.levart at gmail.com  Wed Mar  5 02:57:58 2014
From: peter.levart at gmail.com (Peter Levart)
Date: Wed, 05 Mar 2014 08:57:58 +0100
Subject: [concurrency-interest] Comparing semantics
 ofj.l.c.l.Condition.await/signal with j.l.Object.wait/notify
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEOGKEAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCCEOGKEAA.davidcholmes@aapt.net.au>
Message-ID: <5316D906.20502@gmail.com>

Thank you all for clarifications.

Regards, Peter

On 03/04/2014 11:35 PM, David Holmes wrote:
> Hi Peter,
> The basic rule that we documented for Condition.await, and that we 
> ensure is implemented in hotspot for both Conditions and Object.wait, 
> is that "signals" must never be lost. A waiting thread either 
> "consumes" a "signal" or else returns due to timeout, interrupt or 
> spurious.
> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of
>     *Peter Levart
>     *Sent:* Tuesday, 4 March 2014 11:00 PM
>     *To:* concurrency-interest at cs.oswego.edu
>     *Subject:* [concurrency-interest] Comparing semantics
>     ofj.l.c.l.Condition.await/signal with j.l.Object.wait/notify
>
>     Hi,
>
>     I'm reading the javadoc for
>     java.lang.concurrent.locks.Condition.await() method which states:
>
>     /"An implementation can favor responding to an interrupt over
>     normal method return in response to a signal. In that case the
>     implementation must ensure that the signal is redirected to
>     another waiting thread, if there is one.//"/
>
>     This could be interpreted as "reliable signal delivery". So one
>     could write code like:
>
>         try {
>             condition.await();
>         } catch (InterruptedException e) {
>             // need not check the condition here, just handle the
>     interrupt since
>             // the signal will be delivered to some other waiting
>     thread if there is one
>         }
>
>     ...is this really the semantics that can be relied upon?
>
>     What about Object.wait() when paired with Object.notify()? The
>     javadoc does not specify exactly that an exceptional return could
>     also mean that the same thread might have also been chosen by
>     concurrent Object.notify(), but does not specify a similar
>     guarantee as Condition.await() either...
>
>     Does anybody know what guarantees does Object.wait/notify provide
>     when faced with concurrent thread interruptions?
>
>
>     Regards, Peter
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/b935afff/attachment-0001.html>

From dl at cs.oswego.edu  Wed Mar  5 07:54:01 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 05 Mar 2014 07:54:01 -0500
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>
	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>
	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
Message-ID: <53171E69.3070209@cs.oswego.edu>


Alex and Vladimir:  Thanks for trying to churn through JSR133
rules for these cases. Unfortunately there is no automated tool
for doing this as there is for the C/C++11 memory model
(http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/).
The main goals of JMM revision project are to simplify rules
considerably and address some suspicious consequences, including
these. Using JSR133, it seems impossible to give a general answer
to the question of whether a volatile field initialization
in a constructor will be seen in all racy publication scenarios.
This clearly should be addressed. On the other hand, allowing
racy publications is never a good idea, so the practical impact
is low.

Also, given that these cases will be addressed to at least
clarify outcomes, adding jcstress tests for them now doesn't
seem all that useful.

-Doug


On 03/05/2014 01:37 AM, Vladimir Sitnikov wrote:
>     the context of discussion in [1] was assigning a value to a volatile
>     variable that does get used as a volatile
>
> I do not follow you. No unsafe is used, thus volatile variable is always used as
> volatile.
>
> Here is the trace that results in 0 observed in actor2:
>
>     read(s.shell, !null)
>       \-po-> vread(sh.x, 0)
>                \-so-> vstore(this.x, -1)
>                          \-po-> vread(this.x, -1)
>                                   \-po-> vstore(this.y, -1)
>                                             \-po-> vread(this.y, -1)
>                                                      \-po-> vstore(this.x, -1)
>                                                               \-po-> vstore(s.shell)
>
> The first two actions (in the listed above order) are the actions of actor2, the rest is actor1.
>
> Let us pick synchronization order as above: vstore(this.x, 0) -so-> vread(sh.x, 0) -so-> vstore(this.x, -1) -so-> vread(this.x, -1) -so->...
>
> Note that we don't get vread(sh.x, 0) --hb--> vstore(this.x, -1), so there is no read(s.shell, !null) --hb--> vstore(s.shell), so there is no violation of happens-before and write-seen.
>
> So we commit the trace as follows:
>
> 1. C1: commit initializations s.shell=null, shell.x=0, and vstore(s.shell)
>
> 2. C2: commit read(s.shell, !null)
>
> 3. C3: commit read(sh.x, 0). The read sees the default value: it is the only write to x yet committed.
>
> 4. commit all the remaining actions
>
> --
> Vladimir
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From sitnikov.vladimir at gmail.com  Wed Mar  5 08:14:51 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Wed, 5 Mar 2014 17:14:51 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53171E69.3070209@cs.oswego.edu>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
	<53171E69.3070209@cs.oswego.edu>
Message-ID: <CAB=Je-Gwyg1xOG-DOg-_R-R4+7ZKFRDy=0J1JiFeejCAGF+7Ow@mail.gmail.com>

>
> Also, given that these cases will be addressed to at least
> clarify outcomes, adding jcstress tests for them now doesn't
> seem all that useful.
>
> What will happen if fields are written after object construction?

The original question of [3] is "Unfortunately the initialization can only
be done via a setter hence the var can't be declared final".
So question of "will it blend" is still open even if all the initialization
in constructor are safe:  sh=new Shell(); sh.x=-1; sh.y=sh.x; sh.x=s.y;
shared=sh;
Will this case be covered as well by JMM revision?

On the other hand, allowing racy publications is never a good idea, so the
> practical impact is low.

That is clear. The problem is from time to time someone tries to "optimize"
and eliminate volatile, synchronized, etc, so it makes sense to have some
building blocks prepared to refer to.

-- 
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/915bfb2d/attachment.html>

From dl at cs.oswego.edu  Wed Mar  5 08:26:25 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 05 Mar 2014 08:26:25 -0500
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-Gwyg1xOG-DOg-_R-R4+7ZKFRDy=0J1JiFeejCAGF+7Ow@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>
	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>
	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53171E69.3070209@cs.oswego.edu>
	<CAB=Je-Gwyg1xOG-DOg-_R-R4+7ZKFRDy=0J1JiFeejCAGF+7Ow@mail.gmail.com>
Message-ID: <53172601.3080000@cs.oswego.edu>

On 03/05/2014 08:14 AM, Vladimir Sitnikov wrote:
> The original question of [3] is "Unfortunately the initialization can only be
> done via a setter hence the var can't be declared final".
> So question of "will it blend" is still open even if all the initialization in
> constructor are safe:  sh=new Shell(); sh.x=-1; sh.y=sh.x; sh.x=s.y; shared=sh;
> Will this case be covered as well by JMM revision?

We expect that expressions of the form field.volatile.setRelease(value)
will be available. This alone does not and cannot provide
a complete answer in all scenarios though. Programmers must still
ensure that no leaks/aliases are possible upon first access.

-Doug



From sitnikov.vladimir at gmail.com  Wed Mar  5 09:29:12 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Wed, 5 Mar 2014 18:29:12 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53172601.3080000@cs.oswego.edu>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
	<53171E69.3070209@cs.oswego.edu>
	<CAB=Je-Gwyg1xOG-DOg-_R-R4+7ZKFRDy=0J1JiFeejCAGF+7Ow@mail.gmail.com>
	<53172601.3080000@cs.oswego.edu>
Message-ID: <CAB=Je-FZGKUXQEn5O+w440A3U2mzPgRcaCQZtE8pv5RY5pa5dw@mail.gmail.com>

So the ultimate answer is "do not code like in [4] and [5] since no one can
explain the consequences and since the behavior will be updated", isn't it?
That does not sound very promising.

-- 
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/af13b217/attachment.html>

From dl at cs.oswego.edu  Wed Mar  5 09:39:10 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 05 Mar 2014 09:39:10 -0500
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-FZGKUXQEn5O+w440A3U2mzPgRcaCQZtE8pv5RY5pa5dw@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53171E69.3070209@cs.oswego.edu>	<CAB=Je-Gwyg1xOG-DOg-_R-R4+7ZKFRDy=0J1JiFeejCAGF+7Ow@mail.gmail.com>	<53172601.3080000@cs.oswego.edu>
	<CAB=Je-FZGKUXQEn5O+w440A3U2mzPgRcaCQZtE8pv5RY5pa5dw@mail.gmail.com>
Message-ID: <5317370E.2010406@cs.oswego.edu>

On 03/05/2014 09:29 AM, Vladimir Sitnikov wrote:
> So the ultimate answer is "do not code like in [4] and [5] since no one can
> explain the consequences and since the behavior will be updated", isn't it?

The answer is: these examples are currently not provably correct.
So people should avoid them. Or take the risk that all JVM
implementations are more conservative than necessary and that
specs will be updated to reflect this.

> That does not sound very promising.

It is not a good state of affairs. If it were, we wouldn't
need a JMM revision.

-Doug


From oleksandr.otenko at oracle.com  Wed Mar  5 12:39:14 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 05 Mar 2014 17:39:14 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
Message-ID: <53176142.1020603@oracle.com>

On 05/03/2014 06:37, Vladimir Sitnikov wrote:
>
>     the context of discussion in [1] was assigning a value to a
>     volatile variable that does get used as a volatile
>
> I do not follow you. No unsafe is used, thus volatile variable is 
> always used as volatile.
>
> Here is the trace that results in 0 observed in actor2:
Because there is no barrier between tmp=shared and r1=tmp.x. This is 
racy independent of how the value is set in the constructor. So I keep 
mentioning the line that is needed for this to work, and what is needed 
if that line is not there - a load-load barrier.

Alex


>     read(s.shell, !null)
>       \-po-> vread(sh.x, 0)
>                \-so-> vstore(this.x, -1)
>                          \-po-> vread(this.x, -1)
>                                   \-po-> vstore(this.y, -1)
>                                             \-po-> vread(this.y, -1)
>                                                      \-po-> vstore(this.x, -1)
>                                                               \-po-> vstore(s.shell)
> The first two actions (in the listed above order) are the actions of actor2, the rest is actor1.
>
> Let us pick synchronization order as above: vstore(this.x, 0) -so-> vread(sh.x, 0) -so-> vstore(this.x, -1) -so-> vread(this.x, -1) -so->...
> Note that we don't get vread(sh.x, 0) --hb--> vstore(this.x, -1), so there is no read(s.shell, !null) --hb--> vstore(s.shell), so there is no violation of happens-before and write-seen.
>
> So we commit the trace as follows:
> 1. C1: commit initializations s.shell=null, shell.x=0, and vstore(s.shell)
> 2. C2: commit read(s.shell, !null)
> 3. C3: commit read(sh.x, 0). The read sees the default value: it is the only write to x yet committed.
> 4. commit all the remaining actions
> --
> Vladimir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/ecdc322f/attachment.html>

From sitnikov.vladimir at gmail.com  Wed Mar  5 12:58:24 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Wed, 5 Mar 2014 21:58:24 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53176142.1020603@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
	<53176142.1020603@oracle.com>
Message-ID: <CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>

>
> Because there is no barrier between tmp=shared and r1=tmp.x. This is racy
> independent of how the value is set in the constructor. So I keep
> mentioning the line that is needed for this to work, and what is needed if
> that line is not there - a load-load barrier.

1) Do you agree with the proof or not?

--
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/8f26789d/attachment.html>

From oleksandr.otenko at oracle.com  Wed Mar  5 15:16:21 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 05 Mar 2014 20:16:21 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>
	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>
Message-ID: <53178615.3010303@oracle.com>

I don't see how you prove absence of any HB between reading shared and 
reading tmp.y.


Alex


On 05/03/2014 17:58, Vladimir Sitnikov wrote:
>
>     Because there is no barrier between tmp=shared and r1=tmp.x. This
>     is racy independent of how the value is set in the constructor. So
>     I keep mentioning the line that is needed for this to work, and
>     what is needed if that line is not there - a load-load barrier.
>
> 1) Do you agree with the proof or not?
>
> --
> Vladimir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/d6bb9c33/attachment.html>

From oleksandr.otenko at oracle.com  Wed Mar  5 15:58:02 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Wed, 05 Mar 2014 20:58:02 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53178615.3010303@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>
	<53178615.3010303@oracle.com>
Message-ID: <53178FDA.40505@oracle.com>

Let me even put this clearer.

JMM does not talk about this, but it is a matter of relativistic nature 
of the world that:

even though normal write and read of shared, w S and r S, may be 
observed in unspecified order by threads, there are two threads that /do 
agree/ on their order.

Therefore, anyone observing w S is also guaranteed to observe other 
events in that thread, whose order with respect to w S is guaranteed - 
volatile loads, their preceding volatile stores, and any other 
instruction in program order preceding those volatile stores.

So, from the point where r S really occurs onwards the reads of X are 
guaranteed to observe non-zero value. In this sense the /publication/ is 
correct and safe, and Gil is right. That's the answer to the original 
question.

Yet, the accessor is not correct, because R X may be observed in 
different order with respect to r S. Once you enforce that by some means 
- turn r S into volatile read R S, add a volatile store of anything, or 
add a load-load barrier, the test will never observe zero.

Alex

On 05/03/2014 20:16, Oleksandr Otenko wrote:
> I don't see how you prove absence of any HB between reading shared and 
> reading tmp.y.
>
>
> Alex
>
>
> On 05/03/2014 17:58, Vladimir Sitnikov wrote:
>>
>>     Because there is no barrier between tmp=shared and r1=tmp.x. This
>>     is racy independent of how the value is set in the constructor.
>>     So I keep mentioning the line that is needed for this to work,
>>     and what is needed if that line is not there - a load-load barrier.
>>
>> 1) Do you agree with the proof or not?
>>
>> --
>> Vladimir
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140305/34f88834/attachment.html>

From sitnikov.vladimir at gmail.com  Thu Mar  6 01:21:32 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Thu, 6 Mar 2014 10:21:32 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53178FDA.40505@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
	<53176142.1020603@oracle.com>
	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>
	<53178615.3010303@oracle.com> <53178FDA.40505@oracle.com>
Message-ID: <CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>

Can you please pinpoint the section of JLS that induces vstore(this.x, -1)
--hb--> vread(sh.x) ?
Below I elaborate why no such happens-before is required by JLS 7.

there are two threads that *do agree* on their order.

Please pinpoint the relevant section of JLS.
I see 0 occurrences of "agree" in chapter 17 of JLS.


I don't see how you prove absence of any HB between reading shared and
> reading tmp.y.

There _is_ read(tmp, !null) --hb--> vread(tmp.y) since those actions happen
in single thread, however this HB says _nothing_ on the write that is
observable by vread(tmp.y) in actor2.
> JLS 17.4.5: If *x* and *y* are actions of the same thread and *x* comes
before *y* in program order, then *hb(x, y)*.

There is _no_ vstore(tmp.y, -1) (action of actor1) --hb--> read(tmp, !null)
(action of actor2)
Those are the actions of different threads, thus "If *x* and *y* are
actions of the same thread and *x* comes before *y* in program order,
then *hb(x,
y)*." does not apply.
Finalizers are not involved, synchornized-with are not involved as well.
Transitive happens-before cannot be induced.

There is _no_ vstore(tmp.y, -1) (action of actor1) --hb--> vread(tmp.y)
(action of actor2)
There is no happens-before, since those actions do _not_ synchronize-with
since vread is _not_ subsequent.
>
> JLS 17.4.4: A write to a volatile variable v (?8.3.1.4) synchronizes-with
> all subsequent reads of v by any thread (where "subsequent" is defined
> according to the synchronization order).

Note that I've picked synchronization order as follows: vstore(this.x, 0)
-so-> vread(sh.x, 0) -so-> vstore(this.x, -1) -so-> vread(this.x, -1)
-so->..  With this order, vread(sh.x, 0) is not subsequent to
vstore(this.x, -1), thus no synchronized-with, thus no happens-before.

To sum it up, there is no vstore(this.x, -1) --hb--> vread(sh.x) (direct or
transitive).

--
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140306/9b79dc23/attachment-0001.html>

From oleksandr.otenko at oracle.com  Thu Mar  6 06:32:04 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Thu, 06 Mar 2014 11:32:04 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>
	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
Message-ID: <53185CB4.7040203@oracle.com>

JMM is a model of reality.

The threads interact by sending signals over space (CPU interconnects) 
and time (sharing CPU). The thread that performs the normal write, w S, 
and the thread performing the normal read, r S, are bound to agree that 
r S occurs after w S.

JLS will not talk about this, because it complicates the matter - these 
observations are clearly not transitive. The spec only talks about 
correctness condition of /race-free/ algorithms. It does not set out to 
specify the outcomes of racy algorithms.

So, because this problem has "race" in its title, I believe you are 
using the wrong tool to prove something about this algorithm.


Alex


On 06/03/2014 06:21, Vladimir Sitnikov wrote:
> Can you please pinpoint the section of JLS that induces vstore(this.x, 
> -1) --hb--> vread(sh.x) ?
> Below I elaborate why no such happens-before is required by JLS 7.
>
>     there are two threads that /do agree/ on their order.
>
> Please pinpoint the relevant section of JLS.
> I see 0 occurrences of "agree" in chapter 17 of JLS.
>
>     I don't see how you prove absence of any HB between reading shared
>     and reading tmp.y.
>
> There _is_ read(tmp, !null) --hb--> vread(tmp.y) since those actions 
> happen in single thread, however this HB says _nothing_ on the write 
> that is observable by vread(tmp.y) in actor2.
> > JLS 17.4.5: If /x/and/y/are actions of the same thread and/x/comes 
> before/y/in program order, then/hb(x, y)/.
>
> There is _no_ vstore(tmp.y, -1) (action of actor1) --hb--> read(tmp, 
> !null) (action of actor2)
> Those are the actions of different threads, thus "If /x/and/y/are 
> actions of the same thread and/x/comes before/y/in program order, 
> then/hb(x, y)/." does not apply.
> Finalizers are not involved, synchornized-with are not involved as well.
> Transitive happens-before cannot be induced.
>
> There is _no_ vstore(tmp.y, -1) (action of actor1) --hb--> 
> vread(tmp.y) (action of actor2)
> There is no happens-before, since those actions do _not_ 
> synchronize-with since vread is _not_ subsequent.
>
>     JLS 17.4.4: A write to a volatile variable v (?8.3.1.4)
>     synchronizes-with all subsequent reads of v by any thread (where
>     "subsequent" is defined according to the synchronization order).
>
> Note that I've picked synchronization order as follows: vstore(this.x, 
> 0) -so-> vread(sh.x, 0) -so-> vstore(this.x, -1) -so-> vread(this.x, 
> -1) -so->..  With this order, vread(sh.x, 0) is not subsequent to 
> vstore(this.x, -1), thus no synchronized-with, thus no happens-before.
>
> To sum it up, there is no vstore(this.x, -1) --hb--> vread(sh.x) 
> (direct or transitive).
>
> --
> Vladimir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140306/3ffad863/attachment.html>

From aleksey.shipilev at oracle.com  Thu Mar  6 07:08:07 2014
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 06 Mar 2014 16:08:07 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53185CB4.7040203@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com>
Message-ID: <53186527.1060001@oracle.com>

On 03/06/2014 03:32 PM, Oleksandr Otenko wrote:
> JMM is a model of reality.

No, it isn't. Bringing the "reality" analogies while reasoning about the
formal spec is an attractive option, but unfortunately it is very
unreliable. I, for one, would like people to answer Vladimir's questions
based on spec, not based on the implementations out there (that includes
observations how current hardware works), or the speculations how the
world works.

> The spec only talks about correctness condition of /race-free/
> algorithms. It does not set out to specify the outcomes of racy
> algorithms.

Yes, it does. Simplest counter-example: final fields.

> So, because this problem has "race" in its title, I believe you are
> using the wrong tool to prove something about this algorithm.

I don't think it is a wrong approach, see the entire section on
committing the actions. Even when the execution has the racy reads, some
outcomes are forbidden, e.g. to avoid OoTA. Spec might be overly
complicated and broken for some scenarios though, this is why Doug is
reluctant to give the blessing on the correctness :)

-Aleksey.

From oleksandr.otenko at oracle.com  Thu Mar  6 09:12:58 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Thu, 06 Mar 2014 14:12:58 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53186527.1060001@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com> <53186527.1060001@oracle.com>
Message-ID: <5318826A.1020700@oracle.com>

On 06/03/2014 12:08, Aleksey Shipilev wrote:
> On 03/06/2014 03:32 PM, Oleksandr Otenko wrote:
>> JMM is a model of reality.
> No, it isn't. Bringing the "reality" analogies while reasoning about the
> formal spec is an attractive option, but unfortunately it is very
> unreliable. I, for one, would like people to answer Vladimir's questions
> based on spec, not based on the implementations out there (that includes
> observations how current hardware works), or the speculations how the
> world works.
Well, the specification has many clauses that are fuzzy enough for the 
proof to not be strict.

Given the spec, prove that at the time tmp=shared it must be always the 
case that loading of tmp.y has occurred - forget the rest of the test 
for the moment.

To my mind, it is easy enough to see that the observation of the 
opposite is not allowed by language semantics.

I'll start with the modified example where my point will be more 
obvious. Quoting just the relevant bit:

     r S
         |
         ^
         |
R Y->--W Y
  |
  ^
  |
w S

If you permit such ordering of R Y and W Y that volatile read of Y, R Y, 
observes the effects of volatile write of Y, W Y, then don't we have a 
transitive closure (or whatever the term was) of orders, which make the 
order of normal read and write of shared, r S and w S, violate language 
semantics? I am not sure if this "violate language semantics" applies 
here or not. This is what I mean "fuzzy enough". I think it does apply here.

Since this outcome is not allowed, what is W Y doing there? R Y will 
never observe its effects (I think the term is "synchronize-with it"). 
Do you know how to explain the difference in the permitted behaviour of 
the program in the absence of W Y? (or replace it with W Z and show that 
the total order of W Z preceding R Y is not allowed)

By the way, the meaning of this discussion is more than just this 
example here. It rests on the origins of the statement in the cookbook 
that the normal reads and writes are not allowed to go ahead of volatile 
reads - all threads agree that w S occurs after R Y, and my reading is 
that it is so whether W Y is there or not.

Alex

>
>> The spec only talks about correctness condition of /race-free/
>> algorithms. It does not set out to specify the outcomes of racy
>> algorithms.
> Yes, it does. Simplest counter-example: final fields.
>
>> So, because this problem has "race" in its title, I believe you are
>> using the wrong tool to prove something about this algorithm.
> I don't think it is a wrong approach, see the entire section on
> committing the actions. Even when the execution has the racy reads, some
> outcomes are forbidden, e.g. to avoid OoTA. Spec might be overly
> complicated and broken for some scenarios though, this is why Doug is
> reluctant to give the blessing on the correctness :)
>
> -Aleksey.


From aleksey.shipilev at oracle.com  Thu Mar  6 09:53:24 2014
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Thu, 06 Mar 2014 18:53:24 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <5318826A.1020700@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com> <53186527.1060001@oracle.com>
	<5318826A.1020700@oracle.com>
Message-ID: <53188BE4.2020700@oracle.com>

On 03/06/2014 06:12 PM, Oleksandr Otenko wrote:
> I'll start with the modified example where my point will be more
> obvious. Quoting just the relevant bit:
> 
>     r S
>         |
>         ^
>         |
> R Y->--W Y
>  |
>  ^
>  |
> w S

You lost me right here, I can't understand your example. I can vaguely
understand "r S" is a read of "S". But what do arrows signify? Please be
more rigorous: that is, I would like the example which builds on the
formalisms of spec, and does it in the form the readers of this list are
used to, e.g. read(y), vwrite(y), --hb-->, --sw-->, --so-->, etc.

I chimed in mostly because Vladimir seems to ask for the same: instead
of building up some wacked interpretation of spec, let's build on
something already written out in the spec. Vladimir had started doing
that here:
 http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012450.html

...and I think that's an approach to go, because it follows the spec
mechanics: it builds the candidate execution yielding the result we are
looking for, proves execution consistency, and validates the execution
by committing the actions from it. Is there an error in Vladimir's
proof, which makes that execution non-plausible?

-Aleksey.

From valentin.male.kovalenko at gmail.com  Thu Mar  6 11:45:49 2014
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Thu, 6 Mar 2014 20:45:49 +0400
Subject: [concurrency-interest] Writing final fields via reflection vs
	safe-visibility of new contents
Message-ID: <CAO-wXwL2O0SHoC+kSU101PQVnQNL0xhKJVFLgvQXLubZ5TeTHQ@mail.gmail.com>

There is a similar to
http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140301/312755f3/attachment.obj
 [1]
example in JLS (http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf, see
"Example 17.5.3-1"):

class A {
 final int x;
 A() {
 x = 1;
 }

 int f() {
 return d(this,this);
 }

 int d(A a1, A a2) {
 int i = a1.x;
 g(a1);
 int j = a2.x;
 return j - i;
 }

 static void g(A a) {
 // uses reflection to change a.x to 2
 }
}

and JLS states that "In the d method, the compiler is allowed to reorder
the reads of x and the call to g freely. Thus, new A().f() could return -1,
0, or 1."

Note, that we have only a single thread and still we may see a default
value 0. So I suppose in [1] actor all the more so is allowed to see 0.
But which compiler is meant in the aforementioned JLS quote - bytecode
compiler or JIT?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140306/b59f7211/attachment.html>

From sitnikov.vladimir at gmail.com  Thu Mar  6 12:07:11 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Thu, 6 Mar 2014 21:07:11 +0400
Subject: [concurrency-interest] Writing final fields via reflection vs
 safe-visibility of new contents
In-Reply-To: <CAO-wXwL2O0SHoC+kSU101PQVnQNL0xhKJVFLgvQXLubZ5TeTHQ@mail.gmail.com>
References: <CAO-wXwL2O0SHoC+kSU101PQVnQNL0xhKJVFLgvQXLubZ5TeTHQ@mail.gmail.com>
Message-ID: <CAB=Je-HcQdB8wDo76Lvnck9oZNRE+yU0vDx2fjO9qPB4W=6KbA@mail.gmail.com>

>
>
> Note, that we have only a single thread and still we may see a default
> value 0.
>
Please be super-careful when you declare "one can see default value for
final field" in such trivial case.
Why bother with "17.5.1 Semantics of final fields" then?

Note that method d returns _the difference_ of two reads of the same field.
All that example shows is that both reads are unordered: it may turn out
they both return the same value, in that case the resulting j-i will be 0.

-- 
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140306/9a7d3fc8/attachment.html>

From oleksandr.otenko at oracle.com  Thu Mar  6 12:31:03 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Thu, 06 Mar 2014 17:31:03 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53188BE4.2020700@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com> <53186527.1060001@oracle.com>
	<5318826A.1020700@oracle.com> <53188BE4.2020700@oracle.com>
Message-ID: <5318B0D7.7030600@oracle.com>

1. His graph shows the path from read(shared, !null) to write(shared, 
tmp). If this doesn't break language semantics, then what sort of 
situations does that statement in JMM refer to?

2. Is there a disagreement that adding a volatile write between normal 
read of shared and a volatile read of x makes the test pass?

3. I don't understand why one would consider a invalid accessor as a 
proof of the constructor being invalid.

4. I can't write the same sort of reasoning Vladimir wrote, because I 
haven't practiced using it that way. That approach requires enumeration 
of all possible synchronization orders to demonstrate that something can 
never occur. Enumeration doesn't scale with the number of threads as 
well as the size of the problem. Enumeration does not take into account 
properties of data types and doesn't allow expressing inductive proofs. 
If you don't want to think about the problem in other ways, that's fine.

5. I understand there will be no official recognition of the validity of 
the approach because of what has been announced in [1] as the official 
answer to the question.

Alex

On 06/03/2014 14:53, Aleksey Shipilev wrote:
> On 03/06/2014 06:12 PM, Oleksandr Otenko wrote:
>> I'll start with the modified example where my point will be more
>> obvious. Quoting just the relevant bit:
>>
>>      r S
>>          |
>>          ^
>>          |
>> R Y->--W Y
>>   |
>>   ^
>>   |
>> w S
> You lost me right here, I can't understand your example. I can vaguely
> understand "r S" is a read of "S". But what do arrows signify? Please be
> more rigorous: that is, I would like the example which builds on the
> formalisms of spec, and does it in the form the readers of this list are
> used to, e.g. read(y), vwrite(y), --hb-->, --sw-->, --so-->, etc.
>
> I chimed in mostly because Vladimir seems to ask for the same: instead
> of building up some wacked interpretation of spec, let's build on
> something already written out in the spec. Vladimir had started doing
> that here:
>   http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012450.html
>
> ...and I think that's an approach to go, because it follows the spec
> mechanics: it builds the candidate execution yielding the result we are
> looking for, proves execution consistency, and validates the execution
> by committing the actions from it. Is there an error in Vladimir's
> proof, which makes that execution non-plausible?
>
> -Aleksey.


From valentin.male.kovalenko at gmail.com  Thu Mar  6 13:07:20 2014
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Thu, 6 Mar 2014 22:07:20 +0400
Subject: [concurrency-interest] Writing final fields via reflection vs
 safe-visibility of new contents
Message-ID: <CAO-wXwK_E3XA5acomxVnd07A3w5dhE_ouE_TSG90aVE4QSkHJg@mail.gmail.com>

Yeah.., sorry, it's my fail :(

On Thu, Mar 6, 2014 at 9:07 PM, Vladimir Sitnikov <
sitnikov.vladimir at gmail.com> wrote:

>
>> Note, that we have only a single thread and still we may see a default
>> value 0.
>>
> Please be super-careful when you declare "one can see default value for
> final field" in such trivial case.
> Why bother with "17.5.1 Semantics of final fields" then?
>
> Note that method d returns _the difference_ of two reads of the same field.
> All that example shows is that both reads are unordered: it may turn out
> they both return the same value, in that case the resulting j-i will be 0.
>
> --
> Vladimir
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140306/cb9dc95d/attachment.html>

From oleksandr.otenko at oracle.com  Sat Mar  8 06:57:03 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Sat, 08 Mar 2014 11:57:03 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <53188BE4.2020700@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com> <53186527.1060001@oracle.com>
	<5318826A.1020700@oracle.com> <53188BE4.2020700@oracle.com>
Message-ID: <531B058F.6040203@oracle.com>

ok, here we go:

int x;
volatile y;
Shared z;

Thread 1:
this.x=1;
this.y=1;
int r=this.y;
z=this;

Thread 2:
tmp=z;
tmp.y=1;
int r=tmp.y;
r=tmp.x;

So, we have:

Program orders:

Thread 1:
write(x,1);
vwrite(y,1);
vread(y,_); -- volatile read of some value, don't care what that value is
write(z,this);

Thread 2:
read(z,this);
vwrite(y, 1);
vread(y,_);
read(x,r);

A total order of volatile operations cannot contain Thread1.vread(y,_) 
after Thread2.vwrite(y,1), because then vread will synchronize-with 
vwrite, and taking into account program orders of two threads we get 
read(z,this) happens-before write(z,this). This violates statement in 
17.4.5, which requires reads to never occur before writes.

Because the order is total, and the above ordering is not allowed, the 
only possible synchronization order is Thread1.vread(y,_) before 
Thread2.vwrite(y,1). Now, taking into account program orders of two 
threads we get Thread1.vwrite(y,1) is before Thread2.vread(y,_), which 
also establishes a synchronizes-with relationship between them, and 
transitively we get write(x,1) happens-before read(x,r), so r is never 0.

I don't know how to write all of this in terms of the notation the 
others on this list are used to.


Alex


On 06/03/2014 14:53, Aleksey Shipilev wrote:
> On 03/06/2014 06:12 PM, Oleksandr Otenko wrote:
>> I'll start with the modified example where my point will be more
>> obvious. Quoting just the relevant bit:
>>
>>      r S
>>          |
>>          ^
>>          |
>> R Y->--W Y
>>   |
>>   ^
>>   |
>> w S
> You lost me right here, I can't understand your example. I can vaguely
> understand "r S" is a read of "S". But what do arrows signify? Please be
> more rigorous: that is, I would like the example which builds on the
> formalisms of spec, and does it in the form the readers of this list are
> used to, e.g. read(y), vwrite(y), --hb-->, --sw-->, --so-->, etc.
>
> I chimed in mostly because Vladimir seems to ask for the same: instead
> of building up some wacked interpretation of spec, let's build on
> something already written out in the spec. Vladimir had started doing
> that here:
>   http://cs.oswego.edu/pipermail/concurrency-interest/2014-March/012450.html
>
> ...and I think that's an approach to go, because it follows the spec
> mechanics: it builds the candidate execution yielding the result we are
> looking for, proves execution consistency, and validates the execution
> by committing the actions from it. Is there an error in Vladimir's
> proof, which makes that execution non-plausible?
>
> -Aleksey.


From sitnikov.vladimir at gmail.com  Sat Mar  8 09:21:01 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Sat, 8 Mar 2014 18:21:01 +0400
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <531B058F.6040203@oracle.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>
	<5315081A.4040600@oracle.com> <531508D7.6020808@oracle.com>
	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>
	<5315E430.5020503@oracle.com> <5315FBD6.5040800@oracle.com>
	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>
	<53162A2B.3060409@oracle.com>
	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>
	<531658E1.1080709@oracle.com>
	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>
	<53176142.1020603@oracle.com>
	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>
	<53178615.3010303@oracle.com> <53178FDA.40505@oracle.com>
	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>
	<53185CB4.7040203@oracle.com> <53186527.1060001@oracle.com>
	<5318826A.1020700@oracle.com> <53188BE4.2020700@oracle.com>
	<531B058F.6040203@oracle.com>
Message-ID: <CAB=Je-GmP-ngTVBRLE_nvnXB6kZefv9_K4Ej57GGresCS_wKCQ@mail.gmail.com>

That is a nice and clean explanation, however the case differs from both
[4] and [5].
Can you please approach to [4] or [5] in the similar way?

--
Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140308/eee85e37/attachment.html>

From oleksandr.otenko at oracle.com  Mon Mar 10 09:20:27 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Mon, 10 Mar 2014 13:20:27 +0000
Subject: [concurrency-interest] Volatile load-store-load in constructor
 vs safe publication via race
In-Reply-To: <CAB=Je-GmP-ngTVBRLE_nvnXB6kZefv9_K4Ej57GGresCS_wKCQ@mail.gmail.com>
References: <CAB=Je-Fv-gm09w9F6Jy5iiYnTGXL-oHvfbg1YOjhSY551ZJOkw@mail.gmail.com>	<5315081A.4040600@oracle.com>	<531508D7.6020808@oracle.com>	<CAB=Je-Hf5H9bx2WDSxKbm_7w5S5AtPw-EW-=Tkhx=7Y8V1yFJg@mail.gmail.com>	<5315E430.5020503@oracle.com>	<5315FBD6.5040800@oracle.com>	<CAB=Je-H-UoSQwtQGSZQx1_hMrex4cWBFL2OuiGQPHpr-6=qmeg@mail.gmail.com>	<53162A2B.3060409@oracle.com>	<CAB=Je-HkSAzudr8mxYJqE11za46Nrzyg=AmFpPPhDcgr-QVkig@mail.gmail.com>	<531658E1.1080709@oracle.com>	<CAB=Je-EOic4YFOAWz+Vn3xgeNyF25_Dg3VgrmQyKpV1QZ_QtxQ@mail.gmail.com>	<53176142.1020603@oracle.com>	<CAB=Je-HPLKi6G-N9HkvLCuUsfBsE_tnMdvHo7vqJY_ra=+5v6Q@mail.gmail.com>	<53178615.3010303@oracle.com>	<53178FDA.40505@oracle.com>	<CAB=Je-FLQJhA+qGiEbhu1JtfCq7RSq9h513_FDEeeJagaPaeLQ@mail.gmail.com>	<53185CB4.7040203@oracle.com>	<53186527.1060001@oracle.com>	<5318826A.1020700@oracle.com>	<53188BE4.2020700@oracle.com>	<531B058F.6040203@oracle.com>
	<CAB=Je-GmP-ngTVBRLE_nvnXB6kZefv9_K4Ej57GGresCS_wKCQ@mail.gmail.com>
Message-ID: <531DBC1B.9020409@oracle.com>

[1], [4] and [5] have a problem in the accessor. Even using the weaker 
notion of memory model from cookbook, the volatile read can go ahead of 
normal read in the accessor, so it doesn't matter how the constructor is 
written. I initially assumed that the accessor can be fixed by using any 
volatile store between a read of shared reference and a volatile read of 
y will do, so considered a store to another volatile variable, z, but 
that is not strong enough. The use of load-load barriers is justified in 
practice, but JMM does not specify what the barriers are.

In terms of JMM, without a volatile store to a variable that the 
constructor reads there will be no contradiction arising from normal 
read and write of the shared variable, whatever the order of other 
volatile operations. This is perhaps what your proof shows, but I am not 
certain how to interpret the chain of operations you constructed - it's 
just me.

Here's how load-load barrier can be justified:

int x;
volatile int y;
*volatile int t;**
*Shared z;

Thread 1:
this.x=1;
this.y=1;
int r=*this.t; *
z=this;

Thread 2:
tmp=z;
*tmp.t*=1;
int r=tmp.y;
r=tmp.x;

Notice I only added a field to show an equivalent statement, but here 
the whole field can be eliminated as follows. Following the cookbook, 
since t is not used after reading in the constructor, the instruction 
*r=this.t;* can be eliminated - but keep the barriers.

Since the value t is not used anywhere, the instruction *tmp.t=1;* can 
be eliminated, but keep the barriers. Since t is not used anywhere, 
remove the whole field.

Since no one can synchronize-with *tmp.t=1;*, load-store and store-store 
barriers preceding that instruction can be eliminated, too. So we only 
have load-load barrier between the normal read tmp=z and volatile read 
r=tmp.y left.

Therefore, under these assumptions, since the code that is correct as 
per JMM can be "optimized" to the accessor code in [4] with the 
load-load barrier, the original suggestion to use barriers should behave 
in the same way.

This is, of course, if the code gets implemented as actual reads and 
writes on the target platform. Aleksey's remark that "JMM is not the 
physical reality" is true in the sense that there may be ways to 
implement this inter-thread interaction without using the instructions 
of the target platform.


Alex


On 08/03/2014 14:21, Vladimir Sitnikov wrote:
> That is a nice and clean explanation, however the case differs from 
> both [4] and [5].
> Can you please approach to [4] or [5] in the similar way?
>
> --
> Vladimir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140310/b194716c/attachment.html>

From boehm at acm.org  Thu Mar 13 18:23:31 2014
From: boehm at acm.org (Hans Boehm)
Date: Thu, 13 Mar 2014 15:23:31 -0700
Subject: [concurrency-interest] Semantics of compareAndSwapX
In-Reply-To: <4928147.eN4jYyZp5E@d-allen>
References: <NFBBKALFDCPFIDBNKAPCIELPKEAA.davidcholmes@aapt.net.au>
	<530F4EF6.1080708@redhat.com>
	<CAPUmR1aA1DbQUt5aMx-mYeW401qLzA35PCudg0SEqaYnin=DgA@mail.gmail.com>
	<4928147.eN4jYyZp5E@d-allen>
Message-ID: <CAPUmR1arkcje2CjmCh7J--1sWACjbvap7Ezj68hh8uJsRTwVHw@mail.gmail.com>

[Sorry about the long delay]

Thanks.

Indeed, I am concerned about transitivity guarantees.  They hopefully
exist, but I'm not sure how to extract them from the current spec.

In the worst case, if I have (everything initially zero, read this as
short-hand for assembly)

Thread 1:
x = 1
y = 1; // release store

thread 2:
if (y == 1) {
   DMB; z = 1;
}

thread 3:
if (z == 1) {  // acquire load
    assert (x == 1)

Can the assert fail?

I think you can end up with cases like this if you mix C++ seq_cst
operations with relaxed operations and fences.

Hans


On Thu, Feb 27, 2014 at 1:43 PM, Stephan Diestelhorst <
stephan.diestelhorst at gmail.com> wrote:

> Am Donnerstag, 27. Februar 2014, 08:53:47 schrieb Hans Boehm:
> > As far as I know, the ARMv8 acquire/release operations were designed
> > specifically to act as Java volatile or C++ memory_order_seq_cst
> load/store
> > operations, without the kind of ordering overkill that we currently need
> on
> > x86, i.e. they were designed to get us to the "better world".
>
> I would agree (my personal view).
>
> > My main remaining concern is that we don't have a complete, much less
> > provably correct, mapping of either Java or C++ atomics to this ISA.
>  This
> > leaves a risk that some corner cases, e.g. C++ explicit fences, will be
> > difficult to implement correctly in this model.
>
> Explicit fences should stay explicit fences (DMB) in ARM, I think.
>
> > I am also not at all sure whether the traditional ARMv7 mappings mix
> > and match with an acquire/release based mapping.  These mappings
> > should really be specified in some kind of ABI addednsum.  (But there
> > are already similar issues with ARMv7 by itself, and with some other
> > architectures.)
>
> Not quite sure what the worry is, here.  Proper fences (DMBs) behave as
> they should (unless you consider TLBs, self- / cross-modifying code);
> with ld.acq / st.rel being "fenced in" by them.  I am surely missing
> something here (transitivity?), so: did you have a specific problematic
> case in mind?
>
> Stephan
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140313/4241a893/attachment.html>

From andrew_nuss at yahoo.com  Mon Mar 17 09:13:34 2014
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Mon, 17 Mar 2014 06:13:34 -0700 (PDT)
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
Message-ID: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>

Hi,

I've come to understand that a locking semantic employing AtomicBoolean.getAndSet() will safely publish all non-volatile memory changes to any thread entering the critical section of a simple lock/unlock built on the AtomicBoolean.

However, what if you have a tricky situation where at the beginning of the critical section, you know that you already have ownership of the lock (it is still true and your function was timer-scheduled for example and the boolean left in the true state), so on this entry to the critical section, you don't set, and you may not even unset at the end of the critical section if you reschedule another timer task, but you do want to publish the changes to non-volatile variables.

Does this work:

if (i_already_own_lock) {
????? if (!lock.getAndSet(true))
?????????? throw new IllegalStateException();
????? else
????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???

} else {

?????? ... normal loop with getAndSet until lock obtained
}

.... change non volatile variables within critical section that are shared
.... by 


if (need_to_reschedule) {
???? ... schedule timer task to at some later point in another thread reenter this critical section but left owned!
????? if (!lock.getAndSet(true))
?????????? throw new IllegalStateException();
????? else
????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???

} else {
???? lock.set(false);

}

Thanks,
Andy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140317/d4e9e7e4/attachment.html>

From viktor.klang at gmail.com  Mon Mar 17 09:21:16 2014
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 17 Mar 2014 14:21:16 +0100
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
Message-ID: <CANPzfU81wh29vVzXkcKhkMaPe6XYyEFpW8g4E4tBPQQ__+yDKQ@mail.gmail.com>

"          ;   // the getAndSet did nothing, but is it a publishing event
anyway???"

getAndSet does not conditionally write, it always writes what you put in
there.


On Mon, Mar 17, 2014 at 2:13 PM, Andy Nuss <andrew_nuss at yahoo.com> wrote:

> Hi,
>
> I've come to understand that a locking semantic employing
> AtomicBoolean.getAndSet() will safely publish all non-volatile memory
> changes to any thread entering the critical section of a simple lock/unlock
> built on the AtomicBoolean.
>
> However, what if you have a tricky situation where at the beginning of the
> critical section, you know that you already have ownership of the lock (it
> is still true and your function was timer-scheduled for example and the
> boolean left in the true state), so on this entry to the critical section,
> you don't set, and you may not even unset at the end of the critical
> section if you reschedule another timer task, but you do want to publish
> the changes to non-volatile variables.
>
> Does this work:
>
> if (i_already_own_lock) {
>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing event
> anyway???
> } else {
>        ... normal loop with getAndSet until lock obtained
> }
>
> .... change non volatile variables within critical section that are shared
> .... by
>
> if (need_to_reschedule) {
>      ... schedule timer task to at some later point in another thread
> reenter this critical section but left owned!
>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing event
> anyway???
> } else {
>      lock.set(false);
> }
>
> Thanks,
> Andy
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Cheers,
?

*???????**Viktor Klang*
*Chief Architect - **Typesafe <http://www.typesafe.com/>*

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140317/ccc8ae55/attachment-0001.html>

From peter.levart at gmail.com  Mon Mar 17 17:07:00 2014
From: peter.levart at gmail.com (Peter Levart)
Date: Mon, 17 Mar 2014 22:07:00 +0100
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
Message-ID: <532763F4.5080801@gmail.com>


On 03/17/2014 02:13 PM, Andy Nuss wrote:
> Hi,
>
> I've come to understand that a locking semantic employing 
> AtomicBoolean.getAndSet() will safely publish all non-volatile memory 
> changes to any thread entering the critical section of a simple 
> lock/unlock built on the AtomicBoolean.
>
> However, what if you have a tricky situation where at the beginning of 
> the critical section, you know that you already have ownership of the 
> lock

What do you mean by "you" in sentence: "at the beginning of the critical 
section, you know that *you* already have ownership of the lock" ?

Do you mean *the thread* executing code at the "beginning of the 
critical section"? If this is still the same thread that obtained the 
lock, then there's no problem, since non-volatile variables behave 
properly within the same thread even without synchronization.

  If this is not the same thread that obtained the lock, then this 
"knowledge" of "you" still holding the lock must have been transferred 
to the thread at the beginning of the critical section from the thread 
that obtained the lock somehow with mechanism external to your 
AtomicBoolean based lock. You can view your AtomicBoolean based lock + 
external mechanism for transferring ownership as "the lock". This 
combined lock will only be correct if it guarantees that the critical 
section is executed by a single thread at once.

Regards, Peter

> (it is still true and your function was timer-scheduled for example 
> and the boolean left in the true state), so on this entry to the 
> critical section, you don't set, and you may not even unset at the end 
> of the critical section if you reschedule another timer task, but you 
> do want to publish the changes to non-volatile variables.
>
> Does this work:
>
> if (i_already_own_lock) {
>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing 
> event anyway???
> } else {
>        ... normal loop with getAndSet until lock obtained
> }
>
> .... change non volatile variables within critical section that are shared
> .... by
>
> if (need_to_reschedule) {
>      ... schedule timer task to at some later point in another thread 
> reenter this critical section but left owned!
>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing 
> event anyway???
> } else {
>      lock.set(false);
> }
>
> Thanks,
> Andy
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140317/e362d52f/attachment.html>

From andrew_nuss at yahoo.com  Mon Mar 17 20:19:34 2014
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Mon, 17 Mar 2014 17:19:34 -0700 (PDT)
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <532763F4.5080801@gmail.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
	<532763F4.5080801@gmail.com>
Message-ID: <1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>

I guess what I was trying to do is have one common function that is called from several threads to query a database.? In one of the scenarios, the caller knows that the lock has been left locked on purpose just for that special call, keeping others out of the critical section.? The special caller in a different thread wants to freely enter the critical section of the guard that is set to true for that caller already, yet still publish changes to non volatile memory to other threads that subsequently enter.? The hope was that by calling getAndSet(true) first, and passing into the critical section even though the atomic flag was already true, that this suffices to publish changes in the critical section, even though the getAndSet() does not change the flag in this case.

It seems like one responder is indicating that my solution works and you are indicating that it does not!?




On Monday, March 17, 2014 2:07 PM, Peter Levart <peter.levart at gmail.com> wrote:
 


On 03/17/2014 02:13 PM, Andy Nuss wrote:

Hi,
>
>
>I've come to understand that a locking semantic employing AtomicBoolean.getAndSet() will safely publish all non-volatile memory changes to any thread entering the critical section of a simple lock/unlock built on the AtomicBoolean.
>
>
>However, what if you have a tricky situation where at the beginning of the critical section, you know that you already have ownership of the lock 
What do you mean by "you" in sentence: "at the beginning of the
    critical section, you know that you already have ownership of the lock" ?

Do you mean the thread executing code at the "beginning of the critical section"? If this is still the same thread that obtained the lock, then there's no problem, since non-volatile variables behave properly within the same thread even without synchronization.

?If this is not the same thread that obtained the lock, then this
    "knowledge" of "you" still holding the lock must have been
    transferred to the thread at the beginning of the critical section
    from the thread that obtained the lock somehow with mechanism
    external to your AtomicBoolean based lock. You can view your
    AtomicBoolean based lock + external mechanism for transferring
    ownership as "the lock". This combined lock will only be correct if
    it guarantees that the critical section is executed by a single
    thread at once.

Regards, Peter



(it is still true and your function was timer-scheduled for example and the boolean left in the true state), so on this entry to the critical section, you don't set, and you may not even unset at the end of the critical section if you reschedule another timer task, but you do want to publish the changes to non-volatile variables.
>
>
>Does this work:
>
>
>if (i_already_own_lock) {
>????? if (!lock.getAndSet(true))
>?????????? throw new IllegalStateException();
>????? else
>????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???
>
>} else {
>
>?????? ... normal loop with getAndSet until lock obtained
>}
>
>
>.... change non volatile variables within critical section that are shared
>.... by 
>
>
>
>if (need_to_reschedule) {
>???? ... schedule timer task to at some later point in another thread reenter this critical section but left owned!
>????? if (!lock.getAndSet(true))
>?????????? throw new IllegalStateException();
>????? else
>????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???
> 
>} else {
>???? lock.set(false);
>
>}
>
>
>Thanks,
>Andy
>
>
>
>_______________________________________________
Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140317/0f5bc36d/attachment-0001.html>

From nathan.reynolds at oracle.com  Mon Mar 17 20:34:32 2014
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Mon, 17 Mar 2014 17:34:32 -0700
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>	<532763F4.5080801@gmail.com>
	<1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
Message-ID: <53279498.4010200@oracle.com>

On 3/17/2014 5:19 PM, Andy Nuss wrote:
> I guess what I was trying to do is have one common function that is 
> called from several threads to query a database.  In one of the 
> scenarios, the caller knows that the lock has been left locked on 
> purpose just for that special call, keeping others out of the critical 
> section. The special caller in a different thread wants to freely 
> enter the critical section of the guard that is set to true for that 
> caller already, yet still publish changes to non volatile memory to 
> other threads that subsequently enter. The hope was that by calling 
> getAndSet(true) first, and passing into the critical section even 
> though the atomic flag was already true, that this suffices to publish 
> changes in the critical section, even though the getAndSet() does not 
> change the flag in this case.
How are the non-volatile fields protected?  Is there any guarantee that 
other threads will see a consistent set of values in the non-volatile 
fields if they don't acquire the lock?

Are you basically building a lock using AtomicBoolean.getAndSet() and 
AtomicBoolean.set()?
>
> It seems like one responder is indicating that my solution works and 
> you are indicating that it does not!?
>
>
> On Monday, March 17, 2014 2:07 PM, Peter Levart 
> <peter.levart at gmail.com> wrote:
>
> On 03/17/2014 02:13 PM, Andy Nuss wrote:
>> Hi,
>>
>> I've come to understand that a locking semantic employing 
>> AtomicBoolean.getAndSet() will safely publish all non-volatile memory 
>> changes to any thread entering the critical section of a simple 
>> lock/unlock built on the AtomicBoolean.
>>
>> However, what if you have a tricky situation where at the beginning 
>> of the critical section, you know that you already have ownership of 
>> the lock
>
> What do you mean by "you" in sentence: "at the beginning of the 
> critical section, you know that *you* already have ownership of the 
> lock" ?
>
> Do you mean *the thread* executing code at the "beginning of the 
> critical section"? If this is still the same thread that obtained the 
> lock, then there's no problem, since non-volatile variables behave 
> properly within the same thread even without synchronization.
>
>  If this is not the same thread that obtained the lock, then this 
> "knowledge" of "you" still holding the lock must have been transferred 
> to the thread at the beginning of the critical section from the thread 
> that obtained the lock somehow with mechanism external to your 
> AtomicBoolean based lock. You can view your AtomicBoolean based lock + 
> external mechanism for transferring ownership as "the lock". This 
> combined lock will only be correct if it guarantees that the critical 
> section is executed by a single thread at once.
>
> Regards, Peter
>
>
>> (it is still true and your function was timer-scheduled for example 
>> and the boolean left in the true state), so on this entry to the 
>> critical section, you don't set, and you may not even unset at the 
>> end of the critical section if you reschedule another timer task, but 
>> you do want to publish the changes to non-volatile variables.
>>
>> Does this work:
>>
>> if (i_already_own_lock) {
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>>        ... normal loop with getAndSet until lock obtained
>> }
>>
>> .... change non volatile variables within critical section that are 
>> shared
>> .... by
>>
>> if (need_to_reschedule) {
>>      ... schedule timer task to at some later point in another thread 
>> reenter this critical section but left owned!
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>> lock.set(false);
>> }
>>
>> Thanks,
>> Andy
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140317/5481be80/attachment.html>

From peter.levart at gmail.com  Tue Mar 18 04:23:48 2014
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 18 Mar 2014 09:23:48 +0100
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>	<532763F4.5080801@gmail.com>
	<1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
Message-ID: <53280294.5050804@gmail.com>

On 03/18/2014 01:19 AM, Andy Nuss wrote:
> I guess what I was trying to do is have one common function that is 
> called from several threads to query a database.  In one of the 
> scenarios, the caller knows that the lock has been left locked on 
> purpose just for that special call, keeping others out of the critical 
> section.

How does the caller know that unless the caller thread has acquired the 
lock? This must have been communicated somehow from the thread that 
obtained the lock to the thread of this special caller...

>   The special caller in a different thread wants to freely enter the 
> critical section of the guard that is set to true for that caller 
> already, yet still publish changes to non volatile memory to other 
> threads that subsequently enter.  The hope was that by calling 
> getAndSet(true) first, and passing into the critical section even 
> though the atomic flag was already true, that this suffices to publish 
> changes in the critical section, even though the getAndSet() does not 
> change the flag in this case.
>
> It seems like one responder is indicating that my solution works and 
> you are indicating that it does not!?

I'm just proposing that getAndSet(true) == true condition does not 
matter here. It's just an assertion that "there's still lock being 
held". If you remove this assertion, your code will still behave properly.

We have two groups of threads in this situation. One group is threads 
that "know that they don't have a lock" and want to enter critical 
section. For those threads (T1), the following loop is spin-waiting for 
lock to be released and transferred to them:

while (lock.getAndSet(true)) {}

     ... critical section ...

The non-volatile state is published to such thread from the thread that 
"knows that it has the lock" (T2) via a volatile write:

     lock.set(false);

(I suggest doing the following for unlocking: if 
(!lock.getAndSet(false)) throw new IllegalStateException("Not locked"); )


So we have a T2:volatile-write, T1:volatile-read edge here which 
guarantees non-volatile state is published correctly.

The other group of threads are those threads that "know they have a 
lock" (T2) and for them, it seems there exists some other means, 
external to AtomicBoolean based lock, how they arrange their 
synchronization so that only one of them is accessing non-volatile state 
at one time. I'm guessing that this external mechanism is responsible 
and does indeed guarantee publishing of non-volatile state among threads 
of this group. Unless perhaps this mechanism is based entirely on data 
races. But I don't know of any such mechanism based on data races.


Regards, Peter

>
>
> On Monday, March 17, 2014 2:07 PM, Peter Levart 
> <peter.levart at gmail.com> wrote:
>
> On 03/17/2014 02:13 PM, Andy Nuss wrote:
>> Hi,
>>
>> I've come to understand that a locking semantic employing 
>> AtomicBoolean.getAndSet() will safely publish all non-volatile memory 
>> changes to any thread entering the critical section of a simple 
>> lock/unlock built on the AtomicBoolean.
>>
>> However, what if you have a tricky situation where at the beginning 
>> of the critical section, you know that you already have ownership of 
>> the lock
>
> What do you mean by "you" in sentence: "at the beginning of the 
> critical section, you know that *you* already have ownership of the 
> lock" ?
>
> Do you mean *the thread* executing code at the "beginning of the 
> critical section"? If this is still the same thread that obtained the 
> lock, then there's no problem, since non-volatile variables behave 
> properly within the same thread even without synchronization.
>
>  If this is not the same thread that obtained the lock, then this 
> "knowledge" of "you" still holding the lock must have been transferred 
> to the thread at the beginning of the critical section from the thread 
> that obtained the lock somehow with mechanism external to your 
> AtomicBoolean based lock. You can view your AtomicBoolean based lock + 
> external mechanism for transferring ownership as "the lock". This 
> combined lock will only be correct if it guarantees that the critical 
> section is executed by a single thread at once.
>
> Regards, Peter
>
>
>> (it is still true and your function was timer-scheduled for example 
>> and the boolean left in the true state), so on this entry to the 
>> critical section, you don't set, and you may not even unset at the 
>> end of the critical section if you reschedule another timer task, but 
>> you do want to publish the changes to non-volatile variables.
>>
>> Does this work:
>>
>> if (i_already_own_lock) {
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>>        ... normal loop with getAndSet until lock obtained
>> }
>>
>> .... change non volatile variables within critical section that are 
>> shared
>> .... by
>>
>> if (need_to_reschedule) {
>>      ... schedule timer task to at some later point in another thread 
>> reenter this critical section but left owned!
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>> lock.set(false);
>> }
>>
>> Thanks,
>> Andy
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140318/81393bef/attachment-0001.html>

From peter.levart at gmail.com  Tue Mar 18 04:39:23 2014
From: peter.levart at gmail.com (Peter Levart)
Date: Tue, 18 Mar 2014 09:39:23 +0100
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>
Message-ID: <5328063B.8050108@gmail.com>

Ok, I think I'm slowly beginning to understand the specifics of your 
approach. Would you care to confirm them...

On 03/17/2014 02:13 PM, Andy Nuss wrote:
> Hi,
>
> I've come to understand that a locking semantic employing 
> AtomicBoolean.getAndSet() will safely publish all non-volatile memory 
> changes to any thread entering the critical section of a simple 
> lock/unlock built on the AtomicBoolean.
>
> However, what if you have a tricky situation where at the beginning of 
> the critical section, you know that you already have ownership of the 
> lock (it is still true and your function was timer-scheduled for 
> example and the boolean left in the true state), so on this entry to 
> the critical section, you don't set, and you may not even unset at the 
> end of the critical section if you reschedule another timer task, but 
> you do want to publish the changes to non-volatile variables.
>
> Does this work:
>
> if (i_already_own_lock) {

The "i_already_own_lock" condition is something that is true if the 
caller is initiated from a timer task and false otherwise?

>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing 
> event anyway???
> } else {
>        ... normal loop with getAndSet until lock obtained
> }
>
> .... change non volatile variables within critical section that are shared
> .... by
>
> if (need_to_reschedule) {
>      ... schedule timer task to at some later point in another thread 
> reenter this critical section but left owned!

Ok, here you schedule exactly one timer task that will, when executed in 
some other thread, re-enter the common code on this page, right?

Well, between scheduling the timer task and it's execution in a timer 
thread, there exists a happens-before relationship which guarantees that 
non-volatile state from the thread that scheduled the task is 
transferred to the timer thread executing the task. So you're OK even 
without those assertions that don't change the state of lock.

Regards, Peter

>       if (!lock.getAndSet(true))
>            throw new IllegalStateException();
>       else
>           ;   // the getAndSet did nothing, but is it a publishing 
> event anyway???
> } else {
>      lock.set(false);
> }
>
> Thanks,
> Andy
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140318/d73b5747/attachment.html>

From oleksandr.otenko at oracle.com  Tue Mar 18 09:43:01 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 18 Mar 2014 13:43:01 +0000
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>	<532763F4.5080801@gmail.com>
	<1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
Message-ID: <53284D65.8030208@oracle.com>

The semantics of non-volatile publishing is not clear.

1. If you call getAndSet first, then the publication is not meant to 
occur at the end.
2. The thread that really owns the lock can unlock before (1) finishes 
publishing the non-volatile changes. So what about consistency of 
non-volatiles?


Alex

On 18/03/2014 00:19, Andy Nuss wrote:
> I guess what I was trying to do is have one common function that is 
> called from several threads to query a database.  In one of the 
> scenarios, the caller knows that the lock has been left locked on 
> purpose just for that special call, keeping others out of the critical 
> section. The special caller in a different thread wants to freely 
> enter the critical section of the guard that is set to true for that 
> caller already, yet still publish changes to non volatile memory to 
> other threads that subsequently enter. The hope was that by calling 
> getAndSet(true) first, and passing into the critical section even 
> though the atomic flag was already true, that this suffices to publish 
> changes in the critical section, even though the getAndSet() does not 
> change the flag in this case.
>
> It seems like one responder is indicating that my solution works and 
> you are indicating that it does not!?
>
>
> On Monday, March 17, 2014 2:07 PM, Peter Levart 
> <peter.levart at gmail.com> wrote:
>
> On 03/17/2014 02:13 PM, Andy Nuss wrote:
>> Hi,
>>
>> I've come to understand that a locking semantic employing 
>> AtomicBoolean.getAndSet() will safely publish all non-volatile memory 
>> changes to any thread entering the critical section of a simple 
>> lock/unlock built on the AtomicBoolean.
>>
>> However, what if you have a tricky situation where at the beginning 
>> of the critical section, you know that you already have ownership of 
>> the lock
>
> What do you mean by "you" in sentence: "at the beginning of the 
> critical section, you know that *you* already have ownership of the 
> lock" ?
>
> Do you mean *the thread* executing code at the "beginning of the 
> critical section"? If this is still the same thread that obtained the 
> lock, then there's no problem, since non-volatile variables behave 
> properly within the same thread even without synchronization.
>
>  If this is not the same thread that obtained the lock, then this 
> "knowledge" of "you" still holding the lock must have been transferred 
> to the thread at the beginning of the critical section from the thread 
> that obtained the lock somehow with mechanism external to your 
> AtomicBoolean based lock. You can view your AtomicBoolean based lock + 
> external mechanism for transferring ownership as "the lock". This 
> combined lock will only be correct if it guarantees that the critical 
> section is executed by a single thread at once.
>
> Regards, Peter
>
>
>> (it is still true and your function was timer-scheduled for example 
>> and the boolean left in the true state), so on this entry to the 
>> critical section, you don't set, and you may not even unset at the 
>> end of the critical section if you reschedule another timer task, but 
>> you do want to publish the changes to non-volatile variables.
>>
>> Does this work:
>>
>> if (i_already_own_lock) {
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>>        ... normal loop with getAndSet until lock obtained
>> }
>>
>> .... change non volatile variables within critical section that are 
>> shared
>> .... by
>>
>> if (need_to_reschedule) {
>>      ... schedule timer task to at some later point in another thread 
>> reenter this critical section but left owned!
>> if (!lock.getAndSet(true))
>> throw new IllegalStateException();
>> else
>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>> } else {
>> lock.set(false);
>> }
>>
>> Thanks,
>> Andy
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140318/cdf45fdf/attachment-0001.html>

From andrew_nuss at yahoo.com  Tue Mar 18 10:44:42 2014
From: andrew_nuss at yahoo.com (Andy Nuss)
Date: Tue, 18 Mar 2014 07:44:42 -0700 (PDT)
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <53284D65.8030208@oracle.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>	<532763F4.5080801@gmail.com>
	<1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
	<53284D65.8030208@oracle.com>
Message-ID: <1395153882.31918.YahooMailNeo@web160703.mail.bf1.yahoo.com>

In the original snippet, the entry getAndSet() in the case of callers that already own the lock has the single purpose of verifying that the lock is already held.? If not, then throw an IllegalStateException.? A better solution would be one that doesn't change the lock state if the caller turns out not to own the lock.? Perhaps then a simple get() and throw if not true is better, assuming that this get() still has the effect of causing changes previously made by another thread to be seen??

And for this type of caller, already owning the lock, it is presumed, perhaps not stated clearly by me, that that caller wants to continue to own the lock when exiting the critical section.? But he does want to publish the changes to the PriorityQueue that happened in the critical section, to other threads that might come in, either when the lock is released, or when a similar call from another scheduled tasklet knows that the lock is already "held" and that caller wants to freely enter, update the PriorityQueue, publish, and exit again with the lock still true.

The hope was that in order to exit and publish while leaving the lock true.? I suppose the answer is that in this case, given that the caller has already verified on entry that he already owns the lock, on exit, even though he is not changing the lock state, he can publish changes to PriorityQueue with lock.set(true).? So yes, that is better.? But just for the sake of knowledge about hotspot and the memory model, I was wondering whether lock.getAndSet(true) on exit, which is a NOP in this case, would still cause the changes to the PriorityQueue to be published to any other thread that subsequently enters the critical section thru getAndSet(), whether they be callers which require the state of the flag to be false on entry and loop till they can change it, or callers which require the state of the flag to be true on entry, and throw if it was not.


Andy




On Tuesday, March 18, 2014 6:43 AM, Oleksandr Otenko <oleksandr.otenko at oracle.com> wrote:
 
The semantics of non-volatile publishing is not clear.

1. If you call getAndSet first, then the publication is not meant to
    occur at the end.
2. The thread that really owns the lock can unlock before (1)
    finishes publishing the non-volatile changes. So what about
    consistency of non-volatiles?


Alex


On 18/03/2014 00:19, Andy Nuss wrote:

I guess what I was trying to do is have one common function that is called from several threads to query a database.? In one of the scenarios, the caller knows that the lock has been left locked on purpose just for that special call, keeping others out of the critical section.? The special caller in a different thread wants to freely enter the critical section of the guard that is set to true for that caller already, yet still publish changes to non volatile memory to other threads that subsequently enter.? The hope was that by calling getAndSet(true) first, and passing into the critical section even though the atomic flag was already true, that this suffices to publish changes in the critical section, even though the getAndSet() does not change the flag in this case.
>
>
>It seems like one responder is indicating that my solution works and you are indicating that it does not!?
>
>
>
>
>On Monday, March 17, 2014 2:07 PM, Peter Levart <peter.levart at gmail.com> wrote:
> 
>
>
>On 03/17/2014 02:13 PM, Andy Nuss wrote:
>
>Hi,
>>
>>
>>I've come to understand that a locking semantic employing AtomicBoolean.getAndSet() will safely publish all non-volatile memory changes to any thread entering the critical section of a simple lock/unlock built on the AtomicBoolean.
>>
>>
>>However, what if you have a tricky situation where at the beginning of the critical section, you know that you already have ownership of the lock 
>What do you mean by "you" in sentence: "at the
                    beginning of the critical section, you know that you already have ownership of the lock" ?
>
>Do you mean the thread executing code at the "beginning of the critical section"? If this is still the same thread that obtained the lock, then there's no problem, since non-volatile variables behave properly within the same thread even without synchronization.
>
>?If this is not the same thread that obtained the
                    lock, then this "knowledge" of "you" still holding
                    the lock must have been transferred to the thread at
                    the beginning of the critical section from the
                    thread that obtained the lock somehow with mechanism
                    external to your AtomicBoolean based lock. You can
                    view your AtomicBoolean based lock + external
                    mechanism for transferring ownership as "the lock".
                    This combined lock will only be correct if it
                    guarantees that the critical section is executed by
                    a single thread at once.
>
>Regards, Peter 
>
>
>
>(it is still true and your function was timer-scheduled for example and the boolean left in the true state), so on this entry to the critical section, you don't set, and you may not even unset at the end of the critical section if you reschedule another timer task, but you do want to publish the changes to non-volatile variables.
>>
>>
>>Does this work:
>>
>>
>>if (i_already_own_lock) {
>>????? if (!lock.getAndSet(true))
>>?????????? throw new IllegalStateException();
>>????? else
>>????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???
>>
>>} else {
>>
>>?????? ... normal loop with getAndSet until lock obtained
>>}
>>
>>
>>.... change non volatile variables within critical section that are shared
>>.... by 
>>
>>
>>
>>if (need_to_reschedule) {
>>???? ... schedule timer task to at some later point in another thread reenter this critical section but left owned!
>>????? if (!lock.getAndSet(true))
>>?????????? throw new IllegalStateException();
>>????? else
>>????????? ;?? // the getAndSet did nothing, but is it a publishing event anyway???
>> 
>>} else {
>>???? lock.set(false);
>>
>>}
>>
>>
>>Thanks,
>>Andy
>>
>>
>>
>>_______________________________________________
Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
>
>
>
>
>
>_______________________________________________
Concurrency-interest mailing list Concurrency-interest at cs.oswego.edu http://cs.oswego.edu/mailman/listinfo/concurrency-interest 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140318/6fe47b2f/attachment-0001.html>

From oleksandr.otenko at oracle.com  Tue Mar 18 11:14:59 2014
From: oleksandr.otenko at oracle.com (Oleksandr Otenko)
Date: Tue, 18 Mar 2014 15:14:59 +0000
Subject: [concurrency-interest] tricky publication with
	AtomicBoolean.getAndSet()
In-Reply-To: <1395153882.31918.YahooMailNeo@web160703.mail.bf1.yahoo.com>
References: <1395062014.91759.YahooMailNeo@web160701.mail.bf1.yahoo.com>	<532763F4.5080801@gmail.com>
	<1395101974.21881.YahooMailNeo@web160705.mail.bf1.yahoo.com>
	<53284D65.8030208@oracle.com>
	<1395153882.31918.YahooMailNeo@web160703.mail.bf1.yahoo.com>
Message-ID: <532862F3.6000302@oracle.com>

well, referring to your original post, yes, getAndSet in the second 
snippet will make the changes published, if another thread checks the 
flag. But it is not clear how you enforce (2) - consistency. If "the 
other thread" that wants to look at PriorityQueue proceeds only if the 
lock has been released, then what's the point of publishing early? If 
"the other thread" looks at PriorityQueue regardless of the state of the 
flag, how do you ensure PriorityQueue is in a consistent state?

Alex

On 18/03/2014 14:44, Andy Nuss wrote:
> In the original snippet, the entry getAndSet() in the case of callers 
> that already own the lock has the single purpose of verifying that the 
> lock is already held.  If not, then throw an IllegalStateException.  A 
> better solution would be one that doesn't change the lock state if the 
> caller turns out not to own the lock.  Perhaps then a simple get() and 
> throw if not true is better, assuming that this get() still has the 
> effect of causing changes previously made by another thread to be seen??
>
> And for this type of caller, already owning the lock, it is presumed, 
> perhaps not stated clearly by me, that that caller wants to continue 
> to own the lock when exiting the critical section.  But he does want 
> to publish the changes to the PriorityQueue that happened in the 
> critical section, to other threads that might come in, either when the 
> lock is released, or when a similar call from another scheduled 
> tasklet knows that the lock is already "held" and that caller wants to 
> freely enter, update the PriorityQueue, publish, and exit again with 
> the lock still true.
>
> The hope was that in order to exit and publish while leaving the lock 
> true.  I suppose the answer is that in this case, given that the 
> caller has already verified on entry that he already owns the lock, on 
> exit, even though he is not changing the lock state, he can publish 
> changes to PriorityQueue with lock.set(true).  So yes, that is 
> better.  But just for the sake of knowledge about hotspot and the 
> memory model, I was wondering whether lock.getAndSet(true) on exit, 
> which is a NOP in this case, would still cause the changes to the 
> PriorityQueue to be published to any other thread that subsequently 
> enters the critical section thru getAndSet(), whether they be callers 
> which require the state of the flag to be false on entry and loop till 
> they can change it, or callers which require the state of the flag to 
> be true on entry, and throw if it was not.
>
> Andy
>
>
> On Tuesday, March 18, 2014 6:43 AM, Oleksandr Otenko 
> <oleksandr.otenko at oracle.com> wrote:
> The semantics of non-volatile publishing is not clear.
>
> 1. If you call getAndSet first, then the publication is not meant to 
> occur at the end.
> 2. The thread that really owns the lock can unlock before (1) finishes 
> publishing the non-volatile changes. So what about consistency of 
> non-volatiles?
>
>
> Alex
>
> On 18/03/2014 00:19, Andy Nuss wrote:
>> I guess what I was trying to do is have one common function that is 
>> called from several threads to query a database. In one of the 
>> scenarios, the caller knows that the lock has been left locked on 
>> purpose just for that special call, keeping others out of the 
>> critical section.  The special caller in a different thread wants to 
>> freely enter the critical section of the guard that is set to true 
>> for that caller already, yet still publish changes to non volatile 
>> memory to other threads that subsequently enter. The hope was that by 
>> calling getAndSet(true) first, and passing into the critical section 
>> even though the atomic flag was already true, that this suffices to 
>> publish changes in the critical section, even though the getAndSet() 
>> does not change the flag in this case.
>>
>> It seems like one responder is indicating that my solution works and 
>> you are indicating that it does not!?
>>
>>
>> On Monday, March 17, 2014 2:07 PM, Peter Levart 
>> <peter.levart at gmail.com> <mailto:peter.levart at gmail.com> wrote:
>>
>> On 03/17/2014 02:13 PM, Andy Nuss wrote:
>>> Hi,
>>>
>>> I've come to understand that a locking semantic employing 
>>> AtomicBoolean.getAndSet() will safely publish all non-volatile 
>>> memory changes to any thread entering the critical section of a 
>>> simple lock/unlock built on the AtomicBoolean.
>>>
>>> However, what if you have a tricky situation where at the beginning 
>>> of the critical section, you know that you already have ownership of 
>>> the lock
>>
>> What do you mean by "you" in sentence: "at the beginning of the 
>> critical section, you know that *you* already have ownership of the 
>> lock" ?
>>
>> Do you mean *the thread* executing code at the "beginning of the 
>> critical section"? If this is still the same thread that obtained the 
>> lock, then there's no problem, since non-volatile variables behave 
>> properly within the same thread even without synchronization.
>>
>>  If this is not the same thread that obtained the lock, then this 
>> "knowledge" of "you" still holding the lock must have been 
>> transferred to the thread at the beginning of the critical section 
>> from the thread that obtained the lock somehow with mechanism 
>> external to your AtomicBoolean based lock. You can view your 
>> AtomicBoolean based lock + external mechanism for transferring 
>> ownership as "the lock". This combined lock will only be correct if 
>> it guarantees that the critical section is executed by a single 
>> thread at once.
>>
>> Regards, Peter
>>
>>
>>> (it is still true and your function was timer-scheduled for example 
>>> and the boolean left in the true state), so on this entry to the 
>>> critical section, you don't set, and you may not even unset at the 
>>> end of the critical section if you reschedule another timer task, 
>>> but you do want to publish the changes to non-volatile variables.
>>>
>>> Does this work:
>>>
>>> if (i_already_own_lock) {
>>> if (!lock.getAndSet(true))
>>> throw new IllegalStateException();
>>> else
>>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>>> } else {
>>> ... normal loop with getAndSet until lock obtained
>>> }
>>>
>>> .... change non volatile variables within critical section that are 
>>> shared
>>> .... by
>>>
>>> if (need_to_reschedule) {
>>> ... schedule timer task to at some later point in another thread 
>>> reenter this critical section but left owned!
>>> if (!lock.getAndSet(true))
>>> throw new IllegalStateException();
>>> else
>>> ;   // the getAndSet did nothing, but is it a publishing event anyway???
>>> } else {
>>> lock.set(false);
>>> }
>>>
>>> Thanks,
>>> Andy
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140318/9f274963/attachment-0001.html>

From hjohn at xs4all.nl  Mon Mar 24 06:59:27 2014
From: hjohn at xs4all.nl (John Hendrikx)
Date: Mon, 24 Mar 2014 11:59:27 +0100
Subject: [concurrency-interest] CompletableFuture missing whenComplete
	without exception handling?
Message-ID: <5330100F.8080203@xs4all.nl>

Hi list,

I'm converting some code that uses a CompletableFuture-like asynchronous 
task execution system, and I seem to be missing a way to add a Stage 
that does not influence the result and should not run when there is an 
exception.

If I understand correctly:

- whenComplete: does not influence result, triggers on completion and 
exceptional completion
- thenAccept: changes result to Void, triggers on completion only

Currently I work around this by using thenApply and returning the same 
result myself.

I would have expected there to be methods like:

- whenCompleteHandle: does not influence result, triggers on completion 
and exceptional completion (like the current whenComplete)
- whenCompleteAccept: does not influence result, triggers on completion only

... or something similar.

The chain I'm using would look something like this:

   stage
     .thenApply(...)  // calculates some data (slow)
     .thenApplyAsync(...)  // does something with the data on UI 
executor (fast), returns same data
     .thenCompose(
         CompletableFuture<List<Item>> cf = 
CompletableFuture.completedFuture(emptyList());

         if ("data was not complete") {
            cf = cf.thenApplyAsync(...)  // fetch better data (slow), 
adds items to list, returns list
         }

         return cf.thenAcceptAsync(...)  // uses list (if not empty) and 
notifies UI (fast), returns void
     ) // returns void

Am I missing a way to do this or is this rare enough that no methods 
were created for this?

--John






From viktor.klang at gmail.com  Mon Mar 24 07:11:23 2014
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 24 Mar 2014 12:11:23 +0100
Subject: [concurrency-interest] CompletableFuture missing whenComplete
 without exception handling?
In-Reply-To: <5330100F.8080203@xs4all.nl>
References: <5330100F.8080203@xs4all.nl>
Message-ID: <CANPzfU91pMXumYaL9hvLkXUg28Gw-1FsP6TDcYFFLVbrNZkecw@mail.gmail.com>

On Mon, Mar 24, 2014 at 11:59 AM, John Hendrikx <hjohn at xs4all.nl> wrote:

> Hi list,
>
> I'm converting some code that uses a CompletableFuture-like asynchronous
> task execution system, and I seem to be missing a way to add a Stage that
> does not influence the result and should not run when there is an exception.
>

What happens if that Stage throws an exception?


>
> If I understand correctly:
>
> - whenComplete: does not influence result, triggers on completion and
> exceptional completion
> - thenAccept: changes result to Void, triggers on completion only
>
> Currently I work around this by using thenApply and returning the same
> result myself.
>
> I would have expected there to be methods like:
>
> - whenCompleteHandle: does not influence result, triggers on completion
> and exceptional completion (like the current whenComplete)
> - whenCompleteAccept: does not influence result, triggers on completion
> only
>

In Scala there's an "andThen" method that runs a function on completion and
after that piece of logic completes, it completes the returned Future with
the previous result. If the function throws an exception, that exception is
passed to the ExecutionContext's (the Scala equivalent of Executor)
"reportFailure"-method so it can be logged. Sounds like that's similar to
what you're after.


>
> ... or something similar.
>
> The chain I'm using would look something like this:
>
>   stage
>     .thenApply(...)  // calculates some data (slow)
>     .thenApplyAsync(...)  // does something with the data on UI executor
> (fast), returns same data
>

Sounds like a few lines of utility method that takes a function and
discards the result and returns its input.


>     .thenCompose(
>         CompletableFuture<List<Item>> cf = CompletableFuture.
> completedFuture(emptyList());
>
>         if ("data was not complete") {
>            cf = cf.thenApplyAsync(...)  // fetch better data (slow), adds
> items to list, returns list
>         }
>
>         return cf.thenAcceptAsync(...)  // uses list (if not empty) and
> notifies UI (fast), returns void
>     ) // returns void
>
> Am I missing a way to do this or is this rare enough that no methods were
> created for this?
>
> --John
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
?

*???????**Viktor Klang*
*Chief Architect - **Typesafe <http://www.typesafe.com/>*

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140324/90e4e063/attachment.html>

From hjohn at xs4all.nl  Mon Mar 24 08:06:46 2014
From: hjohn at xs4all.nl (John Hendrikx)
Date: Mon, 24 Mar 2014 13:06:46 +0100
Subject: [concurrency-interest] CompletableFuture missing whenComplete
 without exception handling?
In-Reply-To: <CANPzfU91pMXumYaL9hvLkXUg28Gw-1FsP6TDcYFFLVbrNZkecw@mail.gmail.com>
References: <5330100F.8080203@xs4all.nl>
	<CANPzfU91pMXumYaL9hvLkXUg28Gw-1FsP6TDcYFFLVbrNZkecw@mail.gmail.com>
Message-ID: <53301FD6.6070007@xs4all.nl>

On 24/03/2014 12:11, ?iktor ?lang wrote:
>
> On Mon, Mar 24, 2014 at 11:59 AM, John Hendrikx <hjohn at xs4all.nl 
> <mailto:hjohn at xs4all.nl>> wrote:
>
>     Hi list,
>
>     I'm converting some code that uses a CompletableFuture-like
>     asynchronous task execution system, and I seem to be missing a way
>     to add a Stage that does not influence the result and should not
>     run when there is an exception.
>
>
> What happens if that Stage throws an exception?
It can propogate down the chain until something wants to handle it...

In other words, it doesn't need to change the main result part, but it 
is allowed to change the exception part (if one occurs).

>
>     If I understand correctly:
>
>     - whenComplete: does not influence result, triggers on completion
>     and exceptional completion
>     - thenAccept: changes result to Void, triggers on completion only
>
>     Currently I work around this by using thenApply and returning the
>     same result myself.
>
>     I would have expected there to be methods like:
>
>     - whenCompleteHandle: does not influence result, triggers on
>     completion and exceptional completion (like the current whenComplete)
>     - whenCompleteAccept: does not influence result, triggers on
>     completion only
>
>
> In Scala there's an "andThen" method that runs a function on 
> completion and after that piece of logic completes, it completes the 
> returned Future with the previous result. If the function throws an 
> exception, that exception is passed to the ExecutionContext's (the 
> Scala equivalent of Executor) "reportFailure"-method so it can be 
> logged. Sounds like that's similar to what you're after.
Exceptions get handled in another chain (the chain below is composed 
with it).  If anything goes wrong, it can be handled there; the Executor 
does not need to know about it afaik.
>
>
>     ... or something similar.
>
>     The chain I'm using would look something like this:
>
>       stage
>         .thenApply(...)  // calculates some data (slow)
>         .thenApplyAsync(...)  // does something with the data on UI
>     executor (fast), returns same data
>
>
> Sounds like a few lines of utility method that takes a function and 
> discards the result and returns its input.
Yes, it is easy enough to work around, just seeing if I wasn't missing 
something obvious -- CompletableFuture has a lot of methods :)

Thanks for your help!

--John

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140324/6e181536/attachment.html>

From zhong.j.yu at gmail.com  Mon Mar 24 10:53:34 2014
From: zhong.j.yu at gmail.com (Zhong Yu)
Date: Mon, 24 Mar 2014 09:53:34 -0500
Subject: [concurrency-interest] CompletableFuture missing whenComplete
 without exception handling?
In-Reply-To: <5330100F.8080203@xs4all.nl>
References: <5330100F.8080203@xs4all.nl>
Message-ID: <CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>

So you want something like Stream.peek(). I think it is indeed useful.

A workaround using adapter functional interface:

    interface Peeker<T> extends Function<T,T>
    {
        void peek(T t);

        default T apply(T t)
        {
            peek(t);
            return t;
        }
    }

    void test(CompletionStage<String> cs)
    {
        cs.thenApply( (Peeker<String>)System.out::println );
    }


Zhong Yu

On Mon, Mar 24, 2014 at 5:59 AM, John Hendrikx <hjohn at xs4all.nl> wrote:
> Hi list,
>
> I'm converting some code that uses a CompletableFuture-like asynchronous
> task execution system, and I seem to be missing a way to add a Stage that
> does not influence the result and should not run when there is an exception.
>
> If I understand correctly:
>
> - whenComplete: does not influence result, triggers on completion and
> exceptional completion
> - thenAccept: changes result to Void, triggers on completion only
>
> Currently I work around this by using thenApply and returning the same
> result myself.
>
> I would have expected there to be methods like:
>
> - whenCompleteHandle: does not influence result, triggers on completion and
> exceptional completion (like the current whenComplete)
> - whenCompleteAccept: does not influence result, triggers on completion only
>
> ... or something similar.
>
> The chain I'm using would look something like this:
>
>   stage
>     .thenApply(...)  // calculates some data (slow)
>     .thenApplyAsync(...)  // does something with the data on UI executor
> (fast), returns same data
>     .thenCompose(
>         CompletableFuture<List<Item>> cf =
> CompletableFuture.completedFuture(emptyList());
>
>         if ("data was not complete") {
>            cf = cf.thenApplyAsync(...)  // fetch better data (slow), adds
> items to list, returns list
>         }
>
>         return cf.thenAcceptAsync(...)  // uses list (if not empty) and
> notifies UI (fast), returns void
>     ) // returns void
>
> Am I missing a way to do this or is this rare enough that no methods were
> created for this?
>
> --John
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From viktor.klang at gmail.com  Mon Mar 24 11:08:25 2014
From: viktor.klang at gmail.com (=?UTF-8?B?4oiaaWt0b3Ig0qBsYW5n?=)
Date: Mon, 24 Mar 2014 16:08:25 +0100
Subject: [concurrency-interest] CompletableFuture missing whenComplete
 without exception handling?
In-Reply-To: <CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>
References: <5330100F.8080203@xs4all.nl>
	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>
Message-ID: <CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>

Nice one, Zhong.


On Mon, Mar 24, 2014 at 3:53 PM, Zhong Yu <zhong.j.yu at gmail.com> wrote:

> So you want something like Stream.peek(). I think it is indeed useful.
>
> A workaround using adapter functional interface:
>
>     interface Peeker<T> extends Function<T,T>
>     {
>         void peek(T t);
>
>         default T apply(T t)
>         {
>             peek(t);
>             return t;
>         }
>     }
>
>     void test(CompletionStage<String> cs)
>     {
>         cs.thenApply( (Peeker<String>)System.out::println );
>     }
>
>
> Zhong Yu
>
> On Mon, Mar 24, 2014 at 5:59 AM, John Hendrikx <hjohn at xs4all.nl> wrote:
> > Hi list,
> >
> > I'm converting some code that uses a CompletableFuture-like asynchronous
> > task execution system, and I seem to be missing a way to add a Stage that
> > does not influence the result and should not run when there is an
> exception.
> >
> > If I understand correctly:
> >
> > - whenComplete: does not influence result, triggers on completion and
> > exceptional completion
> > - thenAccept: changes result to Void, triggers on completion only
> >
> > Currently I work around this by using thenApply and returning the same
> > result myself.
> >
> > I would have expected there to be methods like:
> >
> > - whenCompleteHandle: does not influence result, triggers on completion
> and
> > exceptional completion (like the current whenComplete)
> > - whenCompleteAccept: does not influence result, triggers on completion
> only
> >
> > ... or something similar.
> >
> > The chain I'm using would look something like this:
> >
> >   stage
> >     .thenApply(...)  // calculates some data (slow)
> >     .thenApplyAsync(...)  // does something with the data on UI executor
> > (fast), returns same data
> >     .thenCompose(
> >         CompletableFuture<List<Item>> cf =
> > CompletableFuture.completedFuture(emptyList());
> >
> >         if ("data was not complete") {
> >            cf = cf.thenApplyAsync(...)  // fetch better data (slow), adds
> > items to list, returns list
> >         }
> >
> >         return cf.thenAcceptAsync(...)  // uses list (if not empty) and
> > notifies UI (fast), returns void
> >     ) // returns void
> >
> > Am I missing a way to do this or is this rare enough that no methods were
> > created for this?
> >
> > --John
> >
> >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
?

*???????**Viktor Klang*
*Chief Architect - **Typesafe <http://www.typesafe.com/>*

Twitter: @viktorklang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140324/4be2dac3/attachment-0001.html>

From navin.jha at jpmorgan.com  Tue Mar 25 12:01:11 2014
From: navin.jha at jpmorgan.com (Jha, Navin)
Date: Tue, 25 Mar 2014 16:01:11 +0000
Subject: [concurrency-interest] read in current ConcurrentHashMap
In-Reply-To: <CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>
References: <5330100F.8080203@xs4all.nl>
	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>
	<CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>
Message-ID: <9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>

In the documentation for current ConcurrentHashMap implementation it says:

Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).

Looking at the get() code I was wondering when the blocking might happen. I should point out that I don?t know the semantics of UNSAFE.getObjectVolatile(...).

The get(?) code below:

public V get(Object key) {
        Segment<K,V> s; // manually integrate access methods to reduce overhead
        HashEntry<K,V>[] tab;
        int h = hash(key.hashCode());
        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
            (tab = s.table) != null) {
            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }

This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/a4bf4f08/attachment.html>

From nathan.reynolds at oracle.com  Tue Mar 25 12:18:12 2014
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 25 Mar 2014 09:18:12 -0700
Subject: [concurrency-interest] read in current ConcurrentHashMap
In-Reply-To: <9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>
References: <5330100F.8080203@xs4all.nl>	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>	<CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>
	<9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>
Message-ID: <5331AC44.5060109@oracle.com>

If I remember right, the ConcurrentHashMap of JDK 6 could have blocked 
in some cases.  The ConcurrentHashMap of JDK 8 has been revamped.  I am 
not surprised that I don't see any way for a get() to block.

-Nathan

On 3/25/2014 9:01 AM, Jha, Navin wrote:
>
> In the documentation for current ConcurrentHashMap implementation it says:
>
> /Retrieval operations (including//get//) generally do not block, so 
> may overlap with update operations (including//put////and//remove//)./
>
> //
>
> Looking at the get() code I was wondering when the blocking might 
> happen. I should point out that I don't know the semantics of 
> UNSAFE.getObjectVolatile(...).
>
> The get(...) code below:
>
> public V get(Object key) {
>
> Segment<K,V> s; // manually integrate access methods to reduce overhead
>
> HashEntry<K,V>[] tab;
>
> int h = hash(key.hashCode());
>
> long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
>
> if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
>
> (tab = s.table) != null) {
>
> for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
>
> (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
>
> e != null; e = e.next) {
>
> K k;
>
> if ((k = e.key) == key || (e.hash == h && key.equals(k)))
>
> return e.value;
>
> }
>
> }
>
> return null;
>
> }
>
> This email is confidential and subject to important disclaimers and 
> conditions including on offers for the purchase or sale of securities, 
> accuracy and completeness of information, viruses, confidentiality, 
> legal privilege, and legal entity disclaimers, available at 
> http://www.jpmorgan.com/pages/disclosures/email.
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/7cf8b99e/attachment-0001.html>

From sitnikov.vladimir at gmail.com  Tue Mar 25 12:25:00 2014
From: sitnikov.vladimir at gmail.com (Vladimir Sitnikov)
Date: Tue, 25 Mar 2014 20:25:00 +0400
Subject: [concurrency-interest] Writing final fields via reflection vs
	safe-visibility of new contents
In-Reply-To: <CAB=Je-E7JeHpcBCvw1yKXMD6JrfWxKY8bR8wOY3z47jcL7w9wA@mail.gmail.com>
References: <CAB=Je-E7JeHpcBCvw1yKXMD6JrfWxKY8bR8wOY3z47jcL7w9wA@mail.gmail.com>
Message-ID: <CAB=Je-G5t3=5N4rAGKczqPSLuxFgsJOWxU7NHi2F5wpLLOUpSA@mail.gmail.com>

I suppose I understand cast memory and dereference chains well enough to
answer the original question.

TL;DR -- 0 (!), 41, 1, and 2  are acceptable outcomes

Can you please double check if that is the correct answer?


In other words, if the reference to "final wrapper" (the class with final
field in question, State in particular example) leaks before all the
modifications of final fields, then final field semantics might not fully
apply.

As 17.5.3 suggests, "The object should not be made visible to other
threads, nor should the final fields be read, until all updates to the
final fields
of the object are complete".

In particular case,
1) If thread 2 does not see "updated-via-reflection" final field, then all
is fine and thread 2 is guaranteed to see the write x.x=1.

I assume that "we consider *hb(w, r2)*. (This *happens-before* ordering
does not transitively close with other *happens-before* orderings.)" in
17.5.1 means "final-induced-happens-before can be treated in the same way
as typical happens-before that is described in 17.4.5 in terms of allowable
reads".
I wish the specification is updated with actual meaning of how to treat
"final-induced-happens-before"(those happens-before differ somehow from
"other happens-before").

2) Now the interesting part. If thread 2 does see "updated-via-reflection"
value, then we need to cast all the chains and see if all the chains
fit "*hb(w,
f)*, *hb(f, a)*, *mc(a, r1)*, and *dereferences(r1, r2)*" conditions of
17.5.1

We pick as follows:
  w -- write(x.x, 2)
  f -- freeze that happens immediately with update-via-reflection (17.5.3)
   hb(w, f) -- due to program order
   a -- that is the problem

Thread 1 did not perform new actions after update of final field, but the
spec requires hb(f, a).
2.1) We might try to use a==f (in other words, a is a freeze action).
  In this case,  no memory chain can be created that fulfills *mc(a, r1)*.
17.5.1 defines three ways to cast a memory chain, however none of those can
chain freeze action with any other action.

2.2) We might try to use a==thread termination, however no luck with *mc(a,
r1) *here as well

There is no way to apply 17.5.1, thus we do not have
"final-induced-happens-before" here.
That effectively says we are alone with non-volatile, non-final fields.
The answer for that case is well-known and it is acceptable for thread 2 to
see the write of default value (the write of default value of x in second
IntHolder).

Vladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/610dcab0/attachment.html>

From navin.jha at jpmorgan.com  Tue Mar 25 13:10:30 2014
From: navin.jha at jpmorgan.com (Jha, Navin)
Date: Tue, 25 Mar 2014 17:10:30 +0000
Subject: [concurrency-interest] read in current ConcurrentHashMap
In-Reply-To: <5331AC44.5060109@oracle.com>
References: <5330100F.8080203@xs4all.nl>
	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>
	<CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>
	<9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>
	<5331AC44.5060109@oracle.com>
Message-ID: <9F257429AEF3514CA5CA2FEC92CBFA271A77EBF4@SCACMX019.exchad.jpmchase.net>

Thanks Nathan. I was curious about the "could have blocked case" if you remember more :)

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Nathan Reynolds
Sent: Tuesday, March 25, 2014 12:18 PM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] read in current ConcurrentHashMap

If I remember right, the ConcurrentHashMap of JDK 6 could have blocked in some cases.  The ConcurrentHashMap of JDK 8 has been revamped.  I am not surprised that I don't see any way for a get() to block.


-Nathan
On 3/25/2014 9:01 AM, Jha, Navin wrote:
In the documentation for current ConcurrentHashMap implementation it says:

Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).

Looking at the get() code I was wondering when the blocking might happen. I should point out that I don't know the semantics of UNSAFE.getObjectVolatile(...).

The get(...) code below:

public V get(Object key) {
        Segment<K,V> s; // manually integrate access methods to reduce overhead
        HashEntry<K,V>[] tab;
        int h = hash(key.hashCode());
        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
            (tab = s.table) != null) {
            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }

This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.




_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest


This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/bcc2147a/attachment-0001.html>

From nathan.reynolds at oracle.com  Tue Mar 25 13:58:28 2014
From: nathan.reynolds at oracle.com (Nathan Reynolds)
Date: Tue, 25 Mar 2014 10:58:28 -0700
Subject: [concurrency-interest] read in current ConcurrentHashMap
In-Reply-To: <9F257429AEF3514CA5CA2FEC92CBFA271A77EBF4@SCACMX019.exchad.jpmchase.net>
References: <5330100F.8080203@xs4all.nl>	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>	<CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>	<9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>
	<5331AC44.5060109@oracle.com>
	<9F257429AEF3514CA5CA2FEC92CBFA271A77EBF4@SCACMX019.exchad.jpmchase.net>
Message-ID: <5331C3C4.4080709@oracle.com>

Found it.  In JDK 6, ConcurrentHashMap.get() calls 
ConcurrentHashMap.Segment.get(). See the link below for the code.  
Segment.get() will call Segment.readValueUnderLock() if the value is 
null in the entry.

http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.Segment.get%28java.lang.Object%2Cint%29

-Nathan

On 3/25/2014 10:10 AM, Jha, Navin wrote:
>
> Thanks Nathan. I was curious about the "could have blocked case" if 
> you remember more ?
>
> *From:*concurrency-interest-bounces at cs.oswego.edu 
> [mailto:concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of 
> *Nathan Reynolds
> *Sent:* Tuesday, March 25, 2014 12:18 PM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] read in current ConcurrentHashMap
>
> If I remember right, the ConcurrentHashMap of JDK 6 could have blocked 
> in some cases.  The ConcurrentHashMap of JDK 8 has been revamped.  I 
> am not surprised that I don't see any way for a get() to block.
>
> -Nathan
>
> On 3/25/2014 9:01 AM, Jha, Navin wrote:
>
>     In the documentation for current ConcurrentHashMap implementation
>     it says:
>
>     /Retrieval operations (including//get//) generally do not block,
>     so may overlap with update operations
>     (including//put////and//remove//)./
>
>     //
>
>     Looking at the get() code I was wondering when the blocking might
>     happen. I should point out that I don't know the semantics of
>     UNSAFE.getObjectVolatile(...).
>
>     The get(...) code below:
>
>     public V get(Object key) {
>
>     Segment<K,V> s; // manually integrate access methods to reduce
>     overhead
>
>     HashEntry<K,V>[] tab;
>
>     int h = hash(key.hashCode());
>
>     long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
>
>     if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) !=
>     null &&
>
>     (tab = s.table) != null) {
>
>     for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
>
>     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
>
>     e != null; e = e.next) {
>
>     K k;
>
>     if ((k = e.key) == key || (e.hash == h && key.equals(k)))
>
>     return e.value;
>
>     }
>
>     }
>
>     return null;
>
>     }
>
>     This email is confidential and subject to important disclaimers
>     and conditions including on offers for the purchase or sale of
>     securities, accuracy and completeness of information, viruses,
>     confidentiality, legal privilege, and legal entity disclaimers,
>     available at http://www.jpmorgan.com/pages/disclosures/email
>     <http://www.jpmorgan.com/pages/disclosures/email>.
>
>
>
>
>     _______________________________________________
>
>     Concurrency-interest mailing list
>
>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> This email is confidential and subject to important disclaimers and 
> conditions including on offers for the purchase or sale of securities, 
> accuracy and completeness of information, viruses, confidentiality, 
> legal privilege, and legal entity disclaimers, available at 
> http://www.jpmorgan.com/pages/disclosures/email.
>


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/3c9e5dc1/attachment.html>

From navin.jha at jpmorgan.com  Tue Mar 25 14:07:33 2014
From: navin.jha at jpmorgan.com (Jha, Navin)
Date: Tue, 25 Mar 2014 18:07:33 +0000
Subject: [concurrency-interest] read in current ConcurrentHashMap
In-Reply-To: <5331C3C4.4080709@oracle.com>
References: <5330100F.8080203@xs4all.nl>
	<CACuKZqGZG+jH7kqZsLB7ojYNnQQ_Whj5B-Mo8VvaTdtmC9VYLQ@mail.gmail.com>
	<CANPzfU9WUzm63nTzNPHJWMMDsGZXPtgX-ZBEoZ3ric-SNGFxmw@mail.gmail.com>
	<9F257429AEF3514CA5CA2FEC92CBFA271A77EAEC@SCACMX019.exchad.jpmchase.net>
	<5331AC44.5060109@oracle.com>
	<9F257429AEF3514CA5CA2FEC92CBFA271A77EBF4@SCACMX019.exchad.jpmchase.net>
	<5331C3C4.4080709@oracle.com>
Message-ID: <9F257429AEF3514CA5CA2FEC92CBFA271A77EC88@SCACMX019.exchad.jpmchase.net>

Thank you so much!

From: Nathan Reynolds [mailto:nathan.reynolds at oracle.com]
Sent: Tuesday, March 25, 2014 1:58 PM
To: Jha, Navin; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] read in current ConcurrentHashMap

Found it.  In JDK 6, ConcurrentHashMap.get() calls ConcurrentHashMap.Segment.get().  See the link below for the code.  Segment.get() will call Segment.readValueUnderLock() if the value is null in the entry.

http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.Segment.get%28java.lang.Object%2Cint%29


-Nathan
On 3/25/2014 10:10 AM, Jha, Navin wrote:
Thanks Nathan. I was curious about the ?could have blocked case? if you remember more ?

From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Nathan Reynolds
Sent: Tuesday, March 25, 2014 12:18 PM
To: concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] read in current ConcurrentHashMap

If I remember right, the ConcurrentHashMap of JDK 6 could have blocked in some cases.  The ConcurrentHashMap of JDK 8 has been revamped.  I am not surprised that I don't see any way for a get() to block.



-Nathan
On 3/25/2014 9:01 AM, Jha, Navin wrote:
In the documentation for current ConcurrentHashMap implementation it says:

Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).

Looking at the get() code I was wondering when the blocking might happen. I should point out that I don?t know the semantics of UNSAFE.getObjectVolatile(...).

The get(?) code below:

public V get(Object key) {
        Segment<K,V> s; // manually integrate access methods to reduce overhead
        HashEntry<K,V>[] tab;
        int h = hash(key.hashCode());
        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
            (tab = s.table) != null) {
            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }

This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.





_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest


This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.


This email is confidential and subject to important disclaimers and conditions including on offers for the purchase or sale of securities, accuracy and completeness of information, viruses, confidentiality, legal privilege, and legal entity disclaimers, available at http://www.jpmorgan.com/pages/disclosures/email.  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140325/490a034a/attachment-0001.html>

From shelajev at gmail.com  Wed Mar 26 11:19:59 2014
From: shelajev at gmail.com (=?UTF-8?Q?Oleg_=C5=A0elajev?=)
Date: Wed, 26 Mar 2014 17:19:59 +0200
Subject: [concurrency-interest] Did ForkJoinPool.invoke(RecursiveTask
 task)'s semantics change in Java 8?
Message-ID: <CAOcG6DD+z3-BpPqGcevkQp+qKXx8KqWumJOPjiicdeYP6A9O3w@mail.gmail.com>

Hi,

I've been playing around with this
example<https://github.com/kabutz/javaspecialists/blob/master/src/main/java/eu/javaspecialists/tjsn/math/fibonacci/FibonacciRecursiveParallelDijkstraKaratsuba.java>,
created by Dr Heinz M. Kabutz, that uses ForkJoin to compute Fibonacci
numbers.

It uses a single ForkJoin pool to execute tasks in parallel for both
computing Fibonacci numbers recursively and multiplying large integers
recursively with the Karatsuba algorithm.

Additionally it features a cache for the computed Fibonacci numbers. To
avoid double work, the cache works in a way that if a thread asks for a
value that is not ready, but is being computed currently, then that thread
doesn't start the computation again, but begins a timed waiting until the
result is available.

Now this example works very well with Java 7 (build 1.7.0_40-b43). However,
it stalls and doesn't progress if I run it with Java 8 (1.8.0-b132).

To be precise, I run this with the following main method:

public static void main(String[] args) throws Exception {
    int n = 40004;
    BigInteger result = new FibonacciRecursiveParallelDijkstraKaratsuba(new
ForkJoinPool(4)).calculate(n);
    System.out.println(result.hashCode());
}

I have a vague understanding why it is happening. When the code computes
Fibonacci numbers it gets the same smaller numbers a lot. I have 4 worker
threads in the pool, and they all rush to compute same values, so 3 of them
get stuck behind the cache and sit in a timed waiting state, waiting for
the result.
Now one thread always gets through the cache and tries to compute a
Fibonacci number.
So it invokes another RecursiveTask (Karatsuba multiplication) and starts
awaiting the join. Since there are no free workers and everyone is waiting
the whole system stalls and doesn't progress. Here is a workers' thread
dump: http://pastebin.com/dAp5mDzW

This doesn't seem to happen with Java 7, there FJP.invoke() checks if the
current thread is a worker in the same pool and does the work itself or
compensates with spawning another worker (?) before awaiting the join.

I understand that it might not be the best idea to make workers wait in
this fashion, but I can imagine that the code like this is fairly common,
and with FJP.commonPool() available from anywhere, most of the tasks are
probably using the same pool.

I haven't found any proof that FJP.invoke() has changed semantics, but it
seems kinda so. Or am I just getting lucky with Java 7 implementation and
for some inputs it would stall in the same manner as well?

Best,
Oleg
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140326/abcd36d8/attachment.html>

From dl at cs.oswego.edu  Wed Mar 26 12:13:01 2014
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 26 Mar 2014 12:13:01 -0400
Subject: [concurrency-interest] Did ForkJoinPool.invoke(RecursiveTask
 task)'s semantics change in Java 8?
In-Reply-To: <CAOcG6DD+z3-BpPqGcevkQp+qKXx8KqWumJOPjiicdeYP6A9O3w@mail.gmail.com>
References: <CAOcG6DD+z3-BpPqGcevkQp+qKXx8KqWumJOPjiicdeYP6A9O3w@mail.gmail.com>
Message-ID: <5332FC8D.8040607@cs.oswego.edu>

On 03/26/2014 11:19 AM, Oleg ?elajev wrote:
> Hi,
>
> I've been playing around with this example
> <https://github.com/kabutz/javaspecialists/blob/master/src/main/java/eu/javaspecialists/tjsn/math/fibonacci/FibonacciRecursiveParallelDijkstraKaratsuba.java>,
> created by Dr Heinz M. Kabutz, that uses ForkJoin to compute Fibonacci numbers.
>
> It uses a single ForkJoin pool to execute tasks in parallel for both computing
> Fibonacci numbers recursively and multiplying large integers recursively with
> the Karatsuba algorithm.
>
> Additionally it features a cache for the computed Fibonacci numbers. To avoid
> double work, the cache works in a way that if a thread asks for a value that is
> not ready, but is being computed currently, then that thread doesn't start the
> computation again, but begins a timed waiting until the result is available.
>
> Now this example works very well with Java 7 (build 1.7.0_40-b43). However, it
> stalls and doesn't progress if I run it with Java 8 (1.8.0-b132).
>
> To be precise, I run this with the following main method:
>
> public static void main(String[] args) throws Exception {
>      int n = 40004;
> BigInteger result = new FibonacciRecursiveParallelDijkstraKaratsuba(new
> ForkJoinPool(4)).calculate(n);
>      System.out.println(result.hashCode());
> }
>
> I have a vague understanding why it is happening. When the code computes
> Fibonacci numbers it gets the same smaller numbers a lot. I have 4 worker
> threads in the pool, and they all rush to compute same values, so 3 of them get
> stuck behind the cache and sit in a timed waiting state, waiting for the result.
> Now one thread always gets through the cache and tries to compute a Fibonacci
> number.
> So it invokes another RecursiveTask (Karatsuba multiplication) and starts
> awaiting the join. Since there are no free workers and everyone is waiting the
> whole system stalls and doesn't progress. Here is a workers' thread dump:
> http://pastebin.com/dAp5mDzW <http://pastebin.com/dAp5mDzW>
>
> This doesn't seem to happen with Java 7, there FJP.invoke() checks if the
> current thread is a worker in the same pool and does the work itself or
> compensates with spawning another worker (?) before awaiting the join.
>
> I understand that it might not be the best idea to make workers wait in this
> fashion, but I can imagine that the code like this is fairly common, and with
> FJP.commonPool() available from anywhere, most of the tasks are probably using
> the same pool.
>
> I haven't found any proof that FJP.invoke() has changed semantics, but it seems
> kinda so. Or am I just getting lucky with Java 7 implementation and for some
> inputs it would stall in the same manner as well?

It appears to be luck. These threads were blocking on non-FJ
synchronization at
   eu.javaspecialists.tjsn.concurrency.util.FutureResult.get

If you block FJ tasks on external sync/IO, FJ cannot guarantee to
notice that you've exhausted all threads, and so it might not create
others.

In this particular case, the problems would be avoided by
reworking Heinz's FutureResult class using ForkJoinPool.ManagedBlocker.

To address this issue in other uncontrolled contexts,
the JDK8 stream framework uses CountedCompleters instead of the
easier-to-use RecursiveTasks used in this example.

-Doug




From ganeshkumarv at sensiple.com  Fri Mar 28 22:52:23 2014
From: ganeshkumarv at sensiple.com (Ganesh Vijayakumar)
Date: Fri, 28 Mar 2014 22:52:23 -0400
Subject: [concurrency-interest] Runtime.getRuntime().availableProcessors()
Message-ID: <CAG_WF8eb3Wtr=OVYkiYRkVN_GtWySydYi058JrV5W__tp_V8Og@mail.gmail.com>

Hello,

Runtime.*getRuntime*().availableProcessors() always returns the number of
processors online.
I would like to get the number of available processors for the current
process
The only option i see is to execute nproc (linux) and read the return val,
Is there an alternative?

Thanks,
Ganesh.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140328/1023f258/attachment.html>

From davidcholmes at aapt.net.au  Sat Mar 29 00:10:58 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 29 Mar 2014 14:10:58 +1000
Subject: [concurrency-interest]
	Runtime.getRuntime().availableProcessors()
In-Reply-To: <CAG_WF8eb3Wtr=OVYkiYRkVN_GtWySydYi058JrV5W__tp_V8Og@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEHIKFAA.davidcholmes@aapt.net.au>

You need to use a native method to extract the desired information. Simplest
way is to get the processor count from the current thread's scheduling
affinity.

See

http://bugs.openjdk.java.net/browse/JDK-6515172

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Ganesh
Vijayakumar
  Sent: Saturday, 29 March 2014 12:52 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Runtime.getRuntime().availableProcessors()


  Hello,


  Runtime.getRuntime().availableProcessors() always returns the number of
processors online.
  I would like to get the number of available processors for the current
process
  The only option i see is to execute nproc (linux) and read the return val,
Is there an alternative?


  Thanks,
  Ganesh.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140329/0837992a/attachment.html>

From ganesh17jan at gmail.com  Sat Mar 29 03:02:47 2014
From: ganesh17jan at gmail.com (Ganesh Vijayakumar)
Date: Sat, 29 Mar 2014 03:02:47 -0400
Subject: [concurrency-interest]
	Runtime.getRuntime().availableProcessors()
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEHIKFAA.davidcholmes@aapt.net.au>
References: <CAG_WF8eb3Wtr=OVYkiYRkVN_GtWySydYi058JrV5W__tp_V8Og@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEHIKFAA.davidcholmes@aapt.net.au>
Message-ID: <CAG_WF8dH+2A=yes6NDRvBs5k9dHq+vdzaq4nLx_FME82FC0Bsg@mail.gmail.com>

Hello David,

Thanks much.
Does the hotspot VM use this availableProcessors()  to initialize defaults
(ergonomics) like number of gc threads etc..,? If so could you point me to
any document that tells me things that depends on this ?

Ganesh


On Sat, Mar 29, 2014 at 12:10 AM, David Holmes <davidcholmes at aapt.net.au>wrote:

>  You need to use a native method to extract the desired information.
> Simplest way is to get the processor count from the current thread's
> scheduling affinity.
>
> See
>
> http://bugs.openjdk.java.net/browse/JDK-6515172
>
> David
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Ganesh
> Vijayakumar
> *Sent:* Saturday, 29 March 2014 12:52 PM
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest]
> Runtime.getRuntime().availableProcessors()
>
> Hello,
>
> Runtime.*getRuntime*().availableProcessors() always returns the number of
> processors online.
> I would like to get the number of available processors for the current
> process
> The only option i see is to execute nproc (linux) and read the return val,
> Is there an alternative?
>
> Thanks,
> Ganesh.
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140329/3fc70b66/attachment.html>

From davidcholmes at aapt.net.au  Sat Mar 29 03:53:23 2014
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 29 Mar 2014 17:53:23 +1000
Subject: [concurrency-interest]
	Runtime.getRuntime().availableProcessors()
In-Reply-To: <CAG_WF8dH+2A=yes6NDRvBs5k9dHq+vdzaq4nLx_FME82FC0Bsg@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEIBKFAA.davidcholmes@aapt.net.au>

Yes ths is used for GC and JIT ergonomics but I think the only accurate
documentation (the Java 6 Heap/GC Tuning Guide seems out of date) is the
source code. Grep for active_processor_count.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Ganesh
Vijayakumar
  Sent: Saturday, 29 March 2014 5:03 PM
  To: dholmes at ieee.org
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re:
[concurrency-interest]Runtime.getRuntime().availableProcessors()


  Hello David,


  Thanks much.
  Does the hotspot VM use this availableProcessors()  to initialize defaults
(ergonomics) like number of gc threads etc..,? If so could you point me to
any document that tells me things that depends on this ?


  Ganesh




  On Sat, Mar 29, 2014 at 12:10 AM, David Holmes <davidcholmes at aapt.net.au>
wrote:

    You need to use a native method to extract the desired information.
Simplest way is to get the processor count from the current thread's
scheduling affinity.

    See

    http://bugs.openjdk.java.net/browse/JDK-6515172

    David
      -----Original Message-----
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Ganesh
Vijayakumar
      Sent: Saturday, 29 March 2014 12:52 PM
      To: concurrency-interest at cs.oswego.edu
      Subject: [concurrency-interest]
Runtime.getRuntime().availableProcessors()


      Hello,


      Runtime.getRuntime().availableProcessors() always returns the number
of processors online.
      I would like to get the number of available processors for the current
process
      The only option i see is to execute nproc (linux) and read the return
val, Is there an alternative?


      Thanks,
      Ganesh.



    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20140329/4488bc62/attachment.html>

