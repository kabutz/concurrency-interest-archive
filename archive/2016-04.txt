From unmeshjoshi at gmail.com  Fri Apr 15 02:09:08 2016
From: unmeshjoshi at gmail.com (Unmesh Joshi)
Date: Fri, 15 Apr 2016 11:39:08 +0530
Subject: [concurrency-interest] Synchronizing on ReservationNode in
	ConcurrentHashMap.computeIfAbsent
Message-ID: <CAOk+zfeBX7jEog7Vs3NV5x=jDu0agtq88w2tt8nfV26ye_HP8A@mail.gmail.com>

Hi,


I was browsing through the code of ConcurrentHashMap.computeIfAbsent
and on line 1655, I see synchronization as following..

(http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java?av=f)


  Node <http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.Node><K,V>
r = new ReservationNode
<http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.ReservationNode><K,V>();

synchronized (r)


What is the significance of synchronizing on new object?


Thanks,

Unmesh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160415/da14a84f/attachment.html>

From jason at tedor.me  Fri Apr 15 07:53:23 2016
From: jason at tedor.me (Jason Tedor)
Date: Fri, 15 Apr 2016 11:53:23 +0000
Subject: [concurrency-interest] Synchronizing on ReservationNode in
	ConcurrentHashMap.computeIfAbsent
In-Reply-To: <CAOk+zfeBX7jEog7Vs3NV5x=jDu0agtq88w2tt8nfV26ye_HP8A@mail.gmail.com>
References: <CAOk+zfeBX7jEog7Vs3NV5x=jDu0agtq88w2tt8nfV26ye_HP8A@mail.gmail.com>
Message-ID: <CAMYd3R4FMQ9vL-D62LwZWSmNc3nYQZUOAyeyVLd5SihWQ-h7GA@mail.gmail.com>

This was discussed previously:
http://cs.oswego.edu/pipermail/concurrency-interest/2016-January/014857.html

On Fri, Apr 15, 2016 at 2:22 AM Unmesh Joshi <unmeshjoshi at gmail.com> wrote:

> Hi,
>
>
> I was browsing through the code of ConcurrentHashMap.computeIfAbsent and on line 1655, I see synchronization as following..
>
> (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java?av=f)
>
>
>   Node <http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.Node><K,V> r = new ReservationNode <http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap.ReservationNode><K,V>();
>
> synchronized (r)
>
>
> What is the significance of synchronizing on new object?
>
>
> Thanks,
>
> Unmesh
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160415/27fc7e09/attachment.html>

From heinz at javaspecialists.eu  Tue Apr 19 04:14:18 2016
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 19 Apr 2016 11:14:18 +0300
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
	computeIfAbsent() ?
Message-ID: <5715E8DA.8020403@javaspecialists.eu>

Hi everybody,

I think I might have discovered some issues with our wonderful 
ConcurrentHashMap.  In this code, it appears to livelock on the 
transfer() method once i=12:

import java.math.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;

public class WeirdComputeIfAbsentBehaviour {
  public static void main(String... args) {
    for (int i = 0; i < 30; i++) {
      System.out.println("i = " + i);
      show(new HashMap(), i);
      show(new LinkedHashMap(), i);
      show(new ConcurrentSkipListMap<>(), i);
      show(new ConcurrentHashMap<>(), i);
    }
  }

  private static void show(Map<Integer, BigInteger> map, int n) {
    System.out.println(map.getClass().getSimpleName() + ": " +
        new FibonacciCached(map).f(n));
  }


  public static class FibonacciCached {
    private final Map<Integer, BigInteger> cache;

    public FibonacciCached(Map<Integer, BigInteger> cache) {
      this.cache = cache;
      cache.put(0, BigInteger.ZERO);
      cache.put(1, BigInteger.ONE);
    }

    public BigInteger f(int n) {
      return cache.computeIfAbsent(n, key -> f(n - 1).add(f(n - 2)));
    }
  }
}


Output in Java 8:

java version "1.8.0_74"
Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)

i = 0
HashMap: 0
LinkedHashMap: 0
ConcurrentSkipListMap: 0
ConcurrentHashMap: 0
i = 1
HashMap: 1
LinkedHashMap: 1
ConcurrentSkipListMap: 1
ConcurrentHashMap: 1
i = 2
HashMap: 1
LinkedHashMap: 1
ConcurrentSkipListMap: 1
ConcurrentHashMap: 1
i = 3
HashMap: 2
LinkedHashMap: 2
ConcurrentSkipListMap: 2
ConcurrentHashMap: 2
i = 4
HashMap: 3
LinkedHashMap: 3
ConcurrentSkipListMap: 3
ConcurrentHashMap: 3
i = 5
HashMap: 5
LinkedHashMap: 5
ConcurrentSkipListMap: 5
ConcurrentHashMap: 5
i = 6
HashMap: 8
LinkedHashMap: 8
ConcurrentSkipListMap: 8
ConcurrentHashMap: 8
i = 7
HashMap: 13
LinkedHashMap: 13
ConcurrentSkipListMap: 13
ConcurrentHashMap: 13
i = 8
HashMap: 21
LinkedHashMap: 21
ConcurrentSkipListMap: 21
ConcurrentHashMap: 21
i = 9
HashMap: 34
LinkedHashMap: 34
ConcurrentSkipListMap: 34
ConcurrentHashMap: 34
i = 10
HashMap: 55
LinkedHashMap: 55
ConcurrentSkipListMap: 55
ConcurrentHashMap: 55
i = 11
HashMap: 89
LinkedHashMap: 89
ConcurrentSkipListMap: 89
ConcurrentHashMap: 89
i = 12
HashMap: 144
LinkedHashMap: 144
ConcurrentSkipListMap: 144
2016-04-19 11:08:49
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.74-b02 mixed mode):
*snip*

"main" #1 prio=5 os_prio=31 tid=0x00007f81e3801000 nid=0x1703 runnable 
[0x0000700000219000]
   java.lang.Thread.State: RUNNABLE
        at 
java.util.concurrent.ConcurrentHashMap.transfer(ConcurrentHashMap.java:2497)
        at 
java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2288)
        at 
java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1720)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.lambda$f$0(WeirdComputeIfAbsentBehaviour.java:35)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached$$Lambda$1/1831932724.apply(Unknown 
Source)
        at 
java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660)
        - locked <0x000000076ae88b50> (a 
java.util.concurrent.ConcurrentHashMap$ReservationNode)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour.show(WeirdComputeIfAbsentBehaviour.java:21)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour.main(WeirdComputeIfAbsentBehaviour.java:15)

Oh and it doesn't even get that far with Java 9 (my VarHandle build from 
last month), because HashMap dies when i=3:

openjdk version "9-internal"
OpenJDK Runtime Environment (build 
9-internal+0-2016-03-02-185127.heinz.sandbox)
OpenJDK 64-Bit Server VM (build 
9-internal+0-2016-03-02-185127.heinz.sandbox, mixed mode)

i = 0
HashMap: 0
LinkedHashMap: 0
ConcurrentSkipListMap: 0
ConcurrentHashMap: 0
i = 1
HashMap: 1
LinkedHashMap: 1
ConcurrentSkipListMap: 1
ConcurrentHashMap: 1
i = 2
HashMap: 1
LinkedHashMap: 1
ConcurrentSkipListMap: 1
ConcurrentHashMap: 1
i = 3
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.HashMap.computeIfAbsent(HashMap.java:1138)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour.show(WeirdComputeIfAbsentBehaviour.java:21)
        at 
samples.ch15.WeirdComputeIfAbsentBehaviour.main(WeirdComputeIfAbsentBehaviour.java:12)

Regards

Heinz
-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion since 2005
JavaOne Rock Star Speaker 2012
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz


From ben.manes at gmail.com  Tue Apr 19 04:45:44 2016
From: ben.manes at gmail.com (Benjamin Manes)
Date: Tue, 19 Apr 2016 01:45:44 -0700
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <5715E8DA.8020403@javaspecialists.eu>
References: <5715E8DA.8020403@javaspecialists.eu>
Message-ID: <CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>

Unfortunately the improvements
<http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.258&r2=1.259>
have not made it into a JDK8 release, as far as I am aware. These increased
the ability for detecting computations that modify the map and throws an
IllegalStateException, as defined by the contract.

On Tue, Apr 19, 2016 at 1:14 AM, Dr Heinz M. Kabutz <
heinz at javaspecialists.eu> wrote:

> Hi everybody,
>
> I think I might have discovered some issues with our wonderful
> ConcurrentHashMap.  In this code, it appears to livelock on the transfer()
> method once i=12:
>
> import java.math.*;
> import java.util.*;
> import java.util.concurrent.*;
> import java.util.function.*;
>
> public class WeirdComputeIfAbsentBehaviour {
>  public static void main(String... args) {
>    for (int i = 0; i < 30; i++) {
>      System.out.println("i = " + i);
>      show(new HashMap(), i);
>      show(new LinkedHashMap(), i);
>      show(new ConcurrentSkipListMap<>(), i);
>      show(new ConcurrentHashMap<>(), i);
>    }
>  }
>
>  private static void show(Map<Integer, BigInteger> map, int n) {
>    System.out.println(map.getClass().getSimpleName() + ": " +
>        new FibonacciCached(map).f(n));
>  }
>
>
>  public static class FibonacciCached {
>    private final Map<Integer, BigInteger> cache;
>
>    public FibonacciCached(Map<Integer, BigInteger> cache) {
>      this.cache = cache;
>      cache.put(0, BigInteger.ZERO);
>      cache.put(1, BigInteger.ONE);
>    }
>
>    public BigInteger f(int n) {
>      return cache.computeIfAbsent(n, key -> f(n - 1).add(f(n - 2)));
>    }
>  }
> }
>
>
> Output in Java 8:
>
> java version "1.8.0_74"
> Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
> Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)
>
> i = 0
> HashMap: 0
> LinkedHashMap: 0
> ConcurrentSkipListMap: 0
> ConcurrentHashMap: 0
> i = 1
> HashMap: 1
> LinkedHashMap: 1
> ConcurrentSkipListMap: 1
> ConcurrentHashMap: 1
> i = 2
> HashMap: 1
> LinkedHashMap: 1
> ConcurrentSkipListMap: 1
> ConcurrentHashMap: 1
> i = 3
> HashMap: 2
> LinkedHashMap: 2
> ConcurrentSkipListMap: 2
> ConcurrentHashMap: 2
> i = 4
> HashMap: 3
> LinkedHashMap: 3
> ConcurrentSkipListMap: 3
> ConcurrentHashMap: 3
> i = 5
> HashMap: 5
> LinkedHashMap: 5
> ConcurrentSkipListMap: 5
> ConcurrentHashMap: 5
> i = 6
> HashMap: 8
> LinkedHashMap: 8
> ConcurrentSkipListMap: 8
> ConcurrentHashMap: 8
> i = 7
> HashMap: 13
> LinkedHashMap: 13
> ConcurrentSkipListMap: 13
> ConcurrentHashMap: 13
> i = 8
> HashMap: 21
> LinkedHashMap: 21
> ConcurrentSkipListMap: 21
> ConcurrentHashMap: 21
> i = 9
> HashMap: 34
> LinkedHashMap: 34
> ConcurrentSkipListMap: 34
> ConcurrentHashMap: 34
> i = 10
> HashMap: 55
> LinkedHashMap: 55
> ConcurrentSkipListMap: 55
> ConcurrentHashMap: 55
> i = 11
> HashMap: 89
> LinkedHashMap: 89
> ConcurrentSkipListMap: 89
> ConcurrentHashMap: 89
> i = 12
> HashMap: 144
> LinkedHashMap: 144
> ConcurrentSkipListMap: 144
> 2016-04-19 11:08:49
> Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.74-b02 mixed mode):
> *snip*
>
> "main" #1 prio=5 os_prio=31 tid=0x00007f81e3801000 nid=0x1703 runnable
> [0x0000700000219000]
>   java.lang.Thread.State: RUNNABLE
>        at
> java.util.concurrent.ConcurrentHashMap.transfer(ConcurrentHashMap.java:2497)
>        at
> java.util.concurrent.ConcurrentHashMap.addCount(ConcurrentHashMap.java:2288)
>        at
> java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1720)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.lambda$f$0(WeirdComputeIfAbsentBehaviour.java:35)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached$$Lambda$1/1831932724.apply(Unknown
> Source)
>        at
> java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660)
>        - locked <0x000000076ae88b50> (a
> java.util.concurrent.ConcurrentHashMap$ReservationNode)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour.show(WeirdComputeIfAbsentBehaviour.java:21)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour.main(WeirdComputeIfAbsentBehaviour.java:15)
>
> Oh and it doesn't even get that far with Java 9 (my VarHandle build from
> last month), because HashMap dies when i=3:
>
> openjdk version "9-internal"
> OpenJDK Runtime Environment (build
> 9-internal+0-2016-03-02-185127.heinz.sandbox)
> OpenJDK 64-Bit Server VM (build
> 9-internal+0-2016-03-02-185127.heinz.sandbox, mixed mode)
>
> i = 0
> HashMap: 0
> LinkedHashMap: 0
> ConcurrentSkipListMap: 0
> ConcurrentHashMap: 0
> i = 1
> HashMap: 1
> LinkedHashMap: 1
> ConcurrentSkipListMap: 1
> ConcurrentHashMap: 1
> i = 2
> HashMap: 1
> LinkedHashMap: 1
> ConcurrentSkipListMap: 1
> ConcurrentHashMap: 1
> i = 3
> Exception in thread "main" java.util.ConcurrentModificationException
>        at java.util.HashMap.computeIfAbsent(HashMap.java:1138)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour$FibonacciCached.f(WeirdComputeIfAbsentBehaviour.java:35)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour.show(WeirdComputeIfAbsentBehaviour.java:21)
>        at
> samples.ch15.WeirdComputeIfAbsentBehaviour.main(WeirdComputeIfAbsentBehaviour.java:12)
>
> Regards
>
> Heinz
> --
> Dr Heinz M. Kabutz (PhD CompSci)
> Author of "The Java(tm) Specialists' Newsletter"
> Sun/Oracle Java Champion since 2005
> JavaOne Rock Star Speaker 2012
> http://www.javaspecialists.eu
> Tel: +30 69 75 595 262
> Skype: kabutz
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160419/8cdd0962/attachment.html>

From heinz at javaspecialists.eu  Tue Apr 19 05:35:52 2016
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 19 Apr 2016 12:35:52 +0300
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
Message-ID: <5715FBF8.80307@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160419/a6ce8774/attachment-0001.html>

From dl at cs.oswego.edu  Tue Apr 19 07:40:29 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 19 Apr 2016 07:40:29 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <5715FBF8.80307@javaspecialists.eu>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu>
Message-ID: <5716192D.4090601@cs.oswego.edu>

On 04/19/2016 05:35 AM, Dr Heinz M. Kabutz wrote:
>  I don't see anything in the
> Map.computeIfAbsent() JavaDoc contract that would make my code invalid.  I guess
> inside ConcurrentHashMap there is a clause of "so the computation should be
> short and simple, *and must not attempt to update any other mappings of this
> map*."

You are right that something should be said in ConcurrentMap and/or Map,
not just ConcurrentHashMap.

In any concurrent context, a computeIfAbsent function with side effects
that that modify map entries (including especially the initially absent one)
may be subject to livelock, deadlock, and/or exceptions.
An exception is the nicest of these options. So as Ben mentioned, we
updated to do so when possible.

Similar issues can arise even in non-concurrent settings when the
side-effecting operations on other map entries throw exceptions
or cause the initially-absent entry not to be absent.

-Doug



From aph at redhat.com  Tue Apr 19 10:00:50 2016
From: aph at redhat.com (Andrew Haley)
Date: Tue, 19 Apr 2016 15:00:50 +0100
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <5716192D.4090601@cs.oswego.edu>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
Message-ID: <57163A12.4070702@redhat.com>

On 04/19/2016 12:40 PM, Doug Lea wrote:
> On 04/19/2016 05:35 AM, Dr Heinz M. Kabutz wrote:
>>  I don't see anything in the
>> Map.computeIfAbsent() JavaDoc contract that would make my code invalid.  I guess
>> inside ConcurrentHashMap there is a clause of "so the computation should be
>> short and simple, *and must not attempt to update any other mappings of this
>> map*."
> 
> You are right that something should be said in ConcurrentMap and/or Map,
> not just ConcurrentHashMap.
> 
> In any concurrent context, a computeIfAbsent function with side effects
> that that modify map entries (including especially the initially absent one)
> may be subject to livelock, deadlock, and/or exceptions.
> An exception is the nicest of these options. So as Ben mentioned, we
> updated to do so when possible.
> 
> Similar issues can arise even in non-concurrent settings when the
> side-effecting operations on other map entries throw exceptions
> or cause the initially-absent entry not to be absent.

And indeed if you're trying to memoize a (possibly) recursive
function.  You end up having to do something like this:

    static <T, R> Function<T, R> memoize(Function<T, R> f) {
        HashMap<T, R> values = new HashMap<>();
        return t -> {
            R result = values.get(t);
            if (result == null) {
                result = f.apply(t);
                values.put(t, result);
            }
            return result;
        };
    }

computeIfAbsent() would be very nice here, but you can't use it.

Andrew.

From alarmnummer at gmail.com  Wed Apr 20 06:05:09 2016
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 20 Apr 2016 13:05:09 +0300
Subject: [concurrency-interest] deadline and long overflow
Message-ID: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>

I have a question regarding dealing with deadlines and long overflow.

For example the following from the SynchronousQueue:

final long deadline = timed ? System.nanoTime() + nanos : 0L;

What would happen if someone calls queue.offer(item, Long.MAX_VALUE, NANOS)
then deadline overflows and becomes negative. I see the same approach in
other parts e.g.

this.deadline = timed ? System.nanoTime() + nanos : 0L;

from the Phaser. Personally I like the simplicity; but my concern is
regarding validity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/adf6d70e/attachment.html>

From davidcholmes at aapt.net.au  Wed Apr 20 06:22:15 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 20 Apr 2016 20:22:15 +1000
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
Message-ID: <007701d19aee$839db5e0$8ad921a0$@aapt.net.au>

Hi Peter,

 

Doesn?t this ?self-correct? when we do

 

nanos = deadline - System.nanoTime();

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Peter Veentjer
Sent: Wednesday, April 20, 2016 8:05 PM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] deadline and long overflow

 

I have a question regarding dealing with deadlines and long overflow.

For example the following from the SynchronousQueue:

final long deadline = timed ? System.nanoTime() + nanos : 0L;

What would happen if someone calls queue.offer(item, Long.MAX_VALUE, NANOS) then deadline overflows and becomes negative. I see the same approach in other parts e.g. 

this.deadline = timed ? System.nanoTime() + nanos : 0L;

from the Phaser. Personally I like the simplicity; but my concern is regarding validity.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/052e27d7/attachment.html>

From oleksandr.otenko at gmail.com  Wed Apr 20 06:32:26 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Wed, 20 Apr 2016 11:32:26 +0100
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
Message-ID: <8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>

Wouldn?t that be a deadline of 500-odd years?

Technically, overflow is a possibility. Practically - very unlikely.

Alex

> On 20 Apr 2016, at 11:05, Peter Veentjer <alarmnummer at gmail.com> wrote:
> 
> I have a question regarding dealing with deadlines and long overflow.
> 
> For example the following from the SynchronousQueue:
> 
> final long deadline = timed ? System.nanoTime() + nanos : 0L;
> What would happen if someone calls queue.offer(item, Long.MAX_VALUE, NANOS) then deadline overflows and becomes negative. I see the same approach in other parts e.g. 
> 
> this.deadline = timed ? System.nanoTime() + nanos : 0L;
> from the Phaser. Personally I like the simplicity; but my concern is regarding validity.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/fda59992/attachment.html>

From Volker.Borchert at atis-systems.com  Wed Apr 20 08:01:49 2016
From: Volker.Borchert at atis-systems.com (Volker.Borchert at atis-systems.com)
Date: Wed, 20 Apr 2016 12:01:49 +0000
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
Message-ID: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>

Sorry if this is inappropiate here...

I'm just browsing 1.8.0_92 release notes and the following question arose.

http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/ce72c7641f38 states

+     * <p>It is also imperative that implementations read the field only once,
+     * as in:
+     *
+     * <pre> {@code
+     * public Set<K> keySet() {
+     *   Set<K> ks = keySet;  // single racy read
+     *   if (ks == null) {
+     *     ks = new KeySet();
+     *     keySet = ks;
+     *   }
+     *   return ks;
+     * }
+     *}</pre>

and changed

--- a/src/java.base/share/classes/java/util/TreeMap.java	Thu Dec 17 20:42:01 2015 +0300
+++ b/src/java.base/share/classes/java/util/TreeMap.java	Thu Dec 17 21:14:58 2015 +0300
@@ -852,7 +852,11 @@
      */
     public Collection<V> values() {
         Collection<V> vs = values;
-        return (vs != null) ? vs : (values = new Values());
+        if (vs == null) {
+            vs = new Values();
+            values = vs;
+        }
+        return vs;
     }
 
     /**

but

    public NavigableSet<K> navigableKeySet() {
        KeySet<K> nks = navigableKeySet;
        return (nks != null) ? nks : (navigableKeySet = new KeySet<>(this));
    }

remained unchanged, with navigableKeySet also non-volatile, so I'd think
the comment above would apply. (Similar for entrySet() and descendingMap().)

What am I missing?

	vb

////////////////////////////////////////////////////////////////////

ATIS systems GmbH 
Sitz: Bad Homburg 
Registergericht: Bad Homburg HRB 1514 
Geschaeftsfuehrer: Stefan Diepolder, Daniel Sieh
 
________________________________________________________________________________________________

This message is confidential. It may also be privileged or otherwise protected by work product immunity or other legal rules. If you have received this message by mistake please let us know by reply and then delete it from your system; you should not copy it or disclose its contents to anyone. All messages sent to and from ATIS systems GmbH may be monitored to ensure compliance with internal policies and to protect our business. E-Mails are not secure and cannot be guaranteed to be error free as they can be intercepted, amended, lost or destroyed. Anyone who communicates with us by e-mail is taken to accept these risks.





From dl at cs.oswego.edu  Wed Apr 20 08:27:08 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 20 Apr 2016 08:27:08 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
Message-ID: <5717759C.1010100@cs.oswego.edu>

On 04/19/2016 11:43 AM, Per Mildner wrote:

>> In any concurrent context, a computeIfAbsent function with side effects
>> that that modify map entries (including especially the initially absent one)
>
> The documentation seems to explicitly exclude the initially absent map entry from the prohibited entries by saying "the computation ? must not attempt to update any _other_ mappings?.
>
> Should this say "the computation ? must not attempt to update any mappings??

Yes. The wording implicitly assumed that readers already knew not to
modify the key's mapping.

In any case, this is already partially covered in the Map javadocs:
http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-
      * <p>The mapping function should not modify this map during computation.

We could add something saying what might happen otherwise:
      * If it does so, the results of this operation are undefined, but may
      * include IllegalStateExceptions, or in concurrent contexts, deadlock
      * or livelock.
      *

-Doug





From dl at cs.oswego.edu  Wed Apr 20 08:52:03 2016
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 20 Apr 2016 08:52:03 -0400
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
Message-ID: <57177B73.2020508@cs.oswego.edu>

On 04/20/2016 06:32 AM, Alex Otenko wrote:
> Wouldn?t that be a deadline of 500-odd years?

Overflow issues can occur in half that time though (around 292 years).

>
> Technically, overflow is a possibility. Practically - very unlikely.
>

Right. There is a disclaimer about this in System.nanotime:
http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--

This could be repeated in every timing-related method, but isn't.

-Doug

> Alex
>
>> On 20 Apr 2016, at 11:05, Peter Veentjer <alarmnummer at gmail.com
>> <mailto:alarmnummer at gmail.com>> wrote:
>>
>> I have a question regarding dealing with deadlines and long overflow.
>>
>> For example the following from the SynchronousQueue:
>>
>> final long deadline = timed ? System.nanoTime() + nanos :0L;
>> What would happen if someone calls queue.offer(item, Long.MAX_VALUE, NANOS)
>> then deadline overflows and becomes negative. I see the same approach in other
>> parts e.g.
>>
>> this.deadline = timed ? System.nanoTime() + nanos :0L;
>> from the Phaser. Personally I like the simplicity; but my concern is regarding
>> validity.
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>




From aleksey.shipilev at oracle.com  Wed Apr 20 09:10:53 2016
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 20 Apr 2016 16:10:53 +0300
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
Message-ID: <57177FDD.1080101@oracle.com>

On 04/20/2016 03:01 PM, Volker.Borchert at atis-systems.com wrote:
> I'm just browsing 1.8.0_92 release notes and the following question arose.
> 
> http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/ce72c7641f38 states

...

> but
> 
>     public NavigableSet<K> navigableKeySet() {
>         KeySet<K> nks = navigableKeySet;
>         return (nks != null) ? nks : (navigableKeySet = new KeySet<>(this));
>     }
> 
> remained unchanged, with navigableKeySet also non-volatile, so I'd think
> the comment above would apply. (Similar for entrySet() and descendingMap().)
> 
> What am I missing?

The block in navigableKeySet() is semantically the same as suggested in
the Javadoc: it reads the non-volatile $navigableKeySet exactly once.
The patch changed keySet() and values() that were doing two racy reads.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/c0146e39/attachment.bin>

From Volker.Borchert at atis-systems.com  Wed Apr 20 09:50:37 2016
From: Volker.Borchert at atis-systems.com (Volker.Borchert at atis-systems.com)
Date: Wed, 20 Apr 2016 13:50:37 +0000
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
Message-ID: <9DD392344AED044287E42246402FDAB47C35870A@max.atis-systems.com>

> The block in navigableKeySet() is semantically the same as suggested in
> the Javadoc: it reads the non-volatile $navigableKeySet exactly once.

Sorry, I can't see the difference between

	KeySet<K> nks = navigableKeySet;
	return (nks != null) ? nks : (navigableKeySet = new KeySet<>(this));

and

	NavigableMap<K, V> km = descendingMap;
	return (km != null) ? km : (descendingMap = new DescendingSubMap<>(this, ...));

and

	EntrySet es = entrySet;
	return (es != null) ? es : (entrySet = new EntrySet());

and

	Collection<V> vs = values;
	return (vs != null) ? vs : (values = new Values());

but only the last one was changed. Am I just routine-blinded?

> The patch changed keySet() and values() that were doing two racy reads.

TreeMap.keySet() delegates to navigableKeySet() so the patch to AbstractMap
won't affect it.

Regards

	vb

////////////////////////////////////////////////////////////////////

ATIS systems GmbH 
Sitz: Bad Homburg 
Registergericht: Bad Homburg HRB 1514 
Geschaeftsfuehrer: Stefan Diepolder, Daniel Sieh
 
________________________________________________________________________________________________

This message is confidential. It may also be privileged or otherwise protected by work product immunity or other legal rules. If you have received this message by mistake please let us know by reply and then delete it from your system; you should not copy it or disclose its contents to anyone. All messages sent to and from ATIS systems GmbH may be monitored to ensure compliance with internal policies and to protect our business. E-Mails are not secure and cannot be guaranteed to be error free as they can be intercepted, amended, lost or destroyed. Anyone who communicates with us by e-mail is taken to accept these risks.





From alarmnummer at gmail.com  Wed Apr 20 09:57:43 2016
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 20 Apr 2016 16:57:43 +0300
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <57177B73.2020508@cs.oswego.edu>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
Message-ID: <CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>

Thanks for the replies.

The question is not about waiting given amount of time; but the calculation
of the deadline itself which can become negative due to overflow. So
imagine you call:

queue.poll(Long.MAX_VALUE, NANOS)

then the deadline will be < 0 due to overflow.

The question is if it can happen that a blocking call fails with a timeout,
perhaps immediately due to this deadline becoming negative. I made some
small examples and it seems to self correct like David suggested but it
feels a bit funny.



On Wed, Apr 20, 2016 at 3:52 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 04/20/2016 06:32 AM, Alex Otenko wrote:
>
>> Wouldn?t that be a deadline of 500-odd years?
>>
>
> Overflow issues can occur in half that time though (around 292 years).
>
>
>> Technically, overflow is a possibility. Practically - very unlikely.
>>
>>
> Right. There is a disclaimer about this in System.nanotime:
> http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--
>
> This could be repeated in every timing-related method, but isn't.
>
> -Doug
>
> Alex
>>
>> On 20 Apr 2016, at 11:05, Peter Veentjer <alarmnummer at gmail.com
>>> <mailto:alarmnummer at gmail.com>> wrote:
>>>
>>> I have a question regarding dealing with deadlines and long overflow.
>>>
>>> For example the following from the SynchronousQueue:
>>>
>>> final long deadline = timed ? System.nanoTime() + nanos :0L;
>>> What would happen if someone calls queue.offer(item, Long.MAX_VALUE,
>>> NANOS)
>>> then deadline overflows and becomes negative. I see the same approach in
>>> other
>>> parts e.g.
>>>
>>> this.deadline = timed ? System.nanoTime() + nanos :0L;
>>> from the Phaser. Personally I like the simplicity; but my concern is
>>> regarding
>>> validity.
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:
>>> Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/a88c9eb9/attachment.html>

From aleksey.shipilev at oracle.com  Wed Apr 20 10:25:04 2016
From: aleksey.shipilev at oracle.com (Aleksey Shipilev)
Date: Wed, 20 Apr 2016 17:25:04 +0300
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <9DD392344AED044287E42246402FDAB47C35870A@max.atis-systems.com>
References: <9DD392344AED044287E42246402FDAB47C35870A@max.atis-systems.com>
Message-ID: <57179140.5090209@oracle.com>

On 04/20/2016 04:50 PM, Volker.Borchert at atis-systems.com wrote:
>> The block in navigableKeySet() is semantically the same as suggested in
>> the Javadoc: it reads the non-volatile $navigableKeySet exactly once.

...

> but only the last one was changed. Am I just routine-blinded?
> 
>> The patch changed keySet() and values() that were doing two racy reads.
> 
> TreeMap.keySet() delegates to navigableKeySet() so the patch to AbstractMap
> won't affect it.

Sorry, I should have meant AbstractMap.keySet() and values(). Those were
broken under non-volatile keySet/values fields.

Others were merely a style/readability rewrites to match the suggested
use: avoiding inline assignments makes reasoning about load/stores
easier. We are quite probably missing those style tuneups in other
places, but this does not affect correctness.

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160420/d7f7502c/attachment.bin>

From martinrb at google.com  Wed Apr 20 12:25:39 2016
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 20 Apr 2016 09:25:39 -0700
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
Message-ID: <CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>

On Wed, Apr 20, 2016 at 6:57 AM, Peter Veentjer <alarmnummer at gmail.com> wrote:
> Thanks for the replies.
>
> The question is not about waiting given amount of time; but the calculation
> of the deadline itself which can become negative due to overflow. So imagine
> you call:
>
> queue.poll(Long.MAX_VALUE, NANOS)
>
> then the deadline will be < 0 due to overflow.
>
> The question is if it can happen that a blocking call fails with a timeout,
> perhaps immediately due to this deadline becoming negative. I made some
> small examples and it seems to self correct like David suggested but it
> feels a bit funny.

All of the time handling code in j.u.concurrent is overflow-aware.
It's not really overflow, it's "wraparound".  It's safe because it's
java, not C.  As long as all of the code that handles nanotime values
follows the advice in the javadoc
https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--
everything is fine.

To compare two nanoTime values


 long t0 = System.nanoTime();
 ...
 long t1 = System.nanoTime();
one should use t1 - t0 < 0, not t1 < t0, because of the possibility of
numerical overflow.

It's hard to test that we haven't made a mistake somewhere, though.

From jsampson at guidewire.com  Wed Apr 20 15:26:51 2016
From: jsampson at guidewire.com (Justin Sampson)
Date: Wed, 20 Apr 2016 19:26:51 +0000
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
	<CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
Message-ID: <DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>

Peter, I had exactly the same funny feeling as you when I first saw
this idiom. A few years back, Martin changed some of my timing code
in Guava's Monitor class from something like this:

  long timeoutNanos = unit.toNanos(time);
  long startNanos = System.nanoTime();
  ...
  long remainingNanos =
      timeoutNanos - (System.nanoTime() - startNanos);

to something like this:

  long timeoutNanos = unit.toNanos(time);
  long deadline = System.nanoTime() + timeoutNanos;
  ...
  long remainingNanos = deadline - System.nanoTime();

At first I thought that this would introduce some kind of overflow
error with MAX_VALUE, but I wrote a unit test for it and it passed!
Only then did I realize that these two constructs are exactly
identical in runtime behavior due to the arithmetic wraparound of
long values. Any overflow bugs triggered by one would have been
triggered by the other just as well.

(For anyone who thinks MAX_VALUE isn't interesting because it's a
centuries-long timeout, consider someone passing MAX_VALUE into an
API with the intention of "actually, don't timeout this call." If
there were an arithmetic overflow bug that caused it to, say,
timeout immediately instead of never, that would be a very
noticeable and reproducible issue.)

Now, that's not quite the end of the story. It turns out that
there's no overflow bug for MAX_VALUE as long as nanoTime() actually
progresses forward, but there IS an overflow bug for MIN_VALUE, and
there IS an overflow bug for MAX_VALUE if nanoTime() ever goes
backward.

For the MIN_VALUE case, consider for simplicity that the first call
to nanoTime() returns 0 and the second call returns 1. Then with
either of the constructs above, remainingNanos ends up equal to
MIN_VALUE-1, which is actually MAX_VALUE. Without additional guard
clauses, that could result in blocking forever rather than not at
all, which is what MIN_VALUE should mean (as with any non-positive
timeout). The fix is simply to check for time <= 0 before doing any
of these calculations, but this bug has actually slipped into the
some parts of the JDK before -- and all my testing and agonizing
over Martin's change in Guava helped find and fix one or two such
cases in the JDK! :)

For the MAX_VALUE case, there's only an overflow bug if nanoTime()
goes backward, causing some negative value to be subtracted from
MAX_VALUE in the code above. That should never happen in HotSpot,
but there have been occasional bugs and experimental "optimizations"
in other JVMs that allow it to be seen. JDK code is NOT written to
be robust to that possibility, which would slightly complicate the
code everywhere that a timeout is checked.

There is ONE remaining overflow situation that we really can't do
anything about: When the elapsed time between two calls to
nanoTime() actually exceeds 2^63-1. I'm personally willing to ignore
that one!

Cheers,
Justin


From martinrb at google.com  Wed Apr 20 15:35:04 2016
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 20 Apr 2016 12:35:04 -0700
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
	<CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
	<DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
Message-ID: <CA+kOe09aRs3Rf5S0QxcKFrnaEqoDZY81b1U54qV+pFup_7rKPg@mail.gmail.com>

On Wed, Apr 20, 2016 at 12:26 PM, Justin Sampson <jsampson at guidewire.com> wrote:
> For the MAX_VALUE case, there's only an overflow bug if nanoTime()
> goes backward, causing some negative value to be subtracted from
> MAX_VALUE in the code above. That should never happen in HotSpot,
> but there have been occasional bugs and experimental "optimizations"
> in other JVMs that allow it to be seen. JDK code is NOT written to
> be robust to that possibility, which would slightly complicate the
> code everywhere that a timeout is checked.

While JDK implementations are required to provide nanoTime
monotonicity, it is an onerous requirement and so relying on it is a
kind of stress test for VM implementers.  If I was writing application
code with "forever" timeouts, I would use MAX_VALUE/2 NANOSECONDS
which is still "forever enough".  We once investigated what it would
take to make jsr166 code robust against nanoTime occasionally going
backwards (invariably with MIN_VALUE or MAX_VALUE nanos), and the
changes required were too invasive (and untestable!)

From Volker.Borchert at atis-systems.com  Thu Apr 21 03:30:33 2016
From: Volker.Borchert at atis-systems.com (Volker.Borchert at atis-systems.com)
Date: Thu, 21 Apr 2016 07:30:33 +0000
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
Message-ID: <9DD392344AED044287E42246402FDAB47C35873D@max.atis-systems.com>

> Sorry, I should have meant AbstractMap.keySet() and values(). Those were
> broken under non-volatile keySet/values fields.
> 
> Others were merely a style/readability rewrites to match the suggested
> use: avoiding inline assignments makes reasoning about load/stores
> easier. We are quite probably missing those style tuneups in other
> places, but this does not affect correctness.

(browse 1.8.0_77 source)

I see. Thank you.

	vb

////////////////////////////////////////////////////////////////////

ATIS systems GmbH 
Sitz: Bad Homburg 
Registergericht: Bad Homburg HRB 1514 
Geschaeftsfuehrer: Stefan Diepolder, Daniel Sieh
 
________________________________________________________________________________________________

This message is confidential. It may also be privileged or otherwise protected by work product immunity or other legal rules. If you have received this message by mistake please let us know by reply and then delete it from your system; you should not copy it or disclose its contents to anyone. All messages sent to and from ATIS systems GmbH may be monitored to ensure compliance with internal policies and to protect our business. E-Mails are not secure and cannot be guaranteed to be error free as they can be intercepted, amended, lost or destroyed. Anyone who communicates with us by e-mail is taken to accept these risks.





From daniel.tetlow at optasense.com  Thu Apr 21 07:59:12 2016
From: daniel.tetlow at optasense.com (Daniel Tetlow)
Date: Thu, 21 Apr 2016 11:59:12 +0000
Subject: [concurrency-interest] Waiting for a cancelled Future
Message-ID: <DB4PR04MB3948E50FEBE24CB5745E519E56E0@DB4PR04MB394.eurprd04.prod.outlook.com>

Hi,

When I submit a task to one of the standard JDK ExecutorServices, I get a Future that represents the asynchronous execution of that task.

If I cancel the task before it gets executed, then of course Future.get() returns immediately as there is no asynchronous execution to wait for.

If I try to cancel the task while it is executing, what surprises me is that Future.get() still returns immediately even if the task is still actually running. So it appears that upon cancellation, the future becomes detached from the asynchronous execution state of the task. It may be that the task does not cancel gracefully, or that the task needs to do some cleanup on its cancellation path that takes time. In any case, if a task is executing by the time I cancel it, I'd still like to wait for it to finish before proceeding.

I have tried putting my own execution status on the actual Runnable/Callable that I submit to the executor, so I can check that separately. But this seems wrong to me because I end up duplicating status already known by the FutureTask, and this is likely also prone to race conditions.

How should I handle this, or am I doing something wrong to get into this state in the first place?


Thanks for your comments,

Dan.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160421/ce768cb1/attachment-0001.html>

From ppozerov at gmail.com  Thu Apr 21 08:36:22 2016
From: ppozerov at gmail.com (Vladimir Ozerov)
Date: Thu, 21 Apr 2016 15:36:22 +0300
Subject: [concurrency-interest] Waiting for a cancelled Future
In-Reply-To: <CAJJmzpWpA3ci_1Jfw3odNTQw2Q-13nMhLWic1JnaOnQ4RcFU7w@mail.gmail.com>
References: <DB4PR04MB3948E50FEBE24CB5745E519E56E0@DB4PR04MB394.eurprd04.prod.outlook.com>
	<CAJJmzpUvzqLShDLY9+_s9KfJvEiCQJU5308L8c1OXyNktzsKcw@mail.gmail.com>
	<CAJJmzpWpA3ci_1Jfw3odNTQw2Q-13nMhLWic1JnaOnQ4RcFU7w@mail.gmail.com>
Message-ID: <CAJJmzpXDihEQ0rSCcBg=CJ1Wc4KywhsypRaitLCDtfGNsZkH6g@mail.gmail.com>

Hi Dan,

This is an interesting question. Some frameworks which have their own
"futures" has the same semantics as you described - they still wait for
computation to complete. And both approaches could make sense.

However, future.get() is essentially about result, not about thread or
computation state. When future is cancelled, result is known immediately,
and there is no reason to block waiters any further. So immediate return
makes perfect sense to me in this case.

Vladimir.
21 ???. 2016 ?. 15:09 ???????????? "Daniel Tetlow" <
daniel.tetlow at optasense.com> ???????:

Hi,



When I submit a task to one of the standard JDK ExecutorServices, I get a
Future that represents the asynchronous execution of that task.



If I cancel the task before it gets executed, then of course Future.get()
returns immediately as there is no asynchronous execution to wait for.



If I try to cancel the task while it is executing, what surprises me is
that Future.get() still returns immediately even if the task is still
actually running. So it appears that upon cancellation, the future becomes
detached from the asynchronous execution state of the task. It may be that
the task does not cancel gracefully, or that the task needs to do some
cleanup on its cancellation path that takes time. In any case, if a task is
executing by the time I cancel it, I?d still like to wait for it to finish
before proceeding.



I have tried putting my own execution status on the actual
Runnable/Callable that I submit to the executor, so I can check that
separately. But this seems wrong to me because I end up duplicating status
already known by the FutureTask, and this is likely also prone to race
conditions.



How should I handle this, or am I doing something wrong to get into this
state in the first place?





Thanks for your comments,



Dan.



_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160421/f14b28c4/attachment.html>

From Sebastian.Millies at softwareag.com  Thu Apr 21 10:13:50 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Thu, 21 Apr 2016 14:13:50 +0000
Subject: [concurrency-interest] Waiting for a cancelled Future
In-Reply-To: <CAJJmzpXDihEQ0rSCcBg=CJ1Wc4KywhsypRaitLCDtfGNsZkH6g@mail.gmail.com>
References: <DB4PR04MB3948E50FEBE24CB5745E519E56E0@DB4PR04MB394.eurprd04.prod.outlook.com>
	<CAJJmzpUvzqLShDLY9+_s9KfJvEiCQJU5308L8c1OXyNktzsKcw@mail.gmail.com>
	<CAJJmzpWpA3ci_1Jfw3odNTQw2Q-13nMhLWic1JnaOnQ4RcFU7w@mail.gmail.com>
	<CAJJmzpXDihEQ0rSCcBg=CJ1Wc4KywhsypRaitLCDtfGNsZkH6g@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E5714F@HQMBX5.eur.ad.sag>

I agree with Vladimir. Cancel says you don?t care about the result, so why should one wait for a task to produce something one doesn?t need?
If a task cannot be cancelled gracefully, as you say, it should just refuse to be cancelled and do nothing in the cancel() method but return false.

However, in case you really want it, couldn?t you do the following? Submit a task for execution that would release a Semaphore when it is finished. Produce a second future from the original one that would try to acquire that same semaphore before completing. Calling get() on that second future would block while the cancelled task is still running. Both parts of this approach could be encapsulated in a single utility method.


n  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Vladimir Ozerov
Sent: Thursday, April 21, 2016 2:36 PM
To: Daniel Tetlow
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Waiting for a cancelled Future


Hi Dan,

This is an interesting question. Some frameworks which have their own "futures" has the same semantics as you described - they still wait for computation to complete. And both approaches could make sense.

However, future.get() is essentially about result, not about thread or computation state. When future is cancelled, result is known immediately, and there is no reason to block waiters any further. So immediate return makes perfect sense to me in this case.

Vladimir.
21 ???. 2016 ?. 15:09 ???????????? "Daniel Tetlow" <daniel.tetlow at optasense.com<mailto:daniel.tetlow at optasense.com>> ???????:
Hi,

When I submit a task to one of the standard JDK ExecutorServices, I get a Future that represents the asynchronous execution of that task.

If I cancel the task before it gets executed, then of course Future.get() returns immediately as there is no asynchronous execution to wait for.

If I try to cancel the task while it is executing, what surprises me is that Future.get() still returns immediately even if the task is still actually running. So it appears that upon cancellation, the future becomes detached from the asynchronous execution state of the task. It may be that the task does not cancel gracefully, or that the task needs to do some cleanup on its cancellation path that takes time. In any case, if a task is executing by the time I cancel it, I?d still like to wait for it to finish before proceeding.

I have tried putting my own execution status on the actual Runnable/Callable that I submit to the executor, so I can check that separately. But this seems wrong to me because I end up duplicating status already known by the FutureTask, and this is likely also prone to race conditions.

How should I handle this, or am I doing something wrong to get into this state in the first place?


Thanks for your comments,

Dan.


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160421/c2805f1e/attachment-0001.html>

From viktor.klang at gmail.com  Fri Apr 22 03:22:41 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 22 Apr 2016 09:22:41 +0200
Subject: [concurrency-interest] Waiting for a cancelled Future
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E5714F@HQMBX5.eur.ad.sag>
References: <DB4PR04MB3948E50FEBE24CB5745E519E56E0@DB4PR04MB394.eurprd04.prod.outlook.com>
	<CAJJmzpUvzqLShDLY9+_s9KfJvEiCQJU5308L8c1OXyNktzsKcw@mail.gmail.com>
	<CAJJmzpWpA3ci_1Jfw3odNTQw2Q-13nMhLWic1JnaOnQ4RcFU7w@mail.gmail.com>
	<CAJJmzpXDihEQ0rSCcBg=CJ1Wc4KywhsypRaitLCDtfGNsZkH6g@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E5714F@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU-TYV0XHvB8eUwF20spbxQjc29Mckyo6sO4HWE+yo_bUw@mail.gmail.com>

I prefer the model where execution control is separate from where the
result may be obtained. Those are two orthogonal concerns, and with
different access control (reading results vs writing the result)

-- 
Cheers,
?
On Apr 21, 2016 4:23 PM, "Millies, Sebastian" <
Sebastian.Millies at softwareag.com> wrote:

> I agree with Vladimir. Cancel says you don?t care about the result, so why
> should one wait for a task to produce something one doesn?t need?
>
> If a task cannot be cancelled gracefully, as you say, it should just
> refuse to be cancelled and do nothing in the cancel() method but return
> false.
>
>
>
> However, in case you really want it, couldn?t you do the following? Submit
> a task for execution that would release a Semaphore when it is finished.
> Produce a second future from the original one that would try to acquire
> that same semaphore before completing. Calling get() on that second future
> would block while the cancelled task is still running. Both parts of this
> approach could be encapsulated in a single utility method.
>
>
>
> n  Sebastian
>
>
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Vladimir Ozerov
> *Sent:* Thursday, April 21, 2016 2:36 PM
> *To:* Daniel Tetlow
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Waiting for a cancelled Future
>
>
>
> Hi Dan,
>
> This is an interesting question. Some frameworks which have their own
> "futures" has the same semantics as you described - they still wait for
> computation to complete. And both approaches could make sense.
>
> However, future.get() is essentially about result, not about thread or
> computation state. When future is cancelled, result is known immediately,
> and there is no reason to block waiters any further. So immediate return
> makes perfect sense to me in this case.
>
> Vladimir.
>
> 21 ???. 2016 ?. 15:09 ???????????? "Daniel Tetlow" <
> daniel.tetlow at optasense.com> ???????:
>
> Hi,
>
>
>
> When I submit a task to one of the standard JDK ExecutorServices, I get a
> Future that represents the asynchronous execution of that task.
>
>
>
> If I cancel the task before it gets executed, then of course Future.get()
> returns immediately as there is no asynchronous execution to wait for.
>
>
>
> If I try to cancel the task while it is executing, what surprises me is
> that Future.get() still returns immediately even if the task is still
> actually running. So it appears that upon cancellation, the future becomes
> detached from the asynchronous execution state of the task. It may be that
> the task does not cancel gracefully, or that the task needs to do some
> cleanup on its cancellation path that takes time. In any case, if a task is
> executing by the time I cancel it, I?d still like to wait for it to finish
> before proceeding.
>
>
>
> I have tried putting my own execution status on the actual
> Runnable/Callable that I submit to the executor, so I can check that
> separately. But this seems wrong to me because I end up duplicating status
> already known by the FutureTask, and this is likely also prone to race
> conditions.
>
>
>
> How should I handle this, or am I doing something wrong to get into this
> state in the first place?
>
>
>
>
>
> Thanks for your comments,
>
>
>
> Dan.
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160422/dfbf42aa/attachment.html>

From viktor.klang at gmail.com  Fri Apr 22 04:37:11 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Fri, 22 Apr 2016 10:37:11 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <5717759C.1010100@cs.oswego.edu>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
Message-ID: <CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>

Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache)
{
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to
parallelize it.
Also means that concurrent readers/writers won't block eachother
(computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache)
{
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2,
e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
e);
    }
  }


-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160422/ae2c22b6/attachment.html>

From alarmnummer at gmail.com  Sat Apr 23 00:32:57 2016
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sat, 23 Apr 2016 07:32:57 +0300
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <CA+kOe09aRs3Rf5S0QxcKFrnaEqoDZY81b1U54qV+pFup_7rKPg@mail.gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
	<CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
	<DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
	<CA+kOe09aRs3Rf5S0QxcKFrnaEqoDZY81b1U54qV+pFup_7rKPg@mail.gmail.com>
Message-ID: <CAGuAWdDD-CA3gE_Y6rJPx94136g1QyA2TT1i4=dcNoSp2NmmzA@mail.gmail.com>

I want to thank all, especially Martin, for their answers.

On Wed, Apr 20, 2016 at 10:35 PM, Martin Buchholz <martinrb at google.com>
wrote:

> On Wed, Apr 20, 2016 at 12:26 PM, Justin Sampson <jsampson at guidewire.com>
> wrote:
> > For the MAX_VALUE case, there's only an overflow bug if nanoTime()
> > goes backward, causing some negative value to be subtracted from
> > MAX_VALUE in the code above. That should never happen in HotSpot,
> > but there have been occasional bugs and experimental "optimizations"
> > in other JVMs that allow it to be seen. JDK code is NOT written to
> > be robust to that possibility, which would slightly complicate the
> > code everywhere that a timeout is checked.
>
> While JDK implementations are required to provide nanoTime
> monotonicity, it is an onerous requirement and so relying on it is a
> kind of stress test for VM implementers.  If I was writing application
> code with "forever" timeouts, I would use MAX_VALUE/2 NANOSECONDS
> which is still "forever enough".  We once investigated what it would
> take to make jsr166 code robust against nanoTime occasionally going
> backwards (invariably with MIN_VALUE or MAX_VALUE nanos), and the
> changes required were too invasive (and untestable!)
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160423/2acaa60b/attachment.html>

From heinz at javaspecialists.eu  Sat Apr 23 01:30:44 2016
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Sat, 23 Apr 2016 08:30:44 +0300
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>	<5715FBF8.80307@javaspecialists.eu>
	<5716192D.4090601@cs.oswego.edu>	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
Message-ID: <571B0884.1010706@javaspecialists.eu>

An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160423/e61ab66c/attachment.html>

From Sebastian.Millies at softwareag.com  Sat Apr 23 06:50:58 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Sat, 23 Apr 2016 10:50:58 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <571B0884.1010706@javaspecialists.eu>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu>	<5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>

I?m not sure I?m getting it. What?s significant about putting that empty CF in as a placeholder first? That is, what is the advantage over writing

public CompletionStage<BigInteger> f(int n) {
  CompletionStage<BigInteger> prev = cache.get(n);
  if (prev != null) {
    return prev;
  }
  else {
    return f(n - 1).thenCompose(x ->
           f(n - 2).thenCompose(y -> {
           CompletableFuture<BigInteger> next = CompletableFuture.completedFuture(x.add(y));
           CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
           return prev != null ? v : next;
    }));
  }
}

Is it that in Viktor?s code, only the thread that first has a cache miss calls the computation that will complete the future, while in the above code there may be multiple computations, only one of which will eventually contribute to the result? And would that consideration only apply to the async version?


n  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Dr Heinz M. Kabutz
Sent: Saturday, April 23, 2016 7:31 AM
To: Viktor Klang
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks so much Viktor for that code!  The part that I somehow missed was the empty CompletableFuture: CompletableFuture<BigInteger> next = new CompletableFuture<>();

Very interesting indeed.


Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun/Oracle Java Champion since 2005

JavaOne Rock Star Speaker 2012

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz


Viktor Klang wrote:
Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> { next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to parallelize it.
Also means that concurrent readers/writers won't block eachother (computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e), e);
    }
  }


--
Cheers,
?



________________________________



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160423/849f2c72/attachment-0001.html>

From viktor.klang at gmail.com  Sat Apr 23 15:45:03 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sat, 23 Apr 2016 21:45:03 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>

Hi Sebastian,

I only provided the code as an alternate solution to using computeIfAbsent,
for a more ?optimized?[1] version, see the snippet below.

If / when CHM becomes completely non-blocking, this would mean that readers
would never block other readers nor other writers, and writers would never
block readers or other writers.

package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache)
{
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletionStage<BigInteger> ret = cache.get(n);
      if (ret == null) {
        final CompletableFuture<BigInteger> compute = new
CompletableFuture<>();
        ret = cache.putIfAbsent(n, compute);
        if (ret == null)
          ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
e), e);
      }
      return ret;
    }
  }

1: It's very much possible and recommended to not make the first
thenCompose an async one, as only the addition of v and v2 might be
"expensive" (for large additions).

On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> I?m not sure I?m getting it. What?s significant about putting that empty
> CF in as a placeholder first? That is, what is the advantage over writing
>
>
>
> public CompletionStage<BigInteger> f(int n) {
>
>   CompletionStage<BigInteger> prev = cache.get(n);
>
>   if (prev != null) {
>
>     return prev;
>
>   }
>
>   else {
>
>     return f(n - 1).thenCompose(x ->
>
>            f(n - 2).thenCompose(y -> {
>
>            CompletableFuture<BigInteger> next =
> CompletableFuture.completedFuture(x.add(y));
>
>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>
>            return prev != null ? v : next;
>
>     }));
>
>   }
>
> }
>
>
>
> Is it that in Viktor?s code, only the thread that first has a cache miss
> calls the computation that will complete the future, while in the above
> code there may be multiple computations, only one of which will eventually
> contribute to the result? And would that consideration only apply to the
> async version?
>
>
>
> n  Sebastian
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dr Heinz M.
> Kabutz
> *Sent:* Saturday, April 23, 2016 7:31 AM
> *To:* Viktor Klang
> *Cc:* concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks so much Viktor for that code!  The part that I somehow missed was
> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
> CompletableFuture<>();
>
> Very interesting indeed.
>
> Regards
>
>
>
> Heinz
>
> --
>
> Dr Heinz M. Kabutz (PhD CompSci)
>
> Author of "The Java(tm) Specialists' Newsletter"
>
> Sun/Oracle Java Champion since 2005
>
> JavaOne Rock Star Speaker 2012
>
> http://www.javaspecialists.eu
>
> Tel: +30 69 75 595 262
>
> Skype: kabutz
>
>
>
> Viktor Klang wrote:
>
> Heinz,
>
> There's also the option of going this route:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
> next.complete(v.add(v2)); return next; }));
>
>     }
>
>   }
>
>
>
>
>
> Add Executor parameter to `f` and switch to thenComposeAsync to be able to
> parallelize it.
>
> Also means that concurrent readers/writers won't block eachother
> (computeIfAbsent would do that for instance)
>
>
>
> ? la:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
> e);
>
>     }
>
>   }
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
>
> ------------------------------
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160423/08c5fafd/attachment.html>

From henri.tremblay at gmail.com  Mon Apr 25 13:01:55 2016
From: henri.tremblay at gmail.com (Henri Tremblay)
Date: Mon, 25 Apr 2016 13:01:55 -0400
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
Message-ID: <CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>

Hi Viktor,

Thanks a lot for those examples. They are crystal clear demonstration of a
nice CompletableFuture usage.

Really nice
Henri

On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com> wrote:

> Hi Sebastian,
>
> I only provided the code as an alternate solution to using
> computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.
>
> If / when CHM becomes completely non-blocking, this would mean that
> readers would never block other readers nor other writers, and writers
> would never block readers or other writers.
>
> package livedemo;
>
>   import java.util.concurrent.*;
>   import java.math.BigInteger;
>   import java.util.Map;
>
>   public class FibonacciCached {
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>       this.cache = cache;
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>     }
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>       CompletionStage<BigInteger> ret = cache.get(n);
>       if (ret == null) {
>         final CompletableFuture<BigInteger> compute = new
> CompletableFuture<>();
>         ret = cache.putIfAbsent(n, compute);
>         if (ret == null)
>           ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
> e), e);
>       }
>       return ret;
>     }
>   }
>
> 1: It's very much possible and recommended to not make the first
> thenCompose an async one, as only the addition of v and v2 might be
> "expensive" (for large additions).
>
> On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
>> I?m not sure I?m getting it. What?s significant about putting that empty
>> CF in as a placeholder first? That is, what is the advantage over writing
>>
>>
>>
>> public CompletionStage<BigInteger> f(int n) {
>>
>>   CompletionStage<BigInteger> prev = cache.get(n);
>>
>>   if (prev != null) {
>>
>>     return prev;
>>
>>   }
>>
>>   else {
>>
>>     return f(n - 1).thenCompose(x ->
>>
>>            f(n - 2).thenCompose(y -> {
>>
>>            CompletableFuture<BigInteger> next =
>> CompletableFuture.completedFuture(x.add(y));
>>
>>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>>
>>            return prev != null ? v : next;
>>
>>     }));
>>
>>   }
>>
>> }
>>
>>
>>
>> Is it that in Viktor?s code, only the thread that first has a cache miss
>> calls the computation that will complete the future, while in the above
>> code there may be multiple computations, only one of which will eventually
>> contribute to the result? And would that consideration only apply to the
>> async version?
>>
>>
>>
>> n  Sebastian
>>
>>
>>
>> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
>> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dr Heinz M.
>> Kabutz
>> *Sent:* Saturday, April 23, 2016 7:31 AM
>> *To:* Viktor Klang
>> *Cc:* concurrency-interest
>> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
>> computeIfAbsent() ?
>>
>>
>>
>> Thanks so much Viktor for that code!  The part that I somehow missed was
>> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
>> CompletableFuture<>();
>>
>> Very interesting indeed.
>>
>> Regards
>>
>>
>>
>> Heinz
>>
>> --
>>
>> Dr Heinz M. Kabutz (PhD CompSci)
>>
>> Author of "The Java(tm) Specialists' Newsletter"
>>
>> Sun/Oracle Java Champion since 2005
>>
>> JavaOne Rock Star Speaker 2012
>>
>> http://www.javaspecialists.eu
>>
>> Tel: +30 69 75 595 262
>>
>> Skype: kabutz
>>
>>
>>
>> Viktor Klang wrote:
>>
>> Heinz,
>>
>> There's also the option of going this route:
>>
>>
>>
>>   package livedemo;
>>
>>
>>
>>   import java.util.concurrent.*;
>>
>>   import java.math.BigInteger;
>>
>>   import java.util.Map;
>>
>>
>>
>>   public class FibonacciCached {
>>
>>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>>
>>
>>
>>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
>> cache) {
>>
>>       this.cache = cache;
>>
>>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>>
>>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>>
>>     }
>>
>>
>>
>>     public CompletionStage<BigInteger> f(int n) {
>>
>>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>>
>>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>>
>>       if (prev != null) return prev;
>>
>>       else
>>
>>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
>> next.complete(v.add(v2)); return next; }));
>>
>>     }
>>
>>   }
>>
>>
>>
>>
>>
>> Add Executor parameter to `f` and switch to thenComposeAsync to be able
>> to parallelize it.
>>
>> Also means that concurrent readers/writers won't block eachother
>> (computeIfAbsent would do that for instance)
>>
>>
>>
>> ? la:
>>
>>
>>
>>   package livedemo;
>>
>>
>>
>>   import java.util.concurrent.*;
>>
>>   import java.math.BigInteger;
>>
>>   import java.util.Map;
>>
>>
>>
>>   public class FibonacciCached {
>>
>>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>>
>>
>>
>>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
>> cache) {
>>
>>       this.cache = cache;
>>
>>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>>
>>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>>
>>     }
>>
>>
>>
>>     public CompletionStage<BigInteger> f(int n, Executor e) {
>>
>>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>>
>>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>>
>>       if (prev != null) return prev;
>>
>>       else
>>
>>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
>> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
>> e);
>>
>>     }
>>
>>   }
>>
>>
>>
>>
>>
>> --
>>
>> Cheers,
>>
>> ?
>>
>>
>>
>> ------------------------------
>>
>>
>>
>> _______________________________________________
>>
>> Concurrency-interest mailing list
>>
>> Concurrency-interest at cs.oswego.edu
>>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>>
>> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
>> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
>> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
>> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
>> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
>> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>>
>
>
>
> --
> Cheers,
> ?
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160425/4e19d91a/attachment.html>

From thurston at nomagicsoftware.com  Mon Apr 25 19:29:38 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Mon, 25 Apr 2016 16:29:38 -0700 (MST)
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <57177FDD.1080101@oracle.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
	<57177FDD.1080101@oracle.com>
Message-ID: <1461626978870-13403.post@n7.nabble.com>

Just curious,

has anyone actually observed a real JVM returning null in the original, racy
code?
I realize the JMM allows it, but I'd be surprised that a JVM would reorder
reads of the *same* memory location





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/8145539-coll-AbstractMap-keySet-and-values-should-not-be-volatile-tp13382p13403.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From vitalyd at gmail.com  Tue Apr 26 08:27:12 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 26 Apr 2016 08:27:12 -0400
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <1461626978870-13403.post@n7.nabble.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
	<57177FDD.1080101@oracle.com>
	<1461626978870-13403.post@n7.nabble.com>
Message-ID: <CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>

The problem is compilers can do weird things on the assumption of data race
free code.  If you haven't seen
https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong,
I recommend reading it.  It's in the context of C/C++/Go but the general
point stands.

In this case, compiler can arrange a read of the field into a
register/stack slot - assume it reads null.  Later it re-tests the field
(memory), sees non null, but returns the register/stack slot value.  It's
weird, but legal.  Whether it happens I don't know, but you likely don't
want to find out :).

On Monday, April 25, 2016, thurstonn <thurston at nomagicsoftware.com> wrote:

> Just curious,
>
> has anyone actually observed a real JVM returning null in the original,
> racy
> code?
> I realize the JMM allows it, but I'd be surprised that a JVM would reorder
> reads of the *same* memory location
>
>
>
>
>
> --
> View this message in context:
> http://jsr166-concurrency.10961.n7.nabble.com/8145539-coll-AbstractMap-keySet-and-values-should-not-be-volatile-tp13382p13403.html
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <javascript:;>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160426/703c74f7/attachment.html>

From Sebastian.Millies at softwareag.com  Tue Apr 26 11:09:03 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Tue, 26 Apr 2016 15:09:03 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>

Yes, thank you very much,  very instructive. I wonder how expensive the asynchronous computation step must be to make it worthwhile speed-wise. When computing the 2000th Fibonacci number on my quadcore, at least, the asynchronous ?optimized? CF version performs 10 ? 20 times worse compared to single-threaded code using a memoizer  with a simple HashMap, such as the one posted by Andrew Haley in this thread.

n  Sebastian

From: Henri Tremblay [mailto:henri.tremblay at gmail.com]
Sent: Monday, April 25, 2016 7:02 PM
To: Viktor Klang
Cc: Millies, Sebastian; concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Hi Viktor,

Thanks a lot for those examples. They are crystal clear demonstration of a nice CompletableFuture usage.

Really nice
Henri

On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>> wrote:
Hi Sebastian,

I only provided the code as an alternate solution to using computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.

If / when CHM becomes completely non-blocking, this would mean that readers would never block other readers nor other writers, and writers would never block readers or other writers.

package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletionStage<BigInteger> ret = cache.get(n);
      if (ret == null) {
        final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
        ret = cache.putIfAbsent(n, compute);
        if (ret == null)
          ret = f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; }, e), e);
      }
      return ret;
    }
  }
1: It's very much possible and recommended to not make the first thenCompose an async one, as only the addition of v and v2 might be "expensive" (for large additions).

On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I?m not sure I?m getting it. What?s significant about putting that empty CF in as a placeholder first? That is, what is the advantage over writing

public CompletionStage<BigInteger> f(int n) {
  CompletionStage<BigInteger> prev = cache.get(n);
  if (prev != null) {
    return prev;
  }
  else {
    return f(n - 1).thenCompose(x ->
           f(n - 2).thenCompose(y -> {
           CompletableFuture<BigInteger> next = CompletableFuture.completedFuture(x.add(y));
           CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
           return prev != null ? v : next;
    }));
  }
}

Is it that in Viktor?s code, only the thread that first has a cache miss calls the computation that will complete the future, while in the above code there may be multiple computations, only one of which will eventually contribute to the result? And would that consideration only apply to the async version?


?  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Dr Heinz M. Kabutz
Sent: Saturday, April 23, 2016 7:31 AM
To: Viktor Klang
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks so much Viktor for that code!  The part that I somehow missed was the empty CompletableFuture: CompletableFuture<BigInteger> next = new CompletableFuture<>();

Very interesting indeed.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun/Oracle Java Champion since 2005

JavaOne Rock Star Speaker 2012

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz


Viktor Klang wrote:
Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> { next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to parallelize it.
Also means that concurrent readers/writers won't block eachother (computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e), e);
    }
  }


--
Cheers,
?



________________________________



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com




--
Cheers,
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160426/8d7a91fc/attachment-0001.html>

From heinz at javaspecialists.eu  Tue Apr 26 11:33:22 2016
From: heinz at javaspecialists.eu (Dr Heinz M. Kabutz)
Date: Tue, 26 Apr 2016 16:33:22 +0100
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
	computeIfAbsent() ?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu>
	<5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
Message-ID: <CACLL95qnCDX+qn2ciX961qUfPxqzbwm50PVpw0pik9fWe=GWkg@mail.gmail.com>

You need to combine it with Dijkstra's sum of squares and parallelise
BigInteger.multiply to see good results

On Tuesday, 26 April 2016, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> Yes, thank you very much,  very instructive. I wonder how expensive the
> asynchronous computation step must be to make it worthwhile speed-wise.
> When computing the 2000th Fibonacci number on my quadcore, at least, the
> asynchronous ?optimized? CF version performs 10 ? 20 times worse compared
> to single-threaded code using a memoizer  with a simple HashMap, such as
> the one posted by Andrew Haley in this thread.
>
> n  Sebastian
>
>
>
> *From:* Henri Tremblay [mailto:henri.tremblay at gmail.com
> <javascript:_e(%7B%7D,'cvml','henri.tremblay at gmail.com');>]
> *Sent:* Monday, April 25, 2016 7:02 PM
> *To:* Viktor Klang
> *Cc:* Millies, Sebastian; concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Viktor,
>
>
>
> Thanks a lot for those examples. They are crystal clear demonstration of a
> nice CompletableFuture usage.
>
>
>
> Really nice
>
> Henri
>
>
>
> On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com
> <javascript:_e(%7B%7D,'cvml','viktor.klang at gmail.com');>> wrote:
>
> Hi Sebastian,
>
>
>
> I only provided the code as an alternate solution to using
> computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.
>
>
> If / when CHM becomes completely non-blocking, this would mean that
> readers would never block other readers nor other writers, and writers
> would never block readers or other writers.
>
> package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletionStage<BigInteger> ret = cache.get(n);
>
>       if (ret == null) {
>
>         final CompletableFuture<BigInteger> compute = new
> CompletableFuture<>();
>
>         ret = cache.putIfAbsent(n, compute);
>
>         if (ret == null)
>
>           ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
> e), e);
>
>       }
>
>       return ret;
>
>     }
>
>   }
>
> 1: It's very much possible and recommended to not make the first
> thenCompose an async one, as only the addition of v and v2 might be
> "expensive" (for large additions).
>
>
>
> On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com
> <javascript:_e(%7B%7D,'cvml','Sebastian.Millies at softwareag.com');>> wrote:
>
> I?m not sure I?m getting it. What?s significant about putting that empty
> CF in as a placeholder first? That is, what is the advantage over writing
>
>
>
> public CompletionStage<BigInteger> f(int n) {
>
>   CompletionStage<BigInteger> prev = cache.get(n);
>
>   if (prev != null) {
>
>     return prev;
>
>   }
>
>   else {
>
>     return f(n - 1).thenCompose(x ->
>
>            f(n - 2).thenCompose(y -> {
>
>            CompletableFuture<BigInteger> next =
> CompletableFuture.completedFuture(x.add(y));
>
>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>
>            return prev != null ? v : next;
>
>     }));
>
>   }
>
> }
>
>
>
> Is it that in Viktor?s code, only the thread that first has a cache miss
> calls the computation that will complete the future, while in the above
> code there may be multiple computations, only one of which will eventually
> contribute to the result? And would that consideration only apply to the
> async version?
>
>
>
> n  Sebastian
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu
> <javascript:_e(%7B%7D,'cvml','concurrency-interest-bounces at cs.oswego.edu');>
> [mailto:concurrency-interest-bounces at cs.oswego.edu
> <javascript:_e(%7B%7D,'cvml','concurrency-interest-bounces at cs.oswego.edu');>]
> *On Behalf Of *Dr Heinz M. Kabutz
> *Sent:* Saturday, April 23, 2016 7:31 AM
> *To:* Viktor Klang
> *Cc:* concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks so much Viktor for that code!  The part that I somehow missed was
> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
> CompletableFuture<>();
>
> Very interesting indeed.
>
> Regards
>
>
>
> Heinz
>
> --
>
> Dr Heinz M. Kabutz (PhD CompSci)
>
> Author of "The Java(tm) Specialists' Newsletter"
>
> Sun/Oracle Java Champion since 2005
>
> JavaOne Rock Star Speaker 2012
>
> http://www.javaspecialists.eu
>
> Tel: +30 69 75 595 262
>
> Skype: kabutz
>
>
>
> Viktor Klang wrote:
>
> Heinz,
>
> There's also the option of going this route:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
> next.complete(v.add(v2)); return next; }));
>
>     }
>
>   }
>
>
>
>
>
> Add Executor parameter to `f` and switch to thenComposeAsync to be able to
> parallelize it.
>
> Also means that concurrent readers/writers won't block eachother
> (computeIfAbsent would do that for instance)
>
>
>
> ? la:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
> e);
>
>     }
>
>   }
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
>
> ------------------------------
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu <javascript:_e(%7B%7D,'cvml','Concurrency-interest at cs.oswego.edu');>
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> <javascript:_e(%7B%7D,'cvml','Concurrency-interest at cs.oswego.edu');>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


-- 
Dr Heinz M. Kabutz (PhD CompSci)
Author of "The Java(tm) Specialists' Newsletter"
Sun/Oracle Java Champion
JavaOne Rockstar Speaker
http://www.javaspecialists.eu
Tel: +30 69 75 595 262
Skype: kabutz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160426/10bfd8f4/attachment-0001.html>

From viktor.klang at gmail.com  Tue Apr 26 11:34:00 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 26 Apr 2016 17:34:00 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu>
	<5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>

Hi Sebastian!

(IMO) Async is neverr for performance, it is for scalability. (And
resilience; Parallelization is for performance)

What does the scaling profile look for 1..N concurrent accesses?

And did you try using thenCompose iso. thenComposeAsync for the initial
step?

Also, which executor did you use and using what config?

A lot of questions, I know!
-- 
Cheers,
?
On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <
Sebastian.Millies at softwareag.com> wrote:

> Yes, thank you very much,  very instructive. I wonder how expensive the
> asynchronous computation step must be to make it worthwhile speed-wise.
> When computing the 2000th Fibonacci number on my quadcore, at least, the
> asynchronous ?optimized? CF version performs 10 ? 20 times worse compared
> to single-threaded code using a memoizer  with a simple HashMap, such as
> the one posted by Andrew Haley in this thread.
>
> n  Sebastian
>
>
>
> *From:* Henri Tremblay [mailto:henri.tremblay at gmail.com]
> *Sent:* Monday, April 25, 2016 7:02 PM
> *To:* Viktor Klang
> *Cc:* Millies, Sebastian; concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Viktor,
>
>
>
> Thanks a lot for those examples. They are crystal clear demonstration of a
> nice CompletableFuture usage.
>
>
>
> Really nice
>
> Henri
>
>
>
> On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> Hi Sebastian,
>
>
>
> I only provided the code as an alternate solution to using
> computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.
>
>
> If / when CHM becomes completely non-blocking, this would mean that
> readers would never block other readers nor other writers, and writers
> would never block readers or other writers.
>
> package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletionStage<BigInteger> ret = cache.get(n);
>
>       if (ret == null) {
>
>         final CompletableFuture<BigInteger> compute = new
> CompletableFuture<>();
>
>         ret = cache.putIfAbsent(n, compute);
>
>         if (ret == null)
>
>           ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
> e), e);
>
>       }
>
>       return ret;
>
>     }
>
>   }
>
> 1: It's very much possible and recommended to not make the first
> thenCompose an async one, as only the addition of v and v2 might be
> "expensive" (for large additions).
>
>
>
> On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
> I?m not sure I?m getting it. What?s significant about putting that empty
> CF in as a placeholder first? That is, what is the advantage over writing
>
>
>
> public CompletionStage<BigInteger> f(int n) {
>
>   CompletionStage<BigInteger> prev = cache.get(n);
>
>   if (prev != null) {
>
>     return prev;
>
>   }
>
>   else {
>
>     return f(n - 1).thenCompose(x ->
>
>            f(n - 2).thenCompose(y -> {
>
>            CompletableFuture<BigInteger> next =
> CompletableFuture.completedFuture(x.add(y));
>
>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>
>            return prev != null ? v : next;
>
>     }));
>
>   }
>
> }
>
>
>
> Is it that in Viktor?s code, only the thread that first has a cache miss
> calls the computation that will complete the future, while in the above
> code there may be multiple computations, only one of which will eventually
> contribute to the result? And would that consideration only apply to the
> async version?
>
>
>
> n  Sebastian
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dr Heinz M.
> Kabutz
> *Sent:* Saturday, April 23, 2016 7:31 AM
> *To:* Viktor Klang
> *Cc:* concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks so much Viktor for that code!  The part that I somehow missed was
> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
> CompletableFuture<>();
>
> Very interesting indeed.
>
> Regards
>
>
>
> Heinz
>
> --
>
> Dr Heinz M. Kabutz (PhD CompSci)
>
> Author of "The Java(tm) Specialists' Newsletter"
>
> Sun/Oracle Java Champion since 2005
>
> JavaOne Rock Star Speaker 2012
>
> http://www.javaspecialists.eu
>
> Tel: +30 69 75 595 262
>
> Skype: kabutz
>
>
>
> Viktor Klang wrote:
>
> Heinz,
>
> There's also the option of going this route:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
> next.complete(v.add(v2)); return next; }));
>
>     }
>
>   }
>
>
>
>
>
> Add Executor parameter to `f` and switch to thenComposeAsync to be able to
> parallelize it.
>
> Also means that concurrent readers/writers won't block eachother
> (computeIfAbsent would do that for instance)
>
>
>
> ? la:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
> e);
>
>     }
>
>   }
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
>
> ------------------------------
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160426/86f4b65d/attachment-0001.html>

From thurston at nomagicsoftware.com  Tue Apr 26 11:00:59 2016
From: thurston at nomagicsoftware.com (thurstonn)
Date: Tue, 26 Apr 2016 08:00:59 -0700 (MST)
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
	<57177FDD.1080101@oracle.com>
	<1461626978870-13403.post@n7.nabble.com>
	<CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>
Message-ID: <1461682859324-13408.post@n7.nabble.com>

Yes, I understand the compiler transformation that could cause the problem,
and that it's allowed by the JMM, but I find it hard to believe that there's
an actual JIT out there in the wild that would actually do so.
The "normal", logical optimization would be to eliminate the redundant read,
which actually "solves" the data race.

It's one thing for the compiler (or more likely the CPU) to reorder reads of
*different memory locations*, but to reorder reads of *the same memory
location*?  That seems far-fetched.

Anyway, I'll take a look at the link.


*I should note that the problem wouldn't have manifested itself in
AbstractMap since #keyset and #values were originally declared volatile; I
was asking about the general idiom 


Vitaly Davidovich wrote
> The problem is compilers can do weird things on the assumption of data
> race
> free code.  If you haven't seen
> https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong,
> I recommend reading it.  It's in the context of C/C++/Go but the general
> point stands.
> 
> In this case, compiler can arrange a read of the field into a
> register/stack slot - assume it reads null.  Later it re-tests the field
> (memory), sees non null, but returns the register/stack slot value.  It's
> weird, but legal.  Whether it happens I don't know, but you likely don't
> want to find out :).
> 
> On Monday, April 25, 2016, thurstonn &lt;

> thurston@

> &gt; wrote:
> 
>> Just curious,
>>
>> has anyone actually observed a real JVM returning null in the original,
>> racy
>> code?
>> I realize the JMM allows it, but I'd be surprised that a JVM would
>> reorder
>> reads of the *same* memory location
>>
>>
>>
>>
>>
>> --
>> View this message in context:
>> http://jsr166-concurrency.10961.n7.nabble.com/8145539-coll-AbstractMap-keySet-and-values-should-not-be-volatile-tp13382p13403.html
>> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>> _______________________________________________
>> Concurrency-interest mailing list
>> 

> Concurrency-interest at .oswego

>  &lt;javascript:;&gt;
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> 
> 
> -- 
> Sent from my phone
> 
> _______________________________________________
> Concurrency-interest mailing list

> Concurrency-interest at .oswego

> http://cs.oswego.edu/mailman/listinfo/concurrency-interest





--
View this message in context: http://jsr166-concurrency.10961.n7.nabble.com/8145539-coll-AbstractMap-keySet-and-values-should-not-be-volatile-tp13382p13408.html
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

From jsampson at guidewire.com  Tue Apr 26 15:12:18 2016
From: jsampson at guidewire.com (Justin Sampson)
Date: Tue, 26 Apr 2016 19:12:18 +0000
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
	<57177FDD.1080101@oracle.com>	<1461626978870-13403.post@n7.nabble.com>
	<CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>
Message-ID: <DM2PR05MB68611871773FBB1323338F0D1630@DM2PR05MB686.namprd05.prod.outlook.com>

Vitaly Davidovich wrote:

> The problem is compilers can do weird things on the assumption of
> data race free code. If you haven't seen
> https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong
> I recommend reading it. It's in the context of C/C++/Go but the
> general point stands.

Interesting -- that article actually seems to describe cases of
thin-air reads due to the compiler reusing memory locations, which
is impossible in Java even for racy code, right?

Thanks,
Justin


From vitalyd at gmail.com  Tue Apr 26 15:16:15 2016
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Tue, 26 Apr 2016 15:16:15 -0400
Subject: [concurrency-interest] 8145539: (coll) AbstractMap.keySet and
 .values should not be volatile
In-Reply-To: <DM2PR05MB68611871773FBB1323338F0D1630@DM2PR05MB686.namprd05.prod.outlook.com>
References: <9DD392344AED044287E42246402FDAB47C3536DD@max.atis-systems.com>
	<57177FDD.1080101@oracle.com>
	<1461626978870-13403.post@n7.nabble.com>
	<CAHjP37Go0mgf45qc12r9seRutYVtOtkFWSBYHutOwdcY-iOmBA@mail.gmail.com>
	<DM2PR05MB68611871773FBB1323338F0D1630@DM2PR05MB686.namprd05.prod.outlook.com>
Message-ID: <CAHjP37EDi+EeuWnWhQSrPywFL7CCHAgA0CrD51U+jA_yB30b0Q@mail.gmail.com>

Yes, I believe JVMs are not allowed to introduce phantom reads or writes.
In other words, reading a plain field into a local (and only using the
local) in java means it will not be re-read, whereas no such guarantee
exists in C/C++.  Relatedly, that blog shows a case where gcc and clang
read and write, back-to-back(!), a field to memory -- that is also not
allowed in conforming JVMs, AFAIK.

On Tue, Apr 26, 2016 at 3:12 PM, Justin Sampson <jsampson at guidewire.com>
wrote:

> Vitaly Davidovich wrote:
>
> > The problem is compilers can do weird things on the assumption of
> > data race free code. If you haven't seen
> >
> https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong
> > I recommend reading it. It's in the context of C/C++/Go but the
> > general point stands.
>
> Interesting -- that article actually seems to describe cases of
> thin-air reads due to the compiler reusing memory locations, which
> is impossible in Java even for racy code, right?
>
> Thanks,
> Justin
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160426/47ccbab6/attachment.html>

From Sebastian.Millies at softwareag.com  Wed Apr 27 03:20:39 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 27 Apr 2016 07:20:39 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu>	<5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>

Hello Viktor,

as I don?t know if attachments are alright in this group, I have put the code and benchmark in a gist:
https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889


n  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Tuesday, April 26, 2016 5:34 PM
To: Millies, Sebastian
Cc: concurrency-interest; Henri Tremblay
Subject: RE: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?


Hi Sebastian!

(IMO) Async is neverr for performance, it is for scalability. (And resilience; Parallelization is for performance)

What does the scaling profile look for 1..N concurrent accesses?

And did you try using thenCompose iso. thenComposeAsync for the initial step?

Also, which executor did you use and using what config?

A lot of questions, I know!
--
Cheers,
?
On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Yes, thank you very much,  very instructive. I wonder how expensive the asynchronous computation step must be to make it worthwhile speed-wise. When computing the 2000th Fibonacci number on my quadcore, at least, the asynchronous ?optimized? CF version performs 10 ? 20 times worse compared to single-threaded code using a memoizer  with a simple HashMap, such as the one posted by Andrew Haley in this thread.

?  Sebastian

From: Henri Tremblay [mailto:henri.tremblay at gmail.com<mailto:henri.tremblay at gmail.com>]
Sent: Monday, April 25, 2016 7:02 PM
To: Viktor Klang
Cc: Millies, Sebastian; concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Hi Viktor,

Thanks a lot for those examples. They are crystal clear demonstration of a nice CompletableFuture usage.

Really nice
Henri

On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>> wrote:
Hi Sebastian,

I only provided the code as an alternate solution to using computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.

If / when CHM becomes completely non-blocking, this would mean that readers would never block other readers nor other writers, and writers would never block readers or other writers.

package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletionStage<BigInteger> ret = cache.get(n);
      if (ret == null) {
        final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
        ret = cache.putIfAbsent(n, compute);
        if (ret == null)
          ret = f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; }, e), e);
      }
      return ret;
    }
  }
1: It's very much possible and recommended to not make the first thenCompose an async one, as only the addition of v and v2 might be "expensive" (for large additions).

On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I?m not sure I?m getting it. What?s significant about putting that empty CF in as a placeholder first? That is, what is the advantage over writing

public CompletionStage<BigInteger> f(int n) {
  CompletionStage<BigInteger> prev = cache.get(n);
  if (prev != null) {
    return prev;
  }
  else {
    return f(n - 1).thenCompose(x ->
           f(n - 2).thenCompose(y -> {
           CompletableFuture<BigInteger> next = CompletableFuture.completedFuture(x.add(y));
           CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
           return prev != null ? v : next;
    }));
  }
}

Is it that in Viktor?s code, only the thread that first has a cache miss calls the computation that will complete the future, while in the above code there may be multiple computations, only one of which will eventually contribute to the result? And would that consideration only apply to the async version?


?  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Dr Heinz M. Kabutz
Sent: Saturday, April 23, 2016 7:31 AM
To: Viktor Klang
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks so much Viktor for that code!  The part that I somehow missed was the empty CompletableFuture: CompletableFuture<BigInteger> next = new CompletableFuture<>();

Very interesting indeed.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun/Oracle Java Champion since 2005

JavaOne Rock Star Speaker 2012

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz


Viktor Klang wrote:
Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> { next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to parallelize it.
Also means that concurrent readers/writers won't block eachother (computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e), e);
    }
  }


--
Cheers,
?



________________________________



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com




--
Cheers,
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/ecda14f4/attachment-0001.html>

From viktor.klang at gmail.com  Wed Apr 27 03:23:42 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 27 Apr 2016 09:23:42 +0200
Subject: [concurrency-interest] For those of us who bench on Linux
In-Reply-To: <CANPzfU_NdmZbrifRZtaiOVes5sviZsfgUV99SY2LxwE2HxNqaA@mail.gmail.com>
References: <CANPzfU9KAyHip0Q8pcGos-KQX9rc=tirO703wTTeQyRNcYPhQg@mail.gmail.com>
	<CANPzfU-NPteek-U6NAq1gTx898NscbkcM-=-y-nSUGRMaG83eQ@mail.gmail.com>
	<CANPzfU_NdmZbrifRZtaiOVes5sviZsfgUV99SY2LxwE2HxNqaA@mail.gmail.com>
Message-ID: <CANPzfU9Q7+nm1igMvBaGCGdgOxuAPMD7Yy3h7paN1t9aSGePgw@mail.gmail.com>

TL;DR: problems found and fixed with Linux scheduler affecting multicore
systems.

Story & paper:
https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/

Code: https://github.com/jplozi/wastedcores

Would love to hear your thoughts.

-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/7ca3b03f/attachment.html>

From viktor.klang at gmail.com  Wed Apr 27 04:22:02 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 27 Apr 2016 10:22:02 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>

Thanks Sebastian,

(There's a thenComposeAsync missing in the async version.)

Could you augment the JMH test to attempt to use the same Fib from multiple
threads to show how it behaves under contention? (this is where the
simple-version breaks down as it isn't threadsafe)

I believe you'll also have to use larger values for fib to make sure that
BigInteger.add gets a bit of exercise too :)


On Wed, Apr 27, 2016 at 9:20 AM, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> Hello Viktor,
>
>
>
> as I don?t know if attachments are alright in this group, I have put the
> code and benchmark in a gist:
>
> https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889
>
>
>
> n  Sebastian
>
>
>
> *From:* Viktor Klang [mailto:viktor.klang at gmail.com]
> *Sent:* Tuesday, April 26, 2016 5:34 PM
> *To:* Millies, Sebastian
> *Cc:* concurrency-interest; Henri Tremblay
> *Subject:* RE: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Sebastian!
>
> (IMO) Async is neverr for performance, it is for scalability. (And
> resilience; Parallelization is for performance)
>
> What does the scaling profile look for 1..N concurrent accesses?
>
> And did you try using thenCompose iso. thenComposeAsync for the initial
> step?
>
> Also, which executor did you use and using what config?
>
> A lot of questions, I know!
> --
> Cheers,
> ?
>
> On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <
> Sebastian.Millies at softwareag.com> wrote:
>
> Yes, thank you very much,  very instructive. I wonder how expensive the
> asynchronous computation step must be to make it worthwhile speed-wise.
> When computing the 2000th Fibonacci number on my quadcore, at least, the
> asynchronous ?optimized? CF version performs 10 ? 20 times worse compared
> to single-threaded code using a memoizer  with a simple HashMap, such as
> the one posted by Andrew Haley in this thread.
>
> n  Sebastian
>
>
>
> *From:* Henri Tremblay [mailto:henri.tremblay at gmail.com]
> *Sent:* Monday, April 25, 2016 7:02 PM
> *To:* Viktor Klang
> *Cc:* Millies, Sebastian; concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Viktor,
>
>
>
> Thanks a lot for those examples. They are crystal clear demonstration of a
> nice CompletableFuture usage.
>
>
>
> Really nice
>
> Henri
>
>
>
> On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> Hi Sebastian,
>
>
>
> I only provided the code as an alternate solution to using
> computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.
>
>
> If / when CHM becomes completely non-blocking, this would mean that
> readers would never block other readers nor other writers, and writers
> would never block readers or other writers.
>
> package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletionStage<BigInteger> ret = cache.get(n);
>
>       if (ret == null) {
>
>         final CompletableFuture<BigInteger> compute = new
> CompletableFuture<>();
>
>         ret = cache.putIfAbsent(n, compute);
>
>         if (ret == null)
>
>           ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
> e), e);
>
>       }
>
>       return ret;
>
>     }
>
>   }
>
> 1: It's very much possible and recommended to not make the first
> thenCompose an async one, as only the addition of v and v2 might be
> "expensive" (for large additions).
>
>
>
> On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
> I?m not sure I?m getting it. What?s significant about putting that empty
> CF in as a placeholder first? That is, what is the advantage over writing
>
>
>
> public CompletionStage<BigInteger> f(int n) {
>
>   CompletionStage<BigInteger> prev = cache.get(n);
>
>   if (prev != null) {
>
>     return prev;
>
>   }
>
>   else {
>
>     return f(n - 1).thenCompose(x ->
>
>            f(n - 2).thenCompose(y -> {
>
>            CompletableFuture<BigInteger> next =
> CompletableFuture.completedFuture(x.add(y));
>
>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>
>            return prev != null ? v : next;
>
>     }));
>
>   }
>
> }
>
>
>
> Is it that in Viktor?s code, only the thread that first has a cache miss
> calls the computation that will complete the future, while in the above
> code there may be multiple computations, only one of which will eventually
> contribute to the result? And would that consideration only apply to the
> async version?
>
>
>
> n  Sebastian
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dr Heinz M.
> Kabutz
> *Sent:* Saturday, April 23, 2016 7:31 AM
> *To:* Viktor Klang
> *Cc:* concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks so much Viktor for that code!  The part that I somehow missed was
> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
> CompletableFuture<>();
>
> Very interesting indeed.
>
> Regards
>
>
>
> Heinz
>
> --
>
> Dr Heinz M. Kabutz (PhD CompSci)
>
> Author of "The Java(tm) Specialists' Newsletter"
>
> Sun/Oracle Java Champion since 2005
>
> JavaOne Rock Star Speaker 2012
>
> http://www.javaspecialists.eu
>
> Tel: +30 69 75 595 262
>
> Skype: kabutz
>
>
>
> Viktor Klang wrote:
>
> Heinz,
>
> There's also the option of going this route:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
> next.complete(v.add(v2)); return next; }));
>
>     }
>
>   }
>
>
>
>
>
> Add Executor parameter to `f` and switch to thenComposeAsync to be able to
> parallelize it.
>
> Also means that concurrent readers/writers won't block eachother
> (computeIfAbsent would do that for instance)
>
>
>
> ? la:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
> e);
>
>     }
>
>   }
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
>
> ------------------------------
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/ab01a675/attachment-0001.html>

From davidcholmes at aapt.net.au  Wed Apr 27 04:50:54 2016
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 27 Apr 2016 18:50:54 +1000
Subject: [concurrency-interest] For those of us who bench on Linux
In-Reply-To: <CANPzfU9Q7+nm1igMvBaGCGdgOxuAPMD7Yy3h7paN1t9aSGePgw@mail.gmail.com>
References: <CANPzfU9KAyHip0Q8pcGos-KQX9rc=tirO703wTTeQyRNcYPhQg@mail.gmail.com>	<CANPzfU-NPteek-U6NAq1gTx898NscbkcM-=-y-nSUGRMaG83eQ@mail.gmail.com>	<CANPzfU_NdmZbrifRZtaiOVes5sviZsfgUV99SY2LxwE2HxNqaA@mail.gmail.com>
	<CANPzfU9Q7+nm1igMvBaGCGdgOxuAPMD7Yy3h7paN1t9aSGePgw@mail.gmail.com>
Message-ID: <002901d1a061$e8faafb0$baf00f10$@aapt.net.au>

Very interesting. In particular that scheduling affinity (to take advantage of a warm cache) can be a performance hit.

 

Thanks for the link.

 

David

 

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Viktor Klang
Sent: Wednesday, April 27, 2016 5:24 PM
To: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: [concurrency-interest] For those of us who bench on Linux

 

TL;DR: problems found and fixed with Linux scheduler affecting multicore systems.

Story & paper: https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/

Code: https://github.com/jplozi/wastedcores

Would love to hear your thoughts.

-- 
Cheers,
?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/a5038591/attachment.html>

From Sebastian.Millies at softwareag.com  Wed Apr 27 09:09:47 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 27 Apr 2016 13:09:47 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
	<CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>

I have added https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889#file-fibcachedconcurrentbenchmark-java
to compute concurrent benchmarks of the 6000th Fibonacci number. Only the CF versions of course.

The same Fib is used by two threads in each case, the pool for the async version gets another two.

The bad news is they?re prone to  deadlock. Now I am no expert in JMH, perhaps it?s just the way I?ve set up the tests .(I hope so.)


n  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Wednesday, April 27, 2016 10:22 AM
To: Millies, Sebastian
Cc: concurrency-interest; Henri Tremblay
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks Sebastian,

(There's a thenComposeAsync missing in the async version.)

Could you augment the JMH test to attempt to use the same Fib from multiple threads to show how it behaves under contention? (this is where the simple-version breaks down as it isn't threadsafe)

I believe you'll also have to use larger values for fib to make sure that BigInteger.add gets a bit of exercise too :)


On Wed, Apr 27, 2016 at 9:20 AM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Hello Viktor,

as I don?t know if attachments are alright in this group, I have put the code and benchmark in a gist:
https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889


?  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>]
Sent: Tuesday, April 26, 2016 5:34 PM
To: Millies, Sebastian
Cc: concurrency-interest; Henri Tremblay
Subject: RE: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?


Hi Sebastian!

(IMO) Async is neverr for performance, it is for scalability. (And resilience; Parallelization is for performance)

What does the scaling profile look for 1..N concurrent accesses?

And did you try using thenCompose iso. thenComposeAsync for the initial step?

Also, which executor did you use and using what config?

A lot of questions, I know!
--
Cheers,
?
On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Yes, thank you very much,  very instructive. I wonder how expensive the asynchronous computation step must be to make it worthwhile speed-wise. When computing the 2000th Fibonacci number on my quadcore, at least, the asynchronous ?optimized? CF version performs 10 ? 20 times worse compared to single-threaded code using a memoizer  with a simple HashMap, such as the one posted by Andrew Haley in this thread.

?  Sebastian

From: Henri Tremblay [mailto:henri.tremblay at gmail.com<mailto:henri.tremblay at gmail.com>]
Sent: Monday, April 25, 2016 7:02 PM
To: Viktor Klang
Cc: Millies, Sebastian; concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Hi Viktor,

Thanks a lot for those examples. They are crystal clear demonstration of a nice CompletableFuture usage.

Really nice
Henri

On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>> wrote:
Hi Sebastian,

I only provided the code as an alternate solution to using computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.

If / when CHM becomes completely non-blocking, this would mean that readers would never block other readers nor other writers, and writers would never block readers or other writers.

package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletionStage<BigInteger> ret = cache.get(n);
      if (ret == null) {
        final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
        ret = cache.putIfAbsent(n, compute);
        if (ret == null)
          ret = f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; }, e), e);
      }
      return ret;
    }
  }
1: It's very much possible and recommended to not make the first thenCompose an async one, as only the addition of v and v2 might be "expensive" (for large additions).

On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I?m not sure I?m getting it. What?s significant about putting that empty CF in as a placeholder first? That is, what is the advantage over writing

public CompletionStage<BigInteger> f(int n) {
  CompletionStage<BigInteger> prev = cache.get(n);
  if (prev != null) {
    return prev;
  }
  else {
    return f(n - 1).thenCompose(x ->
           f(n - 2).thenCompose(y -> {
           CompletableFuture<BigInteger> next = CompletableFuture.completedFuture(x.add(y));
           CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
           return prev != null ? v : next;
    }));
  }
}

Is it that in Viktor?s code, only the thread that first has a cache miss calls the computation that will complete the future, while in the above code there may be multiple computations, only one of which will eventually contribute to the result? And would that consideration only apply to the async version?


?  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Dr Heinz M. Kabutz
Sent: Saturday, April 23, 2016 7:31 AM
To: Viktor Klang
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks so much Viktor for that code!  The part that I somehow missed was the empty CompletableFuture: CompletableFuture<BigInteger> next = new CompletableFuture<>();

Very interesting indeed.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun/Oracle Java Champion since 2005

JavaOne Rock Star Speaker 2012

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz


Viktor Klang wrote:
Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> { next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to parallelize it.
Also means that concurrent readers/writers won't block eachother (computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e), e);
    }
  }


--
Cheers,
?



________________________________



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com




--
Cheers,
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest




--
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/eaa749ae/attachment-0001.html>

From viktor.klang at gmail.com  Wed Apr 27 09:20:32 2016
From: viktor.klang at gmail.com (Viktor Klang)
Date: Wed, 27 Apr 2016 15:20:32 +0200
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
	<CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>
Message-ID: <CANPzfU-aAdVw5aTWAanGER_NgLRqoKyk_E6GCvuw-oXBrnFz=Q@mail.gmail.com>

Do you have a thread dump? (sorry, I don't have any spare cycles to have a
stab at running it right now)

On Wed, Apr 27, 2016 at 3:09 PM, Millies, Sebastian <
Sebastian.Millies at softwareag.com> wrote:

> I have added
> https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889#file-fibcachedconcurrentbenchmark-java
>
> to compute concurrent benchmarks of the 6000th Fibonacci number. Only the
> CF versions of course.
>
>
>
> The same Fib is used by two threads in each case, the pool for the async
> version gets another two.
>
>
>
> The bad news is they?re prone to  deadlock. Now I am no expert in JMH,
> perhaps it?s just the way I?ve set up the tests .(I hope so.)
>
>
>
> n  Sebastian
>
>
>
> *From:* Viktor Klang [mailto:viktor.klang at gmail.com]
> *Sent:* Wednesday, April 27, 2016 10:22 AM
> *To:* Millies, Sebastian
> *Cc:* concurrency-interest; Henri Tremblay
>
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks Sebastian,
>
>
>
> (There's a thenComposeAsync missing in the async version.)
>
>
>
> Could you augment the JMH test to attempt to use the same Fib from
> multiple threads to show how it behaves under contention? (this is where
> the simple-version breaks down as it isn't threadsafe)
>
>
>
> I believe you'll also have to use larger values for fib to make sure that
> BigInteger.add gets a bit of exercise too :)
>
>
>
>
>
> On Wed, Apr 27, 2016 at 9:20 AM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
> Hello Viktor,
>
>
>
> as I don?t know if attachments are alright in this group, I have put the
> code and benchmark in a gist:
>
> https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889
>
>
>
> n  Sebastian
>
>
>
> *From:* Viktor Klang [mailto:viktor.klang at gmail.com]
> *Sent:* Tuesday, April 26, 2016 5:34 PM
> *To:* Millies, Sebastian
> *Cc:* concurrency-interest; Henri Tremblay
> *Subject:* RE: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Sebastian!
>
> (IMO) Async is neverr for performance, it is for scalability. (And
> resilience; Parallelization is for performance)
>
> What does the scaling profile look for 1..N concurrent accesses?
>
> And did you try using thenCompose iso. thenComposeAsync for the initial
> step?
>
> Also, which executor did you use and using what config?
>
> A lot of questions, I know!
> --
> Cheers,
> ?
>
> On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <
> Sebastian.Millies at softwareag.com> wrote:
>
> Yes, thank you very much,  very instructive. I wonder how expensive the
> asynchronous computation step must be to make it worthwhile speed-wise.
> When computing the 2000th Fibonacci number on my quadcore, at least, the
> asynchronous ?optimized? CF version performs 10 ? 20 times worse compared
> to single-threaded code using a memoizer  with a simple HashMap, such as
> the one posted by Andrew Haley in this thread.
>
> n  Sebastian
>
>
>
> *From:* Henri Tremblay [mailto:henri.tremblay at gmail.com]
> *Sent:* Monday, April 25, 2016 7:02 PM
> *To:* Viktor Klang
> *Cc:* Millies, Sebastian; concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Hi Viktor,
>
>
>
> Thanks a lot for those examples. They are crystal clear demonstration of a
> nice CompletableFuture usage.
>
>
>
> Really nice
>
> Henri
>
>
>
> On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> Hi Sebastian,
>
>
>
> I only provided the code as an alternate solution to using
> computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.
>
>
> If / when CHM becomes completely non-blocking, this would mean that
> readers would never block other readers nor other writers, and writers
> would never block readers or other writers.
>
> package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletionStage<BigInteger> ret = cache.get(n);
>
>       if (ret == null) {
>
>         final CompletableFuture<BigInteger> compute = new
> CompletableFuture<>();
>
>         ret = cache.putIfAbsent(n, compute);
>
>         if (ret == null)
>
>           ret = f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; },
> e), e);
>
>       }
>
>       return ret;
>
>     }
>
>   }
>
> 1: It's very much possible and recommended to not make the first
> thenCompose an async one, as only the addition of v and v2 might be
> "expensive" (for large additions).
>
>
>
> On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <
> Sebastian.Millies at softwareag.com> wrote:
>
> I?m not sure I?m getting it. What?s significant about putting that empty
> CF in as a placeholder first? That is, what is the advantage over writing
>
>
>
> public CompletionStage<BigInteger> f(int n) {
>
>   CompletionStage<BigInteger> prev = cache.get(n);
>
>   if (prev != null) {
>
>     return prev;
>
>   }
>
>   else {
>
>     return f(n - 1).thenCompose(x ->
>
>            f(n - 2).thenCompose(y -> {
>
>            CompletableFuture<BigInteger> next =
> CompletableFuture.completedFuture(x.add(y));
>
>            CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
>
>            return prev != null ? v : next;
>
>     }));
>
>   }
>
> }
>
>
>
> Is it that in Viktor?s code, only the thread that first has a cache miss
> calls the computation that will complete the future, while in the above
> code there may be multiple computations, only one of which will eventually
> contribute to the result? And would that consideration only apply to the
> async version?
>
>
>
> n  Sebastian
>
>
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dr Heinz M.
> Kabutz
> *Sent:* Saturday, April 23, 2016 7:31 AM
> *To:* Viktor Klang
> *Cc:* concurrency-interest
> *Subject:* Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on
> computeIfAbsent() ?
>
>
>
> Thanks so much Viktor for that code!  The part that I somehow missed was
> the empty CompletableFuture: CompletableFuture<BigInteger> next = new
> CompletableFuture<>();
>
> Very interesting indeed.
>
> Regards
>
>
>
> Heinz
>
> --
>
> Dr Heinz M. Kabutz (PhD CompSci)
>
> Author of "The Java(tm) Specialists' Newsletter"
>
> Sun/Oracle Java Champion since 2005
>
> JavaOne Rock Star Speaker 2012
>
> http://www.javaspecialists.eu
>
> Tel: +30 69 75 595 262
>
> Skype: kabutz
>
>
>
> Viktor Klang wrote:
>
> Heinz,
>
> There's also the option of going this route:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> {
> next.complete(v.add(v2)); return next; }));
>
>     }
>
>   }
>
>
>
>
>
> Add Executor parameter to `f` and switch to thenComposeAsync to be able to
> parallelize it.
>
> Also means that concurrent readers/writers won't block eachother
> (computeIfAbsent would do that for instance)
>
>
>
> ? la:
>
>
>
>   package livedemo;
>
>
>
>   import java.util.concurrent.*;
>
>   import java.math.BigInteger;
>
>   import java.util.Map;
>
>
>
>   public class FibonacciCached {
>
>     private final Map<Integer, CompletionStage<BigInteger>> cache;
>
>
>
>     public FibonacciCached(Map<Integer, CompletionStage<BigInteger>>
> cache) {
>
>       this.cache = cache;
>
>       cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
>
>       cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
>
>     }
>
>
>
>     public CompletionStage<BigInteger> f(int n, Executor e) {
>
>       CompletableFuture<BigInteger> next = new CompletableFuture<>();
>
>       CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
>
>       if (prev != null) return prev;
>
>       else
>
>         return f(n-1, e).thenComposeAsync(v -> f(n-2,
> e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e),
> e);
>
>     }
>
>   }
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
>
> ------------------------------
>
>
>
> _______________________________________________
>
> Concurrency-interest mailing list
>
> Concurrency-interest at cs.oswego.edu
>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
> Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt,
> Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 -
> Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman),
> Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; -
> Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas
> Bereczky - *http://www.softwareag.com* <http://www.softwareag.com>
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>
>
>
>
> --
>
> Cheers,
>
> ?
>



-- 
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/d41ee775/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Wed Apr 27 10:45:58 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Wed, 27 Apr 2016 14:45:58 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
	<CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>
	<CANPzfU-aAdVw5aTWAanGER_NgLRqoKyk_E6GCvuw-oXBrnFz=Q@mail.gmail.com> 
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E58AF3@HQMBX5.eur.ad.sag>

There is a thread dump on DropBox: https://www.dropbox.com/s/zy87bt4e7dzd099/threaddump-1461767854829.tdump?dl=0

Here?s some console output:

# JMH 1.12 (released 26 days ago)
# VM version: JDK 1.8.0_92, VM 25.92-b14
# VM invoker: C:\Program Files\Java\jdk1.8.0_92\jre\bin\java.exe
# VM options: -Dfile.encoding=UTF-8
# Warmup: 10 iterations, 1000 ms each
# Measurement: 20 iterations, 1000 ms each
# Timeout: 10 min per iteration
# Threads: 2 threads
# Benchmark mode: Single shot invocation time
# Benchmark: java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000

# Run progress: 0.00% complete, ETA 00:00:00
# Fork: 1 of 1
# Warmup Iteration   1: POOL_SIZE = 2


n  Sebastian

(PS: changed measurement mode to single shot, because only the first method call in each iteration would do any work, the rest would just be map lookups.)

From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Wednesday, April 27, 2016 3:21 PM
To: Millies, Sebastian
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Do you have a thread dump? (sorry, I don't have any spare cycles to have a stab at running it right now)

On Wed, Apr 27, 2016 at 3:09 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I have added https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889#file-fibcachedconcurrentbenchmark-java
to compute concurrent benchmarks of the 6000th Fibonacci number. Only the CF versions of course.

The same Fib is used by two threads in each case, the pool for the async version gets another two.

The bad news is they?re prone to  deadlock. Now I am no expert in JMH, perhaps it?s just the way I?ve set up the tests .(I hope so.)


?  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>]
Sent: Wednesday, April 27, 2016 10:22 AM
To: Millies, Sebastian
Cc: concurrency-interest; Henri Tremblay

Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks Sebastian,

(There's a thenComposeAsync missing in the async version.)

Could you augment the JMH test to attempt to use the same Fib from multiple threads to show how it behaves under contention? (this is where the simple-version breaks down as it isn't threadsafe)

I believe you'll also have to use larger values for fib to make sure that BigInteger.add gets a bit of exercise too :)


On Wed, Apr 27, 2016 at 9:20 AM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Hello Viktor,

as I don?t know if attachments are alright in this group, I have put the code and benchmark in a gist:
https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889


?  Sebastian

From: Viktor Klang [mailto:viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>]
Sent: Tuesday, April 26, 2016 5:34 PM
To: Millies, Sebastian
Cc: concurrency-interest; Henri Tremblay
Subject: RE: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?


Hi Sebastian!

(IMO) Async is neverr for performance, it is for scalability. (And resilience; Parallelization is for performance)

What does the scaling profile look for 1..N concurrent accesses?

And did you try using thenCompose iso. thenComposeAsync for the initial step?

Also, which executor did you use and using what config?

A lot of questions, I know!
--
Cheers,
?
On Apr 26, 2016 5:09 PM, "Millies, Sebastian" <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Yes, thank you very much,  very instructive. I wonder how expensive the asynchronous computation step must be to make it worthwhile speed-wise. When computing the 2000th Fibonacci number on my quadcore, at least, the asynchronous ?optimized? CF version performs 10 ? 20 times worse compared to single-threaded code using a memoizer  with a simple HashMap, such as the one posted by Andrew Haley in this thread.

?  Sebastian

From: Henri Tremblay [mailto:henri.tremblay at gmail.com<mailto:henri.tremblay at gmail.com>]
Sent: Monday, April 25, 2016 7:02 PM
To: Viktor Klang
Cc: Millies, Sebastian; concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Hi Viktor,

Thanks a lot for those examples. They are crystal clear demonstration of a nice CompletableFuture usage.

Really nice
Henri

On 23 April 2016 at 15:45, Viktor Klang <viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>> wrote:
Hi Sebastian,

I only provided the code as an alternate solution to using computeIfAbsent, for a more ?optimized?[1] version, see the snippet below.

If / when CHM becomes completely non-blocking, this would mean that readers would never block other readers nor other writers, and writers would never block readers or other writers.

package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletionStage<BigInteger> ret = cache.get(n);
      if (ret == null) {
        final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
        ret = cache.putIfAbsent(n, compute);
        if (ret == null)
          ret = f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { compute.complete(v.add(v2)); return compute; }, e), e);
      }
      return ret;
    }
  }
1: It's very much possible and recommended to not make the first thenCompose an async one, as only the addition of v and v2 might be "expensive" (for large additions).

On Sat, Apr 23, 2016 at 12:50 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I?m not sure I?m getting it. What?s significant about putting that empty CF in as a placeholder first? That is, what is the advantage over writing

public CompletionStage<BigInteger> f(int n) {
  CompletionStage<BigInteger> prev = cache.get(n);
  if (prev != null) {
    return prev;
  }
  else {
    return f(n - 1).thenCompose(x ->
           f(n - 2).thenCompose(y -> {
           CompletableFuture<BigInteger> next = CompletableFuture.completedFuture(x.add(y));
           CompletionStage<BigInteger> v = cache.putIfAbsent(n, next);
           return prev != null ? v : next;
    }));
  }
}

Is it that in Viktor?s code, only the thread that first has a cache miss calls the computation that will complete the future, while in the above code there may be multiple computations, only one of which will eventually contribute to the result? And would that consideration only apply to the async version?


?  Sebastian


From: concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu> [mailto:concurrency-interest-bounces at cs.oswego.edu<mailto:concurrency-interest-bounces at cs.oswego.edu>] On Behalf Of Dr Heinz M. Kabutz
Sent: Saturday, April 23, 2016 7:31 AM
To: Viktor Klang
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Thanks so much Viktor for that code!  The part that I somehow missed was the empty CompletableFuture: CompletableFuture<BigInteger> next = new CompletableFuture<>();

Very interesting indeed.

Regards



Heinz

--

Dr Heinz M. Kabutz (PhD CompSci)

Author of "The Java(tm) Specialists' Newsletter"

Sun/Oracle Java Champion since 2005

JavaOne Rock Star Speaker 2012

http://www.javaspecialists.eu

Tel: +30 69 75 595 262

Skype: kabutz


Viktor Klang wrote:
Heinz,

There's also the option of going this route:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1).thenCompose(v -> f(n-2).thenCompose(v2 -> { next.complete(v.add(v2)); return next; }));
    }
  }


Add Executor parameter to `f` and switch to thenComposeAsync to be able to parallelize it.
Also means that concurrent readers/writers won't block eachother (computeIfAbsent would do that for instance)

? la:

  package livedemo;

  import java.util.concurrent.*;
  import java.math.BigInteger;
  import java.util.Map;

  public class FibonacciCached {
    private final Map<Integer, CompletionStage<BigInteger>> cache;

    public FibonacciCached(Map<Integer, CompletionStage<BigInteger>> cache) {
      this.cache = cache;
      cache.put(0, CompletableFuture.completedFuture(BigInteger.ZERO));
      cache.put(1, CompletableFuture.completedFuture(BigInteger.ONE));
    }

    public CompletionStage<BigInteger> f(int n, Executor e) {
      CompletableFuture<BigInteger> next = new CompletableFuture<>();
      CompletionStage<BigInteger> prev = cache.putIfAbsent(n, next);
      if (prev != null) return prev;
      else
        return f(n-1, e).thenComposeAsync(v -> f(n-2, e).thenComposeAsync(v2 -> { next.complete(v.add(v2)); return next; }, e), e);
    }
  }


--
Cheers,
?



________________________________



_______________________________________________

Concurrency-interest mailing list

Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>

http://cs.oswego.edu/mailman/listinfo/concurrency-interest



Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com




--
Cheers,
?

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest




--
Cheers,
?



--
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160427/e2b9bc92/attachment-0001.html>

From Sebastian.Millies at softwareag.com  Thu Apr 28 04:38:43 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Thu, 28 Apr 2016 08:38:43 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU-aAdVw5aTWAanGER_NgLRqoKyk_E6GCvuw-oXBrnFz=Q@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
	<CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>
	<CANPzfU-aAdVw5aTWAanGER_NgLRqoKyk_E6GCvuw-oXBrnFz=Q@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E58D74@HQMBX5.eur.ad.sag>

Dropbox may not have been a good idea ? Here?s a thread-dump from deadlock in the cf6000Async benchmark:

2016-04-28 10:29:36
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.92-b14 mixed mode):

"java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000-jmh-worker-2" #14 daemon prio=5 os_prio=0 tid=0x000000001fc95800 nid=0x2418 waiting on condition [0x000000001f62e000]
   java.lang.Thread.State: WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076bc429b8> (a java.util.concurrent.CompletableFuture$Signaller)
                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
                at java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1693)
                at java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323)
                at java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1729)
                at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1934)
                at java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000(FibCachedConcurrentBenchmark.java:76)
                at java8.concurrent.generated.FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.cfAsync6000_ss_jmhStub(FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.java:490)
                at java8.concurrent.generated.FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.cfAsync6000_SingleShotTime(FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.java:433)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                at java.lang.reflect.Method.invoke(Method.java:498)
                at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:430)
                at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:412)
                at java.util.concurrent.FutureTask.run(FutureTask.java:266)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
                - <0x000000076b9cda18> (a java.util.concurrent.ThreadPoolExecutor$Worker)

"java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000-jmh-worker-1" #13 daemon prio=5 os_prio=0 tid=0x000000001fc94800 nid=0x2414 waiting on condition [0x000000001f3df000]
   java.lang.Thread.State: WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076b9517a0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
                at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
                at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
                at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
                - None

"Service Thread" #10 daemon prio=9 os_prio=0 tid=0x000000001d97d000 nid=0x2404 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C1 CompilerThread3" #9 daemon prio=9 os_prio=2 tid=0x000000001c71f000 nid=0x1cb0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread2" #8 daemon prio=9 os_prio=2 tid=0x000000001c71e000 nid=0x19cc waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread1" #7 daemon prio=9 os_prio=2 tid=0x000000001c71b000 nid=0x1d78 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread0" #6 daemon prio=9 os_prio=2 tid=0x000000001d8db000 nid=0xfec waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x000000001d8d9800 nid=0x200c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000001d8d8000 nid=0x620 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x000000001c711000 nid=0x10a4 in Object.wait() [0x000000001ec7f000]
   java.lang.Thread.State: WAITING (on object monitor)
                at java.lang.Object.wait(Native Method)
                - waiting on <0x000000076b208ee0> (a java.lang.ref.ReferenceQueue$Lock)
                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
                - locked <0x000000076b208ee0> (a java.lang.ref.ReferenceQueue$Lock)
                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
                at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

   Locked ownable synchronizers:
                - None

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000000001c70a000 nid=0x1b48 in Object.wait() [0x000000001e91f000]
   java.lang.Thread.State: WAITING (on object monitor)
                at java.lang.Object.wait(Native Method)
                - waiting on <0x000000076b206b50> (a java.lang.ref.Reference$Lock)
                at java.lang.Object.wait(Object.java:502)
                at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
                - locked <0x000000076b206b50> (a java.lang.ref.Reference$Lock)
                at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

   Locked ownable synchronizers:
                - None

"main" #1 prio=5 os_prio=0 tid=0x000000000020f800 nid=0x1e14 waiting on condition [0x0000000002b1e000]
   java.lang.Thread.State: TIMED_WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076b9cd9f8> (a java.util.concurrent.FutureTask)
                at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
                at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:426)
                at java.util.concurrent.FutureTask.get(FutureTask.java:204)
                at org.openjdk.jmh.runner.BenchmarkHandler.runIteration(BenchmarkHandler.java:376)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmark(BaseRunner.java:263)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmark(BaseRunner.java:235)
                at org.openjdk.jmh.runner.BaseRunner.doSingle(BaseRunner.java:142)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmarksForked(BaseRunner.java:76)
                at org.openjdk.jmh.runner.ForkedRunner.run(ForkedRunner.java:72)
                at org.openjdk.jmh.runner.ForkedMain.main(ForkedMain.java:84)

   Locked ownable synchronizers:
                - None

"VM Thread" os_prio=2 tid=0x000000001c701000 nid=0x2038 runnable

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x000000000266e800 nid=0x1ba0 runnable

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x0000000002670000 nid=0x4a0 runnable

"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x0000000002671800 nid=0xfb4 runnable

"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x0000000002673000 nid=0x1b8 runnable

"GC task thread#4 (ParallelGC)" os_prio=0 tid=0x0000000002676800 nid=0x1168 runnable

"GC task thread#5 (ParallelGC)" os_prio=0 tid=0x0000000002677800 nid=0xa84 runnable

"GC task thread#6 (ParallelGC)" os_prio=0 tid=0x000000000267b000 nid=0x17dc runnable

"GC task thread#7 (ParallelGC)" os_prio=0 tid=0x000000000267c000 nid=0x2090 runnable

"VM Periodic Task Thread" os_prio=2 tid=0x000000001d981800 nid=0x2408 waiting on condition

JNI global references: 334


From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Wednesday, April 27, 2016 3:21 PM
To: Millies, Sebastian
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Do you have a thread dump? (sorry, I don't have any spare cycles to have a stab at running it right now)

On Wed, Apr 27, 2016 at 3:09 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I have added https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889#file-fibcachedconcurrentbenchmark-java
to compute concurrent benchmarks of the 6000th Fibonacci number. Only the CF versions of course.

The same Fib is used by two threads in each case, the pool for the async version gets another two.

The bad news is they?re prone to  deadlock. Now I am no expert in JMH, perhaps it?s just the way I?ve set up the tests .(I hope so.)


?  Sebastian


Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160428/b921e7af/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Apr 28 10:58:27 2016
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 28 Apr 2016 15:58:27 +0100
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
	<CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
	<DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
Message-ID: <07BA27AF-DD47-4156-9F53-A223CCD97ECD@gmail.com>

It seems insane to pass MAX_VALUE or MAX_VALUE/2 where the caller means ?forever?. Use the call without the timeout, that?s what they are for. Them behaving in (observably) the same way as the timed waits with MAX_VALUE passed in, is an implementation detail. Passing a value that has the intended meaning is the caller responsibility.

Alex

> On 20 Apr 2016, at 20:26, Justin Sampson <jsampson at guidewire.com> wrote:
> 
> Peter, I had exactly the same funny feeling as you when I first saw
> this idiom. A few years back, Martin changed some of my timing code
> in Guava's Monitor class from something like this:
> 
>  long timeoutNanos = unit.toNanos(time);
>  long startNanos = System.nanoTime();
>  ...
>  long remainingNanos =
>      timeoutNanos - (System.nanoTime() - startNanos);
> 
> to something like this:
> 
>  long timeoutNanos = unit.toNanos(time);
>  long deadline = System.nanoTime() + timeoutNanos;
>  ...
>  long remainingNanos = deadline - System.nanoTime();
> 
> At first I thought that this would introduce some kind of overflow
> error with MAX_VALUE, but I wrote a unit test for it and it passed!
> Only then did I realize that these two constructs are exactly
> identical in runtime behavior due to the arithmetic wraparound of
> long values. Any overflow bugs triggered by one would have been
> triggered by the other just as well.
> 
> (For anyone who thinks MAX_VALUE isn't interesting because it's a
> centuries-long timeout, consider someone passing MAX_VALUE into an
> API with the intention of "actually, don't timeout this call." If
> there were an arithmetic overflow bug that caused it to, say,
> timeout immediately instead of never, that would be a very
> noticeable and reproducible issue.)
> 
> Now, that's not quite the end of the story. It turns out that
> there's no overflow bug for MAX_VALUE as long as nanoTime() actually
> progresses forward, but there IS an overflow bug for MIN_VALUE, and
> there IS an overflow bug for MAX_VALUE if nanoTime() ever goes
> backward.
> 
> For the MIN_VALUE case, consider for simplicity that the first call
> to nanoTime() returns 0 and the second call returns 1. Then with
> either of the constructs above, remainingNanos ends up equal to
> MIN_VALUE-1, which is actually MAX_VALUE. Without additional guard
> clauses, that could result in blocking forever rather than not at
> all, which is what MIN_VALUE should mean (as with any non-positive
> timeout). The fix is simply to check for time <= 0 before doing any
> of these calculations, but this bug has actually slipped into the
> some parts of the JDK before -- and all my testing and agonizing
> over Martin's change in Guava helped find and fix one or two such
> cases in the JDK! :)
> 
> For the MAX_VALUE case, there's only an overflow bug if nanoTime()
> goes backward, causing some negative value to be subtracted from
> MAX_VALUE in the code above. That should never happen in HotSpot,
> but there have been occasional bugs and experimental "optimizations"
> in other JVMs that allow it to be seen. JDK code is NOT written to
> be robust to that possibility, which would slightly complicate the
> code everywhere that a timeout is checked.
> 
> There is ONE remaining overflow situation that we really can't do
> anything about: When the elapsed time between two calls to
> nanoTime() actually exceeds 2^63-1. I'm personally willing to ignore
> that one!
> 
> Cheers,
> Justin
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From jh at squareup.com  Thu Apr 28 14:13:12 2016
From: jh at squareup.com (Josh Humphries)
Date: Thu, 28 Apr 2016 14:13:12 -0400
Subject: [concurrency-interest] deadline and long overflow
In-Reply-To: <07BA27AF-DD47-4156-9F53-A223CCD97ECD@gmail.com>
References: <CAGuAWdDs1bCFaNvz29=-Xr7u0G9T8RkczGCK2ju9C2FQhEkfHQ@mail.gmail.com>
	<8B8E9452-3BCD-43D3-8EA7-E28DC32E6E5B@gmail.com>
	<57177B73.2020508@cs.oswego.edu>
	<CAGuAWdDtiyAbGKeLTwwkt_EAA3bfHC=h9tQ=q2KtV-gPc+iG4Q@mail.gmail.com>
	<CA+kOe090BrOF=JXW7xeHEXLLueHHDsSffLNzOfqsL8EhzxvyOQ@mail.gmail.com>
	<DM2PR05MB686F7894B3F4EBE6749B8A9D16D0@DM2PR05MB686.namprd05.prod.outlook.com>
	<07BA27AF-DD47-4156-9F53-A223CCD97ECD@gmail.com>
Message-ID: <CAHJZN-v4-FNN3mov-1o5B_eYHQOJkJKfhj=_XG7yPUceM+v6nA@mail.gmail.com>

This isn't always an option. For example, ExecutorService#awaitTermination
has no such overload.

----
*Josh Humphries*
Manager, Shared Systems  |  Platform Engineering
Atlanta, GA  |  678-400-4867
*Square* (www.squareup.com)

On Thu, Apr 28, 2016 at 10:58 AM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> It seems insane to pass MAX_VALUE or MAX_VALUE/2 where the caller means
> ?forever?. Use the call without the timeout, that?s what they are for. Them
> behaving in (observably) the same way as the timed waits with MAX_VALUE
> passed in, is an implementation detail. Passing a value that has the
> intended meaning is the caller responsibility.
>
> Alex
>
> > On 20 Apr 2016, at 20:26, Justin Sampson <jsampson at guidewire.com> wrote:
> >
> > Peter, I had exactly the same funny feeling as you when I first saw
> > this idiom. A few years back, Martin changed some of my timing code
> > in Guava's Monitor class from something like this:
> >
> >  long timeoutNanos = unit.toNanos(time);
> >  long startNanos = System.nanoTime();
> >  ...
> >  long remainingNanos =
> >      timeoutNanos - (System.nanoTime() - startNanos);
> >
> > to something like this:
> >
> >  long timeoutNanos = unit.toNanos(time);
> >  long deadline = System.nanoTime() + timeoutNanos;
> >  ...
> >  long remainingNanos = deadline - System.nanoTime();
> >
> > At first I thought that this would introduce some kind of overflow
> > error with MAX_VALUE, but I wrote a unit test for it and it passed!
> > Only then did I realize that these two constructs are exactly
> > identical in runtime behavior due to the arithmetic wraparound of
> > long values. Any overflow bugs triggered by one would have been
> > triggered by the other just as well.
> >
> > (For anyone who thinks MAX_VALUE isn't interesting because it's a
> > centuries-long timeout, consider someone passing MAX_VALUE into an
> > API with the intention of "actually, don't timeout this call." If
> > there were an arithmetic overflow bug that caused it to, say,
> > timeout immediately instead of never, that would be a very
> > noticeable and reproducible issue.)
> >
> > Now, that's not quite the end of the story. It turns out that
> > there's no overflow bug for MAX_VALUE as long as nanoTime() actually
> > progresses forward, but there IS an overflow bug for MIN_VALUE, and
> > there IS an overflow bug for MAX_VALUE if nanoTime() ever goes
> > backward.
> >
> > For the MIN_VALUE case, consider for simplicity that the first call
> > to nanoTime() returns 0 and the second call returns 1. Then with
> > either of the constructs above, remainingNanos ends up equal to
> > MIN_VALUE-1, which is actually MAX_VALUE. Without additional guard
> > clauses, that could result in blocking forever rather than not at
> > all, which is what MIN_VALUE should mean (as with any non-positive
> > timeout). The fix is simply to check for time <= 0 before doing any
> > of these calculations, but this bug has actually slipped into the
> > some parts of the JDK before -- and all my testing and agonizing
> > over Martin's change in Guava helped find and fix one or two such
> > cases in the JDK! :)
> >
> > For the MAX_VALUE case, there's only an overflow bug if nanoTime()
> > goes backward, causing some negative value to be subtracted from
> > MAX_VALUE in the code above. That should never happen in HotSpot,
> > but there have been occasional bugs and experimental "optimizations"
> > in other JVMs that allow it to be seen. JDK code is NOT written to
> > be robust to that possibility, which would slightly complicate the
> > code everywhere that a timeout is checked.
> >
> > There is ONE remaining overflow situation that we really can't do
> > anything about: When the elapsed time between two calls to
> > nanoTime() actually exceeds 2^63-1. I'm personally willing to ignore
> > that one!
> >
> > Cheers,
> > Justin
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160428/b0c643c5/attachment.html>

From gergg at cox.net  Fri Apr 29 20:38:33 2016
From: gergg at cox.net (Gregg Wonderly)
Date: Fri, 29 Apr 2016 19:38:33 -0500
Subject: [concurrency-interest] For those of us who bench on Linux
In-Reply-To: <nLsU1s00W02hR0p01LsXa3>
References: <CANPzfU9KAyHip0Q8pcGos-KQX9rc=tirO703wTTeQyRNcYPhQg@mail.gmail.com>
	<CANPzfU-NPteek-U6NAq1gTx898NscbkcM-=-y-nSUGRMaG83eQ@mail.gmail.com>
	<CANPzfU_NdmZbrifRZtaiOVes5sviZsfgUV99SY2LxwE2HxNqaA@mail.gmail.com>
	<CANPzfU9Q7+nm1igMvBaGCGdgOxuAPMD7Yy3h7paN1t9aSGePgw@mail.gmail.com>
	<nLsU1s00W02hR0p01LsXa3>
Message-ID: <CB5B21BC-11F6-46D3-B13F-769A8C77F54C@cox.net>

There are so many pieces of the processor usability visible to software.  The optimizations that used to be simple are now very complex to get right.  It would be great to see the processors managing cores as virtual entities to do power management for us.

Gregg

Sent from my iPhone

> On Apr 27, 2016, at 3:50 AM, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> Very interesting. In particular that scheduling affinity (to take advantage of a warm cache) can be a performance hit.
>  
> Thanks for the link.
>  
> David
>  
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Viktor Klang
> Sent: Wednesday, April 27, 2016 5:24 PM
> To: concurrency-interest <concurrency-interest at cs.oswego.edu>
> Subject: [concurrency-interest] For those of us who bench on Linux
>  
> TL;DR: problems found and fixed with Linux scheduler affecting multicore systems.
> 
> Story & paper: https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/
> 
> Code: https://github.com/jplozi/wastedcores
> 
> Would love to hear your thoughts.
> 
> -- 
> Cheers,
> ?
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160429/6f5d8996/attachment.html>

From Sebastian.Millies at softwareag.com  Sat Apr 30 17:18:58 2016
From: Sebastian.Millies at softwareag.com (Millies, Sebastian)
Date: Sat, 30 Apr 2016 21:18:58 +0000
Subject: [concurrency-interest] ConcurrentHashMapV8 Livelock on
 computeIfAbsent() ?
In-Reply-To: <CANPzfU9FMXDqF6BLzor7awmJE5+MD5UrvCdPC0uiyrjCOV9n8g@mail.gmail.com>
References: <5715E8DA.8020403@javaspecialists.eu>
	<CAGu0=MN-qrM46acU=dgNJXdMmLWNejMHrYZPELXbT2SJBJe24g@mail.gmail.com>
	<5715FBF8.80307@javaspecialists.eu> <5716192D.4090601@cs.oswego.edu>
	<6701E505-7F1F-4364-B3E1-39A8C2EB554B@sics.se>
	<5717759C.1010100@cs.oswego.edu>
	<CANPzfU9b7ikXOKJcuMO-PV8unLzkEN4rx94vYr9obXuPu8n9eA@mail.gmail.com>
	<571B0884.1010706@javaspecialists.eu>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E576AE@HQMBX5.eur.ad.sag>
	<CANPzfU91BD4DxWRajFL-AANOYVk_fSqRfThhe2PV2zoWQ6sxcQ@mail.gmail.com>
	<CADZL2=u9z3kY+YaYKDSnAX0-Pbn+6x1H_-E-Czn4FQ8xV1poyw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E584D1@HQMBX5.eur.ad.sag>
	<CANPzfU8QrjHQUikwhvrC-P0=myu5cXzmsUKpE31gWpFP+jCFgw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E587A2@HQMBX5.eur.ad.sag>
	<CANPzfU9xnbiTnEbsmUGa7=u0zw+EtY6t5LUGYMMzvzkxzTyeSw@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E58A89@HQMBX5.eur.ad.sag>
	<CANPzfU-aAdVw5aTWAanGER_NgLRqoKyk_E6GCvuw-oXBrnFz=Q@mail.gmail.com>
	<32F15738E8E5524DA4F01A0FA4A8E4900102E58D74@HQMBX5.eur.ad.sag>
	<CANPzfU9FMXDqF6BLzor7awmJE5+MD5UrvCdPC0uiyrjCOV9n8g@mail.gmail.com>
Message-ID: <32F15738E8E5524DA4F01A0FA4A8E4900102E59C73@HQMBX5.eur.ad.sag>

Hi Viktor,

I?m sorry, I?ve made a mistake: there hasn?t been a deadlock at all. When running the JMH benchmark, I don?t get as much stack space as when running stand-alone, so the recursion depth of 6000 was causing a StackoverflowError. However, I didn?t see that error, it was hidden by JMH, I just saw the benchmark hanging and the JMH worker threads all being parked, and jumped to the wrong conclusion.

Anyway, computing the 3500th Fibonacci number, I consistently do not see any advantage of the async version over the synchronous one. In fact, it is the other way around:

2 Threads
Benchmark                                 Mode  Cnt  Score     Error  Units
FibCachedConcurrentBenchmark.cf3500         ss   20   4.132 ?  1.421  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20   9.134 ?  0.862  ms/op
FibCachedConcurrentBenchmark.cf3500         ss   20   2.887 ?  0.571  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20  10.345 ? 12.954  ms/op
FibCachedConcurrentBenchmark.cf3500         ss   20   3.500 ?  1.291  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20   8.803 ?  1.679  ms/op

4 Threads
Benchmark                                 Mode  Cnt  Score   Error  Units
FibCachedConcurrentBenchmark.cf3500         ss   20  2.780 ? 0.430  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20  8.850 ? 1.595  ms/op
FibCachedConcurrentBenchmark.cf3500         ss   20  3.034 ? 0.451  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20  9.744 ? 1.669  ms/op
FibCachedConcurrentBenchmark.cf3500         ss   20  3.965 ? 1.380  ms/op
FibCachedConcurrentBenchmark.cfAsync3500    ss   20  8.430 ? 2.396  ms/op

Perhaps adding to BigIntegers just isn?t expensive enough to warrant the overhead of going async.


n  Sebastian

PS: Your code below I think doesn?t address the problem, namely as you suggested ?to use the same Fib from multiple threads to show how it behaves under contention?. Your test(int) method below produces a new CF instance for each thread, so there is no contention. Or does it?


From: Viktor Klang [mailto:viktor.klang at gmail.com]
Sent: Friday, April 29, 2016 5:59 PM
To: Millies, Sebastian
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Hi Sebastian,

could it be a thread-pool issue?

This works just fine for me:


package yava.klang;

import java.math.BigInteger;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.Executor;
import java.util.function.Function;

/**
 * Demonstrates ways of caching recursive functions.
 *
 * @author Andrew Haley, Viktor Klang, Sebastian Millies
 * @see triggered by <a href=
 *      "http://concurrency.markmail.org/search/?q=#query:%20list%3Aedu.oswego.cs.concurrency-interest+page:3+mid:tf7xddfa6i6ow6d3+state:results">
 *      this discussion</a> on concurrency-interest
 *
 */
public class FibCached {

    private static class Memoizer<T, R> {
        private final Map<T, R> memo;

        public Memoizer(Map<T, R> memo) {
            this.memo = memo;
        }

        public Function<T, R> memoize(Function<T, R> f) {
            return t -> {
                            R r = memo.get(t);
                            if (r == null) {
                                r = f.apply(t);
                                memo.put(t, r);
                            }
                            return r;
                        };
        }
    }

    public static class FibonacciSimple {
        private final Memoizer<Integer, BigInteger> m;

        public FibonacciSimple(Map<Integer, BigInteger> cache) {
            m = new Memoizer<>(cache);
        }

        public BigInteger fib(int n) {
            if (n <= 2) return BigInteger.ONE;
            return m.memoize(this::fib).apply(n - 1).add(
                   m.memoize(this::fib).apply(n - 2));
        }
    }

    public static class CF {
        private final static CompletionStage<BigInteger> csOne = CompletableFuture.completedFuture(BigInteger.ONE);
        private final Map<Integer, CompletionStage<BigInteger>> cache;

        public CF(Map<Integer, CompletionStage<BigInteger>> cache) {
            this.cache = cache;
        }

        public CompletionStage<BigInteger> fib(int n) {
            if (n <= 2) return csOne;

            CompletionStage<BigInteger> ret = cache.get(n);
            if (ret == null) {
                final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
                ret = cache.putIfAbsent(n, compute);
                if (ret == null) {
                    ret = fib(n - 1).thenCompose(x ->
                          fib(n - 2).thenCompose(y -> {
                                compute.complete(x.add(y));
                                return compute;
                    }));
                }
            }
            return ret;
        }

        // async version. It's very much possible and recommended to not make the first thenCompose an async one,
        // as only the addition of x and y might be "expensive" (for large values).
        public CompletionStage<BigInteger> fib(int n, Executor e) {
            if (n <= 2) return csOne;

            CompletionStage<BigInteger> ret = cache.get(n);
            if (ret == null) {
                final CompletableFuture<BigInteger> compute = new CompletableFuture<>();
                ret = cache.putIfAbsent(n, compute);
                if (ret == null) {
                    ret = fib(n - 1, e).thenComposeAsync(x ->
                          fib(n - 2, e).thenComposeAsync(y -> {
                                compute.complete(x.add(y));
                                return compute;
                    }, e));
                }
            }
            return ret;
        }
    }

    public static CompletionStage<BigInteger> test(final int n) {
        final CF fib = new CF(new ConcurrentHashMap<>());
        return fib.fib(n, ForkJoinPool.commonPool());
    }

}

On Thu, Apr 28, 2016 at 10:38 AM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
Dropbox may not have been a good idea ? Here?s a thread-dump from deadlock in the cf6000Async benchmark:

2016-04-28 10:29:36
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.92-b14 mixed mode):

"java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000-jmh-worker-2" #14 daemon prio=5 os_prio=0 tid=0x000000001fc95800 nid=0x2418 waiting on condition [0x000000001f62e000]
   java.lang.Thread.State: WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076bc429b8> (a java.util.concurrent.CompletableFuture$Signaller)
                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
                at java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1693)
                at java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323)
                at java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1729)
                at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1934)
                at java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000(FibCachedConcurrentBenchmark.java:76)
                at java8.concurrent.generated.FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.cfAsync6000_ss_jmhStub(FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.java:490)
                at java8.concurrent.generated.FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.cfAsync6000_SingleShotTime(FibCachedConcurrentBenchmark_cfAsync6000_jmhTest.java:433)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                at java.lang.reflect.Method.invoke(Method.java:498)
                at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:430)
                at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:412)
                at java.util.concurrent.FutureTask.run(FutureTask.java:266)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
                - <0x000000076b9cda18> (a java.util.concurrent.ThreadPoolExecutor$Worker)

"java8.concurrent.FibCachedConcurrentBenchmark.cfAsync6000-jmh-worker-1" #13 daemon prio=5 os_prio=0 tid=0x000000001fc94800 nid=0x2414 waiting on condition [0x000000001f3df000]
   java.lang.Thread.State: WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076b9517a0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
                at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
                at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
                at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
                - None

"Service Thread" #10 daemon prio=9 os_prio=0 tid=0x000000001d97d000 nid=0x2404 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C1 CompilerThread3" #9 daemon prio=9 os_prio=2 tid=0x000000001c71f000 nid=0x1cb0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread2" #8 daemon prio=9 os_prio=2 tid=0x000000001c71e000 nid=0x19cc waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread1" #7 daemon prio=9 os_prio=2 tid=0x000000001c71b000 nid=0x1d78 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"C2 CompilerThread0" #6 daemon prio=9 os_prio=2 tid=0x000000001d8db000 nid=0xfec waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x000000001d8d9800 nid=0x200c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000001d8d8000 nid=0x620 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
                - None

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x000000001c711000 nid=0x10a4 in Object.wait() [0x000000001ec7f000]
   java.lang.Thread.State: WAITING (on object monitor)
                at java.lang.Object.wait(Native Method)
                - waiting on <0x000000076b208ee0> (a java.lang.ref.ReferenceQueue$Lock)
                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
                - locked <0x000000076b208ee0> (a java.lang.ref.ReferenceQueue$Lock)
                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
                at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

   Locked ownable synchronizers:
                - None

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000000001c70a000 nid=0x1b48 in Object.wait() [0x000000001e91f000]
   java.lang.Thread.State: WAITING (on object monitor)
                at java.lang.Object.wait(Native Method)
                - waiting on <0x000000076b206b50> (a java.lang.ref.Reference$Lock)
                at java.lang.Object.wait(Object.java:502)
                at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
                - locked <0x000000076b206b50> (a java.lang.ref.Reference$Lock)
                at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

   Locked ownable synchronizers:
                - None

"main" #1 prio=5 os_prio=0 tid=0x000000000020f800 nid=0x1e14 waiting on condition [0x0000000002b1e000]
   java.lang.Thread.State: TIMED_WAITING (parking)
                at sun.misc.Unsafe.park(Native Method)
                - parking to wait for  <0x000000076b9cd9f8> (a java.util.concurrent.FutureTask)
                at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
                at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:426)
                at java.util.concurrent.FutureTask.get(FutureTask.java:204)
                at org.openjdk.jmh.runner.BenchmarkHandler.runIteration(BenchmarkHandler.java:376)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmark(BaseRunner.java:263)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmark(BaseRunner.java:235)
                at org.openjdk.jmh.runner.BaseRunner.doSingle(BaseRunner.java:142)
                at org.openjdk.jmh.runner.BaseRunner.runBenchmarksForked(BaseRunner.java:76)
                at org.openjdk.jmh.runner.ForkedRunner.run(ForkedRunner.java:72)
                at org.openjdk.jmh.runner.ForkedMain.main(ForkedMain.java:84)

   Locked ownable synchronizers:
                - None

"VM Thread" os_prio=2 tid=0x000000001c701000 nid=0x2038 runnable

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x000000000266e800 nid=0x1ba0 runnable

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x0000000002670000 nid=0x4a0 runnable

"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x0000000002671800 nid=0xfb4 runnable

"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x0000000002673000 nid=0x1b8 runnable

"GC task thread#4 (ParallelGC)" os_prio=0 tid=0x0000000002676800 nid=0x1168 runnable

"GC task thread#5 (ParallelGC)" os_prio=0 tid=0x0000000002677800 nid=0xa84 runnable

"GC task thread#6 (ParallelGC)" os_prio=0 tid=0x000000000267b000 nid=0x17dc runnable

"GC task thread#7 (ParallelGC)" os_prio=0 tid=0x000000000267c000 nid=0x2090 runnable

"VM Periodic Task Thread" os_prio=2 tid=0x000000001d981800 nid=0x2408 waiting on condition

JNI global references: 334


From: Viktor Klang [mailto:viktor.klang at gmail.com<mailto:viktor.klang at gmail.com>]
Sent: Wednesday, April 27, 2016 3:21 PM
To: Millies, Sebastian
Cc: concurrency-interest
Subject: Re: [concurrency-interest] ConcurrentHashMapV8 Livelock on computeIfAbsent() ?

Do you have a thread dump? (sorry, I don't have any spare cycles to have a stab at running it right now)

On Wed, Apr 27, 2016 at 3:09 PM, Millies, Sebastian <Sebastian.Millies at softwareag.com<mailto:Sebastian.Millies at softwareag.com>> wrote:
I have added https://gist.github.com/smillies/0cceb17501f74c4f53bf4930eba61889#file-fibcachedconcurrentbenchmark-java
to compute concurrent benchmarks of the 6000th Fibonacci number. Only the CF versions of course.

The same Fib is used by two threads in each case, the pool for the async version gets another two.

The bad news is they?re prone to  deadlock. Now I am no expert in JMH, perhaps it?s just the way I?ve set up the tests .(I hope so.)


?  Sebastian


Software AG ? Sitz/Registered office: Uhlandstra?e 12, 64297 Darmstadt, Germany ? Registergericht/Commercial register: Darmstadt HRB 1562 - Vorstand/Management Board: Karl-Heinz Streibich (Vorsitzender/Chairman), Eric Duffaut, Dr. Wolfram Jost, Arnd Zinnhardt; - Aufsichtsratsvorsitzender/Chairman of the Supervisory Board: Dr. Andreas Bereczky - http://www.softwareag.com




--
Cheers,
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20160430/1768c738/attachment-0001.html>

