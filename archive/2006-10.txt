From syg6 at yahoo.com  Mon Oct  2 11:45:18 2006
From: syg6 at yahoo.com (Robert Bowen)
Date: Mon, 2 Oct 2006 08:45:18 -0700 (PDT)
Subject: [concurrency-interest] How to use Callable instead of Runnable with
	ScheduledThreadPoolExecutor?
Message-ID: <20061002154518.85083.qmail@web37705.mail.mud.yahoo.com>

Hello concurrent people,

I have been futzing around with the Java 1.5 concurrent classes for a while now and more or less have the hang of things. But there is one thing I can't figure out. I'd like to schedule a task to execute every x seconds, have it return me a list of Futures for those tasks and, based on the result in each Future, do something.

I'd like to use either scheduleAtFixedRate() or scheduleWithFixedDelay() but both of these take Runnable as their first parameter, and I'd like to use a Callable (to get a Result). I see that schedule() and submit() both take Callable as a parameter but that's for a one-shot execution, I need something periodic.

Any way to do this?

Many thanks guys,
Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061002/2228490a/attachment.html 

From tim at peierls.net  Mon Oct  2 12:17:48 2006
From: tim at peierls.net (Tim Peierls)
Date: Mon, 2 Oct 2006 12:17:48 -0400
Subject: [concurrency-interest] How to use Callable instead of Runnable
	with ScheduledThreadPoolExecutor?
In-Reply-To: <20061002154518.85083.qmail@web37705.mail.mud.yahoo.com>
References: <20061002154518.85083.qmail@web37705.mail.mud.yahoo.com>
Message-ID: <63b4e4050610020917n5a6f09acv685e3ce48d61718f@mail.gmail.com>

It's hard to see how to make this work. Would you expect to receive the list
of Futures upon submission of the periodic task? In what order would you
wait for the results?

Instead, why not use a callback style?

interface PeriodicTaskListener<T> {
    void resultReturned(T result);
    void exceptionThrown(Exception exception);
}

class PeriodicTask<T> implements Runnable {
    private final Callable<T> callable;
    private final PeriodicTaskListener<T> listener;

    PeriodicTask(Callable<T> callable,
                 PeriodicTaskListener<T> listener) {
        this.callable = callable;
        this.listener = listener;
    }

    public void run() {
        try {
            listener.resultReturned(callable.call());
        } catch (Exception e) {
            listener.exceptionThrown(e);
        }
    }
}

Then you can use it like this:

scheduledThreadPool.scheduleAtFixedRate(new PeriodicTask<Long>(
    new Callable<Long>() {
        public Long call() throws Exception {
            ... compute some value ...
        }
    },
    new PeriodicTaskListener<Long>() {
        public void resultReturned(Long result) {
            ... do something with result ...
        }
        public void exceptionThrown(Exception ex) {
            ... do something about ex ...
        }
    },
    5L, 5L, TimeUnit.SECONDS // every five seconds
));

--tim

On 10/2/06, Robert Bowen <syg6 at yahoo.com> wrote:
>
> Hello concurrent people,
>
> I have been futzing around with the Java 1.5 concurrent classes for a
> while now and more or less have the hang of things. But there is one thing I
> can't figure out. I'd like to schedule a task to execute every x seconds,
> have it return me a list of Futures for those tasks and, based on the result
> in each Future, do something.
>
> I'd like to use either scheduleAtFixedRate() or scheduleWithFixedDelay()but both of these take Runnable as their first parameter, and I'd like to
> use a Callable (to get a Result). I see that schedule() and submit() both
> take Callable as a parameter but that's for a one-shot execution, I need
> something periodic.
>
> Any way to do this?
>
> Many thanks guys,
> Bob
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061002/43bf6714/attachment.html 

From david at walend.net  Wed Oct  4 09:13:02 2006
From: david at walend.net (David Walend)
Date: Wed, 4 Oct 2006 09:13:02 -0400
Subject: [concurrency-interest] PriorityBlockingQueue question
In-Reply-To: <63b4e4050609260811s7d82dd14o9707d799444742d2@mail.gmail.com>
References: <385F5ACD-A953-4C1D-B2FE-6FD1B07BA5F8@walend.net>
	<45183CE8.1040302@it.edu>
	<0C9DDA6E-95BD-4B39-9C67-7EDF5D0262B8@walend.net>
	<63b4e4050609260735t1cce80bag54c79a2f8a55d208@mail.gmail.com>
	<63b4e4050609260811s7d82dd14o9707d799444742d2@mail.gmail.com>
Message-ID: <D78006E3-BD9D-47EF-8AD9-25AE0DCC98E6@walend.net>


On Sep 26, 2006, at 11:11 AM, Tim Peierls wrote:

> On 9/26/06, Tim Peierls <tim at peierls.net> wrote:
> No ideas for this -- I'm thinking about the other approach.
>
> What if you maintained a separate queue for each selector and  
> atomically marked messages when consumed? (You could use  
> AtomicMarkableReference.attemptMark, for example.) Then you don't  
> have the problem of having to remove a message from all other  
> queues, since receivers can simply ignore messages that someone  
> else marked.

Thanks for the suggestion, Tim.

See https://somnifugijms.dev.java.net/source/browse/somnifugijms/v3/ 
source/somnifugi/net/walend/somnifugi/juc/ 
MessageSelectingPriorityBlockingQueue.java?rev=1.3&view=auto&content- 
type=text/vnd.viewcvs-markup for a new version.

I like this one a lot. JMS QueueSenders handle the message selector  
workings inside offer(). JMS QueueReceivers with no message selector  
(and will use the ALLMESSAGESELECTOR) will have something close to  
PBQ performance. QueueReceivers with messages selectors will still  
have to do a PBQ scan in the remove() method, but that's the only  
disappointing thing. Everything else should be very live.

Thanks again for the help. Please let me know if you see any problems  
when you flip through the code.

Dave

David Walend
david at walend.net



From tim at peierls.net  Wed Oct  4 10:06:53 2006
From: tim at peierls.net (Tim Peierls)
Date: Wed, 4 Oct 2006 10:06:53 -0400
Subject: [concurrency-interest] PriorityBlockingQueue question
In-Reply-To: <D78006E3-BD9D-47EF-8AD9-25AE0DCC98E6@walend.net>
References: <385F5ACD-A953-4C1D-B2FE-6FD1B07BA5F8@walend.net>
	<45183CE8.1040302@it.edu>
	<0C9DDA6E-95BD-4B39-9C67-7EDF5D0262B8@walend.net>
	<63b4e4050609260735t1cce80bag54c79a2f8a55d208@mail.gmail.com>
	<63b4e4050609260811s7d82dd14o9707d799444742d2@mail.gmail.com>
	<D78006E3-BD9D-47EF-8AD9-25AE0DCC98E6@walend.net>
Message-ID: <63b4e4050610040706t2bd31ab4o5dc47286d48ef896@mail.gmail.com>

I had time for a quick scan only right now. I noticed a lock.lock()/unlock()
pair that doesn't match the "approved" pattern: in
getQueueForMessageSelector. Since you aren't using lockInterruptibly or any
of the other features of RL, why not just use synchronized?

--tim

On 10/4/06, David Walend <david at walend.net> wrote:
>
>
> On Sep 26, 2006, at 11:11 AM, Tim Peierls wrote:
>
> > On 9/26/06, Tim Peierls <tim at peierls.net> wrote:
> > No ideas for this -- I'm thinking about the other approach.
> >
> > What if you maintained a separate queue for each selector and
> > atomically marked messages when consumed? (You could use
> > AtomicMarkableReference.attemptMark, for example.) Then you don't
> > have the problem of having to remove a message from all other
> > queues, since receivers can simply ignore messages that someone
> > else marked.
>
> Thanks for the suggestion, Tim.
>
> See https://somnifugijms.dev.java.net/source/browse/somnifugijms/v3/
> source/somnifugi/net/walend/somnifugi/juc/
> MessageSelectingPriorityBlockingQueue.java?rev=1.3&view=auto&content-
> type=text/vnd.viewcvs-markup for a new version.
>
> I like this one a lot. JMS QueueSenders handle the message selector
> workings inside offer(). JMS QueueReceivers with no message selector
> (and will use the ALLMESSAGESELECTOR) will have something close to
> PBQ performance. QueueReceivers with messages selectors will still
> have to do a PBQ scan in the remove() method, but that's the only
> disappointing thing. Everything else should be very live.
>
> Thanks again for the help. Please let me know if you see any problems
> when you flip through the code.
>
> Dave
>
> David Walend
> david at walend.net
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061004/6bef9781/attachment.html 

From moran at gigaspaces.com  Fri Oct  6 11:12:46 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Fri, 06 Oct 2006 17:12:46 +0200
Subject: [concurrency-interest] Extending with an exposed lock?
Message-ID: <4526726E.8090007@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061006/577cffa5/attachment.html 

From dl at cs.oswego.edu  Sun Oct  8 09:33:10 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 08 Oct 2006 09:33:10 -0400
Subject: [concurrency-interest] Extending with an exposed lock?
In-Reply-To: <4526726E.8090007@gigaspaces.com>
References: <4526726E.8090007@gigaspaces.com>
Message-ID: <4528FE16.7060201@cs.oswego.edu>

[First: Sorry that a misconfigured firewall elsewhere on our campus
was interfering with DNS, so some of you might not have gotten the
original or had a reply stall. This should now be fixed.]

Moran Avigdor wrote:
> Extending a concurrent construct (for example CyclicBarrier, 
> ThreadPoolExecutor, etc.) may impose limitations
> especially when it regards to internal locking mechanisms used by the 
> 'super' class.
> 
> My specific extended use has no additional value to this post, thus I 
> will refrain from elaborating on it - unless interest arises.
> 
> The concurrency difficulty here is that my extended code needs to be 
> atomic in respect to other code conducted
> through the same API. If I choose an 'outer' locking it may lead to a 
> deadlock if 'inner' (super's) locking is in await states
> waiting for a condition to settle.
> 
> Exposing the lock (via getter) would impose ambiguities between 
> different lock implementations (more specifically backport vs. 
> java.util.concurrent package) - not to mention misuse.
> 
> The option that I am raising is having a /protected V 
> underLock(Callable<V> c) /that will be used to delegate logic from the
> extending class to be performed under the 'inner' lock used by the super 
> implementation.
>  >From the extending class point of view, the 'inner' lock can be of any 
> kind, including a synchronization of an Object used by backport.
> 

 > The ThreadPoolExecutor has in this regard an afterExecute(Runnable,
 > Throwable) and beforeExecute(Thread, Runnable) calls.
 > Those have been used successfully.
 >
 > But, does anyone see another option under the current limitations
 > (besides reflection to get the inner lock...)?
 >


There are several different kinds of cases here:

1. Components that do no internal blocking. In these, you can, if
desired, wrap all usages in an outer lock. This will probably
decrease throughput, but leaves you in control. This applies
for example to ConcurrentSkipLists, which don't even use locks
internally, so support a lot of internal concurrency. Using
an external before/after-style lock would disable internal
concurrency, but with no other effects on liveness.

2. Components like Semaphore, CountDownLatch, SynchronousQueue,
and Exchanger that may do internal blocking, but without using locks.
For these, you'd never want to "extend" the atomicity of methods even
with before/after locks, since a thread may block while holding
lock, preventing others from calling methods that would unblock
it (this is an analog of nested monitor lockout). In these cases,
the only kind of external before/after extensions you can use
with blocking methods are those that both acquire and release
external lock both before and after. As in:

class MySemaphore extends Semaphore {
   private synchronized void before() { ... stuff ...}
   private synchronized void after() { ... other stuff ... }
   public void acquire() throw InterruptedException {
     before(); try { super.acquire(); } finally { after(); }
   }
}

This might seem overly restrictive, but I don't know of use
cases where you'd want to do anything beyond this.

3. Components that are like (2) but just so happen to use
Lock/Condition for waiting. At the moment, this includes
CyclicBarrier, ArrayBlockingQueue, PriorityBlockingQueue.
But all of these might at any time change to instead use
strategies in (2), which are usually more efficient and
desirable on other grounds, so we really don't want to
expose locks in these cases and preclude further improvements.
So, in these cases, you also can only use the above style.
(There are also in-between cases like current LinkedBlockingQueue,
that use locks and conditions, but still permit some internal
concurrency.)


Can you live with this?

-Doug

From matthias.ernst at coremedia.com  Mon Oct  9 03:15:28 2006
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Mon, 9 Oct 2006 09:15:28 +0200
Subject: [concurrency-interest] SwingWorker & allowCoreThreadsTimeout
Message-ID: <9DC7096A2275564C9E2CF5042569976D0ACFB6@hermes.coremedia.com>

I just found this gem in the javax.swing.SwingWorker (1.7b01) which just doesn't look like the right thing(TM). That would be an application for just using MAX_WORKER_THREADS core threads, the same number of max, plus allowCoreThreadsTimeout, right?

If you agree, I'd submit the change to Sun.

Thanks
Matthias


            obj = new ThreadPoolExecutor(0, MAX_WORKER_THREADS,
                                         1L, TimeUnit.SECONDS,
                                         new LinkedBlockingQueue<Runnable>(),
                                         threadFactory) {

                    private final ReentrantLock pauseLock = new ReentrantLock();
                    private final Condition unpaused = pauseLock.newCondition();
                    private boolean isPaused = false;
                    private final ReentrantLock executeLock = new ReentrantLock();
                    
                    @Override
                    public void execute(Runnable command) {
                        /*
                         * ThreadPoolExecutor first tries to run task
                         * in a corePool. If all threads are busy it
                         * tries to add task to the waiting queue. If it
                         * fails it run task in maximumPool.
                         *
                         * We want corePool to be 0 and
                         * maximumPool to be MAX_WORKER_THREADS
                         * We need to change the order of the execution.
                         * First try corePool then try maximumPool
                         * pool and only then store to the waiting
                         * queue. We can not do that because we would
                         * need access to the private methods.
                         *
                         * Instead we enlarge corePool to
                         * MAX_WORKER_THREADS before the execution and
                         * shrink it back to 0 after. 
                         * It does pretty much what we need.
                         *
                         * While we changing the corePoolSize we need
                         * to stop running worker threads from accepting new
                         * tasks.
                         */
                        
                        //we need atomicity for the execute method.
                        executeLock.lock();
                        try {

                            pauseLock.lock();
                            try {
                                isPaused = true;
                            } finally {
                                pauseLock.unlock();
                            }
                            
                            setCorePoolSize(MAX_WORKER_THREADS);
                            super.execute(command);
                            setCorePoolSize(0);
                            
                            pauseLock.lock();
                            try {
                                isPaused = false;
                                unpaused.signalAll();
                            } finally {
                                pauseLock.unlock();
                            }
                        } finally {
                            executeLock.unlock();
                        }
                    }
                    @Override 
                    protected void afterExecute(Runnable r, Throwable t) { 
                        super.afterExecute(r, t);
                        pauseLock.lock();
                        try {
                            while(isPaused) {
                                unpaused.await();
                            }
                        } catch(InterruptedException ignore) {
                            
                        } finally {
                            pauseLock.unlock();
                        }
                    }
                };
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061009/f279f621/attachment.html 

From moran at gigaspaces.com  Mon Oct  9 12:24:52 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Mon, 09 Oct 2006 18:24:52 +0200
Subject: [concurrency-interest] Extending with an exposed lock?
In-Reply-To: <4528FE16.7060201@cs.oswego.edu>
References: <4526726E.8090007@gigaspaces.com> <4528FE16.7060201@cs.oswego.edu>
Message-ID: <452A77D4.70807@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061009/10a9f9b8/attachment.html 

From syg6 at yahoo.com  Tue Oct 10 11:12:34 2006
From: syg6 at yahoo.com (Robert Bowen)
Date: Tue, 10 Oct 2006 08:12:34 -0700 (PDT)
Subject: [concurrency-interest] Best way to remove a scheduled task with
	ScheduledThreadPoolExecutor
Message-ID: <20061010151234.805.qmail@web37702.mail.mud.yahoo.com>

Hello again all,

I am using a ScheduledThreadPoolExecutor to schedule Runnable tasks. I would like to be able to remove tasks as well. I see in the API that ScheduledThreadPoolExecutor has a remove() method which takes a Runnable as a parameter. Fantastic! How do I tell it which Runnable I want to remove?

I've tried getting the ScheduledThreadPoolExecutor's BlockingQueue and iterating over it:

BlockingQueue bq = stpe.getQueue();
while (it.hasNext())
{
  MyRunnable mr = (MyRunnable)it.next();
}

but as soon as I call it.next() I get a ConcurrentModificationException. Yikes. 

How else can I do this? Removing all of the elements (using drainTo()?) off the BlockingQueue and re-scheduling all of the remaining ScheduledThreadPoolExecutor tasks? This doesn't sound like a good idea ...

Many thanks!
Bob

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061010/339489e9/attachment.html 

From holger at wizards.de  Tue Oct 10 11:45:28 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Tue, 10 Oct 2006 17:45:28 +0200
Subject: [concurrency-interest] Best way to remove a scheduled task with
 ScheduledThreadPoolExecutor
In-Reply-To: <20061010151234.805.qmail@web37702.mail.mud.yahoo.com>
References: <20061010151234.805.qmail@web37702.mail.mud.yahoo.com>
Message-ID: <452BC018.2030401@wizards.de>

Robert Bowen wrote:
> I am using a ScheduledThreadPoolExecutor to schedule Runnable tasks. I
> would like to be able to remove tasks as well. I see in the API that
> ScheduledThreadPoolExecutor has a remove() method which takes a Runnable
> as a parameter. Fantastic! How do I tell it which Runnable I want to remove?

You cannot - that method does not work as expected and contains an
internal bug that got fixed in Mustang b71. Check the mailing list
archives from around last December/January, there was a fairly long
discussion about this. Summary: just use cancel() on your returned Futures
- this will let the tasks drop out of the queue eventually.

Holger

From joe.bowbeer at gmail.com  Tue Oct 10 12:08:39 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 10 Oct 2006 09:08:39 -0700
Subject: [concurrency-interest] Best way to remove a scheduled task with
	ScheduledThreadPoolExecutor
In-Reply-To: <452BC018.2030401@wizards.de>
References: <20061010151234.805.qmail@web37702.mail.mud.yahoo.com>
	<452BC018.2030401@wizards.de>
Message-ID: <31f2a7bd0610100908g435984c7k64d4ec9990ec3129@mail.gmail.com>

After cancel() you *can* call STPE.purge() to remove it ASAP.  But
this is probably not necessary unless you're wasting lots and lots of
tasks.

On 10/10/06, Holger Hoffst?tte <holger at wizards.de> wrote:
> Robert Bowen wrote:
> > I am using a ScheduledThreadPoolExecutor to schedule Runnable tasks. I
> > would like to be able to remove tasks as well. I see in the API that
> > ScheduledThreadPoolExecutor has a remove() method which takes a Runnable
> > as a parameter. Fantastic! How do I tell it which Runnable I want to remove?
>
> You cannot - that method does not work as expected and contains an
> internal bug that got fixed in Mustang b71. Check the mailing list
> archives from around last December/January, there was a fairly long
> discussion about this. Summary: just use cancel() on your returned Futures
> - this will let the tasks drop out of the queue eventually.
>
> Holger
>


From syg6 at yahoo.com  Tue Oct 10 15:10:52 2006
From: syg6 at yahoo.com (Robert Bowen)
Date: Tue, 10 Oct 2006 12:10:52 -0700 (PDT)
Subject: [concurrency-interest] Best way to remove a scheduled task with
	ScheduledThreadPoolExecutor
Message-ID: <20061010191052.49565.qmail@web37713.mail.mud.yahoo.com>

Hmmm ... I'm at home now and don't have my code in front of me but ... if I am not mistaken, when you call ScheduledThreadPoolExecutor.scheduleAtFixedRate(Runnable) what you're left with is an Executor with Future Tasks, each one an instance of your Runnable. So my question remains, how do I get access to each individual Runnable / Future Task, so I can call cancel() on it?

Maybe I'll see it more clearly when I have the code in front of me ...

Thanks for your help!
Bob

----- Original Message ----
From: Joe Bowbeer <joe.bowbeer at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Tuesday, October 10, 2006 6:08:39 PM
Subject: Re: [concurrency-interest] Best way to remove a scheduled task with ScheduledThreadPoolExecutor

After cancel() you *can* call STPE.purge() to remove it ASAP.  But
this is probably not necessary unless you're wasting lots and lots of
tasks.

On 10/10/06, Holger Hoffst?tte <holger at wizards.de> wrote:
> Robert Bowen wrote:
> > I am using a ScheduledThreadPoolExecutor to schedule Runnable tasks. I
> > would like to be able to remove tasks as well. I see in the API that
> > ScheduledThreadPoolExecutor has a remove() method which takes a Runnable
> > as a parameter. Fantastic! How do I tell it which Runnable I want to remove?
>
> You cannot - that method does not work as expected and contains an
> internal bug that got fixed in Mustang b71. Check the mailing list
> archives from around last December/January, there was a fairly long
> discussion about this. Summary: just use cancel() on your returned Futures
> - this will let the tasks drop out of the queue eventually.
>
> Holger
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061010/71bbbec5/attachment.html 

From joe.bowbeer at gmail.com  Tue Oct 10 15:25:49 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 10 Oct 2006 12:25:49 -0700
Subject: [concurrency-interest] Best way to remove a scheduled task with
	ScheduledThreadPoolExecutor
In-Reply-To: <20061010191052.49565.qmail@web37713.mail.mud.yahoo.com>
References: <20061010191052.49565.qmail@web37713.mail.mud.yahoo.com>
Message-ID: <31f2a7bd0610101225r696749d0kd48e14e0dfdac52b@mail.gmail.com>

scheduleAtFixedRate returns a (Scheduled)Future instance associated
with your Runnable.  This Future is what you cancel.

If you want to cancel each and every one, you can shutdownNow the
executorService.

On 10/10/06, Robert Bowen <syg6 at yahoo.com> wrote:
>
> Hmmm ... I'm at home now and don't have my code in front of me but ... if I
> am not mistaken, when you call
> ScheduledThreadPoolExecutor.scheduleAtFixedRate(Runnable)
> what you're left with is an Executor with Future Tasks, each one an instance
> of your Runnable. So my question remains, how do I get access to each
> individual Runnable / Future Task, so I can call cancel() on it?
>
> Maybe I'll see it more clearly when I have the code in front of me ...
>
> Thanks for your help!
> Bob
>

From syg6 at yahoo.com  Wed Oct 11 04:59:15 2006
From: syg6 at yahoo.com (Robert Bowen)
Date: Wed, 11 Oct 2006 01:59:15 -0700 (PDT)
Subject: [concurrency-interest] Best way to remove a scheduled task with
	ScheduledThreadPoolExecutor
Message-ID: <20061011085915.79663.qmail@web37713.mail.mud.yahoo.com>

Right you are! Problem solved! They seemed to have thought of everything when developing this API!

Thanks for all your help, it saved me a lot of time!

Bob

----- Original Message ----
From: Joe Bowbeer <joe.bowbeer at gmail.com>
To: concurrency-interest at cs.oswego.edu
Sent: Tuesday, October 10, 2006 9:25:49 PM
Subject: Re: [concurrency-interest] Best way to remove a scheduled task with ScheduledThreadPoolExecutor

scheduleAtFixedRate returns a (Scheduled)Future instance associated
with your Runnable.  This Future is what you cancel.

If you want to cancel each and every one, you can shutdownNow the
executorService.

On 10/10/06, Robert Bowen <syg6 at yahoo.com> wrote:
>
> Hmmm ... I'm at home now and don't have my code in front of me but ... if I
> am not mistaken, when you call
> ScheduledThreadPoolExecutor.scheduleAtFixedRate(Runnable)
> what you're left with is an Executor with Future Tasks, each one an instance
> of your Runnable. So my question remains, how do I get access to each
> individual Runnable / Future Task, so I can call cancel() on it?
>
> Maybe I'll see it more clearly when I have the code in front of me ...
>
> Thanks for your help!
> Bob
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061011/2e47c260/attachment.html 

From dcholmes at optusnet.com.au  Wed Oct 11 05:21:00 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 11 Oct 2006 19:21:00 +1000
Subject: [concurrency-interest] Best way to remove a scheduled task
	withScheduledThreadPoolExecutor
In-Reply-To: <20061011085915.79663.qmail@web37713.mail.mud.yahoo.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGENHHCAA.dcholmes@optusnet.com.au>

Note however, that in Java 5, there is an issue with cancel() decreasing the
number of worker threads in the pool. This is fixed in Java 6.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Robert Bowen
  Sent: Wednesday, 11 October 2006 6:59 PM
  To: Joe Bowbeer; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Best way to remove a scheduled task
withScheduledThreadPoolExecutor


  Right you are! Problem solved! They seemed to have thought of everything
when developing this API!

  Thanks for all your help, it saved me a lot of time!

  Bob


  ----- Original Message ----
  From: Joe Bowbeer <joe.bowbeer at gmail.com>
  To: concurrency-interest at cs.oswego.edu
  Sent: Tuesday, October 10, 2006 9:25:49 PM
  Subject: Re: [concurrency-interest] Best way to remove a scheduled task
with ScheduledThreadPoolExecutor


  scheduleAtFixedRate returns a (Scheduled)Future instance associated
  with your Runnable.  This Future is what you cancel.

  If you want to cancel each and every one, you can shutdownNow the
  executorService.

  On 10/10/06, Robert Bowen <syg6 at yahoo.com> wrote:
  >
  > Hmmm ... I'm at home now and don't have my code in front of me but ...
if I
  > am not mistaken, when you call
  > ScheduledThreadPoolExecutor.scheduleAtFixedRate(Runnable)
  > what you're left with is an Executor with Future Tasks, each one an
instance
  > of your Runnable. So my question remains, how do I get access to each
  > individual Runnable / Future Task, so I can call cancel() on it?
  >
  > Maybe I'll see it more clearly when I have the code in front of me ...
  >
  > Thanks for your help!
  > Bob
  >
  _______________________________________________
  Concurrency-interest mailing list
  Concurrency-interest at altair.cs.oswego.edu
  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061011/4b369dd3/attachment.html 

From holger at wizards.de  Wed Oct 11 21:52:42 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 12 Oct 2006 03:52:42 +0200
Subject: [concurrency-interest] Question on JCIP annotations
Message-ID: <452D9FEA.3040906@wizards.de>


While adopting the JCIP annotations I've come across quite a few "utility
classes", i.e. classes that only contain static methods and no
mutable/visible/published state. Is this considered to be @Threadsafe or
@Immutable? I guess both but that was probably not the intention. :^)

thanks
Holger


From tim at peierls.net  Thu Oct 12 07:38:18 2006
From: tim at peierls.net (Tim Peierls)
Date: Thu, 12 Oct 2006 07:38:18 -0400
Subject: [concurrency-interest] Question on JCIP annotations
In-Reply-To: <452D9FEA.3040906@wizards.de>
References: <452D9FEA.3040906@wizards.de>
Message-ID: <63b4e4050610120438p6e1cbde5j15c75e56447d3305@mail.gmail.com>

We were trying to keep the number of annotations to a minimum, otherwise
this would have been called @Stateless.

How about this:

@ThreadSafe // because stateless
public class Util {
}

--tim

On 10/11/06, Holger Hoffst?tte <holger at wizards.de> wrote:
>
>
> While adopting the JCIP annotations I've come across quite a few "utility
> classes", i.e. classes that only contain static methods and no
> mutable/visible/published state. Is this considered to be @Threadsafe or
> @Immutable? I guess both but that was probably not the intention. :^)
>
> thanks
> Holger
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061012/3c453d14/attachment.html 

From holger at wizards.de  Thu Oct 12 08:01:14 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 12 Oct 2006 14:01:14 +0200
Subject: [concurrency-interest] Question on JCIP annotations
In-Reply-To: <63b4e4050610120438p6e1cbde5j15c75e56447d3305@mail.gmail.com>
References: <452D9FEA.3040906@wizards.de>
	<63b4e4050610120438p6e1cbde5j15c75e56447d3305@mail.gmail.com>
Message-ID: <452E2E8A.9080203@wizards.de>

Tim Peierls wrote:
> We were trying to keep the number of annotations to a minimum, otherwise
> this would have been called @Stateless.

Agreed - I realize it's a corner case and just wanted to ask for some
clarification (with an eye towards Findbugs). @ThreadSafe makes more sense
when @Immutable implies multiple objects.

thanks
Holger

From brian at quiotix.com  Thu Oct 12 11:10:21 2006
From: brian at quiotix.com (Brian Goetz)
Date: Thu, 12 Oct 2006 11:10:21 -0400
Subject: [concurrency-interest] Question on JCIP annotations
In-Reply-To: <452E2E8A.9080203@wizards.de>
References: <452D9FEA.3040906@wizards.de>	<63b4e4050610120438p6e1cbde5j15c75e56447d3305@mail.gmail.com>
	<452E2E8A.9080203@wizards.de>
Message-ID: <452E5ADD.7040709@quiotix.com>

> Agreed - I realize it's a corner case and just wanted to ask for some
> clarification (with an eye towards Findbugs). @ThreadSafe makes more sense
> when @Immutable implies multiple objects.

Also, bear in mind that a class with static methods only might still not 
be thread-safe if they have shared mutable state that is not properly 
synchronized.  For example:

@NotThreadSafe
public class FooFactory {
   private static int fooCount;

   public static Foo newFoo() {
     ++fooCount;
     return new Foo();
   }

   public static getFooCount() { return fooCount; }
}

From the.mindstorm.mailinglist at gmail.com  Tue Oct 17 19:58:43 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 02:58:43 +0300
Subject: [concurrency-interest] what to do about InterruptedException in
	ThreadPoolExecutor.awaitTermination
Message-ID: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>

Hi!

I am using a ThreadPoolExecutor to run invoke concurrently different
methods on an object. Before continuing, I am interested if the task
was finished:

My code looks something like:

[code]
exec.submitRunnable(imr);
exec.shutdown();
boolean finished= exec.awaitTermination(timeOut);
[/code]

I am trying to understand what should I do about the
InterruptedException that can be thrown from the awaitTermination
method. As I read in the JCiP, I should be doing one of:
1/ propagate it (which is not acceptable in my case)
2/ have something like Thread.currentThread().interrupt();
3/ ignore it

Currently, because I couldn't find a good answer to my question, I am
just ignoring it and it looks like things are working as expected (and
I have a couple of test covering the code). I have also tried the 2nd
option and I am getting the same results, so I am wondering if I am
safe with the 3rd option or should I do the 2nd one.

thanks in advance for all your advise,

./alex
--
.w( the_mindstorm )p.

From dawidk at mathcs.emory.edu  Tue Oct 17 20:23:39 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 17 Oct 2006 20:23:39 -0400
Subject: [concurrency-interest] what to do about InterruptedException
 inThreadPoolExecutor.awaitTermination
In-Reply-To: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
References: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
Message-ID: <4535740B.5090108@mathcs.emory.edu>

Alexandru Popescu wrote:
> Hi!
>
> I am using a ThreadPoolExecutor to run invoke concurrently different
> methods on an object. Before continuing, I am interested if the task
> was finished:
>
> My code looks something like:
>
> [code]
> exec.submitRunnable(imr);
> exec.shutdown();
> boolean finished= exec.awaitTermination(timeOut);
> [/code]
>
> I am trying to understand what should I do about the
> InterruptedException that can be thrown from the awaitTermination
> method. As I read in the JCiP, I should be doing one of:
> 1/ propagate it (which is not acceptable in my case)
> 2/ have something like Thread.currentThread().interrupt();
> 3/ ignore it
>
> Currently, because I couldn't find a good answer to my question, I am
> just ignoring it and it looks like things are working as expected (and
> I have a couple of test covering the code). I have also tried the 2nd
> option and I am getting the same results, so I am wondering if I am
> safe with the 3rd option or should I do the 2nd one.
>   

If you can't do 1) you should always do 2), so that later in the same 
thread (e.g. when you return from the method) the interruption status is 
not lost and eventually results in InterruptedException once the thread 
enters another blocking call. But I am not clear why you need to 
shutdown the executor in the code above. Do you want to wait for _all_ 
submitted tasks to finish, or just the one you just submitted? In the 
latter case, you should call get() on the future object returned from 
submit(), instead of awaitTermination on the executor.

Regards,
Dawid


From dcholmes at optusnet.com.au  Tue Oct 17 20:31:11 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 18 Oct 2006 10:31:11 +1000
Subject: [concurrency-interest] what to do about InterruptedException
	inThreadPoolExecutor.awaitTermination
In-Reply-To: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEDMHDAA.dcholmes@optusnet.com.au>

Alex,

> My code looks something like:
>
> [code]
> exec.submitRunnable(imr);
> exec.shutdown();
> boolean finished= exec.awaitTermination(timeOut);
> [/code]
>
> I am trying to understand what should I do about the
> InterruptedException that can be thrown from the awaitTermination
> method. As I read in the JCiP, I should be doing one of:
> 1/ propagate it (which is not acceptable in my case)
> 2/ have something like Thread.currentThread().interrupt();
> 3/ ignore it

So the difference between #2 and #3 in practice is what else the thread
executing the above code does. In general you should always do #2 - it is
safe and correct no matter what thread does. #3 can be correct if the thread
does nothing else after the above code, but if you/someone changes that
later then they need to remember to convert to #2 if needed. So stick with
#2 as a general rule.

Cheers,
David Holmes


From the.mindstorm.mailinglist at gmail.com  Tue Oct 17 20:36:56 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 03:36:56 +0300
Subject: [concurrency-interest] what to do about InterruptedException
	inThreadPoolExecutor.awaitTermination
In-Reply-To: <4535740B.5090108@mathcs.emory.edu>
References: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
	<4535740B.5090108@mathcs.emory.edu>
Message-ID: <c6f400460610171736j7fccd340i2382b7daf789a26d@mail.gmail.com>

On 10/18/06, Dawid Kurzyniec <dawidk at mathcs.emory.edu> wrote:
> Alexandru Popescu wrote:
> > Hi!
> >
> > I am using a ThreadPoolExecutor to run invoke concurrently different
> > methods on an object. Before continuing, I am interested if the task
> > was finished:
> >
> > My code looks something like:
> >
> > [code]
> > exec.submitRunnable(imr);
> > exec.shutdown();
> > boolean finished= exec.awaitTermination(timeOut);
> > [/code]
> >
> > I am trying to understand what should I do about the
> > InterruptedException that can be thrown from the awaitTermination
> > method. As I read in the JCiP, I should be doing one of:
> > 1/ propagate it (which is not acceptable in my case)
> > 2/ have something like Thread.currentThread().interrupt();
> > 3/ ignore it
> >
> > Currently, because I couldn't find a good answer to my question, I am
> > just ignoring it and it looks like things are working as expected (and
> > I have a couple of test covering the code). I have also tried the 2nd
> > option and I am getting the same results, so I am wondering if I am
> > safe with the 3rd option or should I do the 2nd one.
> >
>
> If you can't do 1) you should always do 2), so that later in the same
> thread (e.g. when you return from the method) the interruption status is
> not lost and eventually results in InterruptedException once the thread
> enters another blocking call.

Thanks. I guess this is true only in case the thread is reused
somehow, and not if the thread is never used again.

> But I am not clear why you need to
> shutdown the executor in the code above. Do you want to wait for _all_
> submitted tasks to finish, or just the one you just submitted? In the
> latter case, you should call get() on the future object returned from
> submit(), instead of awaitTermination on the executor.
>

The reason I need an awaitTimeout is cause I must be able to timeout the method.

./alex
--
.w( the_mindstorm )p.

> Regards,
> Dawid
>
>

From the.mindstorm.mailinglist at gmail.com  Tue Oct 17 20:38:25 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 03:38:25 +0300
Subject: [concurrency-interest] what to do about InterruptedException
	inThreadPoolExecutor.awaitTermination
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEDMHDAA.dcholmes@optusnet.com.au>
References: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEDMHDAA.dcholmes@optusnet.com.au>
Message-ID: <c6f400460610171738m5b2843b1x3dd2c2d737ce5e30@mail.gmail.com>

On 10/18/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Alex,
>
> > My code looks something like:
> >
> > [code]
> > exec.submitRunnable(imr);
> > exec.shutdown();
> > boolean finished= exec.awaitTermination(timeOut);
> > [/code]
> >
> > I am trying to understand what should I do about the
> > InterruptedException that can be thrown from the awaitTermination
> > method. As I read in the JCiP, I should be doing one of:
> > 1/ propagate it (which is not acceptable in my case)
> > 2/ have something like Thread.currentThread().interrupt();
> > 3/ ignore it
>
> So the difference between #2 and #3 in practice is what else the thread
> executing the above code does. In general you should always do #2 - it is
> safe and correct no matter what thread does. #3 can be correct if the thread
> does nothing else after the above code, but if you/someone changes that
> later then they need to remember to convert to #2 if needed. So stick with
> #2 as a general rule.
>

Considering my previous answer to  Dawid, it looks like at least I got
this one right.

./alex
--
.w( the_mindstorm )p.

> Cheers,
> David Holmes
>
>

From dawidk at mathcs.emory.edu  Tue Oct 17 21:23:35 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 17 Oct 2006 21:23:35 -0400
Subject: [concurrency-interest] what to do about
	InterruptedExceptioninThreadPoolExecutor.awaitTermination
In-Reply-To: <c6f400460610171736j7fccd340i2382b7daf789a26d@mail.gmail.com>
References: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com><45	35740B.5090108@mathcs.emory.edu>
	<c6f400460610171736j7fccd340i2382b7daf789a26d@mail.gmail.com>
Message-ID: <45358217.2040408@mathcs.emory.edu>

Alexandru Popescu wrote:
>> But I am not clear why you need to
>> shutdown the executor in the code above. Do you want to wait for _all_
>> submitted tasks to finish, or just the one you just submitted? In the
>> latter case, you should call get() on the future object returned from
>> submit(), instead of awaitTermination on the executor.
>>     
> The reason I need an awaitTimeout is cause I must be able to timeout the method.
>   

There is also future.get(timeout)...

Regards,
Dawid


From the.mindstorm.mailinglist at gmail.com  Tue Oct 17 21:29:55 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 04:29:55 +0300
Subject: [concurrency-interest] what to do about
	InterruptedExceptioninThreadPoolExecutor.awaitTermination
In-Reply-To: <45358217.2040408@mathcs.emory.edu>
References: <c6f400460610171658s272f6439rb71af4f59533e6c8@mail.gmail.com>
	<c6f400460610171736j7fccd340i2382b7daf789a26d@mail.gmail.com>
	<45358217.2040408@mathcs.emory.edu>
Message-ID: <c6f400460610171829p75f13fcai10279ed35e0748c9@mail.gmail.com>

On 10/18/06, Dawid Kurzyniec <dawidk at mathcs.emory.edu> wrote:
> Alexandru Popescu wrote:
> >> But I am not clear why you need to
> >> shutdown the executor in the code above. Do you want to wait for _all_
> >> submitted tasks to finish, or just the one you just submitted? In the
> >> latter case, you should call get() on the future object returned from
> >> submit(), instead of awaitTermination on the executor.
> >>
> > The reason I need an awaitTimeout is cause I must be able to timeout the method.
> >
>
> There is also future.get(timeout)...
>

It looks like by the time I initially wrote the code (and even now) I
wasn't aware of this one. Thanks.

./alex
--
.w( the_mindstorm )p.

> Regards,
> Dawid
>
>

From the.mindstorm.mailinglist at gmail.com  Tue Oct 17 22:23:15 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 05:23:15 +0300
Subject: [concurrency-interest] JCiP Memoizer
Message-ID: <c6f400460610171923j155daf18k4778c18e54913bc4@mail.gmail.com>

Hi!

I would start by saying that till now Chapter 5 is my favorite so far
:">. Still, I have a small problem (indeed it is 5am) understanding
the final version of Memoizer (page 108), or at least one line from
it:

[code]
public V compute(final A arg) throws InterruptedException {
   while(true) {
            // code
    }
}
[/code]

I feel I am missing the meaning of this "infinite" loop. Can you
please help me out?

many thanks,

./alex
--
.w( the_mindstorm )p.

From joe.bowbeer at gmail.com  Wed Oct 18 01:01:24 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 17 Oct 2006 22:01:24 -0700
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <c6f400460610171923j155daf18k4778c18e54913bc4@mail.gmail.com>
References: <c6f400460610171923j155daf18k4778c18e54913bc4@mail.gmail.com>
Message-ID: <31f2a7bd0610172201r26fbb75bg9f66a6978e46ab26@mail.gmail.com>

On 10/17/06, Alexandru Popescu <the.mindstorm.mailinglist at gmail.com> wrote:
>
> I would start by saying that till now Chapter 5 is my favorite so far
> :">. Still, I have a small problem (indeed it is 5am) understanding
> the final version of Memoizer (page 108), or at least one line from
> it:
>
> public V compute(final A arg) throws InterruptedException {
>    while(true) {
>             // code
>     }
> }
>

It's because of this line further down:

            } catch (CancellationException e) {
                cache.remove(arg, f);

from http://jcip.net/listings/Memoizer.java

Here's a partial explanation:

The memoizing compute method is trying to reflect the exception from
the wrapped method back to the caller, but it also has to handle the
case where the task may have been cancelled (somehow).

In this case, the compute method removes its task from the cache (iff
it created the task) and tries again.

--Joe

From tim at peierls.net  Wed Oct 18 01:17:51 2006
From: tim at peierls.net (Tim Peierls)
Date: Wed, 18 Oct 2006 01:17:51 -0400
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <31f2a7bd0610172201r26fbb75bg9f66a6978e46ab26@mail.gmail.com>
References: <c6f400460610171923j155daf18k4778c18e54913bc4@mail.gmail.com>
	<31f2a7bd0610172201r26fbb75bg9f66a6978e46ab26@mail.gmail.com>
Message-ID: <63b4e4050610172217i380ea0fbucf0d2b4fdbf01ec4@mail.gmail.com>

It's only 1am here, but it looks funny to me, too. I remember that the
intent was that a thread interrupted in the middle of a long computation
should not leave the incomplete computation lying around in the cache. So
any thread that detects a cancellation removes the task from the cache and
tries again.

But an interruption during ft.run() will not be seen as a cancellation of
the FutureTask, so this doesn't work. The fix would probably involve
checking for interruption after the call to ft.run().

I just read Joe's response, but I don't see how a Memoizer-created
FutureTask, encapsulated as it is, could ever be cancelled. (Also, I don't
think cache.remove(arg, f) ensures that only the task creator removes the
task; it just ensures that the only the failed task is removed.)

--tim


On 10/18/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
> On 10/17/06, Alexandru Popescu <the.mindstorm.mailinglist at gmail.com>
> wrote:
> >
> > I would start by saying that till now Chapter 5 is my favorite so far
> > :">. Still, I have a small problem (indeed it is 5am) understanding
> > the final version of Memoizer (page 108), or at least one line from
> > it:
> >
> > public V compute(final A arg) throws InterruptedException {
> >    while(true) {
> >             // code
> >     }
> > }
> >
>
> It's because of this line further down:
>
>             } catch (CancellationException e) {
>                 cache.remove(arg, f);
>
> from http://jcip.net/listings/Memoizer.java
>
> Here's a partial explanation:
>
> The memoizing compute method is trying to reflect the exception from
> the wrapped method back to the caller, but it also has to handle the
> case where the task may have been cancelled (somehow).
>
> In this case, the compute method removes its task from the cache (iff
> it created the task) and tries again.
>
> --Joe
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061018/9a0ee35a/attachment-0001.html 

From the.mindstorm.mailinglist at gmail.com  Wed Oct 18 04:06:23 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 11:06:23 +0300
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <63b4e4050610172217i380ea0fbucf0d2b4fdbf01ec4@mail.gmail.com>
References: <c6f400460610171923j155daf18k4778c18e54913bc4@mail.gmail.com>
	<31f2a7bd0610172201r26fbb75bg9f66a6978e46ab26@mail.gmail.com>
	<63b4e4050610172217i380ea0fbucf0d2b4fdbf01ec4@mail.gmail.com>
Message-ID: <c6f400460610180106v60901a56n3bac1ffa6b4922de@mail.gmail.com>

On 10/18/06, Tim Peierls <tim at peierls.net> wrote:
> It's only 1am here, but it looks funny to me, too. I remember that the
> intent was that a thread interrupted in the middle of a long computation
> should not leave the incomplete computation lying around in the cache. So
> any thread that detects a cancellation removes the task from the cache and
> tries again.
>
> But an interruption during ft.run() will not be seen as a cancellation of
> the FutureTask, so this doesn't work. The fix would probably involve
> checking for interruption after the call to ft.run().
>
>  I just read Joe's response, but I don't see how a Memoizer-created
> FutureTask, encapsulated as it is, could ever be cancelled. (Also, I don't
> think cache.remove(arg, f) ensures that only the task creator removes the
> task; it just ensures that the only the failed task is removed.)
>

(a bit later: early in the morning): Things are starting to become
more clear. I don't think there is any way a FutureTask can be
cancelled (cause I don't see it published). Also, I am not sure how
can you reach a CancellationException (for the same reasons).

Another question related to the same code would be: what if the
compute method must not perpetuate the InterruptedException? Wouldn't
this qualify for the cache.remove call? (because as far as I get it,
if the expensive computation resulted in an InterruptedException, then
you will never get the change to compute the real value.

Sorry if I ask wrong questions, but the code looks pretty interesting
(and I am doing an attempt to further detail it to my collegues, that
may need to use something similar).

./alex
--
.w( the_mindstorm )p.



> --tim
>
>
>
> On 10/18/06, Joe Bowbeer < joe.bowbeer at gmail.com> wrote:
> > On 10/17/06, Alexandru Popescu <
> the.mindstorm.mailinglist at gmail.com> wrote:
> > >
> > > I would start by saying that till now Chapter 5 is my favorite so far
> > > :">. Still, I have a small problem (indeed it is 5am) understanding
> > > the final version of Memoizer (page 108), or at least one line from
> > > it:
> > >
> > > public V compute(final A arg) throws InterruptedException {
> > >    while(true) {
> > >             // code
> > >     }
> > > }
> > >
> >
> > It's because of this line further down:
> >
> >             } catch (CancellationException e) {
> >                 cache.remove(arg, f);
> >
> > from http://jcip.net/listings/Memoizer.java
> >
> > Here's a partial explanation:
> >
> > The memoizing compute method is trying to reflect the exception from
> > the wrapped method back to the caller, but it also has to handle the
> > case where the task may have been cancelled (somehow).
> >
> > In this case, the compute method removes its task from the cache (iff
> > it created the task) and tries again.
> >
> > --Joe
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>

From dcholmes at optusnet.com.au  Wed Oct 18 06:28:47 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 18 Oct 2006 20:28:47 +1000
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <c6f400460610180106v60901a56n3bac1ffa6b4922de@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEEDHDAA.dcholmes@optusnet.com.au>

Alex,

I have to concur with Tim. The intent was that interruption during ft.run()
implied cancellation and so there was a need to do clean-up of the cache
entry. But there is nothing to convert the interruption to a cancel()
request and so all that happens in the current case is that everyone who
calls f.get() will get ExecutionException with a cause of
InterruptedException.

Assuming the general case and there was a means to cancel() the FutureTask
then I would be tempted to rewrite the code as follows:

    try {
       return f.get();
    }
    catch (CancellationException e) {
       cache.remove(arg, f);
    }
    catch (ExecutionException e) {
       Throwable t = e.getCause();
       if (t instanceof InterruptedException) // ft.run was 'cancelled'
          cache.remove(arg,f);
       throw launderThrowable(t);
    }

But this doesn't quite work right as it causes an InterruptionException in
both the thread that actually got the interrupt (the one that ran ft.run() )
and any thread that happened to be blocked on f.get() at the time. (Later
threads will re-compute due to the cache removal). What we want to be able
to do is determine if the current thread is the one that executed ft.run()
and only in that case throw the InterruptException. One way to do that would
be to declare ft at the top of the while loop and check for ft != null eg:

    try {
       return f.get();
    }
    catch (CancellationException e) {
       cache.remove(arg, f);
    }
    catch (ExecutionException e) {
       Throwable t = e.getCause();
       if (t instanceof InterruptedException) { // ft.run was 'cancelled'
          cache.remove(arg,f);
          if (ft != null)  // we did ft.run() so we were interrupted
             throw (InterruptedException) t;
          // else retry
       else {
          throw launderThrowable(t);
       }
    }


Note that if compute() doesn't convert an interrupt to InterruptedException
then we presume it did not actually abort the computation. Hence finding the
interrupt bit set after ft.run() is not an indication of cancellation.

And as per the text if you might be able to recompute then any
ExecutionException might be used to just remove the cache entry, and only
throw if the current thread was the one that invoked ft.run().

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
> Alexandru Popescu
> Sent: Wednesday, 18 October 2006 6:06 PM
> To: concurrency-interest
> Subject: Re: [concurrency-interest] JCiP Memoizer
>
>
> On 10/18/06, Tim Peierls <tim at peierls.net> wrote:
> > It's only 1am here, but it looks funny to me, too. I remember that the
> > intent was that a thread interrupted in the middle of a long computation
> > should not leave the incomplete computation lying around in the
> cache. So
> > any thread that detects a cancellation removes the task from
> the cache and
> > tries again.
> >
> > But an interruption during ft.run() will not be seen as a
> cancellation of
> > the FutureTask, so this doesn't work. The fix would probably involve
> > checking for interruption after the call to ft.run().
> >
> >  I just read Joe's response, but I don't see how a Memoizer-created
> > FutureTask, encapsulated as it is, could ever be cancelled.
> (Also, I don't
> > think cache.remove(arg, f) ensures that only the task creator
> removes the
> > task; it just ensures that the only the failed task is removed.)
> >
>
> (a bit later: early in the morning): Things are starting to become
> more clear. I don't think there is any way a FutureTask can be
> cancelled (cause I don't see it published). Also, I am not sure how
> can you reach a CancellationException (for the same reasons).
>
> Another question related to the same code would be: what if the
> compute method must not perpetuate the InterruptedException? Wouldn't
> this qualify for the cache.remove call? (because as far as I get it,
> if the expensive computation resulted in an InterruptedException, then
> you will never get the change to compute the real value.
>
> Sorry if I ask wrong questions, but the code looks pretty interesting
> (and I am doing an attempt to further detail it to my collegues, that
> may need to use something similar).
>
> ./alex
> --
> .w( the_mindstorm )p.
>
>
>
> > --tim
> >
> >
> >
> > On 10/18/06, Joe Bowbeer < joe.bowbeer at gmail.com> wrote:
> > > On 10/17/06, Alexandru Popescu <
> > the.mindstorm.mailinglist at gmail.com> wrote:
> > > >
> > > > I would start by saying that till now Chapter 5 is my
> favorite so far
> > > > :">. Still, I have a small problem (indeed it is 5am) understanding
> > > > the final version of Memoizer (page 108), or at least one line from
> > > > it:
> > > >
> > > > public V compute(final A arg) throws InterruptedException {
> > > >    while(true) {
> > > >             // code
> > > >     }
> > > > }
> > > >
> > >
> > > It's because of this line further down:
> > >
> > >             } catch (CancellationException e) {
> > >                 cache.remove(arg, f);
> > >
> > > from http://jcip.net/listings/Memoizer.java
> > >
> > > Here's a partial explanation:
> > >
> > > The memoizing compute method is trying to reflect the exception from
> > > the wrapped method back to the caller, but it also has to handle the
> > > case where the task may have been cancelled (somehow).
> > >
> > > In this case, the compute method removes its task from the cache (iff
> > > it created the task) and tries again.
> > >
> > > --Joe
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Wed Oct 18 07:19:16 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 18 Oct 2006 04:19:16 -0700
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEEDHDAA.dcholmes@optusnet.com.au>
References: <c6f400460610180106v60901a56n3bac1ffa6b4922de@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEEDHDAA.dcholmes@optusnet.com.au>
Message-ID: <31f2a7bd0610180419t38bfc8eaq6f719a45ab92fb11@mail.gmail.com>

I think the existing cancellation exception handling would make more
sense if the task were submitted to an executor.  Then a forced
shutdown of the executor, for example, could cause a cancellation
exception.

Btw, when I've coded this kind of thing in the past, I've usually
finessed the problem by adding "throws Exception" to the method in
question :-)

On 10/18/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Alex,
>
> I have to concur with Tim. The intent was that interruption during ft.run()
> implied cancellation and so there was a need to do clean-up of the cache
> entry. But there is nothing to convert the interruption to a cancel()
> request and so all that happens in the current case is that everyone who
> calls f.get() will get ExecutionException with a cause of
> InterruptedException.
>
> [...]

From the.mindstorm.mailinglist at gmail.com  Wed Oct 18 07:42:51 2006
From: the.mindstorm.mailinglist at gmail.com (Alexandru Popescu)
Date: Wed, 18 Oct 2006 14:42:51 +0300
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <31f2a7bd0610180419t38bfc8eaq6f719a45ab92fb11@mail.gmail.com>
References: <c6f400460610180106v60901a56n3bac1ffa6b4922de@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEEDHDAA.dcholmes@optusnet.com.au>
	<31f2a7bd0610180419t38bfc8eaq6f719a45ab92fb11@mail.gmail.com>
Message-ID: <c6f400460610180442u7623d23bkd38d52ec404a78dd@mail.gmail.com>

On 10/18/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> I think the existing cancellation exception handling would make more
> sense if the task were submitted to an executor.  Then a forced
> shutdown of the executor, for example, could cause a cancellation
> exception.
>
> Btw, when I've coded this kind of thing in the past, I've usually
> finessed the problem by adding "throws Exception" to the method in
> question :-)
>

He he... in my case I must have no throws :-).

./alex
--
.w( the_mindstorm )p.

> On 10/18/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Alex,
> >
> > I have to concur with Tim. The intent was that interruption during ft.run()
> > implied cancellation and so there was a need to do clean-up of the cache
> > entry. But there is nothing to convert the interruption to a cancel()
> > request and so all that happens in the current case is that everyone who
> > calls f.get() will get ExecutionException with a cause of
> > InterruptedException.
> >
> > [...]
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tim at peierls.net  Wed Oct 18 08:51:06 2006
From: tim at peierls.net (Tim Peierls)
Date: Wed, 18 Oct 2006 08:51:06 -0400
Subject: [concurrency-interest] JCiP Memoizer
In-Reply-To: <31f2a7bd0610180419t38bfc8eaq6f719a45ab92fb11@mail.gmail.com>
References: <c6f400460610180106v60901a56n3bac1ffa6b4922de@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEEDHDAA.dcholmes@optusnet.com.au>
	<31f2a7bd0610180419t38bfc8eaq6f719a45ab92fb11@mail.gmail.com>
Message-ID: <63b4e4050610180551l4fa0434as36ccb06a4af0b84c@mail.gmail.com>

One of the things that makes the Memoizer example so interesting (and
suitable for inclusion in chapter 5 of JCiP) is that it is a rare example of
FutureTask used outside of an Executor.

Does David's last fix with additional interrupt checking in the Callable
adapter do the trick? Something like this:

    public V compute(final A arg) throws InterruptedException {
        while (true) {
            Future<V> f = cache.get(arg);
            FutureTask<V> ft = null;
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    public V call() throws InterruptedException {
                        V result = c.compute(arg);
                        if (Thread.interrupted())
                            throw new InterruptedException();
                        return result;
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                } else {
                    ft = null;
                }
            }
            try {
                return f.get();
            } catch (CancellationException e) {
                throw new IllegalStateException("can't have been
cancelled"); // ??
            } catch (ExecutionException e) {
                Throwable t = e.getCause();
                if (t instanceof InterruptedException) { // ft.run()
was interrupted
                    cache.remove(arg,f);
                    if (ft != null)  // we did ft.run() so we were interrupted
                        throw (InterruptedException) t;
                    // else retry
                } else {
                    throw launderThrowable(t);
                }
            }
        }
    }


Yuck. Makes that final example a lot harder to explain than we were hoping
for.

--tim


On 10/18/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>
> I think the existing cancellation exception handling would make more
> sense if the task were submitted to an executor.  Then a forced
> shutdown of the executor, for example, could cause a cancellation
> exception.
>
> Btw, when I've coded this kind of thing in the past, I've usually
> finessed the problem by adding "throws Exception" to the method in
> question :-)
>
> On 10/18/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Alex,
> >
> > I have to concur with Tim. The intent was that interruption during
> ft.run()
> > implied cancellation and so there was a need to do clean-up of the cache
> > entry. But there is nothing to convert the interruption to a cancel()
> > request and so all that happens in the current case is that everyone who
> > calls f.get() will get ExecutionException with a cause of
> > InterruptedException.
> >
> > [...]
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061018/229cf12e/attachment.html 

From dcholmes at optusnet.com.au  Wed Oct 18 09:10:27 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 18 Oct 2006 23:10:27 +1000
Subject: [concurrency-interest] JCiP Memoizer
Message-ID: <200610181310.k9IDARFx008105@mail14.syd.optusnet.com.au>

An embedded and charset-unspecified text was scrubbed...
Name: not available
Url: /pipermail/attachments/20061018/6d316ce9/attachment.ksh 

From kav at it.edu  Thu Oct 19 05:39:10 2006
From: kav at it.edu (Kasper Nielsen)
Date: Thu, 19 Oct 2006 11:39:10 +0200
Subject: [concurrency-interest] ArrayBlockingQueue and addAll()
In-Reply-To: <4501C1DD.5020608@it.edu>
References: <4501C1DD.5020608@it.edu>
Message-ID: <453747BE.5090103@it.edu>

Hi,

Any reason for not letting ArrayBlockingQueue.addAll() use a more 
efficient implementation then the one inherited from AbstractCollection?

- Kasper

From kav at it.edu  Thu Oct 19 06:11:28 2006
From: kav at it.edu (Kasper Nielsen)
Date: Thu, 19 Oct 2006 12:11:28 +0200
Subject: [concurrency-interest] Escaping "this" reference in constructors
Message-ID: <45374F50.5020007@it.edu>

Hi,

I'm well aware of the problems with letting the "this" reference escape 
in a constructor. However sometimes it is just too tempting.
Consider this small example,

class MainService {
     private final ServiceA a;
     private final ServiceB b;
     MainService() {
         a = new ServiceA(this);
         b = new ServiceB();
     }
     void start() {b.set(this);}
}
class ServiceA {
     private final MainService m;
     ServiceA(MainService m) {this.m = m;}
}
class ServiceB  {
     private volatile MainService m;
     public void set(MainService m) {this.m = m;}
}

I would rather not use ServiceB, because of the volatile field. I make a 
fair amount of callback from ServiceA/B into MainService. So i'd rather 
not want to pay for a volatile field. (yes I know they are cheap)

I guess ServiceA is okay in this situation because I have 100 % control 
of the code.


Now consider a slightly different implementation of MainService

class MainService2 {
     private final Service a;
     MainService2(Class<? extends Service> c) throws Exception {
         a = c.getConstructor(MainService2.class).newInstance(this);
     }
}
interface Service {
   void start();
}
class ServiceImpl implements Service {
     private final MainService2 m;
     ServiceA(MainService2 m) {this.m = m;}
     public void start() {//do dangerous stuff on MainService2}
}

Here the user specifies the type of the service to the constructor of 
MainService2 and there is no telling what type of service the user 
specifies only that it is some subtype of Service.

Would it be fine if I made something like this part of the Service 
interface contract: *No* operations are allowed to be invoked on 
MainService2 in the constructor. The only allowed use of MainService2 is 
storing the reference into a field.

Am I shooting myself in the foot?

- Kasper

From dl at cs.oswego.edu  Thu Oct 19 14:01:22 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 19 Oct 2006 14:01:22 -0400
Subject: [concurrency-interest] ArrayBlockingQueue and addAll()
In-Reply-To: <453747BE.5090103@it.edu>
References: <4501C1DD.5020608@it.edu> <453747BE.5090103@it.edu>
Message-ID: <4537BD72.2030705@cs.oswego.edu>

Kasper Nielsen wrote:
> Hi,
> 
> Any reason for not letting ArrayBlockingQueue.addAll() use a more 
> efficient implementation then the one inherited from AbstractCollection?
> 

It is mainly because there's not a huge possibility for improvement.
Suppose for example a queue with capacity 100 gets calls from two different
threads to addAll with 200 elements each. At best you could put in the
first 100 for the first one, and let the others contend one-by-one as
consumers remove elements. This and other small improvements aren't
usually enough faster that letting all of them contend one-by-one
to deserve explicit coding. Although people who frequently hit cases
where it would be enough faster to bother, might feel differently.
So it is a good suggestion for a potential small performance improvement,
that we ought to take up someday. Thanks!

-Doug


From kav at it.edu  Thu Oct 19 14:16:53 2006
From: kav at it.edu (Kasper Nielsen)
Date: Thu, 19 Oct 2006 20:16:53 +0200
Subject: [concurrency-interest] ArrayBlockingQueue and addAll()
In-Reply-To: <4537BD72.2030705@cs.oswego.edu>
References: <4501C1DD.5020608@it.edu> <453747BE.5090103@it.edu>
	<4537BD72.2030705@cs.oswego.edu>
Message-ID: <4537C115.3050309@it.edu>


Doug Lea wrote:
> Kasper Nielsen wrote:
>> Hi,
>>
>> Any reason for not letting ArrayBlockingQueue.addAll() use a more 
>> efficient implementation then the one inherited from AbstractCollection?
>>
> 
> It is mainly because there's not a huge possibility for improvement.
> Suppose for example a queue with capacity 100 gets calls from two different
> threads to addAll with 200 elements each. At best you could put in the
> first 100 for the first one, and let the others contend one-by-one as
> consumers remove elements. 
I can't see how they can contend one-by-one, the contract of add is to 
throw a RuntimeException() if any element cannot be added.
So what would happen would be
T1 : inserts 100 elements and throws IllegalStateException("Queue full");
T2 : throws IllegalStateException("Queue full");

- Kasper

From dl at cs.oswego.edu  Thu Oct 19 15:47:36 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 19 Oct 2006 15:47:36 -0400
Subject: [concurrency-interest] ArrayBlockingQueue and addAll()
In-Reply-To: <4537C115.3050309@it.edu>
References: <4501C1DD.5020608@it.edu> <453747BE.5090103@it.edu>
	<4537BD72.2030705@cs.oswego.edu> <4537C115.3050309@it.edu>
Message-ID: <4537D658.8060502@cs.oswego.edu>

Kasper Nielsen wrote:
> 
> Doug Lea wrote:
>> Kasper Nielsen wrote:
>>> Hi,
>>>
>>> Any reason for not letting ArrayBlockingQueue.addAll() use a more 
>>> efficient implementation then the one inherited from AbstractCollection?
>>>
> I can't see how they can contend one-by-one, the contract of add is to 
> throw a RuntimeException() if any element cannot be added.

Yes; sorry. I was thinking about blocking cases. However, variants of
the same issue hold: Suppose that there is a very fast consumer that
removes elements as fast as they are added. In this case, adding
200 elements one-by-one in a 100-capacity queue may succeed, whereas
if 100 are put in, in bulk, and then an exception is thrown for
the rest, only 100 will be transferred. Of course, since there are
no promises about these things either way, this would be equally
legal. And sometimes faster in practice, so it is still a useful
suggestion.

-Doug



From kav at it.edu  Fri Oct 20 10:06:07 2006
From: kav at it.edu (Kasper Nielsen)
Date: Fri, 20 Oct 2006 16:06:07 +0200
Subject: [concurrency-interest] Deamon thread Factory
Message-ID: <4538D7CF.6050800@it.edu>

Hi,

I find myself using daemon threads quite often. However the utility 
class Executors lacks methods for this. It would be nice with an easy 
way to create daemon threads.

Perhaps a static ThreadFactory daemonThreadFactory(); method

- Kasper


From matthias.ernst at coremedia.com  Fri Oct 20 10:25:09 2006
From: matthias.ernst at coremedia.com (Ernst, Matthias)
Date: Fri, 20 Oct 2006 16:25:09 +0200
Subject: [concurrency-interest] Unsafe publication of generic reflection
	information?
Message-ID: <9DC7096A2275564C9E2CF5042569976D5F7346@hermes.coremedia.com>

Hi,

java.lang.Class#genericInfo is unsafely published. Although its property
getter checks for null and all the getters in ClassRepository do, too,
there is no such check for the members of
ClassRepository#superInterfaces array.

Could it be that a thread calling aClass.getGenericInterfaces() would
see an array with "holes" in it?

Thanks
Matthias


From tim at peierls.net  Fri Oct 20 10:45:12 2006
From: tim at peierls.net (Tim Peierls)
Date: Fri, 20 Oct 2006 10:45:12 -0400
Subject: [concurrency-interest] Deamon thread Factory
In-Reply-To: <4538D7CF.6050800@it.edu>
References: <4538D7CF.6050800@it.edu>
Message-ID: <63b4e4050610200745h4152be1bh3005cae36f7f621a@mail.gmail.com>

Daemon threads should be used sparingly, for reasons given in Sec 7.4.2 of
JCiP. Adding such a method to Executors would inevitably encourage people to
use daemon threads even where inappropriate. Better to have the folks who
really need a daemonThreadFactory() method roll their own. It's easy enough:

public static ThreadFactory daemonThreadFactory() {
    final ThreadFactory f = Executors.defaultThreadFactory();
    return new ThreadFactory() {
        public Thread newThread(Runnable r) {
            Thread t = f.newThread(r);
            t.setDaemon(true);
            return t;
        }
    };
}

--tim

On 10/20/06, Kasper Nielsen <kav at it.edu> wrote:
>
> Hi,
>
> I find myself using daemon threads quite often. However the utility
> class Executors lacks methods for this. It would be nice with an easy
> way to create daemon threads.
>
> Perhaps a static ThreadFactory daemonThreadFactory(); method
>
> - Kasper
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061020/e513137f/attachment.html 

From moran at gigaspaces.com  Sat Oct 21 11:07:58 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Sat, 21 Oct 2006 17:07:58 +0200
Subject: [concurrency-interest] Deamon thread Factory
In-Reply-To: <63b4e4050610200745h4152be1bh3005cae36f7f621a@mail.gmail.com>
References: <4538D7CF.6050800@it.edu>
	<63b4e4050610200745h4152be1bh3005cae36f7f621a@mail.gmail.com>
Message-ID: <453A37CE.4000500@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061021/23c4d5bd/attachment.html 

From dharrigan at gmail.com  Mon Oct 23 13:46:19 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Mon, 23 Oct 2006 18:46:19 +0100
Subject: [concurrency-interest] Await...Signal - Catching
	IllegalMonitorStateException???
Message-ID: <7153be990610231046g1ed47ae6j8ca1377ba516d736@mail.gmail.com>

Hi,

Firstly let me say that I'm really happy to find this list. I find threading
difficult, but I'm trying to get to trips with it as best I can, and I'm
sure
this list will help my minisule understanding...

Okay, I am trying to get to trips with the concurrency features in Java
1.5, and I've got an issue that I'm trying to understand. I have this
basic program structure...

....
....
private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
....
Parser parser = new Parser(condition);
lock.lock();
try {
    new Thread(parser).start();
    if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
        if(parser.isReading()) {
            if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                setTimedOutWhilstReading(true);
            }
        }
        setTimedOutWhilstWaitingForResponse(true);
    }
} catch(InterruptedException e) {
} finally {
  lock.unlock();
}

then in Parser I have this...

....
....
public Parser(final Condition condition) {
    this.condition = condition;
}

public void run() {
    try {
       synchronized(this) {
           wait(10000); // <--------- simulate this parser taking 10 seconds
reading, causing timeout in calling thread
       }
    } catch (InterruptedException e) {
    }

    try {
        condition.signal();
    } catch(IllegalMonitorStateException e) {
    }
}



Okay, let me try and explain:

I have a thread (X) that creates a parser (Y). X has to check for a few
things,
namely that Y hasn't timed out waiting for a response (the first await in X)
then
if it has timed out X checks to see if Y has started to parse a response.
I've
simulated in Y that Y takes 10 seconds to do it's business (ignorning a
response read etc..I'm just interested in overall time at this point).

Now, in X, because the two awaits have timed out (total ~4 seconds), X has
moved on and exited out of it's run() and the calling thread of X does some
extra things...etc...

But, because X has moved on, when I call condition.signal() I have to catch
an IllegalMonitorStateException! This seems to me a bit "strange." I can
perhaps
hazzard a guess that because the lock (it's condition) in X no longer
exists, then
calling condition.signal() in Y causes this, but my question is - is this
correct? Do
I have to do this? Am I not tripping out?

Now, the reason I have condition.signal() is that in the version of Parser
that
does the parsing and returns in < 4 seconds, then X which is sitting in an
await state, calling condition.signal() is the right thing to do - I have to
tell X
that Y is finished....

What I'm trying to understand is what happens if Y takes a long long time,
what
I have to do to X (and Y) for the states to be properly managed....

I hope this is clear? If not, then please do ask me for clarification...

Thanks so so much, and I look forward to participating in this list!

-=david=-
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061023/4402cab3/attachment.html 

From Richie.Jefts at APCC.com  Mon Oct 23 14:27:36 2006
From: Richie.Jefts at APCC.com (Richie.Jefts at APCC.com)
Date: Mon, 23 Oct 2006 13:27:36 -0500
Subject: [concurrency-interest] Await...Signal -
	Catching	IllegalMonitorStateException???
In-Reply-To: <7153be990610231046g1ed47ae6j8ca1377ba516d736@mail.gmail.com>
Message-ID: <OFDB2DF54A.F0F461B2-ON85257210.00645667-86257210.00651525@apcc.com>

You need to surround condition.signal() with lock/unlock. This is similar 
to surrounding object.notify() with a synchronized block.

You may want to consider using the ExecutorService. For example,

Future future = executorService.submit(parser);
try {
        future.get(4L, TimeUnit.SECONDS);
}
catch (ExecutionException e) {
        // handle...
}
catch (TimeoutException e) {
        future.cancel(true);
}

And the parser can check Thread.isInterrupted() every so often for 
cancellation in case the timeout has occurred. Java Concurrency in 
Practice has some nice examples.
 
richie




"David Harrigan" <dharrigan at gmail.com> 
Sent by: concurrency-interest-bounces at cs.oswego.edu
10/23/2006 12:46 PM

To
concurrency-interest at cs.oswego.edu
cc

Subject
[concurrency-interest] Await...Signal - Catching 
IllegalMonitorStateException???






Hi,

Firstly let me say that I'm really happy to find this list. I find 
threading
difficult, but I'm trying to get to trips with it as best I can, and I'm 
sure
this list will help my minisule understanding...

Okay, I am trying to get to trips with the concurrency features in Java
1.5, and I've got an issue that I'm trying to understand. I have this
basic program structure...

....
....
private Lock lock = new ReentrantLock(); 
private Condition condition = lock.newCondition();
....
Parser parser = new Parser(condition);
lock.lock();
try {
    new Thread(parser).start();
    if(!condition.await(2000, TimeUnit.MILLISECONDS)) { 
        if(parser.isReading()) {
            if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                setTimedOutWhilstReading(true);
            }
        }
        setTimedOutWhilstWaitingForResponse(true); 
    }
} catch(InterruptedException e) {
} finally {
  lock.unlock();
}

then in Parser I have this...

....
....
public Parser(final Condition condition) {
    this.condition = condition; 
}

public void run() {
    try {
       synchronized(this) {
           wait(10000); // <--------- simulate this parser taking 10 
seconds reading, causing timeout in calling thread
       }
    } catch (InterruptedException e) { 
    }

    try {
        condition.signal();
    } catch(IllegalMonitorStateException e) {
    }
}



Okay, let me try and explain:

I have a thread (X) that creates a parser (Y). X has to check for a few 
things, 
namely that Y hasn't timed out waiting for a response (the first await in 
X) then
if it has timed out X checks to see if Y has started to parse a response. 
I've
simulated in Y that Y takes 10 seconds to do it's business (ignorning a 
response read etc..I'm just interested in overall time at this point). 

Now, in X, because the two awaits have timed out (total ~4 seconds), X has
moved on and exited out of it's run() and the calling thread of X does 
some 
extra things...etc...

But, because X has moved on, when I call condition.signal() I have to 
catch
an IllegalMonitorStateException! This seems to me a bit "strange." I can 
perhaps
hazzard a guess that because the lock (it's condition) in X no longer 
exists, then 
calling condition.signal() in Y causes this, but my question is - is this 
correct? Do
I have to do this? Am I not tripping out?

Now, the reason I have condition.signal() is that in the version of Parser 
that 
does the parsing and returns in < 4 seconds, then X which is sitting in an
await state, calling condition.signal() is the right thing to do - I have 
to tell X
that Y is finished....

What I'm trying to understand is what happens if Y takes a long long time, 
what 
I have to do to X (and Y) for the states to be properly managed....

I hope this is clear? If not, then please do ask me for clarification...

Thanks so so much, and I look forward to participating in this list! 

-=david=-_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061023/edf0c028/attachment.html 

From dharrigan at gmail.com  Mon Oct 23 14:33:55 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Mon, 23 Oct 2006 19:33:55 +0100
Subject: [concurrency-interest] Await...Signal - Catching
	IllegalMonitorStateException???
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E03C1BC64@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E03C1BC64@MI8NYCMAIL15.Mi8.com>
Message-ID: <7153be990610231133vd612bc3na78553e131ffc39d@mail.gmail.com>

Hi Mike,

Thanks for replying.

It appears that I need to pass in the lock into thread Y so that it can call
lock.lock() on it before
calling condition.signal(), is this correct? i.e.,

Parser parser = new Parser(condition, lock);

then in Parser:

public void run() {
 try {
   Thread.sleep(10000);
 } catch (InterruptedException e) {
 }

 lock.lock();
 try {
   condition.signal();
 } finally {
   lock.unlock();
}
}

Does that feel right to you? Thanks for helping me to understand this (see,
I'm
learning already :-D )

-=david=-

On 10/23/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>
>  I think the call to
>
> condition.signal();
>
> in this code will always throw this exception.  You should never be
> catching this exception explicitly, it is intended to inform you when you
> have a logic error in your use of a condition.  If you look at the docs for
> Condition.await()/signal()/signalAll(), it says that the owning lock, in
> this case "lock", must be held by the current thread before a call to any of
> the above functions.  Failure to do this results in the exception.
>
> When the X thread is in await() it will release the lock and go into a
> wait-state, in this case it will wait until signal() is called on the
> Condition or the await() times out.  When this happens it will wake up,
> reaquire the lock and continue (you later release the lock again
> correctly).  It will wait to reacquire the lock if something else holds
> it.  It is done this way to avoid race conditions where a call to await()
> could "miss" a call to signal().
>
> In short to avoid the exception you should acquire the lock in your Parse
> thread before calling signal() and release it immediatly after in a finally
> block.
>
> Also worth noting that to make a thread sleep for a period of time
> Thread.sleep() is better and safer than using synchronized + wait() as it
> won't interfere with anything else using "this" as a synchornization object.
>
> HTH.
>
>  ------------------------------
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *David Harrigan
> *Sent:* 23 October 2006 18:46
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Await...Signal - Catching
> IllegalMonitorStateException???
>
> Hi,
>
> Firstly let me say that I'm really happy to find this list. I find
> threading
> difficult, but I'm trying to get to trips with it as best I can, and I'm
> sure
> this list will help my minisule understanding...
>
> Okay, I am trying to get to trips with the concurrency features in Java
> 1.5, and I've got an issue that I'm trying to understand. I have this
> basic program structure...
>
> ....
> ....
> private Lock lock = new ReentrantLock();
> private Condition condition = lock.newCondition();
> ....
> Parser parser = new Parser(condition);
> lock.lock();
> try {
>     new Thread(parser).start();
>     if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
>         if(parser.isReading()) {
>             if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
>                 setTimedOutWhilstReading(true);
>             }
>         }
>         setTimedOutWhilstWaitingForResponse(true);
>     }
> } catch(InterruptedException e) {
> } finally {
>   lock.unlock();
> }
>
> then in Parser I have this...
>
> ....
> ....
> public Parser(final Condition condition) {
>     this.condition = condition;
> }
>
> public void run() {
>     try {
>        synchronized(this) {
>            wait(10000); // <--------- simulate this parser taking 10
> seconds reading, causing timeout in calling thread
>        }
>     } catch (InterruptedException e) {
>     }
>
>     try {
>         condition.signal();
>     } catch(IllegalMonitorStateException e) {
>     }
> }
>
>
>
> Okay, let me try and explain:
>
> I have a thread (X) that creates a parser (Y). X has to check for a few
> things,
> namely that Y hasn't timed out waiting for a response (the first await in
> X) then
> if it has timed out X checks to see if Y has started to parse a response.
> I've
> simulated in Y that Y takes 10 seconds to do it's business (ignorning a
> response read etc..I'm just interested in overall time at this point).
>
> Now, in X, because the two awaits have timed out (total ~4 seconds), X has
> moved on and exited out of it's run() and the calling thread of X does
> some
> extra things...etc...
>
> But, because X has moved on, when I call condition.signal() I have to
> catch
> an IllegalMonitorStateException! This seems to me a bit "strange." I can
> perhaps
> hazzard a guess that because the lock (it's condition) in X no longer
> exists, then
> calling condition.signal() in Y causes this, but my question is - is this
> correct? Do
> I have to do this? Am I not tripping out?
>
> Now, the reason I have condition.signal() is that in the version of Parser
> that
> does the parsing and returns in < 4 seconds, then X which is sitting in an
> await state, calling condition.signal() is the right thing to do - I have
> to tell X
> that Y is finished....
>
> What I'm trying to understand is what happens if Y takes a long long time,
> what
> I have to do to X (and Y) for the states to be properly managed....
>
> I hope this is clear? If not, then please do ask me for clarification...
>
> Thanks so so much, and I look forward to participating in this list!
>
> -=david=-
>
>  This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061023/81c6c150/attachment-0001.html 

From mike.quilleash at subexazure.com  Mon Oct 23 14:20:47 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Mon, 23 Oct 2006 14:20:47 -0400
Subject: [concurrency-interest] Await...Signal - Catching
 IllegalMonitorStateException???
Message-ID: <DAE04D9F6FD21448A220918A522FB60E03C1BC64@MI8NYCMAIL15.Mi8.com>

I think the call to
 
condition.signal();
 
in this code will always throw this exception.  You should never be
catching this exception explicitly, it is intended to inform you when
you have a logic error in your use of a condition.  If you look at the
docs for Condition.await()/signal()/signalAll(), it says that the owning
lock, in this case "lock", must be held by the current thread before a
call to any of the above functions.  Failure to do this results in the
exception.
 
When the X thread is in await() it will release the lock and go into a
wait-state, in this case it will wait until signal() is called on the
Condition or the await() times out.  When this happens it will wake up,
reaquire the lock and continue (you later release the lock again
correctly).  It will wait to reacquire the lock if something else holds
it.  It is done this way to avoid race conditions where a call to
await() could "miss" a call to signal().
 
In short to avoid the exception you should acquire the lock in your
Parse thread before calling signal() and release it immediatly after in
a finally block.
 
Also worth noting that to make a thread sleep for a period of time
Thread.sleep() is better and safer than using synchronized + wait() as
it won't interfere with anything else using "this" as a synchornization
object.
 
HTH.

________________________________

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Harrigan
Sent: 23 October 2006 18:46
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


Hi,

Firstly let me say that I'm really happy to find this list. I find
threading
difficult, but I'm trying to get to trips with it as best I can, and I'm
sure
this list will help my minisule understanding...

Okay, I am trying to get to trips with the concurrency features in Java
1.5, and I've got an issue that I'm trying to understand. I have this
basic program structure...

....
....
private Lock lock = new ReentrantLock(); 
private Condition condition = lock.newCondition();
....
Parser parser = new Parser(condition);
lock.lock();
try {
    new Thread(parser).start();
    if(!condition.await(2000, TimeUnit.MILLISECONDS)) { 
        if(parser.isReading()) {
            if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                setTimedOutWhilstReading(true);
            }
        }
        setTimedOutWhilstWaitingForResponse(true); 
    }
} catch(InterruptedException e) {
} finally {
  lock.unlock();
}

then in Parser I have this...

....
....
public Parser(final Condition condition) {
    this.condition = condition; 
}

public void run() {
    try {
       synchronized(this) {
           wait(10000); // <--------- simulate this parser taking 10
seconds reading, causing timeout in calling thread
       }
    } catch (InterruptedException e) { 
    }

    try {
        condition.signal();
    } catch(IllegalMonitorStateException e) {
    }
}



Okay, let me try and explain:

I have a thread (X) that creates a parser (Y). X has to check for a few
things, 
namely that Y hasn't timed out waiting for a response (the first await
in X) then
if it has timed out X checks to see if Y has started to parse a
response. I've
simulated in Y that Y takes 10 seconds to do it's business (ignorning a 
response read etc..I'm just interested in overall time at this point). 

Now, in X, because the two awaits have timed out (total ~4 seconds), X
has
moved on and exited out of it's run() and the calling thread of X does
some 
extra things...etc...

But, because X has moved on, when I call condition.signal() I have to
catch
an IllegalMonitorStateException! This seems to me a bit "strange." I can
perhaps
hazzard a guess that because the lock (it's condition) in X no longer
exists, then 
calling condition.signal() in Y causes this, but my question is - is
this correct? Do
I have to do this? Am I not tripping out?

Now, the reason I have condition.signal() is that in the version of
Parser that 
does the parsing and returns in < 4 seconds, then X which is sitting in
an
await state, calling condition.signal() is the right thing to do - I
have to tell X
that Y is finished....

What I'm trying to understand is what happens if Y takes a long long
time, what 
I have to do to X (and Y) for the states to be properly managed....

I hope this is clear? If not, then please do ask me for clarification...

Thanks so so much, and I look forward to participating in this list! 

-=david=-


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061023/d07a1dcd/attachment.html 

From dcholmes at optusnet.com.au  Tue Oct 24 11:51:01 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 25 Oct 2006 01:51:01 +1000
Subject: [concurrency-interest] Await...Signal - Catching
	IllegalMonitorStateException???
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E03C1BC64@MI8NYCMAIL15.Mi8.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEJDHDAA.dcholmes@optusnet.com.au>

David,

You are misusing await()/signal(). The whole point of Conditions is to wait
for some state to be achieved. Hence you should acquire the lock and while
the state is not what you expect, perform the await(). The thread that is
updating the state will acquire the same lock, update the state and perform
the signal()/signalAll(). You can abstract out the state changes if the
"change" is actually just "event X occurred" - in which case a Semaphore or
CountDownLatch might be suitable as a coordination mechanism.

Sorry this is a rushed reply and I don't have the cycles right now to fully
understand what you are trying to do.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mike
Quilleash
  Sent: Tuesday, 24 October 2006 4:21 AM
  To: David Harrigan; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


  I think the call to

  condition.signal();

  in this code will always throw this exception.  You should never be
catching this exception explicitly, it is intended to inform you when you
have a logic error in your use of a condition.  If you look at the docs for
Condition.await()/signal()/signalAll(), it says that the owning lock, in
this case "lock", must be held by the current thread before a call to any of
the above functions.  Failure to do this results in the exception.

  When the X thread is in await() it will release the lock and go into a
wait-state, in this case it will wait until signal() is called on the
Condition or the await() times out.  When this happens it will wake up,
reaquire the lock and continue (you later release the lock again correctly).
It will wait to reacquire the lock if something else holds it.  It is done
this way to avoid race conditions where a call to await() could "miss" a
call to signal().

  In short to avoid the exception you should acquire the lock in your Parse
thread before calling signal() and release it immediatly after in a finally
block.

  Also worth noting that to make a thread sleep for a period of time
Thread.sleep() is better and safer than using synchronized + wait() as it
won't interfere with anything else using "this" as a synchornization object.

  HTH.



----------------------------------------------------------------------------
--
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Harrigan
  Sent: 23 October 2006 18:46
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


  Hi,

  Firstly let me say that I'm really happy to find this list. I find
threading
  difficult, but I'm trying to get to trips with it as best I can, and I'm
sure
  this list will help my minisule understanding...

  Okay, I am trying to get to trips with the concurrency features in Java
  1.5, and I've got an issue that I'm trying to understand. I have this
  basic program structure...

  ....
  ....
  private Lock lock = new ReentrantLock();
  private Condition condition = lock.newCondition();
  ....
  Parser parser = new Parser(condition);
  lock.lock();
  try {
      new Thread(parser).start();
      if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
          if(parser.isReading()) {
              if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                  setTimedOutWhilstReading(true);
              }
          }
          setTimedOutWhilstWaitingForResponse(true);
      }
  } catch(InterruptedException e) {
  } finally {
    lock.unlock();
  }

  then in Parser I have this...

  ....
  ....
  public Parser(final Condition condition) {
      this.condition = condition;
  }

  public void run() {
      try {
         synchronized(this) {
             wait(10000); // <--------- simulate this parser taking 10
seconds reading, causing timeout in calling thread
         }
      } catch (InterruptedException e) {
      }

      try {
          condition.signal();
      } catch(IllegalMonitorStateException e) {
      }
  }



  Okay, let me try and explain:

  I have a thread (X) that creates a parser (Y). X has to check for a few
things,
  namely that Y hasn't timed out waiting for a response (the first await in
X) then
  if it has timed out X checks to see if Y has started to parse a response.
I've
  simulated in Y that Y takes 10 seconds to do it's business (ignorning a
  response read etc..I'm just interested in overall time at this point).

  Now, in X, because the two awaits have timed out (total ~4 seconds), X has
  moved on and exited out of it's run() and the calling thread of X does
some
  extra things...etc...

  But, because X has moved on, when I call condition.signal() I have to
catch
  an IllegalMonitorStateException! This seems to me a bit "strange." I can
perhaps
  hazzard a guess that because the lock (it's condition) in X no longer
exists, then
  calling condition.signal() in Y causes this, but my question is - is this
correct? Do
  I have to do this? Am I not tripping out?

  Now, the reason I have condition.signal() is that in the version of Parser
that
  does the parsing and returns in < 4 seconds, then X which is sitting in an
  await state, calling condition.signal() is the right thing to do - I have
to tell X
  that Y is finished....

  What I'm trying to understand is what happens if Y takes a long long time,
what
  I have to do to X (and Y) for the states to be properly managed....

  I hope this is clear? If not, then please do ask me for clarification...

  Thanks so so much, and I look forward to participating in this list!

  -=david=-

 This e-mail is bound by the terms and conditions described at
http://www.subexazure.com/mail-disclaimer.html

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061025/96bd8754/attachment-0001.html 

From dharrigan at gmail.com  Tue Oct 24 14:37:27 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Tue, 24 Oct 2006 19:37:27 +0100
Subject: [concurrency-interest] Await...Signal - Catching
	IllegalMonitorStateException???
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEJDHDAA.dcholmes@optusnet.com.au>
References: <DAE04D9F6FD21448A220918A522FB60E03C1BC64@MI8NYCMAIL15.Mi8.com>
	<NFBBKALFDCPFIDBNKAPCOEJDHDAA.dcholmes@optusnet.com.au>
Message-ID: <7153be990610241137t679f8a24mcd66132ba906c926@mail.gmail.com>

Hi David,

I appreciate your email back tremendously, it helps to clarify what I'm
trying to do :-) The thing
is, I am waiting for a state to happen. The first thread X should wait (for
a certain amount of time)
until thread Y has done it's job. If Y continues for too long, X should
continue and Y should be
abandoned, otherwise Y will return in time and X can process the results.

I believe this is a good model for Lock, newCondition and await(with
timeout) and signal and
after the helpful comments back, I'm now passing in the lock as well as the
condition into
thread Y, which then calls await on the condition, after reacquiring the
lock. Doing it this way
I now do not get any exceptions.

Does this feel right to you?

btw, and this is a shout out to all those who have contributed to Java
Concurrency in
Practice - what an excellent booK!!!!!! :-)

-=david=-

On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
>  David,
>
> You are misusing await()/signal(). The whole point of Conditions is to
> wait for some state to be achieved. Hence you should acquire the lock and
> while the state is not what you expect, perform the await(). The thread that
> is updating the state will acquire the same lock, update the state and
> perform the signal()/signalAll(). You can abstract out the state changes if
> the "change" is actually just "event X occurred" - in which case a Semaphore
> or CountDownLatch might be suitable as a coordination mechanism.
>
> Sorry this is a rushed reply and I don't have the cycles right now to
> fully understand what you are trying to do.
>
> Cheers,
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Mike Quilleash
> *Sent:* Tuesday, 24 October 2006 4:21 AM
> *To:* David Harrigan; concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Await...Signal - Catching
> IllegalMonitorStateException???
>
> I think the call to
>
> condition.signal();
>
> in this code will always throw this exception.  You should never be
> catching this exception explicitly, it is intended to inform you when you
> have a logic error in your use of a condition.  If you look at the docs for
> Condition.await()/signal()/signalAll(), it says that the owning lock, in
> this case "lock", must be held by the current thread before a call to any of
> the above functions.  Failure to do this results in the exception.
>
> When the X thread is in await() it will release the lock and go into a
> wait-state, in this case it will wait until signal() is called on the
> Condition or the await() times out.  When this happens it will wake up,
> reaquire the lock and continue (you later release the lock again
> correctly).  It will wait to reacquire the lock if something else holds
> it.  It is done this way to avoid race conditions where a call to await()
> could "miss" a call to signal().
>
> In short to avoid the exception you should acquire the lock in your Parse
> thread before calling signal() and release it immediatly after in a finally
> block.
>
> Also worth noting that to make a thread sleep for a period of time
> Thread.sleep() is better and safer than using synchronized + wait() as it
> won't interfere with anything else using "this" as a synchornization object.
>
> HTH.
>
>  ------------------------------
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *David Harrigan
> *Sent:* 23 October 2006 18:46
> *To:* concurrency-interest at cs.oswego.edu
> *Subject:* [concurrency-interest] Await...Signal - Catching
> IllegalMonitorStateException???
>
> Hi,
>
> Firstly let me say that I'm really happy to find this list. I find
> threading
> difficult, but I'm trying to get to trips with it as best I can, and I'm
> sure
> this list will help my minisule understanding...
>
> Okay, I am trying to get to trips with the concurrency features in Java
> 1.5, and I've got an issue that I'm trying to understand. I have this
> basic program structure...
>
> ....
> ....
> private Lock lock = new ReentrantLock();
> private Condition condition = lock.newCondition();
> ....
> Parser parser = new Parser(condition);
> lock.lock();
> try {
>     new Thread(parser).start();
>     if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
>         if(parser.isReading()) {
>             if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
>                 setTimedOutWhilstReading(true);
>             }
>         }
>         setTimedOutWhilstWaitingForResponse(true);
>     }
> } catch(InterruptedException e) {
> } finally {
>   lock.unlock();
> }
>
> then in Parser I have this...
>
> ....
> ....
> public Parser(final Condition condition) {
>     this.condition = condition;
> }
>
> public void run() {
>     try {
>        synchronized(this) {
>            wait(10000); // <--------- simulate this parser taking 10
> seconds reading, causing timeout in calling thread
>        }
>     } catch (InterruptedException e) {
>     }
>
>     try {
>         condition.signal();
>     } catch(IllegalMonitorStateException e) {
>     }
> }
>
>
>
> Okay, let me try and explain:
>
> I have a thread (X) that creates a parser (Y). X has to check for a few
> things,
> namely that Y hasn't timed out waiting for a response (the first await in
> X) then
> if it has timed out X checks to see if Y has started to parse a response.
> I've
> simulated in Y that Y takes 10 seconds to do it's business (ignorning a
> response read etc..I'm just interested in overall time at this point).
>
> Now, in X, because the two awaits have timed out (total ~4 seconds), X has
> moved on and exited out of it's run() and the calling thread of X does
> some
> extra things...etc...
>
> But, because X has moved on, when I call condition.signal() I have to
> catch
> an IllegalMonitorStateException! This seems to me a bit "strange." I can
> perhaps
> hazzard a guess that because the lock (it's condition) in X no longer
> exists, then
> calling condition.signal() in Y causes this, but my question is - is this
> correct? Do
> I have to do this? Am I not tripping out?
>
> Now, the reason I have condition.signal() is that in the version of Parser
> that
> does the parsing and returns in < 4 seconds, then X which is sitting in an
> await state, calling condition.signal() is the right thing to do - I have
> to tell X
> that Y is finished....
>
> What I'm trying to understand is what happens if Y takes a long long time,
> what
> I have to do to X (and Y) for the states to be properly managed....
>
> I hope this is clear? If not, then please do ask me for clarification...
>
> Thanks so so much, and I look forward to participating in this list!
>
> -=david=-
>
>  This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061024/e9defebb/attachment.html 

From dcholmes at optusnet.com.au  Tue Oct 24 16:27:05 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 25 Oct 2006 06:27:05 +1000
Subject: [concurrency-interest] Await...Signal -
	CatchingIllegalMonitorStateException???
In-Reply-To: <7153be990610241137t679f8a24mcd66132ba906c926@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>

Hi David,

What you don't do is actually check any state before the await(). Your code
will not work correctly unless the parser thread has to acquire the Lock
before it commences parsing - otherwise it could complete the parsing and do
the signal prior to the main thread doing the await().

Passing a Lock+Condition is working at the wrong level of abstraction -
those should be encapsulated together with the state that is being checked.

It seems like what you might have here is a use for FutureTask. Your main
thread will create the FutureTask and do a timed get() to wait for the
result. You pass the FutureTask to your parseThread and it does the actual
parsing and upon completion marks the Future task as done.

Again this is a rushed response - sorry.

Thanks for the comments re JCiP :-)

Cheers,
David Holmes

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
Harrigan
Sent: Wednesday, 25 October 2006 4:37 AM
To: dholmes at ieee.org
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Await...Signal -
CatchingIllegalMonitorStateException???


  Hi David,

  I appreciate your email back tremendously, it helps to clarify what I'm
trying to do :-) The thing
  is, I am waiting for a state to happen. The first thread X should wait
(for a certain amount of time)
  until thread Y has done it's job. If Y continues for too long, X should
continue and Y should be
  abandoned, otherwise Y will return in time and X can process the results.

  I believe this is a good model for Lock, newCondition and await(with
timeout) and signal and
  after the helpful comments back, I'm now passing in the lock as well as
the condition into
  thread Y, which then calls await on the condition, after reacquiring the
lock. Doing it this way
  I now do not get any exceptions.

  Does this feel right to you?

  btw, and this is a shout out to all those who have contributed to Java
Concurrency in
  Practice - what an excellent booK!!!!!! :-)

  -=david=-


  On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
    David,

    You are misusing await()/signal(). The whole point of Conditions is to
wait for some state to be achieved. Hence you should acquire the lock and
while the state is not what you expect, perform the await(). The thread that
is updating the state will acquire the same lock, update the state and
perform the signal()/signalAll(). You can abstract out the state changes if
the "change" is actually just "event X occurred" - in which case a Semaphore
or CountDownLatch might be suitable as a coordination mechanism.

    Sorry this is a rushed reply and I don't have the cycles right now to
fully understand what you are trying to do.

    Cheers,
    David Holmes
      -----Original Message-----
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mike
Quilleash
      Sent: Tuesday, 24 October 2006 4:21 AM
      To: David Harrigan; concurrency-interest at cs.oswego.edu
      Subject: Re: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


      I think the call to

      condition.signal();

      in this code will always throw this exception.  You should never be
catching this exception explicitly, it is intended to inform you when you
have a logic error in your use of a condition.  If you look at the docs for
Condition.await()/signal()/signalAll(), it says that the owning lock, in
this case "lock", must be held by the current thread before a call to any of
the above functions.  Failure to do this results in the exception.

      When the X thread is in await() it will release the lock and go into a
wait-state, in this case it will wait until signal() is called on the
Condition or the await() times out.  When this happens it will wake up,
reaquire the lock and continue (you later release the lock again correctly).
It will wait to reacquire the lock if something else holds it.  It is done
this way to avoid race conditions where a call to await() could "miss" a
call to signal().

      In short to avoid the exception you should acquire the lock in your
Parse thread before calling signal() and release it immediatly after in a
finally block.

      Also worth noting that to make a thread sleep for a period of time
Thread.sleep() is better and safer than using synchronized + wait() as it
won't interfere with anything else using "this" as a synchornization object.

      HTH.



--------------------------------------------------------------------------
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Harrigan
      Sent: 23 October 2006 18:46
      To: concurrency-interest at cs.oswego.edu
      Subject: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


      Hi,

      Firstly let me say that I'm really happy to find this list. I find
threading
      difficult, but I'm trying to get to trips with it as best I can, and
I'm sure
      this list will help my minisule understanding...

      Okay, I am trying to get to trips with the concurrency features in
Java
      1.5, and I've got an issue that I'm trying to understand. I have this
      basic program structure...

      ....
      ....
      private Lock lock = new ReentrantLock();
      private Condition condition = lock.newCondition();
      ....
      Parser parser = new Parser(condition);
      lock.lock();
      try {
          new Thread(parser).start();
          if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
              if(parser.isReading()) {
                  if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                      setTimedOutWhilstReading(true);
                  }
              }
              setTimedOutWhilstWaitingForResponse(true);
          }
      } catch(InterruptedException e) {
      } finally {
        lock.unlock();
      }

      then in Parser I have this...

      ....
      ....
      public Parser(final Condition condition) {
          this.condition = condition;
      }

      public void run() {
          try {
             synchronized(this) {
                 wait(10000); // <--------- simulate this parser taking 10
seconds reading, causing timeout in calling thread
             }
          } catch (InterruptedException e) {
          }

          try {
              condition.signal();
          } catch(IllegalMonitorStateException e) {
          }
      }



      Okay, let me try and explain:

      I have a thread (X) that creates a parser (Y). X has to check for a
few things,
      namely that Y hasn't timed out waiting for a response (the first await
in X) then
      if it has timed out X checks to see if Y has started to parse a
response. I've
      simulated in Y that Y takes 10 seconds to do it's business (ignorning
a
      response read etc..I'm just interested in overall time at this point).

      Now, in X, because the two awaits have timed out (total ~4 seconds), X
has
      moved on and exited out of it's run() and the calling thread of X does
some
      extra things...etc...

      But, because X has moved on, when I call condition.signal() I have to
catch
      an IllegalMonitorStateException! This seems to me a bit "strange." I
can perhaps
      hazzard a guess that because the lock (it's condition) in X no longer
exists, then
      calling condition.signal() in Y causes this, but my question is - is
this correct? Do
      I have to do this? Am I not tripping out?

      Now, the reason I have condition.signal() is that in the version of
Parser that
      does the parsing and returns in < 4 seconds, then X which is sitting
in an
      await state, calling condition.signal() is the right thing to do - I
have to tell X
      that Y is finished....

      What I'm trying to understand is what happens if Y takes a long long
time, what
      I have to do to X (and Y) for the states to be properly managed....

      I hope this is clear? If not, then please do ask me for
clarification...

      Thanks so so much, and I look forward to participating in this list!

      -=david=-

 This e-mail is bound by the terms and conditions described at
http://www.subexazure.com/mail-disclaimer.html


    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at altair.cs.oswego.edu
    http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061025/ed0f4857/attachment-0001.html 

From dcholmes at optusnet.com.au  Tue Oct 24 16:42:06 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 25 Oct 2006 06:42:06 +1000
Subject: [concurrency-interest] Await...Signal
	-CatchingIllegalMonitorStateException???
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEJHHDAA.dcholmes@optusnet.com.au>

Correction - acquiring the Lock before the signal will ensure that the main
thread has called await() first. See - rushing too much.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David Holmes
  Sent: Wednesday, 25 October 2006 6:27 AM
  To: David Harrigan
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest]
Await...Signal -CatchingIllegalMonitorStateException???


  Hi David,

  What you don't do is actually check any state before the await(). Your
code will not work correctly unless the parser thread has to acquire the
Lock before it commences parsing - otherwise it could complete the parsing
and do the signal prior to the main thread doing the await().

  Passing a Lock+Condition is working at the wrong level of abstraction -
those should be encapsulated together with the state that is being checked.

  It seems like what you might have here is a use for FutureTask. Your main
thread will create the FutureTask and do a timed get() to wait for the
result. You pass the FutureTask to your parseThread and it does the actual
parsing and upon completion marks the Future task as done.

  Again this is a rushed response - sorry.

  Thanks for the comments re JCiP :-)

  Cheers,
  David Holmes

  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of David
Harrigan
  Sent: Wednesday, 25 October 2006 4:37 AM
  To: dholmes at ieee.org
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Await...Signal -
CatchingIllegalMonitorStateException???


    Hi David,

    I appreciate your email back tremendously, it helps to clarify what I'm
trying to do :-) The thing
    is, I am waiting for a state to happen. The first thread X should wait
(for a certain amount of time)
    until thread Y has done it's job. If Y continues for too long, X should
continue and Y should be
    abandoned, otherwise Y will return in time and X can process the
results.

    I believe this is a good model for Lock, newCondition and await(with
timeout) and signal and
    after the helpful comments back, I'm now passing in the lock as well as
the condition into
    thread Y, which then calls await on the condition, after reacquiring the
lock. Doing it this way
    I now do not get any exceptions.

    Does this feel right to you?

    btw, and this is a shout out to all those who have contributed to Java
Concurrency in
    Practice - what an excellent booK!!!!!! :-)

    -=david=-


    On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
      David,

      You are misusing await()/signal(). The whole point of Conditions is to
wait for some state to be achieved. Hence you should acquire the lock and
while the state is not what you expect, perform the await(). The thread that
is updating the state will acquire the same lock, update the state and
perform the signal()/signalAll(). You can abstract out the state changes if
the "change" is actually just "event X occurred" - in which case a Semaphore
or CountDownLatch might be suitable as a coordination mechanism.

      Sorry this is a rushed reply and I don't have the cycles right now to
fully understand what you are trying to do.

      Cheers,
      David Holmes
        -----Original Message-----
        From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mike
Quilleash
        Sent: Tuesday, 24 October 2006 4:21 AM
        To: David Harrigan; concurrency-interest at cs.oswego.edu
        Subject: Re: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


        I think the call to

        condition.signal();

        in this code will always throw this exception.  You should never be
catching this exception explicitly, it is intended to inform you when you
have a logic error in your use of a condition.  If you look at the docs for
Condition.await()/signal()/signalAll(), it says that the owning lock, in
this case "lock", must be held by the current thread before a call to any of
the above functions.  Failure to do this results in the exception.

        When the X thread is in await() it will release the lock and go into
a wait-state, in this case it will wait until signal() is called on the
Condition or the await() times out.  When this happens it will wake up,
reaquire the lock and continue (you later release the lock again correctly).
It will wait to reacquire the lock if something else holds it.  It is done
this way to avoid race conditions where a call to await() could "miss" a
call to signal().

        In short to avoid the exception you should acquire the lock in your
Parse thread before calling signal() and release it immediatly after in a
finally block.

        Also worth noting that to make a thread sleep for a period of time
Thread.sleep() is better and safer than using synchronized + wait() as it
won't interfere with anything else using "this" as a synchornization object.

        HTH.



------------------------------------------------------------------------
        From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Harrigan
        Sent: 23 October 2006 18:46
        To: concurrency-interest at cs.oswego.edu
        Subject: [concurrency-interest] Await...Signal - Catching
IllegalMonitorStateException???


        Hi,

        Firstly let me say that I'm really happy to find this list. I find
threading
        difficult, but I'm trying to get to trips with it as best I can, and
I'm sure
        this list will help my minisule understanding...

        Okay, I am trying to get to trips with the concurrency features in
Java
        1.5, and I've got an issue that I'm trying to understand. I have
this
        basic program structure...

        ....
        ....
        private Lock lock = new ReentrantLock();
        private Condition condition = lock.newCondition();
        ....
        Parser parser = new Parser(condition);
        lock.lock();
        try {
            new Thread(parser).start();
            if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                if(parser.isReading()) {
                    if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
                        setTimedOutWhilstReading(true);
                    }
                }
                setTimedOutWhilstWaitingForResponse(true);
            }
        } catch(InterruptedException e) {
        } finally {
          lock.unlock();
        }

        then in Parser I have this...

        ....
        ....
        public Parser(final Condition condition) {
            this.condition = condition;
        }

        public void run() {
            try {
               synchronized(this) {
                   wait(10000); // <--------- simulate this parser taking 10
seconds reading, causing timeout in calling thread
               }
            } catch (InterruptedException e) {
            }

            try {
                condition.signal();
            } catch(IllegalMonitorStateException e) {
            }
        }



        Okay, let me try and explain:

        I have a thread (X) that creates a parser (Y). X has to check for a
few things,
        namely that Y hasn't timed out waiting for a response (the first
await in X) then
        if it has timed out X checks to see if Y has started to parse a
response. I've
        simulated in Y that Y takes 10 seconds to do it's business
(ignorning a
        response read etc..I'm just interested in overall time at this
point).

        Now, in X, because the two awaits have timed out (total ~4 seconds),
X has
        moved on and exited out of it's run() and the calling thread of X
does some
        extra things...etc...

        But, because X has moved on, when I call condition.signal() I have
to catch
        an IllegalMonitorStateException! This seems to me a bit "strange." I
can perhaps
        hazzard a guess that because the lock (it's condition) in X no
longer exists, then
        calling condition.signal() in Y causes this, but my question is - is
this correct? Do
        I have to do this? Am I not tripping out?

        Now, the reason I have condition.signal() is that in the version of
Parser that
        does the parsing and returns in < 4 seconds, then X which is sitting
in an
        await state, calling condition.signal() is the right thing to do - I
have to tell X
        that Y is finished....

        What I'm trying to understand is what happens if Y takes a long long
time, what
        I have to do to X (and Y) for the states to be properly managed....

        I hope this is clear? If not, then please do ask me for
clarification...

        Thanks so so much, and I look forward to participating in this list!

        -=david=-

 This e-mail is bound by the terms and conditions described at
http://www.subexazure.com/mail-disclaimer.html


      _______________________________________________
      Concurrency-interest mailing list
      Concurrency-interest at altair.cs.oswego.edu
      http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest




-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061025/9c5d2895/attachment.html 

From dharrigan at gmail.com  Tue Oct 24 16:44:18 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Tue, 24 Oct 2006 21:44:18 +0100
Subject: [concurrency-interest] Await...Signal
	-CatchingIllegalMonitorStateException???
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEJHHDAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>
	<NFBBKALFDCPFIDBNKAPCCEJHHDAA.dcholmes@optusnet.com.au>
Message-ID: <7153be990610241344l73b2157epd2f3f409c6be5777@mail.gmail.com>

Hi David,

I appreciate you taking the time, whilst rushing about :-)

I've read your comments - time to rethink my approach :-)

-=david=-

On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
>  Correction - acquiring the Lock before the signal will ensure that the
> main thread has called await() first. See - rushing too much.
>
> David
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *David Holmes
> *Sent:* Wednesday, 25 October 2006 6:27 AM
> *To:* David Harrigan
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Await...Signal
> -CatchingIllegalMonitorStateException???
>
> Hi David,
>
> What you don't do is actually check any state before the await(). Your
> code will not work correctly unless the parser thread has to acquire the
> Lock before it commences parsing - otherwise it could complete the parsing
> and do the signal prior to the main thread doing the await().
>
> Passing a Lock+Condition is working at the wrong level of abstraction -
> those should be encapsulated together with the state that is being checked.
>
> It seems like what you might have here is a use for FutureTask. Your main
> thread will create the FutureTask and do a timed get() to wait for the
> result. You pass the FutureTask to your parseThread and it does the actual
> parsing and upon completion marks the Future task as done.
>
> Again this is a rushed response - sorry.
>
> Thanks for the comments re JCiP :-)
>
> Cheers,
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *David Harrigan
> *Sent:* Wednesday, 25 October 2006 4:37 AM
> *To:* dholmes at ieee.org
> *Cc:* concurrency-interest at cs.oswego.edu
> *Subject:* Re: [concurrency-interest] Await...Signal -
> CatchingIllegalMonitorStateException???
>
> Hi David,
>
> I appreciate your email back tremendously, it helps to clarify what I'm
> trying to do :-) The thing
> is, I am waiting for a state to happen. The first thread X should wait
> (for a certain amount of time)
> until thread Y has done it's job. If Y continues for too long, X should
> continue and Y should be
> abandoned, otherwise Y will return in time and X can process the results.
>
> I believe this is a good model for Lock, newCondition and await(with
> timeout) and signal and
> after the helpful comments back, I'm now passing in the lock as well as
> the condition into
> thread Y, which then calls await on the condition, after reacquiring the
> lock. Doing it this way
> I now do not get any exceptions.
>
> Does this feel right to you?
>
> btw, and this is a shout out to all those who have contributed to Java
> Concurrency in
> Practice - what an excellent booK!!!!!! :-)
>
> -=david=-
>
> On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> >
> >  David,
> >
> > You are misusing await()/signal(). The whole point of Conditions is to
> > wait for some state to be achieved. Hence you should acquire the lock and
> > while the state is not what you expect, perform the await(). The thread that
> > is updating the state will acquire the same lock, update the state and
> > perform the signal()/signalAll(). You can abstract out the state changes if
> > the "change" is actually just "event X occurred" - in which case a Semaphore
> > or CountDownLatch might be suitable as a coordination mechanism.
> >
> > Sorry this is a rushed reply and I don't have the cycles right now to
> > fully understand what you are trying to do.
> >
> > Cheers,
> > David Holmes
> >
> > -----Original Message-----
> > *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> > concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Mike Quilleash
> >
> > *Sent:* Tuesday, 24 October 2006 4:21 AM
> > *To:* David Harrigan; concurrency-interest at cs.oswego.edu
> > *Subject:* Re: [concurrency-interest] Await...Signal - Catching
> > IllegalMonitorStateException???
> >
> > I think the call to
> >
> > condition.signal();
> >
> > in this code will always throw this exception.  You should never be
> > catching this exception explicitly, it is intended to inform you when you
> > have a logic error in your use of a condition.  If you look at the docs for
> > Condition.await()/signal()/signalAll(), it says that the owning lock, in
> > this case "lock", must be held by the current thread before a call to any of
> > the above functions.  Failure to do this results in the exception.
> >
> > When the X thread is in await() it will release the lock and go into a
> > wait-state, in this case it will wait until signal() is called on the
> > Condition or the await() times out.  When this happens it will wake up,
> > reaquire the lock and continue (you later release the lock again
> > correctly).  It will wait to reacquire the lock if something else holds
> > it.  It is done this way to avoid race conditions where a call to await()
> > could "miss" a call to signal().
> >
> > In short to avoid the exception you should acquire the lock in your
> > Parse thread before calling signal() and release it immediatly after in a
> > finally block.
> >
> > Also worth noting that to make a thread sleep for a period of time
> > Thread.sleep() is better and safer than using synchronized + wait() as
> > it won't interfere with anything else using "this" as a synchornization
> > object.
> >
> > HTH.
> >
> >  ------------------------------
> > *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> > concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *David
> > Harrigan
> > *Sent:* 23 October 2006 18:46
> > *To:* concurrency-interest at cs.oswego.edu
> > *Subject:* [concurrency-interest] Await...Signal - Catching
> > IllegalMonitorStateException???
> >
> > Hi,
> >
> > Firstly let me say that I'm really happy to find this list. I find
> > threading
> > difficult, but I'm trying to get to trips with it as best I can, and I'm
> > sure
> > this list will help my minisule understanding...
> >
> > Okay, I am trying to get to trips with the concurrency features in Java
> > 1.5, and I've got an issue that I'm trying to understand. I have this
> > basic program structure...
> >
> > ....
> > ....
> > private Lock lock = new ReentrantLock();
> > private Condition condition = lock.newCondition();
> > ....
> > Parser parser = new Parser(condition);
> > lock.lock();
> > try {
> >     new Thread(parser).start();
> >     if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
> >         if(parser.isReading()) {
> >             if(!condition.await(2000, TimeUnit.MILLISECONDS)) {
> >                 setTimedOutWhilstReading(true);
> >             }
> >         }
> >         setTimedOutWhilstWaitingForResponse(true);
> >     }
> > } catch(InterruptedException e) {
> > } finally {
> >   lock.unlock();
> > }
> >
> > then in Parser I have this...
> >
> > ....
> > ....
> > public Parser(final Condition condition) {
> >     this.condition = condition;
> > }
> >
> > public void run() {
> >     try {
> >        synchronized(this) {
> >            wait(10000); // <--------- simulate this parser taking 10
> > seconds reading, causing timeout in calling thread
> >        }
> >     } catch (InterruptedException e) {
> >     }
> >
> >     try {
> >         condition.signal();
> >     } catch(IllegalMonitorStateException e) {
> >     }
> > }
> >
> >
> >
> > Okay, let me try and explain:
> >
> > I have a thread (X) that creates a parser (Y). X has to check for a few
> > things,
> > namely that Y hasn't timed out waiting for a response (the first await
> > in X) then
> > if it has timed out X checks to see if Y has started to parse a
> > response. I've
> > simulated in Y that Y takes 10 seconds to do it's business (ignorning a
> > response read etc..I'm just interested in overall time at this point).
> >
> > Now, in X, because the two awaits have timed out (total ~4 seconds), X
> > has
> > moved on and exited out of it's run() and the calling thread of X does
> > some
> > extra things...etc...
> >
> > But, because X has moved on, when I call condition.signal() I have to
> > catch
> > an IllegalMonitorStateException! This seems to me a bit "strange." I can
> > perhaps
> > hazzard a guess that because the lock (it's condition) in X no longer
> > exists, then
> > calling condition.signal() in Y causes this, but my question is - is
> > this correct? Do
> > I have to do this? Am I not tripping out?
> >
> > Now, the reason I have condition.signal() is that in the version of
> > Parser that
> > does the parsing and returns in < 4 seconds, then X which is sitting in
> > an
> > await state, calling condition.signal() is the right thing to do - I
> > have to tell X
> > that Y is finished....
> >
> > What I'm trying to understand is what happens if Y takes a long long
> > time, what
> > I have to do to X (and Y) for the states to be properly managed....
> >
> > I hope this is clear? If not, then please do ask me for clarification...
> >
> > Thanks so so much, and I look forward to participating in this list!
> >
> > -=david=-
> >
> >  This e-mail is bound by the terms and conditions described at
> > http://www.subexazure.com/mail-disclaimer.html
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061024/7d3e77d9/attachment-0001.html 

From tim at peierls.net  Tue Oct 24 17:09:09 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue, 24 Oct 2006 17:09:09 -0400
Subject: [concurrency-interest] Await...Signal -
	CatchingIllegalMonitorStateException???
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>
References: <7153be990610241137t679f8a24mcd66132ba906c926@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>
Message-ID: <63b4e4050610241409n710cc83dmfec03c1e7cce9ea8@mail.gmail.com>

On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> It seems like what you might have here is a use for FutureTask. Your main
> thread will create the FutureTask and do a timed get() to wait for the
> result. You pass the FutureTask to your parseThread and it does the actual
> parsing and upon completion marks the Future task as done.
>

Also take (another?) look at chapter 6 of JCiP, especially section 6.3,
which has an extended example of an activity that waits for another to
complete.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061024/852df023/attachment.html 

From dharrigan at gmail.com  Wed Oct 25 04:24:54 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Wed, 25 Oct 2006 09:24:54 +0100
Subject: [concurrency-interest] Await...Signal -
	CatchingIllegalMonitorStateException???
In-Reply-To: <63b4e4050610241409n710cc83dmfec03c1e7cce9ea8@mail.gmail.com>
References: <7153be990610241137t679f8a24mcd66132ba906c926@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEJFHDAA.dcholmes@optusnet.com.au>
	<63b4e4050610241409n710cc83dmfec03c1e7cce9ea8@mail.gmail.com>
Message-ID: <7153be990610250124n422a390ci20061b5760688c8c@mail.gmail.com>

Thanks Tim,

I will do take (another :-)) look at the chapter.

-d=avid=-

On 10/24/06, Tim Peierls <tim at peierls.net> wrote:
>
> On 10/24/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> >
> > It seems like what you might have here is a use for FutureTask. Your
> > main thread will create the FutureTask and do a timed get() to wait for the
> > result. You pass the FutureTask to your parseThread and it does the actual
> > parsing and upon completion marks the Future task as done.
> >
>
> Also take (another?) look at chapter 6 of JCiP, especially section 6.3,
> which has an extended example of an activity that waits for another to
> complete.
>
> --tim
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061025/77c8ad2c/attachment.html 

From fabio.veronez at gmail.com  Wed Oct 25 09:43:20 2006
From: fabio.veronez at gmail.com (Fabio Cechinel Veronez)
Date: Wed, 25 Oct 2006 10:43:20 -0300
Subject: [concurrency-interest] [OFF-TOPIC] Generic Introspecting Problem
Message-ID: <2ec434e70610250643n48833fe2kb649ea3dff59c46e@mail.gmail.com>

	Hello all,

	fist of all; I'm sorry about my poor English and really sorry about
this off-topic message but I don't know for whom ask this kind of
question (I would thank any help or even suggests of other list =)).

	Well, let me try to explain my problem: I'm having a problem when I
try to get, using 'java.beans.Introspector', the property type of a
class that implements a generic interface. My interface
'Identifiable<T>' defines a method called 'T getId()' that should be
implemented by the concret class that defines the id type. But when I
try to get the property type of the field 'id', in some cases I get
'java.lang.Object' and in other cases I get the right type depending
on the set of the getter, setter and static methods.

	I wrote the testing case below and i was expecting to see the output:

	"ThreePropertyAndWithoutValueOfWorks -> id:
ThreePropertyAndWithoutValueOfWorks$Id
	ThreePropertiesAndValueOfDontWork -> id: ThreePropertiesAndValueOfDontWork$Id
	WithValueOfButJustOnePropertyWorks -> id: WithValueOfButJustOnePropertyWorks$Id
	ThreePropertiesAndWithoutValueOfWorks -> id:
ThreePropertiesAndWithoutValueOfWorks$Id"

	but i received:

	"ThreePropertyAndWithoutValueOfWorks -> id:
ThreePropertyAndWithoutValueOfWorks$Id
	ThreePropertiesAndValueOfDontWork -> id: java.lang.Object
	WithValueOfButJustOnePropertyWorks -> id: WithValueOfButJustOnePropertyWorks$Id
	ThreePropertiesAndWithoutValueOfWorks -> id:
ThreePropertiesAndWithoutValueOfWorks$Id"

	Just 'ThreePropertiesAndValueOfDontWork' class does not return the
concret (not generic) type of 'id'. Note that the only difference
between the example classes are the getter/setter and the "valueOf
style" method.

	I don't know the reason of this strange behavior. Any one could help
me? It was expected?

	Ps.: My java -version:
	"java version "1.5.0_06"
	Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)
	Java HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode)"

	
CODE:

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;


public class IntrospectorTest {
	
	public static void main(String[] args) throws IntrospectionException {
		printProperty(ThreePropertyAndWithoutValueOfWorks.class, "id");
		printProperty(ThreePropertiesAndValueOfDontWork.class, "id");
		printProperty(WithValueOfButJustOnePropertyWorks.class, "id");
		printProperty(ThreePropertiesAndWithoutValueOfWorks.class, "id");
		
	}
	
	public static void printProperty(Class target, String property)
throws IntrospectionException {
		PropertyDescriptor[] pds =
Introspector.getBeanInfo(target).getPropertyDescriptors();
		for (PropertyDescriptor descriptor : pds) {
			if (descriptor.getName().equals(property))
				System.out.println(target.getSimpleName() + " -> " +
descriptor.getName() + ": " + descriptor.getPropertyType().getName());
		}
	}

}

interface Identifiable<T> {
	
	public T getId();
}

class ThreePropertiesAndWithoutValueOfWorks implements
Identifiable<ThreePropertiesAndWithoutValueOfWorks.Id> {
	
	private Id id;	
	private String name;
	private Object other;
	
	
	public Id getId() {
		return id;
	}
	
	public void setId(Id id) {
		this.id = id;
	}

	public Object getOther() {
		return other;
	}
	
	public void setOther(Object other) {
		this.other = other;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public static class Id {		
	}
}

class ThreePropertiesAndValueOfDontWork implements
Identifiable<ThreePropertiesAndValueOfDontWork.Id> {
	
	private Id id;	
	private String name;
	private Object other;
	
	
	public Id getId() {
		return id;
	}
	
	public void setId(Id id) {
		this.id = id;
	}

	public Object getOther() {
		return other;
	}
	
	public void setOther(Object other) {
		this.other = other;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public static ThreePropertyAndWithoutValueOfWorks valueOf(Integer value) {
		return new ThreePropertyAndWithoutValueOfWorks();
	}

	public static class Id {		
	}
}

class ThreePropertyAndWithoutValueOfWorks implements
Identifiable<ThreePropertyAndWithoutValueOfWorks.Id> {
	
	private Id id;
	private String name;
	private Object other;
	
	
	public Id getId() {
		return id;
	}
	
	public void setId(Id id) {
		this.id = id;
	}

	public Object getOther() {
		return other;
	}
	
	public void setOther(Object other) {
		this.other = other;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
		
	public static class Id {		
	}
}

class WithValueOfButJustOnePropertyWorks implements
Identifiable<WithValueOfButJustOnePropertyWorks.Id> {
	
	private Id id;
	
	public Id getId() {
		return id;
	}
	
	public void setId(Id id) {
		this.id = id;
	}	
	
	public static ThreePropertyAndWithoutValueOfWorks valueOf(Integer value) {
		return new ThreePropertyAndWithoutValueOfWorks();
	}
		
	public static class Id {		
	}
}



-- 
Fabio Cechinel Veronez
Bacharel em Ci?ncias da Computa??o - UFSC
Sun Certified Programmer For The Java 2 Platform 1.4
-------------- next part --------------
A non-text attachment was scrubbed...
Name: IntrospectorTest.java
Type: application/octet-stream
Size: 3183 bytes
Desc: not available
Url : /pipermail/attachments/20061025/65a2cd43/attachment.obj 

From unmesh_joshi at hotmail.com  Thu Oct 26 06:39:46 2006
From: unmesh_joshi at hotmail.com (Unmesh joshi)
Date: Thu, 26 Oct 2006 10:39:46 +0000
Subject: [concurrency-interest] Stopping all the threads and getting the
	stack frames
In-Reply-To: <mailman.1.1161792000.10388.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <BAY121-F16EE890F79A76614EF0834EF070@phx.gbl>

Hi,

I was trying to study garbage collector algorithms for java. I am curious to 
know how can we stop all the threads and get the stack frames in each thread 
to search for live object references. Is there any OS level API for doing 
that? How is it done when we implement garbage collector? Are there any 
detailed references for the impementation?

Thanks,
Unmesh

_________________________________________________________________
NRIs: Send Money FREE! Go ahead and register now! 
http://ads.mediaturf.net/event.ng/Type=click&FlightID=20273&AdID=65989&TargetID=11172&Targets=11172&Values=202,414,1093,1264,3122&Redirect=http:%2F%2Fwww.icicinri.net%2Fmoney2india%2F%3Fm2i%3DBAC-MSN%26att%3DMSNTLM2I18CHAR%26rfr%3DMSNTLM2I18CHAR


From dharrigan at gmail.com  Thu Oct 26 08:13:02 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Thu, 26 Oct 2006 05:13:02 -0700 (PDT)
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
Message-ID: <7009924.post@talk.nabble.com>


Hi,

Previously, if I wanted to set a thread name, I could so something like
this:

new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();

now, if I'm delgating over to an Executors, like
Executors.newCachedThreadPool(), and using that to execute my thread:

ExecutorService s = Executors.newCachedThreadPool();
s.execute(new RunnableTask());

The execute method isn't overloaded to provide a name, so, how do I go about
setting the Thread name? 

-=david=-
-- 
View this message in context: http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.html#a7009924
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From mike.quilleash at subexazure.com  Thu Oct 26 08:40:33 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Thu, 26 Oct 2006 08:40:33 -0400
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
Message-ID: <DAE04D9F6FD21448A220918A522FB60E03CDE3CA@MI8NYCMAIL15.Mi8.com>

I asked the same question a while back.  The solution for me was to wrap
up whatever you are submitting to the executor with a Runnable.

Something like

Public class ThreadRenameWrapper implements Runnable
{
  private final String name;
  private final Runnable runnable;

  public ThreadRenameWrapper( String name, Runnable runnable )
  {
    this.name = name;
    this.runnable = runnable;
  }

  public void run()
  {
    Thread thread = Thread.currentThread();
    String oldName = thread.getName();

    thread.setName( name );
    try
    {
      runnable.run();
    }
    finally
    {
      thread.setName( oldName );
    }
  }
}

HTH.

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
Harrigan
Sent: 26 October 2006 13:13
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool


Hi,

Previously, if I wanted to set a thread name, I could so something like
this:

new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();

now, if I'm delgating over to an Executors, like
Executors.newCachedThreadPool(), and using that to execute my thread:

ExecutorService s = Executors.newCachedThreadPool(); s.execute(new
RunnableTask());

The execute method isn't overloaded to provide a name, so, how do I go
about setting the Thread name? 

-=david=-
--
View this message in context:
http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.ht
ml#a7009924
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From holger at wizards.de  Thu Oct 26 08:56:39 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Thu, 26 Oct 2006 14:56:39 +0200
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <7009924.post@talk.nabble.com>
References: <7009924.post@talk.nabble.com>
Message-ID: <4540B087.6080000@wizards.de>

David Harrigan wrote:
> Previously, if I wanted to set a thread name, I could so something like
> this:
> 
> new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
> 
> now, if I'm delgating over to an Executors, like
> Executors.newCachedThreadPool(), and using that to execute my thread:
> 
> ExecutorService s = Executors.newCachedThreadPool();
> s.execute(new RunnableTask());
> 
> The execute method isn't overloaded to provide a name, so, how do I go about
> setting the Thread name? 

You implement the ThreadFactory interface to generate named threads and
plug that into the ExecutorService via setThreadFactory().

public class NamedThreadFactory implements ThreadFactory
{
..
    public Thread newThread(Runnable runnable)
    {
        return new Thread(runnable, this.createNewName());
    }
..
}

-h

From conivek at gmail.com  Thu Oct 26 09:05:06 2006
From: conivek at gmail.com (Kevin Condon)
Date: Thu, 26 Oct 2006 09:05:06 -0400
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E03CDE3CA@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E03CDE3CA@MI8NYCMAIL15.Mi8.com>
Message-ID: <2e780ac60610260605w45bb4e4ax76365961d5781020@mail.gmail.com>

You can use:

ThreadFactory factory = new ThreadFactory() {
  public Thread newThread(Runnable r) {
    return new Thread(r, "threadname");
  }
};
Executors.newCachedThreadPool(factory);

Kevin

On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> I asked the same question a while back.  The solution for me was to wrap
> up whatever you are submitting to the executor with a Runnable.
>
> Something like
>
> Public class ThreadRenameWrapper implements Runnable
> {
>  private final String name;
>  private final Runnable runnable;
>
>  public ThreadRenameWrapper( String name, Runnable runnable )
>  {
>    this.name = name;
>    this.runnable = runnable;
>  }
>
>  public void run()
>  {
>    Thread thread = Thread.currentThread();
>    String oldName = thread.getName();
>
>    thread.setName( name );
>    try
>    {
>      runnable.run();
>    }
>    finally
>    {
>      thread.setName( oldName );
>    }
>  }
> }
>
> HTH.
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> Harrigan
> Sent: 26 October 2006 13:13
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
>
>
> Hi,
>
> Previously, if I wanted to set a thread name, I could so something like
> this:
>
> new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
>
> now, if I'm delgating over to an Executors, like
> Executors.newCachedThreadPool(), and using that to execute my thread:
>
> ExecutorService s = Executors.newCachedThreadPool(); s.execute(new
> RunnableTask());
>
> The execute method isn't overloaded to provide a name, so, how do I go
> about setting the Thread name?
>
> -=david=-
> --
> View this message in context:
> http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.ht
> ml#a7009924
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dharrigan at gmail.com  Thu Oct 26 09:08:45 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Thu, 26 Oct 2006 14:08:45 +0100
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <2e780ac60610260605w45bb4e4ax76365961d5781020@mail.gmail.com>
References: <DAE04D9F6FD21448A220918A522FB60E03CDE3CA@MI8NYCMAIL15.Mi8.com>
	<2e780ac60610260605w45bb4e4ax76365961d5781020@mail.gmail.com>
Message-ID: <7153be990610260608he8c60f4g5a1edc7ec2ae4949@mail.gmail.com>

Hi,

Ooh, that's quite a nice one. I like it.

-=david=-

On 10/26/06, Kevin Condon <conivek at gmail.com> wrote:
>
> You can use:
>
> ThreadFactory factory = new ThreadFactory() {
>   public Thread newThread(Runnable r) {
>     return new Thread(r, "threadname");
>   }
> };
> Executors.newCachedThreadPool(factory);
>
> Kevin
>
> On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> > I asked the same question a while back.  The solution for me was to wrap
> > up whatever you are submitting to the executor with a Runnable.
> >
> > Something like
> >
> > Public class ThreadRenameWrapper implements Runnable
> > {
> >  private final String name;
> >  private final Runnable runnable;
> >
> >  public ThreadRenameWrapper( String name, Runnable runnable )
> >  {
> >    this.name = name;
> >    this.runnable = runnable;
> >  }
> >
> >  public void run()
> >  {
> >    Thread thread = Thread.currentThread();
> >    String oldName = thread.getName();
> >
> >    thread.setName( name );
> >    try
> >    {
> >      runnable.run();
> >    }
> >    finally
> >    {
> >      thread.setName( oldName );
> >    }
> >  }
> > }
> >
> > HTH.
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> > Harrigan
> > Sent: 26 October 2006 13:13
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
> >
> >
> > Hi,
> >
> > Previously, if I wanted to set a thread name, I could so something like
> > this:
> >
> > new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
> >
> > now, if I'm delgating over to an Executors, like
> > Executors.newCachedThreadPool(), and using that to execute my thread:
> >
> > ExecutorService s = Executors.newCachedThreadPool(); s.execute(new
> > RunnableTask());
> >
> > The execute method isn't overloaded to provide a name, so, how do I go
> > about setting the Thread name?
> >
> > -=david=-
> > --
> > View this message in context:
> > http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.ht
> > ml#a7009924
> > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >  This e-mail is bound by the terms and conditions described at
> http://www.subexazure.com/mail-disclaimer.html
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061026/b9872bdf/attachment.html 

From mike.quilleash at subexazure.com  Thu Oct 26 09:16:29 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Thu, 26 Oct 2006 09:16:29 -0400
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
Message-ID: <DAE04D9F6FD21448A220918A522FB60E03CDE449@MI8NYCMAIL15.Mi8.com>

This is simpler if you just need a single name for all threads in the
pool.  My requirement at the time was for a different name per runnable
so I had to do it differently.

Cheers. 

-----Original Message-----
From: Kevin Condon [mailto:conivek at gmail.com] 
Sent: 26 October 2006 14:05
To: Mike Quilleash 
Cc: David Harrigan; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Setting a Thread name in a
ThreadPool

You can use:

ThreadFactory factory = new ThreadFactory() {
  public Thread newThread(Runnable r) {
    return new Thread(r, "threadname");
  }
};
Executors.newCachedThreadPool(factory);

Kevin

On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> I asked the same question a while back.  The solution for me was to 
> wrap up whatever you are submitting to the executor with a Runnable.
>
> Something like
>
> Public class ThreadRenameWrapper implements Runnable {  private final 
> String name;  private final Runnable runnable;
>
>  public ThreadRenameWrapper( String name, Runnable runnable )  {
>    this.name = name;
>    this.runnable = runnable;
>  }
>
>  public void run()
>  {
>    Thread thread = Thread.currentThread();
>    String oldName = thread.getName();
>
>    thread.setName( name );
>    try
>    {
>      runnable.run();
>    }
>    finally
>    {
>      thread.setName( oldName );
>    }
>  }
> }
>
> HTH.
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David

> Harrigan
> Sent: 26 October 2006 13:13
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
>
>
> Hi,
>
> Previously, if I wanted to set a thread name, I could so something 
> like
> this:
>
> new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
>
> now, if I'm delgating over to an Executors, like 
> Executors.newCachedThreadPool(), and using that to execute my thread:
>
> ExecutorService s = Executors.newCachedThreadPool(); s.execute(new 
> RunnableTask());
>
> The execute method isn't overloaded to provide a name, so, how do I go

> about setting the Thread name?
>
> -=david=-
> --
> View this message in context:
> http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.
> ht
> ml#a7009924
> Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>  This e-mail is bound by the terms and conditions described at 
> http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From conivek at gmail.com  Thu Oct 26 09:23:16 2006
From: conivek at gmail.com (Kevin Condon)
Date: Thu, 26 Oct 2006 09:23:16 -0400
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E03CDE449@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E03CDE449@MI8NYCMAIL15.Mi8.com>
Message-ID: <2e780ac60610260623i52ba81f0m374e0202bda07e86@mail.gmail.com>

Hi Mike,

We use a slightly more nuanced ThreadFactory to give unique names to
each thread.

class CountingThreadFactory extends ThreadFactory {
  private static final AtomicInteger count = new AtomicInteger(0);
  public Thread newThread(Runnable r) {
    return new Thread(r, "thread" + count.getAndIncrement());
  }
}

Regards,
Kevin

On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> This is simpler if you just need a single name for all threads in the
> pool.  My requirement at the time was for a different name per runnable
> so I had to do it differently.
>
> Cheers.
>
> -----Original Message-----
> From: Kevin Condon [mailto:conivek at gmail.com]
> Sent: 26 October 2006 14:05
> To: Mike Quilleash
> Cc: David Harrigan; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Setting a Thread name in a
> ThreadPool
>
> You can use:
>
> ThreadFactory factory = new ThreadFactory() {
>  public Thread newThread(Runnable r) {
>    return new Thread(r, "threadname");
>  }
> };
> Executors.newCachedThreadPool(factory);
>
> Kevin
>
> On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> > I asked the same question a while back.  The solution for me was to
> > wrap up whatever you are submitting to the executor with a Runnable.
> >
> > Something like
> >
> > Public class ThreadRenameWrapper implements Runnable {  private final
> > String name;  private final Runnable runnable;
> >
> >  public ThreadRenameWrapper( String name, Runnable runnable )  {
> >    this.name = name;
> >    this.runnable = runnable;
> >  }
> >
> >  public void run()
> >  {
> >    Thread thread = Thread.currentThread();
> >    String oldName = thread.getName();
> >
> >    thread.setName( name );
> >    try
> >    {
> >      runnable.run();
> >    }
> >    finally
> >    {
> >      thread.setName( oldName );
> >    }
> >  }
> > }
> >
> > HTH.
> >
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
>
> > Harrigan
> > Sent: 26 October 2006 13:13
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
> >
> >
> > Hi,
> >
> > Previously, if I wanted to set a thread name, I could so something
> > like
> > this:
> >
> > new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
> >
> > now, if I'm delgating over to an Executors, like
> > Executors.newCachedThreadPool(), and using that to execute my thread:
> >
> > ExecutorService s = Executors.newCachedThreadPool(); s.execute(new
> > RunnableTask());
> >
> > The execute method isn't overloaded to provide a name, so, how do I go
>
> > about setting the Thread name?
> >
> > -=david=-
> > --
> > View this message in context:
> > http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.
> > ht
> > ml#a7009924
> > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >  This e-mail is bound by the terms and conditions described at
> > http://www.subexazure.com/mail-disclaimer.html
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>  This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
>
>

From tim at peierls.net  Thu Oct 26 10:00:59 2006
From: tim at peierls.net (Tim Peierls)
Date: Thu, 26 Oct 2006 10:00:59 -0400
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <2e780ac60610260623i52ba81f0m374e0202bda07e86@mail.gmail.com>
References: <DAE04D9F6FD21448A220918A522FB60E03CDE449@MI8NYCMAIL15.Mi8.com>
	<2e780ac60610260623i52ba81f0m374e0202bda07e86@mail.gmail.com>
Message-ID: <63b4e4050610260700r28382664nf161830651560ac3@mail.gmail.com>

On 10/26/06, Kevin Condon <conivek at gmail.com> wrote:
>
> Hi Mike,
>
> We use a slightly more nuanced ThreadFactory to give unique names to
> each thread.


The default ThreadFactory in j.u.c does this, too.

I think Mike was distinguishing a different name for each thread in the pool
(which you get by default) vs. a different name for each Runnable adopted by
the pool thread when it runs that Runnable.

The latter is at odds with decoupling the work to be done from the execution
policy that determines which thread does what work. The only justification I
can see for it is in debugging or monitoring, but even then I think there
are better solutions, e.g., notify the monitoring agent of pre/post-run()
events using the task identity and thread name instead of setting the thread
name from the task identity.

--tim

On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> > This is simpler if you just need a single name for all threads in the
> > pool.  My requirement at the time was for a different name per runnable
> > so I had to do it differently.
> >
> > Cheers.
> >
> > -----Original Message-----
> > From: Kevin Condon [mailto:conivek at gmail.com]
> > Sent: 26 October 2006 14:05
> > To: Mike Quilleash
> > Cc: David Harrigan; concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Setting a Thread name in a
> > ThreadPool
> >
> > You can use:
> >
> > ThreadFactory factory = new ThreadFactory() {
> >  public Thread newThread(Runnable r) {
> >    return new Thread(r, "threadname");
> >  }
> > };
> > Executors.newCachedThreadPool(factory);
> >
> > Kevin
> >
> > On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
> > > I asked the same question a while back.  The solution for me was to
> > > wrap up whatever you are submitting to the executor with a Runnable.
> > >
> > > Something like
> > >
> > > Public class ThreadRenameWrapper implements Runnable {  private final
> > > String name;  private final Runnable runnable;
> > >
> > >  public ThreadRenameWrapper( String name, Runnable runnable )  {
> > >    this.name = name;
> > >    this.runnable = runnable;
> > >  }
> > >
> > >  public void run()
> > >  {
> > >    Thread thread = Thread.currentThread();
> > >    String oldName = thread.getName();
> > >
> > >    thread.setName( name );
> > >    try
> > >    {
> > >      runnable.run();
> > >    }
> > >    finally
> > >    {
> > >      thread.setName( oldName );
> > >    }
> > >  }
> > > }
> > >
> > > HTH.
> > >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of David
> >
> > > Harrigan
> > > Sent: 26 October 2006 13:13
> > > To: concurrency-interest at cs.oswego.edu
> > > Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
> > >
> > >
> > > Hi,
> > >
> > > Previously, if I wanted to set a thread name, I could so something
> > > like
> > > this:
> > >
> > > new Thread(new RunnableTask(), "DoSomethingWonderfulThread").start();
> > >
> > > now, if I'm delgating over to an Executors, like
> > > Executors.newCachedThreadPool(), and using that to execute my thread:
> > >
> > > ExecutorService s = Executors.newCachedThreadPool(); s.execute(new
> > > RunnableTask());
> > >
> > > The execute method isn't overloaded to provide a name, so, how do I go
> >
> > > about setting the Thread name?
> > >
> > > -=david=-
> > > --
> > > View this message in context:
> > > http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566.
> > > ht
> > > ml#a7009924
> > > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >  This e-mail is bound by the terms and conditions described at
> > > http://www.subexazure.com/mail-disclaimer.html
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> >
> >  This e-mail is bound by the terms and conditions described at
> http://www.subexazure.com/mail-disclaimer.html
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061026/58263070/attachment.html 

From dcholmes at optusnet.com.au  Thu Oct 26 10:41:53 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 27 Oct 2006 00:41:53 +1000
Subject: [concurrency-interest] Stopping all the threads and getting
	thestack frames
In-Reply-To: <BAY121-F16EE890F79A76614EF0834EF070@phx.gbl>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEKJHDAA.dcholmes@optusnet.com.au>

Are you talking about from within Java, or how the virtual machine does it?
The VM triggers a global safepoint at which time all the threads have
walkable stacks, and the GC thread can then walk those stacks. The VM itself
maintains the logical Java stack of each native thread as an explicit data
structure.

There are JVMTI API's for an "external agent" to interact with the threads
in a target VM - including, if I recall correctly, a way to get a stack
trace for each thread.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Unmesh
> joshi
> Sent: Thursday, 26 October 2006 8:40 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Stopping all the threads and getting
> thestack frames
>
>
> Hi,
>
> I was trying to study garbage collector algorithms for java. I am
> curious to
> know how can we stop all the threads and get the stack frames in
> each thread
> to search for live object references. Is there any OS level API for doing
> that? How is it done when we implement garbage collector? Are there any
> detailed references for the impementation?
>
> Thanks,
> Unmesh
>
> _________________________________________________________________
> NRIs: Send Money FREE! Go ahead and register now!
> http://ads.mediaturf.net/event.ng/Type=click&FlightID=20273&AdID=6
5989&TargetID=11172&Targets=11172&Values=202,414,1093,1264,3122&Redirect=htt
p:%2F%2Fwww.icicinri.net%2Fmoney2india%2F%3Fm2i%3DBAC-MSN%26att%3DMSNTLM2I18
CHAR%26rfr%3DMSNTLM2I18CHAR

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dcholmes at optusnet.com.au  Thu Oct 26 10:47:04 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 27 Oct 2006 00:47:04 +1000
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <63b4e4050610260700r28382664nf161830651560ac3@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEKJHDAA.dcholmes@optusnet.com.au>

Right! My question was going to be "what's wrong with the names they have?"

A Runnable can always change the name if security permits, but should set it
back again unless you're sure every submitted Runnable manages the name
itself.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Tim Peierls
  Sent: Friday, 27 October 2006 12:01 AM
  To: Kevin Condon; Mike Quilleash
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Setting a Thread name in a ThreadPool


  On 10/26/06, Kevin Condon <conivek at gmail.com> wrote:
    Hi Mike,

    We use a slightly more nuanced ThreadFactory to give unique names to
    each thread.

  The default ThreadFactory in j.u.c does this, too.

  I think Mike was distinguishing a different name for each thread in the
pool (which you get by default) vs. a different name for each Runnable
adopted by the pool thread when it runs that Runnable .

  The latter is at odds with decoupling the work to be done from the
execution policy that determines which thread does what work. The only
justification I can see for it is in debugging or monitoring, but even then
I think there are better solutions, e.g., notify the monitoring agent of
pre/post-run() events using the task identity and thread name instead of
setting the thread name from the task identity.

  --tim


    On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
    > This is simpler if you just need a single name for all threads in the
    > pool.  My requirement at the time was for a different name per
runnable
    > so I had to do it differently.
    >
    > Cheers.
    >
    > -----Original Message-----
    > From: Kevin Condon [mailto:conivek at gmail.com]
    > Sent: 26 October 2006 14:05
    > To: Mike Quilleash
    > Cc: David Harrigan; concurrency-interest at cs.oswego.edu
    > Subject: Re: [concurrency-interest] Setting a Thread name in a
    > ThreadPool
    >
    > You can use:
    >
    > ThreadFactory factory = new ThreadFactory() {
    >  public Thread newThread(Runnable r) {
    >    return new Thread(r, "threadname");
    >  }
    > };
    > Executors.newCachedThreadPool(factory);
    >
    > Kevin
    >
    > On 10/26/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
    > > I asked the same question a while back.  The solution for me was to
    > > wrap up whatever you are submitting to the executor with a Runnable.
    > >
    > > Something like
    > >
    > > Public class ThreadRenameWrapper implements Runnable {  private
final
    > > String name;  private final Runnable runnable;
    > >
    > >  public ThreadRenameWrapper( String name, Runnable runnable )  {
    > >    this.name = name;
    > >    this.runnable = runnable;
    > >  }
    > >
    > >  public void run()
    > >  {
    > >    Thread thread = Thread.currentThread ();
    > >    String oldName = thread.getName();
    > >
    > >    thread.setName( name );
    > >    try
    > >    {
    > >      runnable.run();
    > >    }
    > >    finally
    > >    {
    > >      thread.setName( oldName );
    > >    }
    > >  }
    > > }
    > >
    > > HTH.
    > >
    > > -----Original Message-----
    > > From: concurrency-interest-bounces at cs.oswego.edu
    > > [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of
David
    >
    > > Harrigan
    > > Sent: 26 October 2006 13:13
    > > To: concurrency-interest at cs.oswego.edu
    > > Subject: [concurrency-interest] Setting a Thread name in a
ThreadPool
    > >
    > >
    > > Hi,
    > >
    > > Previously, if I wanted to set a thread name, I could so something
    > > like
    > > this:
    > >
    > > new Thread(new RunnableTask(),
"DoSomethingWonderfulThread").start();
    > >
    > > now, if I'm delgating over to an Executors, like
    > > Executors.newCachedThreadPool(), and using that to execute my
thread:
    > >
    > > ExecutorService s = Executors.newCachedThreadPool (); s.execute(new
    > > RunnableTask());
    > >
    > > The execute method isn't overloaded to provide a name, so, how do I
go
    >
    > > about setting the Thread name?
    > >
    > > -=david=-
    > > --
    > > View this message in context:
    > >
http://www.nabble.com/Setting-a-Thread-name-in-a-ThreadPool-tf2513566 .
    > > ht
    > > ml#a7009924
    > > Sent from the JSR166 Concurrency mailing list archive at Nabble.com.
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at altair.cs.oswego.edu
    > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    > >
    > >  This e-mail is bound by the terms and conditions described at
    > > http://www.subexazure.com/mail-disclaimer.html
    > >
    > >
    > > _______________________________________________
    > > Concurrency-interest mailing list
    > > Concurrency-interest at altair.cs.oswego.edu
    > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
    > >
    >
    >
    >  This e-mail is bound by the terms and conditions described at
http://www.subexazure.com/mail-disclaimer.html
    >
    >
    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at altair.cs.oswego.edu
    http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061027/411acfa9/attachment-0001.html 

From gregg at cytetech.com  Thu Oct 26 12:08:36 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Thu, 26 Oct 2006 11:08:36 -0500
Subject: [concurrency-interest] Setting a Thread name in a ThreadPool
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEKJHDAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCGEKJHDAA.dcholmes@optusnet.com.au>
Message-ID: <4540DD84.8000807@cytetech.com>



David Holmes wrote:
> Right! My question was going to be "what's wrong with the names they have?"

In multi-threaded applications, I like to put the IP address of a client being 
served, a database key name of a row being updated etc on my threads so that I 
can tell from the trace, which threads and which associated data are "stuck", or 
having particular issues.

Gregg Wonderly

From jmanson at cs.umd.edu  Fri Oct 27 02:07:05 2006
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Thu, 26 Oct 2006 23:07:05 -0700
Subject: [concurrency-interest] Volatile field use cases?
Message-ID: <4541A209.2090909@cs.umd.edu>

Hi folks,

Some of us were talking off line about the ways in which people use 
volatile fields.  They can be used for writing a variety of interesting 
data structures, like non-blocking queues, but I have no idea how many 
people are doing this.

I thought it might be interesting to ask the crowd here about the more 
interesting ways in which you use volatiles.  Do you have something 
fabulously interesting that you do?  Do you write non-blocking data 
structures?  One thing I don't really know is if people ever write code 
that relies on strong guarantees between more than one volatile field -- 
do you?

Basically, what are you folks using them to do?

All of this is by way of finding out what the impact of the JMM has 
been, now that we are a couple of years down the line: seeing what works 
and what doesn't, and laying out plans for future memory models.

Thanks,

					Jeremy

From conivek at gmail.com  Fri Oct 27 08:03:55 2006
From: conivek at gmail.com (Kevin Condon)
Date: Fri, 27 Oct 2006 08:03:55 -0400
Subject: [concurrency-interest] Volatile field use cases?
In-Reply-To: <4541A209.2090909@cs.umd.edu>
References: <4541A209.2090909@cs.umd.edu>
Message-ID: <2e780ac60610270503o534ef27bl581ef051f095dcb@mail.gmail.com>

I don't have any unique uses for volatiles to describe, but I think
this is an important topic.  When I started using Java back around
1999, the rumor was that volatile semantics were not reliable in all
JVM implementations and that the use of synchronized blocks was the
approach of choice.  The rumors were not incredibly well
substantiated, but it was enough that many of us put volatiles in the
closet.  That's a habit that I'm beginning to change with the new JMM,
and this kind of discussion could help to stimulate that change.

Regards,
Kevin

On 10/27/06, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Hi folks,
>
> Some of us were talking off line about the ways in which people use
> volatile fields.  They can be used for writing a variety of interesting
> data structures, like non-blocking queues, but I have no idea how many
> people are doing this.
>
> I thought it might be interesting to ask the crowd here about the more
> interesting ways in which you use volatiles.  Do you have something
> fabulously interesting that you do?  Do you write non-blocking data
> structures?  One thing I don't really know is if people ever write code
> that relies on strong guarantees between more than one volatile field --
> do you?
>
> Basically, what are you folks using them to do?
>
> All of this is by way of finding out what the impact of the JMM has
> been, now that we are a couple of years down the line: seeing what works
> and what doesn't, and laying out plans for future memory models.
>
> Thanks,
>
>                                        Jeremy
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dharrigan at gmail.com  Fri Oct 27 09:37:55 2006
From: dharrigan at gmail.com (David Harrigan)
Date: Fri, 27 Oct 2006 06:37:55 -0700 (PDT)
Subject: [concurrency-interest] CompletionService and I/O - can I use it?
Message-ID: <7030419.post@talk.nabble.com>


Hi,

Another posting ;) I appreciate all the help I'm getting in this to further
my (and maybe other's) understanding.

Rethinking my problem, I have decided to take the advice and use a
CompletionService to hand off the searchers, and to wait for their results,
so I have something like this:

...
private final CompletionService<Searcher> ecs =
ExecutorCompletionService<Searcher>(Executors.newCachedThreadPool());

public void search(final List<Searcher> searchers) {
    for(Searcher searcher : searchers) {
        ecs.submit(searcher);
    }

    for(int i = 0, j = searchers.size() ; i < j ; i++) {
        try {
            Future<Searcher> result = ecs.poll(1000, TimeUnit.MILLISECONDS);
            if(result != null) {
              Searcher s = result.get();
              // do something with s now...
            }
        } catch(InterruptedException e) { 
           Thread.currentThread().interrupt();
        } catch(ExecutionException e) {
           e.printStackTrace();
        }
}

This I think gives me the ability to poll each searcher for 1 second. But I
have two
questions:

1. A searcher makes a connection to the outside world, this could take more
than 1
second, or it could take less than 1 second. If it takes more than 1 second,
fine, then
it's dead and I don't care about it, but say it makes a connection within 1
second, but
then takes another 2 seconds to retrieve the results, the method above will
timeout
the searcher and I won't be able to do anything with it. What I would
ideally like is
the ability to poll for the searcher, then if it's doing something, to wait
for it to 
complete. Can I somehow shove it back on the queue? Or to "peek" inside the
queue to see if my searcher is doing anything interesting?

2. Perhaps using a CompletionService isn't appropriate in this case? You
see, I have
3 states a search can move thru:

Connected but not reading
Reading
Finished

each of those states could timeout. I can control the first one, but I need
to be
able to pause acting on the searcher if it's reading for another bit of
time, but
eventually to timeout if reading is taking too long...

Has anyone else come across this situation (it must be common! - it's a
basic
I/O read/wait time of situation) and using threads to control it? I would
appreciate
any help/advice on this.

-=david=-

-- 
View this message in context: http://www.nabble.com/CompletionService-and-I-O---can-I-use-it--tf2520636.html#a7030419
Sent from the JSR166 Concurrency mailing list archive at Nabble.com.


From hanson.char at gmail.com  Fri Oct 27 12:39:12 2006
From: hanson.char at gmail.com (Hanson Char)
Date: Fri, 27 Oct 2006 09:39:12 -0700
Subject: [concurrency-interest] Volatile field use cases?
In-Reply-To: <4541A209.2090909@cs.umd.edu>
References: <4541A209.2090909@cs.umd.edu>
Message-ID: <ca53c8f80610270939t51ba8d21pafee2af5c267ebd5@mail.gmail.com>

For some/many reasons, I've been finding volatile useful all the time.
 One pattern I find particularly interesting is the way volatile is
taken advantage of in the implementation of CopyOnWriteArrayList.  The
other is to use volatile to ensure safe publication when a field
cannot be made final.

My 2 cents.

Hanson

On 10/26/06, Jeremy Manson <jmanson at cs.umd.edu> wrote:
> Hi folks,
>
> Some of us were talking off line about the ways in which people use
> volatile fields.  They can be used for writing a variety of interesting
> data structures, like non-blocking queues, but I have no idea how many
> people are doing this.
>
> I thought it might be interesting to ask the crowd here about the more
> interesting ways in which you use volatiles.  Do you have something
> fabulously interesting that you do?  Do you write non-blocking data
> structures?  One thing I don't really know is if people ever write code
> that relies on strong guarantees between more than one volatile field --
> do you?
>
> Basically, what are you folks using them to do?
>
> All of this is by way of finding out what the impact of the JMM has
> been, now that we are a couple of years down the line: seeing what works
> and what doesn't, and laying out plans for future memory models.
>
> Thanks,
>
>                                         Jeremy
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From tim at peierls.net  Sat Oct 28 11:58:48 2006
From: tim at peierls.net (Tim Peierls)
Date: Sat, 28 Oct 2006 11:58:48 -0400
Subject: [concurrency-interest] CompletionService and I/O - can I use it?
In-Reply-To: <7030419.post@talk.nabble.com>
References: <7030419.post@talk.nabble.com>
Message-ID: <63b4e4050610280858w36637726m65450362a89eee82@mail.gmail.com>

A completion service is appropriate if you want to get results from tasks as
they complete (either by having a result or by throwing an exception). The
completion service returns completed tasks; the timed poll method waits the
given duration for any task to become available by completing, not one
particular task.

You are submitting Searcher instances to a CompletionService<Searcher>,
which means that Searcher must implement Callable<Searcher>. This could be
part of a design where the call method of the Searcher establishes the
connection and reads some data, throwing an exception if either of these
activities take too long. Otherwise, if connection and reading complete
successfully, the call method returns the searcher itself. Then a sequence
of ready-to-use Searchers could be obtained by calling the following method
in a loop:

Searcher getNextReadySearcher(long deadlineNanos)
            throws TimeoutException, InterruptedException {
    while (true) {
        try {
            long remainingNanos = deadlineNanos - System.nanoTime();
            if (remainingNanos > 0) {
                Future<Searcher> f = ecs.poll(remainingNanos,
TimeUnit.NANOSECONDS);
                if (f != null) return f.get();
            }
            throw new TimeoutException("deadline passed");
        } catch (ExecutionException e) {
            // could resubmit if exception refers to Searcher
            if (e.getCause() instanceof SearcherException) {
                SearcherException se = (SearcherException) e.getCause();
                ecs.submit(se.getSearcher());
            }
            // retry loop
        }
    }
}

For an example of doing work with a time budget, see Section 6.3.7 of Java
Concurrency in Practice. For an example of nonstandard cancellation within
the task execution framework, see Section 7.1.7.

--tim


On 10/27/06, David Harrigan <dharrigan at gmail.com> wrote:
>
>
> Hi,
>
> Another posting ;) I appreciate all the help I'm getting in this to
> further
> my (and maybe other's) understanding.
>
> Rethinking my problem, I have decided to take the advice and use a
> CompletionService to hand off the searchers, and to wait for their
> results,
> so I have something like this:
>
> ...
> private final CompletionService<Searcher> ecs =
> ExecutorCompletionService<Searcher>(Executors.newCachedThreadPool());
>
> public void search(final List<Searcher> searchers) {
>     for(Searcher searcher : searchers) {
>         ecs.submit(searcher);
>     }
>
>     for(int i = 0, j = searchers.size() ; i < j ; i++) {
>         try {
>             Future<Searcher> result = ecs.poll (1000,
> TimeUnit.MILLISECONDS);
>             if(result != null) {
>               Searcher s = result.get();
>               // do something with s now...
>             }
>         } catch(InterruptedException e) {
>            Thread.currentThread().interrupt();
>         } catch(ExecutionException e) {
>            e.printStackTrace();
>         }
> }
>
> This I think gives me the ability to poll each searcher for 1 second. But
> I
> have two
> questions:
>
> 1. A searcher makes a connection to the outside world, this could take
> more
> than 1
> second, or it could take less than 1 second. If it takes more than 1
> second,
> fine, then
> it's dead and I don't care about it, but say it makes a connection within
> 1
> second, but
> then takes another 2 seconds to retrieve the results, the method above
> will
> timeout
> the searcher and I won't be able to do anything with it. What I would
> ideally like is
> the ability to poll for the searcher, then if it's doing something, to
> wait
> for it to
> complete. Can I somehow shove it back on the queue? Or to "peek" inside
> the
> queue to see if my searcher is doing anything interesting?
>
> 2. Perhaps using a CompletionService isn't appropriate in this case? You
> see, I have
> 3 states a search can move thru:
>
> Connected but not reading
> Reading
> Finished
>
> each of those states could timeout. I can control the first one, but I
> need
> to be
> able to pause acting on the searcher if it's reading for another bit of
> time, but
> eventually to timeout if reading is taking too long...
>
> Has anyone else come across this situation (it must be common! - it's a
> basic
> I/O read/wait time of situation) and using threads to control it? I would
> appreciate
> any help/advice on this.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061028/7c59310b/attachment.html 

From moran at gigaspaces.com  Mon Oct 30 17:57:45 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Tue, 31 Oct 2006 00:57:45 +0200
Subject: [concurrency-interest] proper handling of InterruptedException
Message-ID: <45468369.1090207@gigaspaces.com>

A question arose, your opinions are welcome -

What is considered a proper handling of InterrupedException?
Is it a common practice to throw InterruptedException when the thread 
was interrupted while waiting?
or should the thread catch it, ignore it and gracefully die?

Thank you.

-- 
Moran


From joe.bowbeer at gmail.com  Mon Oct 30 18:37:05 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 30 Oct 2006 15:37:05 -0800
Subject: [concurrency-interest] proper handling of InterruptedException
In-Reply-To: <45468369.1090207@gigaspaces.com>
References: <45468369.1090207@gigaspaces.com>
Message-ID: <31f2a7bd0610301537v7a7bd535rc3720b06c96fbdd7@mail.gmail.com>

If interrupts are used as the primary means of cancellation then I
prefer that blocking methods be interruptible and that all
interruptible methods declare "throws InterruptedException" -- and
that InterruptedExceptions "happen" with as little interference as
possible.

This is simple to implement at the sight of the interrupt and, at
runtime, results in a clear record of where the interrupt was
detected. It also encourages a kind of rigor wrt exceptions and
shutdown that is good for you :-)

Note that even if your method throws InterruptedException, it still
might need to catch the exception before rethrowing it, for example if
some post-interrupt cleanup is needed.

On 10/30/06, Moran Avigdor <moran at gigaspaces.com> wrote:
> A question arose, your opinions are welcome -
>
> What is considered a proper handling of InterrupedException?
> Is it a common practice to throw InterruptedException when the thread
> was interrupted while waiting?
> or should the thread catch it, ignore it and gracefully die?
>

From brian at quiotix.com  Mon Oct 30 18:52:45 2006
From: brian at quiotix.com (Brian Goetz)
Date: Mon, 30 Oct 2006 18:52:45 -0500
Subject: [concurrency-interest] proper handling of InterruptedException
In-Reply-To: <45468369.1090207@gigaspaces.com>
References: <45468369.1090207@gigaspaces.com>
Message-ID: <4546904D.3050500@quiotix.com>

The cardinal rule is: Never hide the fact that an interruption occurred.

So, your choices are:
  - Throw IE yourself
  - Re-set the interrupted bit (Thread.currentThread().interrupt())
  - Handle the interruption

The classes in JUC (like BlockingQueue and Semaphore) throw IE since 
their caller is in a better position to deal with the interruption than 
they are.

Lots more detail in JCiP Ch 7.

Moran Avigdor wrote:
> A question arose, your opinions are welcome -
> 
> What is considered a proper handling of InterrupedException?
> Is it a common practice to throw InterruptedException when the thread 
> was interrupted while waiting?
> or should the thread catch it, ignore it and gracefully die?
> 
> Thank you.
> 

From dcholmes at optusnet.com.au  Mon Oct 30 19:03:50 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 31 Oct 2006 10:03:50 +1000
Subject: [concurrency-interest] proper handling of InterruptedException
In-Reply-To: <45468369.1090207@gigaspaces.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEMDHDAA.dcholmes@optusnet.com.au>

Just one additional note:

> or should the thread catch it, ignore it and gracefully die?

The only circumstances where a thread can "gracefully die" due to an
exception is in the threasd's own run() method - where a return will cause
the thread to gracefully die. In that one case it is fine to catch it and
gracefully die - you aren't ignoring it as you are dying in response to it.

But any method further down the call chain needs to re-throw or re-assert as
Brian/Joe mentioned.

Cheers,
David Holmes


From egordienko at yahoo.com  Tue Oct 31 10:35:51 2006
From: egordienko at yahoo.com (Eugene Gordienko)
Date: Tue, 31 Oct 2006 07:35:51 -0800 (PST)
Subject: [concurrency-interest] Fixed size CopyOnWriteArrayList vs array
	concurrent access.
Message-ID: <20061031153551.60710.qmail@web33402.mail.mud.yahoo.com>


 Hi All,

We use java 1.4. We have a use case: fixed size array of objects and need concurrent access to its elements: almost even number of reads and
writes, also some iterations. The size may be less than 10 but may be more than 100.

So my choice was fixed size CopyOnWriteArrayList (COWAL) ...  but my collegues'  argument  is: when we wrie to COWAL the chunk of it is locked
while in case of array of objects we can lock just on one array element.

What is your experience/suggestion?

Many thanks,
Eugene






From tim at peierls.net  Tue Oct 31 11:37:39 2006
From: tim at peierls.net (Tim Peierls)
Date: Tue, 31 Oct 2006 11:37:39 -0500
Subject: [concurrency-interest] Fixed size CopyOnWriteArrayList vs array
	concurrent access.
In-Reply-To: <20061031153551.60710.qmail@web33402.mail.mud.yahoo.com>
References: <20061031153551.60710.qmail@web33402.mail.mud.yahoo.com>
Message-ID: <63b4e4050610310837x47f31443h53efeb58d29a92a@mail.gmail.com>

COWAL is most appropriate when writes are infrequent.

I think the simplest approach in your case is an array of thread-safe
value-holders. You could use SynchronizedRef from Doug Lea's
util.concurrentpackage, or AtomicReference from Dawid Kurzyniec's
backport. Or just roll
your own.

Note that this only deals with concurrent access of the elements as opaque
values. It does not address the issue of whether the element values
themselves refer to thread-safe objects; if they do not, then two threads
might safely obtain the value of the first element in the array only to
unsafely call methods of the object referred to by that value.

--tim

On 10/31/06, Eugene Gordienko <egordienko at yahoo.com> wrote:
>
>
> Hi All,
>
> We use java 1.4. We have a use case: fixed size array of objects and need
> concurrent access to its elements: almost even number of reads and
> writes, also some iterations. The size may be less than 10 but may be more
> than 100.
>
> So my choice was fixed size CopyOnWriteArrayList (COWAL) ...  but my
> collegues'  argument  is: when we wrie to COWAL the chunk of it is locked
> while in case of array of objects we can lock just on one array element.
>
> What is your experience/suggestion?
>
> Many thanks,
> Eugene
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20061031/bb3e41cc/attachment.html 

From brian at quiotix.com  Tue Oct 31 12:51:02 2006
From: brian at quiotix.com (Brian Goetz)
Date: Tue, 31 Oct 2006 12:51:02 -0500
Subject: [concurrency-interest] Fixed size CopyOnWriteArrayList vs array
 concurrent access.
In-Reply-To: <20061031153551.60710.qmail@web33402.mail.mud.yahoo.com>
References: <20061031153551.60710.qmail@web33402.mail.mud.yahoo.com>
Message-ID: <45478D06.1030508@quiotix.com>

Your colleague has an incorrect understanding.

Because the backing array is effectively immutable (not modified after 
publication), for readers it only needs to be locked briefly to 
guarantee visibility of the reference the the array.  (In fact, the 
implementation can do even better than that, but the point is that 
multiple threads can iterate the list concurrently.)

The cost comes when you want to modify the list.  Then the list has to 
be copied; if modifications are frequent, this can have significant 
costs.  (In a naive implementation, newly arriving readers may be locked 
out during the copy operation, but there are tricks to prevent this.) 
COW structures are useful when reads greatly outnumber writes or the 
size of the collection is small.

Eugene Gordienko wrote:
>  Hi All,
> 
> We use java 1.4. We have a use case: fixed size array of objects and need concurrent access to its elements: almost even number of reads and
> writes, also some iterations. The size may be less than 10 but may be more than 100.
> 
> So my choice was fixed size CopyOnWriteArrayList (COWAL) ...  but my collegues'  argument  is: when we wrie to COWAL the chunk of it is locked
> while in case of array of objects we can lock just on one array element.
> 
> What is your experience/suggestion?
> 
> Many thanks,
> Eugene
> 
> 
> 
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest

