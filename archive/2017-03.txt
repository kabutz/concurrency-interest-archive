From akarnokd at gmail.com  Wed Mar  1 03:54:00 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 1 Mar 2017 09:54:00 +0100
Subject: [concurrency-interest] request(0) in Flow.Subscription and in
	SubmissionPublisher
Message-ID: <CAAWwtm-q5hRX9gA5hCDCEL__HHERk0qU5wY4cfi=M17jncLNdQ@mail.gmail.com>

Hi,

according to the Reactive-Streams specification, requesting non-positive
value is forbidden and must be rewarded with an onError:

> §3.9: While the Subscription is not cancelled, Subscription.request(long
n) MUST signal onError with a java.lang.IllegalArgumentException if the
argument is <= 0. The cause message MUST include a reference to this rule
and/or quote the full rule.

However, the Flow.Subscription essentially ignores 0:

> If {@code n} is
> negative, the Subscriber will receive an {@code onError}
> signal with an {@link IllegalArgumentException} argument.
> Otherwise, the Subscriber will receive up to {@code n}
> additional {@code onNext} invocations (or fewer if
> terminated)


SubmissionPublisher<Integer> sp = new SubmissionPublisher<>(Runnable::run, 128);
Throwable[] err = { null };

sp.subscribe(new Flow.Subscriber<Integer>() {
    @Override
    public void onSubscribe(Flow.Subscription subscription) {
        subscription.request(0L);
    }

    @Override
    public void onNext(Integer item) {

    }

    @Override
    public void onError(Throwable throwable) {
        err[0] = throwable;
    }

    @Override
    public void onComplete() {

    }
});

assertNotNull(err[0]);


Was this a deliberate change?

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/238d2e56/attachment.html>

From akarnokd at gmail.com  Wed Mar  1 04:50:46 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 1 Mar 2017 10:50:46 +0100
Subject: [concurrency-interest] Running SubmissionPublisher with the
	Reactive-Streams TCK
Message-ID: <CAAWwtm-cL-+68U+9S9ehvaUPgh=MruRJdk_nSkH3=X-DGzuRHQ@mail.gmail.com>

Hello.

I've run the SubmissionPublisher against the Reactive-Streams TCK via the
following code:

import org.reactivestreams.Publisher;
import org.reactivestreams.tck.PublisherVerification;
import org.reactivestreams.tck.TestEnvironment;
import org.testng.annotations.Test;

import java.util.concurrent.Flow;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.SubmissionPublisher;

@Test
public class SubmissionPublisherTckTest extends PublisherVerification<Integer> {

    public SubmissionPublisherTckTest() {
        super(new TestEnvironment(200));
    }

    @Override
    public Publisher<Integer> createPublisher(long elements) {
        SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
        ForkJoinPool.commonPool().submit(() -> {
            while (!sp.hasSubscribers()) {
                Thread.yield();
            }
            for (int i = 0; i < elements; i++) {
                sp.submit(i);
            }
            sp.close();
        });
        return toRs(sp);
    }

    @Override
    public Publisher<Integer> createFailedPublisher() {
        return null;
    }

    @Override
    public long maxElementsFromPublisher() {
        return 100;
    }

    <T> org.reactivestreams.Publisher<T> toRs(Flow.Publisher<T> fp) {
        return rs -> {
            fp.subscribe(new Flow.Subscriber<T>() {

                @Override
                public void onSubscribe(Flow.Subscription subscription) {
                    rs.onSubscribe(new org.reactivestreams.Subscription() {

                        @Override
                        public void request(long l) {
                            subscription.request(l);
                        }

                        @Override
                        public void cancel() {
                            subscription.cancel();
                        }
                    });
                }

                @Override
                public void onNext(T item) {
                    rs.onNext(item);
                }

                @Override
                public void onError(Throwable throwable) {
                    rs.onError(throwable);
                }

                @Override
                public void onComplete() {
                    rs.onComplete();
                }
            });
        };
    }

}


It requires the "org.reactivestreams:reactive-streams-tck:1.0.0" dependency.

There were 3 failures:


   - SubmissionPublisherTckTest.required_spec109_subscribeThrowNPEOnNullSubscriber


java.lang.AssertionError: Publisher did not throw a NullPointerException
when given a null Subscribe in subscribe

at org.testng.Assert.fail(Assert.java:89)
at org.reactivestreams.tck.TestEnvironment.flop(TestEnvironment.java:117)
at
org.reactivestreams.tck.PublisherVerification$10.run(PublisherVerification.java:459)
at
org.reactivestreams.tck.PublisherVerification.activePublisherTest(PublisherVerification.java:1092)
at
org.reactivestreams.tck.PublisherVerification.required_spec109_subscribeThrowNPEOnNullSubscriber(PublisherVerification.java:454)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
Method)
at
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:547)
at
org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:74)
at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
at
org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)
at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
at org.testng.TestRunner.privateRun(TestRunner.java:749)
at org.testng.TestRunner.run(TestRunner.java:600)
at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
at org.testng.SuiteRunner.run(SuiteRunner.java:223)
at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
at org.testng.TestNG.run(TestNG.java:900)
at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)


   - SubmissionPublisherTckTest.required_spec309_requestNegativeNumberMustSignalIllegalArgumentException



java.lang.AssertionError: Got expected exception [class
java.lang.IllegalArgumentException] but missing message part [3.9], was:
negative subscription request
Expected :true
Actual   :false
 <Click to see difference>


at org.testng.Assert.fail(Assert.java:89)
at org.testng.Assert.failNotEquals(Assert.java:480)
at org.testng.Assert.assertTrue(Assert.java:37)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectErrorWithMessage(TestEnvironment.java:466)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectErrorWithMessage(TestEnvironment.java:459)
at
org.reactivestreams.tck.PublisherVerification$22.run(PublisherVerification.java:876)
at
org.reactivestreams.tck.PublisherVerification.activePublisherTest(PublisherVerification.java:1092)
at
org.reactivestreams.tck.PublisherVerification.required_spec309_requestNegativeNumberMustSignalIllegalArgumentException(PublisherVerification.java:870)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
Method)
at
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:547)
at
org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:74)
at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
at
org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)
at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
at org.testng.TestRunner.privateRun(TestRunner.java:749)
at org.testng.TestRunner.run(TestRunner.java:600)
at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
at org.testng.SuiteRunner.run(SuiteRunner.java:223)
at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
at org.testng.TestNG.run(TestNG.java:900)
at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)


   -
   SubmissionPublisherTckTest.required_spec309_requestZeroMustSignalIllegalArgumentException


java.lang.AssertionError: Expected
onError(java.lang.IllegalArgumentException) within 200 ms

at org.testng.Assert.fail(Assert.java:78)
at
org.reactivestreams.tck.TestEnvironment.flopAndFail(TestEnvironment.java:180)
at
org.reactivestreams.tck.TestEnvironment$Receptacle.expectError(TestEnvironment.java:930)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectError(TestEnvironment.java:484)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectError(TestEnvironment.java:476)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectErrorWithMessage(TestEnvironment.java:464)
at
org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectErrorWithMessage(TestEnvironment.java:459)
at
org.reactivestreams.tck.PublisherVerification$21.run(PublisherVerification.java:862)
at
org.reactivestreams.tck.PublisherVerification.activePublisherTest(PublisherVerification.java:1092)
at
org.reactivestreams.tck.PublisherVerification.required_spec309_requestZeroMustSignalIllegalArgumentException(PublisherVerification.java:858)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
Method)
at
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:547)
at
org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:74)
at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
at
org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)
at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
at org.testng.TestRunner.privateRun(TestRunner.java:749)
at org.testng.TestRunner.run(TestRunner.java:600)
at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
at org.testng.SuiteRunner.run(SuiteRunner.java:223)
at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
at org.testng.TestNG.run(TestNG.java:900)
at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)
Caused by: java.lang.AssertionError: Expected
onError(java.lang.IllegalArgumentException) within 200 ms
at org.testng.Assert.fail(Assert.java:89)
at
org.reactivestreams.tck.TestEnvironment.flopAndFail(TestEnvironment.java:177)
... 32 more



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/f6c9e1b7/attachment-0001.html>

From akarnokd at gmail.com  Wed Mar  1 05:16:45 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Wed, 1 Mar 2017 11:16:45 +0100
Subject: [concurrency-interest] Running SubmissionPublisher with the
	Reactive-Streams TCK
In-Reply-To: <CAAWwtm-cL-+68U+9S9ehvaUPgh=MruRJdk_nSkH3=X-DGzuRHQ@mail.gmail.com>
References: <CAAWwtm-cL-+68U+9S9ehvaUPgh=MruRJdk_nSkH3=X-DGzuRHQ@mail.gmail.com>
Message-ID: <CAAWwtm8AcL=vGqBE_H=_wKODgvYBEUT0VS8ks34OXoWEi6MeHg@mail.gmail.com>

Correction, the failure due to
SubmissionPublisherTckTest.required_spec109_subscribeThrowNPEOnNullSubscriber
was my mistake not forwarding a null in the toRs() converter function:

return rs -> {
    if (rs == null) {
        fp.subscribe(null);
        return;
    }
    fp.subscribe(new Flow.Subscriber<T>() {




2017-03-01 10:50 GMT+01:00 Dávid Karnok <akarnokd at gmail.com>:

> Hello.
>
> I've run the SubmissionPublisher against the Reactive-Streams TCK via the
> following code:
>
> import org.reactivestreams.Publisher;
> import org.reactivestreams.tck.PublisherVerification;
> import org.reactivestreams.tck.TestEnvironment;
> import org.testng.annotations.Test;
>
> import java.util.concurrent.Flow;
> import java.util.concurrent.ForkJoinPool;
> import java.util.concurrent.SubmissionPublisher;
>
> @Test
> public class SubmissionPublisherTckTest extends PublisherVerification<Integer> {
>
>     public SubmissionPublisherTckTest() {
>         super(new TestEnvironment(200));
>     }
>
>     @Override
>     public Publisher<Integer> createPublisher(long elements) {
>         SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();
>         ForkJoinPool.commonPool().submit(() -> {
>             while (!sp.hasSubscribers()) {
>                 Thread.yield();
>             }
>             for (int i = 0; i < elements; i++) {
>                 sp.submit(i);
>             }
>             sp.close();
>         });
>         return toRs(sp);
>     }
>
>     @Override
>     public Publisher<Integer> createFailedPublisher() {
>         return null;
>     }
>
>     @Override
>     public long maxElementsFromPublisher() {
>         return 100;
>     }
>
>     <T> org.reactivestreams.Publisher<T> toRs(Flow.Publisher<T> fp) {
>         return rs -> {
>             fp.subscribe(new Flow.Subscriber<T>() {
>
>                 @Override
>                 public void onSubscribe(Flow.Subscription subscription) {
>                     rs.onSubscribe(new org.reactivestreams.Subscription() {
>
>                         @Override
>                         public void request(long l) {
>                             subscription.request(l);
>                         }
>
>                         @Override
>                         public void cancel() {
>                             subscription.cancel();
>                         }
>                     });
>                 }
>
>                 @Override
>                 public void onNext(T item) {
>                     rs.onNext(item);
>                 }
>
>                 @Override
>                 public void onError(Throwable throwable) {
>                     rs.onError(throwable);
>                 }
>
>                 @Override
>                 public void onComplete() {
>                     rs.onComplete();
>                 }
>             });
>         };
>     }
>
> }
>
>
> It requires the "org.reactivestreams:reactive-streams-tck:1.0.0"
> dependency.
>
> There were 3 failures:
>
>
>    - SubmissionPublisherTckTest.required_spec109_
>    subscribeThrowNPEOnNullSubscriber
>
> java.lang.AssertionError: Publisher did not throw a NullPointerException
> when given a null Subscribe in subscribe
>
> at org.testng.Assert.fail(Assert.java:89)
> at org.reactivestreams.tck.TestEnvironment.flop(TestEnvironment.java:117)
> at org.reactivestreams.tck.PublisherVerification$10.run(
> PublisherVerification.java:459)
> at org.reactivestreams.tck.PublisherVerification.activePublisherTest(
> PublisherVerification.java:1092)
> at org.reactivestreams.tck.PublisherVerification.required_spec109_
> subscribeThrowNPEOnNullSubscriber(PublisherVerification.java:454)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
> Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(
> NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(
> DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:547)
> at org.testng.internal.MethodInvocationHelper.invokeMethod(
> MethodInvocationHelper.java:74)
> at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
> at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
> at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
> at org.testng.internal.TestMethodWorker.invokeTestMethods(
> TestMethodWorker.java:125)
> at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
> at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
> at org.testng.TestRunner.privateRun(TestRunner.java:749)
> at org.testng.TestRunner.run(TestRunner.java:600)
> at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
> at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
> at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
> at org.testng.SuiteRunner.run(SuiteRunner.java:223)
> at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
> at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
> at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
> at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
> at org.testng.TestNG.run(TestNG.java:900)
> at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
> at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)
>
>
>    - SubmissionPublisherTckTest.required_spec309_
>    requestNegativeNumberMustSignalIllegalArgumentException
>
>
> java.lang.AssertionError: Got expected exception [class java.lang.IllegalArgumentException]
> but missing message part [3.9], was: negative subscription request
> Expected :true
> Actual   :false
>  <Click to see difference>
>
>
> at org.testng.Assert.fail(Assert.java:89)
> at org.testng.Assert.failNotEquals(Assert.java:480)
> at org.testng.Assert.assertTrue(Assert.java:37)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.
> expectErrorWithMessage(TestEnvironment.java:466)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.
> expectErrorWithMessage(TestEnvironment.java:459)
> at org.reactivestreams.tck.PublisherVerification$22.run(
> PublisherVerification.java:876)
> at org.reactivestreams.tck.PublisherVerification.activePublisherTest(
> PublisherVerification.java:1092)
> at org.reactivestreams.tck.PublisherVerification.required_spec309_
> requestNegativeNumberMustSignalIllegalArgumentException(
> PublisherVerification.java:870)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
> Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(
> NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(
> DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:547)
> at org.testng.internal.MethodInvocationHelper.invokeMethod(
> MethodInvocationHelper.java:74)
> at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
> at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
> at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
> at org.testng.internal.TestMethodWorker.invokeTestMethods(
> TestMethodWorker.java:125)
> at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
> at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
> at org.testng.TestRunner.privateRun(TestRunner.java:749)
> at org.testng.TestRunner.run(TestRunner.java:600)
> at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
> at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
> at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
> at org.testng.SuiteRunner.run(SuiteRunner.java:223)
> at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
> at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
> at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
> at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
> at org.testng.TestNG.run(TestNG.java:900)
> at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
> at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)
>
>
>    - SubmissionPublisherTckTest.required_spec309_
>    requestZeroMustSignalIllegalArgumentException
>
>
> java.lang.AssertionError: Expected onError(java.lang.IllegalArgumentException)
> within 200 ms
>
> at org.testng.Assert.fail(Assert.java:78)
> at org.reactivestreams.tck.TestEnvironment.flopAndFail(
> TestEnvironment.java:180)
> at org.reactivestreams.tck.TestEnvironment$Receptacle.
> expectError(TestEnvironment.java:930)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectError(
> TestEnvironment.java:484)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.expectError(
> TestEnvironment.java:476)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.
> expectErrorWithMessage(TestEnvironment.java:464)
> at org.reactivestreams.tck.TestEnvironment$ManualSubscriber.
> expectErrorWithMessage(TestEnvironment.java:459)
> at org.reactivestreams.tck.PublisherVerification$21.run(
> PublisherVerification.java:862)
> at org.reactivestreams.tck.PublisherVerification.activePublisherTest(
> PublisherVerification.java:1092)
> at org.reactivestreams.tck.PublisherVerification.required_spec309_
> requestZeroMustSignalIllegalArgumentException(PublisherVerification.java:
> 858)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
> Method)
> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(
> NativeMethodAccessorImpl.java:62)
> at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(
> DelegatingMethodAccessorImpl.java:43)
> at java.base/java.lang.reflect.Method.invoke(Method.java:547)
> at org.testng.internal.MethodInvocationHelper.invokeMethod(
> MethodInvocationHelper.java:74)
> at org.testng.internal.Invoker.invokeMethod(Invoker.java:673)
> at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:846)
> at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1170)
> at org.testng.internal.TestMethodWorker.invokeTestMethods(
> TestMethodWorker.java:125)
> at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
> at org.testng.TestRunner.runWorkers(TestRunner.java:1147)
> at org.testng.TestRunner.privateRun(TestRunner.java:749)
> at org.testng.TestRunner.run(TestRunner.java:600)
> at org.testng.SuiteRunner.runTest(SuiteRunner.java:317)
> at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:312)
> at org.testng.SuiteRunner.privateRun(SuiteRunner.java:274)
> at org.testng.SuiteRunner.run(SuiteRunner.java:223)
> at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
> at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)
> at org.testng.TestNG.runSuitesSequentially(TestNG.java:1039)
> at org.testng.TestNG.runSuitesLocally(TestNG.java:964)
> at org.testng.TestNG.run(TestNG.java:900)
> at org.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:72)
> at org.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:127)
> Caused by: java.lang.AssertionError: Expected onError(java.lang.IllegalArgumentException)
> within 200 ms
> at org.testng.Assert.fail(Assert.java:89)
> at org.reactivestreams.tck.TestEnvironment.flopAndFail(
> TestEnvironment.java:177)
> ... 32 more
>
>
>
> --
> Best regards,
> David Karnok
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/fe718de7/attachment-0001.html>

From kedar.mhaswade at gmail.com  Wed Mar  1 14:00:42 2017
From: kedar.mhaswade at gmail.com (kedar mhaswade)
Date: Wed, 1 Mar 2017 11:00:42 -0800
Subject: [concurrency-interest] Spot the bug in stream processing,
 IntConsumer and Executor
In-Reply-To: <CAKwFPQ81BX_ZQC2G-DxaQmXaRrna9QKdN8XNLGxCiqhwNe7t4A@mail.gmail.com>
References: <CABzSAw8dvy05fuX=7EaEcauwk_k+f_hgh-NAs-ZELRKGPerYEQ@mail.gmail.com>
 <CAGu0=MOnu=A+p69fS9K8S3p67hs=7R4LYPP0kH_1thNeGFM0EA@mail.gmail.com>
 <CAKwFPQ94hjtKJjrj-B7SE8G=JWABafF2NbKT_xNcX-9M9c8C3g@mail.gmail.com>
 <CABzSAw_y87uEMQjyNQ5BK4o3Eh+YZFv9Dvs3=ZZ8+on5-Oe19g@mail.gmail.com>
 <CAKwFPQ81BX_ZQC2G-DxaQmXaRrna9QKdN8XNLGxCiqhwNe7t4A@mail.gmail.com>
Message-ID: <CABzSAw9-SkLJmHFi8StEtT5MSO-AatcNy5b4O=kK6Gr-C9PsHg@mail.gmail.com>

​Sorry for the delay, Tom.​

On Sat, Feb 25, 2017 at 9:37 AM, Tom Lee <concurrency-interest at tomlee.co>
wrote:

> FWIW I noticed that 100/1000 thing too, and still got "bad" results (all
> zeros) after changing the 100 to 1000.
>

​I think there was another mistake in my original code, in that the *main
thread* was printing the value of the volatile count. Perhaps, as you were
suggesting, in the case of *incrementStream*, the class loading or some
other issues appear to cause the submitted tasks to take longer to start
(than in *increment*).

With the 100->1000 change, I also moved the print statement inside the task
[1] and then I got the comparable (albeit incorrect because of the race
owing to nonatomic count++) results.


[1]

public class RaceCondition {

    private static volatile int count = 0;
    public static void main(String[] args) throws InterruptedException {
        // update the shared variable traditionally
        Runnable increment = () -> {
            System.out.println("count was: " + count + " in thread: " +
Thread.currentThread());
            for (int i = 0; i < 1000; i++)
                count++;
            System.out.println("count updated to: " + count + " in thread:
" + Thread.currentThread());
        };
        // update the shared variable as a side effect of an
IntConsumer#accept
        Runnable incrementStream = () -> {
            System.out.println("count was: " + count + " in thread: " +
Thread.currentThread());
            IntStream.rangeClosed(1, 1000).forEach(i -> count++);
            System.out.println("count updated to: " + count + " in thread:
" + Thread.currentThread());
        };
        Runnable bulkUpdate = () -> count += 1000;
        ExecutorService exec = Executors.newCachedThreadPool(); // short
lived tasks
        try {
            for (int i = 0; i < 10; i++) {
//                exec.execute(incrementStream);
                  exec.execute(increment);
                  // *statement printing the count was here previously*
            }
        } finally {
            exec.awaitTermination(5, TimeUnit.SECONDS);
            exec.shutdown();
            System.out.println("final: " + count);
        }
    }
}

>
> On Feb 25, 2017 9:32 AM, "kedar mhaswade" <kedar.mhaswade at gmail.com>
> wrote:
>
>> Thanks Tom and Benjamin. Yes, I am trying to demonstrate a race
>> condition, so yes, this code is for illustration purposes only.
>>
>> *And upon a closer look, I found the bug in my code:*
>>
>>         Runnable increment = () -> {
>>             for (int i = 0; i < *1000*; i++)
>>                 count++;
>>         };
>>
>>         // update the shared variable as a side effect of an
>> IntConsumer#accept
>>         Runnable incrementStream = () -> IntStream.rangeClosed(1, *100*).forEach(i
>> -> count++);
>>
>>
>> The stream-oriented task was getting a *100* instead of a *1000* :-P.
>> Fixing this gives very similar results. Of course, it clearly demonstrates
>> that count++ is *not* an atomic operation and some updates are lost as
>> expected. I also verified that by using an AtomicInteger instead of a
>> simple volatile, the final value of count is 10,000, always.
>>
>> Regards,
>> Kedar
>>
>>
>> On Sat, Feb 25, 2017 at 12:09 AM, Tom Lee <concurrency-interest at tomlee.co
>> > wrote:
>>
>>> Hi Kedar,
>>>
>>> Disclaimer: I'd generally say something about this approach to having
>>> multiple threads incrementing a variable being a bad idea in general, but
>>> it sounds like you're just trying to explore the behavior of this race
>>> right?
>>>
>>> Benjamin's on the right track: you're seeing zeros because the code
>>> submitted to the executor hasn't run by the time you print out the "task
>>> ... updates count to ..." messages. Still, it's not a complete fix & you'll
>>> very likely continue to see very different results even if you add an
>>> awaitTermination call after the shutdown() call. Also probably depends on
>>> how fast your machine is etc. etc. too (e.g. perhaps on slower machines /
>>> fewer cores you'd see similar output for both).
>>>
>>> It's still kind of interesting why the exhibited behavior is so
>>> different. Here's a bit of a hint -- with the following code I get very
>>> similar output irrespective of whether I'm using "increment" or
>>> "incrementStream":
>>>
>>> private static volatile int count = 0;
>>> public static void main(String[] args) throws Exception {
>>>
>>>     // warmup (slower)
>>>     run(false);
>>>
>>>     // do it for real (faster)
>>>     count = 0;
>>>     run(true);
>>> }
>>>
>>> private static void run(final boolean show) throws Exception {
>>>     Runnable increment = () -> {
>>>         for (int i = 0; i < 1000; i++)
>>>             count++;
>>>     };
>>>
>>>     Runnable incrementStream = () -> {
>>>         IntStream.rangeClosed(1, 1000).forEach(i -> count++);
>>>     };
>>>     ExecutorService exec = Executors.newCachedThreadPool();
>>>     try {
>>>         for (int i = 0; i < 10; i++) {
>>>             exec.execute(increment);
>>>             // exec.execute(incrementStream);
>>>             if (show) System.out.println("task: " + i + " updates count to: " + count);
>>>         }
>>>     }
>>>     finally {
>>>         exec.shutdown();
>>>         exec.awaitTermination(10, TimeUnit.SECONDS);
>>>         if (show) System.out.println("final: " + count);
>>>     }
>>> }
>>>
>>> Weird right?
>>>
>>> Another hint: I added code to println() a message to the end of
>>> incrementStream() in your original code ("hello" or something silly like
>>> that). I didn't see any "hello" messages until after all the "task ...
>>> updates count to ..." messages were displayed.
>>>
>>> Without going too deep, I suspect all your incrementStream() threads are
>>> held up by class loading etc. Specifically, the stream APIs you're using in
>>> incrementStream pull in maybe 40 additional classes on an Oracle JVM. To
>>> see for yourself, run the JVM with -verbose:class and run both
>>> increment and incrementStream -- notice the latter does a bunch of extra
>>> work. Since classes are sort of loaded on-demand, that work needs to happen
>>> before your incrementStream threads can run. Thus why the warmup step above
>>> improves the situation.
>>>
>>> Put another way: even though logically increment and incrementStream are
>>> doing something very similar, the latter has to do a bunch of additional
>>> work before any of the stuff that touches the count variable even gets to
>>> run. And if it's not obvious it should be noted that your scenario here is
>>> very small/fast and this effect will be less pronounced (but not entirely
>>> absent) in a larger test.
>>>
>>> Cheers,
>>> Tom
>>>
>>>
>>> On Fri, Feb 24, 2017 at 9:07 PM, Benjamin Manes <ben.manes at gmail.com>
>>> wrote:
>>>
>>>> You need to wait until the executor has completed, or else the main
>>>> method may complete prior to the task running.
>>>>
>>>> exec.awaitTermination(1, TimeUnit.MINUTES);
>>>>
>>>>
>>>> On Fri, Feb 24, 2017 at 8:53 PM, kedar mhaswade <
>>>> kedar.mhaswade at gmail.com> wrote:
>>>>
>>>>> ​Perhaps I had a long day. So, this might completely be a silly
>>>>> mistake, but I need congenial help to figure it out.
>>>>>
>>>>> To demonstrate race condition, I wrote the following program. The
>>>>> program has ten concurrent tasks that modify count, a volatile shared
>>>>> variable. If I use the *increment* task (line 39), I get different
>>>>> results (like, e.g. [2]) every time I run it, demonstrating the race
>>>>> condition.
>>>>>
>>>>> However, if I use the *incrementStream* task instead (line 39), then
>>>>> the count variable is not updated at all. The output is like [1] *every
>>>>> time*. In a separate program not involving threads, I have verified
>>>>> that the lambda expression like incrementStream updates a member variable
>>>>> as expected.
>>>>>
>>>>> What am I doing wrong?
>>>>>
>>>>> Regards,
>>>>> Kedar
>>>>>
>>>>>
>>>>> public class RaceCondition {
>>>>>
>>>>>     private static volatile int count = 0;
>>>>>     public static void main(String[] args) {
>>>>>         // update the shared variable traditionally
>>>>>         Runnable increment = () -> {
>>>>>             for (int i = 0; i < 1000; i++)
>>>>>                 count++;
>>>>>         };
>>>>>         // update the shared variable as a side effect of an
>>>>> IntConsumer#accept
>>>>>         Runnable incrementStream = () -> IntStream.rangeClosed(1,
>>>>> 100).forEach(i -> count++);
>>>>>         ExecutorService exec = Executors.newCachedThreadPool(); //
>>>>> short lived tasks
>>>>>         try {
>>>>>             for (int i = 0; i < 10; i++) {
>>>>>
>>>>> ​// ​
>>>>> exec.execute(incrementStream)
>>>>> ​;
>>>>> // line 38​
>>>>> ​​
>>>>>
>>>>>               exec.execute(increment);
>>>>> ​         // line 39​
>>>>>
>>>>>                 System.out.println("task: " + i + " updates count to:
>>>>> " + count);
>>>>>             }
>>>>>         } finally {
>>>>>             exec.shutdown();
>>>>>             System.out.println("final: " + count);
>>>>>         }
>>>>>     }
>>>>>
>>>>> }
>>>>> [1]
>>>>> task: 0 updates count to: 0
>>>>> task: 1 updates count to: 0
>>>>> task: 2 updates count to: 0
>>>>> task: 3 updates count to: 0
>>>>> task: 4 updates count to: 0
>>>>> task: 5 updates count to: 0
>>>>> task: 6 updates count to: 0
>>>>> task: 7 updates count to: 0
>>>>> task: 8 updates count to: 0
>>>>> task: 9 updates count to: 0
>>>>> final: 0
>>>>> [2]
>>>>> task: 0 updates count to: 0
>>>>> task: 1 updates count to: 1000
>>>>> task: 2 updates count to: 1000
>>>>> task: 3 updates count to: 2000
>>>>> task: 4 updates count to: 4027
>>>>> task: 5 updates count to: 5000
>>>>> task: 6 updates count to: 6000
>>>>> task: 7 updates count to: 7005
>>>>> task: 8 updates count to: 8000
>>>>> task: 9 updates count to: 8185
>>>>> final: 9381
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/6e85e69f/attachment-0001.html>

From shevek at anarres.org  Wed Mar  1 16:59:00 2017
From: shevek at anarres.org (Shevek)
Date: Wed, 1 Mar 2017 13:59:00 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has quadratic
	complexity
Message-ID: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>

I'm building an algebraic search algorithm, consider it as a prioritized 
depth-first search with pruning. I use a PriorityBlockingQueue to hold 
the partial solutions, ordered by the partial evaluator, and when I find 
a complete solution, I call queue.removeIf((t) -> t.cost >= knownCost);

The trouble is that PriorityBlockingQueue.removeIf() uses PBQ$Itr, 
within which remove() calls PriorityBlockingQueue.removeEQ(), which 
itself has linear cost, making PBQ.removeIf() have quadratic overall 
complexity.

What solutions are available to me? I'm aiming for >10K ops/sec on 4 
cores, so it's not at the point where synchronization is murder but it 
matters. I do need to prune the queues, as they aren't remotely FIFO and 
old elements will get left around for a long time. Queue sizes are in 
the order of some millions.

* I could execute the removeIf() on a background thread.
* I could use a non-Blocking queue and use coarse grained locking
   - but then I lose poll(long, TimeUnit), which I could reimplement
* I could use another queue implementation - which one do you suggest?

Thank you.

S.

From martinrb at google.com  Wed Mar  1 17:37:48 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 1 Mar 2017 14:37:48 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
Message-ID: <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>

Late in jdk9 development we tried to optimize various bulk operations in
j.u.c. including PBQ.removeif, but the PBQ changes didn't make the jdk9
train. At least removeIf is not O(n**2) like some other collections !

On Wed, Mar 1, 2017 at 1:59 PM, Shevek <shevek at anarres.org> wrote:

> I'm building an algebraic search algorithm, consider it as a prioritized
> depth-first search with pruning. I use a PriorityBlockingQueue to hold the
> partial solutions, ordered by the partial evaluator, and when I find a
> complete solution, I call queue.removeIf((t) -> t.cost >= knownCost);
>
> The trouble is that PriorityBlockingQueue.removeIf() uses PBQ$Itr, within
> which remove() calls PriorityBlockingQueue.removeEQ(), which itself has
> linear cost, making PBQ.removeIf() have quadratic overall complexity.
>
> What solutions are available to me? I'm aiming for >10K ops/sec on 4
> cores, so it's not at the point where synchronization is murder but it
> matters. I do need to prune the queues, as they aren't remotely FIFO and
> old elements will get left around for a long time. Queue sizes are in the
> order of some millions.
>
> * I could execute the removeIf() on a background thread.
> * I could use a non-Blocking queue and use coarse grained locking
>   - but then I lose poll(long, TimeUnit), which I could reimplement
> * I could use another queue implementation - which one do you suggest?
>
> Thank you.
>
> S.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/b67b2424/attachment.html>

From jhump at bluegosling.com  Wed Mar  1 17:58:43 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Wed, 1 Mar 2017 17:58:43 -0500
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
Message-ID: <CAO78j+JM2sjDjvqibDdBAvdU2afe85C3sdHhizZetwChXP1BVg@mail.gmail.com>

I've experimented with alternate ordered blocking queue implementations.
One I've written that is reasonably well-tested (though not used in any
production system that I know of) is backed by a ConcurrentSkipListSet:
here's source
<https://github.com/jhump/bluegosling/blob/master/src/com/bluegosling/collections/concurrent/LockFreeSkipListBlockingQueue.java>.
(It's lock-free, so I was hoping it could perform better than
PriorityBlockingQueue under contention. Preliminary performance tests
suggest any performance benefit is slim to none, though I've not done
anything in the way of profiling).

Unfortunately, it looks like iterator#remove() for ConcurrentSkipListSet is
also not constant time. So this implementation is better at O(n * log n)
instead of O(n ^ 2). But a skip-list is not a cache-friendly data structure
with lots and lots of pointer chasing (so higher constant factors). So this
still isn't that great. It may be just as good to roll your own your own
O(n) removeIf by copying the queue, pruning it, and then re-initializing it.

Speaking of rolling your own, one approach is to wrap a
PriorityBlockingQueue and use a ReadWriteLock to protect it: "read" lock
just means shared, which is for every normal queue operation (since the
wrapped queue is thread-safe); "write" lock is exclusive, which you'd hold
while re-building/pruning its contents.

If you know you're using a particular JRE and are willing to tie yourself
to its implementation, you could just sub-class PriorityBlockingQueue and
use reflection in the ctor to get a ref to the queue's private lock and
internal object array. Then you can provide your own optimized removeIf()
by grabbing the lock, pruning the array directly (could be done efficiently
with a single O(n) pass over its contents), re-heapify what's left in the
array (also O(n)), and then release the lock.

----
*Josh Humphries*
jhump at bluegosling.com

On Wed, Mar 1, 2017 at 4:59 PM, Shevek <shevek at anarres.org> wrote:

> I'm building an algebraic search algorithm, consider it as a prioritized
> depth-first search with pruning. I use a PriorityBlockingQueue to hold the
> partial solutions, ordered by the partial evaluator, and when I find a
> complete solution, I call queue.removeIf((t) -> t.cost >= knownCost);
>
> The trouble is that PriorityBlockingQueue.removeIf() uses PBQ$Itr, within
> which remove() calls PriorityBlockingQueue.removeEQ(), which itself has
> linear cost, making PBQ.removeIf() have quadratic overall complexity.
>
> What solutions are available to me? I'm aiming for >10K ops/sec on 4
> cores, so it's not at the point where synchronization is murder but it
> matters. I do need to prune the queues, as they aren't remotely FIFO and
> old elements will get left around for a long time. Queue sizes are in the
> order of some millions.
>
> * I could execute the removeIf() on a background thread.
> * I could use a non-Blocking queue and use coarse grained locking
>   - but then I lose poll(long, TimeUnit), which I could reimplement
> * I could use another queue implementation - which one do you suggest?
>
> Thank you.
>
> S.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/e6838eec/attachment.html>

From martinrb at google.com  Wed Mar  1 18:23:11 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 1 Mar 2017 15:23:11 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
Message-ID: <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>

Looking again, I noticed the subject of this thread, and I believe it's not
true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n ^2),
but we can get to O(n) because heapify is known to be O(n).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/621cabcc/attachment.html>

From shevek at anarres.org  Wed Mar  1 18:46:05 2017
From: shevek at anarres.org (Shevek)
Date: Wed, 1 Mar 2017 15:46:05 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
Message-ID: <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>

It's not about the heapify.

If I have a queue of 1M objects, and I want to remove K = N/2 of them:

I walk the queue using the iterator. That's N.

For each item I remove, removeEQ() walks the array from 0 to i in order 
to call removeAt(). That's asymptotically the second factor of N. It's 
this behaviour within removeEQ() which I think people on this thread may 
not have realized.

Therefore PBQ's removeIf() is quadratic, assuming it removes some number 
of elements which is a linear function of N.

S.

On 03/01/2017 03:23 PM, Martin Buchholz wrote:
> Looking again, I noticed the subject of this thread, and I believe it's
> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
> ^2), but we can get to O(n) because heapify is known to be O(n).

From jhump at bluegosling.com  Wed Mar  1 18:50:33 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Wed, 1 Mar 2017 18:50:33 -0500
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
Message-ID: <CAO78j+LTD9DL_jhVrU8C3zhhEM=7wsdOMNQa6yzxTdbVqMrYKw@mail.gmail.com>

Martin,
That looks to be true for PQ, but not for PBQ. PBQ makes a copy of the
underlying array so iteration is strongly consistent (and safe with regards
to concurrent modifications). So when iterator#remove() is called, it must
perform a linear scan of the live min-heap to first find the element, and
then it can do the the O(log n) sifting. So that would make removeIf(...)
O(n^2)

----
*Josh Humphries*
jhump at bluegosling.com

On Wed, Mar 1, 2017 at 6:23 PM, Martin Buchholz <martinrb at google.com> wrote:

> Looking again, I noticed the subject of this thread, and I believe it's
> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
> ^2), but we can get to O(n) because heapify is known to be O(n).
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/a350281b/attachment-0001.html>

From martinrb at google.com  Wed Mar  1 19:06:59 2017
From: martinrb at google.com (Martin Buchholz)
Date: Wed, 1 Mar 2017 16:06:59 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
Message-ID: <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>

Hmmm ... I stand corrected.  PBQ.removeIf is quadratic, but probably only
noticeably so for large element sizes (10,000 ?) , since removeEQ is a very
fast linear memory scan when e.g. the array fits into cache.

My point about heapify is that removeIf can lock the entire collection,
ignore the heap invariant as it traverses the array, then restores the
invariant using heapfiy at the end before unlocking.

Historically, we have tried hard to make blocking queue interior removal
operations correct, but not necessarily fast.  Implementers' lives would
have been easier if interior removal was never supported (especially for
ArrayBlockingQueue).

On Wed, Mar 1, 2017 at 3:46 PM, Shevek <shevek at anarres.org> wrote:

> It's not about the heapify.
>
> If I have a queue of 1M objects, and I want to remove K = N/2 of them:
>
> I walk the queue using the iterator. That's N.
>
> For each item I remove, removeEQ() walks the array from 0 to i in order to
> call removeAt(). That's asymptotically the second factor of N. It's this
> behaviour within removeEQ() which I think people on this thread may not
> have realized.
>
> Therefore PBQ's removeIf() is quadratic, assuming it removes some number
> of elements which is a linear function of N.
>
> S.
>
>
> On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>
>> Looking again, I noticed the subject of this thread, and I believe it's
>> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
>> ^2), but we can get to O(n) because heapify is known to be O(n).
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/cd414353/attachment.html>

From vitalyd at gmail.com  Wed Mar  1 19:15:45 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 02 Mar 2017 00:15:45 +0000
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
 <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
Message-ID: <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>

On Wed, Mar 1, 2017 at 7:10 PM Martin Buchholz <martinrb at google.com> wrote:

> Hmmm ... I stand corrected.  PBQ.removeIf is quadratic, but probably only
> noticeably so for large element sizes (10,000 ?) , since removeEQ is a very
> fast linear memory scan when e.g. the array fits into cache.
>
linear scan of ... references requiring a deref (and assume cache miss on
each)? There won't be anything fast about that :)

>
> My point about heapify is that removeIf can lock the entire collection,
> ignore the heap invariant as it traverses the array, then restores the
> invariant using heapfiy at the end before unlocking.
>
> Historically, we have tried hard to make blocking queue interior removal
> operations correct, but not necessarily fast.  Implementers' lives would
> have been easier if interior removal was never supported (especially for
> ArrayBlockingQueue).
>
> On Wed, Mar 1, 2017 at 3:46 PM, Shevek <shevek at anarres.org> wrote:
>
> It's not about the heapify.
>
> If I have a queue of 1M objects, and I want to remove K = N/2 of them:
>
> I walk the queue using the iterator. That's N.
>
> For each item I remove, removeEQ() walks the array from 0 to i in order to
> call removeAt(). That's asymptotically the second factor of N. It's this
> behaviour within removeEQ() which I think people on this thread may not
> have realized.
>
> Therefore PBQ's removeIf() is quadratic, assuming it removes some number
> of elements which is a linear function of N.
>
> S.
>
>
> On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>
> Looking again, I noticed the subject of this thread, and I believe it's
> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
> ^2), but we can get to O(n) because heapify is known to be O(n).
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-- 
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170302/4308d2c9/attachment.html>

From jhump at bluegosling.com  Wed Mar  1 20:09:52 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Wed, 1 Mar 2017 20:09:52 -0500
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
 <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
 <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>
Message-ID: <CAO78j++WzUnY+aWM8TqcmJjGUfY_gnEL=wW6E4QOJjT8b2aeqA@mail.gmail.com>

On Wed, Mar 1, 2017 at 7:15 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

>
> On Wed, Mar 1, 2017 at 7:10 PM Martin Buchholz <martinrb at google.com>
> wrote:
>
>> Hmmm ... I stand corrected.  PBQ.removeIf is quadratic, but probably only
>> noticeably so for large element sizes (10,000 ?) , since removeEQ is a very
>> fast linear memory scan when e.g. the array fits into cache.
>>
> linear scan of ... references requiring a deref (and assume cache miss on
> each)? There won't be anything fast about that :)
>

It's actually doing identity equality checks, so nothing needs to be
de-referenced in this case.


>
>> My point about heapify is that removeIf can lock the entire collection,
>> ignore the heap invariant as it traverses the array, then restores the
>> invariant using heapfiy at the end before unlocking.
>>
>
Yep. That's what I was suggesting as a hack (interim?) solution: do that
via a sub-class that uses reflection to access the superclass's private
lock and object array.


>
>> Historically, we have tried hard to make blocking queue interior removal
>> operations correct, but not necessarily fast.  Implementers' lives would
>> have been easier if interior removal was never supported (especially for
>> ArrayBlockingQueue).
>>
>> On Wed, Mar 1, 2017 at 3:46 PM, Shevek <shevek at anarres.org> wrote:
>>
>> It's not about the heapify.
>>
>> If I have a queue of 1M objects, and I want to remove K = N/2 of them:
>>
>> I walk the queue using the iterator. That's N.
>>
>> For each item I remove, removeEQ() walks the array from 0 to i in order
>> to call removeAt(). That's asymptotically the second factor of N. It's this
>> behaviour within removeEQ() which I think people on this thread may not
>> have realized.
>>
>> Therefore PBQ's removeIf() is quadratic, assuming it removes some number
>> of elements which is a linear function of N.
>>
>> S.
>>
>>
>> On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>>
>> Looking again, I noticed the subject of this thread, and I believe it's
>> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
>> ^2), but we can get to O(n) because heapify is known to be O(n).
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> --
> Sent from my phone
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/d1df3a38/attachment-0001.html>

From vitalyd at gmail.com  Wed Mar  1 20:25:48 2017
From: vitalyd at gmail.com (Vitaly Davidovich)
Date: Thu, 02 Mar 2017 01:25:48 +0000
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CAO78j++WzUnY+aWM8TqcmJjGUfY_gnEL=wW6E4QOJjT8b2aeqA@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
 <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
 <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>
 <CAO78j++WzUnY+aWM8TqcmJjGUfY_gnEL=wW6E4QOJjT8b2aeqA@mail.gmail.com>
Message-ID: <CAHjP37Ff2iK1VRat8WmhUMr+O5WSjKQ4SuG5es_TOcCwjLm9ww@mail.gmail.com>

On Wed, Mar 1, 2017 at 8:10 PM Josh Humphries <jhump at bluegosling.com> wrote:

> On Wed, Mar 1, 2017 at 7:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
> wrote:
>
>
> On Wed, Mar 1, 2017 at 7:10 PM Martin Buchholz <martinrb at google.com>
> wrote:
>
> Hmmm ... I stand corrected.  PBQ.removeIf is quadratic, but probably only
> noticeably so for large element sizes (10,000 ?) , since removeEQ is a very
> fast linear memory scan when e.g. the array fits into cache.
>
> linear scan of ... references requiring a deref (and assume cache miss on
> each)? There won't be anything fast about that :)
>
>
> It's actually doing identity equality checks, so nothing needs to be
> de-referenced in this case.
>
Indeed, you're right - I didn't notice that until now after you mentioned
it.

>
>
>
> My point about heapify is that removeIf can lock the entire collection,
> ignore the heap invariant as it traverses the array, then restores the
> invariant using heapfiy at the end before unlocking.
>
>
> Yep. That's what I was suggesting as a hack (interim?) solution: do that
> via a sub-class that uses reflection to access the superclass's private
> lock and object array.
>
>
>
> Historically, we have tried hard to make blocking queue interior removal
> operations correct, but not necessarily fast.  Implementers' lives would
> have been easier if interior removal was never supported (especially for
> ArrayBlockingQueue).
>
> On Wed, Mar 1, 2017 at 3:46 PM, Shevek <shevek at anarres.org> wrote:
>
> It's not about the heapify.
>
> If I have a queue of 1M objects, and I want to remove K = N/2 of them:
>
> I walk the queue using the iterator. That's N.
>
> For each item I remove, removeEQ() walks the array from 0 to i in order to
> call removeAt(). That's asymptotically the second factor of N. It's this
> behaviour within removeEQ() which I think people on this thread may not
> have realized.
>
> Therefore PBQ's removeIf() is quadratic, assuming it removes some number
> of elements which is a linear function of N.
>
> S.
>
>
> On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>
> Looking again, I noticed the subject of this thread, and I believe it's
> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
> ^2), but we can get to O(n) because heapify is known to be O(n).
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> --
> Sent from my phone
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> --
Sent from my phone
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170302/0b9ef240/attachment.html>

From jhump at bluegosling.com  Wed Mar  1 20:55:04 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Wed, 1 Mar 2017 20:55:04 -0500
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CAHjP37Ff2iK1VRat8WmhUMr+O5WSjKQ4SuG5es_TOcCwjLm9ww@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
 <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
 <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>
 <CAO78j++WzUnY+aWM8TqcmJjGUfY_gnEL=wW6E4QOJjT8b2aeqA@mail.gmail.com>
 <CAHjP37Ff2iK1VRat8WmhUMr+O5WSjKQ4SuG5es_TOcCwjLm9ww@mail.gmail.com>
Message-ID: <CAO78j+KWXfuJwxf_j2Byd3KSvFnAy9ka4fRYstCwWmrdPjKNoA@mail.gmail.com>

Shevek,
FWIW, here's a hack solution where removeIf() is orders of magnitude faster
for huge queue w/ non-trivial number of deletions during removeIf:
https://gist.github.com/jhump/2dc67844dc57ba510d305c56aa640440
Since it uses reflection to poke at the JRE class's internals, it obviously
isn't expected to work except on recent Oracle JDK 1.8 release.

A possibly safer option is to simply fork all of the source code from
OpenJDK's PriorityBlockingQueue.java and add the new method. Then you have
no need for reflection and it wouldn't be brittle when running on different
JREs or versions of Oracle JRE.

----
*Josh Humphries*
jhump at bluegosling.com

On Wed, Mar 1, 2017 at 8:25 PM, Vitaly Davidovich <vitalyd at gmail.com> wrote:

>
>
> On Wed, Mar 1, 2017 at 8:10 PM Josh Humphries <jhump at bluegosling.com>
> wrote:
>
>> On Wed, Mar 1, 2017 at 7:15 PM, Vitaly Davidovich <vitalyd at gmail.com>
>> wrote:
>>
>>
>> On Wed, Mar 1, 2017 at 7:10 PM Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>> Hmmm ... I stand corrected.  PBQ.removeIf is quadratic, but probably only
>> noticeably so for large element sizes (10,000 ?) , since removeEQ is a very
>> fast linear memory scan when e.g. the array fits into cache.
>>
>> linear scan of ... references requiring a deref (and assume cache miss on
>> each)? There won't be anything fast about that :)
>>
>>
>> It's actually doing identity equality checks, so nothing needs to be
>> de-referenced in this case.
>>
> Indeed, you're right - I didn't notice that until now after you mentioned
> it.
>
>>
>>
>>
>> My point about heapify is that removeIf can lock the entire collection,
>> ignore the heap invariant as it traverses the array, then restores the
>> invariant using heapfiy at the end before unlocking.
>>
>>
>> Yep. That's what I was suggesting as a hack (interim?) solution: do that
>> via a sub-class that uses reflection to access the superclass's private
>> lock and object array.
>>
>>
>>
>> Historically, we have tried hard to make blocking queue interior removal
>> operations correct, but not necessarily fast.  Implementers' lives would
>> have been easier if interior removal was never supported (especially for
>> ArrayBlockingQueue).
>>
>> On Wed, Mar 1, 2017 at 3:46 PM, Shevek <shevek at anarres.org> wrote:
>>
>> It's not about the heapify.
>>
>> If I have a queue of 1M objects, and I want to remove K = N/2 of them:
>>
>> I walk the queue using the iterator. That's N.
>>
>> For each item I remove, removeEQ() walks the array from 0 to i in order
>> to call removeAt(). That's asymptotically the second factor of N. It's this
>> behaviour within removeEQ() which I think people on this thread may not
>> have realized.
>>
>> Therefore PBQ's removeIf() is quadratic, assuming it removes some number
>> of elements which is a linear function of N.
>>
>> S.
>>
>>
>> On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>>
>> Looking again, I noticed the subject of this thread, and I believe it's
>> not true.  I believe PBQ and PQ removeIf methods are O(n log n) not O(n
>> ^2), but we can get to O(n) because heapify is known to be O(n).
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> --
>> Sent from my phone
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> --
> Sent from my phone
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/25943fa7/attachment-0001.html>

From shevek at anarres.org  Wed Mar  1 21:05:22 2017
From: shevek at anarres.org (Shevek)
Date: Wed, 1 Mar 2017 18:05:22 -0800
Subject: [concurrency-interest] PriorityBlockingQueue.removeIf has
 quadratic complexity
In-Reply-To: <CAO78j+KWXfuJwxf_j2Byd3KSvFnAy9ka4fRYstCwWmrdPjKNoA@mail.gmail.com>
References: <3143bfdc-7adc-01bf-9292-05816485c886@anarres.org>
 <CA+kOe0_+e22=nZYfq6X9V9NsnTLcAWVYF8R66z8C5_MrazdYUw@mail.gmail.com>
 <CA+kOe0-Mc0cuZimyXyXubipurKJ-eS06o7d8FEthvCb-Jowkhg@mail.gmail.com>
 <b8e75dd7-a624-4620-a176-51d84ad87942@anarres.org>
 <CA+kOe08QS7yE9GBkhP8C=CWuMr72mVtFX_WbePrQ4kx1buVOEQ@mail.gmail.com>
 <CAHjP37FOaM4AyFFmKLi0xR5T3-9rnHg9YEQPNBFZ4V_nyd5WHg@mail.gmail.com>
 <CAO78j++WzUnY+aWM8TqcmJjGUfY_gnEL=wW6E4QOJjT8b2aeqA@mail.gmail.com>
 <CAHjP37Ff2iK1VRat8WmhUMr+O5WSjKQ4SuG5es_TOcCwjLm9ww@mail.gmail.com>
 <CAO78j+KWXfuJwxf_j2Byd3KSvFnAy9ka4fRYstCwWmrdPjKNoA@mail.gmail.com>
Message-ID: <b29882ce-5661-dd91-e5a1-69bde332e294@anarres.org>

You're wonderful, thank you. Yes, I totally believe the performance 
improvements - it all started when I was trying to work out why my 
performance wasn't scaling and all threads were blocked, and as you can 
see, it was slow enough that even stack sampling worked.

Hopefully we get a built-in performance improvement in a future version. 
I was using removeIf() on the assumption that builtins know things about 
structure and allocation which make them faster than iterators, but the 
answer may be "not quite yet".

Aside: visualvm CPU sampler isn't working on the latest JDK8s. :-( I 
haven't looked at why not, yet.

S.

On 03/01/2017 05:55 PM, Josh Humphries wrote:
> Shevek,
> FWIW, here's a hack solution where removeIf() is orders of magnitude
> faster for huge queue w/ non-trivial number of deletions during removeIf:
> https://gist.github.com/jhump/2dc67844dc57ba510d305c56aa640440
> <https://gist.github.com/jhump/2dc67844dc57ba510d305c56aa640440>
> Since it uses reflection to poke at the JRE class's internals, it
> obviously isn't expected to work except on recent Oracle JDK 1.8 release.
>
> A possibly safer option is to simply fork all of the source code from
> OpenJDK's PriorityBlockingQueue.java and add the new method. Then you
> have no need for reflection and it wouldn't be brittle when running on
> different JREs or versions of Oracle JRE.
>
> ----
> *Josh Humphries*
> jhump at bluegosling.com <mailto:jhump at bluegosling.com>
>
> On Wed, Mar 1, 2017 at 8:25 PM, Vitaly Davidovich <vitalyd at gmail.com
> <mailto:vitalyd at gmail.com>> wrote:
>
>
>
>     On Wed, Mar 1, 2017 at 8:10 PM Josh Humphries <jhump at bluegosling.com
>     <mailto:jhump at bluegosling.com>> wrote:
>
>         On Wed, Mar 1, 2017 at 7:15 PM, Vitaly Davidovich
>         <vitalyd at gmail.com <mailto:vitalyd at gmail.com>> wrote:
>
>
>             On Wed, Mar 1, 2017 at 7:10 PM Martin Buchholz
>             <martinrb at google.com <mailto:martinrb at google.com>> wrote:
>
>                 Hmmm ... I stand corrected.  PBQ.removeIf is quadratic,
>                 but probably only noticeably so for large element sizes
>                 (10,000 ?) , since removeEQ is a very fast linear memory
>                 scan when e.g. the array fits into cache.
>
>             linear scan of ... references requiring a deref (and assume
>             cache miss on each)? There won't be anything fast about that :)
>
>
>         It's actually doing identity equality checks, so nothing needs
>         to be de-referenced in this case.
>
>     Indeed, you're right - I didn't notice that until now after you
>     mentioned it.
>
>
>
>
>                 My point about heapify is that removeIf can lock the
>                 entire collection, ignore the heap invariant as it
>                 traverses the array, then restores the invariant using
>                 heapfiy at the end before unlocking.
>
>
>         Yep. That's what I was suggesting as a hack (interim?) solution:
>         do that via a sub-class that uses reflection to access the
>         superclass's private lock and object array.
>
>
>
>                 Historically, we have tried hard to make blocking queue
>                 interior removal operations correct, but not necessarily
>                 fast.  Implementers' lives would have been easier if
>                 interior removal was never supported (especially for
>                 ArrayBlockingQueue).
>
>                 On Wed, Mar 1, 2017 at 3:46 PM, Shevek
>                 <shevek at anarres.org <mailto:shevek at anarres.org>> wrote:
>
>                     It's not about the heapify.
>
>                     If I have a queue of 1M objects, and I want to
>                     remove K = N/2 of them:
>
>                     I walk the queue using the iterator. That's N.
>
>                     For each item I remove, removeEQ() walks the array
>                     from 0 to i in order to call removeAt(). That's
>                     asymptotically the second factor of N. It's this
>                     behaviour within removeEQ() which I think people on
>                     this thread may not have realized.
>
>                     Therefore PBQ's removeIf() is quadratic, assuming it
>                     removes some number of elements which is a linear
>                     function of N.
>
>                     S.
>
>
>                     On 03/01/2017 03:23 PM, Martin Buchholz wrote:
>
>                         Looking again, I noticed the subject of this
>                         thread, and I believe it's
>                         not true.  I believe PBQ and PQ removeIf methods
>                         are O(n log n) not O(n
>                         ^2), but we can get to O(n) because heapify is
>                         known to be O(n).
>
>
>                 _______________________________________________
>                 Concurrency-interest mailing list
>                 Concurrency-interest at cs.oswego.edu
>                 <mailto:Concurrency-interest at cs.oswego.edu>
>                 http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>                 <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>             --
>             Sent from my phone
>
>             _______________________________________________
>             Concurrency-interest mailing list
>             Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>             <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>
>     --
>     Sent from my phone
>
>

From 7025260588 at txt.att.net  Wed Mar  1 21:34:30 2017
From: 7025260588 at txt.att.net (7025260588 at txt.att.net)
Date: Wed, 01 Mar 2017 20:34:30 -0600
Subject: [concurrency-interest] Concurrency-interest_Digest, _Vol_146,
	_Issue_5
In-Reply-To: mailman.12.1488417042.2202.concurrency-interest@cs.oswego.edu
Message-ID: <qqZA1u0020gVARn01qZACk@txt.att.net>

Stop

  -----Original Message-----
  From: <concurrency-interest at cs.oswego.edu>
  Sent: Wed, 01 Mar 2017 20:10:42 -0500
  To: 7025260588 at txt.att.net
 Subject: Concurrency-interest_Digest,_Vol_146,_Issue_5

>Send Concurrency-interest mailing list submissions to
>	concurrency-interest at cs.oswego.edu
>
>To subscribe or unsubscribe via the World Wide Web, visit
>	http://cs.oswego.edu/mailman

==================================================================
This mobile text message is brought to you by AT&T

From concurrency-interest at tomlee.co  Wed Mar  1 21:42:40 2017
From: concurrency-interest at tomlee.co (Tom Lee)
Date: Wed, 1 Mar 2017 18:42:40 -0800
Subject: [concurrency-interest] Spot the bug in stream processing,
 IntConsumer and Executor
In-Reply-To: <CABzSAw9-SkLJmHFi8StEtT5MSO-AatcNy5b4O=kK6Gr-C9PsHg@mail.gmail.com>
References: <CABzSAw8dvy05fuX=7EaEcauwk_k+f_hgh-NAs-ZELRKGPerYEQ@mail.gmail.com>
 <CAGu0=MOnu=A+p69fS9K8S3p67hs=7R4LYPP0kH_1thNeGFM0EA@mail.gmail.com>
 <CAKwFPQ94hjtKJjrj-B7SE8G=JWABafF2NbKT_xNcX-9M9c8C3g@mail.gmail.com>
 <CABzSAw_y87uEMQjyNQ5BK4o3Eh+YZFv9Dvs3=ZZ8+on5-Oe19g@mail.gmail.com>
 <CAKwFPQ81BX_ZQC2G-DxaQmXaRrna9QKdN8XNLGxCiqhwNe7t4A@mail.gmail.com>
 <CABzSAw9-SkLJmHFi8StEtT5MSO-AatcNy5b4O=kK6Gr-C9PsHg@mail.gmail.com>
Message-ID: <CAKwFPQ8xv94Gj6dpK1yZBD5Z1o-TpswYLq66a0LHWTEu+mZwuw@mail.gmail.com>

On Wed, Mar 1, 2017 at 11:00 AM, kedar mhaswade <kedar.mhaswade at gmail.com>
wrote:

>
> ​Sorry for the delay, Tom.​
>

Not at all.


> On Sat, Feb 25, 2017 at 9:37 AM, Tom Lee <concurrency-interest at tomlee.co>
> wrote:
>
>> FWIW I noticed that 100/1000 thing too, and still got "bad" results (all
>> zeros) after changing the 100 to 1000.
>>
>
> ​I think there was another mistake in my original code, in that the *main
> thread* was printing the value of the volatile count. Perhaps, as you
> were suggesting, in the case of *incrementStream*, the class loading or
> some other issues appear to cause the submitted tasks to take longer to
> start (than in *increment*).
>
> With the 100->1000 change, I also moved the print statement inside the
> task [1] and then I got the comparable (albeit incorrect because of the
> race owing to nonatomic count++) results.
>

Ah yep, that would probably explain it :)


>
> [1]
>
> public class RaceCondition {
>
>     private static volatile int count = 0;
>     public static void main(String[] args) throws InterruptedException {
>         // update the shared variable traditionally
>         Runnable increment = () -> {
>             System.out.println("count was: " + count + " in thread: " +
> Thread.currentThread());
>             for (int i = 0; i < 1000; i++)
>                 count++;
>             System.out.println("count updated to: " + count + " in thread:
> " + Thread.currentThread());
>         };
>         // update the shared variable as a side effect of an
> IntConsumer#accept
>         Runnable incrementStream = () -> {
>             System.out.println("count was: " + count + " in thread: " +
> Thread.currentThread());
>             IntStream.rangeClosed(1, 1000).forEach(i -> count++);
>             System.out.println("count updated to: " + count + " in thread:
> " + Thread.currentThread());
>         };
>         Runnable bulkUpdate = () -> count += 1000;
>         ExecutorService exec = Executors.newCachedThreadPool(); // short
> lived tasks
>         try {
>             for (int i = 0; i < 10; i++) {
> //                exec.execute(incrementStream);
>                   exec.execute(increment);
>                   // *statement printing the count was here previously*
>             }
>         } finally {
>             exec.awaitTermination(5, TimeUnit.SECONDS);
>
>             exec.shutdown();
>             System.out.println("final: " + count);
>         }
>     }
> }
>
>>
>> On Feb 25, 2017 9:32 AM, "kedar mhaswade" <kedar.mhaswade at gmail.com>
>> wrote:
>>
>>> Thanks Tom and Benjamin. Yes, I am trying to demonstrate a race
>>> condition, so yes, this code is for illustration purposes only.
>>>
>>> *And upon a closer look, I found the bug in my code:*
>>>
>>>         Runnable increment = () -> {
>>>             for (int i = 0; i < *1000*; i++)
>>>                 count++;
>>>         };
>>>
>>>         // update the shared variable as a side effect of an
>>> IntConsumer#accept
>>>         Runnable incrementStream = () -> IntStream.rangeClosed(1, *100*).forEach(i
>>> -> count++);
>>>
>>>
>>> The stream-oriented task was getting a *100* instead of a *1000* :-P.
>>> Fixing this gives very similar results. Of course, it clearly demonstrates
>>> that count++ is *not* an atomic operation and some updates are lost as
>>> expected. I also verified that by using an AtomicInteger instead of a
>>> simple volatile, the final value of count is 10,000, always.
>>>
>>> Regards,
>>> Kedar
>>>
>>>
>>> On Sat, Feb 25, 2017 at 12:09 AM, Tom Lee <concurrency-interest at tomlee.c
>>> o> wrote:
>>>
>>>> Hi Kedar,
>>>>
>>>> Disclaimer: I'd generally say something about this approach to having
>>>> multiple threads incrementing a variable being a bad idea in general, but
>>>> it sounds like you're just trying to explore the behavior of this race
>>>> right?
>>>>
>>>> Benjamin's on the right track: you're seeing zeros because the code
>>>> submitted to the executor hasn't run by the time you print out the "task
>>>> ... updates count to ..." messages. Still, it's not a complete fix & you'll
>>>> very likely continue to see very different results even if you add an
>>>> awaitTermination call after the shutdown() call. Also probably depends on
>>>> how fast your machine is etc. etc. too (e.g. perhaps on slower machines /
>>>> fewer cores you'd see similar output for both).
>>>>
>>>> It's still kind of interesting why the exhibited behavior is so
>>>> different. Here's a bit of a hint -- with the following code I get very
>>>> similar output irrespective of whether I'm using "increment" or
>>>> "incrementStream":
>>>>
>>>> private static volatile int count = 0;
>>>> public static void main(String[] args) throws Exception {
>>>>
>>>>     // warmup (slower)
>>>>     run(false);
>>>>
>>>>     // do it for real (faster)
>>>>     count = 0;
>>>>     run(true);
>>>> }
>>>>
>>>> private static void run(final boolean show) throws Exception {
>>>>     Runnable increment = () -> {
>>>>         for (int i = 0; i < 1000; i++)
>>>>             count++;
>>>>     };
>>>>
>>>>     Runnable incrementStream = () -> {
>>>>         IntStream.rangeClosed(1, 1000).forEach(i -> count++);
>>>>     };
>>>>     ExecutorService exec = Executors.newCachedThreadPool();
>>>>     try {
>>>>         for (int i = 0; i < 10; i++) {
>>>>             exec.execute(increment);
>>>>             // exec.execute(incrementStream);
>>>>             if (show) System.out.println("task: " + i + " updates count to: " + count);
>>>>         }
>>>>     }
>>>>     finally {
>>>>         exec.shutdown();
>>>>         exec.awaitTermination(10, TimeUnit.SECONDS);
>>>>         if (show) System.out.println("final: " + count);
>>>>     }
>>>> }
>>>>
>>>> Weird right?
>>>>
>>>> Another hint: I added code to println() a message to the end of
>>>> incrementStream() in your original code ("hello" or something silly like
>>>> that). I didn't see any "hello" messages until after all the "task ...
>>>> updates count to ..." messages were displayed.
>>>>
>>>> Without going too deep, I suspect all your incrementStream() threads
>>>> are held up by class loading etc. Specifically, the stream APIs you're
>>>> using in incrementStream pull in maybe 40 additional classes on an Oracle
>>>> JVM. To see for yourself, run the JVM with -verbose:class and run both
>>>> increment and incrementStream -- notice the latter does a bunch of extra
>>>> work. Since classes are sort of loaded on-demand, that work needs to happen
>>>> before your incrementStream threads can run. Thus why the warmup step above
>>>> improves the situation.
>>>>
>>>> Put another way: even though logically increment and incrementStream
>>>> are doing something very similar, the latter has to do a bunch of
>>>> additional work before any of the stuff that touches the count variable
>>>> even gets to run. And if it's not obvious it should be noted that your
>>>> scenario here is very small/fast and this effect will be less pronounced
>>>> (but not entirely absent) in a larger test.
>>>>
>>>> Cheers,
>>>> Tom
>>>>
>>>>
>>>> On Fri, Feb 24, 2017 at 9:07 PM, Benjamin Manes <ben.manes at gmail.com>
>>>> wrote:
>>>>
>>>>> You need to wait until the executor has completed, or else the main
>>>>> method may complete prior to the task running.
>>>>>
>>>>> exec.awaitTermination(1, TimeUnit.MINUTES);
>>>>>
>>>>>
>>>>> On Fri, Feb 24, 2017 at 8:53 PM, kedar mhaswade <
>>>>> kedar.mhaswade at gmail.com> wrote:
>>>>>
>>>>>> ​Perhaps I had a long day. So, this might completely be a silly
>>>>>> mistake, but I need congenial help to figure it out.
>>>>>>
>>>>>> To demonstrate race condition, I wrote the following program. The
>>>>>> program has ten concurrent tasks that modify count, a volatile shared
>>>>>> variable. If I use the *increment* task (line 39), I get different
>>>>>> results (like, e.g. [2]) every time I run it, demonstrating the race
>>>>>> condition.
>>>>>>
>>>>>> However, if I use the *incrementStream* task instead (line 39), then
>>>>>> the count variable is not updated at all. The output is like [1] *every
>>>>>> time*. In a separate program not involving threads, I have verified
>>>>>> that the lambda expression like incrementStream updates a member variable
>>>>>> as expected.
>>>>>>
>>>>>> What am I doing wrong?
>>>>>>
>>>>>> Regards,
>>>>>> Kedar
>>>>>>
>>>>>>
>>>>>> public class RaceCondition {
>>>>>>
>>>>>>     private static volatile int count = 0;
>>>>>>     public static void main(String[] args) {
>>>>>>         // update the shared variable traditionally
>>>>>>         Runnable increment = () -> {
>>>>>>             for (int i = 0; i < 1000; i++)
>>>>>>                 count++;
>>>>>>         };
>>>>>>         // update the shared variable as a side effect of an
>>>>>> IntConsumer#accept
>>>>>>         Runnable incrementStream = () -> IntStream.rangeClosed(1,
>>>>>> 100).forEach(i -> count++);
>>>>>>         ExecutorService exec = Executors.newCachedThreadPool(); //
>>>>>> short lived tasks
>>>>>>         try {
>>>>>>             for (int i = 0; i < 10; i++) {
>>>>>>
>>>>>> ​// ​
>>>>>> exec.execute(incrementStream)
>>>>>> ​;
>>>>>> // line 38​
>>>>>> ​​
>>>>>>
>>>>>>               exec.execute(increment);
>>>>>> ​         // line 39​
>>>>>>
>>>>>>                 System.out.println("task: " + i + " updates count to:
>>>>>> " + count);
>>>>>>             }
>>>>>>         } finally {
>>>>>>             exec.shutdown();
>>>>>>             System.out.println("final: " + count);
>>>>>>         }
>>>>>>     }
>>>>>>
>>>>>> }
>>>>>> [1]
>>>>>> task: 0 updates count to: 0
>>>>>> task: 1 updates count to: 0
>>>>>> task: 2 updates count to: 0
>>>>>> task: 3 updates count to: 0
>>>>>> task: 4 updates count to: 0
>>>>>> task: 5 updates count to: 0
>>>>>> task: 6 updates count to: 0
>>>>>> task: 7 updates count to: 0
>>>>>> task: 8 updates count to: 0
>>>>>> task: 9 updates count to: 0
>>>>>> final: 0
>>>>>> [2]
>>>>>> task: 0 updates count to: 0
>>>>>> task: 1 updates count to: 1000
>>>>>> task: 2 updates count to: 1000
>>>>>> task: 3 updates count to: 2000
>>>>>> task: 4 updates count to: 4027
>>>>>> task: 5 updates count to: 5000
>>>>>> task: 6 updates count to: 6000
>>>>>> task: 7 updates count to: 7005
>>>>>> task: 8 updates count to: 8000
>>>>>> task: 9 updates count to: 8185
>>>>>> final: 9381
>>>>>>
>>>>>>
>>>>>> _______________________________________________
>>>>>> Concurrency-interest mailing list
>>>>>> Concurrency-interest at cs.oswego.edu
>>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170301/d1e3e5f7/attachment-0001.html>

From akarnokd at gmail.com  Thu Mar  2 15:39:08 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Thu, 2 Mar 2017 21:39:08 +0100
Subject: [concurrency-interest] SubmissionPublisher closeExceptionally() may
	override close()
Message-ID: <CAAWwtm_4O9OXPhezemmumhhuVBBibmbJkmrm8PQ23UmNqtQGfw@mail.gmail.com>

Hi,

The following test fails (after a few rounds for me) because a concurrent
call to close() and closeExceptionally() race for the terminal condition
and different subscribers may see different terminal state:


Flow.Subscriber<Integer> createSub(Object[] result, int index,
CountDownLatch cdl) {
    return new Flow.Subscriber<Integer>() {
        @Override
        public void onSubscribe(Flow.Subscription subscription) {

        }

        @Override
        public void onNext(Integer item) {

        }

        @Override
        public void onError(Throwable throwable) {
            result[index] = throwable;
            cdl.countDown();
        }

        @Override
        public void onComplete() {
            result[index] = "complete";
            cdl.countDown();
        }
    };
}

@Test
public void closeErrorRace() throws Exception {
    ExecutorService exec = Executors.newSingleThreadExecutor();
    try {
        for (int i = 0; i < 1000; i++) {
            System.out.println("Round " + i);
            SubmissionPublisher<Integer> sp = new SubmissionPublisher<>();

            CountDownLatch cdl = new CountDownLatch(2);

            Object[] result = { null, null };

            sp.subscribe(createSub(result, 0, cdl));

            Flow.Subscriber<Integer> sb2 = createSub(result, 1, cdl);

            Throwable ex = new RuntimeException();

            AtomicInteger wip = new AtomicInteger(2);

            Runnable r1 = () -> {
                wip.decrementAndGet();
                while (wip.get() != 0) ;

                sp.closeExceptionally(ex);
                sp.subscribe(sb2);
            };

            exec.submit(r1);

            wip.decrementAndGet();
            while (wip.get() != 0) ;

            sp.close();

            assertTrue(cdl.await(5, TimeUnit.SECONDS));

            assertEquals(result[0], result[1]);
        }
    } finally {
        exec.shutdownNow();
    }
}

I'm assuming consistency is desirable here and the fix could be an if
statement inside the synchronized block of closeExceptionally():

if (!closed) {
    BufferedSubscription b;
    synchronized (this) {
        b = clients;
        if (b == null) { // or if (closed) {
            return;
        }
        clients = null;
        closed = true;
        closedException = error;
    }
    // the rest
}

-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170302/f469a264/attachment.html>

From dl at cs.oswego.edu  Thu Mar  2 19:47:18 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 2 Mar 2017 19:47:18 -0500
Subject: [concurrency-interest] SubmissionPublisher closeExceptionally()
 may override close()
In-Reply-To: <CAAWwtm_4O9OXPhezemmumhhuVBBibmbJkmrm8PQ23UmNqtQGfw@mail.gmail.com>
References: <CAAWwtm_4O9OXPhezemmumhhuVBBibmbJkmrm8PQ23UmNqtQGfw@mail.gmail.com>
Message-ID: <47165746-92f8-cef6-bfcb-811c31203799@cs.oswego.edu>

On 03/02/2017 03:39 PM, Dávid Karnok wrote:
> Hi,
>
> The following test fails (after a few rounds for me) because a
> concurrent call to close() and closeExceptionally() race for the
> terminal condition and different subscribers may see different terminal
> state:

Thanks for the picky testing!
I agree that the onSubscribe error status is unnecessarily racy,
and it would be nicer to be consistent, and it is easy to do so.
It's now in our sources, but given jdk9  ramp-down rules, unlikely to
make it into initial jdk9 release, especially because it is a niceness
bug.

Thanks also for the post about request method. I hadn't noticed that
somehow r-s spec got passed requiring that the response to innocuous
calls to request(0) should be error. I'll further recheck that this
was not due to some miscommunication.

-Doug




From akarnokd at gmail.com  Fri Mar  3 03:34:10 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Fri, 3 Mar 2017 09:34:10 +0100
Subject: [concurrency-interest] SubmissionPublisher closeExceptionally()
 may override close()
In-Reply-To: <47165746-92f8-cef6-bfcb-811c31203799@cs.oswego.edu>
References: <CAAWwtm_4O9OXPhezemmumhhuVBBibmbJkmrm8PQ23UmNqtQGfw@mail.gmail.com>
 <47165746-92f8-cef6-bfcb-811c31203799@cs.oswego.edu>
Message-ID: <CAAWwtm9yWpbVPq5ns7hh463Hp1S7K9ELk9b96jf6kwu1-DY=LA@mail.gmail.com>

No problem.

2017-03-03 1:47 GMT+01:00 Doug Lea <dl at cs.oswego.edu>:

> On 03/02/2017 03:39 PM, Dávid Karnok wrote:
>
>> Hi,
>>
>> The following test fails (after a few rounds for me) because a
>> concurrent call to close() and closeExceptionally() race for the
>> terminal condition and different subscribers may see different terminal
>> state:
>>
>
> Thanks for the picky testing!
> I agree that the onSubscribe error status is unnecessarily racy,
> and it would be nicer to be consistent, and it is easy to do so.
> It's now in our sources, but given jdk9  ramp-down rules, unlikely to
> make it into initial jdk9 release, especially because it is a niceness
> bug.
>
> Thanks also for the post about request method. I hadn't noticed that
> somehow r-s spec got passed requiring that the response to innocuous
> calls to request(0) should be error. I'll further recheck that this
> was not due to some miscommunication.
>
> -Doug
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170303/17797a55/attachment.html>

From viktor.klang at gmail.com  Sun Mar  5 15:06:38 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Sun, 5 Mar 2017 21:06:38 +0100
Subject: [concurrency-interest] JDK 9 Flow and Reactive Streams Rules /
	TCK
In-Reply-To: <43a3301b-d6b4-a958-eff8-4423578b647f@cs.oswego.edu>
References: <CAOnZH-a5_pVbjuqoFL3YdhN=2BZCUe8DvFAH+v4zhsKWAkMUUw@mail.gmail.com>
 <43a3301b-d6b4-a958-eff8-4423578b647f@cs.oswego.edu>
Message-ID: <CANPzfU8tv4KwgkZ9FYn1SQW=ebCnfL1Y0fMc-qOsAFnRWmvvDA@mail.gmail.com>

We've had some issues getting Gradle to handle jdk9 properly, so I haven't
had a chance to create a bridge for the TCK yet—we have converters in the
pipeline for Flow<>RS which means we wouldn't have to bifurcate the TCK
project.


On Wed, Mar 1, 2017 at 1:59 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 02/27/2017 03:12 PM, Rossen Stoyanchev wrote:
>
> The Javadoc for Flow.java [1] and also the JEP-266 [2] mention that
>> these interfaces correspond to the reactive-streams specification both
>> linking to reactive-streams.org <http://reactive-streams.org> but there
>> is no explicit mention of spec rules + TCK nor whether implementations
>> of the Flow interfaces are required to conform.
>>
>
> I hope that you don't mean to imply that people should feel free
> not to conform to or test their implementations of other j.u.c
> interfaces :-)
>
> Our javadocs cover the R-S specs, but are expressed in a typical
> JDK interface-centric fashion. I'm not sure what more we can say
> or do to make people click the reactive-streams.org links to find
> out more about rationale and available tests.
> Although we should consider your suggestion of adding the link in a
> few more places just in case people missed them.
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170305/33b24bb5/attachment.html>

From akarnokd at gmail.com  Sun Mar  5 15:24:09 2017
From: akarnokd at gmail.com (=?UTF-8?Q?D=C3=A1vid_Karnok?=)
Date: Sun, 5 Mar 2017 21:24:09 +0100
Subject: [concurrency-interest] JDK 9 Flow and Reactive Streams Rules /
	TCK
In-Reply-To: <CANPzfU8tv4KwgkZ9FYn1SQW=ebCnfL1Y0fMc-qOsAFnRWmvvDA@mail.gmail.com>
References: <CAOnZH-a5_pVbjuqoFL3YdhN=2BZCUe8DvFAH+v4zhsKWAkMUUw@mail.gmail.com>
 <43a3301b-d6b4-a958-eff8-4423578b647f@cs.oswego.edu>
 <CANPzfU8tv4KwgkZ9FYn1SQW=ebCnfL1Y0fMc-qOsAFnRWmvvDA@mail.gmail.com>
Message-ID: <CAAWwtm8mh79-KPD39hGGPCr+SvXjeQ6vY4DKOZpiqYvHiwm2_g@mail.gmail.com>

If you can setup a JDK 9 project/build environment, creating the converter
and using the RS TCK is relatively easy. I managed this via IntelliJ 2017.1
EAP in a non-Gradle, non-Maven project by adding the TCK via Add Library
from Maven and writing the converter:

https://github.com/akarnokd/akarnokd-misc-java9/blob/master/src/hu/akarnokd/java9/benchmark/SubmissionPublisherTckTest.java#L45

until https://github.com/reactive-streams/reactive-streams-jvm/pull/296
gets worked out.


2017-03-05 21:06 GMT+01:00 Viktor Klang <viktor.klang at gmail.com>:

> We've had some issues getting Gradle to handle jdk9 properly, so I haven't
> had a chance to create a bridge for the TCK yet—we have converters in the
> pipeline for Flow<>RS which means we wouldn't have to bifurcate the TCK
> project.
>
>
> On Wed, Mar 1, 2017 at 1:59 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
>> On 02/27/2017 03:12 PM, Rossen Stoyanchev wrote:
>>
>> The Javadoc for Flow.java [1] and also the JEP-266 [2] mention that
>>> these interfaces correspond to the reactive-streams specification both
>>> linking to reactive-streams.org <http://reactive-streams.org> but there
>>> is no explicit mention of spec rules + TCK nor whether implementations
>>> of the Flow interfaces are required to conform.
>>>
>>
>> I hope that you don't mean to imply that people should feel free
>> not to conform to or test their implementations of other j.u.c
>> interfaces :-)
>>
>> Our javadocs cover the R-S specs, but are expressed in a typical
>> JDK interface-centric fashion. I'm not sure what more we can say
>> or do to make people click the reactive-streams.org links to find
>> out more about rationale and available tests.
>> Although we should consider your suggestion of adding the link in a
>> few more places just in case people missed them.
>>
>> -Doug
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Cheers,
> √
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


-- 
Best regards,
David Karnok
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170305/f85c22e4/attachment.html>

From dl at cs.oswego.edu  Mon Mar 13 12:17:32 2017
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 13 Mar 2017 12:17:32 -0400
Subject: [concurrency-interest] JDK 9 VarHandle memory mode usage guide
Message-ID: <31443cfc-0e0c-95f2-3296-2e3d6b6ac274@cs.oswego.edu>


As may recall, JDK 9 VarHandles with new memory modes were incorporated
without a full overhaul of the Java Memory Model that would be needed
to formally specify them. For the past year or so I've been sporadically
working on an expert-programmer guide that conveys as much information
as possible while skirting the issues (like out-of-thin-air) that led
to stalls in revising the JMM. Considering that there's now no chance
for a JLS JMM update to occur before JDK 9 release, this might be the
we can do. The current draft is available at
   http://gee.cs.oswego.edu/dl/html/j9mm.html

If you are on this list, you are probably in the main target audience
for this guide. Someday, a less imposing overview might be nice. Plus
more examples.

-Doug



From rl.stpuu at gmail.com  Thu Mar 16 12:29:19 2017
From: rl.stpuu at gmail.com (Roussanka Loukanova)
Date: Thu, 16 Mar 2017 17:29:19 +0100
Subject: [concurrency-interest] CfP: LACompLing2017 - Logic and Algorithms
 in Computational Linguistics 2017
Message-ID: <CACAe74jJYkuBEZfLcN-DvOPSWuM8SkR8WdwAR=iutwoG0zb2aw@mail.gmail.com>

                      CALL FOR PAPERS

                          Workshop on
Logic and Algorithms in Computational Linguistics 2017 (LACompLing2017)
                   Stockholm, August 16-19, 2017

        http://staff.math.su.se/rloukanova/LACompLing17.html

     * Submission deadline for regular papers: April 14, 2017 *
=================================================

                      Affiliated with the
26th Annual EACSL Conference on Computer Science Logic CSL'2017
                   Stockholm, 20--26 August 2017
                   https://www.csl17.conf.kth.se/

                        Co-located with:
                     Logic in Stockholm 2017
                  https://www.lis17.conf.kth.se/
=================================================

DESCRIPTION
==
Computational linguistics studies natural language in its various
manifestations from a computational point of view, both on the theoretical
level (modeling grammar modules dealing with natural language form and
meaning, and the relation between these two) and on the practical level
(developing applications for language and speech technology). Right from
the start in the 1950ties, there have been strong links with computer
science, logic, and many areas of mathematics - one can think of Chomsky's
contributions to the theory of formal languages and automata, or Lambek's
logical modeling of natural language syntax. The workshop assesses the
place of logic, mathematics, and computer science in present day
computational linguistics. It intends to be a forum for presenting new
results as well as work in progress.
--------------------------------

SCOPE
==
The workshop focuses mainly on logical approaches to computational
processing of natural language, and on the applicability of methods and
techniques from the study of artificial languages (programming/logic) in
computational linguistics. We invite participation and submissions from
other relevant approaches too, especially if they can inspire new work and
approaches.

The topics of LACompLing2017 include, but are not limited to:

- Computational theories of human language
- Computational syntax
- Computational semantics
- Computational syntax-semantics interface
- Interfaces between morphology, lexicon, syntax, semantics, speech, text,
pragmatics
- Computational grammar
- Logic and reasoning systems for linguistics
- Type theories for linguistics
- Models of computation and algorithms for linguistics
- Language processing
- Parsing algorithms
- Generation of language from semantic representations
- Large-scale grammars of natural languages
- Multilingual processing
- Data science in language processing
- Machine learning of language
- Interdisciplinary methods
- Integration of formal, computational, model theoretic, graphical,
diagrammatic, statistical, and other related methods
- Logic for information extraction or expression in written and spoken
language
- Language theories based on biological fundamentals of information and
languages
- Computational neuroscience of language

IMPORTANT DATES
==
Submission deadline for regular papers: April 14, 2017
Notification of paper acceptance: May 31, 2017
Abstracts of short presentations:  June 4, 2017
Notifications for short presentations: June 12, 2017
Deadline for final submissions: June 25, 2017
Workshop: August 16-19, 2017

SUBMISSION INSTRUCTIONS
==
- Regular papers: between 10-15 pages, including figures and references, by
using LaTeX, with article.sty:
\documentclass[a4paper,11pt]{article}

- Abstracts of short presentations: not more than 1 page, by using LaTeX,
with article.sty:
\documentclass[a4paper,11pt]{article}

- We invite original papers that are not submitted concurrently to another
conference or for publication elsewhere

- The submissions of proposed papers and abstracts of short presentations
have to be in pdf

- The camera-ready submissions require the pdf of the papers and their
LaTeX sources

The submissions are via the EasyChair management system of LACompLing2017:

https://easychair.org/conferences/?conf=lacompling2017

PUBLICATIONS
==
- The proceedings of LACompLing2017 will be published digitally by the DiVA
system of Stockholm University:
http://su.diva-portal.org

- Improved and extended versions of selected papers, which have been
presented at the workshop LACompLing2017, will be published by the Journal
of Logic, Language and Information, JoLLI, after the workshop.

ORGANIZERS
==
Krasimir Angelov, University of Gothenburg, Sweden
Valeria de Paiva, Nuance Communications, USA
Kristina Liefke, Ludwig-Maximilians-University Munich, Germany
Roussanka Loukanova, Stockholm University, Sweden (chair)
Michael Moortgat, Utrecht University, The Netherlands
Reinhard Muskens, Tilburg University, The Netherlands

CONTACT
==
Roussanka Loukanova (rloukanova at gmail.com)
Valeria de Paiva (valeria.depaiva at gmail.com)
--------------------------------
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170316/cd6b4eab/attachment.html>

From rl.stpuu at gmail.com  Thu Mar 16 13:08:06 2017
From: rl.stpuu at gmail.com (Roussanka Loukanova)
Date: Thu, 16 Mar 2017 18:08:06 +0100
Subject: [concurrency-interest] CfP: AI aspects of Reasoning, Information,
	and Memory 2017 (AIRIM'17)
Message-ID: <CACAe74hpUP1ONP1KcNpYD2CEo4ZKfGXSwKbd7-Hps+n5oe7a+g@mail.gmail.com>

CALL FOR PAPERS

2nd International Workshop on
AI aspects of Reasoning, Information, and Memory 2017 (AIRIM'17)

https://www.fedcsis.org/2017/airim

Prague, Czech Republic, 3-6 September, 2017

Paper submission: May 10, 2017

-------------------------------------------------------------
SCOPE
There is general realization that computational models of languages and
reasoning can be improved by integration of heterogeneous resources of
information, e.g., multidimensional diagrams, images, language, syntax,
semantics, quantitative data, memory. While the event targets promotion of
integrated computational approaches, we invite contributions from any
individual areas related to information, language, memory, reasoning.

TOPICS

We welcome submissions of papers on the following topics, without limiting
to them, across approaches, methods, theories, and applications:

- Reasoning systems --- theories and applications
- Proof systems and model checkers
- Theories of computation and information
- Interactive computation and reasoning
- Computation and reasoning with heterogeneous information
- Space and time in information, language, memory, and reasoning
- Partiality, underspecification, vagueness, and possibilities
- Detection of and reasoning with inconsistency
- Logic and language --- approaches, theories, methods
- Computational morphology, syntax, semantics, and interfaces between these
- Constraint-based and type-theoretic approaches and grammars
- Logical approaches to multilingual processing
- Logical and computational foundations in machine learning and information
retrieval
- Mathematics for linguistics and cognitive science
- Reasoning, information, and memory in computational neuroscience and life
sciences
- Interdisciplinary approaches to information, language, memory, and
reasoning

IMPORTANT DATES

Paper submission (strict deadline): May 10, 2017 23:59:59 pm HST
Position paper submission: May 31, 2017
Authors notification: June 14, 2017
Final paper submission and registration: June 28, 2017
Final deadline for discounted fee: August 01, 2017
Conference dates: September 3-6, 2017

PAPER SUBMISSION and PUBLICATIONS

The publication rules for AIRIM'17 are the same as for AAIA'17:
https://www.fedcsis.org/2017/airim

- Authors should submit draft papers (as Postscript, PDF of MSWord file)
- The total length of a paper should not exceed 10 pages IEEE style
(including tables, figures and references). IEEE style templates are
available at the websites of AIRIM'17 | AAIA'17
- Papers will be refereed and accepted on the basis of their scientific
merit and relevance to the workshop
- Pre-prints containing accepted papers will be published on a USB memory
stick provided to the FedCSIS participants
- Only papers presented at the conference will be published in Conference
Proceedings and submitted for inclusion in the IEEE Xplore® database
- Conference proceedings will be published in a volume with ISBN, ISSN, and
DOI numbers and posted at the conference WWW site
- Conference proceedings will be indexed in BazEkon and submitted for
indexation in: Thomson Reuters - Conference Proceedings Citation Index,
SciVerse Scopus, Inspec, Index Copernicus, DBLP Computer Science
Bibliography, and Google Scholar
- Extended versions of selected papers presented during the conference will
be published as Special Issue(s)

CONTACT INFORMATION

Roussanka Loukanova (rloukanova at gmail.com)
-------------------------------------------------------------
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170316/af7f4a0d/attachment-0001.html>

From openjdk at duigou.org  Sun Mar 19 21:10:25 2017
From: openjdk at duigou.org (Mike Duigou)
Date: Sun, 19 Mar 2017 18:10:25 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
Message-ID: <58b268542c393f6cce3949bb8544a35a@duigou.org>

Is it just an oversight or is there a reason why the array types in the 
j.u.c.atomic package, AtomicIntegerArray, AtomicLongArray and 
AtomicReferenceArray, do not provide toArray(), stream() or, for 
AtomicReferenceArray, iterator() methods? I don't see any obstacles in 
implementing the methods but I am surprised that the methods aren't 
already there.

Mike

From leventov.ru at gmail.com  Sun Mar 19 21:59:42 2017
From: leventov.ru at gmail.com (Roman Leventov)
Date: Sun, 19 Mar 2017 19:59:42 -0600
Subject: [concurrency-interest] Moving ThreadPoolExecutor from finalization
	to Cleaner
Message-ID: <CAAMLo=Z8iPysE+scCEuyOowuGyr7ASm0nd6+rNYz+jSp5sdEnw@mail.gmail.com>

Finalizable objects on the heap affect garbage collection negatively.
ThreadPoolExecutor is always used by some programmers instead of new
Thread().start(), via Executors.newSingleThreadExecutor(). I would not be
surprised if some applications create thousands of ThreadPoolExecutors. So
making ThreadPoolExecutor to use Cleaner instead of finalization should be
helpful.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170319/95d5917a/attachment.html>

From martinrb at google.com  Mon Mar 20 18:16:26 2017
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 20 Mar 2017 15:16:26 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <58b268542c393f6cce3949bb8544a35a@duigou.org>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
Message-ID: <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>

There's a large number of collection-like methods one could define for
atomic arrays - forEach, fill, indexOf, toArray(), etc...
If we were brave enough to change the Java language, we could do the same
for ordinary arrays; it already has a "length" "field".

But all of j.u.c.atomic feels largely obsoleted by VarHandles.  Both are
low-level mechanisms.  Build your own collection class on top!

On Sun, Mar 19, 2017 at 6:10 PM, Mike Duigou <openjdk at duigou.org> wrote:

> Is it just an oversight or is there a reason why the array types in the
> j.u.c.atomic package, AtomicIntegerArray, AtomicLongArray and
> AtomicReferenceArray, do not provide toArray(), stream() or, for
> AtomicReferenceArray, iterator() methods? I don't see any obstacles in
> implementing the methods but I am surprised that the methods aren't already
> there.
>
> Mike
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/81eeb8ff/attachment.html>

From jbloch at gmail.com  Mon Mar 20 18:52:09 2017
From: jbloch at gmail.com (Joshua Bloch)
Date: Mon, 20 Mar 2017 15:52:09 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
Message-ID: <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>

On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com>
wrote:

> There's a large number of collection-like methods one could define for
> atomic arrays - forEach, fill, indexOf, toArray(), etc...
> If we were brave enough to change the Java language, we could do the same
> for ordinary arrays; it already has a "length" "field".
>
> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
>

All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still
the tool of choice for generating serial numbers (and the like)?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/c94bb104/attachment.html>

From martinrb at google.com  Mon Mar 20 19:06:00 2017
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 20 Mar 2017 16:06:00 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
Message-ID: <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>

AtomicLong is still fine and not going away, but manipulating a VarHandle
for a long field
http://download.java.net/java/jdk9/docs/api/java/lang/invoke/VarHandle.html#getAndAdd-java.lang.Object...-
saves a level of indirection and is expected to be a little more efficient.

On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch <jbloch at gmail.com> wrote:

>
>
> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
>> There's a large number of collection-like methods one could define for
>> atomic arrays - forEach, fill, indexOf, toArray(), etc...
>> If we were brave enough to change the Java language, we could do the same
>> for ordinary arrays; it already has a "length" "field".
>>
>> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
>>
>
> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still
> the tool of choice for generating serial numbers (and the like)?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/73a66a3c/attachment.html>

From jbloch at gmail.com  Mon Mar 20 19:10:22 2017
From: jbloch at gmail.com (Joshua Bloch)
Date: Mon, 20 Mar 2017 16:10:22 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
Message-ID: <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>

The conceptual surface area appears larger. Have you confirmed that the
performance justifies this for simple uses such as the one I mentioned (a
static long or AtomicLong uses solely for computing serial nubmers)? I'm
not just giving you a hard time. This affects the concurrency chapter of
Effective Java 3e.


On Mon, Mar 20, 2017 at 4:06 PM, Martin Buchholz <martinrb at google.com>
wrote:

> AtomicLong is still fine and not going away, but manipulating a VarHandle
> for a long field
> http://download.java.net/java/jdk9/docs/api/java/lang/
> invoke/VarHandle.html#getAndAdd-java.lang.Object...-
> saves a level of indirection and is expected to be a little more efficient.
>
> On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch <jbloch at gmail.com> wrote:
>
>>
>>
>> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>>> There's a large number of collection-like methods one could define for
>>> atomic arrays - forEach, fill, indexOf, toArray(), etc...
>>> If we were brave enough to change the Java language, we could do the
>>> same for ordinary arrays; it already has a "length" "field".
>>>
>>> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
>>>
>>
>> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still
>> the tool of choice for generating serial numbers (and the like)?
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/6037351a/attachment.html>

From ben.manes at gmail.com  Mon Mar 20 19:18:43 2017
From: ben.manes at gmail.com (Benjamin Manes)
Date: Mon, 20 Mar 2017 23:18:43 +0000
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
Message-ID: <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>

I think for common case usages, one should still prefer the atomic classes.
For custom data structures, e.g. a cache's entry, the VarHandles API is
preferable for greater flexibility and lower memory overhead.

On Mon, Mar 20, 2017 at 4:14 PM Joshua Bloch <jbloch at gmail.com> wrote:

> The conceptual surface area appears larger. Have you confirmed that the
> performance justifies this for simple uses such as the one I mentioned (a
> static long or AtomicLong uses solely for computing serial nubmers)? I'm
> not just giving you a hard time. This affects the concurrency chapter of
> Effective Java 3e.
>
>
> On Mon, Mar 20, 2017 at 4:06 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
> AtomicLong is still fine and not going away, but manipulating a VarHandle
> for a long field
>
> http://download.java.net/java/jdk9/docs/api/java/lang/invoke/VarHandle.html#getAndAdd-java.lang.Object...-
> saves a level of indirection and is expected to be a little more efficient.
>
> On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch <jbloch at gmail.com> wrote:
>
>
>
> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com>
> wrote:
>
> There's a large number of collection-like methods one could define for
> atomic arrays - forEach, fill, indexOf, toArray(), etc...
> If we were brave enough to change the Java language, we could do the same
> for ordinary arrays; it already has a "length" "field".
>
> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
>
>
> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still
> the tool of choice for generating serial numbers (and the like)?
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/2578a8b5/attachment-0001.html>

From jbloch at gmail.com  Mon Mar 20 19:24:38 2017
From: jbloch at gmail.com (Joshua Bloch)
Date: Mon, 20 Mar 2017 16:24:38 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
Message-ID: <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>

Ben,

That's what I assumed, but I'll give Martin a chance to respond :)

Josh

On Mon, Mar 20, 2017 at 4:18 PM, Benjamin Manes <ben.manes at gmail.com> wrote:

> I think for common case usages, one should still prefer the atomic
> classes. For custom data structures, e.g. a cache's entry, the VarHandles
> API is preferable for greater flexibility and lower memory overhead.
>
> On Mon, Mar 20, 2017 at 4:14 PM Joshua Bloch <jbloch at gmail.com> wrote:
>
>> The conceptual surface area appears larger. Have you confirmed that the
>> performance justifies this for simple uses such as the one I mentioned (a
>> static long or AtomicLong uses solely for computing serial nubmers)? I'm
>> not just giving you a hard time. This affects the concurrency chapter of
>> Effective Java 3e.
>>
>>
>> On Mon, Mar 20, 2017 at 4:06 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>> AtomicLong is still fine and not going away, but manipulating a VarHandle
>> for a long field
>> http://download.java.net/java/jdk9/docs/api/java/lang/
>> invoke/VarHandle.html#getAndAdd-java.lang.Object...-
>> saves a level of indirection and is expected to be a little more
>> efficient.
>>
>> On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch <jbloch at gmail.com> wrote:
>>
>>
>>
>> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com>
>> wrote:
>>
>> There's a large number of collection-like methods one could define for
>> atomic arrays - forEach, fill, indexOf, toArray(), etc...
>> If we were brave enough to change the Java language, we could do the same
>> for ordinary arrays; it already has a "length" "field".
>>
>> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
>>
>>
>> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still
>> the tool of choice for generating serial numbers (and the like)?
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/f191b82f/attachment.html>

From forax at univ-mlv.fr  Mon Mar 20 19:33:42 2017
From: forax at univ-mlv.fr (Remi Forax)
Date: Tue, 21 Mar 2017 00:33:42 +0100 (CET)
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
Message-ID: <1435772898.36749.1490052822694.JavaMail.zimbra@u-pem.fr>

Hi Martin, 
i think there is an Arrayish interface with several default methods implemented by all plain old Java arrays as part of valhalla. 

I think it's currently scheduled for 11 when generics over primitives will be integrated. 

Rémi 

> De: "Martin Buchholz" <martinrb at google.com>
> À: "Mike Duigou" <openjdk at duigou.org>
> Cc: "Concurrency Interest" <concurrency-interest at cs.oswego.edu>
> Envoyé: Lundi 20 Mars 2017 23:16:26
> Objet: Re: [concurrency-interest] Atomic arrays and toArray(), stream(),
> iterator()

> There's a large number of collection-like methods one could define for atomic
> arrays - forEach, fill, indexOf, toArray(), etc...
> If we were brave enough to change the Java language, we could do the same for
> ordinary arrays; it already has a "length" "field".

> But all of j.u.c.atomic feels largely obsoleted by VarHandles. Both are
> low-level mechanisms. Build your own collection class on top!

> On Sun, Mar 19, 2017 at 6:10 PM, Mike Duigou < openjdk at duigou.org > wrote:

>> Is it just an oversight or is there a reason why the array types in the
>> j.u.c.atomic package, AtomicIntegerArray, AtomicLongArray and
>> AtomicReferenceArray, do not provide toArray(), stream() or, for
>> AtomicReferenceArray, iterator() methods? I don't see any obstacles in
>> implementing the methods but I am surprised that the methods aren't already
>> there.

>> Mike
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170321/db5293ed/attachment.html>

From forax at univ-mlv.fr  Mon Mar 20 19:47:14 2017
From: forax at univ-mlv.fr (Remi Forax)
Date: Tue, 21 Mar 2017 00:47:14 +0100 (CET)
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
 <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
Message-ID: <450871930.37455.1490053634955.JavaMail.zimbra@u-pem.fr>

Hi Josh, 

[Added Paul in CC as he works on it] 

VarHandles are a replacement for all Atomic*FieldUpdaters (fields + array), 
- they are faster because the VarHandle API do not uses generics which has a runtime cost, the VM can not trust genrics because they are erased and use a polymorphic signature instead. 
- they work on ByteBuffer too 
- they allow opaque access (the semantics of volatile before the revision of the JMM) 
- they allow real weakCAS semantics and not the Frankenstein weakCAS of the field updater) 

Atomic classes are still here, still easier to use than VarHandle, and like before, compared to a VarHandle, they cost a pointer indirection (apart if you inherit from the Atomic class). 

regards, 
Rémi 

> De: "jbloch" <jbloch at gmail.com>
> À: "Benjamin Manes" <ben.manes at gmail.com>
> Cc: "Martin Buchholz" <martinrb at google.com>, "Mike Duigou" <openjdk at duigou.org>,
> "Concurrency Interest" <concurrency-interest at cs.oswego.edu>
> Envoyé: Mardi 21 Mars 2017 00:24:38
> Objet: Re: [concurrency-interest] Atomic arrays and toArray(), stream(),
> iterator()

> Ben,
> That's what I assumed, but I'll give Martin a chance to respond :)

> Josh

> On Mon, Mar 20, 2017 at 4:18 PM, Benjamin Manes < ben.manes at gmail.com > wrote:

>> I think for common case usages, one should still prefer the atomic classes. For
>> custom data structures, e.g. a cache's entry, the VarHandles API is preferable
>> for greater flexibility and lower memory overhead.

>> On Mon, Mar 20, 2017 at 4:14 PM Joshua Bloch < jbloch at gmail.com > wrote:

>>> The conceptual surface area appears larger. Have you confirmed that the
>>> performance justifies this for simple uses such as the one I mentioned (a
>>> static long or AtomicLong uses solely for computing serial nubmers)? I'm not
>>> just giving you a hard time. This affects the concurrency chapter of Effective
>>> Java 3e.

>>> On Mon, Mar 20, 2017 at 4:06 PM, Martin Buchholz < martinrb at google.com > wrote:

>>>> AtomicLong is still fine and not going away, but manipulating a VarHandle for a
>>>> long field
>>>> http://download.java.net/java/jdk9/docs/api/java/lang/invoke/VarHandle.html#getAndAdd-java.lang.Object...-
>>>> saves a level of indirection and is expected to be a little more efficient.

>>>> On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch < jbloch at gmail.com > wrote:

>>>>> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz < martinrb at google.com > wrote:

>>>>>> There's a large number of collection-like methods one could define for atomic
>>>>>> arrays - forEach, fill, indexOf, toArray(), etc...
>>>>>> If we were brave enough to change the Java language, we could do the same for
>>>>>> ordinary arrays; it already has a "length" "field".

>>>>>> But all of j.u.c.atomic feels largely obsoleted by VarHandles.

>>>>> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still the
>>>>> tool of choice for generating serial numbers (and the like)?

>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170321/b9a1f951/attachment-0001.html>

From martinrb at google.com  Mon Mar 20 19:49:31 2017
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 20 Mar 2017 16:49:31 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
 <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
Message-ID: <CA+kOe0-NbBM1Mfh71HfN7-LC5S6JuqgTFrW3g6z-4iuJ7Ep9tA@mail.gmail.com>

On Mon, Mar 20, 2017 at 4:24 PM, Joshua Bloch <jbloch at gmail.com> wrote:

> Ben,
>
> That's what I assumed, but I'll give Martin a chance to respond :)
>

I was waiting for Doug or Aleksey to respond!

The biggest advantage of AtomicLong will always be PORTABILITY.  Each
platform iteration takes more years to become ubiquitous than its
predecessor, and that will be even more true for jdk9.  VarHandles are for
classes that are part of the platform or that value extreme performance
more than portability.

OTOH jdk9 AtomicLong is a wrapper around VarHandle.  It's unlikely to be
completely free. .... oh I now see Remi has a better answer!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/da6d2e6d/attachment.html>

From jbloch at gmail.com  Mon Mar 20 20:19:06 2017
From: jbloch at gmail.com (Joshua Bloch)
Date: Mon, 20 Mar 2017 17:19:06 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <CA+kOe0-NbBM1Mfh71HfN7-LC5S6JuqgTFrW3g6z-4iuJ7Ep9tA@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
 <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
 <CA+kOe0-NbBM1Mfh71HfN7-LC5S6JuqgTFrW3g6z-4iuJ7Ep9tA@mail.gmail.com>
Message-ID: <CAP0L=USLMkRYrvpZyrQFtq-mBd+nMzBZP4-UCJjbsaDXA9eoag@mail.gmail.com>

Yes, all of this makes sense.  Also Doug just called me, and said pretty
much the same thing (though he he used some amusing phrase like
"repulsively ugly incantation"). So I think we're all on the same page.

Josh

On Mon, Mar 20, 2017 at 4:49 PM, Martin Buchholz <martinrb at google.com>
wrote:

>
>
> On Mon, Mar 20, 2017 at 4:24 PM, Joshua Bloch <jbloch at gmail.com> wrote:
>
>> Ben,
>>
>> That's what I assumed, but I'll give Martin a chance to respond :)
>>
>
> I was waiting for Doug or Aleksey to respond!
>
> The biggest advantage of AtomicLong will always be PORTABILITY.  Each
> platform iteration takes more years to become ubiquitous than its
> predecessor, and that will be even more true for jdk9.  VarHandles are for
> classes that are part of the platform or that value extreme performance
> more than portability.
>
> OTOH jdk9 AtomicLong is a wrapper around VarHandle.  It's unlikely to be
> completely free. .... oh I now see Remi has a better answer!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/5c8d79af/attachment.html>

From paul.sandoz at oracle.com  Mon Mar 20 20:25:33 2017
From: paul.sandoz at oracle.com (Paul Sandoz)
Date: Mon, 20 Mar 2017 17:25:33 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
In-Reply-To: <450871930.37455.1490053634955.JavaMail.zimbra@u-pem.fr>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
 <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
 <450871930.37455.1490053634955.JavaMail.zimbra@u-pem.fr>
Message-ID: <9A0E5632-D6F3-4116-9021-570FDA53EAE7@oracle.com>

Hi,

I think Ben makes a fair evaluation. W.r.t the Atomic* classes, not including Atomic*FieldUpdaters as Remi notes below, my recommendation would be to reach for VarHandle if:

1) the Atomic* box is bothersome;
2) some type other than int/long/ref is required; or
3) VarHandle-specific access is required (e.g. bitwise ops).


If we consider the Atomic* box as something that does not need to strongly encapsulate, which i think is more the case now many weaker forms of access are supported, we could make an argument for providing public static final VarHandle instances on each AtomicType as a bridge to support VarHandle-specific access.


Some of the Atomic* classes use VarHandle but others are problematic (such as AtomicInteger/Long) due to circular dependencies in class initializers at start up. I hope to revisit this aspect at some point. (Martin, at one point AtomicLong did wrap VarHandle but i had to revert the changeset due to such circularity issues.)

Hth,
Paul.

> On 20 Mar 2017, at 16:47, Remi Forax <forax at univ-mlv.fr> wrote:
> 
> Hi Josh,
> 
> [Added Paul in CC as he works on it]
> 
> VarHandles are a replacement for all Atomic*FieldUpdaters (fields + array),
> - they are faster because the VarHandle API do not uses generics which has a runtime cost, the VM can not trust genrics because they are erased and use a polymorphic signature instead.
> - they work on ByteBuffer too
> - they allow opaque access (the semantics of volatile before the revision of the JMM)
> - they allow real weakCAS semantics and not the Frankenstein weakCAS of the field updater)
> 
> Atomic classes are still here, still easier to use than VarHandle, and like before, compared to a VarHandle, they cost a pointer indirection (apart if you inherit from the Atomic class).
> 
> regards,
> Rémi
> 
> De: "jbloch" <jbloch at gmail.com>
> À: "Benjamin Manes" <ben.manes at gmail.com>
> Cc: "Martin Buchholz" <martinrb at google.com>, "Mike Duigou" <openjdk at duigou.org>, "Concurrency Interest" <concurrency-interest at cs.oswego.edu>
> Envoyé: Mardi 21 Mars 2017 00:24:38
> Objet: Re: [concurrency-interest] Atomic arrays and toArray(), stream(),        iterator()
> Ben,
> That's what I assumed, but I'll give Martin a chance to respond :)
> 
> Josh
> 
> On Mon, Mar 20, 2017 at 4:18 PM, Benjamin Manes <ben.manes at gmail.com> wrote:
> I think for common case usages, one should still prefer the atomic classes. For custom data structures, e.g. a cache's entry, the VarHandles API is preferable for greater flexibility and lower memory overhead.
> 
> On Mon, Mar 20, 2017 at 4:14 PM Joshua Bloch <jbloch at gmail.com> wrote:
> The conceptual surface area appears larger. Have you confirmed that the performance justifies this for simple uses such as the one I mentioned (a static long or AtomicLong uses solely for computing serial nubmers)? I'm not just giving you a hard time. This affects the concurrency chapter of Effective Java 3e.
> 
> 
> On Mon, Mar 20, 2017 at 4:06 PM, Martin Buchholz <martinrb at google.com> wrote:
> AtomicLong is still fine and not going away, but manipulating a VarHandle for a long field
> http://download.java.net/java/jdk9/docs/api/java/lang/invoke/VarHandle.html#getAndAdd-java.lang.Object...-
> saves a level of indirection and is expected to be a little more efficient.
> 
> On Mon, Mar 20, 2017 at 3:52 PM, Joshua Bloch <jbloch at gmail.com> wrote:
> 
> 
> On Mon, Mar 20, 2017 at 3:16 PM, Martin Buchholz <martinrb at google.com> wrote:
> There's a large number of collection-like methods one could define for atomic arrays - forEach, fill, indexOf, toArray(), etc...
> If we were brave enough to change the Java language, we could do the same for ordinary arrays; it already has a "length" "field".
> 
> But all of j.u.c.atomic feels largely obsoleted by VarHandles.
> 
> All of j.u.c atomic? That's a strong statement. Isn't an AtomicLong still the tool of choice for generating serial numbers (and the like)?
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 841 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170320/4760330d/attachment.sig>

From openjdk at duigou.org  Mon Mar 20 20:34:07 2017
From: openjdk at duigou.org (Mike Duigou)
Date: Mon, 20 Mar 2017 17:34:07 -0700
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
 iterator()
In-Reply-To: <CAP0L=USLMkRYrvpZyrQFtq-mBd+nMzBZP4-UCJjbsaDXA9eoag@mail.gmail.com>
References: <58b268542c393f6cce3949bb8544a35a@duigou.org>
 <CA+kOe0-TVxjvfb5uSnLUWqtYrNbkVpSCHzSkUQydJkXwAM9KsQ@mail.gmail.com>
 <CAP0L=URjTnHs5txMMYuZkL+tM0U5VF3NiqFmM5G=HxbqJEq9pg@mail.gmail.com>
 <CA+kOe0-+VEuPipTArhXa2NsOkiTiUqTOtJnpk2wNrYZuFempYQ@mail.gmail.com>
 <CAP0L=US0xHnKCVJ20oHBeihPE0VqO+ALQX6JjAvBxTbELT4PRQ@mail.gmail.com>
 <CAGu0=MMfHuHNNe-DOVixBODTjnP9ef+gZRx12i671-zANuZbew@mail.gmail.com>
 <CAP0L=UTye=OF47BxfPOpP-jftsKKm=vUZ8_=7u=QxOC3fzqBWg@mail.gmail.com>
 <CA+kOe0-NbBM1Mfh71HfN7-LC5S6JuqgTFrW3g6z-4iuJ7Ep9tA@mail.gmail.com>
 <CAP0L=USLMkRYrvpZyrQFtq-mBd+nMzBZP4-UCJjbsaDXA9eoag@mail.gmail.com>
Message-ID: <e6d3bf10931bc574841af74a8fb790a4@duigou.org>

For the safe serial number pattern I've become pretty partial to 
variations of

final static LongSupplier serialSource = (new 
AtomicLong(0))::incrementAndGet;

sometimes with the LongSupplier itself being supplied by a framework. It 
is useful that I can safely pass around the LongSupplier while also 
delaying invocation until a value is actually needed.

Mike

On 2017-03-20 17:19, Joshua Bloch wrote:
> Yes, all of this makes sense.  Also Doug just called me, and said
> pretty much the same thing (though he he used some amusing phrase like
> "repulsively ugly incantation"). So I think we're all on the same
> page.
> 
> Josh
> 
> On Mon, Mar 20, 2017 at 4:49 PM, Martin Buchholz <martinrb at google.com>
> wrote:
> 
>> On Mon, Mar 20, 2017 at 4:24 PM, Joshua Bloch <jbloch at gmail.com>
>> wrote:
>> 
>>> Ben,
>>> 
>>> That's what I assumed, but I'll give Martin a chance to respond :)
>> 
>> I was waiting for Doug or Aleksey to respond!
>> 
>> The biggest advantage of AtomicLong will always be PORTABILITY.
>> Each platform iteration takes more years to become ubiquitous than
>> its predecessor, and that will be even more true for jdk9.
>> VarHandles are for classes that are part of the platform or that
>> value extreme performance more than portability.
>> 
>> OTOH jdk9 AtomicLong is a wrapper around VarHandle.  It's unlikely
>> to be completely free. .... oh I now see Remi has a better answer!

From jini at zeus.net.au  Tue Mar 21 00:36:11 2017
From: jini at zeus.net.au (Peter)
Date: Tue, 21 Mar 2017 14:36:11 +1000 (AEST)
Subject: [concurrency-interest] Atomic arrays and toArray(), stream(),
	iterator()
Message-ID: <eebe38645df87de798c1a5208d291352@org.tizen.email>

 
Interesting discussion about Atomic's vs VarHandles.  In practise I haven't found an Atomic causing a "hotspot" yet.

I recall some discussion about visibility issues with ByteBuffer, I'd be interested how VarHandles can be used to solve them, with consideration for native code visibility too?

Thanks,

Peter.

Sent from my Samsung device.
 
  Include original message
---- Original message ----
From: Mike Duigou <openjdk at duigou.org>
Sent: 21/03/2017 10:34:07 am
To: jbloch at gmail.com
Cc: Martin Buchholz <martinrb at google.com>; Concurrency Interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Atomic arrays and toArray(), stream(), iterator()

For the safe serial number pattern I've become pretty partial to 
variations of

final static LongSupplier serialSource = (new 
AtomicLong(0))::incrementAndGet;

sometimes with the LongSupplier itself being supplied by a framework. It 
is useful that I can safely pass around the LongSupplier while also 
delaying invocation until a value is actually needed.

Mike

On 2017-03-20 17:19, Joshua Bloch wrote:
> Yes, all of this makes sense.  Also Doug just called me, and said
> pretty much the same thing (though he he used some amusing phrase like
> "repulsively ugly incantation"). So I think we're all on the same
> page.
> 
> Josh
> 
> On Mon, Mar 20, 2017 at 4:49 PM, Martin Buchholz <martinrb at google.com>
> wrote:
> 
>> On Mon, Mar 20, 2017 at 4:24 PM, Joshua Bloch <jbloch at gmail.com>
>> wrote:
>> 
>>> Ben,
>>> 
>>> That's what I assumed, but I'll give Martin a chance to respond :)
>> 
>> I was waiting for Doug or Aleksey to respond!
>> 
>> The biggest advantage of AtomicLong will always be PORTABILITY.
>> Each platform iteration takes more years to become ubiquitous than
>> its predecessor, and that will be even more true for jdk9.
>> VarHandles are for classes that are part of the platform or that
>> value extreme performance more than portability
>> 
>> OTOH jdk9 AtomicLong is a wrapper around VarHandle.  It's unlikely
>> to be completely free. .... oh I now see Remi has a better answer!
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170321/9ca11cc8/attachment-0001.html>

From yan.gang at oracle.com  Fri Mar 24 12:22:29 2017
From: yan.gang at oracle.com (Gang Yan)
Date: Fri, 24 Mar 2017 09:22:29 -0700 (PDT)
Subject: [concurrency-interest] Question about
 java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
Message-ID: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>

 

Hi all

 

I hava a bug about Managed servers are taking too long to come up, it took 2-3hrs to come up.is on JDK 1.7.131.

 

I check server log and thread dump.This thread is waiting for some one to release something:

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 waiting on condition [0x00007fa440e81000]

   java.lang.Thread.State: WAITING (parking)

    at sun.misc.Unsafe.park(Native Method)

    - parking to wait for  <0x00000007c3cb4dd8> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)

    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:867)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1197)

    at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:945)

    at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)

    at oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.scanApplicationPolicies(PolicyChangeScanner.java:439)

    at oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.scan(PolicyChangeScanner.java:273)

    at oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner$ScanTask.run(PolicyChangeScanner.java:234)

    at oracle.security.jps.az.internal.common.scanner.PolicyChangeScannerExecutor$SchedulerTask.run(PolicyChangeScannerExecutor.java:69)

    at java.util.TimerThread.mainLoop(Timer.java:555)

    at java.util.TimerThread.run(Timer.java:505)

 

It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 in Object.wait() [0x00007fa440e81000]

   java.lang.Thread.State: TIMED_WAITING (on object monitor)

    at java.lang.Object.wait(Native Method)

    at java.util.TimerThread.mainLoop(Timer.java:552)

    - locked <0x00000007c448e018> (a java.util.TaskQueue)

    at java.util.TimerThread.run(Timer.java:505)

 

how to find out who hold on this lock ?

 

Thanks!

 

 

 

 

 

 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170324/a0d7e98f/attachment.html>

From jhump at bluegosling.com  Fri Mar 24 19:20:31 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 24 Mar 2017 19:20:31 -0400
Subject: [concurrency-interest] Question about
	java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
In-Reply-To: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
References: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
Message-ID: <CAO78j+J-YEnjiFufOnbk7_sDmp-m9vhsgN2d=P6bV3AF-5WfRg@mail.gmail.com>

IIUC, the built in lock tracking only tracks exclusive holders of a
ReadWriteLock (e.g. write lock), and not shared holders (e.g. read lock).
So the issue here looks to be that the read lock was acquired (perhaps by
multiple threads), and isn't being release. So the attempt to acquire a
write lock is wedged. Unfortunately, the annotations in the stack trace
won't show which threads have the read lock.

If you don't think there are any such tasks (e.g. threads acquiring the
read lock and then never releasing it), the problem could be barging. The
stack trace shows you are using an unfair lock (which is the default, for
performance reasons). With an unfair read lock, an attempt to acquire a
read lock will succeed if it is already read-locked -- even if there is a
writer, waiting in line for the lock (in other words, the reader "barges"
in front of the writer). So if the readers never "quiesce" (e.g. no point
in time where the number of readers reaches zero), the writer will be
starved. This could be solved by using a fair lock.



----
*Josh Humphries*
jhump at bluegosling.com

On Fri, Mar 24, 2017 at 12:22 PM, Gang Yan <yan.gang at oracle.com> wrote:

>
>
> Hi all
>
>
>
> I hava a bug about Managed servers are taking too long to come up, it took
> 2-3hrs to come up.is on JDK 1.7.131.
>
>
>
> I check server log and thread dump.This thread is waiting for some one to
> release something:
>
>
>
> "Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0
> waiting on condition [0x00007fa440e81000]
>
>    java.lang.Thread.State: WAITING (parking)
>
>     at sun.misc.Unsafe.park(Native Method)
>
>     - parking to wait for  <0x00000007c3cb4dd8> (a
> java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)
>
>     at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.
> parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.
> acquireQueued(AbstractQueuedSynchronizer.java:867)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(
> AbstractQueuedSynchronizer.java:1197)
>
>     at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(
> ReentrantReadWriteLock.java:945)
>
>     at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)
>
>     at oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.
> scanApplicationPolicies(PolicyChangeScanner.java:439)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScanner.scan(PolicyChangeScanner.java:273)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScanner$ScanTask.run(PolicyChangeScanner.java:234)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScannerExecutor$SchedulerTask.run(PolicyChangeScannerExecutor.
> java:69)
>
>     at java.util.TimerThread.mainLoop(Timer.java:555)
>
>     at java.util.TimerThread.run(Timer.java:505)
>
>
>
> It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING
>
>
>
> "Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0
> in Object.wait() [0x00007fa440e81000]
>
>    java.lang.Thread.State: TIMED_WAITING (on object monitor)
>
>     at java.lang.Object.wait(Native Method)
>
>     at java.util.TimerThread.mainLoop(Timer.java:552)
>
>     - locked <0x00000007c448e018> (a java.util.TaskQueue)
>
>     at java.util.TimerThread.run(Timer.java:505)
>
>
>
> how to find out who hold on this lock ?
>
>
>
> Thanks!
>
>
>
>
>
>
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170324/991664ad/attachment-0001.html>

From davidcholmes at aapt.net.au  Fri Mar 24 19:22:14 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 25 Mar 2017 09:22:14 +1000
Subject: [concurrency-interest] Question about
	java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
In-Reply-To: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
References: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
Message-ID: <00b101d2a4f5$79a5d6a0$6cf183e0$@aapt.net.au>

The TIMED_WAITING section is not a thread waiting for a "lock". It is the
TimerThread doing a timed Object.wait() to wait until the next task is
scheduled to be released.

 

David

 

From: Concurrency-interest
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gang Yan
Sent: Saturday, March 25, 2017 2:22 AM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Question about
java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync

 

 

Hi all

 

I hava a bug about Managed servers are taking too long to come up, it took
2-3hrs to come up.is on JDK 1.7.131.

 

I check server log and thread dump.This thread is waiting for some one to
release something:

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0
waiting on condition [0x00007fa440e81000]

   java.lang.Thread.State: WAITING (parking)

    at sun.misc.Unsafe.park(Native Method)

    - parking to wait for  <0x00000007c3cb4dd8> (a
java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)

    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)

    at
java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(
AbstractQueuedSynchronizer.java:834)

    at
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Abstract
QueuedSynchronizer.java:867)

    at
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueued
Synchronizer.java:1197)

    at
java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantRe
adWriteLock.java:945)

    at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)

    at
oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.scanAppli
cationPolicies(PolicyChangeScanner.java:439)

    at
oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.scan(Poli
cyChangeScanner.java:273)

    at
oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner$ScanTask.
run(PolicyChangeScanner.java:234)

    at
oracle.security.jps.az.internal.common.scanner.PolicyChangeScannerExecutor$S
chedulerTask.run(PolicyChangeScannerExecutor.java:69)

    at java.util.TimerThread.mainLoop(Timer.java:555)

    at java.util.TimerThread.run(Timer.java:505)

 

It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 in
Object.wait() [0x00007fa440e81000]

   java.lang.Thread.State: TIMED_WAITING (on object monitor)

    at java.lang.Object.wait(Native Method)

    at java.util.TimerThread.mainLoop(Timer.java:552)

    - locked <0x00000007c448e018> (a java.util.TaskQueue)

    at java.util.TimerThread.run(Timer.java:505)

 

how to find out who hold on this lock ?

 

Thanks!

 

 

 

 

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170325/9674746c/attachment.html>

From nathanila at gmail.com  Fri Mar 24 19:53:43 2017
From: nathanila at gmail.com (Nathan & Ila Reynolds)
Date: Fri, 24 Mar 2017 17:53:43 -0600
Subject: [concurrency-interest] Question
	about	java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
In-Reply-To: <CAO78j+J-YEnjiFufOnbk7_sDmp-m9vhsgN2d=P6bV3AF-5WfRg@mail.gmail.com>
References: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
 <CAO78j+J-YEnjiFufOnbk7_sDmp-m9vhsgN2d=P6bV3AF-5WfRg@mail.gmail.com>
Message-ID: <00be01d2a4f9$deff7020$9cfe5060$@gmail.com>

Along these lines, I recently discovered a situation where ThreadMXBean fails to detect ReentrantReadWriteLock deadlock.  It is very easy to reproduce.  I would assume that fixing this problem would make it easy to see your problem as well.

http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8176204

 

-Nathan

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Josh Humphries
Sent: Friday, March 24, 2017 5:21 PM
To: Gang Yan <yan.gang at oracle.com>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Question about java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync

 

IIUC, the built in lock tracking only tracks exclusive holders of a ReadWriteLock (e.g. write lock), and not shared holders (e.g. read lock). So the issue here looks to be that the read lock was acquired (perhaps by multiple threads), and isn't being release. So the attempt to acquire a write lock is wedged. Unfortunately, the annotations in the stack trace won't show which threads have the read lock.

 

If you don't think there are any such tasks (e.g. threads acquiring the read lock and then never releasing it), the problem could be barging. The stack trace shows you are using an unfair lock (which is the default, for performance reasons). With an unfair read lock, an attempt to acquire a read lock will succeed if it is already read-locked -- even if there is a writer, waiting in line for the lock (in other words, the reader "barges" in front of the writer). So if the readers never "quiesce" (e.g. no point in time where the number of readers reaches zero), the writer will be starved. This could be solved by using a fair lock.

 

 




----
Josh Humphries
 <mailto:jhump at bluegosling.com> jhump at bluegosling.com

 

On Fri, Mar 24, 2017 at 12:22 PM, Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com> > wrote:

 

Hi all

 

I hava a bug about Managed servers are taking too long to come up, it took 2-3hrs to come up.is <http://up.is>  on JDK 1.7.131.

 

I check server log and thread dump.This thread is waiting for some one to release something:

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 waiting on condition [0x00007fa440e81000]

   java.lang.Thread.State: WAITING (parking)

    at sun.misc.Unsafe.park(Native Method)

    - parking to wait for  <0x00000007c3cb4dd8> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)

    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:867)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1197)

    at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:945)

    at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner.scanApplicationPolicies(PolicyChangeScanner.java:439)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner.scan(PolicyChangeScanner.java:273)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner$ScanTask.run(PolicyChangeScanner.java:234)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScannerExecutor$SchedulerTask.run(PolicyChangeScannerExecutor.java:69)

    at java.util.TimerThread.mainLoop(Timer.java:555)

    at java.util.TimerThread.run(Timer.java:505)

 

It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 in Object.wait() [0x00007fa440e81000]

   java.lang.Thread.State: TIMED_WAITING (on object monitor)

    at java.lang.Object.wait(Native Method)

    at java.util.TimerThread.mainLoop(Timer.java:552)

    - locked <0x00000007c448e018> (a java.util.TaskQueue)

    at java.util.TimerThread.run(Timer.java:505)

 

how to find out who hold on this lock ?

 

Thanks!

 

 

 

 

 

 


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170324/1a1621c8/attachment-0001.html>

From jhump at bluegosling.com  Fri Mar 24 19:59:50 2017
From: jhump at bluegosling.com (Josh Humphries)
Date: Fri, 24 Mar 2017 19:59:50 -0400
Subject: [concurrency-interest] Question about
	java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
In-Reply-To: <00be01d2a4f9$deff7020$9cfe5060$@gmail.com>
References: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
 <CAO78j+J-YEnjiFufOnbk7_sDmp-m9vhsgN2d=P6bV3AF-5WfRg@mail.gmail.com>
 <00be01d2a4f9$deff7020$9cfe5060$@gmail.com>
Message-ID: <CAO78j+KvtnHdeM40Wrapazwn_smf87XVJJ4dQMSN5r2C4n9sFw@mail.gmail.com>

Yep, the fact that readers are not tracked is why it cannot find the
deadlock.

I am pretty sure that readers are not tracked because it's not free to do
so. With an exclusive lock, it's simpler because only a single thread can
hold the lock (so a single field, atomically updated, is all that is needed
to track the holder). Tracking a shared lock on the other hand, where many
threads could hold it, would require introduction of a thread-safe data
structure (which adds much more book-keeping overhead -- execution time and
garbage overhead on every acquire and release, memory overhead per lock
instance).


----
*Josh Humphries*
jhump at bluegosling.com

On Fri, Mar 24, 2017 at 7:53 PM, Nathan & Ila Reynolds <nathanila at gmail.com>
wrote:

> Along these lines, I recently discovered a situation where ThreadMXBean
> fails to detect ReentrantReadWriteLock deadlock.  It is very easy to
> reproduce.  I would assume that fixing this problem would make it easy to
> see your problem as well.
>
> http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8176204
>
>
>
> -Nathan
>
>
>
> *From:* Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu] *On Behalf Of *Josh Humphries
> *Sent:* Friday, March 24, 2017 5:21 PM
> *To:* Gang Yan <yan.gang at oracle.com>
> *Cc:* concurrency-interest <concurrency-interest at cs.oswego.edu>
> *Subject:* Re: [concurrency-interest] Question about
> java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
>
>
>
> IIUC, the built in lock tracking only tracks exclusive holders of a
> ReadWriteLock (e.g. write lock), and not shared holders (e.g. read lock).
> So the issue here looks to be that the read lock was acquired (perhaps by
> multiple threads), and isn't being release. So the attempt to acquire a
> write lock is wedged. Unfortunately, the annotations in the stack trace
> won't show which threads have the read lock.
>
>
>
> If you don't think there are any such tasks (e.g. threads acquiring the
> read lock and then never releasing it), the problem could be barging. The
> stack trace shows you are using an unfair lock (which is the default, for
> performance reasons). With an unfair read lock, an attempt to acquire a
> read lock will succeed if it is already read-locked -- even if there is a
> writer, waiting in line for the lock (in other words, the reader "barges"
> in front of the writer). So if the readers never "quiesce" (e.g. no point
> in time where the number of readers reaches zero), the writer will be
> starved. This could be solved by using a fair lock.
>
>
>
>
>
>
> ----
> *Josh Humphries*
> jhump at bluegosling.com
>
>
>
> On Fri, Mar 24, 2017 at 12:22 PM, Gang Yan <yan.gang at oracle.com> wrote:
>
>
>
> Hi all
>
>
>
> I hava a bug about Managed servers are taking too long to come up, it took
> 2-3hrs to come up.is on JDK 1.7.131.
>
>
>
> I check server log and thread dump.This thread is waiting for some one to
> release something:
>
>
>
> "Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0
> waiting on condition [0x00007fa440e81000]
>
>    java.lang.Thread.State: WAITING (parking)
>
>     at sun.misc.Unsafe.park(Native Method)
>
>     - parking to wait for  <0x00000007c3cb4dd8> (a
> java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)
>
>     at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.
> parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.
> acquireQueued(AbstractQueuedSynchronizer.java:867)
>
>     at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(
> AbstractQueuedSynchronizer.java:1197)
>
>     at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(
> ReentrantReadWriteLock.java:945)
>
>     at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)
>
>     at oracle.security.jps.az.internal.common.scanner.PolicyChangeScanner.
> scanApplicationPolicies(PolicyChangeScanner.java:439)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScanner.scan(PolicyChangeScanner.java:273)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScanner$ScanTask.run(PolicyChangeScanner.java:234)
>
>     at oracle.security.jps.az.internal.common.scanner.
> PolicyChangeScannerExecutor$SchedulerTask.run(PolicyChangeScannerExecutor.
> java:69)
>
>     at java.util.TimerThread.mainLoop(Timer.java:555)
>
>     at java.util.TimerThread.run(Timer.java:505)
>
>
>
> It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING
>
>
>
> "Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0
> in Object.wait() [0x00007fa440e81000]
>
>    java.lang.Thread.State: TIMED_WAITING (on object monitor)
>
>     at java.lang.Object.wait(Native Method)
>
>     at java.util.TimerThread.mainLoop(Timer.java:552)
>
>     - locked <0x00000007c448e018> (a java.util.TaskQueue)
>
>     at java.util.TimerThread.run(Timer.java:505)
>
>
>
> how to find out who hold on this lock ?
>
>
>
> Thanks!
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170324/b22c9092/attachment.html>

From davidcholmes at aapt.net.au  Fri Mar 24 20:35:19 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Sat, 25 Mar 2017 10:35:19 +1000
Subject: [concurrency-interest]
	Question	about	java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync
In-Reply-To: <00be01d2a4f9$deff7020$9cfe5060$@gmail.com>
References: <9f9be545-a552-4dcb-8e13-f57906f0c298@default>
 <CAO78j+J-YEnjiFufOnbk7_sDmp-m9vhsgN2d=P6bV3AF-5WfRg@mail.gmail.com>
 <00be01d2a4f9$deff7020$9cfe5060$@gmail.com>
Message-ID: <00ca01d2a4ff$ae92aeb0$0bb80c10$@aapt.net.au>

Not likely to happen Nathan. Besides in the current case there is no evidence of any deadlock – it doesn’t hang.

 

David

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Nathan & Ila Reynolds
Sent: Saturday, March 25, 2017 9:54 AM
To: 'Josh Humphries' <jhump at bluegosling.com>; 'Gang Yan' <yan.gang at oracle.com>
Cc: 'concurrency-interest' <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] Question about java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync

 

Along these lines, I recently discovered a situation where ThreadMXBean fails to detect ReentrantReadWriteLock deadlock.  It is very easy to reproduce.  I would assume that fixing this problem would make it easy to see your problem as well.

 

http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8176204

 

-Nathan

 

From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Josh Humphries
Sent: Friday, March 24, 2017 5:21 PM
To: Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com> >
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu <mailto:concurrency-interest at cs.oswego.edu> >
Subject: Re: [concurrency-interest] Question about java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync

 

IIUC, the built in lock tracking only tracks exclusive holders of a ReadWriteLock (e.g. write lock), and not shared holders (e.g. read lock). So the issue here looks to be that the read lock was acquired (perhaps by multiple threads), and isn't being release. So the attempt to acquire a write lock is wedged. Unfortunately, the annotations in the stack trace won't show which threads have the read lock.

 

If you don't think there are any such tasks (e.g. threads acquiring the read lock and then never releasing it), the problem could be barging. The stack trace shows you are using an unfair lock (which is the default, for performance reasons). With an unfair read lock, an attempt to acquire a read lock will succeed if it is already read-locked -- even if there is a writer, waiting in line for the lock (in other words, the reader "barges" in front of the writer). So if the readers never "quiesce" (e.g. no point in time where the number of readers reaches zero), the writer will be starved. This could be solved by using a fair lock.

 

 




----
Josh Humphries
 <mailto:jhump at bluegosling.com> jhump at bluegosling.com

 

On Fri, Mar 24, 2017 at 12:22 PM, Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com> > wrote:

 

Hi all

 

I hava a bug about Managed servers are taking too long to come up, it took 2-3hrs to come up.is <http://up.is>  on JDK 1.7.131.

 

I check server log and thread dump.This thread is waiting for some one to release something:

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 waiting on condition [0x00007fa440e81000]

   java.lang.Thread.State: WAITING (parking)

    at sun.misc.Unsafe.park(Native Method)

    - parking to wait for  <0x00000007c3cb4dd8> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)

    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:867)

    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1197)

    at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:945)

    at oracle.security.jps.az.common.util.JpsLock.lock(JpsLock.java:90)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner.scanApplicationPolicies(PolicyChangeScanner.java:439)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner.scan(PolicyChangeScanner.java:273)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScanner$ScanTask.run(PolicyChangeScanner.java:234)

    at oracle.security.jps.az <http://oracle.security.jps.az> .internal.common.scanner.PolicyChangeScannerExecutor$SchedulerTask.run(PolicyChangeScannerExecutor.java:69)

    at java.util.TimerThread.mainLoop(Timer.java:555)

    at java.util.TimerThread.run(Timer.java:505)

 

It is also waiting for the lock: java.lang.Thread.State: TIMED_WAITING

 

"Policy scanning timer" daemon prio=10 tid=0x00007fa3e4a7f800 nid=0x3be0 in Object.wait() [0x00007fa440e81000]

   java.lang.Thread.State: TIMED_WAITING (on object monitor)

    at java.lang.Object.wait(Native Method)

    at java.util.TimerThread.mainLoop(Timer.java:552)

    - locked <0x00000007c448e018> (a java.util.TaskQueue)

    at java.util.TimerThread.run(Timer.java:505)

 

how to find out who hold on this lock ?

 

Thanks!

 

 

 

 

 

 


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu> 
http://cs.oswego.edu/mailman/listinfo/concurrency-interest

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170325/5ba3d76e/attachment-0001.html>

From shade at redhat.com  Tue Mar 28 08:11:51 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 14:11:51 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or a
	field?
Message-ID: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>

Hi,

I need to think out loud about this, because I want to put down some jcstress
tests that assert the expected behavior.

Start with a simple test like this:

@JCStressTest
class ArrayElement {
    Object arr;

    @Actor
    public void actor1() {
        arr = new int[1];
    }

    @Actor
    public void actor2(I_Result r) {
        int[] a = arr;
        if (a != null) {
          r.r1 = a[0];
        } else {
          r.r1 = -1;
        }
    }
}

Would you say (r1) = (0) is allowed? JMM allows this, because the array is
published via the race.

Now to a little trickier example:

@JCStressTest
class ArrayClass {
    Object arr;

    @Actor
    public void actor1() {
        arr = new int[1];
    }

    @Actor
    public void actor2(Z_Result r) {
        Object a = arr;
        if (a != null) {
          r.r1 = (a.getClass() == int[].class);
        } else {
          r.r1 = true;
        }
    }
}

...would you say (r1) = (false) is allowed?

The spec is murky at this point, because you don't know what getClass() invoke
sequence is doing, and what getClass() does inside. At least in Hotspot, the
invocation reads the klassptr from the object to figure out the vtbl to call the
method off, and then getClass() itself returns the Java mirror of that klassptr.
Machine-wise it is reading at the object offset, like a regular field access does.

So it should be false,  otherwise the call to getClass would probably crash the
JVM, trying to call the virtual method off the broken vtbl pointer. We can say
that object metadata is so important for JVM that it protects it from the races.
(This is one of the reasons why final-by-default mechanics can be cheap: we
"only" need to extend those guarantees to all field writes, not only the header)

Now, a trickiest question of all: what about array.length?

E.g.:

@JCStressTest
class ArrayLength {
    Object arr;

    @Actor
    public void actor1() {
        arr = new int[1];
    }

    @Actor
    public void actor2(I_Result r) {
        Object a = arr;
        if (a != null) {
          r.r1 = ((int[])a).length;
        } else {
          r.r1 = -1;
        }
    }
}

Would you say the result (r1) = (0) is plausible? In other words, do we expect
the arraylength to act like a field (thus allowing 0), or act like a metadata
(thus disallowing 0)?

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/47616bfc/attachment.sig>

From shade at redhat.com  Tue Mar 28 08:16:58 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 14:16:58 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
Message-ID: <19f0ad71-bec2-f6f3-00a6-fb470e4fc717@redhat.com>

On 03/28/2017 02:11 PM, Aleksey Shipilev wrote:
> Start with a simple test like this:
> 
> @JCStressTest
> class ArrayElement {
>     Object arr;
> 
>     @Actor
>     public void actor1() {
>         arr = new int[1];
>     }
> 
>     @Actor
>     public void actor2(I_Result r) {
>         int[] a = arr;
>         if (a != null) {
>           r.r1 = a[0];
>         } else {
>           r.r1 = -1;
>         }
>     }
> }
> 
> Would you say (r1) = (0) is allowed? JMM allows this, because the array is
> published via the race.

Yes, actor1() should also do arr[0] = 1, but you know what I mean.

-Aleksey


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/87a8a7fe/attachment.sig>

From oleksandr.otenko at gmail.com  Tue Mar 28 08:23:37 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 28 Mar 2017 13:23:37 +0100
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
Message-ID: <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>

Object class and array length should behave like a final: once you observe the object, you should never observe the class or length change.

Alex

> On 28 Mar 2017, at 13:11, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> Hi,
> 
> I need to think out loud about this, because I want to put down some jcstress
> tests that assert the expected behavior.
> 
> Start with a simple test like this:
> 
> @JCStressTest
> class ArrayElement {
>    Object arr;
> 
>    @Actor
>    public void actor1() {
>        arr = new int[1];
>    }
> 
>    @Actor
>    public void actor2(I_Result r) {
>        int[] a = arr;
>        if (a != null) {
>          r.r1 = a[0];
>        } else {
>          r.r1 = -1;
>        }
>    }
> }
> 
> Would you say (r1) = (0) is allowed? JMM allows this, because the array is
> published via the race.
> 
> Now to a little trickier example:
> 
> @JCStressTest
> class ArrayClass {
>    Object arr;
> 
>    @Actor
>    public void actor1() {
>        arr = new int[1];
>    }
> 
>    @Actor
>    public void actor2(Z_Result r) {
>        Object a = arr;
>        if (a != null) {
>          r.r1 = (a.getClass() == int[].class);
>        } else {
>          r.r1 = true;
>        }
>    }
> }
> 
> ...would you say (r1) = (false) is allowed?
> 
> The spec is murky at this point, because you don't know what getClass() invoke
> sequence is doing, and what getClass() does inside. At least in Hotspot, the
> invocation reads the klassptr from the object to figure out the vtbl to call the
> method off, and then getClass() itself returns the Java mirror of that klassptr.
> Machine-wise it is reading at the object offset, like a regular field access does.
> 
> So it should be false,  otherwise the call to getClass would probably crash the
> JVM, trying to call the virtual method off the broken vtbl pointer. We can say
> that object metadata is so important for JVM that it protects it from the races.
> (This is one of the reasons why final-by-default mechanics can be cheap: we
> "only" need to extend those guarantees to all field writes, not only the header)
> 
> Now, a trickiest question of all: what about array.length?
> 
> E.g.:
> 
> @JCStressTest
> class ArrayLength {
>    Object arr;
> 
>    @Actor
>    public void actor1() {
>        arr = new int[1];
>    }
> 
>    @Actor
>    public void actor2(I_Result r) {
>        Object a = arr;
>        if (a != null) {
>          r.r1 = ((int[])a).length;
>        } else {
>          r.r1 = -1;
>        }
>    }
> }
> 
> Would you say the result (r1) = (0) is plausible? In other words, do we expect
> the arraylength to act like a field (thus allowing 0), or act like a metadata
> (thus disallowing 0)?
> 
> Thanks,
> -Aleksey
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From viktor.klang at gmail.com  Tue Mar 28 08:24:56 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 28 Mar 2017 14:24:56 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <19f0ad71-bec2-f6f3-00a6-fb470e4fc717@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <19f0ad71-bec2-f6f3-00a6-fb470e4fc717@redhat.com>
Message-ID: <CANPzfU_O+vuStC5v_GQETJXmeshZHKw8nEMc5y+dEBJhCcJvDA@mail.gmail.com>

I would say 0 is allowed.

-- 
Cheers,
√

On Mar 28, 2017 2:21 PM, "Aleksey Shipilev" <shade at redhat.com> wrote:

> On 03/28/2017 02:11 PM, Aleksey Shipilev wrote:
> > Start with a simple test like this:
> >
> > @JCStressTest
> > class ArrayElement {
> >     Object arr;
> >
> >     @Actor
> >     public void actor1() {
> >         arr = new int[1];
> >     }
> >
> >     @Actor
> >     public void actor2(I_Result r) {
> >         int[] a = arr;
> >         if (a != null) {
> >           r.r1 = a[0];
> >         } else {
> >           r.r1 = -1;
> >         }
> >     }
> > }
> >
> > Would you say (r1) = (0) is allowed? JMM allows this, because the array
> is
> > published via the race.
>
> Yes, actor1() should also do arr[0] = 1, but you know what I mean.
>
> -Aleksey
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/cb114dd2/attachment.html>

From shade at redhat.com  Tue Mar 28 08:26:04 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 14:26:04 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <CANPzfU_O+vuStC5v_GQETJXmeshZHKw8nEMc5y+dEBJhCcJvDA@mail.gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <19f0ad71-bec2-f6f3-00a6-fb470e4fc717@redhat.com>
 <CANPzfU_O+vuStC5v_GQETJXmeshZHKw8nEMc5y+dEBJhCcJvDA@mail.gmail.com>
Message-ID: <4146f96d-badd-23a9-e712-32f58ff3763a@redhat.com>

For array length? See the ArrayLength example, not ArrayElement.
I agree "0" is allowed in ArrayElement.

-Aleksey

On 03/28/2017 02:24 PM, Viktor Klang wrote:
> I would say 0 is allowed.
> 
> -- 
> Cheers,
> √
> 
> On Mar 28, 2017 2:21 PM, "Aleksey Shipilev" <shade at redhat.com
> <mailto:shade at redhat.com>> wrote:
> 
>     On 03/28/2017 02:11 PM, Aleksey Shipilev wrote:
>     > Start with a simple test like this:
>     >
>     > @JCStressTest
>     > class ArrayElement {
>     >     Object arr;
>     >
>     >     @Actor
>     >     public void actor1() {
>     >         arr = new int[1];
>     >     }
>     >
>     >     @Actor
>     >     public void actor2(I_Result r) {
>     >         int[] a = arr;
>     >         if (a != null) {
>     >           r.r1 = a[0];
>     >         } else {
>     >           r.r1 = -1;
>     >         }
>     >     }
>     > }
>     >
>     > Would you say (r1) = (0) is allowed? JMM allows this, because the array is
>     > published via the race.
> 
>     Yes, actor1() should also do arr[0] = 1, but you know what I mean.
> 
>     -Aleksey
> 
> 
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/837f58f9/attachment-0001.sig>

From shade at redhat.com  Tue Mar 28 08:33:30 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 14:33:30 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
Message-ID: <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>

On 03/28/2017 02:23 PM, Alex Otenko wrote:
> Object class and array length should behave like a final: once you observe
> the object, you should never observe the class or length change.

Let me play Devil's Advocate here.

"Should" reads as something that is guaranteed by spec, right? I cannot find
anything in the spec text that requires reading object class or array length
consistently.

I can whip up the argument that non-visible object class in a racy access is the
recipe for JVM crash, and so it should be protected in practical
implementations. I cannot stretch that argument to arraylength, because 0 length
does not look something that leads to VM crash. Is there a practical argument
for protecting arraylength -- which shows that failing to do this we have a
serious problem?

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/9bf52f2a/attachment.sig>

From valentin.male.kovalenko at gmail.com  Tue Mar 28 08:44:03 2017
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Tue, 28 Mar 2017 15:44:03 +0300
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 146,
	Issue 19
Message-ID: <CAO-wXwKTZgGW9c8yaLi9BF58KnpwUitYBTBTJH4yL6AtZ0=2EA@mail.gmail.com>

> @JCStressTest
> class ArrayLength {
>     Object arr;
>
>     @Actor
>     public void actor1() {
>         arr = new int[1];
>     }
>
>     @Actor
>     public void actor2(I_Result r) {
>         Object a = arr;
>         if (a != null) {
>           r.r1 = ((int[])a).length;
>         } else {
>           r.r1 = -1;
>         }
>     }
> }
>
> Would you say the result (r1) = (0) is plausible? In other words, do we
expect
> the arraylength to act like a field (thus allowing 0), or act like a
metadata
> (thus disallowing 0)?

Alexey,
this is actually covered in JLS 17.4.5. Happens-before Order
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5>:
"*The semantics of operations other than inter-thread actions, such as
reads of array lengths (§10.7
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.7>),
executions of checked casts (§5.5
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.5>, §15.16
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16>),
and invocations of virtual methods (§15.12
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12>),
are not directly affected by data races.*"
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/07ee4021/attachment.html>

From viktor.klang at gmail.com  Tue Mar 28 08:44:56 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 28 Mar 2017 14:44:56 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
Message-ID: <CANPzfU_qjghA5v5U-e6=mRhJrKmx4fiibfboOVbG6r5cesBMTA@mail.gmail.com>

For ArrayLength:

If nothing else, if length is the only "technical" field in an array, and
it is final, there ought to be a store-barrier at the end of its
"constructor"?

For ArrayClass I'd answer the same as the answer above.

Would be intrigued to learn I was wrong tho.

-- 
Cheers,
√

On Mar 28, 2017 2:39 PM, "Aleksey Shipilev" <shade at redhat.com> wrote:

On 03/28/2017 02:23 PM, Alex Otenko wrote:
> Object class and array length should behave like a final: once you observe
> the object, you should never observe the class or length change.

Let me play Devil's Advocate here.

"Should" reads as something that is guaranteed by spec, right? I cannot find
anything in the spec text that requires reading object class or array length
consistently.

I can whip up the argument that non-visible object class in a racy access
is the
recipe for JVM crash, and so it should be protected in practical
implementations. I cannot stretch that argument to arraylength, because 0
length
does not look something that leads to VM crash. Is there a practical
argument
for protecting arraylength -- which shows that failing to do this we have a
serious problem?

-Aleksey


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/a0493336/attachment.html>

From valentin.male.kovalenko at gmail.com  Tue Mar 28 08:46:41 2017
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Tue, 28 Mar 2017 15:46:41 +0300
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 146,
	Issue 19
In-Reply-To: <CAO-wXwKTZgGW9c8yaLi9BF58KnpwUitYBTBTJH4yL6AtZ0=2EA@mail.gmail.com>
References: <CAO-wXwKTZgGW9c8yaLi9BF58KnpwUitYBTBTJH4yL6AtZ0=2EA@mail.gmail.com>
Message-ID: <CAO-wXwKs7-E+-OYR9COO91Sp1aPm71KN2GPNYsPs3kNHr3pyyw@mail.gmail.com>

Sorry, the full quote is: "*The semantics of operations other than
inter-thread actions, such as reads of array lengths (§10.7
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.7>),
executions of checked casts (§5.5
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.5>, §15.16
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16>),
and invocations of virtual methods (§15.12
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12>),
are not directly affected by data races. **Therefore, a data race cannot
cause incorrect behavior such as returning the wrong length for an array*."

On Tue, Mar 28, 2017 at 3:44 PM, Valentin Kovalenko <
valentin.male.kovalenko at gmail.com> wrote:

> > @JCStressTest
> > class ArrayLength {
> >     Object arr;
> >
> >     @Actor
> >     public void actor1() {
> >         arr = new int[1];
> >     }
> >
> >     @Actor
> >     public void actor2(I_Result r) {
> >         Object a = arr;
> >         if (a != null) {
> >           r.r1 = ((int[])a).length;
> >         } else {
> >           r.r1 = -1;
> >         }
> >     }
> > }
> >
> > Would you say the result (r1) = (0) is plausible? In other words, do we
> expect
> > the arraylength to act like a field (thus allowing 0), or act like a
> metadata
> > (thus disallowing 0)?
>
> Alexey,
> this is actually covered in JLS 17.4.5. Happens-before Order
> <https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5>:
> "*The semantics of operations other than inter-thread actions, such as
> reads of array lengths (§10.7
> <https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.7>),
> executions of checked casts (§5.5
> <https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.5>, §15.16
> <https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16>),
> and invocations of virtual methods (§15.12
> <https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12>),
> are not directly affected by data races.*"
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/7da590eb/attachment-0001.html>

From viktor.klang at gmail.com  Tue Mar 28 08:49:19 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Tue, 28 Mar 2017 14:49:19 +0200
Subject: [concurrency-interest] Concurrency-interest Digest, Vol 146,
 Issue 19
In-Reply-To: <CANPzfU8uExn+=AFW4gj4ryBV3kY_weeterGms83CL3NizDe45Q@mail.gmail.com>
References: <CAO-wXwKTZgGW9c8yaLi9BF58KnpwUitYBTBTJH4yL6AtZ0=2EA@mail.gmail.com>
 <CANPzfU8uExn+=AFW4gj4ryBV3kY_weeterGms83CL3NizDe45Q@mail.gmail.com>
Message-ID: <CANPzfU_7xBWVCASR2tM_HNqLeFZvCr2Oxoae7jxVJ65k593S_Q@mail.gmail.com>

"directly affected" ;-)

-- 
Cheers,
√

On Mar 28, 2017 2:47 PM, "Valentin Kovalenko" <
valentin.male.kovalenko at gmail.com> wrote:

> @JCStressTest
> class ArrayLength {
>     Object arr;
>
>     @Actor
>     public void actor1() {
>         arr = new int[1];
>     }
>
>     @Actor
>     public void actor2(I_Result r) {
>         Object a = arr;
>         if (a != null) {
>           r.r1 = ((int[])a).length;
>         } else {
>           r.r1 = -1;
>         }
>     }
> }
>
> Would you say the result (r1) = (0) is plausible? In other words, do we
expect
> the arraylength to act like a field (thus allowing 0), or act like a
metadata
> (thus disallowing 0)?

Alexey,
this is actually covered in JLS 17.4.5. Happens-before Order
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5>:
"*The semantics of operations other than inter-thread actions, such as
reads of array lengths (§10.7
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.7>),
executions of checked casts (§5.5
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.5>, §15.16
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16>),
and invocations of virtual methods (§15.12
<https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12>),
are not directly affected by data races.*"

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/fc104d11/attachment.html>

From oleksandr.otenko at gmail.com  Tue Mar 28 08:59:04 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 28 Mar 2017 13:59:04 +0100
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
Message-ID: <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>

Object class and array length are fixed by language spec, so observing different values violates language semantics. No one codes expecting object class or array length to change, like no one codes expecting String.charAt return different results for the same index.


Alex


> On 28 Mar 2017, at 13:33, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 03/28/2017 02:23 PM, Alex Otenko wrote:
>> Object class and array length should behave like a final: once you observe
>> the object, you should never observe the class or length change.
> 
> Let me play Devil's Advocate here.
> 
> "Should" reads as something that is guaranteed by spec, right? I cannot find
> anything in the spec text that requires reading object class or array length
> consistently.
> 
> I can whip up the argument that non-visible object class in a racy access is the
> recipe for JVM crash, and so it should be protected in practical
> implementations. I cannot stretch that argument to arraylength, because 0 length
> does not look something that leads to VM crash. Is there a practical argument
> for protecting arraylength -- which shows that failing to do this we have a
> serious problem?
> 
> -Aleksey
> 


From davidcholmes at aapt.net.au  Tue Mar 28 09:02:48 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 28 Mar 2017 23:02:48 +1000
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
Message-ID: <01c301d2a7c3$99f53150$cddf93f0$@aapt.net.au>

> -----Original Message-----
> From: Concurrency-interest [mailto:concurrency-interest-
> bounces at cs.oswego.edu] On Behalf Of Aleksey Shipilev
> Sent: Tuesday, March 28, 2017 10:34 PM
> To: Alex Otenko <oleksandr.otenko at gmail.com>
> Cc: Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Array length: behaves like a metadata
or
> a field?
> 
> On 03/28/2017 02:23 PM, Alex Otenko wrote:
> > Object class and array length should behave like a final: once you
observe
> > the object, you should never observe the class or length change.
> 
> Let me play Devil's Advocate here.
> 
> "Should" reads as something that is guaranteed by spec, right? I cannot
find
> anything in the spec text that requires reading object class or array
length
> consistently.

As others have pointed out the array length is treated as a final field.

For getClass() it returns the Class object of which the target is an
instance. There is no "best effort" here, it can't fail and it can't produce
an arbitrary value "out of thin air".

David
------------
 
> I can whip up the argument that non-visible object class in a racy access
is the
> recipe for JVM crash, and so it should be protected in practical
> implementations. I cannot stretch that argument to arraylength, because 0
> length
> does not look something that leads to VM crash. Is there a practical
argument
> for protecting arraylength -- which shows that failing to do this we have
a
> serious problem?
> 
> -Aleksey



From oleksandr.otenko at gmail.com  Tue Mar 28 09:06:43 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Tue, 28 Mar 2017 14:06:43 +0100
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
Message-ID: <6E7005AA-A95C-46C5-9866-666240494497@gmail.com>

Devil’s Prosecutor: is it allowed for array.class to be java.lang.Object then? Would that crash the JVM? Why? Is it because the JVM expected it to be an array? :)

Alex

> On 28 Mar 2017, at 13:33, Aleksey Shipilev <shade at redhat.com> wrote:
> 
> On 03/28/2017 02:23 PM, Alex Otenko wrote:
>> Object class and array length should behave like a final: once you observe
>> the object, you should never observe the class or length change.
> 
> Let me play Devil's Advocate here.
> 
> "Should" reads as something that is guaranteed by spec, right? I cannot find
> anything in the spec text that requires reading object class or array length
> consistently.
> 
> I can whip up the argument that non-visible object class in a racy access is the
> recipe for JVM crash, and so it should be protected in practical
> implementations. I cannot stretch that argument to arraylength, because 0 length
> does not look something that leads to VM crash. Is there a practical argument
> for protecting arraylength -- which shows that failing to do this we have a
> serious problem?
> 
> -Aleksey
> 


From shade at redhat.com  Tue Mar 28 09:20:05 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 15:20:05 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
Message-ID: <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>

On 03/28/2017 02:59 PM, Alex Otenko wrote:
> Object class and array length are fixed by language spec, so observing 
> different values violates language semantics.

Oh, that's the way out: with plain fields, we have a default initialization that
you can observe under the race, but for object class and array length there is
no such "zero" init.

In other words, memory model rules govern what is visible across threads, and
the rest of language spec defines what is the value domain of the observable
values. For metadata there is no "default" values to see.

> No one codes expecting object class or array length to change, like no one
> codes expecting String.charAt return different results for the same index.

What users expect is not something that is guaranteed :)

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/9384ef4e/attachment-0001.sig>

From shade at redhat.com  Tue Mar 28 09:26:32 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 15:26:32 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <01c301d2a7c3$99f53150$cddf93f0$@aapt.net.au>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <01c301d2a7c3$99f53150$cddf93f0$@aapt.net.au>
Message-ID: <a33c2872-0e00-8a46-7874-a8308b099954@redhat.com>

On 03/28/2017 03:02 PM, David Holmes wrote:
> As others have pointed out the array length is treated as a final field.

I was struggling to find how specification guarantees that. "No default init for
array length" seems to be the answer.

> For getClass() it returns the Class object of which the target is an
> instance. There is no "best effort" here, it can't fail and it can't produce
> an arbitrary value "out of thin air".

Yes. Except that for getClass() virtual call you can _theoretically_ fail when
performing the invocation if klassptr is broken, thus the getClass() internals
are irrelevant. This was my argument for ArrayClass case: you need klassptr to
perform virtual calls.

I realized that there is a similar arraylength argument: without it, the array
published under the race would set up GC which can try to copy it for heap
corruption and eventual crash.

Thanks,
-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/186334ac/attachment.sig>

From shade at redhat.com  Tue Mar 28 09:38:59 2017
From: shade at redhat.com (Aleksey Shipilev)
Date: Tue, 28 Mar 2017 15:38:59 +0200
Subject: [concurrency-interest] Array length: behaves like a metadata or
 a field?
In-Reply-To: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
Message-ID: <59084d01-95e1-eb9e-429c-c57ec4e217b7@redhat.com>

On 03/28/2017 02:11 PM, Aleksey Shipilev wrote:
> @JCStressTest
> class ArrayLength {
>     Object arr;
> 
>     @Actor
>     public void actor1() {
>         arr = new int[1];
>     }
> 
>     @Actor
>     public void actor2(I_Result r) {
>         Object a = arr;
>         if (a != null) {
>           r.r1 = ((int[])a).length;
>         } else {
>           r.r1 = -1;
>         }
>     }
> }
> 
> Would you say the result (r1) = (0) is plausible? In other words, do we expect
> the arraylength to act like a field (thus allowing 0), or act like a metadata
> (thus disallowing 0)?

Valentin Kovalenko gives the link to authoritative answer to this:

"The semantics of operations other than inter-thread actions, such as reads of
array lengths (§10.7), executions of checked casts (§5.5, §15.16), and
invocations of virtual methods (§15.12), are not directly affected by data
races. Therefore, a data race cannot cause incorrect behavior such as returning
the wrong length for an array."
 https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5

So the arraylength cannot be observed inconsistently.

Silly me, I paged out that part of the spec from my head.

-Aleksey

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170328/6c36255d/attachment.sig>

From nathanila at gmail.com  Tue Mar 28 11:14:12 2017
From: nathanila at gmail.com (Nathan & Ila Reynolds)
Date: Tue, 28 Mar 2017 09:14:12 -0600
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <59084d01-95e1-eb9e-429c-c57ec4e217b7@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <59084d01-95e1-eb9e-429c-c57ec4e217b7@redhat.com>
Message-ID: <084901d2a7d5$f611ccc0$e2356640$@gmail.com>

Perhaps this is a concern but perhaps GC is well protected.  The GC threads have to see the proper array length and object type.  As pointed out earlier, if GC does not see the proper array length, then heap corruption will happen.  If GC does not see the proper object type, then references will be missed and objects may be prematurely collected.

-Nathan

-----Original Message-----
From: Concurrency-interest [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Aleksey Shipilev
Sent: Tuesday, March 28, 2017 7:39 AM
To: Concurrency-interest at cs.oswego.edu; Valentin Kovalenko <valentin.male.kovalenko at gmail.com>
Subject: Re: [concurrency-interest] Array length: behaves like a metadata or a field?

On 03/28/2017 02:11 PM, Aleksey Shipilev wrote:
> @JCStressTest
> class ArrayLength {
>     Object arr;
> 
>     @Actor
>     public void actor1() {
>         arr = new int[1];
>     }
> 
>     @Actor
>     public void actor2(I_Result r) {
>         Object a = arr;
>         if (a != null) {
>           r.r1 = ((int[])a).length;
>         } else {
>           r.r1 = -1;
>         }
>     }
> }
> 
> Would you say the result (r1) = (0) is plausible? In other words, do 
> we expect the arraylength to act like a field (thus allowing 0), or 
> act like a metadata (thus disallowing 0)?

Valentin Kovalenko gives the link to authoritative answer to this:

"The semantics of operations other than inter-thread actions, such as reads of array lengths (§10.7), executions of checked casts (§5.5, §15.16), and invocations of virtual methods (§15.12), are not directly affected by data races. Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array."
 https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5

So the arraylength cannot be observed inconsistently.

Silly me, I paged out that part of the spec from my head.

-Aleksey



From davidcholmes at aapt.net.au  Tue Mar 28 17:33:13 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 29 Mar 2017 07:33:13 +1000
Subject: [concurrency-interest] Array length: behaves like a metadata or
	a field?
In-Reply-To: <a33c2872-0e00-8a46-7874-a8308b099954@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <01c301d2a7c3$99f53150$cddf93f0$@aapt.net.au>
 <a33c2872-0e00-8a46-7874-a8308b099954@redhat.com>
Message-ID: <01ef01d2a80a$e7cdf6e0$b769e4a0$@aapt.net.au>

> Aleksey Shipilev writes:
> On 03/28/2017 03:02 PM, David Holmes wrote:
> > As others have pointed out the array length is treated as a final field.
> 
> I was struggling to find how specification guarantees that. "No default
init for
> array length" seems to be the answer.

JLS 10.7 states it is a final field. Default init doesn't come into it
because you can't publish an array in the middle of construction.
 
> > For getClass() it returns the Class object of which the target is an
> > instance. There is no "best effort" here, it can't fail and it can't
produce
> > an arbitrary value "out of thin air".
> 
> Yes. Except that for getClass() virtual call you can _theoretically_ fail
when
> performing the invocation if klassptr is broken, thus the getClass()
internals
> are irrelevant. This was my argument for ArrayClass case: you need
klassptr
> to
> perform virtual calls.

If the getClass() implementation is broken that is  a bug. The behavioural
specification of getClass() is quite clear. It is up to the implementors to
realize what they need to do to ensure that in a concurrent world.

Cheers,
David

 
> I realized that there is a similar arraylength argument: without it, the
array
> published under the race would set up GC which can try to copy it for heap
> corruption and eventual crash.
> 
> Thanks,
> -Aleksey



From yan.gang at oracle.com  Thu Mar 30 01:28:46 2017
From: yan.gang at oracle.com (Gang Yan)
Date: Wed, 29 Mar 2017 22:28:46 -0700 (PDT)
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
Message-ID: <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>

Hi all:

I have a problem:

75 threads wait same lock, but not found hold lock thread from thread dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect performance. How to find out who hold lock ?

"[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked, daemon
         -- Parking to wait for: java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d730
         at jrockit/vm/Locks.park0(J)V(Native Method)
         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
         at java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
         at oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
         at jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
         at jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimized]
         at oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
         at oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
         at oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectResolver.java:216)
         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.java:123)
         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113)
         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
         at com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)
         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
        at weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInterceptor.java:42)
         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
         at com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
         at com/bea/core/repackaged/springframework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[optimized]
         at weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.java:230)
         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined]
         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
         at weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146)[inlined]
         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:523)[inlined]
         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)

From oleksandr.otenko at gmail.com  Thu Mar 30 03:18:41 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 30 Mar 2017 08:18:41 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
Message-ID: <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>

The holder may have moved on. Watch for stack overflows in history. When hard errors occur, the behaviour of the JVM is not guaranteed, and stack unwinding can miss finally statements, thus miss lock releases.

Alex

> On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
> 
> Hi all:
> 
> I have a problem:
> 
> 75 threads wait same lock, but not found hold lock thread from thread dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect performance. How to find out who hold lock ?
> 
> "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked, daemon
>         -- Parking to wait for: java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d730
>         at jrockit/vm/Locks.park0(J)V(Native Method)
>         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
>         at java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
>         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
>         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
>         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
>         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
>         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
>         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
>         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
>         at oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
>         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
>         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
>         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
>         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
>         at jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
>         at jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimized]
>         at oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
>         at oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
>         at oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
>         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
>         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectResolver.java:216)
>         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
>         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.java:123)
>         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113)
>         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
>         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
>         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>         at com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)
>         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
>         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
>        at weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
>         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInterceptor.java:42)
>         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>         at com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
>         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>         at com/bea/core/repackaged/springframework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
>         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
>         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
>         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
>         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[optimized]
>         at weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.java:230)
>         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined]
>         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
>         at weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146)[inlined]
>         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:523)[inlined]
>         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
>         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
>         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
>         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From viktor.klang at gmail.com  Thu Mar 30 04:08:32 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 30 Mar 2017 10:08:32 +0200
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
Message-ID: <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>

IMO, Errors which may leave the JVM in an inconsistent state should always
crash the JVM hard.

On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> The holder may have moved on. Watch for stack overflows in history. When
> hard errors occur, the behaviour of the JVM is not guaranteed, and stack
> unwinding can miss finally statements, thus miss lock releases.
>
> Alex
>
> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
> >
> > Hi all:
> >
> > I have a problem:
> >
> > 75 threads wait same lock, but not found hold lock thread from thread
> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect
> performance. How to find out who hold lock ?
> >
> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default
> (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked,
> native_blocked, daemon
> >         -- Parking to wait for: java/util/concurrent/locks/
> ReentrantReadWriteLock$NonfairSync at 0x8646d730
> >         at jrockit/vm/Locks.park0(J)V(Native Method)
> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
> >         at java/util/concurrent/locks/LockSupport.park(LockSupport.
> java:156)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.
> parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.
> doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.
> acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
> >         at java/util/concurrent/locks/ReentrantReadWriteLock$
> ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.
> java:81)
> >         at oracle/security/jps/az/internal/runtime/service/
> PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
> >         at oracle/security/jps/az/internal/runtime/service/
> PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.
> getGrantedAppRoles(PolicyUtil.java:3042)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.
> getJpsAppRoles(PolicyUtil.java:1977)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.
> getJpsAppRoles(PolicyUtil.java:1922)
> >         at oracle/security/jps/internal/core/util/
> SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
> >         at oracle/security/jps/internal/core/util/
> SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
> >         at jrockit/vm/AccessController.doPrivileged(AccessController.
> java:254)[inlined]
> >         at jrockit/vm/AccessController.doPrivileged(AccessController.
> java:268)[optimized]
> >         at oracle/security/jps/internal/core/util/
> SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
> >         at oracle/security/jps/internal/core/util/
> SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
> >         at oracle/security/jps/internal/core/util/
> SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:
> 207)
> >         at oracle/security/jps/az/internal/runtime/service/
> PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.
> resolveJpsSubject(JpsAbsSubjectResolver.java:216)
> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.
> resolveSubject(JpsAbsSubjectResolver.java:175)
> >         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(
> JpsAbsInterceptor.java:123)
> >         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(
> JpsInterceptor.java:113)
> >         at sun/reflect/GeneratedMethodAccessor1293.
> invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown
> Source)
> >         at sun/reflect/DelegatingMethodAccessorImpl.invoke(
> DelegatingMethodAccessorImpl.java:25)[optimized]
> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
> >         at com/bea/core/repackaged/springframework/aop/support/AopUtils.
> invokeJoinpointUsingReflection(AopUtils.java:310)
> >         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.
> invoke(JeeInterceptorInterceptor.java:68)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/support/
> DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionIntercep
> tor.java:131)
> >         at com/bea/core/repackaged/springframework/aop/support/
> DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionIntercep
> tor.java:119)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(
> MethodInvocationVisitorImpl.java:34)
> >        at weblogic/ejb/container/injection/
> EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallback
> Impl.java:54)
> >         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(
> EnvironmentInterceptor.java:42)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/interceptor/
> ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/support/
> DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionIntercep
> tor.java:131)
> >         at com/bea/core/repackaged/springframework/aop/support/
> DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionIntercep
> tor.java:119)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/framework/
> JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
> >         at com/sun/proxy/$Proxy344.destroyWorkflowContext(
> Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown
> Source)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_
> oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/
> Object;I)Ljava/lang/Object;(Unknown Source)
> >         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.
> invoke(SessionRemoteMethodInvoker.java:40)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_
> oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/
> workflow/verification/IWorkflowContext;)V(Unknown Source)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_
> oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/
> InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/
> lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
> >         at weblogic/rmi/internal/BasicServerRef.invoke(
> BasicServerRef.java:674)[optimized]
> >         at weblogic/rmi/cluster/ClusterableServerRef.invoke(
> ClusterableServerRef.java:230)
> >         at weblogic/rmi/internal/BasicServerRef$1.run(
> BasicServerRef.java:526)[inlined]
> >         at weblogic/security/acl/internal/AuthenticatedSubject.
> doAs(AuthenticatedSubject.java:363)[inlined]
> >         at weblogic/security/service/SecurityManager.runAs(
> SecurityManager.java:146)[inlined]
> >         at weblogic/rmi/internal/BasicServerRef.handleRequest(
> BasicServerRef.java:523)[inlined]
> >         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(
> WLSExecuteRequest.java:118)[optimized]
> >         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:
> 268)[optimized]
> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/e68418e6/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Mar 30 04:33:48 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 30 Mar 2017 09:33:48 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
Message-ID: <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>

JVM spec allows for undefined behaviour. They don’t have to throw SOE or OOME. People shouldn’t catch all Throwables, if they want JVM to crash.


Alex


> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> IMO, Errors which may leave the JVM in an inconsistent state should always crash the JVM hard.
> 
> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> The holder may have moved on. Watch for stack overflows in history. When hard errors occur, the behaviour of the JVM is not guaranteed, and stack unwinding can miss finally statements, thus miss lock releases.
> 
> Alex
> 
> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com>> wrote:
> >
> > Hi all:
> >
> > I have a problem:
> >
> > 75 threads wait same lock, but not found hold lock thread from thread dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect performance. How to find out who hold lock ?
> >
> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked, daemon
> >         -- Parking to wait for: java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d730
> >         at jrockit/vm/Locks.park0(J)V(Native Method)
> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
> >         at java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
> >         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimized]
> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
> >         at oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectResolver.java:216)
> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
> >         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.java:123)
> >         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113)
> >         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
> >         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
> >         at com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)
> >         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
> >        at weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
> >         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInterceptor.java:42)
> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at com/bea/core/repackaged/springframework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
> >         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
> >         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
> >         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[optimized]
> >         at weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.java:230)
> >         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined]
> >         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
> >         at weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146)[inlined]
> >         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:523)[inlined]
> >         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
> >         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
> 
> 
> 
> -- 
> Cheers,
> √

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/8e47e73a/attachment-0001.html>

From viktor.klang at gmail.com  Thu Mar 30 04:41:40 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 30 Mar 2017 10:41:40 +0200
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
 <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
Message-ID: <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>

On Thu, Mar 30, 2017 at 10:33 AM, Alex Otenko <oleksandr.otenko at gmail.com>
wrote:

> JVM spec allows for undefined behaviour.
>

Yes—otherwise there wouldn't be a need to crash it ;-)


> They don’t have to throw SOE or OOME.
>

Agreed:
http://www.scala-lang.org/api/current/scala/util/control/NonFatal$.html


> People shouldn’t catch all Throwables, if they want JVM to crash.
>

Absolutely agreed—problem is that they do. All over the place. OOMEs and
SOEs can be thrown virtually everywhere, which means that if they are
triggered under a "catch( Throwable t) { /* yolo */ }" the JVM will keep on
chugging along but with unknown internal damage.

Personally, I love this part of the java.lang.Error javadoc:

«An Error is a subclass of Throwable that indicates serious problems that a
reasonable application should not try to catch.»

With 20/20 hindsight, perhaps *catch* should operate, not on *Throwable* but
rather on *Catchable*—and some *Throwable*s should never have been
*Catchable*.


>
> Alex
>
>
> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> IMO, Errors which may leave the JVM in an inconsistent state should always
> crash the JVM hard.
>
> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com>
> wrote:
>
>> The holder may have moved on. Watch for stack overflows in history. When
>> hard errors occur, the behaviour of the JVM is not guaranteed, and stack
>> unwinding can miss finally statements, thus miss lock releases.
>>
>> Alex
>>
>> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
>> >
>> > Hi all:
>> >
>> > I have a problem:
>> >
>> > 75 threads wait same lock, but not found hold lock thread from thread
>> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect
>> performance. How to find out who hold lock ?
>> >
>> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default
>> (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked,
>> native_blocked, daemon
>> >         -- Parking to wait for: java/util/concurrent/locks/Ree
>> ntrantReadWriteLock$NonfairSync at 0x8646d730
>> >         at jrockit/vm/Locks.park0(J)V(Native Method)
>> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
>> >         at java/util/concurrent/locks/LockSupport.park(LockSupport.java
>> :156)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAn
>> dCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcqu
>> ireShared(AbstractQueuedSynchronizer.java:941)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquir
>> eShared(AbstractQueuedSynchronizer.java:1261)[inlined]
>> >         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.
>> lock(ReentrantReadWriteLock.java:695)[optimized]
>> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java
>> :81)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceIm
>> pl.getApplicationPolicy(PDPServiceImpl.java:850)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceIm
>> pl.getApplicationPolicy(PDPServiceImpl.java:810)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getGrant
>> edAppRoles(PolicyUtil.java:3042)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAp
>> pRoles(PolicyUtil.java:1977)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAp
>> pRoles(PolicyUtil.java:1922)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComput
>> or$1.run(SubjectResolverComputor.java:152)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComput
>> or$1.run(SubjectResolverComputor.java:143)
>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.ja
>> va:254)[inlined]
>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.ja
>> va:268)[optimized]
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComput
>> or.getAppRoles(SubjectResolverComputor.java:143)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComput
>> or.compute(SubjectResolverComputor.java:123)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverCacheI
>> mpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceIm
>> pl.computeJpsSubject(PDPServiceImpl.java:2396)
>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.reso
>> lveJpsSubject(JpsAbsSubjectResolver.java:216)
>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.reso
>> lveSubject(JpsAbsSubjectResolver.java:175)
>> >         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAb
>> sInterceptor.java:123)
>> >         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInter
>> ceptor.java:113)
>> >         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/
>> Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
>> >         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMe
>> thodAccessorImpl.java:25)[optimized]
>> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>> >         at com/bea/core/repackaged/springframework/aop/support/AopUtils
>> .invokeJoinpointUsingReflection(AopUtils.java:310)
>> >         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.inv
>> oke(JeeInterceptorInterceptor.java:68)
>> >         at com/bea/core/repackaged/springframework/aop/framework/Reflec
>> tiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/support/Delegati
>> ngIntroductionInterceptor.doProceed(DelegatingIntroducti
>> onInterceptor.java:131)
>> >         at com/bea/core/repackaged/springframework/aop/support/Delegati
>> ngIntroductionInterceptor.invoke(DelegatingIntroductionI
>> nterceptor.java:119)
>> >         at com/bea/core/repackaged/springframework/aop/framework/Reflec
>> tiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(M
>> ethodInvocationVisitorImpl.java:34)
>> >        at weblogic/ejb/container/injection/EnvironmentInterceptorCallb
>> ackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
>> >         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(Envir
>> onmentInterceptor.java:42)
>> >         at com/bea/core/repackaged/springframework/aop/framework/Reflec
>> tiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/interceptor/Expo
>> seInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
>> >         at com/bea/core/repackaged/springframework/aop/framework/Reflec
>> tiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/support/Delegati
>> ngIntroductionInterceptor.doProceed(DelegatingIntroducti
>> onInterceptor.java:131)
>> >         at com/bea/core/repackaged/springframework/aop/support/Delegati
>> ngIntroductionInterceptor.invoke(DelegatingIntroductionI
>> nterceptor.java:119)
>> >         at com/bea/core/repackaged/springframework/aop/framework/Reflec
>> tiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/framework/JdkDyn
>> amicAopProxy.invoke(JdkDynamicAopProxy.java:204)
>> >         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/
>> services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1
>> ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown
>> Source)
>> >         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.i
>> nvoke(SessionRemoteMethodInvoker.java:40)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1
>> ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/work
>> flow/verification/IWorkflowContext;)V(Unknown Source)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1
>> ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;
>> Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown
>> Source)
>> >         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.
>> java:674)[optimized]
>> >         at weblogic/rmi/cluster/ClusterableServerRef.invoke(Clusterable
>> ServerRef.java:230)
>> >         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.
>> java:526)[inlined]
>> >         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(
>> AuthenticatedSubject.java:363)[inlined]
>> >         at weblogic/security/service/SecurityManager.runAs(SecurityMana
>> ger.java:146)[inlined]
>> >         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServ
>> erRef.java:523)[inlined]
>> >         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRe
>> quest.java:118)[optimized]
>> >         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[
>> optimized]
>> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
>> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>
> --
> Cheers,
> √
>
>
>


-- 
Cheers,
√
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/eb1e118b/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Mar 30 04:53:38 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 30 Mar 2017 09:53:38 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
 <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
 <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>
Message-ID: <DED512D9-7A3B-4035-A9A4-F9ECC5684E95@gmail.com>

If you can’t catch it, you can’t observe it wasn’t thrown.

Alex

> On 30 Mar 2017, at 09:41, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> 
> 
> On Thu, Mar 30, 2017 at 10:33 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> JVM spec allows for undefined behaviour.
> 
> Yes—otherwise there wouldn't be a need to crash it ;-)
>  
> They don’t have to throw SOE or OOME. 
> 
> Agreed: http://www.scala-lang.org/api/current/scala/util/control/NonFatal$.html <http://www.scala-lang.org/api/current/scala/util/control/NonFatal$.html>
>  
> People shouldn’t catch all Throwables, if they want JVM to crash.
> 
> Absolutely agreed—problem is that they do. All over the place. OOMEs and SOEs can be thrown virtually everywhere, which means that if they are triggered under a "catch( Throwable t) { /* yolo */ }" the JVM will keep on chugging along but with unknown internal damage.
> 
> Personally, I love this part of the java.lang.Error javadoc:
> 
> «An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.»
> 
> With 20/20 hindsight, perhaps catch should operate, not on Throwable but rather on Catchable—and some Throwables should never have been Catchable.
> 
> 
> 
> Alex
> 
> 
>> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>> 
>> IMO, Errors which may leave the JVM in an inconsistent state should always crash the JVM hard.
>> 
>> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>> The holder may have moved on. Watch for stack overflows in history. When hard errors occur, the behaviour of the JVM is not guaranteed, and stack unwinding can miss finally statements, thus miss lock releases.
>> 
>> Alex
>> 
>> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com>> wrote:
>> >
>> > Hi all:
>> >
>> > I have a problem:
>> >
>> > 75 threads wait same lock, but not found hold lock thread from thread dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect performance. How to find out who hold lock ?
>> >
>> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked, daemon
>> >         -- Parking to wait for: java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d730
>> >         at jrockit/vm/Locks.park0(J)V(Native Method)
>> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
>> >         at java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
>> >         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
>> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimized]
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
>> >         at oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectResolver.java:216)
>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
>> >         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.java:123)
>> >         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113)
>> >         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
>> >         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
>> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>> >         at com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)
>> >         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
>> >        at weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
>> >         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInterceptor.java:42)
>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>> >         at com/bea/core/repackaged/springframework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
>> >         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
>> >         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
>> >         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[optimized]
>> >         at weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.java:230)
>> >         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined]
>> >         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
>> >         at weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146)[inlined]
>> >         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:523)[inlined]
>> >         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
>> >         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
>> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
>> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>> 
>> 
>> 
>> -- 
>> Cheers,
>> √
> 
> 
> 
> 
> -- 
> Cheers,
> √

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/7eac3a48/attachment-0001.html>

From davidcholmes at aapt.net.au  Thu Mar 30 05:00:08 2017
From: davidcholmes at aapt.net.au (David Holmes)
Date: Thu, 30 Mar 2017 19:00:08 +1000
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
Message-ID: <028501d2a934$08a28d70$19e7a850$@aapt.net.au>

Alex Otenko writes:
> 
> The holder may have moved on. Watch for stack overflows in history. When
> hard errors occur, the behaviour of the JVM is not guaranteed, and stack
> unwinding can miss finally statements, thus miss lock releases.

The VM may abort but I'm not aware of any case where stack unwinding will miss finally statements. Of course statements in finally blocks can generate secondary exceptions.

David
-------
 
> Alex
> 
> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
> >
> > Hi all:
> >
> > I have a problem:
> >
> > 75 threads wait same lock, but not found hold lock thread from thread
> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but
> affect performance. How to find out who hold lock ?
> >
> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-
> tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked,
> daemon
> >         -- Parking to wait for:
> java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d7
> 30
> >         at jrockit/vm/Locks.park0(J)V(Native Method)
> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
> >         at
> java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
> >         at
> java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInter
> rupt(AbstractQueuedSynchronizer.java:811)[inlined]
> >         at
> java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(A
> bstractQueuedSynchronizer.java:941)[inlined]
> >         at
> java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(Abst
> ractQueuedSynchronizer.java:1261)[inlined]
> >         at
> java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(Reentra
> ntReadWriteLock.java:695)[optimized]
> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
> >         at
> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicati
> onPolicy(PDPServiceImpl.java:850)
> >         at
> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicati
> onPolicy(PDPServiceImpl.java:810)
> >         at
> oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(Polic
> yUtil.java:3042)
> >         at
> oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.
> java:1977)
> >         at
> oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.
> java:1922)
> >         at
> oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(Subj
> ectResolverComputor.java:152)
> >         at
> oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(Subj
> ectResolverComputor.java:143)
> >         at
> jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
> >         at
> jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimiz
> ed]
> >         at
> oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRole
> s(SubjectResolverComputor.java:143)
> >         at
> oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(S
> ubjectResolverComputor.java:123)
> >         at
> oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJp
> sSubject(SubjectResolverCacheImpl.java:207)
> >         at
> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJp
> sSubject(PDPServiceImpl.java:2396)
> >         at
> oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(J
> psAbsSubjectResolver.java:216)
> >         at
> oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(Jps
> AbsSubjectResolver.java:175)
> >         at
> oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.j
> ava:123)
> >         at
> oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113
> )
> >         at
> sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljav
> a/lang/Object;)Ljava/lang/Object;(Unknown Source)
> >         at
> sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
> sorImpl.java:25)[optimized]
> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
> >         at
> com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJ
> oinpointUsingReflection(AopUtils.java:310)
> >         at
> com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterc
> eptorInterceptor.java:68)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at
> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
> uctionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
> >         at
> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
> uctionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at
> com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocati
> onVisitorImpl.java:34)
> >        at
> weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callb
> ack(EnvironmentInterceptorCallbackImpl.java:54)
> >         at
> com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInter
> ceptor.java:42)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at
> com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvoca
> tionInterceptor.invoke(ExposeInvocationInterceptor.java:89)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at
> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
> uctionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
> >         at
> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
> uctionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
> >         at
> com/bea/core/repackaged/springframework/aop/framework/JdkDynamicA
> opProxy.invoke(JdkDynamicAopProxy.java:204)
> >         at
> com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/
> workflow/verification/IWorkflowContext;)V(Unknown Source)
> >         at
> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
> l.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(U
> nknown Source)
> >         at
> weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(Ses
> sionRemoteMethodInvoker.java:40)
> >         at
> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
> l.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWo
> rkflowContext;)V(Unknown Source)
> >         at
> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
> l_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/Out
> boundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(
> Unknown Source)
> >         at
> weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[opti
> mized]
> >         at
> weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.jav
> a:230)
> >         at
> weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined
> ]
> >         at
> weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSu
> bject.java:363)[inlined]
> >         at
> weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146
> )[inlined]
> >         at
> weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:52
> 3)[inlined]
> >         at
> weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.jav
> a:118)[optimized]
> >         at
> weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From oleksandr.otenko at gmail.com  Thu Mar 30 05:12:47 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 30 Mar 2017 10:12:47 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
Message-ID: <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>

Right. I never dug to the exact cause, but Lock.unlock() in finally surely can hit SOE while recovering from SOE.


Alex


> On 30 Mar 2017, at 10:00, David Holmes <davidcholmes at aapt.net.au> wrote:
> 
> Alex Otenko writes:
>> 
>> The holder may have moved on. Watch for stack overflows in history. When
>> hard errors occur, the behaviour of the JVM is not guaranteed, and stack
>> unwinding can miss finally statements, thus miss lock releases.
> 
> The VM may abort but I'm not aware of any case where stack unwinding will miss finally statements. Of course statements in finally blocks can generate secondary exceptions.
> 
> David
> -------
> 
>> Alex
>> 
>>> On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
>>> 
>>> Hi all:
>>> 
>>> I have a problem:
>>> 
>>> 75 threads wait same lock, but not found hold lock thread from thread
>> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but
>> affect performance. How to find out who hold lock ?
>>> 
>>> "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-
>> tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked,
>> daemon
>>>        -- Parking to wait for:
>> java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d7
>> 30
>>>        at jrockit/vm/Locks.park0(J)V(Native Method)
>>>        at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>>>        at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
>>>        at
>> java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
>>>        at
>> java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInter
>> rupt(AbstractQueuedSynchronizer.java:811)[inlined]
>>>        at
>> java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(A
>> bstractQueuedSynchronizer.java:941)[inlined]
>>>        at
>> java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(Abst
>> ractQueuedSynchronizer.java:1261)[inlined]
>>>        at
>> java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(Reentra
>> ntReadWriteLock.java:695)[optimized]
>>>        at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
>>>        at
>> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicati
>> onPolicy(PDPServiceImpl.java:850)
>>>        at
>> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicati
>> onPolicy(PDPServiceImpl.java:810)
>>>        at
>> oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(Polic
>> yUtil.java:3042)
>>>        at
>> oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.
>> java:1977)
>>>        at
>> oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.
>> java:1922)
>>>        at
>> oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(Subj
>> ectResolverComputor.java:152)
>>>        at
>> oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(Subj
>> ectResolverComputor.java:143)
>>>        at
>> jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
>>>        at
>> jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimiz
>> ed]
>>>        at
>> oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRole
>> s(SubjectResolverComputor.java:143)
>>>        at
>> oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(S
>> ubjectResolverComputor.java:123)
>>>        at
>> oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJp
>> sSubject(SubjectResolverCacheImpl.java:207)
>>>        at
>> oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJp
>> sSubject(PDPServiceImpl.java:2396)
>>>        at
>> oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(J
>> psAbsSubjectResolver.java:216)
>>>        at
>> oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(Jps
>> AbsSubjectResolver.java:175)
>>>        at
>> oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.j
>> ava:123)
>>>        at
>> oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113
>> )
>>>        at
>> sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljav
>> a/lang/Object;)Ljava/lang/Object;(Unknown Source)
>>>        at
>> sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces
>> sorImpl.java:25)[optimized]
>>>        at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>>>        at
>> com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJ
>> oinpointUsingReflection(AopUtils.java:310)
>>>        at
>> com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterc
>> eptorInterceptor.java:68)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
>> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>>        at
>> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
>> uctionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>>>        at
>> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
>> uctionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
>> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>>        at
>> com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocati
>> onVisitorImpl.java:34)
>>>       at
>> weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callb
>> ack(EnvironmentInterceptorCallbackImpl.java:54)
>>>        at
>> com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInter
>> ceptor.java:42)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
>> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>>        at
>> com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvoca
>> tionInterceptor.invoke(ExposeInvocationInterceptor.java:89)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
>> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>>        at
>> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
>> uctionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>>>        at
>> com/bea/core/repackaged/springframework/aop/support/DelegatingIntrod
>> uctionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/ReflectiveMe
>> thodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>>        at
>> com/bea/core/repackaged/springframework/aop/framework/JdkDynamicA
>> opProxy.invoke(JdkDynamicAopProxy.java:204)
>>>        at
>> com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/
>> workflow/verification/IWorkflowContext;)V(Unknown Source)
>>>        at
>> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
>> l.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(U
>> nknown Source)
>>>        at
>> weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(Ses
>> sionRemoteMethodInvoker.java:40)
>>>        at
>> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
>> l.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWo
>> rkflowContext;)V(Unknown Source)
>>>        at
>> oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImp
>> l_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/Out
>> boundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(
>> Unknown Source)
>>>        at
>> weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[opti
>> mized]
>>>        at
>> weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.jav
>> a:230)
>>>        at
>> weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined
>> ]
>>>        at
>> weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSu
>> bject.java:363)[inlined]
>>>        at
>> weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146
>> )[inlined]
>>>        at
>> weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:52
>> 3)[inlined]
>>>        at
>> weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.jav
>> a:118)[optimized]
>>>        at
>> weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
>>>        at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
>>>        at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/8cc69c5c/attachment-0001.html>

From aph at redhat.com  Thu Mar 30 06:19:13 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 30 Mar 2017 11:19:13 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
 <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
Message-ID: <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>

On 30/03/17 10:12, Alex Otenko wrote:
> Right. I never dug to the exact cause, but Lock.unlock() in finally surely can hit SOE while recovering from SOE.

Should be fixed:

https://bugs.openjdk.java.net/browse/JDK-8046936

Andrew.


From viktor.klang at gmail.com  Thu Mar 30 06:23:25 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 30 Mar 2017 12:23:25 +0200
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <DED512D9-7A3B-4035-A9A4-F9ECC5684E95@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
 <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
 <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>
 <DED512D9-7A3B-4035-A9A4-F9ECC5684E95@gmail.com>
Message-ID: <CANPzfU9SYZZwwV9yxcRLiO0H3kX1fFVD6sOwDeXVEViuJ8OhBg@mail.gmail.com>

Of course you can--outside of the program.
Throwing something that thr JVM can catch, log and exit abnormally is much
cleaner than relying on all previous stack frames to behave well. ^^

-- 
Cheers,
√

On Mar 30, 2017 10:53, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:

> If you can’t catch it, you can’t observe it wasn’t thrown.
>
> Alex
>
> On 30 Mar 2017, at 09:41, Viktor Klang <viktor.klang at gmail.com> wrote:
>
>
>
> On Thu, Mar 30, 2017 at 10:33 AM, Alex Otenko <oleksandr.otenko at gmail.com>
>  wrote:
>
>> JVM spec allows for undefined behaviour.
>>
>
> Yes—otherwise there wouldn't be a need to crash it ;-)
>
>
>> They don’t have to throw SOE or OOME.
>>
>
> Agreed: http://www.scala-lang.org/api/current/scala/util/
> control/NonFatal$.html
>
>
>> People shouldn’t catch all Throwables, if they want JVM to crash.
>>
>
> Absolutely agreed—problem is that they do. All over the place. OOMEs and
> SOEs can be thrown virtually everywhere, which means that if they are
> triggered under a "catch( Throwable t) { /* yolo */ }" the JVM will keep on
> chugging along but with unknown internal damage.
>
> Personally, I love this part of the java.lang.Error javadoc:
>
> «An Error is a subclass of Throwable that indicates serious problems that
> a reasonable application should not try to catch.»
>
> With 20/20 hindsight, perhaps *catch* should operate, not on *Throwable* but
> rather on *Catchable*—and some *Throwable*s should never have been
> *Catchable*.
>
>
>>
>> Alex
>>
>>
>> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com> wrote:
>>
>> IMO, Errors which may leave the JVM in an inconsistent state should
>> always crash the JVM hard.
>>
>> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com>
>>  wrote:
>>
>>> The holder may have moved on. Watch for stack overflows in history. When
>>> hard errors occur, the behaviour of the JVM is not guaranteed, and stack
>>> unwinding can miss finally statements, thus miss lock releases.
>>>
>>> Alex
>>>
>>> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
>>> >
>>> > Hi all:
>>> >
>>> > I have a problem:
>>> >
>>> > 75 threads wait same lock, but not found hold lock thread from thread
>>> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect
>>> performance. How to find out who hold lock ?
>>> >
>>> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default
>>> (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked,
>>> native_blocked, daemon
>>> >         -- Parking to wait for: java/util/concurrent/locks/Ree
>>> ntrantReadWriteLock$NonfairSync at 0x8646d730
>>> >         at jrockit/vm/Locks.park0(J)V(Native Method)
>>> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>>> >         at jrockit/proxy/sun/misc/Unsafe.
>>> park(Unsafe.java:616)[inlined]
>>> >         at java/util/concurrent/locks/Loc
>>> kSupport.park(LockSupport.java:156)[inlined]
>>> >         at java/util/concurrent/locks/Abs
>>> tractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueued
>>> Synchronizer.java:811)[inlined]
>>> >         at java/util/concurrent/locks/Abs
>>> tractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchr
>>> onizer.java:941)[inlined]
>>> >         at java/util/concurrent/locks/Abs
>>> tractQueuedSynchronizer.acquireShared(AbstractQueuedSynchron
>>> izer.java:1261)[inlined]
>>> >         at java/util/concurrent/locks/Ree
>>> ntrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.jav
>>> a:695)[optimized]
>>> >         at oracle/security/jps/az/common/
>>> util/JpsLock.lock(JpsLock.java:81)
>>> >         at oracle/security/jps/az/interna
>>> l/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPSer
>>> viceImpl.java:850)
>>> >         at oracle/security/jps/az/interna
>>> l/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPSer
>>> viceImpl.java:810)
>>> >         at oracle/security/jps/internal/p
>>> olicystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
>>> >         at oracle/security/jps/internal/p
>>> olicystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
>>> >         at oracle/security/jps/internal/p
>>> olicystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
>>> >         at oracle/security/jps/internal/c
>>> ore/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
>>> >         at oracle/security/jps/internal/c
>>> ore/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
>>> >         at jrockit/vm/AccessController.do
>>> Privileged(AccessController.java:254)[inlined]
>>> >         at jrockit/vm/AccessController.do
>>> Privileged(AccessController.java:268)[optimized]
>>> >         at oracle/security/jps/internal/c
>>> ore/util/SubjectResolverComputor.getAppRoles(SubjectResolver
>>> Computor.java:143)
>>> >         at oracle/security/jps/internal/c
>>> ore/util/SubjectResolverComputor.compute(SubjectResolverComp
>>> utor.java:123)
>>> >         at oracle/security/jps/internal/c
>>> ore/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectR
>>> esolverCacheImpl.java:207)
>>> >         at oracle/security/jps/az/interna
>>> l/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServic
>>> eImpl.java:2396)
>>> >         at oracle/security/jps/internal/j
>>> aas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectRes
>>> olver.java:216)
>>> >         at oracle/security/jps/internal/j
>>> aas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
>>> >         at oracle/security/jps/ee/ejb/Jps
>>> AbsInterceptor.intercept(JpsAbsInterceptor.java:123)
>>> >         at oracle/security/jps/ee/ejb/Jps
>>> Interceptor.intercept(JpsInterceptor.java:113)
>>> >         at sun/reflect/GeneratedMethodAcc
>>> essor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown
>>> Source)
>>> >         at sun/reflect/DelegatingMethodAc
>>> cessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
>>> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/support/AopUtils.invokeJoinpointUsingReflectio
>>> n(AopUtils.java:310)
>>> >         at com/oracle/pitchfork/intercept
>>> /JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>> eflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/support/DelegatingIntroductionInterceptor.doPr
>>> oceed(DelegatingIntroductionInterceptor.java:131)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/support/DelegatingIntroductionInterceptor.invo
>>> ke(DelegatingIntroductionInterceptor.java:119)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>> eflectiveMethodInvocation.java:171)
>>> >         at com/oracle/pitchfork/spi/Metho
>>> dInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
>>> >        at weblogic/ejb/container/injection/EnvironmentInterceptorCallb
>>> ackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
>>> >         at com/oracle/pitchfork/spi/Envir
>>> onmentInterceptor.invoke(EnvironmentInterceptor.java:42)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>> eflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/interceptor/ExposeInvocationInterceptor.invoke
>>> (ExposeInvocationInterceptor.java:89)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>> eflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/support/DelegatingIntroductionInterceptor.doPr
>>> oceed(DelegatingIntroductionInterceptor.java:131)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/support/DelegatingIntroductionInterceptor.invo
>>> ke(DelegatingIntroductionInterceptor.java:119)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>> eflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/spring
>>> framework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamic
>>> AopProxy.java:204)
>>> >         at com/sun/proxy/$Proxy344.destro
>>> yWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown
>>> Source)
>>> >         at oracle/bpel/services/workflow/
>>> query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/l
>>> ang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
>>> >         at weblogic/ejb/container/interna
>>> l/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
>>> >         at oracle/bpel/services/workflow/
>>> query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowCont
>>> ext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown
>>> Source)
>>> >         at oracle/bpel/services/workflow/
>>> query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweb
>>> logic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundRespo
>>> nse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown
>>> Source)
>>> >         at weblogic/rmi/internal/BasicSer
>>> verRef.invoke(BasicServerRef.java:674)[optimized]
>>> >         at weblogic/rmi/cluster/Clusterab
>>> leServerRef.invoke(ClusterableServerRef.java:230)
>>> >         at weblogic/rmi/internal/BasicSer
>>> verRef$1.run(BasicServerRef.java:526)[inlined]
>>> >         at weblogic/security/acl/internal
>>> /AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
>>> >         at weblogic/security/service/Secu
>>> rityManager.runAs(SecurityManager.java:146)[inlined]
>>> >         at weblogic/rmi/internal/BasicSer
>>> verRef.handleRequest(BasicServerRef.java:523)[inlined]
>>> >         at weblogic/rmi/internal/wls/WLSE
>>> xecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
>>> >         at weblogic/work/ExecuteThread.ex
>>> ecute(ExecuteThread.java:268)[optimized]
>>> >         at weblogic/work/ExecuteThread.run(ExecuteThread.java:226)
>>> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>
>>
>>
>> --
>> Cheers,
>> √
>>
>>
>>
>
>
> --
> Cheers,
> √
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/f66902f2/attachment-0001.html>

From oleksandr.otenko at gmail.com  Thu Mar 30 06:26:16 2017
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Thu, 30 Mar 2017 11:26:16 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <CANPzfU9SYZZwwV9yxcRLiO0H3kX1fFVD6sOwDeXVEViuJ8OhBg@mail.gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
 <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
 <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>
 <DED512D9-7A3B-4035-A9A4-F9ECC5684E95@gmail.com>
 <CANPzfU9SYZZwwV9yxcRLiO0H3kX1fFVD6sOwDeXVEViuJ8OhBg@mail.gmail.com>
Message-ID: <32B56ADB-8701-4AA4-B203-0AFC4636ACDD@gmail.com>

Some JVMs offer command-line arguments to behave like that.

Alex

> On 30 Mar 2017, at 11:23, Viktor Klang <viktor.klang at gmail.com> wrote:
> 
> Of course you can--outside of the program.
> Throwing something that thr JVM can catch, log and exit abnormally is much cleaner than relying on all previous stack frames to behave well. ^^
> 
> -- 
> Cheers,
> √
> 
> On Mar 30, 2017 10:53, "Alex Otenko" <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
> If you can’t catch it, you can’t observe it wasn’t thrown.
> 
> Alex
> 
>> On 30 Mar 2017, at 09:41, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>> 
>> 
>> 
>> On Thu, Mar 30, 2017 at 10:33 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>> JVM spec allows for undefined behaviour.
>> 
>> Yes—otherwise there wouldn't be a need to crash it ;-)
>>  
>> They don’t have to throw SOE or OOME. 
>> 
>> Agreed: http://www.scala-lang.org/api/current/scala/util/control/NonFatal$.html <http://www.scala-lang.org/api/current/scala/util/control/NonFatal$.html>
>>  
>> People shouldn’t catch all Throwables, if they want JVM to crash.
>> 
>> Absolutely agreed—problem is that they do. All over the place. OOMEs and SOEs can be thrown virtually everywhere, which means that if they are triggered under a "catch( Throwable t) { /* yolo */ }" the JVM will keep on chugging along but with unknown internal damage.
>> 
>> Personally, I love this part of the java.lang.Error javadoc:
>> 
>> «An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.»
>> 
>> With 20/20 hindsight, perhaps catch should operate, not on Throwable but rather on Catchable—and some Throwables should never have been Catchable.
>> 
>> 
>> 
>> Alex
>> 
>> 
>>> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com <mailto:viktor.klang at gmail.com>> wrote:
>>> 
>>> IMO, Errors which may leave the JVM in an inconsistent state should always crash the JVM hard.
>>> 
>>> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com <mailto:oleksandr.otenko at gmail.com>> wrote:
>>> The holder may have moved on. Watch for stack overflows in history. When hard errors occur, the behaviour of the JVM is not guaranteed, and stack unwinding can miss finally statements, thus miss lock releases.
>>> 
>>> Alex
>>> 
>>> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com <mailto:yan.gang at oracle.com>> wrote:
>>> >
>>> > Hi all:
>>> >
>>> > I have a problem:
>>> >
>>> > 75 threads wait same lock, but not found hold lock thread from thread dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect performance. How to find out who hold lock ?
>>> >
>>> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked, native_blocked, daemon
>>> >         -- Parking to wait for: java/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync at 0x8646d730
>>> >         at jrockit/vm/Locks.park0(J)V(Native Method)
>>> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>>> >         at jrockit/proxy/sun/misc/Unsafe.park(Unsafe.java:616)[inlined]
>>> >         at java/util/concurrent/locks/LockSupport.park(LockSupport.java:156)[inlined]
>>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)[inlined]
>>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:941)[inlined]
>>> >         at java/util/concurrent/locks/AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1261)[inlined]
>>> >         at java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:695)[optimized]
>>> >         at oracle/security/jps/az/common/util/JpsLock.lock(JpsLock.java:81)
>>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:850)
>>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPServiceImpl.java:810)
>>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
>>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
>>> >         at oracle/security/jps/internal/policystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
>>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:152)
>>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor$1.run(SubjectResolverComputor.java:143)
>>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:254)[inlined]
>>> >         at jrockit/vm/AccessController.doPrivileged(AccessController.java:268)[optimized]
>>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.getAppRoles(SubjectResolverComputor.java:143)
>>> >         at oracle/security/jps/internal/core/util/SubjectResolverComputor.compute(SubjectResolverComputor.java:123)
>>> >         at oracle/security/jps/internal/core/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectResolverCacheImpl.java:207)
>>> >         at oracle/security/jps/az/internal/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServiceImpl.java:2396)
>>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectResolver.java:216)
>>> >         at oracle/security/jps/internal/jaas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolver.java:175)
>>> >         at oracle/security/jps/ee/ejb/JpsAbsInterceptor.intercept(JpsAbsInterceptor.java:123)
>>> >         at oracle/security/jps/ee/ejb/JpsInterceptor.intercept(JpsInterceptor.java:113)
>>> >         at sun/reflect/GeneratedMethodAccessor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown Source)
>>> >         at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
>>> >         at java/lang/reflect/Method.invoke(Method.java:597)[optimized]
>>> >         at com/bea/core/repackaged/springframework/aop/support/AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)
>>> >         at com/oracle/pitchfork/intercept/JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>> >         at com/oracle/pitchfork/spi/MethodInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
>>> >        at weblogic/ejb/container/injection/EnvironmentInterceptorCallbackImpl.callback(EnvironmentInterceptorCallbackImpl.java:54)
>>> >         at com/oracle/pitchfork/spi/EnvironmentInterceptor.invoke(EnvironmentInterceptor.java:42)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/springframework/aop/interceptor/ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
>>> >         at com/bea/core/repackaged/springframework/aop/support/DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)
>>> >         at com/bea/core/repackaged/springframework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
>>> >         at com/sun/proxy/$Proxy344.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/lang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
>>> >         at weblogic/ejb/container/internal/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
>>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown Source)
>>> >         at oracle/bpel/services/workflow/query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweblogic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundResponse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown Source)
>>> >         at weblogic/rmi/internal/BasicServerRef.invoke(BasicServerRef.java:674)[optimized]
>>> >         at weblogic/rmi/cluster/ClusterableServerRef.invoke(ClusterableServerRef.java:230)
>>> >         at weblogic/rmi/internal/BasicServerRef$1.run(BasicServerRef.java:526)[inlined]
>>> >         at weblogic/security/acl/internal/AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
>>> >         at weblogic/security/service/SecurityManager.runAs(SecurityManager.java:146)[inlined]
>>> >         at weblogic/rmi/internal/BasicServerRef.handleRequest(BasicServerRef.java:523)[inlined]
>>> >         at weblogic/rmi/internal/wls/WLSExecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
>>> >         at weblogic/work/ExecuteThread.execute(ExecuteThread.java:268)[optimized]
>>> >         at weblogic/work/ExecuteThread.ru <http://executethread.ru/>n(ExecuteThread.java:226)
>>> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>>> > _______________________________________________
>>> > Concurrency-interest mailing list
>>> > Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu <mailto:Concurrency-interest at cs.oswego.edu>
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest <http://cs.oswego.edu/mailman/listinfo/concurrency-interest>
>>> 
>>> 
>>> 
>>> -- 
>>> Cheers,
>>> √
>> 
>> 
>> 
>> 
>> -- 
>> Cheers,
>> √
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/b34ee799/attachment-0001.html>

From viktor.klang at gmail.com  Thu Mar 30 06:29:14 2017
From: viktor.klang at gmail.com (Viktor Klang)
Date: Thu, 30 Mar 2017 12:29:14 +0200
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <32B56ADB-8701-4AA4-B203-0AFC4636ACDD@gmail.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <CANPzfU_fTgBdJh8E+_g2-P2JJ0XkCZaVEtCY+DHXNEv_-wdEdQ@mail.gmail.com>
 <C0B23969-B7CD-413F-B134-FC2E9711DD9F@gmail.com>
 <CANPzfU-Om1ovOo2ShR3xn1vV6hGb_nSWF9wo-xn5aTUT6CO-dA@mail.gmail.com>
 <DED512D9-7A3B-4035-A9A4-F9ECC5684E95@gmail.com>
 <CANPzfU9SYZZwwV9yxcRLiO0H3kX1fFVD6sOwDeXVEViuJ8OhBg@mail.gmail.com>
 <32B56ADB-8701-4AA4-B203-0AFC4636ACDD@gmail.com>
Message-ID: <CANPzfU8jJWhMs6arsyY+mwRqPpXtyT19VFoyHj+_JYfgb+u_FA@mail.gmail.com>

Yes, but as you say, it is jvm-specific and not something which can be
encoded as program behavior.

-- 
Cheers,
√

On Mar 30, 2017 12:26, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:

> Some JVMs offer command-line arguments to behave like that.
>
> Alex
>
> On 30 Mar 2017, at 11:23, Viktor Klang <viktor.klang at gmail.com> wrote:
>
> Of course you can--outside of the program.
> Throwing something that thr JVM can catch, log and exit abnormally is much
> cleaner than relying on all previous stack frames to behave well. ^^
>
> --
> Cheers,
> √
>
> On Mar 30, 2017 10:53, "Alex Otenko" <oleksandr.otenko at gmail.com> wrote:
>
>> If you can’t catch it, you can’t observe it wasn’t thrown.
>>
>> Alex
>>
>> On 30 Mar 2017, at 09:41, Viktor Klang <viktor.klang at gmail.com> wrote:
>>
>>
>>
>> On Thu, Mar 30, 2017 at 10:33 AM, Alex Otenko <oleksandr.otenko at gmail.com
>> > wrote:
>>
>>> JVM spec allows for undefined behaviour.
>>>
>>
>> Yes—otherwise there wouldn't be a need to crash it ;-)
>>
>>
>>> They don’t have to throw SOE or OOME.
>>>
>>
>> Agreed: http://www.scala-lang.org/api/current/scala/util/con
>> trol/NonFatal$.html
>>
>>
>>> People shouldn’t catch all Throwables, if they want JVM to crash.
>>>
>>
>> Absolutely agreed—problem is that they do. All over the place. OOMEs and
>> SOEs can be thrown virtually everywhere, which means that if they are
>> triggered under a "catch( Throwable t) { /* yolo */ }" the JVM will keep on
>> chugging along but with unknown internal damage.
>>
>> Personally, I love this part of the java.lang.Error javadoc:
>>
>> «An Error is a subclass of Throwable that indicates serious problems
>> that a reasonable application should not try to catch.»
>>
>> With 20/20 hindsight, perhaps *catch* should operate, not on *Throwable* but
>> rather on *Catchable*—and some *Throwable*s should never have been
>> *Catchable*.
>>
>>
>>>
>>> Alex
>>>
>>>
>>> On 30 Mar 2017, at 09:08, Viktor Klang <viktor.klang at gmail.com> wrote:
>>>
>>> IMO, Errors which may leave the JVM in an inconsistent state should
>>> always crash the JVM hard.
>>>
>>> On Thu, Mar 30, 2017 at 9:18 AM, Alex Otenko <oleksandr.otenko at gmail.com
>>> > wrote:
>>>
>>>> The holder may have moved on. Watch for stack overflows in history.
>>>> When hard errors occur, the behaviour of the JVM is not guaranteed, and
>>>> stack unwinding can miss finally statements, thus miss lock releases.
>>>>
>>>> Alex
>>>>
>>>> > On 30 Mar 2017, at 06:28, Gang Yan <yan.gang at oracle.com> wrote:
>>>> >
>>>> > Hi all:
>>>> >
>>>> > I have a problem:
>>>> >
>>>> > 75 threads wait same lock, but not found hold lock thread from thread
>>>> dump. someone recommend add option" -XX:+PrintConcurrentLocks" but affect
>>>> performance. How to find out who hold lock ?
>>>> >
>>>> > "[STUCK] ExecuteThread: '20' for queue: 'weblogic.kernel.Default
>>>> (self-tuning)'" id=571 idx=0x2f8 tid=19406 prio=1 alive, parked,
>>>> native_blocked, daemon
>>>> >         -- Parking to wait for: java/util/concurrent/locks/Ree
>>>> ntrantReadWriteLock$NonfairSync at 0x8646d730
>>>> >         at jrockit/vm/Locks.park0(J)V(Native Method)
>>>> >         at jrockit/vm/Locks.park(Locks.java:2230)[inlined]
>>>> >         at jrockit/proxy/sun/misc/Unsafe.
>>>> park(Unsafe.java:616)[inlined]
>>>> >         at java/util/concurrent/locks/Loc
>>>> kSupport.park(LockSupport.java:156)[inlined]
>>>> >         at java/util/concurrent/locks/Abs
>>>> tractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueued
>>>> Synchronizer.java:811)[inlined]
>>>> >         at java/util/concurrent/locks/Abs
>>>> tractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchr
>>>> onizer.java:941)[inlined]
>>>> >         at java/util/concurrent/locks/Abs
>>>> tractQueuedSynchronizer.acquireShared(AbstractQueuedSynchron
>>>> izer.java:1261)[inlined]
>>>> >         at java/util/concurrent/locks/Ree
>>>> ntrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.jav
>>>> a:695)[optimized]
>>>> >         at oracle/security/jps/az/common/
>>>> util/JpsLock.lock(JpsLock.java:81)
>>>> >         at oracle/security/jps/az/interna
>>>> l/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPSer
>>>> viceImpl.java:850)
>>>> >         at oracle/security/jps/az/interna
>>>> l/runtime/service/PDPServiceImpl.getApplicationPolicy(PDPSer
>>>> viceImpl.java:810)
>>>> >         at oracle/security/jps/internal/p
>>>> olicystore/PolicyUtil.getGrantedAppRoles(PolicyUtil.java:3042)
>>>> >         at oracle/security/jps/internal/p
>>>> olicystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1977)
>>>> >         at oracle/security/jps/internal/p
>>>> olicystore/PolicyUtil.getJpsAppRoles(PolicyUtil.java:1922)
>>>> >         at oracle/security/jps/internal/c
>>>> ore/util/SubjectResolverComputor$1.run(SubjectResolverComput
>>>> or.java:152)
>>>> >         at oracle/security/jps/internal/c
>>>> ore/util/SubjectResolverComputor$1.run(SubjectResolverComput
>>>> or.java:143)
>>>> >         at jrockit/vm/AccessController.do
>>>> Privileged(AccessController.java:254)[inlined]
>>>> >         at jrockit/vm/AccessController.do
>>>> Privileged(AccessController.java:268)[optimized]
>>>> >         at oracle/security/jps/internal/c
>>>> ore/util/SubjectResolverComputor.getAppRoles(SubjectResolver
>>>> Computor.java:143)
>>>> >         at oracle/security/jps/internal/c
>>>> ore/util/SubjectResolverComputor.compute(SubjectResolverComp
>>>> utor.java:123)
>>>> >         at oracle/security/jps/internal/c
>>>> ore/util/SubjectResolverCacheImpl.computeJpsSubject(SubjectR
>>>> esolverCacheImpl.java:207)
>>>> >         at oracle/security/jps/az/interna
>>>> l/runtime/service/PDPServiceImpl.computeJpsSubject(PDPServic
>>>> eImpl.java:2396)
>>>> >         at oracle/security/jps/internal/j
>>>> aas/JpsAbsSubjectResolver.resolveJpsSubject(JpsAbsSubjectRes
>>>> olver.java:216)
>>>> >         at oracle/security/jps/internal/j
>>>> aas/JpsAbsSubjectResolver.resolveSubject(JpsAbsSubjectResolv
>>>> er.java:175)
>>>> >         at oracle/security/jps/ee/ejb/Jps
>>>> AbsInterceptor.intercept(JpsAbsInterceptor.java:123)
>>>> >         at oracle/security/jps/ee/ejb/Jps
>>>> Interceptor.intercept(JpsInterceptor.java:113)
>>>> >         at sun/reflect/GeneratedMethodAcc
>>>> essor1293.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;(Unknown
>>>> Source)
>>>> >         at sun/reflect/DelegatingMethodAc
>>>> cessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)[optimized]
>>>> >         at java/lang/reflect/Method.invok
>>>> e(Method.java:597)[optimized]
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/support/AopUtils.invokeJoinpointUsingReflectio
>>>> n(AopUtils.java:310)
>>>> >         at com/oracle/pitchfork/intercept
>>>> /JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:68)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>>> eflectiveMethodInvocation.java:171)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/support/DelegatingIntroductionInterceptor.doPr
>>>> oceed(DelegatingIntroductionInterceptor.java:131)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/support/DelegatingIntroductionInterceptor.invo
>>>> ke(DelegatingIntroductionInterceptor.java:119)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>>> eflectiveMethodInvocation.java:171)
>>>> >         at com/oracle/pitchfork/spi/Metho
>>>> dInvocationVisitorImpl.visit(MethodInvocationVisitorImpl.java:34)
>>>> >        at weblogic/ejb/container/injecti
>>>> on/EnvironmentInterceptorCallbackImpl.callback(EnvironmentIn
>>>> terceptorCallbackImpl.java:54)
>>>> >         at com/oracle/pitchfork/spi/Envir
>>>> onmentInterceptor.invoke(EnvironmentInterceptor.java:42)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>>> eflectiveMethodInvocation.java:171)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/interceptor/ExposeInvocationInterceptor.invoke
>>>> (ExposeInvocationInterceptor.java:89)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>>> eflectiveMethodInvocation.java:171)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/support/DelegatingIntroductionInterceptor.doPr
>>>> oceed(DelegatingIntroductionInterceptor.java:131)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/support/DelegatingIntroductionInterceptor.invo
>>>> ke(DelegatingIntroductionInterceptor.java:119)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/ReflectiveMethodInvocation.proceed(R
>>>> eflectiveMethodInvocation.java:171)
>>>> >         at com/bea/core/repackaged/spring
>>>> framework/aop/framework/JdkDynamicAopProxy.invoke(JdkDynamic
>>>> AopProxy.java:204)
>>>> >         at com/sun/proxy/$Proxy344.destro
>>>> yWorkflowContext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown
>>>> Source)
>>>> >         at oracle/bpel/services/workflow/
>>>> query/ejb/TaskQueryService_oz1ipg_EOImpl.__WL_invoke(Ljava/l
>>>> ang/Object;[Ljava/lang/Object;I)Ljava/lang/Object;(Unknown Source)
>>>> >         at weblogic/ejb/container/interna
>>>> l/SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:40)
>>>> >         at oracle/bpel/services/workflow/
>>>> query/ejb/TaskQueryService_oz1ipg_EOImpl.destroyWorkflowCont
>>>> ext(Loracle/bpel/services/workflow/verification/IWorkflowContext;)V(Unknown
>>>> Source)
>>>> >         at oracle/bpel/services/workflow/
>>>> query/ejb/TaskQueryService_oz1ipg_EOImpl_WLSkel.invoke(ILweb
>>>> logic/rmi/spi/InboundRequest;Lweblogic/rmi/spi/OutboundRespo
>>>> nse;Ljava/lang/Object;)Lweblogic/rmi/spi/OutboundResponse;(Unknown
>>>> Source)
>>>> >         at weblogic/rmi/internal/BasicSer
>>>> verRef.invoke(BasicServerRef.java:674)[optimized]
>>>> >         at weblogic/rmi/cluster/Clusterab
>>>> leServerRef.invoke(ClusterableServerRef.java:230)
>>>> >         at weblogic/rmi/internal/BasicSer
>>>> verRef$1.run(BasicServerRef.java:526)[inlined]
>>>> >         at weblogic/security/acl/internal
>>>> /AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)[inlined]
>>>> >         at weblogic/security/service/Secu
>>>> rityManager.runAs(SecurityManager.java:146)[inlined]
>>>> >         at weblogic/rmi/internal/BasicSer
>>>> verRef.handleRequest(BasicServerRef.java:523)[inlined]
>>>> >         at weblogic/rmi/internal/wls/WLSE
>>>> xecuteRequest.run(WLSExecuteRequest.java:118)[optimized]
>>>> >         at weblogic/work/ExecuteThread.ex
>>>> ecute(ExecuteThread.java:268)[optimized]
>>>> >         at weblogic/work/ExecuteThread.ru <http://executethread.ru/>
>>>> n(ExecuteThread.java:226)
>>>> >         at jrockit/vm/RNI.c2java(JJJJJ)V(Native Method)
>>>> > _______________________________________________
>>>> > Concurrency-interest mailing list
>>>> > Concurrency-interest at cs.oswego.edu
>>>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>
>>>
>>>
>>> --
>>> Cheers,
>>> √
>>>
>>>
>>>
>>
>>
>> --
>> Cheers,
>> √
>>
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20170330/79292f55/attachment-0001.html>

From jsampson at guidewire.com  Thu Mar 30 12:59:11 2017
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 30 Mar 2017 16:59:11 +0000
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
 <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
 <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>
Message-ID: <287A3035-6AA2-4154-9249-BFF7EE253692@guidewire.com>

Ooh, neat! I had asked this list whether something like that would be possible, right around the same time that issue was filed, and there was some heated debate around it:

http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/thread.html#13864

Exciting to see progress. :)

Cheers,
Justin


On 3/30/17, 3:19 AM, "Concurrency-interest on behalf of Andrew Haley" <concurrency-interest-bounces at cs.oswego.edu on behalf of aph at redhat.com> wrote:

    On 30/03/17 10:12, Alex Otenko wrote:
    > Right. I never dug to the exact cause, but Lock.unlock() in finally surely can hit SOE while recovering from SOE.
    
    Should be fixed:
    
    https://bugs.openjdk.java.net/browse/JDK-8046936
    
    Andrew.
 


From aph at redhat.com  Thu Mar 30 13:18:52 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 30 Mar 2017 18:18:52 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <287A3035-6AA2-4154-9249-BFF7EE253692@guidewire.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
 <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
 <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>
 <287A3035-6AA2-4154-9249-BFF7EE253692@guidewire.com>
Message-ID: <ac430074-2606-2162-9033-1459cc1391cb@redhat.com>

On 30/03/17 17:59, Justin Sampson wrote:
> Ooh, neat! I had asked this list whether something like that would be possible, right around the same time that issue was filed, and there was some heated debate around it:
> 
> http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/thread.html#13864
> 
> Exciting to see progress. :)

It's better, but still flaky.

http://mail.openjdk.java.net/pipermail/hotspot-dev/2017-January/025728.html

Andrew.


From jsampson at guidewire.com  Thu Mar 30 13:30:12 2017
From: jsampson at guidewire.com (Justin Sampson)
Date: Thu, 30 Mar 2017 17:30:12 +0000
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <ac430074-2606-2162-9033-1459cc1391cb@redhat.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
 <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
 <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>
 <287A3035-6AA2-4154-9249-BFF7EE253692@guidewire.com>
 <ac430074-2606-2162-9033-1459cc1391cb@redhat.com>
Message-ID: <CB9EBB07-1431-414F-A3DB-D2B3A9B22071@guidewire.com>

And apparently it doesn't work on Windows yet:

https://bugs.openjdk.java.net/browse/JDK-8067946

Details, details.

-Justin


On 3/30/17, 10:18 AM, "Andrew Haley" <aph at redhat.com> wrote:

    On 30/03/17 17:59, Justin Sampson wrote:
    > Ooh, neat! I had asked this list whether something like that would be possible, right around the same time that issue was filed, and there was some heated debate around it:
    > 
    > http://cs.oswego.edu/pipermail/concurrency-interest/2015-January/thread.html#13864
    > 
    > Exciting to see progress. :)
    
    It's better, but still flaky.
    
    http://mail.openjdk.java.net/pipermail/hotspot-dev/2017-January/025728.html
    
    Andrew.
    
    


From aph at redhat.com  Thu Mar 30 13:46:54 2017
From: aph at redhat.com (Andrew Haley)
Date: Thu, 30 Mar 2017 18:46:54 +0100
Subject: [concurrency-interest] hold lock thread in thread dump
In-Reply-To: <CB9EBB07-1431-414F-A3DB-D2B3A9B22071@guidewire.com>
References: <3958000a-ba21-fddf-7fbf-7bff0826e9e9@redhat.com>
 <C23FD92F-B873-4520-9B85-1505C467854F@gmail.com>
 <958edc50-d8b8-9855-201d-afeeaa2a608b@redhat.com>
 <9CA1CDE6-3E1D-4A0F-B44E-587956F3EB78@gmail.com>
 <c01dcd00-32f2-8ad7-f1bc-f91c0d51654f@redhat.com>
 <9949a9b1-ba6a-446b-8670-5f0a83d704c5@default>
 <28718292-0ABC-4633-B87D-E1863DB61C25@gmail.com>
 <028501d2a934$08a28d70$19e7a850$@aapt.net.au>
 <E2A620F9-AE27-46F5-9824-04B2848561F6@gmail.com>
 <1a6366c7-b3bc-3465-54b2-262a3a54b49e@redhat.com>
 <287A3035-6AA2-4154-9249-BFF7EE253692@guidewire.com>
 <ac430074-2606-2162-9033-1459cc1391cb@redhat.com>
 <CB9EBB07-1431-414F-A3DB-D2B3A9B22071@guidewire.com>
Message-ID: <19ee43c9-d0c2-80f1-27c0-f935fa465efa@redhat.com>

On 30/03/17 18:30, Justin Sampson wrote:
> And apparently it doesn't work on Windows yet:
> 
> https://bugs.openjdk.java.net/browse/JDK-8067946
> 
> Details, details.

Well, it doesn't really work anywhere if the protected method happens
to be inlined, which it often will be.  The test case in the HotSpot
testsuite solves the problem in a very nice way by disabling inlining.

Andrew.


