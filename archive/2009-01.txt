From wangbing.nudt at gmail.com  Mon Jan  5 04:24:18 2009
From: wangbing.nudt at gmail.com (bing wang)
Date: Mon, 5 Jan 2009 10:24:18 +0100
Subject: [concurrency-interest] 10 years later after Aglets ---the new techs
	for migration of Java Objects across JVMs
Message-ID: <3e257e530901050124r2b380cabr41148f06f77304c4@mail.gmail.com>

10 years later  after Aglets ---the Tech for migration of Java Objects
 across JVMs(Object level mobility)
Mobility and migration of Java object is a grundstein for  many others
,such as Mobile Agent and loadballance.
There have been lots of efforts towards the mobility of Java Object
,IBM's Aglets Architecture and ObjectSpace's Voyager System,ProActive
,to name a few. some are commercial software ,some are not maintained
anymore.
At the drawn of the Java 7 ,I would like to cast a brick on the
migration of Java Objects  across JVMs. what new insight and new
technics we have gained after ten years' advance?

I would mark some of Point I thought is important and raise some opent
questions that puzzled me .

I notice that all the ways falls in two catalogues, the way with the
modification of  the semantic of JVM   and the ways keeping the
semantics by introducing restriction to how the Object would looks
like.
I would like to focus on several concern of  the later.

one way to achieve the  migration is to exactly copy the state of the
Object .and create a new one with the state in the destination while
eradicating the original  in an eligant way . Eligance ,here ,means
that before and after the migration  , the Object should keep 2 kinds
of consistency: first , the consistency of the inside state  ,and
second,apears consistency  in the communication with other Objects
outside.
for example, a forwarder could help to forward the calls to the new
place and a naming service should tell others that he has change his
location.

1 treatment to the referenced objects of the object being migrated
      normally ,there could be three catologues for the referenced
objects   involved  in migreation
      in the  reference graph of the Object being migrated

    *       shared by all across all the JVM
    *       locally used by  one JVM
    *       by  the object itself

       refering to the location :  there could be 2 types of
references an object holds:
       remote reference and local reference
     Open Question:
             which reference need to be transferred by object copy
,and which only need to by reference copy?

2 the definition of the the state and consistency of the state:

         Open Questions:

         a what is state ?
         is the thread stack or the Register Context a necessary part
of the state(see Appedix1) ?
         or ,how do we elegantly pause the execution of a object to
hold the inner consisitency
         how the forwarder pointing to the destination from  the start
place to maintain the outer consistency?
         or , we introduce highlevel agreement to the semantic of the
object we want to migrate .

         b  something can not be migrate trivially: threads.


3  What is the  the sufficient and necessary wayto provide the feature
 of mobile Agent.
        Open Questions:
  a Does the java language (include the  concurrency solution and the
java memory model ) provide all the mechanism for the migration?
  b Is the ristriction in conducting a Object while keeping the semantic of Java
           I would like to take the restriction introduced by
ProActive (http://proactive.inria.fr/)as an example :

    *     no public member ,for we can only monitor the call of function
    *      A no-argument constructor is necessary to create the stub
class needed for communication:  prevent the making of the default
constructor :
    *       provide remote functionalities as public methods with
return types that can be subclassed and are serializable - Since the
stub is created through inheritance, the only methods it can use for
communication are the inherited public methods from the superclass.
The return types of the methods have to be subclassable and therefore
not final.
    *      class and the argument for the constructor need to be serializable .
    *      special callback such as afterMigration and beforeMigration.
    *      no direct access to field variables

4  ways for the state transportation:

     based on Serialization   :involving all the reference in a naive way
     based on the  Java Bean

          Thank you !

Appendix 1
in" Mobile Agents with Java: The Aglet API "(1998.)
Danny B. Lange  and Mitsuru Oshima argued that
No support for preservation and resumption of the execution state. It
is currently
impossible in Java to retrieve the full execution state of an object.
Information such as the
status of the program counter and frame stack is permanently forbidden
territory for Java
programs. Therefore, for a mobile agent to properly resume a
computation on a remote
host, it must rely on internal attribute values and external events to
direct it. An
embedded automaton can keep track of the agent's travels and ensure
that computations
are properly halted and properly resumed.



-- 
Wang,Bing
======================================================
Lehrstuhl Modellierung und Simulation
Institut f?r Informatik
Universit?t Rostock
Joachim-Jungius-Str. 10
18059 Rostock
http://wwwmosi.informatik.uni-rostock.de/

Original Affiliation
High Performance Simulation Group
School of Computer Science,
NUDT,Changsha Hunan 410073
P R China
http://www.yhsim.com/
======================================================


From dl at cs.oswego.edu  Tue Jan  6 10:08:17 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 06 Jan 2009 10:08:17 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
Message-ID: <496373E1.1060401@cs.oswego.edu>

Most of the promised updates and reorganization of jsr166y
for Java7 described last month are now in place.
Package jsr166y contains only those classes slated to
be included in Java7: TransferQueue, Phaser, and
the overhauled basic ForkJoin framework. These will
eventually be renamed again to be in Java7 java.util.concurrent.
Classes that didn't make it for inclusion (mainly
ParallelArray et al) are still available in
package extra166y.

ConcurrentReferenceHashMap is not yet included
but is due up next. Also, the proposed Fences
API cannot be included in jsr166y prereleases but
must await integration with Java7 java.util.concurrent.

The main changes in ForkJoin support managed
blocking and parallelism maintenance, which
in turn enables ForkJoinPool to be declared
as ExecutorService and ForkJoinTask as Future.
This also led to some method name changes
to conform to Executor conventions. (For example,
the method originally invoke, then forkJoin,
is now back to invoke :-) ForkJoinTask now
better supports extension, so only the two
most common flavors, RecursiveTask and RecursiveAction
are supplied -- others can now be added by those
wanting to introduce new styles of FJ processing
(although this needs better documentation).

See the usual places:
* API specs:  http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/
* jar file: http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166y.jar
* CVS sources: http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166y/

And see http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
for other links including extra166y package.

-Doug


From tim at peierls.net  Tue Jan  6 10:29:45 2009
From: tim at peierls.net (Tim Peierls)
Date: Tue, 6 Jan 2009 10:29:45 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
In-Reply-To: <496373E1.1060401@cs.oswego.edu>
References: <496373E1.1060401@cs.oswego.edu>
Message-ID: <63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>

On Tue, Jan 6, 2009 at 10:08 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> This also led to some method name changes to conform to Executor
> conventions. (For example, the method originally invoke, then forkJoin, is
> now back to invoke :-)


:-( Sorry to hear that. I argued for the name FJTask.forkJoin, because it is
self-explanatory, and I don't see how it violates Executor conventions.
FJTask.invoke() looks a lot like FJPool.invoke(FJTask), which is (subtly)
different.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090106/a25d9a0a/attachment.html>

From dl at cs.oswego.edu  Tue Jan  6 10:53:12 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 06 Jan 2009 10:53:12 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
In-Reply-To: <63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>
References: <496373E1.1060401@cs.oswego.edu>
	<63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>
Message-ID: <49637E68.8050308@cs.oswego.edu>

Tim Peierls wrote:
>
> :-( Sorry to hear that. 

Reasoning:
ForkJoinPool implements ExecutorService method
   invokeAll(Collection<Runnable>),
ForkJoinTask implements the analogous form
   invokeAll(Collection<ForkJoinTask>)
and also the var-arg version
   invokeAll(ForkJoinTask ...)
which is further specialized to the two-task case
   invokeAll(ForkJoinTask t1, ForkJoinTask t2)
So the specialization for the one-task case would be
   invokeAll(ForkJoinTask t)
or the less odd-sounding
   invoke(ForkJoinTask t)
or using more standard OO conventions
   t.invoke().
which differs from
   ForkJoinPool.invoke(ForkJoinTask t)
in that t.invoke() always begins execution in the
current thread, while FJP.invoke(t) might not (and
usually doesn't).

-Doug


From tim at peierls.net  Tue Jan  6 13:54:26 2009
From: tim at peierls.net (Tim Peierls)
Date: Tue, 6 Jan 2009 13:54:26 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
In-Reply-To: <49637E68.8050308@cs.oswego.edu>
References: <496373E1.1060401@cs.oswego.edu>
	<63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>
	<49637E68.8050308@cs.oswego.edu>
Message-ID: <63b4e4050901061054s479ea951ud6fb56d8e6553ce5@mail.gmail.com>

OK, thanks. I'll try playing with it to see if it still seems confusing.
--tim

On Tue, Jan 6, 2009 at 10:53 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> Tim Peierls wrote:
>
>>
>> :-( Sorry to hear that.
>>
>
> Reasoning:
> ForkJoinPool implements ExecutorService method
>  invokeAll(Collection<Runnable>),
> ForkJoinTask implements the analogous form
>  invokeAll(Collection<ForkJoinTask>)
> and also the var-arg version
>  invokeAll(ForkJoinTask ...)
> which is further specialized to the two-task case
>  invokeAll(ForkJoinTask t1, ForkJoinTask t2)
> So the specialization for the one-task case would be
>  invokeAll(ForkJoinTask t)
> or the less odd-sounding
>  invoke(ForkJoinTask t)
> or using more standard OO conventions
>  t.invoke().
> which differs from
>  ForkJoinPool.invoke(ForkJoinTask t)
> in that t.invoke() always begins execution in the
> current thread, while FJP.invoke(t) might not (and
> usually doesn't).
>
> -Doug
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090106/c1866376/attachment.html>

From dl at cs.oswego.edu  Wed Jan  7 11:11:14 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 07 Jan 2009 11:11:14 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
In-Reply-To: <49637E68.8050308@cs.oswego.edu>
References: <496373E1.1060401@cs.oswego.edu>
	<63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>
	<49637E68.8050308@cs.oswego.edu>
Message-ID: <4964D422.3010209@cs.oswego.edu>

> Tim Peierls wrote:
>>
>> :-( Sorry to hear that. 

I did a documentation improvement pass, including
a brief walkthrough of the join/invoke variants, and
also regularizing/moving methods that I had forgotten
to do before yesterdays's check-in. Let me know if
this helps.

http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ForkJoinTask.html

-Doug



From tim at peierls.net  Wed Jan  7 15:16:51 2009
From: tim at peierls.net (Tim Peierls)
Date: Wed, 7 Jan 2009 15:16:51 -0500
Subject: [concurrency-interest] jsr166y reorganization and updates
In-Reply-To: <4964D422.3010209@cs.oswego.edu>
References: <496373E1.1060401@cs.oswego.edu>
	<63b4e4050901060729i736b9cfn558badc000a5dd35@mail.gmail.com>
	<49637E68.8050308@cs.oswego.edu> <4964D422.3010209@cs.oswego.edu>
Message-ID: <63b4e4050901071216v5d011eeaxff2808529bdb73b7@mail.gmail.com>

It helps.
I think s/each others/each other's/ in the class comment.

--tim

On Wed, Jan 7, 2009 at 11:11 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> Tim Peierls wrote:
>>
>>>
>>> :-( Sorry to hear that.
>>>
>>
> I did a documentation improvement pass, including
> a brief walkthrough of the join/invoke variants, and
> also regularizing/moving methods that I had forgotten
> to do before yesterdays's check-in. Let me know if
> this helps.
>
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ForkJoinTask.html
>
> -Doug
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090107/7eafaa39/attachment.html>

From alarmnummer at gmail.com  Sat Jan 10 14:27:29 2009
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sat, 10 Jan 2009 20:27:29 +0100
Subject: [concurrency-interest] Reducing the amount of locking
Message-ID: <1466c1d60901101127x138eaa0at8b9a6b646d2de6a9@mail.gmail.com>

Hi All,

I'm currently playing with a heap implementation for an STM which in
essence is just a balanced tree (see Node object at the bottom of this
mail). One of the problems of building that tree is that the balancing
is quite expensive and if the number of changes is big, the system
can't process any other transactions.

So the goal is to make the period to process the transaction as short
as possible, and one of the ways to do that is to partition the tree
building, so that it can be processed in parallel and thereby reducing
the processing time:

My main question is: is there any way to reduce the amount of locking
needed in the BlockingPartitionBuilder? At the moment a single lock is
used for the placement of items and the taking of items. I have been
playing with some AtomicReferences to reduce the amount of locking,
but the system is going to be subject to deadlocks (missed signals).
So I tried this 'standard' solution first, but I'm wondering if there
is a better one.

=====================================================================

public final class ParallelSnapshotBuilder implements SnapshotBuilder {

    private final int partitionCount;
    private final PartitionBuilder[] builders;

    public ParallelSnapshotBuilder() {
        partitionCount = Runtime.getRuntime().availableProcessors();

        builders = new PartitionBuilder[partitionCount];
        for (int k = 0; k < partitionCount; k++)
            builders[k] = new BlockingPartitionBuilder();
    }

    public HeapSnapshot create(Content... changes) {
        forkBuildRoots(changes);
        Node[] roots = joinAndGetBuildRoots();
        return new PartitionedHeapSnapshot(roots);
    }

    private Node[] joinAndGetBuildRoots() {
        Node[] nodes = new Node[partitionCount];
        for (int k = 0; k < partitionCount; k++)
            nodes[k] = builders[k].joinAndGetBuildRoot();
        return nodes;
    }

    private void forkBuildRoots(Content... changes) {
        for (Content content : changes)
            getPartitionBuilder(content).forkBuildRoot(content);
    }

    private PartitionBuilder getPartitionBuilder(Content content) {
        int partition = getPartition(content);
        return builders[partition];
    }

    private int getPartition(Content content) {
        return (int) (content.getHandle() % partitionCount);
    }
}

=====================================================================

class BlockingPartitionBuilder implements PartitionBuilder {

    private final static Object TERMINATOR = new Object();

    private final Thread builderThread;

    private final Lock mainLock = new ReentrantLock();
    private final Condition contentAvailableCondition = mainLock.newCondition();
    private final Condition completedCondition = mainLock.newCondition();

    private TodoNode head;

    private volatile Node busyRoot;
    private volatile Node completedRoot;

    BlockingPartitionBuilder() {
        builderThread = new Thread(new BuildTask());
        builderThread.setDaemon(true);
        builderThread.start();
    }

    public void forkBuildRoot(Content content) {
        if (content == null) throw new NullPointerException();

        mainLock.lock();
        try {
            if (completedRoot != null) {
                busyRoot = completedRoot;
                completedRoot = null;
            }
            head = new TodoNode(head, content);
            contentAvailableCondition.signal();
        } finally {
            mainLock.unlock();
        }
    }

   public Node joinAndGetBuildRoot() {
        if (completedRoot == null) {
            mainLock.lock();
            try {
                head = new TodoNode(head, TERMINATOR);
                while (completedRoot == null)
                    completedCondition.awaitUninterruptibly();
            } finally {
                mainLock.unlock();
            }
        }
        return completedRoot;
    }

    private class BuildTask implements Runnable {

        public void run() {
            while (true)
                processItemsForSingleCommit();
        }

        private void process(Content content) {
            if (busyRoot == null)
                busyRoot = new Node(content);
            else
                busyRoot = busyRoot.createBalanced(content);
        }

        private TodoNode retrieveItems() {
            mainLock.lock();
            try {
                while (head == null)
                    contentAvailableCondition.awaitUninterruptibly();
                TodoNode result = head;
                head = null;
                return result;
            } finally {
                mainLock.unlock();
            }
        }

        private void processItemsForSingleCommit() {
            do {
                TodoNode head = retrieveItems();
                do {
                    if (head.content == TERMINATOR) {
                        mainLock.lock();
                        try {
                            completedRoot = busyRoot;
                            completedCondition.signal();
                        } finally {
                            mainLock.unlock();
                        }
                    } else {
                        process((Content) head.content);
                    }
                    head = head.next;
                } while (head != null);
            } while (completedRoot == null);
        }
    }

    private static class TodoNode {
        final TodoNode next;
        final Object content;

        TodoNode(TodoNode next, Object content) {
            this.next = next;
            this.content = content;
        }
    }
}

=====================================================================

public class Node {

    public static int height(Node node) {
        return node == null ? 0 : node.height;
    }

    private static final int COMPARE_SPOT_ON = 0;
    private static final int COMPARE_GO_RIGHT = 1;
    private static final int COMPARE_GO_LEFT = -1;

    private final Content content;
    private final Node left;
    private final Node right;
    private final int height;

    public Node(Content content) {
        this(content, null, null);
    }

    public Node(Content content, Node left, Node right) {
        this.content = content;
        this.left = left;
        this.right = right;
        this.height = max(height(left), height(right)) + 1;
    }

    public Content getContent() {
        return content;
    }

    public Node singleRotateRight() {
        if (left == null)
            throw new IllegalStateException("to do a right rotate, the
left field can't be null");

        Node q = this;
        Node p = q.left;
        Node a = p.left;
        Node b = p.right;
        Node c = q.right;

        Node qNew = new Node(q.content, b, c);
        return new Node(p.content, a, qNew);
    }

    public Node doubleRotateRight() {
        Node newLeft = left.singleRotateLeft();
        return new Node(content, newLeft, right).singleRotateRight();
    }

    public Node singleRotateLeft() {
        if (right == null)
            throw new IllegalStateException("to do a left rotate, the
right field can't be null");

        Node p = this;
        Node q = p.right;
        Node a = p.left;
        Node b = q.left;
        Node c = q.right;
        Node pNew = new Node(p.content, a, b);
        return new Node(q.content, pNew, c);
    }

    public Node doubleRotateLeft() {
        Node newRight = right.singleRotateRight();
        return new Node(content, left, newRight).singleRotateLeft();
    }

    public Node createBalanced(Content change) {
        Node unbalanced = createUnbalanced(change);
        return unbalanced.balance();
    }

    public Node balance() {
        int balanceFactor = balanceFactor();
        switch (balanceFactor) {
            case 0:
                return this;
            case 1:
                return this;
            case -1:
                return this;
            case 2:
                //het is een right/right of een right/left case
                //is the right right heavy, or left heavy
                int rightBalanceFactor = right.balanceFactor();
                if (rightBalanceFactor == 1)
                    return this.singleRotateLeft();
                else
                    return this.doubleRotateLeft();
            case -2:
                //is the left/left  heavy, or left/right heavy
                int leftBalanceFactor = left.balanceFactor();
                if (leftBalanceFactor == -1)
                    return this.singleRotateRight();
                else
                    return this.doubleRotateRight();
            default:
                throw new RuntimeException("unhandeled balanceFactor:
" + balanceFactor);
        }
    }

    public Node createUnbalanced(Content change) {
        int compare = compare(change.getHandle());
        switch (compare) {
            case COMPARE_SPOT_ON:
                //since the left and right trees are balanced, the new
node will be balanced.
                return new Node(change, left, right);
            case COMPARE_GO_RIGHT:
                Node newRight;
                if (right == null)
                    newRight = new Node(change, null, null);
                else
                    newRight = right.createBalanced(change);
                return new Node(content, left, newRight);
            case COMPARE_GO_LEFT:
                Node newLeft;
                if (left == null)
                    newLeft = new Node(change, null, null);
                else
                    newLeft = left.createBalanced(change);
                return new Node(content, newLeft, right);
            default:
                throw new RuntimeException("unhandeled compare " + compare);
        }
    }

    public int size() {
        int size = 1;
        if (right != null)
            size += right.size();
        if (left != null)
            size += left.size();
        return size;
    }

    public int balanceFactor() {
        return height(right) - height(left);
    }

    public int compare(long otherHandle) {
        if (content.getHandle() == otherHandle) {
            return COMPARE_SPOT_ON;
        } else if (content.getHandle() < otherHandle) {
            return COMPARE_GO_RIGHT;
        } else {
            return COMPARE_GO_LEFT;
        }
    }

    public Node find(long handle) {
        Node node = this;
        do {
            switch (node.compare(handle)) {
                case COMPARE_SPOT_ON:
                    return node;
                case COMPARE_GO_RIGHT:
                    node = node.right;
                    break;
                case COMPARE_GO_LEFT:
                    node = node.left;
                    break;
                default:
                    throw new RuntimeException("unhandled case");
            }
        } while (node != null);

        return null;
    }

}

From tim at peierls.net  Sun Jan 11 12:45:24 2009
From: tim at peierls.net (Tim Peierls)
Date: Sun, 11 Jan 2009 12:45:24 -0500
Subject: [concurrency-interest] Reducing the amount of locking
In-Reply-To: <1466c1d60901101127x138eaa0at8b9a6b646d2de6a9@mail.gmail.com>
References: <1466c1d60901101127x138eaa0at8b9a6b646d2de6a9@mail.gmail.com>
Message-ID: <63b4e4050901110945u484211d3w8cd24f8d45e1b167@mail.gmail.com>

I don't fully understand the code, so I can't answer your question directly,
but it sure seems like a perfect application for map-reduce using
extra166y's ParallelArray:

http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/ParallelArray.html

With a few modifications to your Node class (providing an EMPTY Node
instance and adding a mergeBalanced method that merges two balanced Nodes),
your code could be as simple as this, with no locking whatsoever:

import static extra166y.Ops.Op;
import static extra166y.Ops.Reducer;
import static extra166y.ParallelArray.createUsingHandoff;
import static extra166y.ParallelArray.defaultExecutor;

public final class ParallelArraySnapshotBuilder implements SnapshotBuilder {

    public HeapSnapshot create(Content... changes) {
        Node root = createUsingHandoff(changes, defaultExecutor())
            .withMapping(contentToNode)
            .reduce(mergeBalanced, Node.EMPTY);

        return new PartitionedHeapSnapshot(new Node[] { root }); // or
something more direct
    }

    private static Op<Content, Node> contentToNode = new Op<Content, Node>()
{
        public Node op(Content content) { return new Node(content); }
    };

    private static Reducer<Node> mergeBalanced = new Reducer<Node>() {
        public Node op(Node a, Node b) { return a.mergeBalanced(b); }
    };
}

That aside, are you sure your use of volatile for busyRoot and completedRoot
is correct? I'd worry about the places where they are tested for nullity
without the lock being held. Even if it is correct, it's not easy to see
that it is, which for me counts as a bug.

--tim


On Sat, Jan 10, 2009 at 2:27 PM, Peter Veentjer <alarmnummer at gmail.com>wrote:

> Hi All,
>
> I'm currently playing with a heap implementation for an STM which in
> essence is just a balanced tree (see Node object at the bottom of this
> mail). One of the problems of building that tree is that the balancing
> is quite expensive and if the number of changes is big, the system
> can't process any other transactions.
>
> So the goal is to make the period to process the transaction as short
> as possible, and one of the ways to do that is to partition the tree
> building, so that it can be processed in parallel and thereby reducing
> the processing time:
>
> My main question is: is there any way to reduce the amount of locking
> needed in the BlockingPartitionBuilder? At the moment a single lock is
> used for the placement of items and the taking of items. I have been
> playing with some AtomicReferences to reduce the amount of locking,
> but the system is going to be subject to deadlocks (missed signals).
> So I tried this 'standard' solution first, but I'm wondering if there
> is a better one.
>
> =====================================================================
>
> public final class ParallelSnapshotBuilder implements SnapshotBuilder {
>
>    private final int partitionCount;
>    private final PartitionBuilder[] builders;
>
>    public ParallelSnapshotBuilder() {
>        partitionCount = Runtime.getRuntime().availableProcessors();
>
>        builders = new PartitionBuilder[partitionCount];
>        for (int k = 0; k < partitionCount; k++)
>            builders[k] = new BlockingPartitionBuilder();
>    }
>
>    public HeapSnapshot create(Content... changes) {
>        forkBuildRoots(changes);
>        Node[] roots = joinAndGetBuildRoots();
>        return new PartitionedHeapSnapshot(roots);
>    }
>
>    private Node[] joinAndGetBuildRoots() {
>        Node[] nodes = new Node[partitionCount];
>        for (int k = 0; k < partitionCount; k++)
>            nodes[k] = builders[k].joinAndGetBuildRoot();
>        return nodes;
>    }
>
>    private void forkBuildRoots(Content... changes) {
>        for (Content content : changes)
>            getPartitionBuilder(content).forkBuildRoot(content);
>    }
>
>    private PartitionBuilder getPartitionBuilder(Content content) {
>        int partition = getPartition(content);
>        return builders[partition];
>    }
>
>    private int getPartition(Content content) {
>        return (int) (content.getHandle() % partitionCount);
>    }
> }
>
> =====================================================================
>
> class BlockingPartitionBuilder implements PartitionBuilder {
>
>    private final static Object TERMINATOR = new Object();
>
>    private final Thread builderThread;
>
>    private final Lock mainLock = new ReentrantLock();
>    private final Condition contentAvailableCondition =
> mainLock.newCondition();
>    private final Condition completedCondition = mainLock.newCondition();
>
>    private TodoNode head;
>
>    private volatile Node busyRoot;
>    private volatile Node completedRoot;
>
>    BlockingPartitionBuilder() {
>        builderThread = new Thread(new BuildTask());
>        builderThread.setDaemon(true);
>        builderThread.start();
>    }
>
>    public void forkBuildRoot(Content content) {
>        if (content == null) throw new NullPointerException();
>
>        mainLock.lock();
>        try {
>            if (completedRoot != null) {
>                busyRoot = completedRoot;
>                completedRoot = null;
>            }
>            head = new TodoNode(head, content);
>            contentAvailableCondition.signal();
>        } finally {
>            mainLock.unlock();
>        }
>    }
>
>   public Node joinAndGetBuildRoot() {
>        if (completedRoot == null) {
>            mainLock.lock();
>            try {
>                head = new TodoNode(head, TERMINATOR);
>                while (completedRoot == null)
>                    completedCondition.awaitUninterruptibly();
>            } finally {
>                mainLock.unlock();
>            }
>        }
>        return completedRoot;
>    }
>
>    private class BuildTask implements Runnable {
>
>        public void run() {
>            while (true)
>                processItemsForSingleCommit();
>        }
>
>        private void process(Content content) {
>            if (busyRoot == null)
>                busyRoot = new Node(content);
>            else
>                busyRoot = busyRoot.createBalanced(content);
>        }
>
>        private TodoNode retrieveItems() {
>            mainLock.lock();
>            try {
>                while (head == null)
>                    contentAvailableCondition.awaitUninterruptibly();
>                TodoNode result = head;
>                head = null;
>                return result;
>            } finally {
>                mainLock.unlock();
>            }
>        }
>
>        private void processItemsForSingleCommit() {
>            do {
>                TodoNode head = retrieveItems();
>                do {
>                    if (head.content == TERMINATOR) {
>                        mainLock.lock();
>                        try {
>                            completedRoot = busyRoot;
>                            completedCondition.signal();
>                        } finally {
>                            mainLock.unlock();
>                        }
>                    } else {
>                        process((Content) head.content);
>                    }
>                    head = head.next;
>                } while (head != null);
>            } while (completedRoot == null);
>        }
>    }
>
>    private static class TodoNode {
>        final TodoNode next;
>        final Object content;
>
>        TodoNode(TodoNode next, Object content) {
>            this.next = next;
>            this.content = content;
>        }
>    }
> }
>
> =====================================================================
>
> public class Node {
>
>    public static int height(Node node) {
>        return node == null ? 0 : node.height;
>    }
>
>    private static final int COMPARE_SPOT_ON = 0;
>    private static final int COMPARE_GO_RIGHT = 1;
>    private static final int COMPARE_GO_LEFT = -1;
>
>    private final Content content;
>    private final Node left;
>    private final Node right;
>    private final int height;
>
>    public Node(Content content) {
>        this(content, null, null);
>    }
>
>    public Node(Content content, Node left, Node right) {
>        this.content = content;
>        this.left = left;
>        this.right = right;
>        this.height = max(height(left), height(right)) + 1;
>    }
>
>    public Content getContent() {
>        return content;
>    }
>
>    public Node singleRotateRight() {
>        if (left == null)
>            throw new IllegalStateException("to do a right rotate, the
> left field can't be null");
>
>        Node q = this;
>        Node p = q.left;
>        Node a = p.left;
>        Node b = p.right;
>        Node c = q.right;
>
>        Node qNew = new Node(q.content, b, c);
>        return new Node(p.content, a, qNew);
>    }
>
>    public Node doubleRotateRight() {
>        Node newLeft = left.singleRotateLeft();
>        return new Node(content, newLeft, right).singleRotateRight();
>    }
>
>    public Node singleRotateLeft() {
>        if (right == null)
>            throw new IllegalStateException("to do a left rotate, the
> right field can't be null");
>
>        Node p = this;
>        Node q = p.right;
>        Node a = p.left;
>        Node b = q.left;
>        Node c = q.right;
>        Node pNew = new Node(p.content, a, b);
>        return new Node(q.content, pNew, c);
>    }
>
>    public Node doubleRotateLeft() {
>        Node newRight = right.singleRotateRight();
>        return new Node(content, left, newRight).singleRotateLeft();
>    }
>
>    public Node createBalanced(Content change) {
>        Node unbalanced = createUnbalanced(change);
>        return unbalanced.balance();
>    }
>
>    public Node balance() {
>        int balanceFactor = balanceFactor();
>        switch (balanceFactor) {
>            case 0:
>                return this;
>            case 1:
>                return this;
>            case -1:
>                return this;
>            case 2:
>                //het is een right/right of een right/left case
>                //is the right right heavy, or left heavy
>                int rightBalanceFactor = right.balanceFactor();
>                if (rightBalanceFactor == 1)
>                    return this.singleRotateLeft();
>                else
>                    return this.doubleRotateLeft();
>            case -2:
>                //is the left/left  heavy, or left/right heavy
>                int leftBalanceFactor = left.balanceFactor();
>                if (leftBalanceFactor == -1)
>                    return this.singleRotateRight();
>                else
>                    return this.doubleRotateRight();
>            default:
>                throw new RuntimeException("unhandeled balanceFactor:
> " + balanceFactor);
>        }
>    }
>
>    public Node createUnbalanced(Content change) {
>        int compare = compare(change.getHandle());
>        switch (compare) {
>            case COMPARE_SPOT_ON:
>                //since the left and right trees are balanced, the new
> node will be balanced.
>                return new Node(change, left, right);
>            case COMPARE_GO_RIGHT:
>                Node newRight;
>                if (right == null)
>                    newRight = new Node(change, null, null);
>                else
>                    newRight = right.createBalanced(change);
>                return new Node(content, left, newRight);
>            case COMPARE_GO_LEFT:
>                Node newLeft;
>                if (left == null)
>                    newLeft = new Node(change, null, null);
>                else
>                    newLeft = left.createBalanced(change);
>                return new Node(content, newLeft, right);
>            default:
>                throw new RuntimeException("unhandeled compare " + compare);
>        }
>    }
>
>    public int size() {
>        int size = 1;
>        if (right != null)
>            size += right.size();
>        if (left != null)
>            size += left.size();
>        return size;
>    }
>
>    public int balanceFactor() {
>        return height(right) - height(left);
>    }
>
>    public int compare(long otherHandle) {
>        if (content.getHandle() == otherHandle) {
>            return COMPARE_SPOT_ON;
>        } else if (content.getHandle() < otherHandle) {
>            return COMPARE_GO_RIGHT;
>        } else {
>            return COMPARE_GO_LEFT;
>        }
>    }
>
>    public Node find(long handle) {
>        Node node = this;
>        do {
>            switch (node.compare(handle)) {
>                case COMPARE_SPOT_ON:
>                    return node;
>                case COMPARE_GO_RIGHT:
>                    node = node.right;
>                    break;
>                case COMPARE_GO_LEFT:
>                    node = node.left;
>                    break;
>                default:
>                    throw new RuntimeException("unhandled case");
>            }
>        } while (node != null);
>
>        return null;
>    }
>
> }
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090111/56a90783/attachment-0001.html>

From dl at cs.oswego.edu  Mon Jan 12 12:31:09 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 12 Jan 2009 12:31:09 -0500
Subject: [concurrency-interest] ThreadLocalRandom
Message-ID: <496B7E5D.90503@cs.oswego.edu>


As probably the final refactoring pass on Java7 versions of ForkJoin etc
the thread-local random generator was pulled out into a stand-alone class.
Class ThreadLocalRandom is useful in most situations where people use
java.util.Random across multiple threads. It is a subclass of Random,
but has no constructor -- instead a static "current()" method to
get the one for the current thread. It also doesn't let you change
the seed. (So people who need thread-local generators with explicit
seed control can't use it.)

The main reason for using it is performance, including performance
testing. Using a contended shared Random will often be 10X slower,
and mask the performance differences you are actually looking for.
(Some SPEC benchmarks have had this problem.)

See:
http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ThreadLocalRandom.html

Comments welcome.

Also, as we move closer to jdk7 (openjdk) integration,
anyone wanting to help with code or documentation reviews
ot testing might want to take a look. See links from
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

-Doug

From tim at peierls.net  Mon Jan 12 13:29:54 2009
From: tim at peierls.net (Tim Peierls)
Date: Mon, 12 Jan 2009 13:29:54 -0500
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <496B7E5D.90503@cs.oswego.edu>
References: <496B7E5D.90503@cs.oswego.edu>
Message-ID: <63b4e4050901121029s737263fn66ece3254219b46e@mail.gmail.com>

Maybe say something about using it in ForkJoin stuff, now that you've pulled
it out of there?

--tim

On Mon, Jan 12, 2009 at 12:31 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> As probably the final refactoring pass on Java7 versions of ForkJoin etc
> the thread-local random generator was pulled out into a stand-alone class.
> Class ThreadLocalRandom is useful in most situations where people use
> java.util.Random across multiple threads. It is a subclass of Random,
> but has no constructor -- instead a static "current()" method to
> get the one for the current thread. It also doesn't let you change
> the seed. (So people who need thread-local generators with explicit
> seed control can't use it.)
>
> The main reason for using it is performance, including performance
> testing. Using a contended shared Random will often be 10X slower,
> and mask the performance differences you are actually looking for.
> (Some SPEC benchmarks have had this problem.)
>
> See:
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ThreadLocalRandom.html
>
> Comments welcome.
>
> Also, as we move closer to jdk7 (openjdk) integration,
> anyone wanting to help with code or documentation reviews
> ot testing might want to take a look. See links from
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090112/f6dfef19/attachment.html>

From kimo at webnetic.net  Mon Jan 12 22:23:02 2009
From: kimo at webnetic.net (kimo)
Date: Mon, 12 Jan 2009 19:23:02 -0800
Subject: [concurrency-interest] in case it hasn't been considered as more
	features are added to 166
Message-ID: <ef80160b0901121923v2196fe45q705d1d7e4d3436@mail.gmail.com>

Video here:
http://www.infoq.com/presentations/effective-api-design

How to Design a Good API & Why it Matters

Posted by *Joshua Bloch* on Nov 21, 2006 06:00 AM
Community Architecture<http://www.infoq.com/architecture;jsessionid=BFA4CB98F677293152EE016A47EC89B4>
, Java<http://www.infoq.com/java;jsessionid=BFA4CB98F677293152EE016A47EC89B4>
 Topics Programming<http://www.infoq.com/Programming;jsessionid=BFA4CB98F677293152EE016A47EC89B4>
 Tags JavaPolis<http://www.infoq.com/javapolis;jsessionid=BFA4CB98F677293152EE016A47EC89B4>
*Summary*
A well-written API can be a great asset to the organization that wrote it
and to all that use it. Given the importance of good API design,
surprisingly little has been written on the subject. In this talk (recorded
at Javapolis), Java library designer Joshua Bloch teaches how to design good
APIs, with many examples of what good and bad APIs look like.

*Bio*
Joshua Bloch is a Principal Engineer at Google. He led the design and
implementation of numerous Java platform features, including the Java
Collections Framework. He is the author of the Jolt Award-winning book
Effective Java. He holds a Ph.D. in Computer Science from Carnegie-Mellon
University and a B.S. in Computer Science from Columbia.

*About the conference*
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090112/ec16e907/attachment.html>

From jeremy.manson at gmail.com  Tue Jan 13 01:26:00 2009
From: jeremy.manson at gmail.com (Jeremy Manson)
Date: Mon, 12 Jan 2009 22:26:00 -0800
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <496B7E5D.90503@cs.oswego.edu>
References: <496B7E5D.90503@cs.oswego.edu>
Message-ID: <1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>

This seems a little weirdly backwards to me (although I'm sure you had
a good reason to do it this way).  Given that (I assume) you can't
change the class hierarchy to add a superclass for Random, why didn't
you extract the actual random number generation logic into a delegate
class and have both Random and ThreadLocalRandom point to that class?

Jeremy

On Mon, Jan 12, 2009 at 9:31 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
> As probably the final refactoring pass on Java7 versions of ForkJoin etc
> the thread-local random generator was pulled out into a stand-alone class.
> Class ThreadLocalRandom is useful in most situations where people use
> java.util.Random across multiple threads. It is a subclass of Random,
> but has no constructor -- instead a static "current()" method to
> get the one for the current thread. It also doesn't let you change
> the seed. (So people who need thread-local generators with explicit
> seed control can't use it.)
>
> The main reason for using it is performance, including performance
> testing. Using a contended shared Random will often be 10X slower,
> and mask the performance differences you are actually looking for.
> (Some SPEC benchmarks have had this problem.)
>
> See:
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ThreadLocalRandom.html
>
> Comments welcome.
>
> Also, as we move closer to jdk7 (openjdk) integration,
> anyone wanting to help with code or documentation reviews
> ot testing might want to take a look. See links from
> http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
>
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From josh at bloch.us  Tue Jan 13 02:02:41 2009
From: josh at bloch.us (Joshua Bloch)
Date: Mon, 12 Jan 2009 23:02:41 -0800
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
References: <496B7E5D.90503@cs.oswego.edu>
	<1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
Message-ID: <b097ac510901122302s2edab329rb528c17a4f1ea1d5@mail.gmail.com>

If you're going to go that route, make it an interface (which it should have
been in the first place).  Then Random, SecureRandom, and ThreadLocalRandom
can implement it.  And we can add static factories to return high-quality
PRNGs instead of the not-quite-state-of-the-art PRNG specified by
java.util.Random.  Of course this would have been more effective if we'd
done it in 1997 but c'est la vie.
         Josh

On Mon, Jan 12, 2009 at 10:26 PM, Jeremy Manson <jeremy.manson at gmail.com>wrote:

> This seems a little weirdly backwards to me (although I'm sure you had
> a good reason to do it this way).  Given that (I assume) you can't
> change the class hierarchy to add a superclass for Random, why didn't
> you extract the actual random number generation logic into a delegate
> class and have both Random and ThreadLocalRandom point to that class?
>
> Jeremy
>
> On Mon, Jan 12, 2009 at 9:31 AM, Doug Lea <dl at cs.oswego.edu> wrote:
> >
> > As probably the final refactoring pass on Java7 versions of ForkJoin etc
> > the thread-local random generator was pulled out into a stand-alone
> class.
> > Class ThreadLocalRandom is useful in most situations where people use
> > java.util.Random across multiple threads. It is a subclass of Random,
> > but has no constructor -- instead a static "current()" method to
> > get the one for the current thread. It also doesn't let you change
> > the seed. (So people who need thread-local generators with explicit
> > seed control can't use it.)
> >
> > The main reason for using it is performance, including performance
> > testing. Using a contended shared Random will often be 10X slower,
> > and mask the performance differences you are actually looking for.
> > (Some SPEC benchmarks have had this problem.)
> >
> > See:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ThreadLocalRandom.html
> >
> > Comments welcome.
> >
> > Also, as we move closer to jdk7 (openjdk) integration,
> > anyone wanting to help with code or documentation reviews
> > ot testing might want to take a look. See links from
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > -Doug
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090112/e40fb934/attachment-0001.html>

From jdmarshall at gmail.com  Tue Jan 13 02:07:46 2009
From: jdmarshall at gmail.com (jason marshall)
Date: Mon, 12 Jan 2009 23:07:46 -0800
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
References: <496B7E5D.90503@cs.oswego.edu>
	<1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
Message-ID: <3cf41bb90901122307p411d5c75h23666b657d94fb16@mail.gmail.com>

In what situation you would intentionally share a single Random object among
multiple threads?

Or perhaps to put it another way, what makes a Random instance any more
special than the dozens of other objects I'm likely to be accidentally
sharing between threads, that I'd want to solve the problem differently than
I would the other 11 cases?

Thanks,
Jason


On Mon, Jan 12, 2009 at 10:26 PM, Jeremy Manson <jeremy.manson at gmail.com>wrote:

> This seems a little weirdly backwards to me (although I'm sure you had
> a good reason to do it this way).  Given that (I assume) you can't
> change the class hierarchy to add a superclass for Random, why didn't
> you extract the actual random number generation logic into a delegate
> class and have both Random and ThreadLocalRandom point to that class?
>
> Jeremy
>
> On Mon, Jan 12, 2009 at 9:31 AM, Doug Lea <dl at cs.oswego.edu> wrote:
> >
> > As probably the final refactoring pass on Java7 versions of ForkJoin etc
> > the thread-local random generator was pulled out into a stand-alone
> class.
> > Class ThreadLocalRandom is useful in most situations where people use
> > java.util.Random across multiple threads. It is a subclass of Random,
> > but has no constructor -- instead a static "current()" method to
> > get the one for the current thread. It also doesn't let you change
> > the seed. (So people who need thread-local generators with explicit
> > seed control can't use it.)
> >
> > The main reason for using it is performance, including performance
> > testing. Using a contended shared Random will often be 10X slower,
> > and mask the performance differences you are actually looking for.
> > (Some SPEC benchmarks have had this problem.)
> >
> > See:
> >
> http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/ThreadLocalRandom.html
> >
> > Comments welcome.
> >
> > Also, as we move closer to jdk7 (openjdk) integration,
> > anyone wanting to help with code or documentation reviews
> > ot testing might want to take a look. See links from
> > http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
> >
> > -Doug
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
- Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090112/9f64f835/attachment.html>

From dl at cs.oswego.edu  Tue Jan 13 07:09:38 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 13 Jan 2009 07:09:38 -0500
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
References: <496B7E5D.90503@cs.oswego.edu>
	<1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
Message-ID: <496C8482.6000706@cs.oswego.edu>

Jeremy Manson wrote:
> This seems a little weirdly backwards to me (although I'm sure you had
> a good reason to do it this way).  Given that (I assume) you can't
> change the class hierarchy to add a superclass for Random, why didn't
> you extract the actual random number generation logic into a delegate
> class and have both Random and ThreadLocalRandom point to that class?
> 

Internally, there are two small but important differences
between Random and ThreadLocalRandom:

(1) ThreadLocalRandom does not need to use locking or atomics in
the base seed update method, next(bits). Random must and does.

(2) As a heuristic (but a very noticeably effective one),
ThreadLocalRandom "protects" its cache line by adding some
padding around seed. This is more useful than you might
guess -- it counteracts tendency of garbage collectors
to relocate instances of the same class adjacently in memory,
which would otherwise cause the ThreadLocalRandoms conceptually
owned by different threads to physically interfere with each other.

But to answer your question, the reason for not
delegating the update logic is that the main pseudorandom
update step is only one line of code. It's not worth the
code bulk or performance overhead that would be needed to
encapsulate it to be usable in atomic vs direct updates etc. See
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166y/ThreadLocalRandom.java?view=log

-Doug

From dl at cs.oswego.edu  Tue Jan 13 07:30:41 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 13 Jan 2009 07:30:41 -0500
Subject: [concurrency-interest] ThreadLocalRandom
In-Reply-To: <3cf41bb90901122307p411d5c75h23666b657d94fb16@mail.gmail.com>
References: <496B7E5D.90503@cs.oswego.edu>	<1631da7d0901122226s5e517b08n6d2892d7801ae34c@mail.gmail.com>
	<3cf41bb90901122307p411d5c75h23666b657d94fb16@mail.gmail.com>
Message-ID: <496C8971.1020407@cs.oswego.edu>

jason marshall wrote:
> In what situation you would intentionally share a single Random object 
> among multiple threads?

Right. We all know this. But apparently many people look at
Random class, notice that it is thread-safe, and decide to
use a global one. And there are a few cases
where it is a reasonable choice - for example when
creating a static Random that provides seeds for local ones.
(ConcurrentSkipListMap does something along these lines.)

But we'd rather not penalize people who use Random the
normally best way, thread-locally, with crummy performance
(see my last mail).

> 
> Or perhaps to put it another way, what makes a Random instance any more 
> special than the dozens of other objects I'm likely to be accidentally 
> sharing between threads, that I'd want to solve the problem differently 
> than I would the other 11 cases?
> 

Random is somewhat special in that (1) overhead and contention
can cost a lot more than the underlying functionality (2) Many
programs that use Random use it a lot, so it is a known performance
bottleneck.

You are right that some programs out there include other classes
with similar problems. But we don't know what classes these are.
We can at least address the ones we know about.

-Doug


From dl at cs.oswego.edu  Tue Jan 13 10:05:20 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 13 Jan 2009 10:05:20 -0500
Subject: [concurrency-interest] Java7 Fences API
In-Reply-To: <C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
Message-ID: <496CADB0.3020605@cs.oswego.edu>

[This is initially CCed to concurrency-interest list as an FYI,
but please direct followups to the JMM list only.]

The basic JSR133 JMM scheme provides three kinds of
underlying ordering constaints, that are tied to variable
declarations -- read-volatile, write-volatile, and
write-final (aka write-release, aka publish, aka lazy-set),
or for stand-alone AtomicX objects.

This turns out not to mesh very well with the development of
core concurrent algorithms (like the ones I tend to
implement), where you often need these special flavors of
reads and writes on an occasional basis, which is currently
either impossible or insensible to achieve.  As an example,
the performance sensitive queues underlying ForkJoin
require some critical write-releases of
variables/array-slots during ownership transfer.  These are
slightly more expensive than normal (non-volatile/final)
writes but much cheaper (in this context) than full
write-volatile.

These also come into play in less esoteric usages. It is
very common to want to arrange a write-release to safely
publish a reference that could not be declared "final" for
one reason or another (for example because initialization
occurs in a callback).

Today, these usages cannot even be expressed without
cheating -- using the defacto-standard Unsafe API, which
truly is unsafe to use, so we really don't want people doing
this.  Things were not so bad when I and maybe 5 other
people were the only ones who cheated in this way, but more
and more people find that it is the only way to do it, so
do. Google reports estimated 8460 hits on "sun.misc.unsafe",
which probably corresponds to at least hundreds of
usages. Not good.  (Also, there are a couple of cases that
the current Unsafe API doesn't include, but should be in
place for Java7.)

In the recent C++0x standard, this kind of usage was
addressed by allowing per-usage modes on new read and write
methods. (And further, supporting more than the three modes
considered here, but I don't think we need to introduce more
for Java.)

We can't do this in Java, because Java does not support
call-by-reference. We cannot introduce an API with methods
that would be used like (using C addressof "&"):
   writeVolatile(&aField, aValue)
   ...

The closest you can come to this in Java is to include
similar methods in java.lang.reflect.{Field,Array}.  This is
an option, but not a very nice one. Even when optimized as
well as they can be on good JVMs, there is still enough
overhead to defeat the goals of using such methods.

Another tactic along these lines would be to lift
restrictions about volatileness inside
j.u.c.atomic.AtomicXFieldUpdaters, and similarly for array
versions. However, these encounter the same overhead
problem: They require internal dynamic type checks that are
(sometimes) tolerable for heavy operations like
compareAndSet (CAS) and writeVolatile, but surely not for
the above. (And stay tuned for some possible improvements in
these for CAS.)

So, after years of resisting the idea, my current conclusion
is that we need to stop wishing for a miraculous solution to
lack of call-by-ref, and instead allow developers to roll
their own out of the raw ingredients -- fences. There are
three kinds of fences that come into play here, best
illustrated by their usages in the above constructions for
some field/slot v, and local variable/expression r.  First
illustrated with argumentless fence methods:

readVolatile:  r = v; postLoadFence();
writeVolatile: preStoreFence(); v = r; postStorePreLoadFence();
writeFinal:    preStoreFence(); v = r;
   where {writeRelease, lazySet, publish} are same as writeFinal

JMM note: Recall that "final", and the above implementation
of writeFinal is "one-sided" -- in normal use it does not
require a readFinal counterpart. But if another thread has
already seen the ref (because of a leak before publishing)
then pretty much anything is allowed to happen. Here, it
would be allowed, but not required, to use readVolatile to
read it, which improves range of use a bit.

API note: The method names are intentionally clunky to avoid
the common mistake of putting read-fences before, not after,
reads, which sometimes intuitively looks correct but isn't,
and similarly for writes.  We've seen "experts" discussing
fences make this mistake, which suitable naming seems to fix.

The argument-ful versions of these methods allow tighter
specifications of effects, and closer correspondance to
typical read/write forms, by mentioning the object being
read/written.  These may enable a compiler to generate
better code by being less conservative about effects. Using
these versions to read a field of object x, you can do
   r = x.field; postLoadFence(x);
or even
   r = x.field; postLoadFence(x, xField);
where xField is the result of reflectively looking up
X.field.  These are optional in the Fences API because the
gain in precision is not always (or even usually) worth the
overhead of supplying this information.

All together, the Fences API seems to be the best of a bad
set of options. It provides the necessary capabilities, and,
as awkward/ugly as it is, it is vastly better than
continuing to implicitly invite developers to use Unsafe.

Also, their existence might drive better kinds of support
layered on top of them. Imperfect approaches to "nicer"
supprt include:

1. Macros. If there were a standard Java Macro preprocessor,
someone might introduce some (using C style for now):
    #define publish(v, r) preStoreFence(); v = r
Although even this could use C-like comma operator so it is
one expression. (And readVolatile is trickier still.)  As
overkill, maybe some AOP frameworks could be used in this
way.

2. Syntax support via casts. Allow casted references well as
assignment. (You can't cast l-values because there are no
l-values).

readVolatile:    r = ((volatile)x).field;
writeFinal:      x.field (final)= r;
writeVolatile:   x.field (volatile)= r;

The main weirdness is that "(final)=" doesn't mean what it
looks like, since it also serves as a writeRelease, which
need not be the only/last assignment. And in any case, it is
almost as ugly as using the Fence API, so I doubt that this
approach would be prioritized very highly when considering
syntactic Java language changes.

The specs of these methods still need some work -- I haven't
touched them since initially sketching them out last
year. Suggestions welcome.
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

At some point the JLS memory model specs would need to
reflect these changes.  Conceptually, it does not seem all
that hard to generalize the JMM to cover valriables that are
only sometimes (vs always) treated as volatile or final,
especially in comparison to other JMM spec problems that
someday need to be addressed (mainly, those described in
Jaroslav Sevcik's ECOOP08 paper).

-Doug



From gregg at cytetech.com  Tue Jan 13 11:22:17 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 13 Jan 2009 10:22:17 -0600
Subject: [concurrency-interest] Java7 Fences API
In-Reply-To: <496CADB0.3020605@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>
Message-ID: <496CBFB9.1020200@cytetech.com>

Doug Lea wrote:
> 1. Macros. If there were a standard Java Macro preprocessor,
> someone might introduce some (using C style for now):
>    #define publish(v, r) preStoreFence(); v = r
> Although even this could use C-like comma operator so it is
> one expression. (And readVolatile is trickier still.)  As
> overkill, maybe some AOP frameworks could be used in this
> way.
> 
> 2. Syntax support via casts. Allow casted references well as
> assignment. (You can't cast l-values because there are no
> l-values).

What about annotation style notations?

Gregg Wonderly

From pugh at cs.umd.edu  Tue Jan 13 20:46:12 2009
From: pugh at cs.umd.edu (Bill Pugh)
Date: Tue, 13 Jan 2009 17:46:12 -0800
Subject: [concurrency-interest] [Javamemorymodel-discussion] Java7
	Fences API
In-Reply-To: <496CADB0.3020605@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>
Message-ID: <0818935B-2317-48C8-BE0B-535DD0032337@cs.umd.edu>

yow.

I think this is a much harder problem than Doug seems to think it is.  
Or I don't understand want Doug wants.

Consider, for example,

static void	postLoadFence()
           Ensures that any read or write performed subsequent to a  
call to this method is ordered strictly after any read performed prior  
to the call.

So, if we have:

Initially, x = y = z = 0 and none are volatile.

Thread 1:

r1 = x
Fence().postLoadFence()
y = 1
r3 = z

Thread 2:
z = 1
r2 = y
Fence().postLoadFence()
x = 1

So, it seems to me that we'd be saying that r1 = r2 = 1 it not a  
possible behavior. On the other hand, no happens-before edges would be  
established by anything in the code.

Thus, we could have r1 = 1 and r2 = r3 = 0.

It seems to me that with this, we will be encouraging people to write  
subtle concurrent algorithms in which conflicting memory accesses are  
not ordered by happens before ordering. Which means we can will no  
longer be able to effectively use data race detection tools.

Final fields were hard as hell to try to get into the spec, and  
mutable final fields _really_ pushed the boundaries.  Now Doug wants  
to be able to declare that arbitrary writes have the special semantics  
associated with final writes.

The entire JMM was designed around the idea that there wasn't a unique  
global order over all memory operations, and that you couldn't talk  
about fences, because that just described ordering constraints on how  
operations performed by a thread could be reordered as they were seen  
by the global memory order.

For my sanity, can we back away from what kind of API or language  
features we might design/provide, and go through the compelling use  
cases that require something other than the currently provided memory  
semantics?

If only 5 people in the world could effectively and correctly use the  
new API, I don't think it should be added to the public JVM.

Bill



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090113/71bd55e4/attachment.html>

From hans.boehm at hp.com  Wed Jan 14 00:43:44 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 14 Jan 2009 05:43:44 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion] Java7
	Fences API
In-Reply-To: <0818935B-2317-48C8-BE0B-535DD0032337@cs.umd.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>
	<0818935B-2317-48C8-BE0B-535DD0032337@cs.umd.edu>
Message-ID: <238A96A773B3934685A7269CC8A8D0423F829CFB72@GVW0436EXB.americas.hpqcorp.net>

I think this can probably be expressed in terms of happens-before relationships.  That's what the C++ version does.

See http://wiki.dinkumware.com/twiki/pub/Wg21sanFrancisco/FormalMotions/n2752.html, section 29.6.

(This is a reference to a proposal that has been merged into the C++ committee draft, which is N2800 at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/ )

I doubt this negates your concerns, however.  I think all of us share those to some extent.

For C++, the main argument for fences was that there are use cases for which they result in more efficient code on current architectures, and fences are often so expensive that avoiding one is a big deal.  Releases of multiple locks in a row are one example.

And there are cases like seq_locks that are hard to express otherwise.  Consider the following code:

initial_version = version;
read_a_bunch_of_stuff;
final_version = version;

where potentially interfering writers set a lock bit in the version during the update and increment the version at the end, and I then check version1 and version2 at the end to make sure I read a consistent snapshot.  Even if version is volatile, this doesn't give me the ordering I want.  A fence before the final load does.  (Making all the reads in the middle volatile gives me SC, but this is often impractical, for both performance and software engineering reasons.  Actually, this example doesn't quite work in C++ either, but for relatively minor reasons that don't apply to Java.)

For Java, there's the added problem that we don't have volatile array elements, and it's linguistically hard to specify weaker ordering for volatile accesses, which some people insist on, again for performance reasons.

Hans

________________________________
From: javamemorymodel-discussion-bounces at cs.umd.edu [mailto:javamemorymodel-discussion-bounces at cs.umd.edu] On Behalf Of Bill Pugh
Sent: Tuesday, January 13, 2009 5:46 PM
To: Doug Lea
Cc: Concurrency-interest at cs.oswego.edu; javamemorymodel-discussion at cs.umd.edu
Subject: Re: [Javamemorymodel-discussion] Java7 Fences API

yow.

I think this is a much harder problem than Doug seems to think it is. Or I don't understand want Doug wants.

Consider, for example,

static void     postLoadFence<http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html#postLoadFence()>()
          Ensures that any read or write performed subsequent to a call to this method is ordered strictly after any read performed prior to the call.

So, if we have:

Initially, x = y = z = 0 and none are volatile.

Thread 1:

r1 = x
Fence().postLoadFence()
y = 1
r3 = z

Thread 2:
z = 1
r2 = y
Fence().postLoadFence()
x = 1

So, it seems to me that we'd be saying that r1 = r2 = 1 it not a possible behavior. On the other hand, no happens-before edges would be established by anything in the code.

Thus, we could have r1 = 1 and r2 = r3 = 0.

It seems to me that with this, we will be encouraging people to write subtle concurrent algorithms in which conflicting memory accesses are not ordered by happens before ordering. Which means we can will no longer be able to effectively use data race detection tools.

Final fields were hard as hell to try to get into the spec, and mutable final fields _really_ pushed the boundaries.  Now Doug wants to be able to declare that arbitrary writes have the special semantics associated with final writes.

The entire JMM was designed around the idea that there wasn't a unique global order over all memory operations, and that you couldn't talk about fences, because that just described ordering constraints on how operations performed by a thread could be reordered as they were seen by the global memory order.

For my sanity, can we back away from what kind of API or language features we might design/provide, and go through the compelling use cases that require something other than the currently provided memory semantics?

If only 5 people in the world could effectively and correctly use the new API, I don't think it should be added to the public JVM.

Bill



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/47d2ef4d/attachment.html>

From dl at cs.oswego.edu  Wed Jan 14 09:20:49 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 14 Jan 2009 09:20:49 -0500
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496CADB0.3020605@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>
Message-ID: <496DF4C1.1000105@cs.oswego.edu>


[Same cross-post conventions as the last one.]

As another make-good for a long-standing problem, the
Fences class should include what amounts to a fence with
respect to the garbage collector. This addresses a problem that
Hans Boehm has written and talked about for years.
(Google finds his JavaOne 2005 slides at
http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)

This turns out not to be expressible using other kinds of
fences. It tells the compiler/runtime that the ref in
question must be considered as being used even if nothing in
the program itself indicates it. (The suggested JVM implementation
of this is an "opaque fence" that bypasses/evades any
mechanics or optimizations that might cause ref to vanish.)

Here's a first pass at javadoc/spec. Comments welcome.

     /**
      * Ensures that object referenced by the given reference is not
      * reclaimable by garbage collection until after the invocation of
      * this method. Among other related usages, this method may assist
      * efforts to ensure that finalization associated with garbage
      * collection does not occur before the finalized resources have
      * even been established.  For example:
      *
      * <pre>
      * class Resource {
      *   static NativeResource nativeResourceArray = ...
      *   static void registerInArray(int index) { ... }
      *   int myIndex;
      *   void setup() {
      *      int i = myIndex;
      *      registerInArray(i);
      *      keepAlive(this);
      *   }
      *   Resource(...) {
      *     myIndex = ...
      *     setup();
      *   }
      * }
      * </pre>
      * @param ref the reference
      */
     public static <T> keepAlive(T ref);





From matthias at mernst.org  Wed Jan 14 10:00:45 2009
From: matthias at mernst.org (Matthias Ernst)
Date: Wed, 14 Jan 2009 16:00:45 +0100
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496DF4C1.1000105@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
Message-ID: <22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>

For reference, this is the equivalent in .NET:

http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx


On Wed, Jan 14, 2009 at 3:20 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>
> [Same cross-post conventions as the last one.]
>
> As another make-good for a long-standing problem, the
> Fences class should include what amounts to a fence with
> respect to the garbage collector. This addresses a problem that
> Hans Boehm has written and talked about for years.
> (Google finds his JavaOne 2005 slides at
> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
>
> This turns out not to be expressible using other kinds of
> fences. It tells the compiler/runtime that the ref in
> question must be considered as being used even if nothing in
> the program itself indicates it. (The suggested JVM implementation
> of this is an "opaque fence" that bypasses/evades any
> mechanics or optimizations that might cause ref to vanish.)
>
> Here's a first pass at javadoc/spec. Comments welcome.
>
>    /**
>     * Ensures that object referenced by the given reference is not
>     * reclaimable by garbage collection until after the invocation of
>     * this method. Among other related usages, this method may assist
>     * efforts to ensure that finalization associated with garbage
>     * collection does not occur before the finalized resources have
>     * even been established.  For example:
>     *
>     * <pre>
>     * class Resource {
>     *   static NativeResource nativeResourceArray = ...
>     *   static void registerInArray(int index) { ... }
>     *   int myIndex;
>     *   void setup() {
>     *      int i = myIndex;
>     *      registerInArray(i);
>     *      keepAlive(this);
>     *   }
>     *   Resource(...) {
>     *     myIndex = ...
>     *     setup();
>     *   }
>     * }
>     * </pre>
>     * @param ref the reference
>     */
>    public static <T> keepAlive(T ref);
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From R.Spilker at topdesk.com  Wed Jan 14 10:52:37 2009
From: R.Spilker at topdesk.com (=?us-ascii?Q?Roel_Spilker?=)
Date: Wed, 14 Jan 2009 16:52:37 +0100
Subject: [concurrency-interest] DefaultThreadFactory implementation questions
Message-ID: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>

L.S.,

In the class j.u.c.Executors, there is a package private static class DefaultThreadFactory. This class synthesizes a name for all created threads. For debugging and monitoring purposes, I would like to be able to provide a custom namePrefix. This has lead me?to two questions:
?
1) Is there a reason the ThreadGroup is determined in the constructor and the later used to create a new Thread? As far as I can see, Thread also has a constructor that takes a Runnable and a String name that would use similar code to determine the ThreadGroup. 
?
2) Do other people also feel the need to provide a name? Or is there another way to provide more debugging and monitoring information? If so, is it appropriate to add some API to do so? 
?
I think the API changes could be small. The smallest change would be to add two static methods to Executors:
?
public static ThreadFactory defaultThreadFactory(String namePrefix);
public static ThreadFactory privilagedThreadFactory(String namePrefix);
?
This would be enough, since the code in j.u.g that call defaultThreadFactory also have a counterpart that accepts a provided ThreadFactory. 
?
A more complete API would be to also add: 
?
public static ExecutorService newFixedThreadPool(int nThreads, String namePrefix); 
public static ExecutorService newSingleThreadExecutor(String namePrefix); 
public static ExecutorService newCachedThreadPool(String namePrefix); 
?
... and probably the same for the ScheduledExecutorService factory methods.
?
Also, ThreadPoolExecutor could get two extra constructors that accept a namePrefix.
?
The changes in the code would, for as far as I can see, be very small.
?
Roel Spilker

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/1abe4785/attachment.html>

From gergg at cox.net  Wed Jan 14 11:05:54 2009
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 14 Jan 2009 10:05:54 -0600
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496DF4C1.1000105@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>
Message-ID: <496E0D62.8090807@cox.net>

Doug Lea wrote:
> 
> [Same cross-post conventions as the last one.]
> 
> As another make-good for a long-standing problem, the
> Fences class should include what amounts to a fence with
> respect to the garbage collector. This addresses a problem that
> Hans Boehm has written and talked about for years.
> (Google finds his JavaOne 2005 slides at
> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
> 
> This turns out not to be expressible using other kinds of
> fences. It tells the compiler/runtime that the ref in
> question must be considered as being used even if nothing in
> the program itself indicates it. (The suggested JVM implementation
> of this is an "opaque fence" that bypasses/evades any
> mechanics or optimizations that might cause ref to vanish.)

After reading Hans paper from J1, I'm not sure I understand why this fence is 
needed.  Phantom reference solves the issues that I see with trying to "clean 
up" due to GC finalization happening.  The ReferenceTracker class that I posted 
here works to defeat all the issues that Hans brought up I believe.

Would it make sense to include something like ReferenceTracker in lieu of this 
kind of fence?  Perhaps I'm not understanding how the problem Hans discusses 
turns out to be an issue for developers or JVM implementations?  Is it a problem 
if you use PhantomReference instead of finalize()?

Gregg Wonderly

From tim at peierls.net  Wed Jan 14 11:50:41 2009
From: tim at peierls.net (Tim Peierls)
Date: Wed, 14 Jan 2009 11:50:41 -0500
Subject: [concurrency-interest] DefaultThreadFactory implementation
	questions
In-Reply-To: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
References: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
Message-ID: <63b4e4050901140850y7c6d68b1u41bec60e14fb86d1@mail.gmail.com>

Regarding (2), this doesn't seem like something that should be in the
standard library, since folks would disagree on the precise format of the
prefixed thread name and others would want custom *suffixes*. And it's very
easy to write your own ThreadFactory decorator that arranges for custom
thread name prefixing:

 public static ThreadFactory prefixedThreadName(final ThreadFactory
threadFactory, final String prefix) {
     return new ThreadFactory() {
         public Thread newThread(Runnable runnable) {
             Thread t = threadFactory.newThread(runnable);
             t.setName(prefix + t.getName()); // or with a hyphen, or
replacing "pool" with prefix, or ...
             return t;
         }
     };
 }

 ...

 ThreadFactory myThreadFactory = prefixedThreadName(defaultThreadFactory(),
"myprefix");

The explicit use of ThreadGroup in the DefaultThreadFactory constructor is
to make sure that if a SecurityManager exists then threads created by the
factory will be in that SecurityManager's thread group. This might only be
relevant to the PrivilegedThreadFactory subclass.

--tim

On Wed, Jan 14, 2009 at 10:52 AM, Roel Spilker <R.Spilker at topdesk.com>wrote:

>  L.S.,
>
> In the class j.u.c.Executors, there is a package private static class
> DefaultThreadFactory. This class synthesizes a name for all created threads.
> For debugging and monitoring purposes, I would like to be able to provide a
> custom namePrefix. This has lead me to two questions:
>
> 1) Is there a reason the ThreadGroup is determined in the constructor and
> the later used to create a new Thread? As far as I can see, Thread also has
> a constructor that takes a Runnable and a String name that would use similar
> code to determine the ThreadGroup.
>
> 2) Do other people also feel the need to provide a name? Or is there
> another way to provide more debugging and monitoring information? If so, is
> it appropriate to add some API to do so?
>
> I think the API changes could be small. The smallest change would be to add
> two static methods to Executors:
>
> public static ThreadFactory defaultThreadFactory(String namePrefix);
> public static ThreadFactory privilagedThreadFactory(String namePrefix);
>
> This would be enough, since the code in j.u.g that call defaultThreadFactory
> also have a counterpart that accepts a provided ThreadFactory.
>
> A more complete API would be to also add:
>
> public static ExecutorService newFixedThreadPool(int nThreads, String
> namePrefix);
> public static ExecutorService newSingleThreadExecutor(String namePrefix);
> public static ExecutorService newCachedThreadPool(String namePrefix);
>
> ... and probably the same for the ScheduledExecutorService factory methods.
>
> Also, ThreadPoolExecutor could get two extra constructors that accept a
> namePrefix.
>
> The changes in the code would, for as far as I can see, be very small.
>
> Roel Spilker
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/0b97214e/attachment.html>

From joe.bowbeer at gmail.com  Wed Jan 14 12:00:13 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 14 Jan 2009 09:00:13 -0800
Subject: [concurrency-interest] DefaultThreadFactory implementation
	questions
In-Reply-To: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
References: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
Message-ID: <31f2a7bd0901140900y2a3371adnc1502bbfd752b9a1@mail.gmail.com>

All of the Executors thread pool factory methods have two forms: one that
doesn't take a custom thread factory, and one that does.  The hope was that
anyone who had special thread-creation needs would use the second form,
providing their own thread factory.

If, for example, you want to specify your own prefix, you can wrap the
defaultThreadFactory() of Executors in your own ThreadFactory, as Tim
illustrates, and then specify this custom thread factory when you create
your thread pool.  OK?

(I think custom names is a great reason to provide your own thread factory.)

Joe


On Wed, Jan 14, 2009 at 7:52 AM, Roel Spilker wrote:

>  L.S.,
>
> In the class j.u.c.Executors, there is a package private static class
> DefaultThreadFactory. This class synthesizes a name for all created threads.
> For debugging and monitoring purposes, I would like to be able to provide a
> custom namePrefix. This has lead me to two questions:
>
> 1) Is there a reason the ThreadGroup is determined in the constructor and
> the later used to create a new Thread? As far as I can see, Thread also has
> a constructor that takes a Runnable and a String name that would use similar
> code to determine the ThreadGroup.
>
> 2) Do other people also feel the need to provide a name? Or is there
> another way to provide more debugging and monitoring information? If so, is
> it appropriate to add some API to do so?
>
> I think the API changes could be small. The smallest change would be to add
> two static methods to Executors:
>
> public static ThreadFactory defaultThreadFactory(String namePrefix);
> public static ThreadFactory privilagedThreadFactory(String namePrefix);
>
> This would be enough, since the code in j.u.g that call defaultThreadFactory
> also have a counterpart that accepts a provided ThreadFactory.
>
> A more complete API would be to also add:
>
> public static ExecutorService newFixedThreadPool(int nThreads, String
> namePrefix);
> public static ExecutorService newSingleThreadExecutor(String namePrefix);
> public static ExecutorService newCachedThreadPool(String namePrefix);
>
> ... and probably the same for the ScheduledExecutorService factory methods.
>
> Also, ThreadPoolExecutor could get two extra constructors that accept a
> namePrefix.
>
> The changes in the code would, for as far as I can see, be very small.
>
> Roel Spilker
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/ce1b02fb/attachment.html>

From R.Spilker at topdesk.com  Wed Jan 14 12:15:08 2009
From: R.Spilker at topdesk.com (=?us-ascii?Q?Roel_Spilker?=)
Date: Wed, 14 Jan 2009 18:15:08 +0100
Subject: [concurrency-interest] DefaultThreadFactory implementation
 questions
In-Reply-To: <63b4e4050901140850y7c6d68b1u41bec60e14fb86d1@mail.gmail.com>
References: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
Message-ID: <vmime.496e1d9c.25d0.f8445a5b4f880c5d@mona.topdesk.com>

Tim,
?
Regarding (1):
?
The?constructor?public Thread(Runnable target, String name) already uses the ThreadGroup of the SecurityManager by providing null as the ThreadGroup to the init method.
?
Regarding (2):
?
I agree you could do it like that. However, I think it would still be a good idea to make it easy for the users to create a default thread factory with a given namePrefix. If we would follow your reasoning, there is also no need for public static ExecutorService newFixedThreadPool(int nThreads), since the caller could call public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) after getting threadFactory using Executors. defaultThreadFactory(). 
?
If "folks would disagree on the precise format", they could always choose to use a decorator. But providing a default implementation that enhances debugging and monitoring?consists of?a simple API change, and requires only a few lines of code to be changed. I think that would be good value for money.
?
Roel
?

?
Van: tim at peierls.net [mailto:tpeierls at gmail.com] Namens Tim Peierls
Verzonden: woensdag 14 januari 2009 17:51
Aan: Roel Spilker
CC: concurrency-interest
Onderwerp: Re: [concurrency-interest] DefaultThreadFactory implementation questions



Regarding (2), this doesn't seem like something that should be in the standard library, since folks would disagree on the precise format of the prefixed thread name and others would want custom *suffixes*. And it's very easy to write your own ThreadFactory decorator that arranges for custom thread name prefixing:


?public static ThreadFactory prefixedThreadName(final ThreadFactory threadFactory, final String prefix) {
?? ? return new ThreadFactory() {

?? ? ? ? public Thread newThread(Runnable runnable) {
?? ? ? ? ? ? Thread t = threadFactory.newThread(runnable);
?? ? ? ? ? ? t.setName(prefix + t.getName()); // or with a hyphen, or replacing "pool" with prefix, or ...
?? ? ? ? ? ? return t;
?? ? ? ? }
?? ? };
?}


?...


?ThreadFactory myThreadFactory = prefixedThreadName(defaultThreadFactory(), "myprefix");


The explicit use of ThreadGroup in the DefaultThreadFactory constructor is to make sure that if a SecurityManager exists then threads created by the factory will be in that SecurityManager's thread group. This might only be relevant to the PrivilegedThreadFactory subclass.



--tim

? 




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/4e0e9078/attachment.html>

From matthias at mernst.org  Wed Jan 14 12:32:14 2009
From: matthias at mernst.org (Matthias Ernst)
Date: Wed, 14 Jan 2009 18:32:14 +0100
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496E0D62.8090807@cox.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<496E0D62.8090807@cox.net>
Message-ID: <22ec15240901140932w3f6d4911kd937b4fb25b3ee5e@mail.gmail.com>

On Wed, Jan 14, 2009 at 5:05 PM, Gregg Wonderly <gergg at cox.net> wrote:
> Doug Lea wrote:
>>
>> [Same cross-post conventions as the last one.]
>>
>> As another make-good for a long-standing problem, the
>> Fences class should include what amounts to a fence with
>> respect to the garbage collector. This addresses a problem that
>> Hans Boehm has written and talked about for years.
>> (Google finds his JavaOne 2005 slides at
>> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
>>
>> This turns out not to be expressible using other kinds of
>> fences. It tells the compiler/runtime that the ref in
>> question must be considered as being used even if nothing in
>> the program itself indicates it. (The suggested JVM implementation
>> of this is an "opaque fence" that bypasses/evades any
>> mechanics or optimizations that might cause ref to vanish.)
>
> After reading Hans paper from J1, I'm not sure I understand why this fence
> is needed.  Phantom reference solves the issues that I see with trying to
> "clean up" due to GC finalization happening.  The ReferenceTracker class
> that I posted here works to defeat all the issues that Hans brought up I
> believe.
>
> Would it make sense to include something like ReferenceTracker in lieu of
> this kind of fence?  Perhaps I'm not understanding how the problem Hans
> discusses turns out to be an issue for developers or JVM implementations?
>  Is it a problem if you use PhantomReference instead of finalize()?

I think the issue would be the same. The "Holder" objects you propose
may go out of scope while a call to the referent is in-flight and so
the referent may be released concurrently. The fence makes sure that
you can reliably extend the holder's scope beyond the call into the
referent.

>
> Gregg Wonderly
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From gregg at cytetech.com  Wed Jan 14 12:45:10 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 14 Jan 2009 11:45:10 -0600
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
Message-ID: <496E24A6.2000705@cytetech.com>

Can someone elaborate why the reference on the stack as a local value would not 
maintain a reference that lasted until the method exits?  I can see

work() {
	someUnManagedMethod( new Foo() );
	...
	...
	...
	someOtherUnmanagedMethodWhichErradicatesFooReference();
}

being a little more obvious of an issue, and I guess its interfaces to 
JNI/native things that make this issue boil up to be visible?  Are there any
cases where 100% Java code has this lost reference problem?  It seems not to me...

Gregg Wonderly

Matthias Ernst wrote:
> For reference, this is the equivalent in .NET:
> 
> http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx
> 
> 
> On Wed, Jan 14, 2009 at 3:20 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>> [Same cross-post conventions as the last one.]
>>
>> As another make-good for a long-standing problem, the
>> Fences class should include what amounts to a fence with
>> respect to the garbage collector. This addresses a problem that
>> Hans Boehm has written and talked about for years.
>> (Google finds his JavaOne 2005 slides at
>> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
>>
>> This turns out not to be expressible using other kinds of
>> fences. It tells the compiler/runtime that the ref in
>> question must be considered as being used even if nothing in
>> the program itself indicates it. (The suggested JVM implementation
>> of this is an "opaque fence" that bypasses/evades any
>> mechanics or optimizations that might cause ref to vanish.)
>>
>> Here's a first pass at javadoc/spec. Comments welcome.
>>
>>    /**
>>     * Ensures that object referenced by the given reference is not
>>     * reclaimable by garbage collection until after the invocation of
>>     * this method. Among other related usages, this method may assist
>>     * efforts to ensure that finalization associated with garbage
>>     * collection does not occur before the finalized resources have
>>     * even been established.  For example:
>>     *
>>     * <pre>
>>     * class Resource {
>>     *   static NativeResource nativeResourceArray = ...
>>     *   static void registerInArray(int index) { ... }
>>     *   int myIndex;
>>     *   void setup() {
>>     *      int i = myIndex;
>>     *      registerInArray(i);
>>     *      keepAlive(this);
>>     *   }
>>     *   Resource(...) {
>>     *     myIndex = ...
>>     *     setup();
>>     *   }
>>     * }
>>     * </pre>
>>     * @param ref the reference
>>     */
>>    public static <T> keepAlive(T ref);
>>
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 


From gregg at cytetech.com  Wed Jan 14 12:53:04 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 14 Jan 2009 11:53:04 -0600
Subject: [concurrency-interest] DefaultThreadFactory implementation
	questions
In-Reply-To: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
References: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
Message-ID: <496E2680.20909@cytetech.com>

Roel Spilker wrote:
> 2) Do other people also feel the need to provide a name? Or is there 
> another way to provide more debugging and monitoring information? If so, 
> is it appropriate to add some API to do so?

We just use the ThreadFactory below to manage named thread pools so that we can 
see in stack dumps where the threads are created etc.

Gregg Wonderly

----------------------------------------------------------------------

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
  * This class Provides a ThreadFactory for {@link 
java.util.concurrent.ThreadPoolExecutor}.
  * The threads created have a configured name prefix, explicit Throwable 
catches and associated logging
  * to keep threads from dying due to uncaught exceptions.  Threads can also be 
specified to be created
  * as daemon threads.
  *
  * The internal {@link java.util.logging.Logger} instance will include the 
prefix name as a
  * suffix to the logger name so that logging of specific instances can be 
controlled separately.
  */
public class NamedThreadFactory implements ThreadFactory {
	/**
	 * The name prefix threads are created with.
	 */
	private String name;
	/**
	 * The {@link java.util.logging.Logger} instance used.  This will include a 
"."+name suffix
	 * to allow each instances logging to be controlled separately.  Thus names 
need to follow
	 * the requirements for use in {@link java.util.Logger} names.
	 */
	private Logger log = Logger.getLogger( getClass().getName() );
	/**
	 * Whether threads should be set as daemon threads or not.
	 */
	private boolean isDaemon;

	/**
	 * Create a ThreadFactory which creates threads with the indicated name prefix 
and sets the daemon
	 * setting to the passed value.
	 * @param name The name prefix for threads created by this factory
	 * @param isDaemon Whether daemon threads should be created.
	 */
	public NamedThreadFactory( String name, boolean isDaemon ) {
		this(name);
		this.isDaemon = isDaemon;
	}

	/**
	 * Creates a Thread factory with threads named with the indicated prefix and 
set to non-daemon threads.
	 * @param name The name prefix for threads created by this factory
	 */
	public NamedThreadFactory( String name ) {
		this.name = name;
		try {
			// If there is ever a limit on log name construction, catch any
			// associated errors and just use the classes named logger.
			log = Logger.getLogger(
                              getClass().getName().replace('$','.')+"."+name );
		} catch( Exception ex ) {
			log = Logger.getLogger(
                              getClass().getName().replace('$','.') );
			log.log( Level.SEVERE, ex.toString(), ex );
		}
		if( log.isLoggable( Level.FINE ) ) {
			log.fine( this+" instance created" );
		}
	}

	/**
	 * The incrementing threads number to provide unique threads names.
	 */
	private AtomicInteger cnt = new AtomicInteger(0);
	/**
	 * Creates a new threads with the appropriate name prefix and daemon designation.
	 * @param r The {@link java.lang.Runnable} instance to cause the thread to execute.
	 * @return The newly created thread.
	 */
	public Thread newThread( final Runnable r ) {
		Thread th = new Thread( new Runnable() {
			public void run() {
				try {
					r.run();
				} catch( Throwable ex ) {
					log.log( Level.WARNING, ex.toString()+": Exception unhandled in thread pool 
thread", ex );
				}
			}
		});
		th.setName( name+"-"+cnt.incrementAndGet() );
		th.setDaemon( isDaemon );
		if( log.isLoggable( Level.FINE ) )
			log.fine("Created new thread: \""+th.getName()+"\" (daemon="+isDaemon+")" );
		return th;
	}
	
	public String toString() {
		return "NamedThreadFactory: \""+name+"\" (daemon="+isDaemon+")";
	}
}

From dl at cs.oswego.edu  Wed Jan 14 13:15:58 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 14 Jan 2009 13:15:58 -0500
Subject: [concurrency-interest] Java7 Fences API
In-Reply-To: <496CBFB9.1020200@cytetech.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496CBFB9.1020200@cytetech.com>
Message-ID: <496E2BDE.3060309@cs.oswego.edu>

Gregg Wonderly wrote:
> Doug Lea wrote:
>> 1. Macros. If there were a standard Java Macro preprocessor,
>> someone might introduce some (using C style for now):
>>    #define publish(v, r) preStoreFence(); v = r
>>
> What about annotation style notations?
> 

I haven't been able to come up with an annotation scheme
that works here, and don't think one is possible, since
the annotation targets are sometimes assignment statements,
which cannot be independently annotated.

-Doug


From matthias at mernst.org  Wed Jan 14 13:17:11 2009
From: matthias at mernst.org (Matthias Ernst)
Date: Wed, 14 Jan 2009 19:17:11 +0100
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496E24A6.2000705@cytetech.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
Message-ID: <22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>

On Wed, Jan 14, 2009 at 6:45 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
> Can someone elaborate why the reference on the stack as a local value would
> not maintain a reference that lasted until the method exits?

Why would it? The object will no longer be used in the rest of the
method, why keep it alive?
So it is totally conceivable that the stackmap will no longer announce
this reference to the GC even if the value is still somewhere on the
stack or in a register.
I would even expect a clever optimizer to reuse the storage, so the
reference is "physically" gone.

It is also important to note that this topic is very related to the
memory model. The last point of reachability is just as much subject
to reordering/inlining optimizations and an object can end up being
collected even earlier than its last lexical reference.

Matthias

> I can see
>
> work() {
>        someUnManagedMethod( new Foo() );
>        ...
>        ...
>        ...
>        someOtherUnmanagedMethodWhichErradicatesFooReference();
> }
>
> being a little more obvious of an issue, and I guess its interfaces to
> JNI/native things that make this issue boil up to be visible?  Are there any
> cases where 100% Java code has this lost reference problem?  It seems not to
> me...
>
> Gregg Wonderly
>
> Matthias Ernst wrote:
>>
>> For reference, this is the equivalent in .NET:
>>
>> http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx
>>
>>
>> On Wed, Jan 14, 2009 at 3:20 PM, Doug Lea <dl at cs.oswego.edu> wrote:
>>>
>>> [Same cross-post conventions as the last one.]
>>>
>>> As another make-good for a long-standing problem, the
>>> Fences class should include what amounts to a fence with
>>> respect to the garbage collector. This addresses a problem that
>>> Hans Boehm has written and talked about for years.
>>> (Google finds his JavaOne 2005 slides at
>>> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
>>>
>>> This turns out not to be expressible using other kinds of
>>> fences. It tells the compiler/runtime that the ref in
>>> question must be considered as being used even if nothing in
>>> the program itself indicates it. (The suggested JVM implementation
>>> of this is an "opaque fence" that bypasses/evades any
>>> mechanics or optimizations that might cause ref to vanish.)
>>>
>>> Here's a first pass at javadoc/spec. Comments welcome.
>>>
>>>   /**
>>>    * Ensures that object referenced by the given reference is not
>>>    * reclaimable by garbage collection until after the invocation of
>>>    * this method. Among other related usages, this method may assist
>>>    * efforts to ensure that finalization associated with garbage
>>>    * collection does not occur before the finalized resources have
>>>    * even been established.  For example:
>>>    *
>>>    * <pre>
>>>    * class Resource {
>>>    *   static NativeResource nativeResourceArray = ...
>>>    *   static void registerInArray(int index) { ... }
>>>    *   int myIndex;
>>>    *   void setup() {
>>>    *      int i = myIndex;
>>>    *      registerInArray(i);
>>>    *      keepAlive(this);
>>>    *   }
>>>    *   Resource(...) {
>>>    *     myIndex = ...
>>>    *     setup();
>>>    *   }
>>>    * }
>>>    * </pre>
>>>    * @param ref the reference
>>>    */
>>>   public static <T> keepAlive(T ref);
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
>

From tim at peierls.net  Wed Jan 14 13:40:45 2009
From: tim at peierls.net (Tim Peierls)
Date: Wed, 14 Jan 2009 13:40:45 -0500
Subject: [concurrency-interest] DefaultThreadFactory implementation
	questions
In-Reply-To: <vmime.496e1d9c.25d0.f8445a5b4f880c5d@mona.topdesk.com>
References: <vmime.496e0a45.25d0.198d711b94fca39d@mona.topdesk.com>
	<63b4e4050901140850y7c6d68b1u41bec60e14fb86d1@mail.gmail.com>
	<vmime.496e1d9c.25d0.f8445a5b4f880c5d@mona.topdesk.com>
Message-ID: <63b4e4050901141040i26cba261w69dbcc587de83e87@mail.gmail.com>

On Wed, Jan 14, 2009 at 12:15 PM, Roel Spilker <R.Spilker at topdesk.com>wrote:

>  Regarding (1):
>
> The constructor public Thread(Runnable target, String name) already uses
> the ThreadGroup of the SecurityManager by providing null as the ThreadGroup
> to the init method.
>

As the code stands, you get the ThreadGroup of the current
SecurityManager (or Thread) when the DefaultThreadFactory is constructed
rather than whatever is current when newThread is called. If the code were
to use null for its ThreadGroup parameter (explicitly or implicitly), it
would get the latter behavior. The former behavior is better because the
user controls (or at least knows) what SecurityManager and Thread are
current when the factory is created. It isn't specified what SecurityManager
and Thread are current when newThread is called; it might be different for
each call.



Regarding (2):
>
> I agree you could do it like that. However, I think it would still be a
> good idea to make it easy for the users to create a default thread factory
> with a given namePrefix. If we would follow your reasoning, there is also no
> need for public static ExecutorService newFixedThreadPool(int nThreads),
> since the caller could call public static ExecutorService
> newFixedThreadPool(int nThreads, ThreadFactory threadFactory) after getting
> threadFactory using Executors.defaultThreadFactory().
>

None of the methods in Executors are absolutely essential, but they provide
often-needed j.u.c-related functionality that reduces code verbosity in
common cases and/or is difficult to get right from scratch. I don't think
adding prefixes to thread names is either that common or that difficult to
get right. And if you use a decorator of the sort that I described, it
needn't be verbose, either.

In addition, I think it's much nicer to readers of your code not to require
esoteric knowledge of library parameters.

  ExecutorService ex = newFixedThreadPool(2, "Main"); // Quick, what does
this mean? Or was it ("Main", 2)?

might be compact, but it isn't as friendly as this:

  ExecutorService ex = newFixedThreadPool(2,
withNamePrefixedBy("Main", defaultThreadFactory()));




> If "folks would disagree on the precise format", they could always choose
> to use a decorator. But providing a default implementation that enhances
> debugging and monitoring consists of a simple API change, and requires only
> a few lines of code to be changed. I think that would be good value for
> money.
>

I don't think it pulls more than its throw weight (if I have the metaphor
right). It would clutter the Executors class with methods with magic
parameters in order to elevate just one of many valid custom thread factory
use cases, one that happens to be easy to implement by hand in a few lines
of code. And these methods wouldn't be universally used even by those who
wanted them because no one would agree on exactly how to do it, e.g.,
whether to follow the prefix with a hyphen -- so half of the potential users
would roll their own anyway.

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090114/929f9769/attachment.html>

From hans.boehm at hp.com  Wed Jan 14 14:16:36 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 14 Jan 2009 19:16:36 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
Message-ID: <238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>

> From:  Matthias Ernst
> 
> On Wed, Jan 14, 2009 at 6:45 PM, Gregg Wonderly 
> <gregg at cytetech.com> wrote:
> > Can someone elaborate why the reference on the stack as a 
> local value 
> > would not maintain a reference that lasted until the method exits?
> 
> Why would it? The object will no longer be used in the rest 
> of the method, why keep it alive?
> So it is totally conceivable that the stackmap will no longer 
> announce this reference to the GC even if the value is still 
> somewhere on the stack or in a register.
> I would even expect a clever optimizer to reuse the storage, 
> so the reference is "physically" gone.
Exactly.  And the value may in fact no longer be on the stack or in a register.  Most modern calling conventions (e.g. on X86-64, less so on X86-32) pass arguments in registers.  Thus even if the object was allocated by the caller, by the time it's passed to the current method, where it becomes "this", it may only live in an argument register, which the callee is allowed to overwrite once it's dead.

This has nothing to do with java.lang.ref vs. finalization; the problem exists either way.  It also has little to do with native code, though that might aggravate the problem.

Currently any method that touches "external" object state that may be cleaned up by the objects finalizer, should execute something like
"synchronized(this) { }" at the end of the method in order to prevent premature cleanup of the external state.  I conjecture that 90+% of such code is currently broken.  It rarely fails, since implementations usually happen to keep the relevent pointer (not always "this") live longer anyway.  And X86-32's lack of registers for calling conventions probably also helps, a bit.  And even if the resulting code is wrong, it will only fail once ina blue moon.

There are other possible design tradeoffs, but they're more invasive.  Outlawing dead variable elimination for object references works, and was discussed during JSR133 discussions.  At the time it we felt that this was risking too much performance impact for a rarely used language feature.  Although I advocated this position (in part to help get JSR133 out the door), I think that from a purely technical perspective it's worth considering.

Although C++0x is expected to contain only very minimal GC support, and no finalization support, this issue was discussed in some detail in that context, and I think the options could probably all be adapted to Java.  This is largely written up at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2261.html .

> 
> It is also important to note that this topic is very related 
> to the memory model. The last point of reachability is just 
> as much subject to reordering/inlining optimizations and an 
> object can end up being collected even earlier than its last 
> lexical reference.
Right.  And JSR133 at least made the symchronized(this) solution possible.  But we always knew that this wasn't a great solution.  I think keepAlive is really the minimal solution that people might realistically pay attention to.  I have to admit I'm not encouraged by the .NET documentation that Matthias pointed to, since it also seems to miss the core problem and focus on native code issues instead.

Hans
> 
> Matthias
> 


From gregg at cytetech.com  Wed Jan 14 14:27:00 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 14 Jan 2009 13:27:00 -0600
Subject: [concurrency-interest] Java7 Fences API
In-Reply-To: <496E2BDE.3060309@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496CBFB9.1020200@cytetech.com>
	<496E2BDE.3060309@cs.oswego.edu>
Message-ID: <496E3C84.3070301@cytetech.com>

Doug Lea wrote:
> Gregg Wonderly wrote:
>> Doug Lea wrote:
>>> 1. Macros. If there were a standard Java Macro preprocessor,
>>> someone might introduce some (using C style for now):
>>>    #define publish(v, r) preStoreFence(); v = r
>>>
>> What about annotation style notations?
>
> I haven't been able to come up with an annotation scheme
> that works here, and don't think one is possible, since
> the annotation targets are sometimes assignment statements,
> which cannot be independently annotated.

You were suggesting some language changes or other tooling changes, so I was 
suggesting annotations as something that wouldn't require keyword reuse or other 
weirdness like that.   Instead, allow annotations on statements (which has no 
compatibility issues) and we are done.

Gregg Wonderly

From mthornton at optrak.co.uk  Wed Jan 14 14:45:35 2009
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Wed, 14 Jan 2009 19:45:35 +0000
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
Message-ID: <496E40DF.2070503@optrak.co.uk>

Matthias Ernst wrote:
> On Wed, Jan 14, 2009 at 6:45 PM, Gregg Wonderly <gregg at cytetech.com> wrote:
>   
>> Can someone elaborate why the reference on the stack as a local value would
>> not maintain a reference that lasted until the method exits?
>>     
>
> Why would it? The object will no longer be used in the rest of the
> method, why keep it alive?
> So it is totally conceivable that the stackmap will no longer announce
> this reference to the GC even if the value is still somewhere on the
> stack or in a register.
>   
I believe this already happens with the current JVM (1.6_11 under
Windows, 32 bit).

Mark Thornton



From gregg at cytetech.com  Wed Jan 14 15:30:30 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 14 Jan 2009 14:30:30 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <496E4B66.9070106@cytetech.com>

Boehm, Hans wrote:
>> From:  Matthias Ernst
>>
>> On Wed, Jan 14, 2009 at 6:45 PM, Gregg Wonderly 
>> <gregg at cytetech.com> wrote:
>>> Can someone elaborate why the reference on the stack as a 
>> local value 
>>> would not maintain a reference that lasted until the method exits?
>> Why would it? The object will no longer be used in the rest 
>> of the method, why keep it alive?

I guess I'm trying to wrap my brain around which issue we are discussing.

>> So it is totally conceivable that the stackmap will no longer 
>> announce this reference to the GC even if the value is still 
>> somewhere on the stack or in a register.
>> I would even expect a clever optimizer to reuse the storage, 
>> so the reference is "physically" gone.
 >
> Exactly.  And the value may in fact no longer be on the stack or in a register.  
> Most modern calling conventions (e.g. on X86-64, less so on X86-32) pass arguments
> in registers.  Thus even if the object was allocated by the caller, by the time 
> it's passed to the current method, where it becomes "this", it may only live in 
> an argument register, which the callee is allowed to overwrite once it's dead.

Okay, but the objects life continues as long as someone is referencing it and I 
have no problem understanding the lifecycle for 100% Java stuff.

> This has nothing to do with java.lang.ref vs. finalization; the problem exists 
 > either way.  It also has little to do with native code, though that might
 > aggravate the problem.
> 
>Currently any method that touches "external" object state that may be cleaned 
 >up by the objects finalizer, should execute something like "synchronized(this){}"
>at the end of the method in order to prevent premature cleanup of the external state.
>I conjecture that 90+% of such code is currently broken.  It rarely fails, since
>implementations usually happen to keep the relevent pointer (not always "this")
>live longer anyway.  And X86-32's lack of registers for calling conventions
>probably also helps, a bit.  And even if the resulting code is wrong, it will 
 >only fail once ina blue moon.

But PhantomReference makes finalize() unnecessary when you use the Holder 
pattern that my ReferenceTracker is based on.  With that pattern, you don't have 
anything going on "bad" because the Tracker has a strong reference to the 
"to-be-released" resource and when the Holder goes out, the Tracker knows which 
object to use for "releasing" the associated resource(s).  Every object that has 
associated resources can be dealt with in this way, and any ordering 
requirements can all be managed via strong references where you are in complete 
control of the order of operations.

My Tracker is much like the S object in your paper, so I think you familiar with 
where I'm coming from.

 From my perspective, one can stop using finalize and worrying about all these 
data races by just adopting the pattern that I'm presenting through the use of 
my ReferenceTracker class.

> There are other possible design tradeoffs, but they're more invasive.  
> Outlawing dead variable elimination for object references works, and was
> discussed during JSR133 discussions.  At the time it we felt that this
> was risking too much performance impact for a rarely used language
> feature.  Although I advocated this position (in part to help get 
 > JSR133 out the door), I think that from a purely technical perspective
 > it's worth considering.

I personally don't want to see this level of GC implementation detail visible to 
the developer and a necessary part of their programming knowledge.  finalize() 
has way too many bad things in it related to ordering etc.  Your paper talks 
about these things in great detail.  Exposing them will interfere with the JMM 
and the GC details if they are made more controllable.

Rather than say we need a fence at the end of finalize(), why not, instead say, 
use class XYZ to track references to resources you need to release at the end of 
an objects life.  Then we have a more flexible way to manage this issue it seems 
to me, and there is not the low level detail of locking that the developer has 
to deal with.

> Although C++0x is expected to contain only very minimal GC support, 
 > and no finalization support, this issue was discussed in some detail
 > in that context, and I think the options could probably all be
 > adapted to Java.  This is largely written up at
 > http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2261.html .
> 
>> It is also important to note that this topic is very related 
>> to the memory model. The last point of reachability is just 
>> as much subject to reordering/inlining optimizations and an 
>> object can end up being collected even earlier than its last 
>> lexical reference.
 >
> Right.  And JSR133 at least made the symchronized(this) solution
> possible.  But we always knew that this wasn't a great solution.

It still seems to me that PhantomReference is the better solution than 
finalize(), maybe you can tell me why that isn't the case.

> I think keepAlive is really the minimal solution that people might 
> realistically pay attention to.

It seems that the .NET solution is to just provide a standard method name which 
does nothing, so that the compiler is compelled to maintain order of execution 
and to maintain the reference till the end of the method.  Is there something 
else happening here?

 > I have to admit I'm not
> encouraged by the .NET documentation that Matthias pointed to,
> since it also seems to miss the core problem and focus on native 
 > code issues instead.

Hans, are you only talking about how finalize() works, or is there another path 
in 100% java code that I still haven't gleaned from this?

Gregg Wonderly

From hans.boehm at hp.com  Wed Jan 14 17:12:45 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 14 Jan 2009 22:12:45 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
 Fences.keepAlive
In-Reply-To: <496E4B66.9070106@cytetech.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
	<496E4B66.9070106@cytetech.com>
Message-ID: <238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>

 

> -----Original Message-----
> From: Gregg Wonderly [mailto:gregg at cytetech.com] 
> 
> ...
> But PhantomReference makes finalize() unnecessary when you 
> use the Holder pattern that my ReferenceTracker is based on.  
> With that pattern, you don't have anything going on "bad" 
> because the Tracker has a strong reference to the 
> "to-be-released" resource and when the Holder goes out, the 
> Tracker knows which object to use for "releasing" the 
> associated resource(s).  Every object that has associated 
> resources can be dealt with in this way, and any ordering 
> requirements can all be managed via strong references where 
> you are in complete control of the order of operations.
> 
> My Tracker is much like the S object in your paper, so I 
> think you familiar with where I'm coming from.
> 
>  From my perspective, one can stop using finalize and 
> worrying about all these data races by just adopting the 
> pattern that I'm presenting through the use of my 
> ReferenceTracker class.
I think we're talking about completely different things.  The problem here is unrelated to ordering of different finalizer invocations, which can indeed be addressed with java.lang.ref, or with some finalizer usage patterns.

Consider a slightly expanded example.  I have a finalizable class S, which stores some of its data in a global array A.  Each element s of S contains a field index, such that A[s.index] contains the data associated with s.  The finaliser for s cleans up A[s.index].  Or s is referenced by some java.lang.ref and whoever pops it from the reference queue cleans it up.  It doesn't matter.  There are no other finalizable or java.lang.ref objects in the world.  (In some sense, this is the canonical use of these mechanisms, to clean up some external resource.  In simple cases, the external resource is actually an OS resource, but even that doesn't matter here.)

Assume s has a method foo that accesses the internal state as in

T foo()
{
  int i = index;

a:
  return a[i].bar;
}

Assume for the sake of specificity that S's finalizer just sets a[index] to null.  (In reality, it would probably also mark the entry as available, which would require some synchronization, as finalizers usually do.)

Assume this is called from a context:

s = new S;
y = s.foo();
// no further accesses to s.

Assume that x in the caller is allocated in a register that is also used to pass the this parameter to methods.  (A good register allocator should do exactly that in this case.)  Assume that the i in foo is allocated to the same register.  (This is fine, because the "this" argument is dead after "index" is looked up.)

Now assume that a simple stop the world garbage collection occurs at point a, and this thread is delayed until all cleanup actions are complete.  Thus A[i] will be set to null at point a, and the return statement will encounter a null pointer exception.  This is probably undesirable, and hence the code is wrong.

Currently this is fixable by putting a synchronized(this){} in the finalizer, and rewriting foo as

T foo()
{
  int i = index;

A:
  T res = a[i].bar;
  synchronized(this) {}
  return res;
}

We're proposing to allow this to be written as

T foo()
{
  int i = index;

A:
  T res = a[i].bar;
  keepAlive(this);
  return res;
}

This is a lot faster, maybe a little less magical, but still not beautiful.  I don't think there's any way to avoid the addition of a user call unless we change the language to guarantee later finalization/reference enqueueing.  And if you think about this hard enough, those guarantees would only be sufficient for what you really want in about 98% of cases (warning: made up statistic), since the finalizer might also do something bad to a[i].bar.  But they would probably "unbreak" a lot of existing code.

Hans

> 
> > There are other possible design tradeoffs, but they're more 
> invasive.  
> > Outlawing dead variable elimination for object references 
> works, and 
> > was discussed during JSR133 discussions.  At the time it we 
> felt that 
> > this was risking too much performance impact for a rarely used 
> > language feature.  Although I advocated this position (in 
> part to help 
> > get
>  > JSR133 out the door), I think that from a purely technical 
> perspective  > it's worth considering.
> 
> I personally don't want to see this level of GC 
> implementation detail visible to the developer and a 
> necessary part of their programming knowledge.  finalize() 
> has way too many bad things in it related to ordering etc.  
> Your paper talks about these things in great detail.  
> Exposing them will interfere with the JMM and the GC details 
> if they are made more controllable.
> 
> Rather than say we need a fence at the end of finalize(), why 
> not, instead say, use class XYZ to track references to 
> resources you need to release at the end of an objects life.  
> Then we have a more flexible way to manage this issue it 
> seems to me, and there is not the low level detail of locking 
> that the developer has to deal with.
> 
> > Although C++0x is expected to contain only very minimal GC support,
>  > and no finalization support, this issue was discussed in 
> some detail  > in that context, and I think the options could 
> probably all be  > adapted to Java.  This is largely written 
> up at  > 
> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2261.html .
> > 
> >> It is also important to note that this topic is very 
> related to the 
> >> memory model. The last point of reachability is just as 
> much subject 
> >> to reordering/inlining optimizations and an object can end 
> up being 
> >> collected even earlier than its last lexical reference.
>  >
> > Right.  And JSR133 at least made the symchronized(this) solution 
> > possible.  But we always knew that this wasn't a great solution.
> 
> It still seems to me that PhantomReference is the better 
> solution than finalize(), maybe you can tell me why that 
> isn't the case.
> 
> > I think keepAlive is really the minimal solution that people might 
> > realistically pay attention to.
> 
> It seems that the .NET solution is to just provide a standard 
> method name which does nothing, so that the compiler is 
> compelled to maintain order of execution and to maintain the 
> reference till the end of the method.  Is there something 
> else happening here?
> 
>  > I have to admit I'm not
> > encouraged by the .NET documentation that Matthias pointed 
> to, since 
> > it also seems to miss the core problem and focus on native
>  > code issues instead.
> 
> Hans, are you only talking about how finalize() works, or is 
> there another path in 100% java code that I still haven't 
> gleaned from this?
> 
> Gregg Wonderly
> 

From gergg at cox.net  Thu Jan 15 09:40:08 2009
From: gergg at cox.net (Gregg Wonderly)
Date: Thu, 15 Jan 2009 08:40:08 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>	<496E4B66.9070106@cytetech.com>
	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <496F4AC8.50802@cox.net>

Okay, I see.  You are focusing on the fact that there is a soft reference in the 
form of the integer to another object and the lack of an explicit reference 
allows for finalize() to run at inopportune moments.  It's certainly an issue 
for developers to think about that can, as you say, introduce NPEs that are 
barely explainable.

I do now see how the PhantomReference could be enqueued at the same instant that 
you are pointing to finalize being run, so that's certainly not going to change 
anything about timing of the initial call into finalization of the unreferenced 
chain.

Is there a better name that implies the end of the reference life?  To me, 
keepAlive means starting at this point, until I tell you otherwise.  Something 
like releaseHere(), or something similar would make more sense.

Thanks for the clarifications Hans!

Gregg Wonderly

Boehm, Hans wrote:
>  
> 
>> -----Original Message-----
>> From: Gregg Wonderly [mailto:gregg at cytetech.com] 
>>
>> ...
>> But PhantomReference makes finalize() unnecessary when you 
>> use the Holder pattern that my ReferenceTracker is based on.  
>> With that pattern, you don't have anything going on "bad" 
>> because the Tracker has a strong reference to the 
>> "to-be-released" resource and when the Holder goes out, the 
>> Tracker knows which object to use for "releasing" the 
>> associated resource(s).  Every object that has associated 
>> resources can be dealt with in this way, and any ordering 
>> requirements can all be managed via strong references where 
>> you are in complete control of the order of operations.
>>
>> My Tracker is much like the S object in your paper, so I 
>> think you familiar with where I'm coming from.
>>
>>  From my perspective, one can stop using finalize and 
>> worrying about all these data races by just adopting the 
>> pattern that I'm presenting through the use of my 
>> ReferenceTracker class.
> I think we're talking about completely different things.  The problem here is unrelated to ordering of different finalizer invocations, which can indeed be addressed with java.lang.ref, or with some finalizer usage patterns.
> 
> Consider a slightly expanded example.  I have a finalizable class S, which stores some of its data in a global array A.  Each element s of S contains a field index, such that A[s.index] contains the data associated with s.  The finaliser for s cleans up A[s.index].  Or s is referenced by some java.lang.ref and whoever pops it from the reference queue cleans it up.  It doesn't matter.  There are no other finalizable or java.lang.ref objects in the world.  (In some sense, this is the canonical use of these mechanisms, to clean up some external resource.  In simple cases, the external resource is actually an OS resource, but even that doesn't matter here.)
> 
> Assume s has a method foo that accesses the internal state as in
> 
> T foo()
> {
>   int i = index;
> 
> a:
>   return a[i].bar;
> }
> 
> Assume for the sake of specificity that S's finalizer just sets a[index] to null.  (In reality, it would probably also mark the entry as available, which would require some synchronization, as finalizers usually do.)
> 
> Assume this is called from a context:
> 
> s = new S;
> y = s.foo();
> // no further accesses to s.
> 
> Assume that x in the caller is allocated in a register that is also used to pass the this parameter to methods.  (A good register allocator should do exactly that in this case.)  Assume that the i in foo is allocated to the same register.  (This is fine, because the "this" argument is dead after "index" is looked up.)
> 
> Now assume that a simple stop the world garbage collection occurs at point a, and this thread is delayed until all cleanup actions are complete.  Thus A[i] will be set to null at point a, and the return statement will encounter a null pointer exception.  This is probably undesirable, and hence the code is wrong.
> 
> Currently this is fixable by putting a synchronized(this){} in the finalizer, and rewriting foo as
> 
> T foo()
> {
>   int i = index;
> 
> A:
>   T res = a[i].bar;
>   synchronized(this) {}
>   return res;
> }
> 
> We're proposing to allow this to be written as
> 
> T foo()
> {
>   int i = index;
> 
> A:
>   T res = a[i].bar;
>   keepAlive(this);
>   return res;
> }
> 
> This is a lot faster, maybe a little less magical, but still not beautiful.  I don't think there's any way to avoid the addition of a user call unless we change the language to guarantee later finalization/reference enqueueing.  And if you think about this hard enough, those guarantees would only be sufficient for what you really want in about 98% of cases (warning: made up statistic), since the finalizer might also do something bad to a[i].bar.  But they would probably "unbreak" a lot of existing code.
> 
> Hans
> 
>>> There are other possible design tradeoffs, but they're more 
>> invasive.  
>>> Outlawing dead variable elimination for object references 
>> works, and 
>>> was discussed during JSR133 discussions.  At the time it we 
>> felt that 
>>> this was risking too much performance impact for a rarely used 
>>> language feature.  Although I advocated this position (in 
>> part to help 
>>> get
>>  > JSR133 out the door), I think that from a purely technical 
>> perspective  > it's worth considering.
>>
>> I personally don't want to see this level of GC 
>> implementation detail visible to the developer and a 
>> necessary part of their programming knowledge.  finalize() 
>> has way too many bad things in it related to ordering etc.  
>> Your paper talks about these things in great detail.  
>> Exposing them will interfere with the JMM and the GC details 
>> if they are made more controllable.
>>
>> Rather than say we need a fence at the end of finalize(), why 
>> not, instead say, use class XYZ to track references to 
>> resources you need to release at the end of an objects life.  
>> Then we have a more flexible way to manage this issue it 
>> seems to me, and there is not the low level detail of locking 
>> that the developer has to deal with.
>>
>>> Although C++0x is expected to contain only very minimal GC support,
>>  > and no finalization support, this issue was discussed in 
>> some detail  > in that context, and I think the options could 
>> probably all be  > adapted to Java.  This is largely written 
>> up at  > 
>> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2261.html .
>>>> It is also important to note that this topic is very 
>> related to the 
>>>> memory model. The last point of reachability is just as 
>> much subject 
>>>> to reordering/inlining optimizations and an object can end 
>> up being 
>>>> collected even earlier than its last lexical reference.
>>  >
>>> Right.  And JSR133 at least made the symchronized(this) solution 
>>> possible.  But we always knew that this wasn't a great solution.
>> It still seems to me that PhantomReference is the better 
>> solution than finalize(), maybe you can tell me why that 
>> isn't the case.
>>
>>> I think keepAlive is really the minimal solution that people might 
>>> realistically pay attention to.
>> It seems that the .NET solution is to just provide a standard 
>> method name which does nothing, so that the compiler is 
>> compelled to maintain order of execution and to maintain the 
>> reference till the end of the method.  Is there something 
>> else happening here?
>>
>>  > I have to admit I'm not
>>> encouraged by the .NET documentation that Matthias pointed 
>> to, since 
>>> it also seems to miss the core problem and focus on native
>>  > code issues instead.
>>
>> Hans, are you only talking about how finalize() works, or is 
>> there another path in 100% java code that I still haven't 
>> gleaned from this?
>>
>> Gregg Wonderly
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 


From ashwin.jayaprakash at gmail.com  Thu Jan 15 16:16:18 2009
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Thu, 15 Jan 2009 13:16:18 -0800
Subject: [concurrency-interest] Clarification: volatile, final and atomic ops
Message-ID: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>

Hello,
I'm seeking some clarification with regards to volatile, final and atomic
ops.

I have pasted some really simple Java code that performs work in a loop
below. Every 1024 times, it updates an AtomicInteger with the results it has
accumulated so far.

I'd like to know if the access to the AtomicInteger which touches a volatile
field inside affects the loop all the other times the if(..) block is not
executed. I tried printing the Assembly using JDK7 and couldn't really
figure out anything from the output. So, even if the volatile field is
accessed only once every 1024 times, does the program issue a fence (right
term?) instruction all the time? If it does, then how do I avoid those
expensive volatile fields accesses?

What is the scope of the happens-before/after ordering that the VM ensures?
Is it restricted to field accesses and sync blocks within a method or the
program's entire instruction stream?

Program:

public class Temp {
    static final AtomicInteger STEP1_TOTAL = new AtomicInteger();

    static void test() {
        int localTotal = 0;

        for (int i = 0; i < 1000* 1024; i++) {
            localTotal += doComplexWorkStep1();

            if ((i & 1023) == 0) {
                STEP1_TOTAL.addAndGet(localTotal);
                localTotal = 0;
            }

            doComplexWorkStep2();
        }
    }

    static int doComplexWorkStep1() {
        return 100;
    }

    static void doComplexWorkStep2() {
    }

    public static void main(String[] args) {
        test();
    }
}

Also, how does using "final" for a Local Variable affect performance? Is it
just a compiler thing or does it also result in volatile-like access? How
about "final" for Fields?

Thanks and apologies for asking such dumb questions.

Ashwin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/dabfece9/attachment.html>

From joe.bowbeer at gmail.com  Thu Jan 15 16:44:03 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 15 Jan 2009 13:44:03 -0800
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
Message-ID: <31f2a7bd0901151344w4f2980cdg33d3f4effe79801a@mail.gmail.com>

The cost of atomic addAndGet depends on the VM implementation and the
underlying platform.  It may even depend on what other threads are doing.
The cost might be lower when there is low contention and higher when then is
high contention.  If the compiler (read "VM") can determine that there is no
contention, there may be no cost.  I try not to think about it too much.

What I can say definitively is that your code only pays the price when
addAndGet is invoked.  That is, once every 1024 iterations.

Concerning final, that's a compiler thing.

Joe

On Thu, Jan 15, 2009 at 1:16 PM, Ashwin Jayaprakash wrote:

> Hello,
> I'm seeking some clarification with regards to volatile, final and atomic
> ops.
>
> I have pasted some really simple Java code that performs work in a loop
> below. Every 1024 times, it updates an AtomicInteger with the results it has
> accumulated so far.
>
> I'd like to know if the access to the AtomicInteger which touches a
> volatile field inside affects the loop all the other times the if(..) block
> is not executed. I tried printing the Assembly using JDK7 and couldn't
> really figure out anything from the output. So, even if the volatile field
> is accessed only once every 1024 times, does the program issue a fence
> (right term?) instruction all the time? If it does, then how do I avoid
> those expensive volatile fields accesses?
>
> What is the scope of the happens-before/after ordering that the VM ensures?
> Is it restricted to field accesses and sync blocks within a method or the
> program's entire instruction stream?
>
> Program:
>
> public class Temp {
>     static final AtomicInteger STEP1_TOTAL = new AtomicInteger();
>
>     static void test() {
>         int localTotal = 0;
>
>         for (int i = 0; i < 1000* 1024; i++) {
>             localTotal += doComplexWorkStep1();
>
>             if ((i & 1023) == 0) {
>                 STEP1_TOTAL.addAndGet(localTotal);
>                 localTotal = 0;
>             }
>
>             doComplexWorkStep2();
>         }
>     }
>
>     static int doComplexWorkStep1() {
>         return 100;
>     }
>
>     static void doComplexWorkStep2() {
>     }
>
>     public static void main(String[] args) {
>         test();
>     }
> }
>
> Also, how does using "final" for a Local Variable affect performance? Is it
> just a compiler thing or does it also result in volatile-like access? How
> about "final" for Fields?
>
> Thanks and apologies for asking such dumb questions.
>
> Ashwin.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/8eea4499/attachment.html>

From jason.greene at redhat.com  Thu Jan 15 17:11:33 2009
From: jason.greene at redhat.com (Jason T. Greene)
Date: Thu, 15 Jan 2009 16:11:33 -0600
Subject: [concurrency-interest] Clarification: volatile,
 final and atomic ops
In-Reply-To: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
Message-ID: <496FB495.5010201@redhat.com>

Ashwin Jayaprakash wrote:
> Hello,
> I'm seeking some clarification with regards to volatile, final and 
> atomic ops.
> 
> I have pasted some really simple Java code that performs work in a loop 
> below. Every 1024 times, it updates an AtomicInteger with the results it 
> has accumulated so far.
> 
> I'd like to know if the access to the AtomicInteger which touches a 
> volatile field inside affects the loop all the other times the if(..) 
> block is not executed. I tried printing the Assembly using JDK7 and 
> couldn't really figure out anything from the output. So, even if the 
> volatile field is accessed only once every 1024 times, does the program 
> issue a fence (right term?) instruction all the time? 

No they are issued only when the field is accessed.

? If it does, then
> how do I avoid those expensive volatile fields accesses?
> 
> What is the scope of the happens-before/after ordering that the VM 
> ensures? Is it restricted to field accesses and sync blocks within a 
> method or the program's entire instruction stream?

Thats a long answer. I would start here:
http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html

> Program:
> 
> public class Temp {
>     static final AtomicInteger STEP1_TOTAL = new AtomicInteger();
> 
>     static void test() {
>         int localTotal = 0;
>         
>         for (int i = 0; i < 1000* 1024; i++) {
>             localTotal += doComplexWorkStep1();
> 
>             if ((i & 1023) == 0) {
>                 STEP1_TOTAL.addAndGet(localTotal);
>                 localTotal = 0;
>             }
> 
>             doComplexWorkStep2();
>         }
>     }
> 
>     static int doComplexWorkStep1() {
>         return 100;
>     }
> 
>     static void doComplexWorkStep2() {
>     }
> 
>     public static void main(String[] args) {
>         test();
>     }
> }
> 
> Also, how does using "final" for a Local Variable affect performance? Is 
> it just a compiler thing or does it also result in volatile-like access? 
> How about "final" for Fields?

See above FAQ

-- 
Jason T. Greene
JBoss, a division of Red Hat

From ashwin.jayaprakash at gmail.com  Thu Jan 15 18:10:15 2009
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Thu, 15 Jan 2009 15:10:15 -0800
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <496FB495.5010201@redhat.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
	<496FB495.5010201@redhat.com>
Message-ID: <837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>

Thanks Jason!

I knew about JSR-133, but it still does not clarify if accessing a "final"
field or local variable is slower than a non-final field, for what ever
reasons... Does a final field/variable access incur additional cost?

Ashwin.


On Thu, Jan 15, 2009 at 2:11 PM, Jason T. Greene <jason.greene at redhat.com>wrote:

> Ashwin Jayaprakash wrote:
>
>> Hello,
>> I'm seeking some clarification with regards to volatile, final and atomic
>> ops.
>>
>> I have pasted some really simple Java code that performs work in a loop
>> below. Every 1024 times, it updates an AtomicInteger with the results it has
>> accumulated so far.
>>
>> I'd like to know if the access to the AtomicInteger which touches a
>> volatile field inside affects the loop all the other times the if(..) block
>> is not executed. I tried printing the Assembly using JDK7 and couldn't
>> really figure out anything from the output. So, even if the volatile field
>> is accessed only once every 1024 times, does the program issue a fence
>> (right term?) instruction all the time?
>>
>
> No they are issued only when the field is accessed.
>
> ? If it does, then
>
>> how do I avoid those expensive volatile fields accesses?
>>
>> What is the scope of the happens-before/after ordering that the VM
>> ensures? Is it restricted to field accesses and sync blocks within a method
>> or the program's entire instruction stream?
>>
>
> Thats a long answer. I would start here:
> http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html<http://www.cs.umd.edu/%7Epugh/java/memoryModel/jsr-133-faq.html>
>
>  Program:
>>
>> public class Temp {
>>    static final AtomicInteger STEP1_TOTAL = new AtomicInteger();
>>
>>    static void test() {
>>        int localTotal = 0;
>>                for (int i = 0; i < 1000* 1024; i++) {
>>            localTotal += doComplexWorkStep1();
>>
>>            if ((i & 1023) == 0) {
>>                STEP1_TOTAL.addAndGet(localTotal);
>>                localTotal = 0;
>>            }
>>
>>            doComplexWorkStep2();
>>        }
>>    }
>>
>>    static int doComplexWorkStep1() {
>>        return 100;
>>    }
>>
>>    static void doComplexWorkStep2() {
>>    }
>>
>>    public static void main(String[] args) {
>>        test();
>>    }
>> }
>>
>> Also, how does using "final" for a Local Variable affect performance? Is
>> it just a compiler thing or does it also result in volatile-like access? How
>> about "final" for Fields?
>>
>
> See above FAQ
>
> --
> Jason T. Greene
> JBoss, a division of Red Hat
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/d5033a55/attachment-0001.html>

From ashwin.jayaprakash at gmail.com  Thu Jan 15 18:23:43 2009
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Thu, 15 Jan 2009 15:23:43 -0800
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
	<496FB495.5010201@redhat.com>
	<837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
Message-ID: <837c23d40901151523k5c8ff104u5ed73f9a3ff3382b@mail.gmail.com>

I know I sound obtuse, but I'm wondering how, without knowing whether the
next instruction - in this case the if(..) block and hence the volatile
field access is going to be executed or not, can the compiler or CPU go
ahead and re-order instructions that logically come after the if(..) block?

I mean, can the instructions after the if(..) get executed even before the
if(..) is evaluated and then realize that the if(..) is true and so requires
a fence..so all the re-ordering and execution will have to be discarded...Is
that how it works?

Ashwin.


On Thu, Jan 15, 2009 at 3:10 PM, Ashwin Jayaprakash <
ashwin.jayaprakash at gmail.com> wrote:

> Thanks Jason!
>
> I knew about JSR-133, but it still does not clarify if accessing a "final"
> field or local variable is slower than a non-final field, for what ever
> reasons... Does a final field/variable access incur additional cost?
>
> Ashwin.
>
>
>
> On Thu, Jan 15, 2009 at 2:11 PM, Jason T. Greene <jason.greene at redhat.com>wrote:
>
>> Ashwin Jayaprakash wrote:
>>
>>> Hello,
>>> I'm seeking some clarification with regards to volatile, final and atomic
>>> ops.
>>>
>>> I have pasted some really simple Java code that performs work in a loop
>>> below. Every 1024 times, it updates an AtomicInteger with the results it has
>>> accumulated so far.
>>>
>>> I'd like to know if the access to the AtomicInteger which touches a
>>> volatile field inside affects the loop all the other times the if(..) block
>>> is not executed. I tried printing the Assembly using JDK7 and couldn't
>>> really figure out anything from the output. So, even if the volatile field
>>> is accessed only once every 1024 times, does the program issue a fence
>>> (right term?) instruction all the time?
>>>
>>
>> No they are issued only when the field is accessed.
>>
>> ? If it does, then
>>
>>> how do I avoid those expensive volatile fields accesses?
>>>
>>> What is the scope of the happens-before/after ordering that the VM
>>> ensures? Is it restricted to field accesses and sync blocks within a method
>>> or the program's entire instruction stream?
>>>
>>
>> Thats a long answer. I would start here:
>> http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html<http://www.cs.umd.edu/%7Epugh/java/memoryModel/jsr-133-faq.html>
>>
>>  Program:
>>>
>>> public class Temp {
>>>    static final AtomicInteger STEP1_TOTAL = new AtomicInteger();
>>>
>>>    static void test() {
>>>        int localTotal = 0;
>>>                for (int i = 0; i < 1000* 1024; i++) {
>>>            localTotal += doComplexWorkStep1();
>>>
>>>            if ((i & 1023) == 0) {
>>>                STEP1_TOTAL.addAndGet(localTotal);
>>>                localTotal = 0;
>>>            }
>>>
>>>            doComplexWorkStep2();
>>>        }
>>>    }
>>>
>>>    static int doComplexWorkStep1() {
>>>        return 100;
>>>    }
>>>
>>>    static void doComplexWorkStep2() {
>>>    }
>>>
>>>    public static void main(String[] args) {
>>>        test();
>>>    }
>>> }
>>>
>>> Also, how does using "final" for a Local Variable affect performance? Is
>>> it just a compiler thing or does it also result in volatile-like access? How
>>> about "final" for Fields?
>>>
>>
>> See above FAQ
>>
>> --
>> Jason T. Greene
>> JBoss, a division of Red Hat
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/038e882a/attachment.html>

From jason.greene at redhat.com  Thu Jan 15 18:41:41 2009
From: jason.greene at redhat.com (Jason T. Greene)
Date: Thu, 15 Jan 2009 17:41:41 -0600
Subject: [concurrency-interest] Clarification: volatile,
 final and atomic ops
In-Reply-To: <837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>	
	<496FB495.5010201@redhat.com>
	<837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
Message-ID: <496FC9B5.4020500@redhat.com>

Ashwin Jayaprakash wrote:
> Thanks Jason!
> 
> I knew about JSR-133, but it still does not clarify if accessing a 
> "final" field or local variable is slower than a non-final field, for 
> what ever reasons... Does a final field/variable access incur additional 
> cost?

A final field has cost since it does prevent certain reorderings that 
allow it to be safely published to another thread. Although, due to it's 
restrictions, final field access can be optimized more than volatile access.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From joe.bowbeer at gmail.com  Thu Jan 15 18:50:41 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 15 Jan 2009 15:50:41 -0800
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <837c23d40901151523k5c8ff104u5ed73f9a3ff3382b@mail.gmail.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
	<496FB495.5010201@redhat.com>
	<837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
	<837c23d40901151523k5c8ff104u5ed73f9a3ff3382b@mail.gmail.com>
Message-ID: <31f2a7bd0901151550i5a369165v52f925a44e5c0913@mail.gmail.com>

On Thu, Jan 15, 2009 at 3:23 PM, Ashwin Jayaprakash wrote:

> I know I sound obtuse, but I'm wondering how, without knowing whether the
> next instruction - in this case the if(..) block and hence the volatile
> field access is going to be executed or not, can the compiler or CPU go
> ahead and re-order instructions that logically come after the if(..) block?
>
> I mean, can the instructions after the if(..) get executed even before the
> if(..) is evaluated and then realize that the if(..) is true and so requires
> a fence..so all the re-ordering and execution will have to be discarded...Is
> that how it works?
>
> Ashwin.
>

In terms of how, this might be what you're looking for:

http://gee.cs.oswego.edu/dl/jmm/cookbook.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/98219dfb/attachment.html>

From giorgio.zoppi at gmail.com  Thu Jan 15 18:57:16 2009
From: giorgio.zoppi at gmail.com (Giorgio Zoppi)
Date: Fri, 16 Jan 2009 00:57:16 +0100
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <496FC9B5.4020500@redhat.com>
References: <837c23d40901151316n4c52d0bbid7c2e83ee7428e9a@mail.gmail.com>
	<496FB495.5010201@redhat.com>
	<837c23d40901151510y4dd0e220r7eadd2a2c2afaff2@mail.gmail.com>
	<496FC9B5.4020500@redhat.com>
Message-ID: <c83c917f0901151557w21073141xf550f898448e86c3@mail.gmail.com>

Take a look at this one excellent article on volatile in several
platform (C++, .NET, Java):

http://www.ddj.com/hpc-high-performance-computing/212701484
Just my 1c.

-- 
Quiero ser el rayo de sol que cada d?a te despierta
para hacerte respirar y vivir en me.
"Favola -Moda".


From dcholmes at optusnet.com.au  Thu Jan 15 19:45:25 2009
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 16 Jan 2009 10:45:25 +1000
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <496FC9B5.4020500@redhat.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCECJHPAA.dcholmes@optusnet.com.au>

Jason T. Greene writes:
> Ashwin Jayaprakash wrote:
> > Thanks Jason!
> >
> > I knew about JSR-133, but it still does not clarify if accessing a
> > "final" field or local variable is slower than a non-final field, for
> > what ever reasons... Does a final field/variable access incur
> > additional cost?
>
> A final field has cost since it does prevent certain reorderings that
> allow it to be safely published to another thread. Although, due to it's
> restrictions, final field access can be optimized more than
> volatile access.

But note that, sadly, compilers have not, in the past, been good at doing
this. Hence you will often see in code that a final field is loaded into a
local variable if used a number of times.

And a "final local variable" has no runtime semantics and no associated
costs - it is completely unrelated to use of final/volatile in the memory
model. final local variables and final method parameters are a compile-time
indicator that a variable will not be assigned to, which is needed if the
variable is to be accessed from an inner class.

David Holmes


From ashwin.jayaprakash at gmail.com  Thu Jan 15 20:20:21 2009
From: ashwin.jayaprakash at gmail.com (Ashwin Jayaprakash)
Date: Thu, 15 Jan 2009 17:20:21 -0800
Subject: [concurrency-interest] Clarification: volatile,
	final and atomic ops
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCECJHPAA.dcholmes@optusnet.com.au>
References: <496FC9B5.4020500@redhat.com>
	<NFBBKALFDCPFIDBNKAPCCECJHPAA.dcholmes@optusnet.com.au>
Message-ID: <837c23d40901151720i3cdb677fn9c82b5353be69b43@mail.gmail.com>

I was worried that final local variables were also expensive. That cleared
things up.

Thanks!
Ashwin.


On Thu, Jan 15, 2009 at 4:45 PM, David Holmes <dcholmes at optusnet.com.au>wrote:

> Jason T. Greene writes:
> > Ashwin Jayaprakash wrote:
> > > Thanks Jason!
> > >
> > > I knew about JSR-133, but it still does not clarify if accessing a
> > > "final" field or local variable is slower than a non-final field, for
> > > what ever reasons... Does a final field/variable access incur
> > > additional cost?
> >
> > A final field has cost since it does prevent certain reorderings that
> > allow it to be safely published to another thread. Although, due to it's
> > restrictions, final field access can be optimized more than
> > volatile access.
>
> But note that, sadly, compilers have not, in the past, been good at doing
> this. Hence you will often see in code that a final field is loaded into a
> local variable if used a number of times.
>
> And a "final local variable" has no runtime semantics and no associated
> costs - it is completely unrelated to use of final/volatile in the memory
> model. final local variables and final method parameters are a compile-time
> indicator that a variable will not be assigned to, which is needed if the
> variable is to be accessed from an inner class.
>
> David Holmes
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090115/3594de8c/attachment-0001.html>

From dl at cs.oswego.edu  Fri Jan 16 08:43:12 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 16 Jan 2009 08:43:12 -0500
Subject: [concurrency-interest] Fences, AtomicXFieldUpdater enhancements,
	and @Racy annotations
Message-ID: <49708EF0.20605@cs.oswego.edu>

[This one is equally on java.util.concurrent and JMM issues,
so please be tolerant of cross-post duplication.]

First, I'm getting more confident that the specs for Fence
API are in the right ballpark, although still need a bit
more precision in the discussion of "scopes".  (If anyone
want to help, please do!) See the updated draft
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

Second, I am continuing my crusade to rid the world of
explicit use of "sun.misc.Unsafe". And these plans might
mesh well with the usage concerns that Bill Pugh and I have
discussed and that he's posted about (as in: "yow" :-)

Here's the story.

As mentioned in my initial posting on Fences (1) everyone would
be happier if they almost never had to use them directly, but
instead could get the effects via methods with recognizable
semantics (2) people can get some of these effects already by
using AtomicXFieldUpdaters, but even in those cases often don't.

We can address these, and make AtomicXFieldUpdaters
(1) Applicable in more contexts
(2) Cheaper in most cases where performance matters.
(3) Better advertise intent

Background. For those who have never used them,
AtomicXFieldUpdaters are ugly to declare, but provide
operations like compareAndSet to (volatile) fields of
objects directly, without needing to create stand-alone
AtomicX objects. (If you don't do a lot of low/medium-level
parallel/concurrent programming, you might not think this is
a big deal.  But it is: footprint, locality, and indirection
hurt a lot more here than in sequential programs.)

Here's a sample usage (pasted from ConcurrentSkipListMap)

public class ConcurrentSkipListMap<K,V> ....  {
     /**
      * The topmost head index of the skiplist.
      */
     private transient volatile HeadIndex<K,V> head;

     private static final
         AtomicReferenceFieldUpdater<ConcurrentSkipListMap, HeadIndex>
         headUpdater = AtomicReferenceFieldUpdater.newUpdater
         (ConcurrentSkipListMap.class, HeadIndex.class, "head");

     /**
      * compareAndSet head node
      */
     private boolean casHead(HeadIndex<K,V> cmp, HeadIndex<K,V> val) {
         return headUpdater.compareAndSet(this, cmp, val);
     }

     // ...
}

We can't do much about the 4 lines it takes to declare
one of these (maybe IDEs could help), but we can address
the other problems.

1. Less restrictive API

Right now, we require that the target field be "volatile",
and don't support any non-volatile, "relaxed" operations
through it. As we've been discussing wrt Fences, there are
use cases where these arise. We can support them by lifting
volatile field declaration restriction and/or supplying two
additional methods (illustrated with
AtomicIntegerFieldUpdater).

     /**
      * Gets the value held in the field of the given object managed
      * by this updater, using non-volatile memory consistency rules.
      *
      * @param obj An object whose field to get
      * @return the current value
      */
     public abstract int relaxedGet(T obj);

     /**
      * Sets the field of the given object managed by this updater to the
      * given updated value using non-volatile memory consistency rules.
      *
      * @param obj An object whose field to set
      * @param newValue the new value
      */
     public abstract void relaxedSet(T obj, int newValue);

(Additionally, we need to include AtomicXArrayUpdater
classes, that differ from AtomicXArrays in that you hand an
existing array to constructor/factory-method. We had been
resisting this for similar reasons.)


2. Better typical performance

First, more background:

When people use Unsafe rather than updaters, it is often
because they have discovered that there is non-trivial
dynamic check overhead when using updater methods -- this
overhead dwarfs that of some of the simpler operations like
get(). The reason these checks exist is that even though all
usages are statically typesafe with respect to a Java
compiler, we must protect against people writing raw
bytecode that uses the underlying intrinsics to access
inaccessbile data etc. Such code can otherwise make it
through class loading checks etc, so must be screened.

The now common "try to use Unsafe anyway" hacks (like those
near the bottom of the preliminary releases of jsr166y
classes like ForkJoinPool), exist solely to bypass this: If
the class/caller is allowed to use Unsafe because it is in
bootclasspath or the program has no SecurityManager, or one
that allows access to Unsafe, then do so, else abort.

The improvement to updaters is to automate and extend this
hack: If you are allowed to access Unsafe, provide an
updater that bypasses checks, else the slower kind (rather
than aborting). Luckily we use static factories here so this
part is straightforward. This is a little tricky to set up
but seems doable, subject to review of mechanics by security
folks.

The net result is that updaters will have performance that
should be identical to raw Unsafe calls in usages that do
not require security checks, which is very likely to include
most performance-sensitive applications.  Those that do need
checks will be slower, but for good reason.

3. Better advertised use

The above changes will make updaters a lot more useful and
probably a lot more used.  In fact, there are reasonable
ways to use them to get almost all the effects of Fences
(not quite all though).

But with power comes responsibility.
One downside of updaters is that the declaration of
an updater is removed from the declaration of the field
it is updating, which makes usage hard to check.

This is where annotations can help: Any field that
will be used via an updater should have some annotation
saying so. One good candidate name for this annotation is
   @Racy
The reasoning is that any such variable is allowed
to be used in ways that "don't count" with respect
to the usual definitions of race-freedom.

I don't think it is essential that @Racy be a required
annotation that is checked by javac, but it is essential
for extended checkers, which could help enforce the
typically (but probably not universally) desirable
requirement that if a variable is declared as
@Racy, then ALL reads and writes of it must go through updaters.

It's further possible to make @Racy take some sort of
argument expressing intent, like @Racy("Publish").  But if
this goes anywhere, these issues are probably best left to
JSR305.

Aside to Paul McKenney and other foreigners.  Notice that,
under this scheme, @Racy is nearly synonymous with C++0x "atomic"
but has a much more accurate name :-)

-Doug



From alarmnummer at gmail.com  Fri Jan 16 10:00:21 2009
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Fri, 16 Jan 2009 16:00:21 +0100
Subject: [concurrency-interest] Fences, AtomicXFieldUpdater enhancements,
	and @Racy annotations
In-Reply-To: <49708EF0.20605@cs.oswego.edu>
References: <49708EF0.20605@cs.oswego.edu>
Message-ID: <1466c1d60901160700s64420c46i16ed3cb6a70fe6f@mail.gmail.com>

Hi Doug,

can you tell us something about the internals of the atomic field
updaters? Do they work based on reflection, if yes, what is the
performance impact?

And what is the performance compared to a normal AtomicXXX class?

On Fri, Jan 16, 2009 at 2:43 PM, Doug Lea <dl at cs.oswego.edu> wrote:
> [This one is equally on java.util.concurrent and JMM issues,
> so please be tolerant of cross-post duplication.]
>
> First, I'm getting more confident that the specs for Fence
> API are in the right ballpark, although still need a bit
> more precision in the discussion of "scopes".  (If anyone
> want to help, please do!) See the updated draft
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
>
> Second, I am continuing my crusade to rid the world of
> explicit use of "sun.misc.Unsafe". And these plans might
> mesh well with the usage concerns that Bill Pugh and I have
> discussed and that he's posted about (as in: "yow" :-)
>
> Here's the story.
>
> As mentioned in my initial posting on Fences (1) everyone would
> be happier if they almost never had to use them directly, but
> instead could get the effects via methods with recognizable
> semantics (2) people can get some of these effects already by
> using AtomicXFieldUpdaters, but even in those cases often don't.
>
> We can address these, and make AtomicXFieldUpdaters
> (1) Applicable in more contexts
> (2) Cheaper in most cases where performance matters.
> (3) Better advertise intent
>
> Background. For those who have never used them,
> AtomicXFieldUpdaters are ugly to declare, but provide
> operations like compareAndSet to (volatile) fields of
> objects directly, without needing to create stand-alone
> AtomicX objects. (If you don't do a lot of low/medium-level
> parallel/concurrent programming, you might not think this is
> a big deal.  But it is: footprint, locality, and indirection
> hurt a lot more here than in sequential programs.)
>
> Here's a sample usage (pasted from ConcurrentSkipListMap)
>
> public class ConcurrentSkipListMap<K,V> ....  {
>    /**
>     * The topmost head index of the skiplist.
>     */
>    private transient volatile HeadIndex<K,V> head;
>
>    private static final
>        AtomicReferenceFieldUpdater<ConcurrentSkipListMap, HeadIndex>
>        headUpdater = AtomicReferenceFieldUpdater.newUpdater
>        (ConcurrentSkipListMap.class, HeadIndex.class, "head");
>
>    /**
>     * compareAndSet head node
>     */
>    private boolean casHead(HeadIndex<K,V> cmp, HeadIndex<K,V> val) {
>        return headUpdater.compareAndSet(this, cmp, val);
>    }
>
>    // ...
> }
>
> We can't do much about the 4 lines it takes to declare
> one of these (maybe IDEs could help), but we can address
> the other problems.
>
> 1. Less restrictive API
>
> Right now, we require that the target field be "volatile",
> and don't support any non-volatile, "relaxed" operations
> through it. As we've been discussing wrt Fences, there are
> use cases where these arise. We can support them by lifting
> volatile field declaration restriction and/or supplying two
> additional methods (illustrated with
> AtomicIntegerFieldUpdater).
>
>    /**
>     * Gets the value held in the field of the given object managed
>     * by this updater, using non-volatile memory consistency rules.
>     *
>     * @param obj An object whose field to get
>     * @return the current value
>     */
>    public abstract int relaxedGet(T obj);
>
>    /**
>     * Sets the field of the given object managed by this updater to the
>     * given updated value using non-volatile memory consistency rules.
>     *
>     * @param obj An object whose field to set
>     * @param newValue the new value
>     */
>    public abstract void relaxedSet(T obj, int newValue);
>
> (Additionally, we need to include AtomicXArrayUpdater
> classes, that differ from AtomicXArrays in that you hand an
> existing array to constructor/factory-method. We had been
> resisting this for similar reasons.)
>
>
> 2. Better typical performance
>
> First, more background:
>
> When people use Unsafe rather than updaters, it is often
> because they have discovered that there is non-trivial
> dynamic check overhead when using updater methods -- this
> overhead dwarfs that of some of the simpler operations like
> get(). The reason these checks exist is that even though all
> usages are statically typesafe with respect to a Java
> compiler, we must protect against people writing raw
> bytecode that uses the underlying intrinsics to access
> inaccessbile data etc. Such code can otherwise make it
> through class loading checks etc, so must be screened.
>
> The now common "try to use Unsafe anyway" hacks (like those
> near the bottom of the preliminary releases of jsr166y
> classes like ForkJoinPool), exist solely to bypass this: If
> the class/caller is allowed to use Unsafe because it is in
> bootclasspath or the program has no SecurityManager, or one
> that allows access to Unsafe, then do so, else abort.
>
> The improvement to updaters is to automate and extend this
> hack: If you are allowed to access Unsafe, provide an
> updater that bypasses checks, else the slower kind (rather
> than aborting). Luckily we use static factories here so this
> part is straightforward. This is a little tricky to set up
> but seems doable, subject to review of mechanics by security
> folks.
>
> The net result is that updaters will have performance that
> should be identical to raw Unsafe calls in usages that do
> not require security checks, which is very likely to include
> most performance-sensitive applications.  Those that do need
> checks will be slower, but for good reason.
>
> 3. Better advertised use
>
> The above changes will make updaters a lot more useful and
> probably a lot more used.  In fact, there are reasonable
> ways to use them to get almost all the effects of Fences
> (not quite all though).
>
> But with power comes responsibility.
> One downside of updaters is that the declaration of
> an updater is removed from the declaration of the field
> it is updating, which makes usage hard to check.
>
> This is where annotations can help: Any field that
> will be used via an updater should have some annotation
> saying so. One good candidate name for this annotation is
>  @Racy
> The reasoning is that any such variable is allowed
> to be used in ways that "don't count" with respect
> to the usual definitions of race-freedom.
>
> I don't think it is essential that @Racy be a required
> annotation that is checked by javac, but it is essential
> for extended checkers, which could help enforce the
> typically (but probably not universally) desirable
> requirement that if a variable is declared as
> @Racy, then ALL reads and writes of it must go through updaters.
>
> It's further possible to make @Racy take some sort of
> argument expressing intent, like @Racy("Publish").  But if
> this goes anywhere, these issues are probably best left to
> JSR305.
>
> Aside to Paul McKenney and other foreigners.  Notice that,
> under this scheme, @Racy is nearly synonymous with C++0x "atomic"
> but has a much more accurate name :-)
>
> -Doug
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Fri Jan 16 10:24:17 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 16 Jan 2009 10:24:17 -0500
Subject: [concurrency-interest] Fences, AtomicXFieldUpdater enhancements,
 and @Racy annotations
In-Reply-To: <1466c1d60901160700s64420c46i16ed3cb6a70fe6f@mail.gmail.com>
References: <49708EF0.20605@cs.oswego.edu>
	<1466c1d60901160700s64420c46i16ed3cb6a70fe6f@mail.gmail.com>
Message-ID: <4970A6A1.4020707@cs.oswego.edu>

Peter Veentjer wrote:
> Hi Doug,
> 
> can you tell us something about the internals of the atomic field
> updaters? Do they work based on reflection, if yes, what is the
> performance impact?

You can see the current implementation of the int version at
http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/atomic/AtomicInteger.java?view=log

(It is possible that some JVMs use a different approach, but
I don't think so -- I think all production JVMs use our code.)

It is established using reflection, but then uses the information
collected to do a bunch of checks on a per-call basis.

The trusted streamlined version of, for example AtomicIntegerFieldUpdater.get
is just:
         public int get(T obj) {
             return unsafe.getIntVolatile(obj, offset);
         }
which does not normally entail even a function call, because of
intrinsification. And the method itself is trivially inlinable, so
almost always is. So, ideally,
   int v = aVolatile
and
   int v = aVolatileUpdater.get(this);
run exactly the same.

> 
> And what is the performance compared to a normal AtomicXXX class?

This is where the footprint, locality and indirection issues come in.
Sometimes it is actually better to offload volatile/atomic
operations to a little stand-alone object, but more often it isn't.
Ignoring these, the performance of
   int v = anAtomicInteger.get()
should be about the same with respect to the get() operation
itself (i.e., ignoring the indirection).

-Doug



From jeremy.manson at gmail.com  Sun Jan 18 20:08:27 2009
From: jeremy.manson at gmail.com (Jeremy Manson)
Date: Sun, 18 Jan 2009 17:08:27 -0800
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <496DF4C1.1000105@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
Message-ID: <1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>

Oh, right, we always meant to do that.  Good idea!

I have two concerns with the javadoc:

First, I think it might be unclear to the reader that the problem
arises in that example, because nothing is seen to call the
constructor.  Also, we specified it so that you couldn't finalize the
object until the constructor until the constructor completes, so, for
the purposes of making the point more clearly, it might be a little
odd to call keepAlive on an object before its constructor completes.

Second, I think it might be helpful to have a stronger statement of
the problem in the Javadoc.  When I explain that this can happen to
people, they are usually mystified and then shocked.  Something like
"When a runtime can detect that no reference to an object will ever be
stored in the heap, the garbage collector can reclaim that object at
any time.  This can happen even if the object itself, of fields of
that object, are still in use.  See Section 12.6.1 of the Java
Language Specification for more details."  might be more complete.

Jeremy


On Wed, Jan 14, 2009 at 6:20 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>
> [Same cross-post conventions as the last one.]
>
> As another make-good for a long-standing problem, the
> Fences class should include what amounts to a fence with
> respect to the garbage collector. This addresses a problem that
> Hans Boehm has written and talked about for years.
> (Google finds his JavaOne 2005 slides at
> http://gceclub.sun.com.cn/java_one_online/2005/TS-3281/ts-3281.pdf)
>
> This turns out not to be expressible using other kinds of
> fences. It tells the compiler/runtime that the ref in
> question must be considered as being used even if nothing in
> the program itself indicates it. (The suggested JVM implementation
> of this is an "opaque fence" that bypasses/evades any
> mechanics or optimizations that might cause ref to vanish.)
>
> Here's a first pass at javadoc/spec. Comments welcome.
>
>    /**
>     * Ensures that object referenced by the given reference is not
>     * reclaimable by garbage collection until after the invocation of
>     * this method. Among other related usages, this method may assist
>     * efforts to ensure that finalization associated with garbage
>     * collection does not occur before the finalized resources have
>     * even been established.  For example:
>     *
>     * <pre>
>     * class Resource {
>     *   static NativeResource nativeResourceArray = ...
>     *   static void registerInArray(int index) { ... }
>     *   int myIndex;
>     *   void setup() {
>     *      int i = myIndex;
>     *      registerInArray(i);
>     *      keepAlive(this);
>     *   }
>     *   Resource(...) {
>     *     myIndex = ...
>     *     setup();
>     *   }
>     * }
>     * </pre>
>     * @param ref the reference
>     */
>    public static <T> keepAlive(T ref);
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dl at cs.oswego.edu  Mon Jan 19 06:15:06 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 19 Jan 2009 06:15:06 -0500
Subject: [concurrency-interest] Fences.keepAlive
In-Reply-To: <1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
Message-ID: <497460BA.3030605@cs.oswego.edu>

Jeremy Manson wrote:
> Oh, right, we always meant to do that.  Good idea!
> 
> I have two concerns with the javadoc:
> 
> First, I think it might be unclear to the reader that the problem
> arises in that example, because nothing is seen to call the
> constructor. 

Can you (or anyone) think of a better short example?

> Second, I think it might be helpful to have a stronger statement of
> the problem in the Javadoc.  When I explain that this can happen to
> people, they are usually mystified and then shocked.  Something like
> "When a runtime can detect that no reference to an object will ever be
> stored in the heap, the garbage collector can reclaim that object at
> any time.  This can happen even if the object itself, of fields of
> that object, are still in use.  See Section 12.6.1 of the Java
> Language Specification for more details."  might be more complete.
> 

Thanks! I added a light edit of this.

-DOug



From robertlazarski at gmail.com  Mon Jan 19 14:17:43 2009
From: robertlazarski at gmail.com (robert lazarski)
Date: Mon, 19 Jan 2009 16:17:43 -0300
Subject: [concurrency-interest] Thread pools threads exhausted?
Message-ID: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>

Hi all,

I have an app that reads a lot of url's via apache's httpclient, which
is documented to be thread safe. About once a week or so, we can no
longer query the url's without restarting the app server. We've done a
lot of debugging, but have not isolated the cause yet. One of the
things we are unsure of is the state of our ExecutorService. How can
we tell if all the threads we assigned to the pool are still alive?
Maybe we get timeouts because no threads are available? Our code is
below, which is a springframework bean and therefore deployed in
singleton mode by default. When it fails, the Future times out
repeatably until we restart the app server.  We don't see any uncaught
exception logs.

public class URLReader {
	
	private static final ThreadFactory factory = new
ONExceptionThreadFactory(new ONExceptionHandler());
	private static final ExecutorService executorService =
Executors.newFixedThreadPool(10, factory);
	// See the HttpClient options if need be in HttpConnectionManager the
associated Parameters class.
	private HttpClient objHttp;

	/** commons logging declaration. */
    private static Log logger = LogFactory.getLog(
    		URLReader.class);

    private int timeout_in_seconds;
    private int max_tries;
    private String appInstance;
	
	/**
     * Connect to given URL and return response, or timeout. See
http://commons.apache.org/httpclient/threading.html
     * for programming guidelines and default settings.
     *
     * The behavior of this method is to encode the url.
     */
    public String readURL(final String url) throws Exception {

    	// lazy init
    	if (objHttp == null) {
    		MultiThreadedHttpConnectionManager mgr = new
MultiThreadedHttpConnectionManager();
    		HttpConnectionManagerParams params = new HttpConnectionManagerParams();
    		params.setDefaultMaxConnectionsPerHost(10);
    		mgr.setParams(params);
    		objHttp = new HttpClient(mgr);
    	}
		Callable<String> task = new Callable<String>() {
		     public String call() {
	        	 logger.debug("appInstance: "+appInstance+ " , says ...
readURL call() invoked with url: " + url);
	             // Send the POST request.
	             PostMethod objPost = new PostMethod(url);
		         try {
		             objHttp.executeMethod(objPost);
	                     // Read the response.
		             byte[] byteResponse = objPost.getResponseBody();
		             return new String(byteResponse);
		         } catch (Exception ex) {
		        	 logger.error(ex.getMessage(), ex);
		         } finally {
		        	 objPost.releaseConnection();
		         }
                         // couldn't connect!
		         return null;
		     }
		};

		Future<String> future = executorService.submit(task);
		try {
		    // wait and timeout or return result
		    return future.get(timeout_in_seconds, TimeUnit.SECONDS);	
		} catch (InterruptedException ex) {
                      // Re-assert the thread's interrupted status
                     Thread.currentThread().interrupt();
                     // We don't need the result, so cancel the task too
                     future.cancel(true);
                     logger.error("Thread interrupted, connection to
url: " + url + " is cancelled: " + ex.getMessage(), ex);
                } catch (Exception ex) {
                     // We don't need the result, so cancel the task
                     future.cancel(true);
        	     logger.error(ex.getMessage(), ex);
                }
               // couldn't connect!
               return null;
	   }
       }

/** In long running applications, always use uncaught exception handlers
 *  for all threads that at least log the exception. */
public class ONExceptionThreadFactory implements ThreadFactory  {
	
	private static final ThreadFactory defaultFactory =
Executors.defaultThreadFactory();
	
    private final Thread.UncaughtExceptionHandler handler;

    public ONExceptionThreadFactory(Thread.UncaughtExceptionHandler handler) {
        this.handler = handler;
    }

    public Thread newThread(Runnable r) {
        Thread t = defaultFactory.newThread(r);
        t.setUncaughtExceptionHandler(handler);
        return t;
    }

}

public class ONExceptionHandler implements Thread.UncaughtExceptionHandler {
	
   /** commons logging declaration. */
    private static Log logger = LogFactory.getLog(
                ONExceptionHandler.class);

    public void uncaughtException(Thread t, Throwable ex) {
                logger.error("Unhandled exception caught by threadname: "
                                + t.getName() + "\n" + ex.getMessage(), ex);
    }

}

From joe.bowbeer at gmail.com  Mon Jan 19 14:36:12 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 19 Jan 2009 11:36:12 -0800
Subject: [concurrency-interest] Thread pools threads exhausted?
In-Reply-To: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
References: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
Message-ID: <31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>

Note that executorService.submit can throw RejectedExecutionException but
this is not handled in readUrl.

Recommend:

Configure the rejected execution handler on your executor service to log
rejections.

And/or handle rejected executions in readUrl.

Also, are you only submitting to one host?  I notice maxConnectionsPerHost
is the same as the fixed size of the thread pool.

Joe

On Mon, Jan 19, 2009 at 11:17 AM, robert lazarski wrote:

> Hi all,
>
> I have an app that reads a lot of url's via apache's httpclient, which
> is documented to be thread safe. About once a week or so, we can no
> longer query the url's without restarting the app server. We've done a
> lot of debugging, but have not isolated the cause yet. One of the
> things we are unsure of is the state of our ExecutorService. How can
> we tell if all the threads we assigned to the pool are still alive?
> Maybe we get timeouts because no threads are available? Our code is
> below, which is a springframework bean and therefore deployed in
> singleton mode by default. When it fails, the Future times out
> repeatably until we restart the app server.  We don't see any uncaught
> exception logs.
>
> public class URLReader {
>
>        private static final ThreadFactory factory = new
> ONExceptionThreadFactory(new ONExceptionHandler());
>        private static final ExecutorService executorService =
> Executors.newFixedThreadPool(10, factory);
>        // See the HttpClient options if need be in HttpConnectionManager
> the
> associated Parameters class.
>        private HttpClient objHttp;
>
>        /** commons logging declaration. */
>    private static Log logger = LogFactory.getLog(
>                URLReader.class);
>
>    private int timeout_in_seconds;
>    private int max_tries;
>    private String appInstance;
>
>        /**
>     * Connect to given URL and return response, or timeout. See
> http://commons.apache.org/httpclient/threading.html
>     * for programming guidelines and default settings.
>     *
>     * The behavior of this method is to encode the url.
>     */
>    public String readURL(final String url) throws Exception {
>
>        // lazy init
>        if (objHttp == null) {
>                MultiThreadedHttpConnectionManager mgr = new
> MultiThreadedHttpConnectionManager();
>                HttpConnectionManagerParams params = new
> HttpConnectionManagerParams();
>                params.setDefaultMaxConnectionsPerHost(10);
>                mgr.setParams(params);
>                objHttp = new HttpClient(mgr);
>        }
>                Callable<String> task = new Callable<String>() {
>                     public String call() {
>                         logger.debug("appInstance: "+appInstance+ " , says
> ...
> readURL call() invoked with url: " + url);
>                     // Send the POST request.
>                     PostMethod objPost = new PostMethod(url);
>                         try {
>                             objHttp.executeMethod(objPost);
>                             // Read the response.
>                             byte[] byteResponse =
> objPost.getResponseBody();
>                             return new String(byteResponse);
>                         } catch (Exception ex) {
>                                 logger.error(ex.getMessage(), ex);
>                         } finally {
>                                 objPost.releaseConnection();
>                         }
>                         // couldn't connect!
>                         return null;
>                     }
>                };
>
>                Future<String> future = executorService.submit(task);
>                try {
>                    // wait and timeout or return result
>                    return future.get(timeout_in_seconds, TimeUnit.SECONDS);
>                } catch (InterruptedException ex) {
>                      // Re-assert the thread's interrupted status
>                     Thread.currentThread().interrupt();
>                     // We don't need the result, so cancel the task too
>                     future.cancel(true);
>                     logger.error("Thread interrupted, connection to
> url: " + url + " is cancelled: " + ex.getMessage(), ex);
>                } catch (Exception ex) {
>                     // We don't need the result, so cancel the task
>                     future.cancel(true);
>                     logger.error(ex.getMessage(), ex);
>                }
>               // couldn't connect!
>               return null;
>           }
>       }
>
> /** In long running applications, always use uncaught exception handlers
>  *  for all threads that at least log the exception. */
> public class ONExceptionThreadFactory implements ThreadFactory  {
>
>        private static final ThreadFactory defaultFactory =
> Executors.defaultThreadFactory();
>
>    private final Thread.UncaughtExceptionHandler handler;
>
>    public ONExceptionThreadFactory(Thread.UncaughtExceptionHandler handler)
> {
>        this.handler = handler;
>    }
>
>    public Thread newThread(Runnable r) {
>        Thread t = defaultFactory.newThread(r);
>        t.setUncaughtExceptionHandler(handler);
>        return t;
>    }
>
> }
>
> public class ONExceptionHandler implements Thread.UncaughtExceptionHandler
> {
>
>   /** commons logging declaration. */
>    private static Log logger = LogFactory.getLog(
>                ONExceptionHandler.class);
>
>    public void uncaughtException(Thread t, Throwable ex) {
>                logger.error("Unhandled exception caught by threadname: "
>                                + t.getName() + "\n" + ex.getMessage(), ex);
>    }
>
> }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090119/13d9fc43/attachment.html>

From robertlazarski at gmail.com  Mon Jan 19 15:59:15 2009
From: robertlazarski at gmail.com (robert lazarski)
Date: Mon, 19 Jan 2009 17:59:15 -0300
Subject: [concurrency-interest] Thread pools threads exhausted?
In-Reply-To: <31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>
References: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
	<31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>
Message-ID: <f87675ee0901191259x38009b01p442339a511c40cad@mail.gmail.com>

On Mon, Jan 19, 2009 at 4:36 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> Note that executorService.submit can throw RejectedExecutionException but
> this is not handled in readUrl.
>
> Recommend:
>
> Configure the rejected execution handler on your executor service to log
> rejections.
>
> And/or handle rejected executions in readUrl.
>
> Also, are you only submitting to one host?  I notice maxConnectionsPerHost
> is the same as the fixed size of the thread pool.
>
> Joe

Thanks for the help Joe, Yes, I am always submitting to one host.
Since I was catching Exception and  RejectedExecutionHandler inherits
it, wouldn't I have caught it even though it also inherits
RuntimeException? Anyways, I explicitly catch it now.

I've got some new code shown below. The immediate question I have is
can I do this in the RejectedExecutionHandler?

executor.getQueue().put(runnable);

Here's the new code, thanks for the help.

public class URLReader {
	
	private static final ThreadFactory factory = new
ONExceptionThreadFactory(new ONExceptionHandler());
	// Create a ThreadPoolExecutor using a bounded buffer
	ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 10, 30000,
TimeUnit.MILLISECONDS,
			new ArrayBlockingQueue<Runnable>(10), factory);

	// See the HttpClient options if need be in HttpConnectionManager the
associated Parameters class.
	private HttpClient objHttp;

	/** commons logging declaration. */
    private static Log logger = LogFactory.getLog(
    		URLReader.class);

    private int timeout_in_seconds;
    private int max_tries;
	private String appInstance;
	
	/**
     * Connect to given URL and return response, or timeout. See
http://commons.apache.org/httpclient/threading.html
     * for programming guidelines and default settings.
     *
     * The behavior of this method is to encode the url.
     */
    public String readURL(final String url) throws Exception {

    	// lazy init
    	if (objHttp == null) {
    		pool.setRejectedExecutionHandler(new
ONExceptionRejectedExecutionHandler());
    		MultiThreadedHttpConnectionManager mgr = new
MultiThreadedHttpConnectionManager();
    		HttpConnectionManagerParams params = new HttpConnectionManagerParams();
    		params.setDefaultMaxConnectionsPerHost(10);
    		mgr.setParams(params);
    		objHttp = new HttpClient(mgr);
    	}
		Callable<String> task = new Callable<String>() {
		     public String call() {
	        	 logger.debug("appInstance: "+appInstance+ " , says ...
readURL call() invoked with url: " + url);
	             // Send the POST request.
	             PostMethod objPost = new PostMethod(url);
		         try {
		             objHttp.executeMethod(objPost);
	                 // Read the response.
		             byte[] byteResponse = objPost.getResponseBody();
		             return new String(byteResponse);
		         } catch (Exception ex) {
		        	 logger.error(ex.getMessage(), ex);
		         } finally {
		        	 objPost.releaseConnection();
		         }
                 // couldn't connect!
		         return null;
		     }
		};

		Future<String> future = pool.submit(task);
		try {
			// wait and timeout or return result
			return future.get(timeout_in_seconds, TimeUnit.SECONDS);
		} catch (RejectedExecutionException ex) {
            // We don't need the result, so cancel the task
            future.cancel(true);
        	logger.error("readURL() thread rejected with message: " +
ex.getMessage(), ex);
		} catch (InterruptedException ex) {
            // Re-assert the thread's interrupted status
            Thread.currentThread().interrupt();
            // We don't need the result, so cancel the task too
            future.cancel(true);
            logger.error("Thread interrupted, connection to url: " +
url + " is cancelled: " + ex.getMessage(), ex);
        } catch (Exception ex) {
            // We don't need the result, so cancel the task
            future.cancel(true);
        	logger.error(ex.getMessage(), ex);
        }
        // couldn't connect!
        return null;
	}
    }

public class ONExceptionRejectedExecutionHandler implements
		RejectedExecutionHandler {
	
	   /** commons logging declaration. */
    private static Log logger = LogFactory.getLog(
    		ONExceptionRejectedExecutionHandler.class);

	@Override
	public void rejectedExecution(Runnable runnable, ThreadPoolExecutor executor) {
		try {
			logger.error("rejectedExecution() invoked with
executor.isShutdown() value: " + executor.isShutdown() +
		            " , number of active threads: " + executor.getActiveCount() +
		            " , approximate TaskCount: " + executor.getTaskCount() +
		            " , approximate CompletedTaskCount: " +
executor.getCompletedTaskCount() +
		            " , PoolSize: " + executor.getPoolSize());
			logger.error("rejectedExecution() adding Runnable back onto the Queue");
			executor.getQueue().put(runnable);
		} catch (Exception ex) {
			 throw new RejectedExecutionException(ex);
		}
	}

}

From joe.bowbeer at gmail.com  Mon Jan 19 16:13:11 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 19 Jan 2009 13:13:11 -0800
Subject: [concurrency-interest] Thread pools threads exhausted?
In-Reply-To: <f87675ee0901191259x38009b01p442339a511c40cad@mail.gmail.com>
References: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
	<31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>
	<f87675ee0901191259x38009b01p442339a511c40cad@mail.gmail.com>
Message-ID: <31f2a7bd0901191313r6d2e591ekfa573d14173e6de@mail.gmail.com>

Note that submit throws the exception, which will throw an exception to the
caller of readUrl.  You won't receive the future if the submission is
rejected.

I would strictly avoid manipulating the executor's queue while the executor
is running.

I would catch RejectedExecution in readUrl for starters in order to verify
and diagnose the problem.  Then I would consider selecting a different
rejected execution handler, if that solves the problem.

On Mon, Jan 19, 2009 at 12:59 PM, robert lazarski wrote:

> On Mon, Jan 19, 2009 at 4:36 PM, Joe Bowbeer wrote:
> > Note that executorService.submit can throw RejectedExecutionException but
> > this is not handled in readUrl.
> >
> > Recommend:
> >
> > Configure the rejected execution handler on your executor service to log
> > rejections.
> >
> > And/or handle rejected executions in readUrl.
> >
> > Also, are you only submitting to one host?  I notice
> maxConnectionsPerHost
> > is the same as the fixed size of the thread pool.
> >
> > Joe
>
> Thanks for the help Joe, Yes, I am always submitting to one host.
> Since I was catching Exception and  RejectedExecutionHandler inherits
> it, wouldn't I have caught it even though it also inherits
> RuntimeException? Anyways, I explicitly catch it now.
>
> I've got some new code shown below. The immediate question I have is
> can I do this in the RejectedExecutionHandler?
>
> executor.getQueue().put(runnable);
>
> Here's the new code, thanks for the help.
>
> public class URLReader {
>
>        private static final ThreadFactory factory = new
> ONExceptionThreadFactory(new ONExceptionHandler());
>         // Create a ThreadPoolExecutor using a bounded buffer
>        ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 10, 30000,
> TimeUnit.MILLISECONDS,
>                        new ArrayBlockingQueue<Runnable>(10), factory);
>
>        // See the HttpClient options if need be in HttpConnectionManager
> the
> associated Parameters class.
>        private HttpClient objHttp;
>
>        /** commons logging declaration. */
>    private static Log logger = LogFactory.getLog(
>                URLReader.class);
>
>    private int timeout_in_seconds;
>    private int max_tries;
>        private String appInstance;
>
>        /**
>     * Connect to given URL and return response, or timeout. See
> http://commons.apache.org/httpclient/threading.html
>     * for programming guidelines and default settings.
>     *
>     * The behavior of this method is to encode the url.
>     */
>    public String readURL(final String url) throws Exception {
>
>        // lazy init
>        if (objHttp == null) {
>                 pool.setRejectedExecutionHandler(new
> ONExceptionRejectedExecutionHandler());
>                 MultiThreadedHttpConnectionManager mgr = new
> MultiThreadedHttpConnectionManager();
>                HttpConnectionManagerParams params = new
> HttpConnectionManagerParams();
>                params.setDefaultMaxConnectionsPerHost(10);
>                mgr.setParams(params);
>                objHttp = new HttpClient(mgr);
>        }
>                Callable<String> task = new Callable<String>() {
>                     public String call() {
>                         logger.debug("appInstance: "+appInstance+ " , says
> ...
> readURL call() invoked with url: " + url);
>                     // Send the POST request.
>                     PostMethod objPost = new PostMethod(url);
>                         try {
>                             objHttp.executeMethod(objPost);
>                         // Read the response.
>                             byte[] byteResponse =
> objPost.getResponseBody();
>                             return new String(byteResponse);
>                         } catch (Exception ex) {
>                                 logger.error(ex.getMessage(), ex);
>                         } finally {
>                                 objPost.releaseConnection();
>                         }
>                 // couldn't connect!
>                         return null;
>                     }
>                };
>
>                 Future<String> future = pool.submit(task);
>                 try {
>                        // wait and timeout or return result
>                        return future.get(timeout_in_seconds,
> TimeUnit.SECONDS);
>                 } catch (RejectedExecutionException ex) {
>             // We don't need the result, so cancel the task
>            future.cancel(true);
>                 logger.error("readURL() thread rejected with message: " +
> ex.getMessage(), ex);
>                 } catch (InterruptedException ex) {
>            // Re-assert the thread's interrupted status
>            Thread.currentThread().interrupt();
>            // We don't need the result, so cancel the task too
>            future.cancel(true);
>            logger.error("Thread interrupted, connection to url: " +
> url + " is cancelled: " + ex.getMessage(), ex);
>        } catch (Exception ex) {
>            // We don't need the result, so cancel the task
>            future.cancel(true);
>                logger.error(ex.getMessage(), ex);
>        }
>        // couldn't connect!
>        return null;
>        }
>    }
>
> public class ONExceptionRejectedExecutionHandler implements
>                RejectedExecutionHandler {
>
>           /** commons logging declaration. */
>    private static Log logger = LogFactory.getLog(
>                 ONExceptionRejectedExecutionHandler.class);
>
>        @Override
>        public void rejectedExecution(Runnable runnable, ThreadPoolExecutor
> executor) {
>                try {
>                        logger.error("rejectedExecution() invoked with
> executor.isShutdown() value: " + executor.isShutdown() +
>                            " , number of active threads: " +
> executor.getActiveCount() +
>                            " , approximate TaskCount: " +
> executor.getTaskCount() +
>                            " , approximate CompletedTaskCount: " +
> executor.getCompletedTaskCount() +
>                            " , PoolSize: " + executor.getPoolSize());
>                        logger.error("rejectedExecution() adding Runnable
> back onto the Queue");
>                        executor.getQueue().put(runnable);
>                } catch (Exception ex) {
>                         throw new RejectedExecutionException(ex);
>                }
>        }
>
> }
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090119/8fc559d0/attachment.html>

From robertlazarski at gmail.com  Mon Jan 19 16:27:47 2009
From: robertlazarski at gmail.com (robert lazarski)
Date: Mon, 19 Jan 2009 18:27:47 -0300
Subject: [concurrency-interest] Thread pools threads exhausted?
In-Reply-To: <31f2a7bd0901191313r6d2e591ekfa573d14173e6de@mail.gmail.com>
References: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
	<31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>
	<f87675ee0901191259x38009b01p442339a511c40cad@mail.gmail.com>
	<31f2a7bd0901191313r6d2e591ekfa573d14173e6de@mail.gmail.com>
Message-ID: <f87675ee0901191327x7cebd1b7k158eb65f182ec3b4@mail.gmail.com>

On Mon, Jan 19, 2009 at 6:13 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> Note that submit throws the exception, which will throw an exception to the
> caller of readUrl.  You won't receive the future if the submission is
> rejected.
>

Wow, now I understand. My submit() was outside the try / catch block
and could have silently failed. Thanks for pointing that out.

> I would strictly avoid manipulating the executor's queue while the executor
> is running.
>

OK, I removed that code.

> I would catch RejectedExecution in readUrl for starters in order to verify
> and diagnose the problem.  Then I would consider selecting a different
> rejected execution handler, if that solves the problem.
>

Sounds good, all I can do now is wait until the problem happens again.

- R

From hans.boehm at hp.com  Tue Jan 20 14:20:39 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 20 Jan 2009 19:20:39 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <497460BA.3030605@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
Message-ID: <238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>

I'd be inclined to somewhat simplify the example, and not use the constructor.  I'm also not sure I'd mention the word "native", since that seems to mislead people to believe that this is a native code issue.  Something like:

* class Resource {
*   static Resource[] externalResourceArray = ...
*   int myIndex;
*   Resource(...) {
*     myIndex = ...
*     externalResourceArray[myIndex] = ...;
*     ...
*   }
*   protected void finalize() {
*     externalResourceArray[myIndex] = null;
*     ...
*   }
*   void foo() {  // This might be the last use of this object.
*      int i = myIndex;
*      //  Without keepAlive, this object could be finalized
*      //  here, and externalResoureArray[i] could be
*      //  cleared, since the object itself may not otherwise
*      //  be needed; if there are no later accesses, only
*      //  the index i is still live.
*      bar(externalResourceArray[i]);
*      keepAlive(this);
*   }
* }

Hans

> -----Original Message-----
> From: javamemorymodel-discussion-bounces at cs.umd.edu 
> [mailto:javamemorymodel-discussion-bounces at cs.umd.edu] On 
> Behalf Of Doug Lea
> Sent: Monday, January 19, 2009 3:15 AM
> To: Jeremy Manson
> Cc: Concurrency-interest at cs.oswego.edu; 
> javamemorymodel-discussion at cs.umd.edu
> Subject: Re: [Javamemorymodel-discussion] 
> [concurrency-interest] Fences.keepAlive
> 
> Jeremy Manson wrote:
> > Oh, right, we always meant to do that.  Good idea!
> > 
> > I have two concerns with the javadoc:
> > 
> > First, I think it might be unclear to the reader that the problem 
> > arises in that example, because nothing is seen to call the 
> > constructor.
> 
> Can you (or anyone) think of a better short example?
> 
> > Second, I think it might be helpful to have a stronger statement of 
> > the problem in the Javadoc.  When I explain that this can happen to 
> > people, they are usually mystified and then shocked.  
> Something like 
> > "When a runtime can detect that no reference to an object 
> will ever be 
> > stored in the heap, the garbage collector can reclaim that 
> object at 
> > any time.  This can happen even if the object itself, of fields of 
> > that object, are still in use.  See Section 12.6.1 of the Java 
> > Language Specification for more details."  might be more complete.
> > 
> 
> Thanks! I added a light edit of this.
> 
> -DOug
> 
> 
> _______________________________________________
> Javamemorymodel-discussion mailing list
> Javamemorymodel-discussion at mcfeely.cs.umd.edu
> https://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion
> 

From hans.boehm at hp.com  Tue Jan 20 16:29:29 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 20 Jan 2009 21:29:29 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
 Fences.keepAlive
In-Reply-To: <e52efbe10901201247u4701c7b4of5f892b583ff5c1c@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<e52efbe10901201247u4701c7b4of5f892b583ff5c1c@mail.gmail.com>
Message-ID: <238A96A773B3934685A7269CC8A8D0424268117C3C@GVW0436EXB.americas.hpqcorp.net>

> From: Alexander Terekhov [mailto:alexander.terekhov at gmail.com] 
> 
> On Tue, Jan 20, 2009 at 8:20 PM, Boehm, Hans 
> <hans.boehm at hp.com> wrote:
> > I'd be inclined to somewhat simplify the example, and not use the 
> > constructor.  I'm also not sure I'd mention the word 
> "native", since 
> > that seems to mislead people to believe that this is a native code 
> > issue.  Something like:
> >
> > * class Resource {
> > *   static Resource[] externalResourceArray = ...
> > *   int myIndex;
> > *   Resource(...) {
> > *     myIndex = ...
> > *     externalResourceArray[myIndex] = ...;
> > *     ...
> > *   }
> > *   protected void finalize() {
> > *     externalResourceArray[myIndex] = null;
> > *     ...
> > *   }
> > *   void foo() {  // This might be the last use of this object.
> > *      int i = myIndex;
> > *      //  Without keepAlive, this object could be finalized
> > *      //  here, and externalResoureArray[i] could be
> > *      //  cleared, since the object itself may not otherwise
> > *      //  be needed; if there are no later accesses, only
> > *      //  the index i is still live.
> > *      bar(externalResourceArray[i]);
> > *      keepAlive(this);
> > *   }
> > * }
> 
> Q: What does it mean to have no GC?
> A: You must write "delete" (C++ locals aside for a moment) at 
> destruction point(s).
> 
> Q: What does it mean to have a GC?
> A: You must write "keepAlive" in every member function 
> possibly affected by the GC's premature destruction of *this.
> 
The latter of course only applies to finalizable objects, of which there should be very few.

The real difference between say, the C++ and Java approaches here is actually not so much the presence of GC.  C++ shared_ptr fundamentally has the same issues, in some ways more so.  It seems to me that interestingly the difference is that C++ effectively went for simpler semantics and less performance here, while Java went for more performance at the expense of programmability.  C++ delays destruction of locals until the end of the block, thus prohibiting dead variable elimination where it might be visible.  Hence a shared_ptr and the like can't be destroyed early.  Java allows pointers to disappear early in ways that are visible to finalizers.  This makes at least some small amount of sense, since C++ destructors are intended to be much more common that Java finalizers, and the performance impact would still be more or less universal in Java.  Whether it is really the right decision for Java, I don't know.  But I think the decision was effectively (probably unintentionally?) made around the Java 1.1 time frame, and changing it is likely to be nontrivial.

Hans

From peger at automotive.com  Tue Jan 20 18:08:06 2009
From: peger at automotive.com (Eger, Patrick)
Date: Tue, 20 Jan 2009 15:08:06 -0800
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <238A96A773B3934685A7269CC8A8D0424268117C3C@GVW0436EXB.americas.hpqcorp.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC><C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu><496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu><1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com><497460BA.3030605@cs.oswego.edu><238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net><e52efbe10901201247u4701c7b4of5f892b583ff5c1c@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0424268117C3C@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <1CFD7891521AAB4E8201FB7A78C9D36F01F1D8@mail-001.corp.automotive.com>

Curious, why not either:

A)
Change the Java semantics to be more C++ like then? JVMs could simply
keep an extra object pointer on the method stack frame for "this" to
prevent GC so the implementation could likely be quite simple. Correct
finalization of the below datastructure would require synchronization of
some sort anyways, so the compiler/memory ordering barriers will already
likely be there preventing optimizations that could otherwise be made.
finalize()-free classes of course would not have any penalty at all
since the JIT could detect this. Importantly, I think the amount of code
that absolutely relies on GC to cleanup memory immediately (for
correctness) is little to non-existent. I may be off-base here but it
seems likely that more code would actually be fixed by this change than
broken. Dunno if this is acceptable or not.


Or alternatively, 

B)
Have the JIT implicitly insert a keepAlive(this) directly before the
method return, for all classes having a non-empty finalizer, in all
methods that access the "this" reference. This would have the advantage
of "fixing" these broken programs without possible breakage. The only
issue I can see here would be the possible performance impact.
Mitigating this i see a couple things: a) keepAlive(this) could be a
compiler intrinsic and so multiple keepAlive() "calls" could be
collapsed when inlining, etc. b) Coders have been warned against
finalize() strongly for so long that this would only effect those few
classes for which they are already expecting a performance hit.


Thoughts? Am I being naive here?


> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-
> interest-bounces at cs.oswego.edu] On Behalf Of Boehm, Hans
> Sent: Tuesday, January 20, 2009 1:29 PM
> To: Alexander Terekhov
> Cc: Doug Lea; Concurrency-interest at cs.oswego.edu; javamemorymodel-
> discussion at cs.umd.edu
> Subject: Re: [concurrency-interest] [Javamemorymodel-discussion]
> Fences.keepAlive
> 
> > From: Alexander Terekhov [mailto:alexander.terekhov at gmail.com]
> >
> > On Tue, Jan 20, 2009 at 8:20 PM, Boehm, Hans
> > <hans.boehm at hp.com> wrote:
> > > I'd be inclined to somewhat simplify the example, and not use the
> > > constructor.  I'm also not sure I'd mention the word
> > "native", since
> > > that seems to mislead people to believe that this is a native code
> > > issue.  Something like:
> > >
> > > * class Resource {
> > > *   static Resource[] externalResourceArray = ...
> > > *   int myIndex;
> > > *   Resource(...) {
> > > *     myIndex = ...
> > > *     externalResourceArray[myIndex] = ...;
> > > *     ...
> > > *   }
> > > *   protected void finalize() {
> > > *     externalResourceArray[myIndex] = null;
> > > *     ...
> > > *   }
> > > *   void foo() {  // This might be the last use of this object.
> > > *      int i = myIndex;
> > > *      //  Without keepAlive, this object could be finalized
> > > *      //  here, and externalResoureArray[i] could be
> > > *      //  cleared, since the object itself may not otherwise
> > > *      //  be needed; if there are no later accesses, only
> > > *      //  the index i is still live.
> > > *      bar(externalResourceArray[i]);
> > > *      keepAlive(this);
> > > *   }
> > > * }
> >
> > Q: What does it mean to have no GC?
> > A: You must write "delete" (C++ locals aside for a moment) at
> > destruction point(s).
> >
> > Q: What does it mean to have a GC?
> > A: You must write "keepAlive" in every member function
> > possibly affected by the GC's premature destruction of *this.
> >
> The latter of course only applies to finalizable objects, of which
there
> should be very few.
> 
> The real difference between say, the C++ and Java approaches here is
> actually not so much the presence of GC.  C++ shared_ptr fundamentally
has
> the same issues, in some ways more so.  It seems to me that
interestingly
> the difference is that C++ effectively went for simpler semantics and
less
> performance here, while Java went for more performance at the expense
of
> programmability.  C++ delays destruction of locals until the end of
the
> block, thus prohibiting dead variable elimination where it might be
> visible.  Hence a shared_ptr and the like can't be destroyed early.
Java
> allows pointers to disappear early in ways that are visible to
finalizers.
> This makes at least some small amount of sense, since C++ destructors
are
> intended to be much more common that Java finalizers, and the
performance
> impact would still be more or less universal in Java.  Whether it is
> really the right decision for Java, I don't know.  But I think the
> decision was effectively (probably unintentionall!
>  y?) made around the Java 1.1 time frame, and changing it is likely to
be
> nontrivial.
> 
> Hans
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From hans.boehm at hp.com  Tue Jan 20 18:44:28 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Tue, 20 Jan 2009 23:44:28 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
 Fences.keepAlive
In-Reply-To: <1CFD7891521AAB4E8201FB7A78C9D36F01F1D8@mail-001.corp.automotive.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC><C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu><496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu><1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com><497460BA.3030605@cs.oswego.edu><238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net><e52efbe10901201247u4701c7b4of5f892b583ff5c1c@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0424268117C3C@GVW0436EXB.americas.hpqcorp.net>
	<1CFD7891521AAB4E8201FB7A78C9D36F01F1D8@mail-001.corp.automotive.com>
Message-ID: <238A96A773B3934685A7269CC8A8D0424268117D70@GVW0436EXB.americas.hpqcorp.net>

 

> -----Original Message-----
> From: Eger, Patrick [mailto:peger at automotive.com] 
> Sent: Tuesday, January 20, 2009 3:08 PM
> To: Boehm, Hans; Alexander Terekhov
> Cc: Doug Lea; Concurrency-interest at cs.oswego.edu; 
> javamemorymodel-discussion at cs.umd.edu
> Subject: RE: [concurrency-interest] 
> [Javamemorymodel-discussion] Fences.keepAlive
> 
> Curious, why not either:
> 
> A)
> Change the Java semantics to be more C++ like then? JVMs 
> could simply keep an extra object pointer on the method stack 
> frame for "this" to prevent GC so the implementation could 
> likely be quite simple. Correct finalization of the below 
> datastructure would require synchronization of some sort 
> anyways, so the compiler/memory ordering barriers will 
> already likely be there preventing optimizations that could 
> otherwise be made.
> finalize()-free classes of course would not have any penalty 
> at all since the JIT could detect this. Importantly, I think 
> the amount of code that absolutely relies on GC to cleanup 
> memory immediately (for
> correctness) is little to non-existent. I may be off-base 
> here but it seems likely that more code would actually be 
> fixed by this change than broken. Dunno if this is acceptable or not.
I think it's very tricky to do this without essentially prohibiting all dead variable elimination on references to Java objects.  In particular, limiting it to just "this" seems very weird to me.  It fixes the most obvious examples.  But if someone rewrites one of those member functions as a static function with an explicit object parameter, the code breaks again.  That would probably be even harder to explain than the original problem.

Solution 2 in http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2261.html tries to contain the effect to objects that appear finalizable.  There's a handwaving, untested argument that that might make sense, but even that's unclear.  The problem is that a reference to a non-finalizable P may actually refer to a subclasss that is finalizable. And thinking about it again, it almost certainly doesn't work in Java, since java.lang.ref effectively allows you to finalize any object, no matter what its type.

It seems likely to me that the only clean solution would be to effectively prohibit all dead variable elimination, effectively allowing it only when provably can have no effect on finalization or reference enqueuing, and would hence be invisible (except that space requirements may be reduced.)  In addition to increased register pressure in the compiler, this has some cost in extra garbage retention by the collector.

> 
> 
> Or alternatively, 
> 
> B)
> Have the JIT implicitly insert a keepAlive(this) directly 
> before the method return, for all classes having a non-empty 
> finalizer, in all methods that access the "this" reference. 
> This would have the advantage of "fixing" these broken 
> programs without possible breakage. The only issue I can see 
> here would be the possible performance impact.
> Mitigating this i see a couple things: a) keepAlive(this) 
> could be a compiler intrinsic and so multiple keepAlive() 
> "calls" could be collapsed when inlining, etc. b) Coders have 
> been warned against
> finalize() strongly for so long that this would only effect 
> those few classes for which they are already expecting a 
> performance hit.
I think this is essentially equivalent to (A), with the same issues.

Again, the performance hit is difficult to limit to classes that use finalization.  C++ does manage to limit it to dead variable elimination on objects with destructors.  But once you make heavy use of something like C++ shared_ptr, there are a lot of those objects.

Hans

> 
> 
> Thoughts? Am I being naive here?
> 
> 
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu 
> [mailto:concurrency- 
> > interest-bounces at cs.oswego.edu] On Behalf Of Boehm, Hans
> > Sent: Tuesday, January 20, 2009 1:29 PM
> > To: Alexander Terekhov
> > Cc: Doug Lea; Concurrency-interest at cs.oswego.edu; javamemorymodel- 
> > discussion at cs.umd.edu
> > Subject: Re: [concurrency-interest] [Javamemorymodel-discussion] 
> > Fences.keepAlive
> > 
> > > From: Alexander Terekhov [mailto:alexander.terekhov at gmail.com]
> > >
> > > On Tue, Jan 20, 2009 at 8:20 PM, Boehm, Hans <hans.boehm at hp.com> 
> > > wrote:
> > > > I'd be inclined to somewhat simplify the example, and 
> not use the 
> > > > constructor.  I'm also not sure I'd mention the word
> > > "native", since
> > > > that seems to mislead people to believe that this is a 
> native code 
> > > > issue.  Something like:
> > > >
> > > > * class Resource {
> > > > *   static Resource[] externalResourceArray = ...
> > > > *   int myIndex;
> > > > *   Resource(...) {
> > > > *     myIndex = ...
> > > > *     externalResourceArray[myIndex] = ...;
> > > > *     ...
> > > > *   }
> > > > *   protected void finalize() {
> > > > *     externalResourceArray[myIndex] = null;
> > > > *     ...
> > > > *   }
> > > > *   void foo() {  // This might be the last use of this object.
> > > > *      int i = myIndex;
> > > > *      //  Without keepAlive, this object could be finalized
> > > > *      //  here, and externalResoureArray[i] could be
> > > > *      //  cleared, since the object itself may not otherwise
> > > > *      //  be needed; if there are no later accesses, only
> > > > *      //  the index i is still live.
> > > > *      bar(externalResourceArray[i]);
> > > > *      keepAlive(this);
> > > > *   }
> > > > * }
> > >
> > > Q: What does it mean to have no GC?
> > > A: You must write "delete" (C++ locals aside for a moment) at 
> > > destruction point(s).
> > >
> > > Q: What does it mean to have a GC?
> > > A: You must write "keepAlive" in every member function possibly 
> > > affected by the GC's premature destruction of *this.
> > >
> > The latter of course only applies to finalizable objects, of which
> there
> > should be very few.
> > 
> > The real difference between say, the C++ and Java 
> approaches here is 
> > actually not so much the presence of GC.  C++ shared_ptr 
> fundamentally
> has
> > the same issues, in some ways more so.  It seems to me that
> interestingly
> > the difference is that C++ effectively went for simpler 
> semantics and
> less
> > performance here, while Java went for more performance at 
> the expense
> of
> > programmability.  C++ delays destruction of locals until the end of
> the
> > block, thus prohibiting dead variable elimination where it might be 
> > visible.  Hence a shared_ptr and the like can't be destroyed early.
> Java
> > allows pointers to disappear early in ways that are visible to
> finalizers.
> > This makes at least some small amount of sense, since C++ 
> destructors
> are
> > intended to be much more common that Java finalizers, and the
> performance
> > impact would still be more or less universal in Java.  
> Whether it is 
> > really the right decision for Java, I don't know.  But I think the 
> > decision was effectively (probably unintentionall!
> >  y?) made around the Java 1.1 time frame, and changing it 
> is likely to
> be
> > nontrivial.
> > 
> > Hans
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From peger at automotive.com  Tue Jan 20 19:12:30 2009
From: peger at automotive.com (Eger, Patrick)
Date: Tue, 20 Jan 2009 16:12:30 -0800
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <238A96A773B3934685A7269CC8A8D0424268117D70@GVW0436EXB.americas.hpqcorp.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC><C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu><496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu><1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com><497460BA.3030605@cs.oswego.edu><238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net><e52efbe10901201247u4701c7b4of5f892b583ff5c1c@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0424268117C3C@GVW0436EXB.americas.hpqcorp.net>
	<1CFD7891521AAB4E8201FB7A78C9D36F01F1D8@mail-001.corp.automotive.com>
	<238A96A773B3934685A7269CC8A8D0424268117D70@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <1CFD7891521AAB4E8201FB7A78C9D36F01F1D9@mail-001.corp.automotive.com>

Thanks for the reference, couple comments below:

<snip>

> I think it's very tricky to do this without essentially prohibiting
all
> dead variable elimination on references to Java objects.  In
particular,
> limiting it to just "this" seems very weird to me.  It fixes the most
> obvious examples.  But if someone rewrites one of those member
functions
> as a static function with an explicit object parameter, the code
breaks
> again.  That would probably be even harder to explain than the
original
> problem.

Wouldn't static functions be immune by virtue of not having access to
the member variables in the first place? IE all parameter objects are
already referenced (by the stack frame) for static methods? 


> Solution 2 in http://www.open-
> std.org/JTC1/SC22/WG21/docs/papers/2007/n2261.html tries to contain
the
> effect to objects that appear finalizable.  There's a handwaving,
untested
> argument that that might make sense, but even that's unclear.  The
problem
> is that a reference to a non-finalizable P may actually refer to a
> subclasss that is finalizable. And thinking about it again, it almost
> certainly doesn't work in Java, since java.lang.ref effectively allows
you
> to finalize any object, no matter what its type.
> 

I'm thinking that the JIT could mark/deoptimize the class on first
enqueue to a ReferenceQueue? This would switch the class to have the
same semantics as a non-empty finalize(), and could probably last as
long as the class definition is loaded into the VM. The finalizability
of a class would only be affected by the code generated by a concrete
subclass (though I do see that the parent class chain may need to be
compiled twice for optimal performance, once for finalizable subclasses
and once for non).

> It seems likely to me that the only clean solution would be to
effectively
> prohibit all dead variable elimination, effectively allowing it only
when
> provably can have no effect on finalization or reference enqueuing,
and
> would hence be invisible (except that space requirements may be
reduced.)
> In addition to increased register pressure in the compiler, this has
some
> cost in extra garbage retention by the collector.
> 

With some brainwaving, I tend to think the GC overhead would be pretty
minimal with a modern generational GC. Register pressure (brainwaving
again ;-) I think could be reduced by shoving these possibly dead
pointers off to special L1/memory, that would only need to be read when
walking the stack for GC purposes.


> >
> >
> > Or alternatively,
> >
> > B)
> > Have the JIT implicitly insert a keepAlive(this) directly
> > before the method return, for all classes having a non-empty
> > finalizer, in all methods that access the "this" reference.
> > This would have the advantage of "fixing" these broken
> > programs without possible breakage. The only issue I can see
> > here would be the possible performance impact.
> > Mitigating this i see a couple things: a) keepAlive(this)
> > could be a compiler intrinsic and so multiple keepAlive()
> > "calls" could be collapsed when inlining, etc. b) Coders have
> > been warned against
> > finalize() strongly for so long that this would only effect
> > those few classes for which they are already expecting a
> > performance hit.
> I think this is essentially equivalent to (A), with the same issues.
> 
> Again, the performance hit is difficult to limit to classes that use
> finalization.  C++ does manage to limit it to dead variable
elimination on
> objects with destructors.  But once you make heavy use of something
like
> C++ shared_ptr, there are a lot of those objects.
> 
> Hans
> 
> >

I think the big advantage Java has here over C++ is (as usual) dynamic
compilation, in this case driven by the "needs finalization-friendly
JIT" flag which AFAICS can be computed accurately. Of course I have not
done testing/hacking on any of this, though the OpenJDK does tempt ever
so...

- Patrick

<snip>


From dl at cs.oswego.edu  Wed Jan 21 08:41:25 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2009 08:41:25 -0500
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>		<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>		<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <49772605.5030402@cs.oswego.edu>

Boehm, Hans wrote:
> I'd be inclined to somewhat simplify the example, and not use the
> constructor.  I'm also not sure I'd mention the word "native", since that
> seems to mislead people to believe that this is a native code issue.

Thanks! Added with a few minor edits.

Plus a few other minor edits elsewhere.

http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

-Doug


From mallikap at deshaw.com  Wed Jan 21 08:53:13 2009
From: mallikap at deshaw.com (Mallikarjunaiah, Praveena)
Date: Wed, 21 Jan 2009 19:23:13 +0530
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]Fences.keepAlive
In-Reply-To: <49772605.5030402@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>		<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>		<496CADB0.3020605@cs.oswego.edu><496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com><497460BA.3030605@cs.oswego.edu><238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
Message-ID: <B911686319FBAC4BA4671AF36F8DC309056F5C07@mailhyd2.hyd.deshaw.com>

Hi,

There is a typo in the example of WidgetHolder.

Fences.preStoreFence(this);  // "this" should be replaced with h.widget.

-Praveen 

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Doug
Lea
Sent: Wednesday, January 21, 2009 7:11 PM
To: Boehm, Hans
Cc: Concurrency-interest at cs.oswego.edu;
javamemorymodel-discussion at cs.umd.edu
Subject: Re: [concurrency-interest]
[Javamemorymodel-discussion]Fences.keepAlive

Boehm, Hans wrote:
> I'd be inclined to somewhat simplify the example, and not use the
> constructor.  I'm also not sure I'd mention the word "native", since
that
> seems to mislead people to believe that this is a native code issue.

Thanks! Added with a few minor edits.

Plus a few other minor edits elsewhere.

http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic
/Fences.html

-Doug

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Wed Jan 21 09:01:42 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2009 09:01:42 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]Fences.keepAlive
In-Reply-To: <B911686319FBAC4BA4671AF36F8DC309056F5C07@mailhyd2.hyd.deshaw.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>		<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>		<496CADB0.3020605@cs.oswego.edu><496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com><497460BA.3030605@cs.oswego.edu><238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
	<B911686319FBAC4BA4671AF36F8DC309056F5C07@mailhyd2.hyd.deshaw.com>
Message-ID: <49772AC6.2010008@cs.oswego.edu>

Mallikarjunaiah, Praveena wrote:
> Hi,
> 
> There is a typo in the example of WidgetHolder.
> 
> Fences.preStoreFence(this);  // "this" should be replaced with h.widget.
> 

Thanks; fixed.
Actually, this should be "h", because of the no call-by-ref issue:
You can't say preStoreFence(&h.widget) so must use h.

-Doug


From dl at cs.oswego.edu  Wed Jan 21 10:33:48 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2009 10:33:48 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <496F4AC8.50802@cox.net>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>	<496E4B66.9070106@cytetech.com>	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net>
Message-ID: <4977405C.6060609@cs.oswego.edu>

Gregg Wonderly wrote:
> To 
> me, keepAlive means starting at this point, until I tell you otherwise.  
> Something like releaseHere(), or something similar would make more sense.
> 

That's the main usability bug with any kind of fence method.
Fences separate other accesses, which is especially non-intuitive
in the common case that you cannot see those accesses locally in
program source. And worse here in that the accesses in question
surround reachability analysis by GC. And I can't think of
naming conventions like the pre/post scheme used with other fence
methods that make sense here. But further suggestions are still welcome.

"releaseHere" seems out because it mis-implies a directive to
gc/finalize.

-Doug


From oxbow_lakes at hotmail.com  Wed Jan 21 11:16:29 2009
From: oxbow_lakes at hotmail.com (christopher marshall)
Date: Wed, 21 Jan 2009 16:16:29 +0000
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <4977405C.6060609@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
	<496E4B66.9070106@cytetech.com>
	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net>  <4977405C.6060609@cs.oswego.edu>
Message-ID: <COL109-W826EA3737D42BB5EFD0D808DD10@phx.gbl>




> Date: Wed, 21 Jan 2009 10:33:48 -0500
> From: dl at cs.oswego.edu
>
> That's the main usability bug with any kind of fence method.
> Fences separate other accesses, which is especially non-intuitive
> in the common case that you cannot see those accesses locally in
> program source. And worse here in that the accesses in question
> surround reachability analysis by GC. And I can't think of
> naming conventions like the pre/post scheme used with other fence
> methods that make sense here. But further suggestions are still welcome.
> 
> "releaseHere" seems out because it mis-implies a directive to
> gc/finalize.
> 

As we're on the subject of fences, how about "enGuarde"


_________________________________________________________________
Cut through the jargon: find a PC for your needs.
http://clk.atdmt.com/UKM/go/130777504/direct/01/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090121/1ec21f09/attachment.html>

From joe.bowbeer at gmail.com  Wed Jan 21 11:39:34 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 21 Jan 2009 08:39:34 -0800
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <49772605.5030402@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
Message-ID: <31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>

I *can* follow the class description and its Fences examples.

I don't follow keepAlive.  It's barely covered in the class description and
the method description doesn't make sense to me.

More on fences and keepAlive below.

Fences.  [More yowing...]

It's hard for me to mesh fences with the JMM.  In the context of JMM, fences
seem like magic.  (Whereas in the magical world of a DEC Alpha, fences
impose reality.)

Do fences create open-ended happens-before edges?  Or are the edges only
created when the next load or store occurs?  Or does it matter?

More to the point: Are there Java code transformations (e.g., injections)
that could be used to illustrate what they really do in terms of Java code?

Are fences actually cheap to implement on all platforms?  Won't there be
some platforms where they are more expensive than current alternatives?  (If
not, why wasn't the JMM spec'd in terms of fences?)

keepAlive.

I don't think this is covered well-enough in the class description, and I
can't follow the example in the method description.  I also wonder if
there's a better name.

Some problems I encountered:

I was expecting the "Reference" link to define the term "strongly
reachable", but neither "strong" nor "reachable" can be found on that page.

What does "alive" mean?

JLS 12.6.1 defines the reachable and finalized attributes, but it never
adequately defines "alive".

While there is mention of keeping a thread alive, and of live references,
these terms seem to be used intuitively, and sometimes confusingly, for
example:

    "... then there can never be any live references to it (this includes
references that are not live, but might be resurrected by finalizers) ..."

The undead is really alive?  What does alive mean?  Is it some combination
of reachable and finalized attributes?

I suggest giving keepAlive a more verbose name, like the other fence
method.  Preferably a name composed of terms that are defined in the JLS.
(I also recommend considering tightening up the use of the terms "live" and
"alive" in the JLS.)

keepNotFinalized?

Though even with a new name, I suspect I'll still be trying to figure out
what this does...

Joe

On Wed, Jan 21, 2009 at 5:41 AM, Doug Lea wrote:

> Boehm, Hans wrote:
> > I'd be inclined to somewhat simplify the example, and not use the
> > constructor.  I'm also not sure I'd mention the word "native", since that
> > seems to mislead people to believe that this is a native code issue.
>
> Thanks! Added with a few minor edits.
>
> Plus a few other minor edits elsewhere.
>
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
>
> -Doug
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090121/d67f1a41/attachment.html>

From Darron_Shaffer at stercomm.com  Wed Jan 21 11:48:44 2009
From: Darron_Shaffer at stercomm.com (Shaffer, Darron)
Date: Wed, 21 Jan 2009 11:48:44 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <4977405C.6060609@cs.oswego.edu>
Message-ID: <FC30D8A2D3DEE64D93E8DA54A1DB349A05B4B486@IWDUBCORMSG007.sci.local>

keepAliveUntilThisPoint()?

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Doug
Lea
Sent: Wednesday, January 21, 2009 9:34 AM
To: Gregg Wonderly
Cc: Concurrency-interest at cs.oswego.edu;
javamemorymodel-discussion at cs.umd.edu
Subject: Re: [concurrency-interest][Javamemorymodel-discussion]
Fences.keepAlive

Gregg Wonderly wrote:
> To 
> me, keepAlive means starting at this point, until I tell you
otherwise.  
> Something like releaseHere(), or something similar would make more
sense.
> 

That's the main usability bug with any kind of fence method.
Fences separate other accesses, which is especially non-intuitive
in the common case that you cannot see those accesses locally in
program source. And worse here in that the accesses in question
surround reachability analysis by GC. And I can't think of
naming conventions like the pre/post scheme used with other fence
methods that make sense here. But further suggestions are still welcome.

"releaseHere" seems out because it mis-implies a directive to
gc/finalize.

-Doug

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Wed Jan 21 12:50:04 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2009 12:50:04 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <FC30D8A2D3DEE64D93E8DA54A1DB349A05B4B486@IWDUBCORMSG007.sci.local>
References: <FC30D8A2D3DEE64D93E8DA54A1DB349A05B4B486@IWDUBCORMSG007.sci.local>
Message-ID: <4977604C.9020405@cs.oswego.edu>

Shaffer, Darron wrote:
> keepAliveUntilThisPoint()?
> 

or, to eliminate any sense that it is imperative,
  ref.keepAliveAtLeastUntilThisPoint()
I would like best the more declarative/assertional
   ref.isAlive();
except that it clashes with default-naming scheme that
would imply this is an accessor method (like Thread.isAlive).
Perhaps
   ref.mustBeAlive();
Which might win terms of not mis-implying anything.

Keep 'em coming. Choosing good names is a game where the
ideas of potential users are usually better than those
of the implementors/designers.

-Doug


From gregg at cytetech.com  Wed Jan 21 13:05:53 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 21 Jan 2009 12:05:53 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <4977405C.6060609@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
	<496E4B66.9070106@cytetech.com>
	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net> <4977405C.6060609@cs.oswego.edu>
Message-ID: <49776401.2070005@cytetech.com>

Doug Lea wrote:
> Gregg Wonderly wrote:
>> To me, keepAlive means starting at this point, until I tell you 
>> otherwise.  Something like releaseHere(), or something similar would 
>> make more sense.
>>
> 
> That's the main usability bug with any kind of fence method.
> Fences separate other accesses, which is especially non-intuitive
> in the common case that you cannot see those accesses locally in
> program source. And worse here in that the accesses in question
> surround reachability analysis by GC. And I can't think of
> naming conventions like the pre/post scheme used with other fence
> methods that make sense here. But further suggestions are still welcome.
> 
> "releaseHere" seems out because it mis-implies a directive to
> gc/finalize.

Maybe I'm still not getting what the underlying issue is.  I thought we were 
talking about the fact that because there were no other visible references that 
the Compiler/GC might decide on actions that would cause the object to be made 
eligible for GC.  So, to me releaseHere(), or doneUsingReference() or 
holdThisUntilHere() or some such is the control that we are trying to put in 
place.  Am I still missing something?

Gregg Wonderly

From paul.martin at grammarsmith.com  Wed Jan 21 13:13:17 2009
From: paul.martin at grammarsmith.com (Paul Martin)
Date: Wed, 21 Jan 2009 13:13:17 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <4977405C.6060609@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>	<496E4B66.9070106@cytetech.com>	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net> <4977405C.6060609@cs.oswego.edu>
Message-ID: <169BF173-0515-4DBC-9A61-D6EBC2D0C798@grammarsmith.com>

Maybe the right name for that fence action is "DoNotResuscitate" ?


From kschneider at gmail.com  Wed Jan 21 13:29:19 2009
From: kschneider at gmail.com (Kris Schneider)
Date: Wed, 21 Jan 2009 13:29:19 -0500
Subject: [concurrency-interest] Fwd: [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <3d242a3d0901211027t81df977sac53c4bfebaca237@mail.gmail.com>
References: <FC30D8A2D3DEE64D93E8DA54A1DB349A05B4B486@IWDUBCORMSG007.sci.local>
	<4977604C.9020405@cs.oswego.edu>
	<3d242a3d0901211027t81df977sac53c4bfebaca237@mail.gmail.com>
Message-ID: <3d242a3d0901211029ufb63331hcc82d01f9013b6e5@mail.gmail.com>

Sorry, replied to Doug only...

---------- Forwarded message ----------
From: Kris Schneider <kschneider at gmail.com>
Date: Jan 21, 2009 1:27 PM
Subject: Re: [Javamemorymodel-discussion] [concurrency-interest]
Fences.keepAlive
To: Doug Lea <dl at cs.oswego.edu>


On 1/21/09, Doug Lea <dl at cs.oswego.edu> wrote:
 > Shaffer, Darron wrote:
 >  > keepAliveUntilThisPoint()?
 >  >
 >
 >  or, to eliminate any sense that it is imperative,
 >   ref.keepAliveAtLeastUntilThisPoint()
 >  I would like best the more declarative/assertional
 >    ref.isAlive();
 >  except that it clashes with default-naming scheme that
 >  would imply this is an accessor method (like Thread.isAlive).
 >  Perhaps
 >    ref.mustBeAlive();
 >  Which might win terms of not mis-implying anything.
 >
 >  Keep 'em coming. Choosing good names is a game where the
 >  ideas of potential users are usually better than those
 >  of the implementors/designers.

How about some form of "ensure", like ref.ensureAlive()? There's
already some precedent with methods like ArrayList.ensureCapacity,
which makes no promises about what happens to the list's capacity at
any point in the future.

Otherwise, the discussion makes me think of verbs like "maintain", so
synonyms would be: "perpetuate", "prolong", "retain", "sustain",
"affirm", or some such...

 >  -Doug

 --
 Kris Schneider <mailto:kschneider at gmail.com>

From dl at cs.oswego.edu  Wed Jan 21 13:30:32 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2009 13:30:32 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>	<497460BA.3030605@cs.oswego.edu>	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>	<49772605.5030402@cs.oswego.edu>
	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
Message-ID: <497769C8.5050302@cs.oswego.edu>

Joe Bowbeer wrote:
> 
> It's hard for me to mesh fences with the JMM.  In the context of JMM, fences
> seem like magic.  (Whereas in the magical world of a DEC Alpha, fences impose
> reality.)
> 

Although from a different perspective, it is almost the
opposite.  Memory consistency is all about the relations
among memory accesses, not the accesses themselves. If
people somehow liked programming the interstices across
accesses (which is what fences do), it would probably be
easier to specify a fairly simple memory model of sorts that
described effects.  But no one likes to program in this way,
and even if they did, it would be much harder to verify
correct usage. So instead the JMM associates relations with
sets of accesses of variables tagged as volatile etc. Which
enters the messy territory of how mixtures of volatiles,
non-volatile, and final accesses interrelate. If you instead
program directly use Fence API, you don't have to pay
attention to this part much, but on penalty of having to
program in a very unnatural way -- a style that you would
only tolerate in a small part of your program for the sake of
enforcing an ordering relation that is not otherwise obtainable;
i.e., because the available means of expressing them are either
too weak to too strong.

In other words, the Fences API methods are just as removed from
hardware as volatile specs are. They feel closer
because HW folks have no sympathy about programmability, so
usually only provide instruction sets supporting
interstice-programming (fences), on top of a set
of base ordering guarantees, rather than tagged variable
access, so the mapping is easier.

(*) Footnote/disclaimer: However, there is one access-based,
not relation-based property of volatiles -- access is
guaranteed atomic even for longs and doubles, unlike the
case for non-volatiles.

> More to the point: Are there Java code transformations (e.g., injections)
> that could be used to illustrate what they really do in terms of Java code?

No, only the opposite.

> 
> Are fences actually cheap to implement on all platforms?  Won't there be some
> platforms where they are more expensive than current alternatives? (If not,
> why wasn't the JMM spec'd in terms of fences?)

(See above :-)

-Doug


From Hans.Boehm at hp.com  Wed Jan 21 13:41:19 2009
From: Hans.Boehm at hp.com (Hans Boehm)
Date: Wed, 21 Jan 2009 10:41:19 -0800 (PST)
Subject: [concurrency-interest] [Javamemorymodel-discussion]
 Fences.keepAlive
In-Reply-To: <49776401.2070005@cytetech.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
	<496E4B66.9070106@cytetech.com>
	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net> <4977405C.6060609@cs.oswego.edu>
	<49776401.2070005@cytetech.com>
Message-ID: <alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>



On Wed, 21 Jan 2009, Gregg Wonderly wrote:

> Maybe I'm still not getting what the underlying issue is.  I thought we were
> talking about the fact that because there were no other visible references that
> the Compiler/GC might decide on actions that would cause the object to be made
> eligible for GC.  So, to me releaseHere(), or doneUsingReference() or
> holdThisUntilHere() or some such is the control that we are trying to put in
> place.  Am I still missing something?
>
The problem is that the reference may or may not be used again later in
another method call.  If it is used again later, we expect keepAlive()
(or whatever) to be a no-op, since the object can't be finalized yet
anyway.  But releaseHere() implies that we are definitely done with the
reference, and it's OK to garbage collect the object.

In the case in which this actually is the last use, those names seem OK,
except that the object might still not be finalized until much later.

Although I don't like releaseHere(), the other two, or just 
holdUntilHere(), sound fine to me.  The one diasadvantage is that
the CLR already seems to use keepAlive().  But that may not be
a major concern.

As far as the description is concerned, I wonder whether we can and should
do a complete job in the javadoc.  We should clearly do as well as we can,
but this is a fairly fundamental problem with finalizers and weak 
references.  In the long run, I think this really needs to be addressed
in textbooks, and possibly in the description of finalize() in the JLS.
It seems to me the problem is not so much that people don't understand
the meaning of keepAlive(), as that they are starting from incorrect
assumptions about how finalization works, and hence don't understand the
need for it.

Hans

From gergg at cox.net  Wed Jan 21 14:19:22 2009
From: gergg at cox.net (Gregg Wonderly)
Date: Wed, 21 Jan 2009 13:19:22 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>	<496E4B66.9070106@cytetech.com>	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>	<496F4AC8.50802@cox.net>
	<4977405C.6060609@cs.oswego.edu>	<49776401.2070005@cytetech.com>
	<alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>
Message-ID: <4977753A.1070905@cox.net>

Hans Boehm wrote:
> 
> 
> On Wed, 21 Jan 2009, Gregg Wonderly wrote:
> 
>> Maybe I'm still not getting what the underlying issue is.  I thought 
>> we were
>> talking about the fact that because there were no other visible 
>> references that
>> the Compiler/GC might decide on actions that would cause the object to 
>> be made
>> eligible for GC.  So, to me releaseHere(), or doneUsingReference() or
>> holdThisUntilHere() or some such is the control that we are trying to 
>> put in
>> place.  Am I still missing something?
>>
> The problem is that the reference may or may not be used again later in
> another method call.  If it is used again later, we expect keepAlive()
> (or whatever) to be a no-op, since the object can't be finalized yet
> anyway.  But releaseHere() implies that we are definitely done with the
> reference, and it's OK to garbage collect the object.

Implicitly, I was meaning, "I'm finally done using the object here, so release 
it from being referenced".

Gregg Wonderly

From jason.greene at redhat.com  Wed Jan 21 14:48:10 2009
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 21 Jan 2009 13:48:10 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>	<496E24A6.2000705@cytetech.com>	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>	<496E4B66.9070106@cytetech.com>	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>	<496F4AC8.50802@cox.net>
	<4977405C.6060609@cs.oswego.edu>	<49776401.2070005@cytetech.com>
	<alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>
Message-ID: <49777BFA.2050503@redhat.com>

Hans Boehm wrote:
> 
> 
> On Wed, 21 Jan 2009, Gregg Wonderly wrote:
> 
>> Maybe I'm still not getting what the underlying issue is.  I thought 
>> we were
>> talking about the fact that because there were no other visible 
>> references that
>> the Compiler/GC might decide on actions that would cause the object to 
>> be made
>> eligible for GC.  So, to me releaseHere(), or doneUsingReference() or
>> holdThisUntilHere() or some such is the control that we are trying to 
>> put in
>> place.  Am I still missing something?
>>
> The problem is that the reference may or may not be used again later in
> another method call.  If it is used again later, we expect keepAlive()
> (or whatever) to be a no-op, since the object can't be finalized yet
> anyway.  But releaseHere() implies that we are definitely done with the
> reference, and it's OK to garbage collect the object.
> 
> In the case in which this actually is the last use, those names seem OK,
> except that the object might still not be finalized until much later.
> 
> Although I don't like releaseHere(), the other two, or just 
> holdUntilHere(), sound fine to me.  The one diasadvantage is that
> the CLR already seems to use keepAlive().  But that may not be
> a major concern.

IMO keepAlive() is a good name that is easy to understand.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From jason.greene at redhat.com  Wed Jan 21 15:12:26 2009
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 21 Jan 2009 14:12:26 -0600
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <497769C8.5050302@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>	<497460BA.3030605@cs.oswego.edu>	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>	<49772605.5030402@cs.oswego.edu>	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
	<497769C8.5050302@cs.oswego.edu>
Message-ID: <497781AA.2020009@redhat.com>

Doug Lea wrote:
> Joe Bowbeer wrote:
>>
>> It's hard for me to mesh fences with the JMM.  In the context of JMM, 
>> fences
>> seem like magic.  (Whereas in the magical world of a DEC Alpha, fences 
>> impose
>> reality.)
>>
> 
> Although from a different perspective, it is almost the
> opposite.  Memory consistency is all about the relations
> among memory accesses, not the accesses themselves. If
> people somehow liked programming the interstices across
> accesses (which is what fences do), it would probably be
> easier to specify a fairly simple memory model of sorts that
> described effects.  But no one likes to program in this way,
> and even if they did, it would be much harder to verify
> correct usage. So instead the JMM associates relations with
> sets of accesses of variables tagged as volatile etc. Which
> enters the messy territory of how mixtures of volatiles,
> non-volatile, and final accesses interrelate. If you instead
> program directly use Fence API, you don't have to pay
> attention to this part much, but on penalty of having to
> program in a very unnatural way -- a style that you would
> only tolerate in a small part of your program for the sake of
> enforcing an ordering relation that is not otherwise obtainable;
> i.e., because the available means of expressing them are either
> too weak to too strong.

I find this perspective more convincing. The general problem with clever 
abstractions is that by hiding the true underlying mechanisms, they 
sometimes limit your capabilities or make the natural solution harder to 
express.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From gregg at cytetech.com  Wed Jan 21 15:27:21 2009
From: gregg at cytetech.com (Gregg Wonderly)
Date: Wed, 21 Jan 2009 14:27:21 -0600
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <49777BFA.2050503@redhat.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<22ec15240901140700m3e6de82cn26c55af55c1fae@mail.gmail.com>
	<496E24A6.2000705@cytetech.com>
	<22ec15240901141017i569f85eavc4dcd4d6eed6da83@mail.gmail.com>
	<238A96A773B3934685A7269CC8A8D0423F829CFF13@GVW0436EXB.americas.hpqcorp.net>
	<496E4B66.9070106@cytetech.com>
	<238A96A773B3934685A7269CC8A8D0423F829D0115@GVW0436EXB.americas.hpqcorp.net>
	<496F4AC8.50802@cox.net> <4977405C.6060609@cs.oswego.edu>
	<49776401.2070005@cytetech.com>
	<alpine.DEB.1.10.0901211025290.672@eeepc-hansboehm>
	<49777BFA.2050503@redhat.com>
Message-ID: <49778529.2080305@cytetech.com>

Jason T. Greene wrote:
> Hans Boehm wrote:
>>
>>
>> On Wed, 21 Jan 2009, Gregg Wonderly wrote:
>>
>>> Maybe I'm still not getting what the underlying issue is.  I thought 
>>> we were
>>> talking about the fact that because there were no other visible 
>>> references that
>>> the Compiler/GC might decide on actions that would cause the object 
>>> to be made
>>> eligible for GC.  So, to me releaseHere(), or doneUsingReference() or
>>> holdThisUntilHere() or some such is the control that we are trying to 
>>> put in
>>> place.  Am I still missing something?
>>>
>> The problem is that the reference may or may not be used again later in
>> another method call.  If it is used again later, we expect keepAlive()
>> (or whatever) to be a no-op, since the object can't be finalized yet
>> anyway.  But releaseHere() implies that we are definitely done with the
>> reference, and it's OK to garbage collect the object.
>>
>> In the case in which this actually is the last use, those names seem OK,
>> except that the object might still not be finalized until much later.
>>
>> Although I don't like releaseHere(), the other two, or just 
>> holdUntilHere(), sound fine to me.  The one diasadvantage is that
>> the CLR already seems to use keepAlive().  But that may not be
>> a major concern.
> 
> IMO keepAlive() is a good name that is easy to understand.

I won't argue that its a good name and easy to understand.  What I'm suggesting 
is that it feels more like it initiates and action at that point in the code 
rather than deferring an action until that point in the code.  With 
documentation and such, it would probably work.  I'm still worried about the 
readability of code being weakened because it doesn't really show a delimited 
block of code in an intuitive way.  Given all the other things we do with 
start*(), end*() and blocks as in synchronized(...) { ... } etc. it feels like 
there needs to be something really "good" chosen as the name to make it clear 
what it implies.  Adopting the CLR chosen name, might be advantageous for those 
doing CLR based development, but I'm not sure it's the best choice.

Gregg Wonderly

From hans.boehm at hp.com  Wed Jan 21 16:15:20 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 21 Jan 2009 21:15:20 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <497769C8.5050302@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
	<497769C8.5050302@cs.oswego.edu>
Message-ID: <238A96A773B3934685A7269CC8A8D0424268118363@GVW0436EXB.americas.hpqcorp.net>

 

> -----Original Message-----
> From: javamemorymodel-discussion-bounces at cs.umd.edu 
> [mailto:javamemorymodel-discussion-bounces at cs.umd.edu] On 
> Behalf Of Doug Lea
> Sent: Wednesday, January 21, 2009 10:31 AM
> To: Joe Bowbeer
> Cc: concurrency-interest; javamemorymodel-discussion
> Subject: Re: [Javamemorymodel-discussion] 
> [concurrency-interest] Fences.keepAlive
> 
> Joe Bowbeer wrote:
> > 
> > It's hard for me to mesh fences with the JMM.  In the 
> context of JMM, 
> > fences seem like magic.  (Whereas in the magical world of a 
> DEC Alpha, 
> > fences impose
> > reality.)
> > 
> 
> Although from a different perspective, it is almost the 
> opposite.  Memory consistency is all about the relations 
> among memory accesses, not the accesses themselves. If people 
> somehow liked programming the interstices across accesses 
> (which is what fences do), it would probably be easier to 
> specify a fairly simple memory model of sorts that described 
> effects.  But no one likes to program in this way, and even 
> if they did, it would be much harder to verify correct usage. 
> So instead the JMM associates relations with sets of accesses 
> of variables tagged as volatile etc. Which enters the messy 
> territory of how mixtures of volatiles, non-volatile, and 
> final accesses interrelate. If you instead program directly 
> use Fence API, you don't have to pay attention to this part 
> much, but on penalty of having to program in a very unnatural 
> way -- a style that you would only tolerate in a small part 
> of your program for the sake of enforcing an ordering 
> relation that is not otherwise obtainable; i.e., because the 
> available means of expressing them are either too weak to too strong.
> 
> In other words, the Fences API methods are just as removed 
> from hardware as volatile specs are. They feel closer because 
> HW folks have no sympathy about programmability, so usually 
> only provide instruction sets supporting 
> interstice-programming (fences), on top of a set of base 
> ordering guarantees, rather than tagged variable access, so 
> the mapping is easier.
> 
> (*) Footnote/disclaimer: However, there is one access-based, 
> not relation-based property of volatiles -- access is 
> guaranteed atomic even for longs and doubles, unlike the case 
> for non-volatiles.
> 
This may understate the difficulty of pinning down a satisfactory semantics for fences.  As far as I can tell, they are really hard to specify in a both that's both strong enough to avoid surprises and weak enough to be implementable across commercially significant hardware.  For one example of this, see the thread leading to http://www.decadentplace.org.uk/pipermail/cpp-threads/2009-January/001967.html .

Part of the difficulty here is that volatiles at least have the property that if you declare enough things volatile, you can always get sequential consistency back.  (In Java, there are some minor glitches since we don't have volatile array elements, but those can be worked around.)  Even if you add all possible fences between every pair of memory operations, you won't get sequential consistency back (e.g. for the IRIW example, or for the one in the above thread).  At least I don't know of a reasonable definition for fences that would give you those semantics.

My feeling about the C++ fences has always been that we traded off generality and potentially some performance for a spec with tolerable complexity.  They don't do everything you might want.

Clearly Doug's current proposal for Java fences is different from the C++ one.  Restricting it to a single object seems cleaner and safer, though it doesn't address some of the concerns that drove the C++ one, e.g. minimizing overhead when releasing multiple locks.  But I think the current version still doesn't address some critical details:

1) I think lazySet already fundamentally broke the Java memory model formalism, in that I don't see how it's compatible with a total synchronization order.  LazySet operations performed by different threads presumably don't have to be seen in the same order by all observers?  The fence API breaks it further.

2) I'm really nervous about the final field emulation piece of this, since it assumes the implementation of the reader respects data dependencies.  The current Java memory model guarantees that only for final fields, so I don't think this can be correct, as it stands.  I think I would be much more comfortable if the reader side were also explicit about the required ordering.

3) As I think others have pointed out, the fence wording needs work.  It's unclear what role the argument plays.

Hans

From joe.bowbeer at gmail.com  Wed Jan 21 16:55:33 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 21 Jan 2009 13:55:33 -0800
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
Message-ID: <31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>

More related to keepAlive:

1. Names

 I think one of the "until" names better conveys what it is trying to do.

  holdUntilHere(ref);

Though I would be even more comfortable if a Runnable were used to define
the scope:

  doWithStronglyReachableReference(ref, runnable);

Is that possible?  Or is there a chicken-egg problem?

2. Typo in keepAlive example:

  keepAlive(this) => Fences.keepAlive(this)

3. Concerning "strongly reachable" in the method description, should this
link to "reachability" instead:

http://java.sun.com/javase/6/docs/api/java/lang/ref/package-summary.html#reachability

Joe

PS - Regarding "alive," I reiterate my suggestion to use a term that is
defined in the referenced sections of the JLS. That statement that "live"
includes things that are not "live" still freaks me out.



On Wed, Jan 21, 2009 at 8:39 AM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> I *can* follow the class description and its Fences examples.
>
> I don't follow keepAlive.  It's barely covered in the class description and
> the method description doesn't make sense to me.
>
> More on fences and keepAlive below.
>
> Fences.  [More yowing...]
>
> It's hard for me to mesh fences with the JMM.  In the context of JMM,
> fences seem like magic.  (Whereas in the magical world of a DEC Alpha,
> fences impose reality.)
>
> Do fences create open-ended happens-before edges?  Or are the edges only
> created when the next load or store occurs?  Or does it matter?
>
> More to the point: Are there Java code transformations (e.g., injections)
> that could be used to illustrate what they really do in terms of Java code?
>
> Are fences actually cheap to implement on all platforms?  Won't there be
> some platforms where they are more expensive than current alternatives?  (If
> not, why wasn't the JMM spec'd in terms of fences?)
>
> keepAlive.
>
> I don't think this is covered well-enough in the class description, and I
> can't follow the example in the method description.  I also wonder if
> there's a better name.
>
> Some problems I encountered:
>
> I was expecting the "Reference" link to define the term "strongly
> reachable", but neither "strong" nor "reachable" can be found on that page.
>
> What does "alive" mean?
>
> JLS 12.6.1 defines the reachable and finalized attributes, but it never
> adequately defines "alive".
>
> While there is mention of keeping a thread alive, and of live references,
> these terms seem to be used intuitively, and sometimes confusingly, for
> example:
>
>     "... then there can never be any live references to it (this includes
> references that are not live, but might be resurrected by finalizers) ..."
>
> The undead is really alive?  What does alive mean?  Is it some combination
> of reachable and finalized attributes?
>
> I suggest giving keepAlive a more verbose name, like the other fence
> method.  Preferably a name composed of terms that are defined in the JLS.
> (I also recommend considering tightening up the use of the terms "live" and
> "alive" in the JLS.)
>
> keepNotFinalized?
>
> Though even with a new name, I suspect I'll still be trying to figure out
> what this does...
>
> Joe
>
>
> On Wed, Jan 21, 2009 at 5:41 AM, Doug Lea wrote:
>
>> Boehm, Hans wrote:
>> > I'd be inclined to somewhat simplify the example, and not use the
>> > constructor.  I'm also not sure I'd mention the word "native", since
>> that
>> > seems to mislead people to believe that this is a native code issue.
>>
>> Thanks! Added with a few minor edits.
>>
>> Plus a few other minor edits elsewhere.
>>
>>
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
>>
>> -Doug
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090121/8983f943/attachment.html>

From hans.boehm at hp.com  Wed Jan 21 18:02:12 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 21 Jan 2009 23:02:12 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion]
	Fences.keepAlive
In-Reply-To: <31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>
	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>
	<496CADB0.3020605@cs.oswego.edu> <496DF4C1.1000105@cs.oswego.edu>
	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>
	<497460BA.3030605@cs.oswego.edu>
	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>
	<49772605.5030402@cs.oswego.edu>
	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
	<31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
Message-ID: <238A96A773B3934685A7269CC8A8D04242681184B6@GVW0436EXB.americas.hpqcorp.net>



________________________________
From: javamemorymodel-discussion-bounces at cs.umd.edu [mailto:javamemorymodel-discussion-bounces at cs.umd.edu] On Behalf Of Joe Bowbeer
Sent: Wednesday, January 21, 2009 1:56 PM
To: concurrency-interest; javamemorymodel-discussion
Subject: Re: [Javamemorymodel-discussion] [concurrency-interest] Fences.keepAlive

More related to keepAlive:

1. Names

 I think one of the "until" names better conveys what it is trying to do.

  holdUntilHere(ref);

Though I would be even more comfortable if a Runnable were used to define the scope:

  doWithStronglyReachableReference(ref, runnable);

Is that possible?  Or is there a chicken-egg problem?


It seems possible to me.  But I have two concerns:


 1.  Unlike the other fences, I think we want to encourage use of keepAlive, or whatever it ends up being called.  It may be ugly, but the alternative is usually wrong,which is worse.  This means we want to make it as easy to use as possible, and this seems to make it syntactically quite heavy.  I would expect correct code to use this several times per finalizable class
 2.  We want to add keepAlive in large part because synchronized(this){} is much slower than it needs to be for this (ab)use.  And there is no good argument that keepAlive won't end up on a frequently executed code path.  Do we believe that common implementations will optimize out any overhead associated with the Runnable?  If I understand this correctly, the expected use will involve allocating and constructing the runnable each time.  Construction presumably sets up a method table, which might require a fence.  Thus a naive implementation seems to add significant overhead, which one might avoid with escape analysis etc.  But if implementations don't actually perform those optimizations, we still have a problem.

Hans
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090121/fe27df61/attachment-0001.html>

From dl at cs.oswego.edu  Thu Jan 22 07:29:08 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 22 Jan 2009 07:29:08 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>
	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>	<497460BA.3030605@cs.oswego.edu>	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>	<49772605.5030402@cs.oswego.edu>	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>
	<31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
Message-ID: <49786694.6070601@cs.oswego.edu>

Joe Bowbeer wrote:
> More related to keepAlive:
> 
> 1. Names
> 
>  I think one of the "until" names better conveys what it is trying to do.
> 

I'm thinking we are veering back to just "keepAlive", but
with a bit more tutorial explanation that helps people make
sense of the name. I did another edit pass pulling the
usage example to class-level doc and explaining a bit more.
More suggestions for improvement would be welcome.

http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

> 
> 3. Concerning "strongly reachable" in the method description, should 
> this link to "reachability" instead:

Yes, thanks. I was having trouble getting javadoc to emit that
package-doc URL rather than class doc URL, but now fixed.

-Doug


From mbien at fh-landshut.de  Thu Jan 22 10:13:28 2009
From: mbien at fh-landshut.de (Michael Bien)
Date: Thu, 22 Jan 2009 16:13:28 +0100
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <49786694.6070601@cs.oswego.edu>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>	<497460BA.3030605@cs.oswego.edu>	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>	<49772605.5030402@cs.oswego.edu>	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>	<31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
	<49786694.6070601@cs.oswego.edu>
Message-ID: <49788D18.5000000@fh-landshut.de>

has it already been considered to move the Fences.* API into a sun 
package like Unsafe etc. or even into a external library (@see JDK7 
modules)? I am still not convinced that it is necessary to introduce it 
as public API ;)

I don't think Fences is a API which addresses mainstream problems. It is 
probably rather a feature you would need inside libraries to solve 
corner cases.

i hope you hide it well in javadoc to prevent overuse ;). I fear this 
may cause more bad written code than help fixing corner cases...

regards,

michael

Doug Lea wrote:
> Joe Bowbeer wrote:
>> More related to keepAlive:
>>
>> 1. Names
>>
>>  I think one of the "until" names better conveys what it is trying to 
>> do.
>>
>
> I'm thinking we are veering back to just "keepAlive", but
> with a bit more tutorial explanation that helps people make
> sense of the name. I did another edit pass pulling the
> usage example to class-level doc and explaining a bit more.
> More suggestions for improvement would be welcome.
>
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html 
>
>
>>
>> 3. Concerning "strongly reachable" in the method description, should 
>> this link to "reachability" instead:
>
> Yes, thanks. I was having trouble getting javadoc to emit that
> package-doc URL rather than class doc URL, but now fixed.
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From dl at cs.oswego.edu  Thu Jan 22 10:38:02 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 22 Jan 2009 10:38:02 -0500
Subject: [concurrency-interest]
	[Javamemorymodel-discussion]	Fences.keepAlive
In-Reply-To: <49788D18.5000000@fh-landshut.de>
References: <5BAFC8932E3447198FAD54C657B62910@BrettPC>	<C481C530-641A-44C7-970B-65C2FA0248D7@cs.umd.edu>	<496CADB0.3020605@cs.oswego.edu>	<496DF4C1.1000105@cs.oswego.edu>	<1631da7d0901181708n654bf899n1a266f081642c03c@mail.gmail.com>	<497460BA.3030605@cs.oswego.edu>	<238A96A773B3934685A7269CC8A8D0424268117AF1@GVW0436EXB.americas.hpqcorp.net>	<49772605.5030402@cs.oswego.edu>	<31f2a7bd0901210839t77c735ci128fd55b8f6b6ff9@mail.gmail.com>	<31f2a7bd0901211355o4d5e3d88ha7515278f9154d09@mail.gmail.com>
	<49786694.6070601@cs.oswego.edu> <49788D18.5000000@fh-landshut.de>
Message-ID: <497892DA.3090805@cs.oswego.edu>

Michael Bien wrote:
> has it already been considered to move the Fences.* API into a sun 
> package like Unsafe etc. or even into a external library (@see JDK7 
> modules)? I am still not convinced that it is necessary to introduce it 
> as public API ;)
> 
> I don't think Fences is a API which addresses mainstream problems. It is 
> probably rather a feature you would need inside libraries to solve 
> corner cases.

Everyone (including me) has these concerns. However...
1) It must have a public, standardized API, unlike sun.* classes which
    are not and cannot be part of JCP-approved specs.
2) The specs in the API must be implemented/honored by all
    compliant JVMs, so can only be done as a part of "major release"
    platform JSR (i.e., the Java7 release JSR, whenever that finally
    happens).
3) The only means we know of restricting use; for example, by internally
    blowing up if accessed outside of bootclasspath would make it
    unavailable to a significant segment of its intended audience;
    including those implementing infrastructure running on app-servers.
4) The desired usage restrictions have nothing to do with package
    or class or module accessibility -- methods must be available across
    these. The restrictions instead amount to: don't use this unless
    you know you need to, and are sure of consequences, which is too
    squishy to automate.

If anyone else has any good, implementable, ideas about other ways to
deal with this, please let me know! As mentioned in one of my
replies to Sarita, while there might be some plausible alternative
paths here, all of them that I know would entail some significant
medium/long-term efforts.

Also, do bear in mind that the amount of discussion on the
topic is completely uncorrelated with its range of use!
Relatively few people need this API, but those who do, need
to have clear specs and correct implementations. For JMM-related
features, history shows there are usually a few thousand lines of
list discussion per line of code ultimately implemented :-)

-Doug



From gkorland at gmail.com  Thu Jan 22 17:09:39 2009
From: gkorland at gmail.com (Guy Korland)
Date: Fri, 23 Jan 2009 00:09:39 +0200
Subject: [concurrency-interest] Concurrent stack
Message-ID: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>

Hi,

Are there any plans to add the concurrent package a concurrent stack?
The current implementation exists as part of the JRE is a synchronized.
While there're few well known algorithms for non-blocking stack.

-- 
Guy Korland
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090123/561112e8/attachment.html>

From joe.bowbeer at gmail.com  Thu Jan 22 17:24:52 2009
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 22 Jan 2009 14:24:52 -0800
Subject: [concurrency-interest] Concurrent stack
In-Reply-To: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
References: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
Message-ID: <31f2a7bd0901221424q4962ba84u9a7deedd7ea9cece@mail.gmail.com>

Look for an implementation of java.util.Deque in the java.util.concurrent
package:

http://java.sun.com/javase/6/docs/api/java/util/concurrent/LinkedBlockingDeque.html

On Thu, Jan 22, 2009 at 2:09 PM, Guy Korland wrote:

> Hi,
>
> Are there any plans to add the concurrent package a concurrent stack?
> The current implementation exists as part of the JRE is a synchronized.
> While there're few well known algorithms for non-blocking stack.
>
> --
> Guy Korland
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090122/6f85b198/attachment.html>

From jim.andreou at gmail.com  Thu Jan 22 17:26:32 2009
From: jim.andreou at gmail.com (Jim Andreou)
Date: Fri, 23 Jan 2009 00:26:32 +0200
Subject: [concurrency-interest] Concurrent stack
In-Reply-To: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
References: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
Message-ID: <7d7138c10901221426k43c9bc35sb5264c042228bedf@mail.gmail.com>

It's already there: SynchronousQueue.

put() for push
take() for pop

Ok, this is cheating, but without synchronization (like in Stack, i.e.
sequential pushs and pops), you have no defined order to expect anyway.

Dimitris

2009/1/23 Guy Korland <gkorland at gmail.com>

> Hi,
>
> Are there any plans to add the concurrent package a concurrent stack?
> The current implementation exists as part of the JRE is a synchronized.
> While there're few well known algorithms for non-blocking stack.
>
> --
> Guy Korland
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090123/376322dc/attachment.html>

From jim.andreou at gmail.com  Thu Jan 22 17:34:14 2009
From: jim.andreou at gmail.com (Dimitris Andreou)
Date: Fri, 23 Jan 2009 00:34:14 +0200
Subject: [concurrency-interest] Concurrent stack
In-Reply-To: <7d7138c10901221426k43c9bc35sb5264c042228bedf@mail.gmail.com>
References: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
	<7d7138c10901221426k43c9bc35sb5264c042228bedf@mail.gmail.com>
Message-ID: <4978F466.6050907@gmail.com>

Dah, this is wrong, since that would include waiting for the opposite 
action. Ignore this, thanks.

O/H Jim Andreou ??????:
> It's already there: SynchronousQueue.
>
> put() for push
> take() for pop
>
> Ok, this is cheating, but without synchronization (like in Stack, i.e. 
> sequential pushs and pops), you have no defined order to expect anyway.
>
> Dimitris
>
> 2009/1/23 Guy Korland <gkorland at gmail.com <mailto:gkorland at gmail.com>>
>
>     Hi,
>
>     Are there any plans to add the concurrent package a concurrent stack?
>     The current implementation exists as part of the JRE is a
>     synchronized.
>     While there're few well known algorithms for non-blocking stack.
>
>     -- 
>     Guy Korland
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>


From jim.andreou at gmail.com  Thu Jan 22 17:56:56 2009
From: jim.andreou at gmail.com (Dimitris Andreou)
Date: Fri, 23 Jan 2009 00:56:56 +0200
Subject: [concurrency-interest] Concurrent stack
In-Reply-To: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
References: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
Message-ID: <4978F9B8.4040906@gmail.com>

Out of curiosity: could the following have a chance to scale better than 
a plain LinkedBlockingDeque? (Modest implementation of concurrent stack, 
from what I read at The Art of Multiprocessor Programming, section 11.3, 
where pending pushes and pops cancel each other).

public class Stack<T> {
    private final BlockingDeque<T> stack = new LinkedBlockingDeque<T>();
    private final SynchronousQueue<T> eliminationQueue = new 
SynchronousQueue();

    public void push(T element) throws InterruptedException {
//(I added wait for 1 nanosecond because 0 is special cased and never 
waits, but somebody would have to wait for it to succeed).
        if (eliminationQueue.offer(element, 1L, TimeUnit.NANOSECONDS)) {
            return;
        }
        stack.addLast(element);
    }

    public T pop() throws InterruptedException {
        T element = eliminationQueue.poll(1L, TimeUnit.NANOSECONDS);
        if (element != null) {
            return element;
        }
        return stack.takeLast();
    }
}

O/H Guy Korland ??????:
> Hi,
>
> Are there any plans to add the concurrent package a concurrent stack?
> The current implementation exists as part of the JRE is a synchronized.
> While there're few well known algorithms for non-blocking stack.
>
> -- 
> Guy Korland
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


From gkorland at gmail.com  Fri Jan 23 03:26:48 2009
From: gkorland at gmail.com (Guy Korland)
Date: Fri, 23 Jan 2009 10:26:48 +0200
Subject: [concurrency-interest] Concurrent stack
In-Reply-To: <7d7138c10901221426k43c9bc35sb5264c042228bedf@mail.gmail.com>
References: <79be5fa30901221409h2635e6b7i1c31abee6748b329@mail.gmail.com>
	<7d7138c10901221426k43c9bc35sb5264c042228bedf@mail.gmail.com>
Message-ID: <79be5fa30901230026h19a6ffe2wcde455238f2f39a1@mail.gmail.com>

Hi,

There's a work called "D. Hendler, N. Shavit, and L. Yerushalmi. A Scalable
Lock-Free Stack
Algorithm<http://www.cs.tau.ac.il/%7Eshanir/nir-pubs-web/Papers/Lock_Free.pdf>
".
It provides a much more scalable solution based on an elimination array and
still provides a proved linearizable stack.

Guy

On Fri, Jan 23, 2009 at 12:26 AM, Jim Andreou <jim.andreou at gmail.com> wrote:

> It's already there: SynchronousQueue.
>
> put() for push
> take() for pop
>
> Ok, this is cheating, but without synchronization (like in Stack, i.e.
> sequential pushs and pops), you have no defined order to expect anyway.
>
> Dimitris
>
> 2009/1/23 Guy Korland <gkorland at gmail.com>
>
>> Hi,
>>
>> Are there any plans to add the concurrent package a concurrent stack?
>> The current implementation exists as part of the JRE is a synchronized.
>> While there're few well known algorithms for non-blocking stack.
>>
>> --
>> Guy Korland
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>


-- 
Guy Korland
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090123/3524d134/attachment.html>

From robertlazarski at gmail.com  Fri Jan 23 14:17:12 2009
From: robertlazarski at gmail.com (robert lazarski)
Date: Fri, 23 Jan 2009 16:17:12 -0300
Subject: [concurrency-interest] Thread pools threads exhausted?
In-Reply-To: <f87675ee0901191327x7cebd1b7k158eb65f182ec3b4@mail.gmail.com>
References: <f87675ee0901191117j5fdbb8fdg7e33718fab24eb5a@mail.gmail.com>
	<31f2a7bd0901191136q17ccbaedsfe61ef2f7f0d7fc@mail.gmail.com>
	<f87675ee0901191259x38009b01p442339a511c40cad@mail.gmail.com>
	<31f2a7bd0901191313r6d2e591ekfa573d14173e6de@mail.gmail.com>
	<f87675ee0901191327x7cebd1b7k158eb65f182ec3b4@mail.gmail.com>
Message-ID: <f87675ee0901231117r64ad06a0pfa748ed2f67d50bc@mail.gmail.com>

On Mon, Jan 19, 2009 at 6:27 PM, robert lazarski
<robertlazarski at gmail.com> wrote:
> On Mon, Jan 19, 2009 at 6:13 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
>> Note that submit throws the exception, which will throw an exception to the
>> caller of readUrl.  You won't receive the future if the submission is
>> rejected.
>>
> Sounds good, all I can do now is wait until the problem happens again.
>
> - R

Just thought mention that we seemingly found the problem though it
wasn't thread related. Someone emailed me off list and suggested I
look to see if I ran into an open file descriptors limit. We indeed
ran into that limit (1024 by default), and once we raised it, the
problem hasn't repeated. I'm suprised somewhat since in my previous
experiences with java sockets, I'd get a "too many open files" errors
when that happened.

Anyways, in case someone googles on this ... on linux ...

In file /etc/security/limits.conf add:

* soft nofile 65535
* hard nofile 65535

For an extra measure, in /etc/sysctl.conf put:

fs.file-max = 4194304

These commands require a reboot to take effect. After the reboot, you
can then test by running this command and seeing the result as 65535 .

/root> ulimit -n
65535

- R

From hans.boehm at hp.com  Mon Jan 26 17:46:26 2009
From: hans.boehm at hp.com (Boehm, Hans)
Date: Mon, 26 Jan 2009 22:46:26 +0000
Subject: [concurrency-interest] [Javamemorymodel-discussion] Fences,
	AtomicXFieldUpdater	enhancements, and @Racy annotations
In-Reply-To: <20090126143104.GH6364@linux.vnet.ibm.com>
References: <49708EF0.20605@cs.oswego.edu>
	<20090126143104.GH6364@linux.vnet.ibm.com>
Message-ID: <238A96A773B3934685A7269CC8A8D04242683CAAF6@GVW0436EXB.americas.hpqcorp.net>

 

> -----Original Message-----
> From: javamemorymodel-discussion-bounces at cs.umd.edu 
> [mailto:javamemorymodel-discussion-bounces at cs.umd.edu] On 
> Behalf Of Paul E. McKenney
> Sent: Monday, January 26, 2009 6:31 AM
> To: Doug Lea
> Cc: Concurrency-interest at cs.oswego.edu; 
> javamemorymodel-discussion at cs.umd.edu
> Subject: Re: [Javamemorymodel-discussion] Fences, 
> AtomicXFieldUpdater enhancements, and @Racy annotations
> 
> On Fri, Jan 16, 2009 at 08:43:12AM -0500, Doug Lea wrote:
> > [This one is equally on java.util.concurrent and JMM 
> issues, so please 
> > be tolerant of cross-post duplication.]
> > 
> > First, I'm getting more confident that the specs for Fence 
> API are in 
> > the right ballpark, although still need a bit more precision in the 
> > discussion of "scopes".  (If anyone want to help, please 
> do!) See the 
> > updated draft 
> > 
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atom
> > ic/Fences.html
> 
> Does this support per-thread counters, which do not need any 
> particular ordering semantics, but which must avoid 
> load/store "tearing"?  I could interpret the earlier 
> discussion about Java's storage guarantees as covering this, 
> but thought I should ask explicitly.  I don't see anything in 
> the proposal that supports this sort of thing.
> 
> (In per-thread counters, each thread adds to its own counter, 
> and a thread needing to access the count sums the per-thread 
> counters.)
> 
> 						Thanx, Paul
> 
I think those largely represent an orthogonal issue.  The answer depends on how approximate an answer you're happy with.  Ordinary Java non-volatile variables arguably work, so long as they are of type int, not long (or you do atomic replacement of pointers to them instead).  Only longs may exhibit "tearing".  However you don't get cache-coherence on individual per-thread counters.  Thus thread T2 may still observe thread T1s counter running backwards, but probably only by a little.  (This is a feature, not a bug.  Since, unlike in C++, these are ordinary variables, not weakly oprdered atomics, the optimization cost of preventing this is large, at least in the general case, since it's hard to tell when two read accesses alias.  This sort of "cache coherence" was required in the original Java memory model, but widely ignored.  That was a major factor in convincing Bill and Jeremy to revisit the issue.)

Hans

From dl at cs.oswego.edu  Tue Jan 27 07:23:51 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 27 Jan 2009 07:23:51 -0500
Subject: [concurrency-interest] Fence API
Message-ID: <497EFCD7.3010602@cs.oswego.edu>

Walking through discussions of the name for the method initially
listed as "keepAlive", I'm giving one more shot to a concrete
proposal before resorting to a poll/vote.

The name "reachabilityFence" has a few virtues:
   * mentions reachability vs aliveness
   * "fence" implies the "here"-ness that was missing in other names
   * is of a similar form as other fences, so the spec can phrased
     in a similar way.
Probably the main disadvantage is that it is more awkward-sounding
that some other suggestions.

An updated draft with this wording is at
http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html

Please take a look. If there are more than a few complaints or
alternative suggestions, we'll do a poll.

-Doug


From peter.jones at sun.com  Tue Jan 27 15:01:41 2009
From: peter.jones at sun.com (Peter Jones)
Date: Tue, 27 Jan 2009 15:01:41 -0500
Subject: [concurrency-interest] Fence API
In-Reply-To: <497EFCD7.3010602@cs.oswego.edu>
References: <497EFCD7.3010602@cs.oswego.edu>
Message-ID: <20090127200141.GA17649@east>

On Tue, Jan 27, 2009 at 07:23:51AM -0500, Doug Lea wrote:
> Walking through discussions of the name for the method initially
> listed as "keepAlive", I'm giving one more shot to a concrete
> proposal before resorting to a poll/vote.
>
> The name "reachabilityFence" has a few virtues:
>   * mentions reachability vs aliveness
>   * "fence" implies the "here"-ness that was missing in other names
>   * is of a similar form as other fences, so the spec can phrased
>     in a similar way.
> Probably the main disadvantage is that it is more awkward-sounding
> that some other suggestions.
>
> An updated draft with this wording is at
> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
>
> Please take a look.

I like that name.  A nitpick perhaps, but this wording:

    this method is applicable only when reclamation may have visible
    effects, which is possible only for objects with finalizers

seems a bit narrow to me-- it can also apply when an entity external
to an object is tracking its reachability with reference objects (like
with the previously-mentioned RMI DGC use case, bug 6181943).  Rather
than expand further here, removing the second "only" seems OK to me.

-- Peter

From tom at firstbest.com  Tue Jan 27 16:21:30 2009
From: tom at firstbest.com (Tom Muldoon)
Date: Tue, 27 Jan 2009 16:21:30 -0500
Subject: [concurrency-interest] Looking to extend the ThreadPoolExecutor in
	a JBoss environment
Message-ID: <16DEE585D4230E47ABD58238F73E6FB665C1638EA7@mail2.corp.firstbest.com>

I'm hoping to extend the edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor to override the beforeExecute and/or afterExecute methods (to ensure that the log4j NDC threadLocal is reinitialized) within a JBoss (4.2.2) environment. While extending the class is easy, I'm hoping that someone can shed a little light regarding just how to "tell" JBoss to use my implementation.  I unfortunately came up empty in my search of the JBoss forums (as well as the concurrency-interest archives).

Thanks, Tom
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20090127/97159264/attachment.html>

From dl at cs.oswego.edu  Tue Jan 27 19:13:21 2009
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 27 Jan 2009 19:13:21 -0500
Subject: [concurrency-interest] Fence API
In-Reply-To: <20090127200141.GA17649@east>
References: <497EFCD7.3010602@cs.oswego.edu> <20090127200141.GA17649@east>
Message-ID: <497FA321.2050707@cs.oswego.edu>

Peter Jones wrote:
>> http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html
>>
>> Please take a look.
> 
> I like that name.  A nitpick perhaps, but this wording:
> ...


Thanks! fixed.

I also put in a few sentences trying to summarize issues
Endre pointed out.

Everyone please feel free to keep sending other suggested
improvements. If you like, send them off-list

-Doug

