From qweries at gmail.com  Mon Jul  3 06:08:15 2006
From: qweries at gmail.com (Raj)
Date: Mon, 3 Jul 2006 15:38:15 +0530
Subject: [concurrency-interest] NullPointerExceptionin
	ThreadLocal$ThreadLocalMap.replaceStaleEntry
In-Reply-To: <44A53C02.60207@tackline.plus.com>
References: <f6e4b9950606300116u20040447l12889617cb90e2a@mail.gmail.com>
	<44A5199A.3030807@cs.oswego.edu> <44A53C02.60207@tackline.plus.com>
Message-ID: <f6e4b9950607030308w344433b4qc6a6fb16cd390b3@mail.gmail.com>

To check if we are facing the "ThreadLocal.initialValue" creating a
new ThreadLocal bug, we added the following to ThreadLocal.java and
set it in the boot classpath.

public ThreadLocal()
{
   Throwable throwable = new Throwable();
   StackTraceElement[] traces = throwable.getStackTrace();
   for(int i=0; i<traces.length; i++)
   {
      if(traces[i].getMethodName().equals("initialValue") ||
         traces[i].getMethodName().equals("get") ||
         traces[i].getMethodName().equals("set"))
      {
         throwable.printStackTrace();

         PrintWriter writer =null;
         try{
            File tempFile = File.createTempFile("tlocal", ".txt", new
File("c:/temp"));
            FileOutputStream fileOutputStream = new FileOutputStream(tempFile);
            writer = new PrintWriter(new OutputStreamWriter(fileOutputStream));
            throwable.printStackTrace(writer);
         }catch(Throwable t){
            t.printStackTrace();
            throwable.printStackTrace();
         }finally{
            if(writer!=null){
               writer.flush();
               writer.close();
            }
         }
      }
   }
}

The log files get generated in c:/temp when we run a simple test
client where "ThreadLocal.initialValue" is creating a new ThreadLocal.
This indicates the patched ThreadLocal is fine.

However, when we run our tests, we continue to get the original NPE
but no log file is being created by the patch. This indicates that
there might be some other situation where we get this NPE.

Would greatly appreciate any other thoughts in this regard.

Thanks,
Raj

On 6/30/06, Thomas Hawtin <tackline at tackline.plus.com> wrote:
> Doug Lea wrote:
> >
> > As Joe just mentioned, there was an unsupported usage (that
> > was not clearly documented as unsupported) of initialValue
> > methods recursively creating other ThreadLocals, that was
> > addressed for Mustang, and which might conceivably cause this.
> > It might not be too hard to look in your code to see if
> > there are any cases of this. Otherwise, offhand, this looks
> > like it might be a GC bug, but no one will be able to figure
> > it out unless they can replicate.
>
> Looking through the source, it does appear to be Bug 5025230 [1] as Joe
> says. However, this case is a bit more subtle than the scenario in the
> report. It appears that the nested thread-local initialisation causes
> some tidying of stale entries, which clears the slot about to be filled
> (probably on a complete rehash of the thread's table).
>
> Anyway, the result is the same. Initialising ThreadLocals within
> initialValue doesn't work in both 1.4.2_11 and 1.5.0_07. Currently you
> need mustang for it to work (or patch your own JRE - I believe there is
> a license to do this for internal use (IANAL)).
>
> Avoiding nested initialisation may be more difficult than it would first
> appear. As well as your own code in initialValue, you need to avoid
> using anyone else's code that might initiliase ThreadLocals. For
> instance, loading classes can cause ThreadLocals to initialise (that
> confused me briefly).
>
> You could try flushing out any ThreadLocals in every thread before using
> initialValue. However, the obvious safe approach is to override get in
> place of initialValue. Something like:
>
> public abstract class SaferThreadLocal/*<T>*/
> extends ThreadLocal/*<T>*/
> {
>     private static final Object UNINITIALIZED = new Object();
>
>     //@Override
>     protected final Object/*T*/ initialValue() {
>         return UNINITIALIZED;
>     }
>
>     protected abstract Object/*T*/ initialValueOverride();
>
>     //@SuppressWarnings("unchecked")
>     //@Override
>     protected final Object/*T*/ get() {
>         Object obj = super.get();
>         if (obj == UNINITIALIZED) {
>             obj = initialValueOverride();
>             super.set(obj);
>         }
>         return /*(T)*/obj;
>     }
> }
>
> (Disclaimer: code not tested, or even compiled.)
>
> Tom Hawtin
>
> [1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5025230
>
>

From verma.kr at tcs.com  Mon Jul  3 07:04:49 2006
From: verma.kr at tcs.com (verma.kr at tcs.com)
Date: Mon, 3 Jul 2006 16:34:49 +0530
Subject: [concurrency-interest] Detecting Killed Threads and Restarting them
	automatically
Message-ID: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>

Hi Friends,

        I am new to concurrency field so pardon me for my ignorance.

        I am trying to create a Pool of Threads using 
ScheduledThreadPoolExecutor class as follows:

        ScheduledExecutorService service = new 
ScheduledThreadPoolExecutor(5)
 
        After that i submit 5 tasks each implemeting runnable ..all these 
tasks are supposed to run infinitely in a while loop.

        My doubt is that if at any stage one of the threads is killed due 
to RunTime Exception or some critical error in code being executed, then
        is there a mechanism by which i can detect Thread termination and 
RESTART it. 

        If it can be automatically done that shall be great.

        Please advice.

Thanks And Regards,
Verma Rohit Kumar
Tata Consultancy Services Limited
Mailto: verma.kr at tcs.com
Website: http://www.tcs.com
=====-----=====-----=====
Notice: The information contained in this e-mail
message and/or attachments to it may contain 
confidential or privileged information. If you are 
not the intended recipient, any dissemination, use, 
review, distribution, printing or copying of the 
information contained in this e-mail message 
and/or attachments to it are strictly prohibited. If 
you have received this communication in error, 
please notify us by reply e-mail or telephone and 
immediately and permanently delete the message 
and any attachments. Thank you


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060703/dfba2669/attachment.html 

From dcholmes at optusnet.com.au  Mon Jul  3 08:01:07 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 3 Jul 2006 22:01:07 +1000
Subject: [concurrency-interest] Detecting Killed Threads and Restarting
	themautomatically
In-Reply-To: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEMGGPAA.dcholmes@optusnet.com.au>

If a ThreadPoolExecutor's worker thread terminates due to a runtime
exception then that thread is not automatically replaced immediately.
However when the next task is submitted the normal thread creation policy
will apply: if you are below core size then a thread will be created, if
greater than core but less than max and the queue is full then again a
thread will be created. However, if there are less than max threads running
(but more than core) and the queue is not full, then the TPE will continue
to run with the same (reduced) number of threads.

If this concerns you then don't let your tasks let any exceptions escape.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
verma.kr at tcs.com
  Sent: Monday, 3 July 2006 9:05 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] Detecting Killed Threads and Restarting
themautomatically



  Hi Friends,

          I am new to concurrency field so pardon me for my ignorance.

          I am trying to create a Pool of Threads using
ScheduledThreadPoolExecutor class as follows:

          ScheduledExecutorService service = new
ScheduledThreadPoolExecutor(5)

          After that i submit 5 tasks each implemeting runnable ..all these
tasks are supposed to run infinitely in a while loop.

          My doubt is that if at any stage one of the threads is killed due
to RunTime Exception or some critical error in code being executed, then
          is there a mechanism by which i can detect Thread termination and
RESTART it.

          If it can be automatically done that shall be great.

          Please advice.

  Thanks And Regards,
  Verma Rohit Kumar
  Tata Consultancy Services Limited
  Mailto: verma.kr at tcs.com
  Website: http://www.tcs.com
=====-----=====-----=====
Notice: The information contained in this e-mail
message and/or attachments to it may contain
confidential or privileged information. If you are
not the intended recipient, any dissemination, use,
review, distribution, printing or copying of the
information contained in this e-mail message
and/or attachments to it are strictly prohibited. If
you have received this communication in error,
please notify us by reply e-mail or telephone and
immediately and permanently delete the message
and any attachments. Thank you


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060703/685b190f/attachment.html 

From alarmnummer at gmail.com  Mon Jul  3 08:26:18 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 3 Jul 2006 14:26:18 +0200
Subject: [concurrency-interest] Detecting Killed Threads and Restarting
	them automatically
In-Reply-To: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
References: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
Message-ID: <1466c1d60607030526h7e0b7a89j7267ece660f0a9e3@mail.gmail.com>

If a thread isn't runnable anymore (isn't alive) it can change state
anymore (it is going to be garbage collected).

If a task throws an RuntimeException (it can't throw a checked
exception because the runnable interface doesn't allow this) it is
caught and the 'afterExecute' method is called. You can override this
method in a subclass of ThreadPoolExecutor or in your case a subclass
of the ScheduledThreadPoolExecutor (why isn't a error policy/strategy
used instead of the current construction??)

Throwable's (that are not exceptions) shouldn't be caught anyway
because you can't make any guarantees about the stability of the
system anymore.

btw
I'm working on a concurrency library that contains the Repeater (and
the ThreadpoolRepeater). The repeater is a construct that is made for
continuous running of a single runnable by multiple threads. It has
the same configuration for delays and periods). Personally I prefer
this construct more because it gives me more control and makes it more
clear what it does. I'm going to opensource this library in the near
future.


On 7/3/06, verma.kr at tcs.com <verma.kr at tcs.com> wrote:
>
> Hi Friends,
>
>         I am new to concurrency field so pardon me for my ignorance.
>
>         I am trying to create a Pool of Threads using
> ScheduledThreadPoolExecutor class as follows:
>
>         ScheduledExecutorService service = new
> ScheduledThreadPoolExecutor(5)
>
>         After that i submit 5 tasks each implemeting runnable ..all these
> tasks are supposed to run infinitely in a while loop.
>
>         My doubt is that if at any stage one of the threads is killed due to
> RunTime Exception or some critical error in code being executed, then
>         is there a mechanism by which i can detect Thread termination and
> RESTART it.
>
>         If it can be automatically done that shall be great.
>
>         Please advice.
>
> Thanks And Regards,
>  Verma Rohit Kumar
>  Tata Consultancy Services Limited
>  Mailto: verma.kr at tcs.com
>  Website: http://www.tcs.com=====-----=====-----=====
> Notice: The information contained in this e-mail
> message and/or attachments to it may contain
> confidential or privileged information. If you are
> not the intended recipient, any dissemination, use,
> review, distribution, printing or copying of the
> information contained in this e-mail message
> and/or attachments to it are strictly prohibited. If
> you have received this communication in error,
> please notify us by reply e-mail or telephone and
> immediately and permanently delete the message
> and any attachments. Thank you
>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>

From alarmnummer at gmail.com  Mon Jul  3 08:27:44 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 3 Jul 2006 14:27:44 +0200
Subject: [concurrency-interest] Detecting Killed Threads and Restarting
	them automatically
In-Reply-To: <1466c1d60607030526h7e0b7a89j7267ece660f0a9e3@mail.gmail.com>
References: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
	<1466c1d60607030526h7e0b7a89j7267ece660f0a9e3@mail.gmail.com>
Message-ID: <1466c1d60607030527m1aa7b9fau7df55fcebbaf1dda@mail.gmail.com>

made a typo in the previous mail, it can't change state:

If a thread isn't runnable anymore (isn't alive) it can't change state
anymore (it is going to be garbage collected)

On 7/3/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> If a thread isn't runnable anymore (isn't alive) it can change state
> anymore (it is going to be garbage collected).
>
> If a task throws an RuntimeException (it can't throw a checked
> exception because the runnable interface doesn't allow this) it is
> caught and the 'afterExecute' method is called. You can override this
> method in a subclass of ThreadPoolExecutor or in your case a subclass
> of the ScheduledThreadPoolExecutor (why isn't a error policy/strategy
> used instead of the current construction??)
>
> Throwable's (that are not exceptions) shouldn't be caught anyway
> because you can't make any guarantees about the stability of the
> system anymore.
>
> btw
> I'm working on a concurrency library that contains the Repeater (and
> the ThreadpoolRepeater). The repeater is a construct that is made for
> continuous running of a single runnable by multiple threads. It has
> the same configuration for delays and periods). Personally I prefer
> this construct more because it gives me more control and makes it more
> clear what it does. I'm going to opensource this library in the near
> future.
>
>
> On 7/3/06, verma.kr at tcs.com <verma.kr at tcs.com> wrote:
> >
> > Hi Friends,
> >
> >         I am new to concurrency field so pardon me for my ignorance.
> >
> >         I am trying to create a Pool of Threads using
> > ScheduledThreadPoolExecutor class as follows:
> >
> >         ScheduledExecutorService service = new
> > ScheduledThreadPoolExecutor(5)
> >
> >         After that i submit 5 tasks each implemeting runnable ..all these
> > tasks are supposed to run infinitely in a while loop.
> >
> >         My doubt is that if at any stage one of the threads is killed due to
> > RunTime Exception or some critical error in code being executed, then
> >         is there a mechanism by which i can detect Thread termination and
> > RESTART it.
> >
> >         If it can be automatically done that shall be great.
> >
> >         Please advice.
> >
> > Thanks And Regards,
> >  Verma Rohit Kumar
> >  Tata Consultancy Services Limited
> >  Mailto: verma.kr at tcs.com
> >  Website: http://www.tcs.com=====-----=====-----=====
> > Notice: The information contained in this e-mail
> > message and/or attachments to it may contain
> > confidential or privileged information. If you are
> > not the intended recipient, any dissemination, use,
> > review, distribution, printing or copying of the
> > information contained in this e-mail message
> > and/or attachments to it are strictly prohibited. If
> > you have received this communication in error,
> > please notify us by reply e-mail or telephone and
> > immediately and permanently delete the message
> > and any attachments. Thank you
> >
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
>

From joe.bowbeer at gmail.com  Mon Jul  3 10:38:51 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 3 Jul 2006 07:38:51 -0700
Subject: [concurrency-interest] Detecting Killed Threads and Restarting
	them automatically
In-Reply-To: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
References: <OFB0789612.DC55472B-ON652571A0.003C186A-652571A0.003CE237@tcs.com>
Message-ID: <31f2a7bd0607030738i6dcda41ex819c389112673c44@mail.gmail.com>

On 7/3/06, verma.kr at tcs.com <verma.kr at tcs.com> wrote:
>
>         I am new to concurrency field so pardon me for my ignorance.
>
>         I am trying to create a Pool of Threads using
> ScheduledThreadPoolExecutor class as follows:
>
>         ScheduledExecutorService service = new
> ScheduledThreadPoolExecutor(5)
>
>         After that i submit 5 tasks each implemeting runnable ..all these
> tasks are supposed to run infinitely in a while loop.
>
>         My doubt is that if at any stage one of the threads is killed due to
> RunTime Exception or some critical error in code being executed, then
>         is there a mechanism by which i can detect Thread termination and
> RESTART it.
>
>         If it can be automatically done that shall be great.
>
>         Please advice.
>
> Thanks And Regards,
>  Verma Rohit Kumar
>  Tata Consultancy Services Limited

I recommend that the tasks catch and handle exceptions themselves, as
David suggests.

To detect unexpected thread termination, you can (in addition)
construct your executor with a custom ThreadFactory that assigns a
custom UncaughtExceptionHandler:

  class MyThreadFactory implements ThreadFactory {
      private static final ThreadFactory defaultFactory =
              Executors.defaultThreadFactory();
      private final Thread.UncaughtExceptionHandler handler;
      MyThreadFactory(Thread.UncaughtExceptionHandler handler) {
          this.handler = handler;
      }
      public Thread newThread(Runnable r) {
          Thread t = defaultFactory.newThread(r);
          t.setUncaughtExceptionHandler(handler);
          return t;
      }
  };

  ThreadFactory factory = new MyThreadFactory(handler);
  ScheduledExecutorService service =
Executors.newScheduledThreadPool(5, factory);

From tackline at tackline.plus.com  Mon Jul  3 10:52:05 2006
From: tackline at tackline.plus.com (Thomas Hawtin)
Date: Mon, 03 Jul 2006 15:52:05 +0100
Subject: [concurrency-interest]
	NullPointerExceptioninThreadLocal$ThreadLocalMap.replaceStaleEntry
In-Reply-To: <f6e4b9950607030308w344433b4qc6a6fb16cd390b3@mail.gmail.com>
References: <f6e4b9950606300116u20040447l12889617cb90e2a@mail.gmail.com><44A5199A.3030807@cs.oswego.edu>
	<44A53C02.60207@tackline.plus.com>
	<f6e4b9950607030308w344433b4qc6a6fb16cd390b3@mail.gmail.com>
Message-ID: <44A92F15.1020808@tackline.plus.com>

Raj wrote:
> To check if we are facing the "ThreadLocal.initialValue" creating a
> new ThreadLocal bug, we added the following to ThreadLocal.java and
> set it in the boot classpath.

It's not a problem of creating a ThreadLocal within initialValue. The 
problem is initialising a pre-thread value for a ThreadLocal, from 
either set or get.

If you put you logging code in replaceStaleEntry and rehash, I suspect 
you will see a call from initialValue (or no NPE).

Tom Hawtin

From qweries at gmail.com  Wed Jul  5 03:55:45 2006
From: qweries at gmail.com (Raj)
Date: Wed, 5 Jul 2006 13:25:45 +0530
Subject: [concurrency-interest]
	NullPointerExceptioninThreadLocal$ThreadLocalMap.replaceStaleEntry
In-Reply-To: <44A92F15.1020808@tackline.plus.com>
References: <f6e4b9950606300116u20040447l12889617cb90e2a@mail.gmail.com>
	<44A5199A.3030807@cs.oswego.edu> <44A53C02.60207@tackline.plus.com>
	<f6e4b9950607030308w344433b4qc6a6fb16cd390b3@mail.gmail.com>
	<44A92F15.1020808@tackline.plus.com>
Message-ID: <f6e4b9950607050055w27110742qe3de339852e60803@mail.gmail.com>

Hi Tom,

We moved the logging code to expungeStaleEntry and the log files are
getting generated. From the logs it was confirmed that it was a
re-entrant call to ThreadLocalMap, the call sequence being:
    ThreadLocal.get
    ThreadLocal$ThreadLocalMap.get
    ThreadLocal.initialValue
    DocumentBuilderFactory.newInstance
    AppServerClassLoader.loadClass
    ThreadLocal.get
    ThreadLocal$ThreadLocalMap.expungeStaleEntry

So infact we were facing "5025230R (thread) Creating thread local
variables from within ThreadLocal.initialValue()".

Thomas, like you mentioned, it appears that using third party
libraries in ThreadLocal.initialValue is dangerous. Extending the
argument we should consider JDK classes as third party classes (you
never know which JDK class implementation uses a ThreadLocal). Which
basically means never over-ride ThreadLocal.initialValue.

Thanks all for all the help.

Regards,
Raj

On 7/3/06, Thomas Hawtin <tackline at tackline.plus.com> wrote:
> Raj wrote:
> > To check if we are facing the "ThreadLocal.initialValue" creating a
> > new ThreadLocal bug, we added the following to ThreadLocal.java and
> > set it in the boot classpath.
>
> It's not a problem of creating a ThreadLocal within initialValue. The
> problem is initialising a pre-thread value for a ThreadLocal, from
> either set or get.
>
> If you put you logging code in replaceStaleEntry and rehash, I suspect
> you will see a call from initialValue (or no NPE).
>
> Tom Hawtin
>

From alarmnummer at gmail.com  Thu Jul  6 13:24:20 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Thu, 6 Jul 2006 19:24:20 +0200
Subject: [concurrency-interest] missed deadlines.
Message-ID: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>

I have a question regarding missed deadlines and java.util.Timer and
java.util.concurrent.ScheduledThreadPoolExecutor.

I'm wondering why there is no functionality for dealing with missed
deadlines. Within a Timer you have one thread, if a job takes a long
time, the other tasks are 'queued' untill the long-job has finished.
When that job finishes, all other queued-jobs are run and I think this
could lead to some serious issues. I can image you want to have some
control like:
-execute it
-drop it
-do something else like sending a message.

The same goes for the ScheduledThreadPoolExecutor. If a job takes a
long time and a different job needs to be scheduled, a free thread is
used (if one is available). If no free thread is available, you get
the same problems as with the Timer.

Another think I'm wondering about is the fixed size of the threadpool
of the scheduledthreadpoolexecutor. I can image it would be usefull
that a threadpool increases if there are no available threads to
execute a scheduled task and if those 'extra' threads aren't used for
some time, they could be discarded. Am I missing something?

Peter

From tim at peierls.net  Thu Jul  6 14:21:31 2006
From: tim at peierls.net (Tim Peierls)
Date: Thu, 6 Jul 2006 14:21:31 -0400
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
Message-ID: <63b4e4050607061121k78a31667jed34cafb9e32060b@mail.gmail.com>

If you have a lot long-running tasks that need scheduling, consider
splitting the task into two pieces: a trigger task that is scheduled on a
ScheduledExecutorService, and the main task, which runs in a separate
ExecutorService. The trigger task is responsible only for executing the main
task (perhaps after determining whether it is appropriate to do so at all)
in the second ExecutorService, so it can get out of the way quickly.

As has been pointed out here before, this kind of design raises its own
issues. In particular, if you want cancellation of the trigger task to
cascade to the main task, you need to keep state around in the trigger task.

I use the scheduled trigger task approach to provide a periodic background
update of a large data structure. I don't want the update to run in the
scheduled pool thread, because it could take a while and interfere with
other scheduled activities. So I schedule a trigger task to execute the
update in a cached thread pool.

--tim

On 7/6/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
>
> I have a question regarding missed deadlines and java.util.Timer and
> java.util.concurrent.ScheduledThreadPoolExecutor.
>
> I'm wondering why there is no functionality for dealing with missed
> deadlines. Within a Timer you have one thread, if a job takes a long
> time, the other tasks are 'queued' untill the long-job has finished.
> When that job finishes, all other queued-jobs are run and I think this
> could lead to some serious issues. I can image you want to have some
> control like:
> -execute it
> -drop it
> -do something else like sending a message.
>
> The same goes for the ScheduledThreadPoolExecutor. If a job takes a
> long time and a different job needs to be scheduled, a free thread is
> used (if one is available). If no free thread is available, you get
> the same problems as with the Timer.
>
> Another think I'm wondering about is the fixed size of the threadpool
> of the scheduledthreadpoolexecutor. I can image it would be usefull
> that a threadpool increases if there are no available threads to
> execute a scheduled task and if those 'extra' threads aren't used for
> some time, they could be discarded. Am I missing something?
>
> Peter
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060706/e834feb8/attachment.html 

From taras.tielkes at gmail.com  Thu Jul  6 14:57:14 2006
From: taras.tielkes at gmail.com (Taras Tielkes)
Date: Thu, 06 Jul 2006 20:57:14 +0200
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
Message-ID: <44AD5D0A.9080103@gmail.com>

Peter Veentjer wrote:
> I have a question regarding missed deadlines and java.util.Timer and
> java.util.concurrent.ScheduledThreadPoolExecutor.
>
> I'm wondering why there is no functionality for dealing with missed
> deadlines. Within a Timer you have one thread, if a job takes a long
> time, the other tasks are 'queued' untill the long-job has finished.
> When that job finishes, all other queued-jobs are run and I think this
> could lead to some serious issues. I can image you want to have some
> control like:
> -execute it
> -drop it
> -do something else like sending a message.
>
> The same goes for the ScheduledThreadPoolExecutor. If a job takes a
> long time and a different job needs to be scheduled, a free thread is
> used (if one is available). If no free thread is available, you get
> the same problems as with the Timer.
>
>   
You can do (part of) this using get(long,TimeUnit) on a Future. This 
shifts this responsibility to the caller (I think that's good).

> Another think I'm wondering about is the fixed size of the threadpool
> of the scheduledthreadpoolexecutor. I can image it would be usefull
> that a threadpool increases if there are no available threads to
> execute a scheduled task and if those 'extra' threads aren't used for
> some time, they could be discarded. Am I missing something?
>   
I usually use the "execute in caller thread" policy. If a pool if 
totally stuffed if won't help adding more threads (in the case of cpu 
bound work).

-tt


From joe.bowbeer at gmail.com  Thu Jul  6 15:27:33 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Thu, 6 Jul 2006 12:27:33 -0700
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
Message-ID: <31f2a7bd0607061227s695e3273y6d0b9965726247c6@mail.gmail.com>

On 7/6/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I have a question regarding missed deadlines and java.util.Timer and
> java.util.concurrent.ScheduledThreadPoolExecutor.
>
> I'm wondering why there is no functionality for dealing with missed
> deadlines. Within a Timer you have one thread, if a job takes a long
> time, the other tasks are 'queued' untill the long-job has finished.
> When that job finishes, all other queued-jobs are run and I think this
> could lead to some serious issues. I can image you want to have some
> control like:
> -execute it
> -drop it
> -do something else like sending a message.
>
> The same goes for the ScheduledThreadPoolExecutor. If a job takes a
> long time and a different job needs to be scheduled, a free thread is
> used (if one is available). If no free thread is available, you get
> the same problems as with the Timer.
>
> Another think I'm wondering about is the fixed size of the threadpool
> of the scheduledthreadpoolexecutor. I can image it would be usefull
> that a threadpool increases if there are no available threads to
> execute a scheduled task and if those 'extra' threads aren't used for
> some time, they could be discarded. Am I missing something?
>
> Peter


I understand your main point is that the scheduled executor doesn't
automatically create threads in order to satisfy/meet the schedule,
and I have nothing to offer :-)

For dropping tasks when the deadline has been missed, I want to point
out that there are helper methods to help tasks decide that.

TimerTask has scheduledExecutionTime

   public void run() {
       if (System.currentTimeMillis() - scheduledExecutionTime() >=
           MAX_TARDINESS)
               return;  // Too late; skip this execution.
       // Perform the task
   }

And ScheduledFuture has getDelay.  (But, on closer inspection, I think
it may be tricky for a scheduled runnable or callable "task" to call
this method, since a ScheduledFuture is created for the task by the
ScheduledExecutorService when the task is submitted.)

--Joe

From alarmnummer at gmail.com  Thu Jul  6 15:51:51 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Thu, 6 Jul 2006 21:51:51 +0200
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <31f2a7bd0607061227s695e3273y6d0b9965726247c6@mail.gmail.com>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
	<31f2a7bd0607061227s695e3273y6d0b9965726247c6@mail.gmail.com>
Message-ID: <1466c1d60607061251y7c90035dic7d8e6b647d087cc@mail.gmail.com>

> I understand your main point is that the scheduled executor doesn't
> automatically create threads in order to satisfy/meet the schedule,
> and I have nothing to offer :-)
Uncontroller thread creation is a bad thing.

I wonder how one should deal with missed deadlines. I'm writing an
article about different timer implementations and how they are
integrated in Spring. One of the things that crossed my mind where the
missed deadlines and how they should be/could be solved.

>
> For dropping tasks when the deadline has been missed, I want to point
> out that there are helper methods to help tasks decide that.
>
> TimerTask has scheduledExecutionTime
>
>    public void run() {
>        if (System.currentTimeMillis() - scheduledExecutionTime() >=
>            MAX_TARDINESS)
>                return;  // Too late; skip this execution.
>        // Perform the task
>    }
>
> And ScheduledFuture has getDelay.  (But, on closer inspection, I think
> it may be tricky for a scheduled runnable or callable "task" to call
> this method, since a ScheduledFuture is created for the task by the
> ScheduledExecutorService when the task is submitted.)

I'll have a look at them. Thanks for the reply.
>
> --Joe
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dcholmes at optusnet.com.au  Thu Jul  6 17:11:57 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 7 Jul 2006 07:11:57 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEENKGPAA.dcholmes@optusnet.com.au>

Just to clarify a little on terminology ...

> I'm wondering why there is no functionality for dealing with missed
> deadlines.

A deadline is when a task should be completed by, not when it should be
released by. Of course if your release is delayed long enough then you will
miss your deadline too.

ScheduledExecutor and Timer are best-effort mechanisms to release tasks at a
given time or periodically. If there is too much happening in the system, or
if the executor is under resourced then tasks can be released much later
than expected. If this is an issue for a task then the task should keep
track of its release times and act accordingly.

> Within a Timer you have one thread, if a job takes a long
> time, the other tasks are 'queued' untill the long-job has finished.
> When that job finishes, all other queued-jobs are run and I think this
> could lead to some serious issues. I can image you want to have some
> control like:
> -execute it
> -drop it
> -do something else like sending a message.

You could have various "I'm late" policies but then you'd have to specify
the policy for each task (I don't thing a per-executor policy works well for
this situation). And there are so many things you could do if late. Better
for the task to make such decisions in my view.

There could be an API to assist this, but a task would have to know it was
being executed in a ScheduledExecutor - which a basic Runnable or Callable
doesn't.

> Another think I'm wondering about is the fixed size of the threadpool
> of the scheduledthreadpoolexecutor. I can image it would be usefull
> that a threadpool increases if there are no available threads to
> execute a scheduled task and if those 'extra' threads aren't used for
> some time, they could be discarded. Am I missing something?

I agree that ScheduledTPE needs further thought in the area of pool sizing.
It is stuck at only coreSize. I believe in Mustang allowCoreThreadTimeout
can be set so that would allow the pool to grow and shrink based on demand,
but even so I suspect that the policy of favouring thread creation when
below coreSize would not be ideal.

Cheers,
David Holmes


From dhanji at gmail.com  Thu Jul  6 22:29:27 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Fri, 7 Jul 2006 12:29:27 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEENKGPAA.dcholmes@optusnet.com.au>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEENKGPAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10607061929q345e2efbv6e12be4e75dd000f@mail.gmail.com>

On 7/7/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> > Another think I'm wondering about is the fixed size of the threadpool
> > of the scheduledthreadpoolexecutor. I can image it would be usefull
> > that a threadpool increases if there are no available threads to
> > execute a scheduled task and if those 'extra' threads aren't used for
> > some time, they could be discarded. Am I missing something?
>
> I agree that ScheduledTPE needs further thought in the area of pool
> sizing.
> It is stuck at only coreSize. I believe in Mustang allowCoreThreadTimeout
> can be set so that would allow the pool to grow and shrink based on
> demand,
> but even so I suspect that the policy of favouring thread creation when
> below coreSize would not be ideal.



Re auto-creation of pools, what is wrong with simply starting out with the
max-intended size? After all there is no cost associated with idle threads
is there? I would think that allowing for no cap on max threads is a *very*
bad idea.
Or am I missing something else...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060707/23e90591/attachment.html 

From alarmnummer at gmail.com  Thu Jul  6 22:50:20 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Fri, 7 Jul 2006 04:50:20 +0200
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <63b4e4050607061121k78a31667jed34cafb9e32060b@mail.gmail.com>
References: <1466c1d60607061024s32b10006vb622ab8a3a9eebb1@mail.gmail.com>
	<63b4e4050607061121k78a31667jed34cafb9e32060b@mail.gmail.com>
Message-ID: <1466c1d60607061950h70ed46a0ndee664802cf809d0@mail.gmail.com>

Hmmm.. I have to think about this different approach.

Because the 'scheduling' thread never is blocked for a long period
(unless the executor it uses to execute the tasks on has to much work
to do) tasks are created on time.

But it doesn't mean that a created task is executed directly because
it can be stored in the workqueue of the executor for some time.

If I add an expirationdate to the task when the scheduler creates it
and check the expiration date when it is executed, I could add the
extra control.

I'm going to think about this approach.. thanx.

On 7/6/06, Tim Peierls <tim at peierls.net> wrote:
> If you have a lot long-running tasks that need scheduling, consider
> splitting the task into two pieces: a trigger task that is scheduled on a
> ScheduledExecutorService, and the main task, which runs in a separate
> ExecutorService. The trigger task is responsible only for executing the main
> task (perhaps after determining whether it is appropriate to do so at all)
> in the second ExecutorService, so it can get out of the way quickly.
>
> As has been pointed out here before, this kind of design raises its own
> issues. In particular, if you want cancellation of the trigger task to
> cascade to the main task, you need to keep state around in the trigger task.
>
>  I use the scheduled trigger task approach to provide a periodic background
> update of a large data structure. I don't want the update to run in the
> scheduled pool thread, because it could take a while and interfere with
> other scheduled activities. So I schedule a trigger task to execute the
> update in a cached thread pool.
>
> --tim
>
>
> On 7/6/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> >
>  I have a question regarding missed deadlines and java.util.Timer and
> java.util.concurrent.ScheduledThreadPoolExecutor.
>
> I'm wondering why there is no functionality for dealing with missed
> deadlines. Within a Timer you have one thread, if a job takes a long
> time, the other tasks are 'queued' untill the long-job has finished.
> When that job finishes, all other queued-jobs are run and I think this
> could lead to some serious issues. I can image you want to have some
>  control like:
> -execute it
> -drop it
> -do something else like sending a message.
>
> The same goes for the ScheduledThreadPoolExecutor. If a job takes a
> long time and a different job needs to be scheduled, a free thread is
> used (if one is available). If no free thread is available, you get
> the same problems as with the Timer.
>
> Another think I'm wondering about is the fixed size of the threadpool
> of the scheduledthreadpoolexecutor. I can image it would be usefull
> that a threadpool increases if there are no available threads to
> execute a scheduled task and if those 'extra' threads aren't used for
> some time, they could be discarded. Am I missing something?
>
> Peter
>  _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dcholmes at optusnet.com.au  Thu Jul  6 23:15:37 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 7 Jul 2006 13:15:37 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <aa067ea10607061929q345e2efbv6e12be4e75dd000f@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>

Dhanji R. Prasanna writes:
> Re auto-creation of pools, what is wrong with simply starting out with the
> max-intended size? After all there is no cost associated with idle threads
is
> there?

Sure there is - they use up OS threads, stack space etc. If they didn't we
wouldn't need thread pools we would just keep as many idle threads as we
wanted.

> I would think that allowing for no cap on max threads is a *very* bad
idea.
> Or am I missing something else...

Having an unbounded maximum number of threads can be a bad idea if you have
an unbounded potential arrival rate for tasks. If the task arrival rate is
limited then so is the thread creation rate.

This is why ThreadPoolExecutor has its three-phase policy:
 - create new threads until coreSize is reached
 - then add to queue until queue is full
 - then create new threads until max is reached

Given the ability to allow core threads to timeout if idle in Java 6, this
gives you a lot of control over how the pool can grow and shrink.

ScheduledThreadPoolExecutor sets up the ThreadPoolExecutor queueing and
threading behaviour is a very specific way: the queue is effectively
unbounded so only coreSize comes into play. Given that, there is less
control over how ScheduledThreadPoolExecutor behaves.

Another possible enhancement to TPE is to set a low-water mark on the number
of core threads, so you never drop below that many when idle timeout is
enabled. That effectively breaks the core-pool into two parts, without the
queue coming into the picture, and so provides further policy flexibility.
For ScheduledThreadPoolExecutor this wouldn't help as the queue is what
provides the "delay until" behaviour.

Cheers,
David Holmes


From dhanji at gmail.com  Thu Jul  6 23:45:07 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Fri, 7 Jul 2006 13:45:07 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
References: <aa067ea10607061929q345e2efbv6e12be4e75dd000f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10607062045w51fdbe4q64ec50c2ba2be30c@mail.gmail.com>

On 7/7/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> Dhanji R. Prasanna writes:
> > Re auto-creation of pools, what is wrong with simply starting out with
> the
> > max-intended size? After all there is no cost associated with idle
> threads
> is
> > there?
>
> Sure there is - they use up OS threads, stack space etc. If they didn't we
> wouldn't need thread pools we would just keep as many idle threads as we
> wanted.


Surely the cost of starting new threads (and killing excess idle ones) is
greater than the cost of keeping a reasonable number of idle threads around?
perhaps I should have rephrased "no cost" to "comparatively less cost".


> Having an unbounded maximum number of threads can be a bad idea if you
> have
> an unbounded potential arrival rate for tasks. If the task arrival rate is
> limited then so is the thread creation rate.


 Yea, I cant think of when an unbounded max # of threads is ever a good
idea? Even at OS-level semantics...

ScheduledThreadPoolExecutor sets up the ThreadPoolExecutor queueing and
> threading behaviour is a very specific way: the queue is effectively
> unbounded so only coreSize comes into play. Given that, there is less
> control over how ScheduledThreadPoolExecutor behaves.


This is how I read it STPE is a specialization of TPE. Peter made a fair
comment to me, that perhaps STPE should have embedded/delegated to TPE
rather than extended from it (to avoid contract confusion).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060707/eb7eda4b/attachment.html 

From dcholmes at optusnet.com.au  Thu Jul  6 23:49:58 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 7 Jul 2006 13:49:58 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <aa067ea10607062045w51fdbe4q64ec50c2ba2be30c@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEOAGPAA.dcholmes@optusnet.com.au>

> Surely the cost of starting new threads (and killing excess idle ones) is
greater
> than the cost of keeping a reasonable number of idle threads around?

It's the age-old trade-off: space versus time. If you can afford to have
idle threads around then keep them around. If not then you have take a
startup hit the next time you need one. Again the way TPE works, including
idle timeout, gives a great deal of control and so you can tune to match
your circumstances.

Cheers,
David


From dhanji at gmail.com  Thu Jul  6 23:56:46 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Fri, 7 Jul 2006 13:56:46 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <aa067ea10607062045w51fdbe4q64ec50c2ba2be30c@mail.gmail.com>
References: <aa067ea10607061929q345e2efbv6e12be4e75dd000f@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
	<aa067ea10607062045w51fdbe4q64ec50c2ba2be30c@mail.gmail.com>
Message-ID: <aa067ea10607062056i67e95194lb7f275da2d256506@mail.gmail.com>

Also does the issue of missed deadlines not also cross over to timing
semantics? Couldnt the gc cause threads to be pre-empted at any time (even
if there are plenty available in the pool) and create missed deadlines...

I guess what is bothering me is without RTSJ, is there any meaningful way to
address the deadlines issue?

On 7/7/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>
>
> On 7/7/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> > Dhanji R. Prasanna writes:
> > > Re auto-creation of pools, what is wrong with simply starting out with
> > the
> > > max-intended size? After all there is no cost associated with idle
> > threads
> > is
> > > there?
> >
> > Sure there is - they use up OS threads, stack space etc. If they didn't
> > we
> > wouldn't need thread pools we would just keep as many idle threads as we
> > wanted.
>
>
> Surely the cost of starting new threads (and killing excess idle ones) is
> greater than the cost of keeping a reasonable number of idle threads around?
>
> perhaps I should have rephrased "no cost" to "comparatively less cost".
>
>
> > Having an unbounded maximum number of threads can be a bad idea if you
> > have
> > an unbounded potential arrival rate for tasks. If the task arrival rate
> > is
> > limited then so is the thread creation rate.
>
>
>  Yea, I cant think of when an unbounded max # of threads is ever a good
> idea? Even at OS-level semantics...
>
> ScheduledThreadPoolExecutor sets up the ThreadPoolExecutor queueing and
> > threading behaviour is a very specific way: the queue is effectively
> > unbounded so only coreSize comes into play. Given that, there is less
> > control over how ScheduledThreadPoolExecutor behaves.
>
>
> This is how I read it STPE is a specialization of TPE. Peter made a fair
> comment to me, that perhaps STPE should have embedded/delegated to TPE
> rather than extended from it (to avoid contract confusion).
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060707/a651afb8/attachment.html 

From dcholmes at optusnet.com.au  Fri Jul  7 00:02:25 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 7 Jul 2006 14:02:25 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <aa067ea10607062056i67e95194lb7f275da2d256506@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEOBGPAA.dcholmes@optusnet.com.au>

This is all "best effort" stuff with no pretense at real-time. That means
running late should at worst yield no value, not incur damage. If your needs
are more stringent then that, then you are working with the wrong platform.
Scheduling depends on things both inside and out of the VM.

But I think what was being looked for here was just a way to detect that
something ran much later than expected and so skip it.

Cheers,
David
  -----Original Message-----
  From: Dhanji R. Prasanna [mailto:dhanji at gmail.com]
  Sent: Friday, 7 July 2006 1:57 PM
  To: dholmes at ieee.org
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] missed deadlines.


  Also does the issue of missed deadlines not also cross over to timing
semantics? Couldnt the gc cause threads to be pre-empted at any time (even
if there are plenty available in the pool) and create missed deadlines...

  I guess what is bothering me is without RTSJ, is there any meaningful way
to address the deadlines issue?


  On 7/7/06, Dhanji R. Prasanna < dhanji at gmail.com> wrote:



    On 7/7/06, David Holmes <dcholmes at optusnet.com.au> wrote:
      Dhanji R. Prasanna writes:
      > Re auto-creation of pools, what is wrong with simply starting out
with the
      > max-intended size? After all there is no cost associated with idle
threads
      is
      > there?

      Sure there is - they use up OS threads, stack space etc. If they
didn't we
      wouldn't need thread pools we would just keep as many idle threads as
we
      wanted.

    Surely the cost of starting new threads (and killing excess idle ones)
is greater than the cost of keeping a reasonable number of idle threads
around?
    perhaps I should have rephrased "no cost" to "comparatively less cost".




      Having an unbounded maximum number of threads can be a bad idea if you
have
      an unbounded potential arrival rate for tasks. If the task arrival
rate is
      limited then so is the thread creation rate.

     Yea, I cant think of when an unbounded max # of threads is ever a good
idea? Even at OS-level semantics...



      ScheduledThreadPoolExecutor sets up the ThreadPoolExecutor queueing
and
      threading behaviour is a very specific way: the queue is effectively
      unbounded so only coreSize comes into play. Given that, there is less
      control over how ScheduledThreadPoolExecutor behaves.

    This is how I read it STPE is a specialization of TPE. Peter made a fair
comment to me, that perhaps STPE should have embedded/delegated to TPE
rather than extended from it (to avoid contract confusion).




-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060707/2d88850b/attachment.html 

From mailinglist.taras.tielkes at gmail.com  Fri Jul  7 12:24:15 2006
From: mailinglist.taras.tielkes at gmail.com (Taras Tielkes)
Date: Fri, 07 Jul 2006 18:24:15 +0200
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEENKGPAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCEENKGPAA.dcholmes@optusnet.com.au>
Message-ID: <44AE8AAF.3090704@gmail.com>

David Holmes wrote:
>> Within a Timer you have one thread, if a job takes a long
>> time, the other tasks are 'queued' untill the long-job has finished.
>> When that job finishes, all other queued-jobs are run and I think this
>> could lead to some serious issues. I can image you want to have some
>> control like:
>> -execute it
>> -drop it
>> -do something else like sending a message.
>>     
>
> You could have various "I'm late" policies but then you'd have to specify
> the policy for each task (I don't thing a per-executor policy works well for
> this situation). And there are so many things you could do if late. Better
> for the task to make such decisions in my view.
>   
Some aspects are a good match for an executor, I think: execute / drop 
strategy seems one to me. Others, as mentioned in my other reply, seem 
to be in better hands of the pool user.
The request for distinct interfaces for various extension points (that I 
read in Peters previous post - the 'killed threads' one) is something 
that I agree with.

[off topic begins - not jsr166 related - more a reply to Peter than David]
There seems to be almost a guarantee for Policy/Strategy support in most 
of the Spring framework: pure interface, partial base implementations 
providing useful defaults, and a default instance in the places that 
need it all this - in contrast with overriding methods. This is good, 
for many reasons.

Now, a good idea would be to extend this flexibility to thread context 
creation in the framework in general: 
Global/ThreadLocal/InheritableThreadLocal, and the new 
ActuallyWorksWithGCThreadLocal mentioned by Doug some days ago. This is 
not because I want the new deterministic threadlocal garbage collection 
option, but because InheritableThreadLocal is hardcoded in 2 places in 
Spring: the locale holder, and the new scoping support.

I find this to cause uncollectable reference leaks, in most applications 
of fair complexity, on all relevant platforms (ibm, bea, sun).

The reason (as stated in the thread mentioned above) is simple: there 
are two groups of components: those that create InheritableThreadLocals, 
and those that create threads. The mix of these two usually results in 
references dangling off live threads long after the relevant ClassLoader 
would have been released. A minimal example would be:
--------------------------------------
public class ImageController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, 
HttpServletResponse response) throws Exception {

        BufferedImage image = new BufferedImage(20, 20, 
BufferedImage.TYPE_INT_RGB);
        Graphics2D g = image.createGraphics();
        response.setContentType("image/png");
        OutputStream out = response.getOutputStream();
        ImageIO.write(image, "png", out);
        out.close(); out.flush(); g.dispose();

        return null;
    }
}
--------------------------------------
There isn't much to see in the code, but this controller will activate 
the Java 2D subsystem, which happens to include starting the 
sun.java2d.Disposer thread, which will only exit at JVM shutdown (this 
can be verified with a JVMTI agent). See what I mean by saying that 
InheritableThreadLocal creators can't fathom all thread creation sites 
above their stack? I'll bet good money I can find 3 other leaks 
possibilities of this type caused by Spring in the Sun JVM alone 
(although I also found these two spring ITLs in a different place).

Now, next for a related story - in the Acegi Security subframework (is 
there such a thing?):
http://opensource.atlassian.com/projects/spring/browse/SEC-152

In the beginning, Acegi used a regular ThreadLocal for auth context. 
Then developers using JFC or RMI requested transparent propagation to 
child threads, resulting in a patch to use InheritableThreadLocal. Some 
IBM 1.3 users reported bugs in their JVM implementation, causing the 
migration back to a regular ThreadLocal. This could, of course, not 
please everybody, so a more configurable solution was devised: let the 
framework user choose an implementation of a Strategy interface for 
'thread bound context' creation:
http://www.acegisecurity.org/multiproject/acegi-security/apidocs/org/acegisecurity/context/SecurityContextHolderStrategy.html

Now this is a good solution, but not perfect: the modus of configuration 
is not very flexible, and it's Acegi-specific.
I propose an extension to spring itself, exposing a strategy/polity 
extension point for child frameworks like Acegi, infrastructure like the 
Spring MVC locale support, the new Scoped AOP, and (most important of 
all) RMI/Swing/etc developers seeking a problem-specific solution.

I think the place for such support would be somewhere on the 
ApplicationContext itself, making (for instance) configuration in 
web.xml possible.

Here's the (just submitted) JIRA issue:
http://opensource.atlassian.com/projects/spring/browse/SPR-2258

Regards,
-tt

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060707/5f8d2959/attachment.html 

From jean.morissette at gmail.com  Sat Jul  8 14:00:31 2006
From: jean.morissette at gmail.com (Jean Morissette)
Date: Sat, 8 Jul 2006 14:00:31 -0400
Subject: [concurrency-interest] ThreadPoolTask
Message-ID: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>

Hi,

I need to create a pool of threads that run only one thead-safe task
forever.  The task, which is a Runnable, must be passed in the
constructor.  Also, the thread pool size should be resizable and have
some lifecycling capabilities.

I was thinking to create it on top of ThreadPoolExecutor, by setting
corePoolSize to zero and by using a custom queue that is always full
of the same task instance. So, by adjusting maxPoolSize, we can set
the number of threads executing the task. Here are some code to show
what I mean.

public class ThreadPoolTask {

	private ThreadPoolExecutor executor;

	public ThreadPoolTask(Runnable task) {
		this.executor = new ThreadPoolExecutor(0, 1, 1, TimeUnit.SECONDS,
new FullQueue(task));
	}

	public void setPoolSize(int size) {
		executor.setMaximumPoolSize(size);
	}

	public int getPoolSize() {
		return executor.getMaximumPoolSize();
	}

	private static class FullQueue implements BlockingQueue {
		// ...
	}
}

What do you think?  Is there a more elegant way to implement my requirements?

Thanks,
Jean

From alarmnummer at gmail.com  Sat Jul  8 15:02:00 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sat, 8 Jul 2006 21:02:00 +0200
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
Message-ID: <1466c1d60607081202t31100f74w74708e99b0e34d3c@mail.gmail.com>

Just for this purpose I created the Repeater (interface) and the
ThreadPoolRepeater (one of the implementations). The repeater keeps
repeating a single task over and over untill a new task is set or the
task is set to null. The ThreadPoolRepeater maintains a pool of
threads that keep repeating it. The pool can be increased or
decreased. And the ThreadPoolRepeater can be strict or non strict:
a strict repeater only has a single runnable that is run bij threads.
If a new runnable is set, it block untill all threads are finished
running the runnable.
The non strict repeater allows a new runnable to be set even while
other threads are still working on the old runnable.
And the setting of a new task can also be controller by providing
timeout pararameters (you don't want to block forever in some cases).

And one of the things I'm thinking about is making it easy to work
with delays/periods for those threads. And providing some kind of
context instead of using a threadlocal where threads can store state..

So I certainly think there are better ways to realise it :) Btw: this
library is going to be opensource in a few months,



On 7/8/06, Jean Morissette <jean.morissette at gmail.com> wrote:
> Hi,
>
> I need to create a pool of threads that run only one thead-safe task
> forever.  The task, which is a Runnable, must be passed in the
> constructor.  Also, the thread pool size should be resizable and have
> some lifecycling capabilities.
>
> I was thinking to create it on top of ThreadPoolExecutor, by setting
> corePoolSize to zero and by using a custom queue that is always full
> of the same task instance. So, by adjusting maxPoolSize, we can set
> the number of threads executing the task. Here are some code to show
> what I mean.
>
> public class ThreadPoolTask {
>
>         private ThreadPoolExecutor executor;
>
>         public ThreadPoolTask(Runnable task) {
>                 this.executor = new ThreadPoolExecutor(0, 1, 1, TimeUnit.SECONDS,
> new FullQueue(task));
>         }
>
>         public void setPoolSize(int size) {
>                 executor.setMaximumPoolSize(size);
>         }
>
>         public int getPoolSize() {
>                 return executor.getMaximumPoolSize();
>         }
>
>         private static class FullQueue implements BlockingQueue {
>                 // ...
>         }
> }
>
> What do you think?  Is there a more elegant way to implement my requirements?
>
> Thanks,
> Jean
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dcholmes at optusnet.com.au  Sat Jul  8 19:41:32 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun, 9 Jul 2006 09:41:32 +1000
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>

I must be missing something. If you want to submit the same task multiple
times then submit the same task multiple times. If you want a task to repeat
then either code it so it repeats, or resubmits itself or use a periodic
task if there is a repeat interval.

I think your always full queue is relying on current implementation that
favours passing a queued task when creating a new thread above coreSize.
This behaviour has been changed for Mustang.

Of course once a thread has been created and given its initial task in some
way then that thread will take from the queue and forever repeat the task
handed out by the queue. The trick here is to get the threads started.

Your requirement that the task must be passed in the constructor (presumably
the pool constructor) means you need to prime the pool somehow to start the
threads and have them take from the queue. I don't think you can do that
without performing the required number of execute() operations.

Further, I just spotted an apparent bug if the coreSize is zero.

But why set core to zero anyway? How do you expect to define how many
threads should be processing this task? And how would the pool ever shrink
as no thread would ever be idle. Soundsl like using a queue that always
returns your task, and pre-starting core threads would do what you want.

Cheers,
David Holmes


> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jean
> Morissette
> Sent: Sunday, 9 July 2006 4:01 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] ThreadPoolTask
>
>
> Hi,
>
> I need to create a pool of threads that run only one thead-safe task
> forever.  The task, which is a Runnable, must be passed in the
> constructor.  Also, the thread pool size should be resizable and have
> some lifecycling capabilities.
>
> I was thinking to create it on top of ThreadPoolExecutor, by setting
> corePoolSize to zero and by using a custom queue that is always full
> of the same task instance. So, by adjusting maxPoolSize, we can set
> the number of threads executing the task. Here are some code to show
> what I mean.
>
> public class ThreadPoolTask {
>
> 	private ThreadPoolExecutor executor;
>
> 	public ThreadPoolTask(Runnable task) {
> 		this.executor = new ThreadPoolExecutor(0, 1, 1,
> TimeUnit.SECONDS,
> new FullQueue(task));
> 	}
>
> 	public void setPoolSize(int size) {
> 		executor.setMaximumPoolSize(size);
> 	}
>
> 	public int getPoolSize() {
> 		return executor.getMaximumPoolSize();
> 	}
>
> 	private static class FullQueue implements BlockingQueue {
> 		// ...
> 	}
> }
>
> What do you think?  Is there a more elegant way to implement my
> requirements?
>
> Thanks,
> Jean
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dcholmes at optusnet.com.au  Sat Jul  8 19:46:23 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun, 9 Jul 2006 09:46:23 +1000
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEOMGPAA.dcholmes@optusnet.com.au>

I wrote:
> Further, I just spotted an apparent bug if the coreSize is zero.

Ignore that. No bug.

David

From alarmnummer at gmail.com  Sun Jul  9 04:39:28 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sun, 9 Jul 2006 10:39:28 +0200
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>

On 7/9/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> I must be missing something. If you want to submit the same task multiple
> times then submit the same task multiple times. If you want a task to repeat
> then either code it so it repeats, or resubmits itself or use a periodic
> task if there is a repeat interval.
The problem with resubmitting a task is that you can't increase the
size of the pool.
The problem with a tasks that loops is that the executing thread in
the executor is 'lost' forever.

The executor is not made for continuous (multithreaded) execution of a
single task and that is the reason why I made the Repeater.

>
> I think your always full queue is relying on current implementation that
> favours passing a queued task when creating a new thread above coreSize.
> This behaviour has been changed for Mustang.
>
> Of course once a thread has been created and given its initial task in some
> way then that thread will take from the queue and forever repeat the task
> handed out by the queue. The trick here is to get the threads started.
>
> Your requirement that the task must be passed in the constructor (presumably
> the pool constructor) means you need to prime the pool somehow to start the
> threads and have them take from the queue. I don't think you can do that
> without performing the required number of execute() operations.
>
> Further, I just spotted an apparent bug if the coreSize is zero.
>
> But why set core to zero anyway? How do you expect to define how many
> threads should be processing this task? And how would the pool ever shrink
> as no thread would ever be idle. Soundsl like using a queue that always
> returns your task, and pre-starting core threads would do what you want.
>
> Cheers,
> David Holmes
>
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jean
> > Morissette
> > Sent: Sunday, 9 July 2006 4:01 AM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] ThreadPoolTask
> >
> >
> > Hi,
> >
> > I need to create a pool of threads that run only one thead-safe task
> > forever.  The task, which is a Runnable, must be passed in the
> > constructor.  Also, the thread pool size should be resizable and have
> > some lifecycling capabilities.
> >
> > I was thinking to create it on top of ThreadPoolExecutor, by setting
> > corePoolSize to zero and by using a custom queue that is always full
> > of the same task instance. So, by adjusting maxPoolSize, we can set
> > the number of threads executing the task. Here are some code to show
> > what I mean.
> >
> > public class ThreadPoolTask {
> >
> >       private ThreadPoolExecutor executor;
> >
> >       public ThreadPoolTask(Runnable task) {
> >               this.executor = new ThreadPoolExecutor(0, 1, 1,
> > TimeUnit.SECONDS,
> > new FullQueue(task));
> >       }
> >
> >       public void setPoolSize(int size) {
> >               executor.setMaximumPoolSize(size);
> >       }
> >
> >       public int getPoolSize() {
> >               return executor.getMaximumPoolSize();
> >       }
> >
> >       private static class FullQueue implements BlockingQueue {
> >               // ...
> >       }
> > }
> >
> > What do you think?  Is there a more elegant way to implement my
> > requirements?
> >
> > Thanks,
> > Jean
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From dhanji at gmail.com  Sun Jul  9 06:32:14 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sun, 9 Jul 2006 20:32:14 +1000
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>
Message-ID: <aa067ea10607090332p7b796098he670518bb95a5c79@mail.gmail.com>

On 7/9/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
>
> On 7/9/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > I must be missing something. If you want to submit the same task
> multiple
> > times then submit the same task multiple times. If you want a task to
> repeat
> > then either code it so it repeats, or resubmits itself or use a periodic
> > task if there is a repeat interval.
> The problem with resubmitting a task is that you can't increase the
> size of the pool.


Sure you can. setCorePoolSize() and setMaximumPoolSize() can be called any
time after construction, along with prestartCoreThread() to force the pool
to change size dynamically.

David's suggestion makes a lot of sense; simply let your queue feed the same
task over and over.

I would also say that setting a starting corePoolSize of 0 is pointless, and
probably confusing to a maintainer. The ThreadPoolExecutor does not create
the first thread until it is needed anyway, so you have not gained anything
with a starting size of 0. If you want your executor to drop to 0 threads at
a mature point in its lifecycle, just release it to the gc and create a new
one when needed. Otherwise I dont see the point of (effectively) using
ThreadPoolExecutor as a state machine for your app.

The problem with a tasks that loops is that the executing thread in
> the executor is 'lost' forever.


But there is only ever one task that he wants to repeat, if I understood
correctly, so what is the problem with running it in the same thread
forever?

Repeat = sequential, resubmit/multiple submit = concurrent. Either way the
problem does not require a special delegating executor (unless this is
simply an abstraction facade for your app).
Maybe Im not seeing the issue...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060709/df575514/attachment.html 

From dhanji at gmail.com  Sun Jul  9 06:38:32 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sun, 9 Jul 2006 20:38:32 +1000
Subject: [concurrency-interest] ThreadPoolTask
In-Reply-To: <aa067ea10607090332p7b796098he670518bb95a5c79@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>
	<aa067ea10607090332p7b796098he670518bb95a5c79@mail.gmail.com>
Message-ID: <aa067ea10607090338o473ce0d3w876d25fbcbac6729@mail.gmail.com>

On 7/9/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

>  starting size of 0. If you want your executor to drop to 0 threads at a
> mature point in its lifecycle, just release it to the gc and create a new
> one when needed.
>

making sure to shutdown() the executor first of course...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060709/ee912258/attachment.html 

From alarmnummer at gmail.com  Sun Jul  9 06:49:52 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sun, 9 Jul 2006 12:49:52 +0200
Subject: [concurrency-interest] Fwd:  ThreadPoolTask
In-Reply-To: <1466c1d60607090344k671deaf2nb50f19461f252a8e@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>
	<aa067ea10607090332p7b796098he670518bb95a5c79@mail.gmail.com>
	<1466c1d60607090344k671deaf2nb50f19461f252a8e@mail.gmail.com>
Message-ID: <1466c1d60607090349tdf7e603ob67db6cbe2084751@mail.gmail.com>

---------- Forwarded message ----------
From: Peter Veentjer <alarmnummer at gmail.com>
Date: Jul 9, 2006 12:44 PM
Subject: Re: [concurrency-interest] ThreadPoolTask
To: "Dhanji R. Prasanna" <dhanji at gmail.com>


On 7/9/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>
> On 7/9/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > On 7/9/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > I must be missing something. If you want to submit the same task
> multiple
> > > times then submit the same task multiple times. If you want a task to
> repeat
> > > then either code it so it repeats, or resubmits itself or use a periodic
> > > task if there is a repeat interval.
> > The problem with resubmitting a task is that you can't increase the
> > size of the pool.
>
>
> Sure you can. setCorePoolSize() and setMaximumPoolSize() can be called any
> time after construction, along with prestartCoreThread() to force the pool
> to change size dynamically.
>
> David's suggestion makes a lot of sense; simply let your queue feed the same
> task over and over.
If the queues returns the same value over and over, Davids idea works.
But if a task is responsible for resubmitting itself, you need to have
at least as many tasks as there are threads and this is complex. That
is why increasing the poolsize with this approach has no meaning
because there are no tasks the extra threads can execute.

>
> I would also say that setting a starting corePoolSize of 0 is pointless, and
> probably confusing to a maintainer. The ThreadPoolExecutor does not create
> the first thread until it is needed anyway, so you have not gained anything
> with a starting size of 0. If you want your executor to drop to 0 threads at
> a mature point in its lifecycle, just release it to the gc and create a new
> one when needed. Otherwise I dont see the point of (effectively) using
> ThreadPoolExecutor as a state machine for your app.
>
> > The problem with a tasks that loops is that the executing thread in
> > the executor is 'lost' forever.
>
>
> But there is only ever one task that he wants to repeat, if I understood
> correctly, so what is the problem with running it in the same thread
> forever?
What about shutting down. I want to shutdown my thread-engines in a
controlled and predicatable manner and with a 'while(true){....}' loop
this isn't possible. Ofcourse you can add some kind of flag, but this
places an extra responsibility with the task. So a runnable that loops
for ever imho is a bad approach especially if there are better
alternatives like the Repeater.

The Repeater uses a WaitableReference: this is a synchronisation
structure where a threads blocks if it wants to retrieve a reference
and there is none. And if there is one. the reference is returned. A
queue that keeps returning some value (after a value has been added)
or block if none is available, has the same behaviour.

So in essence they are not that different. But with a Repeater I have
some control I don't have with Executors like preventing concurrent
execution of different runnables.

>
> Repeat = sequential, resubmit/multiple submit = concurrent. Either way the
> problem does not require a special delegating executor (unless this is
> simply an abstraction facade for your app).
> Maybe Im not seeing the issue...
>

From moran at gigaspaces.com  Sun Jul  9 09:15:14 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Sun, 09 Jul 2006 15:15:14 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport non-matching
	signature
In-Reply-To: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
Message-ID: <44B10162.3090409@gigaspaces.com>

In java.util.concurrent.locks.ReentrantReadWriteLock readLock() and 
writeLock() return Locks as follows:

    public ReentrantReadWriteLock.WriteLock writeLock() { return 
writerLock; }
    public ReentrantReadWriteLock.ReadLock  readLock()  { return 
readerLock; }

While, in 
edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock 
these are defined:

    public Lock writeLock() { return writerLock_; }
    public Lock readLock()  { return readerLock_; }

Although ReentrantReadWriteLock.ReadLock/WriteLock are Lock-s this 
incompatibility in signatures causes
problems when using Retrotranslator.

Any comments?





From moran at gigaspaces.com  Sun Jul  9 10:16:36 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Sun, 09 Jul 2006 16:16:36 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport non-matching
	signatures
Message-ID: <44B10FC4.2060401@gigaspaces.com>

In java.util.concurrent.locks.ReentrantReadWriteLock readLock() and 
writeLock() return Locks as follows:

    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }

While, in 
edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock 
these are defined:

    public Lock writeLock() { return writerLock_; }
    public Lock readLock()  { return readerLock_; }

Although ReentrantReadWriteLock.ReadLock/WriteLock are Lock-s this 
incompatibility in signatures causes problems when using Retrotranslator.

Any comments?

-- 
Moran


From dawidk at mathcs.emory.edu  Sun Jul  9 11:17:27 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sun, 09 Jul 2006 11:17:27 -0400
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matchingsignature
In-Reply-To: <44B10162.3090409@gigaspaces.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<44B10162.3090409@gigaspaces.com>
Message-ID: <44B11E07.8090405@mathcs.emory.edu>

Moran Avigdor wrote:
> In java.util.concurrent.locks.ReentrantReadWriteLock readLock() and 
> writeLock() return Locks as follows:
>
>     public ReentrantReadWriteLock.WriteLock writeLock() { return 
> writerLock; }
>     public ReentrantReadWriteLock.ReadLock  readLock()  { return 
> readerLock; }
>
> While, in 
> edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock 
> these are defined:
>
>     public Lock writeLock() { return writerLock_; }
>     public Lock readLock()  { return readerLock_; }
>
> Although ReentrantReadWriteLock.ReadLock/WriteLock are Lock-s this 
> incompatibility in signatures causes
> problems when using Retrotranslator.
>
> Any comments?
>
>   

ReentrantReadWriteLock implements ReadWriteLock interface, defined like 
this:

public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}

In Java 5.0, it is possible to narrow the return type in the 
implementation class to ReadLock and WriteLock, respectively. 
Unfortunately, the same isn't possible in Java 1.4.

Regards,
Dawid


From moran at gigaspaces.com  Sun Jul  9 12:31:04 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Sun, 09 Jul 2006 18:31:04 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matchingsignature
In-Reply-To: <44B11E07.8090405@mathcs.emory.edu>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<44B10162.3090409@gigaspaces.com>
	<44B11E07.8090405@mathcs.emory.edu>
Message-ID: <44B12F48.8050205@gigaspaces.com>

Dawid,

You can narrow the backport implementation to return ReadLock and 
WriteLock respectively,
instead of returning the Lock interface. This will then have the same 
signature as Java 5.0

Moran



Dawid Kurzyniec wrote:
> Moran Avigdor wrote:
>> In java.util.concurrent.locks.ReentrantReadWriteLock readLock() and 
>> writeLock() return Locks as follows:
>>
>>     public ReentrantReadWriteLock.WriteLock writeLock() { return 
>> writerLock; }
>>     public ReentrantReadWriteLock.ReadLock  readLock()  { return 
>> readerLock; }
>>
>> While, in 
>> edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock 
>> these are defined:
>>
>>     public Lock writeLock() { return writerLock_; }
>>     public Lock readLock()  { return readerLock_; }
>>
>> Although ReentrantReadWriteLock.ReadLock/WriteLock are Lock-s this 
>> incompatibility in signatures causes
>> problems when using Retrotranslator.
>>
>> Any comments?
>>
>>   
>
> ReentrantReadWriteLock implements ReadWriteLock interface, defined 
> like this:
>
> public interface ReadWriteLock {
>    Lock readLock();
>    Lock writeLock();
> }
>
> In Java 5.0, it is possible to narrow the return type in the 
> implementation class to ReadLock and WriteLock, respectively. 
> Unfortunately, the same isn't possible in Java 1.4.
>
> Regards,
> Dawid
>
>

From dawidk at mathcs.emory.edu  Sun Jul  9 11:50:19 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sun, 09 Jul 2006 11:50:19 -0400
Subject: [concurrency-interest] ReentrantReadWriteLock
	backportnon-matchingsignature
In-Reply-To: <44B12F48.8050205@gigaspaces.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com><44	B10162.3090409@gigaspaces.com><44B11E07.8090405@mathcs.emory.edu>
	<44B12F48.8050205@gigaspaces.com>
Message-ID: <44B125BB.4090206@mathcs.emory.edu>

Moran Avigdor wrote:
> Dawid,
>
> You can narrow the backport implementation to return ReadLock and 
> WriteLock respectively,
> instead of returning the Lock interface. This will then have the same 
> signature as Java 5.0
>
>   

No, unfortunately, this won't compile under Java 1.4 due to 
"incompatible return types". The ability to narrow return types in 
subclasses and implementation classes was added alongside generics in 
Java 5.0.

Regards,
Dawid


From holger at wizards.de  Sun Jul  9 12:51:01 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Sun, 09 Jul 2006 18:51:01 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport
 non-matching signature
In-Reply-To: <44B125BB.4090206@mathcs.emory.edu>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com><44	B10162.3090409@gigaspaces.com><44B11E07.8090405@mathcs.emory.edu>	<44B12F48.8050205@gigaspaces.com>
	<44B125BB.4090206@mathcs.emory.edu>
Message-ID: <44B133F5.9070607@wizards.de>

Dawid Kurzyniec wrote:
> Moran Avigdor wrote:
>> You can narrow the backport implementation to return ReadLock and 
>> WriteLock respectively,
>> instead of returning the Lock interface. This will then have the same 
>> signature as Java 5.0
> 
> No, unfortunately, this won't compile under Java 1.4 due to 
> "incompatible return types". The ability to narrow return types in 
> subclasses and implementation classes was added alongside generics in 
> Java 5.0.

Maybe I'm missing something but why does the u.c ReentrantReadWriteLock
return the static inner class instead of the Read/WriteLock interfaces in
the first place?

The incompatibility is a serious problem for everybody using
retrotranslator or -weaver, and will likely just force people to continue
using the backport. Considering the number of showstopper fixes in Mustang
that are not backported to 1.5.x for (IMHO) no good reason that might
actually be the best route for many projects.

-h


From jean.morissette at gmail.com  Sun Jul  9 14:57:19 2006
From: jean.morissette at gmail.com (Jean Morissette)
Date: Sun, 9 Jul 2006 14:57:19 -0400
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607090349tdf7e603ob67db6cbe2084751@mail.gmail.com>
References: <97ad10900607081100x12105429j89965b6209843562@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCGEOMGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607090139i1bdc3948y79302b32e85e7752@mail.gmail.com>
	<aa067ea10607090332p7b796098he670518bb95a5c79@mail.gmail.com>
	<1466c1d60607090344k671deaf2nb50f19461f252a8e@mail.gmail.com>
	<1466c1d60607090349tdf7e603ob67db6cbe2084751@mail.gmail.com>
Message-ID: <97ad10900607091157m3fe0c9b0y3f7798faafd055a1@mail.gmail.com>

As Peter has explained, there are some issues with what David has suggested.

My actual solution use a CopiesQueue consisting of n copies of the
specified task.  This queue is memory efficient and very performant
since it contains only a single reference to the task and use an
AtomicInteger to store the size.  Also, I use a Runnable decorator
that resubmit the task in the queue, so the task don't need to be
aware of the ThreadPool/Executor.

So, by setting the size of the queue to Integer.MAX_VALUE, I can
adjust the size of the pool just calling setCorePoolSize and
setMaxPoolSize with the same value.  Here is the code.  What do you
think?


public class ThreadPoolTask {

	private ThreadPoolExecutor executor;
	private Runnable task;

	public ThreadPoolTask(Runnable task) {
		this.task = new RepeatableTask(task);
		this.executor = new ThreadPoolExecutor(1, 1, 60, TimeUnit.SECONDS,
new CopiesQueue(Integer.MAX_VALUE, this.task));
	}

	public void setPoolSize(int size) {
		executor.setCorePoolSize(size);
		executor.setMaximumPoolSize(size);
	}

	public int getPoolSize() {
		return executor.getCorePoolSize();
	}

	public void stop() {
		executor.shutdown();
	}

	public void stopNow() {
		executor.shutdownNow();
	}

	public void awaitTermination(long timeout, TimeUnit unit) throws
InterruptedException {
		executor.awaitTermination(timeout, unit);
	}

	private class RepeatableTask implements Runnable {

		Runnable delegate;

		public RepeatableTask(Runnable delegate) {
			this.delegate = delegate;
		}

		public void run() {
			delegate.run();
			executor.getQueue().offer(this);
		}
	}

	private static class CopiesQueue extends AbstractQueue implements
BlockingQueue {

		AtomicInteger size;
		Object element;

		public CopiesQueue(int initialSize, Object element) {
			size = new AtomicInteger(initialSize);
			this.element = element;
		}

		public boolean offer(Object o) {
			size.incrementAndGet();
			return true;
		}

		public boolean offer(Object o, long timeout, TimeUnit unit) throws
InterruptedException {
			size.incrementAndGet();
			return true;
		}

		public Object poll(long timeout, TimeUnit unit) throws InterruptedException {
			size.decrementAndGet();
			return element;
		}

		public Object take() throws InterruptedException {
			size.decrementAndGet();
			return element;
		}

		public void put(Object o) throws InterruptedException {
			size.incrementAndGet();
		}

		public int remainingCapacity() {
			return Integer.MAX_VALUE;
		}

		public int drainTo(Collection c) {
			List copies = Collections.nCopies(size.getAndSet(0), element);
			c.addAll(copies);
			return copies.size();
		}

		public int drainTo(Collection c, int maxElements) {
			int oldSize;
			int newSize;
			boolean success;
			do {
				oldSize = this.size.get();
				newSize = Math.max(oldSize - maxElements, 0);
				success = size.weakCompareAndSet(oldSize, newSize);
			} while (!success);
			return oldSize - newSize;
		}

		public Object poll() {
			size.decrementAndGet();
			return element;
		}

		public Object peek() {
			return element;
		}

		public Iterator iterator() {
			return Collections.nCopies(size.get(), element).iterator();
		}

		public int size() {
			return size.get();
		}
	}


}

From dcholmes at optusnet.com.au  Sun Jul  9 22:01:34 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 12:01:34 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matching signature
In-Reply-To: <44B133F5.9070607@wizards.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>

Holger Hoffstatte writes:
> Maybe I'm missing something but why does the u.c ReentrantReadWriteLock
> return the static inner class instead of the Read/WriteLock interfaces in
> the first place?

I thought it was because the implementation classes had additional
house-keeping methods that are not part of the Lock interface. But that
isn't actually the case. The idea being that you could just type those
classes directly without having to do a cast.

> The incompatibility is a serious problem for everybody using
> retrotranslator or -weaver, and will likely just force people to continue
> using the backport.

I'm not familiar with those tools - what do they do? And why does this cause
them a problem? Do they try to match j.u.c signatures to those found in the
backport?

Cheers,
David Holmes


From dcholmes at optusnet.com.au  Mon Jul 10 00:14:03 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 14:14:03 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <97ad10900607091157m3fe0c9b0y3f7798faafd055a1@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEPDGPAA.dcholmes@optusnet.com.au>

Jean Morissette wrote:
> As Peter has explained, there are some issues with what David has
> suggested.

That may well be, but so far I don't have a complete view of either all your
requirements or all of Peter's, so it is hard to offer suggestions.

Cheers,
David


From dcholmes at optusnet.com.au  Mon Jul 10 00:17:09 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 14:17:09 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <97ad10900607091157m3fe0c9b0y3f7798faafd055a1@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPDGPAA.dcholmes@optusnet.com.au>

Jean Morissette writes:
> 	private static class CopiesQueue extends AbstractQueue implements
> BlockingQueue {
>
> 		AtomicInteger size;
> 		Object element;
>
> 		public CopiesQueue(int initialSize, Object element) {
> 			size = new AtomicInteger(initialSize);
> 			this.element = element;
> 		}
>
> 		public boolean offer(Object o) {
> 			size.incrementAndGet();
> 			return true;
> 		}

...

I don't get it. Other than going up and down, size is never used to
influence any control flow. ???

David


From dhanji at gmail.com  Mon Jul 10 00:50:32 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 10 Jul 2006 14:50:32 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPDGPAA.dcholmes@optusnet.com.au>
References: <97ad10900607091157m3fe0c9b0y3f7798faafd055a1@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEPDGPAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10607092150t6568161dt6362522957e6b3af@mail.gmail.com>

>From what I gathered from Peter, the specific use of a ThreadPool
"Repeating" executor was that increasing the corePoolSize would
automagically increase the number of tasks being executed ("repeated"). This
is semantically quite different from what a TPE does or is meant to do and
perhaps that is where the confusion has arisen.

Repeating tasks (sequentially requeing them) was not the direct impedence as
that can easily be solved with the task resubmitting itself or a specialized
impl of a blocking queue which keeps queuing the same task instance.

This is what I gathered from the aether... =)

On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
>
> That may well be, but so far I don't have a complete view of either all
> your
> requirements or all of Peter's, so it is hard to offer suggestions.
>
> Cheers,
> David
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060710/575d567a/attachment.html 

From alarmnummer at gmail.com  Mon Jul 10 01:14:59 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 07:14:59 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <aa067ea10607092150t6568161dt6362522957e6b3af@mail.gmail.com>
References: <97ad10900607091157m3fe0c9b0y3f7798faafd055a1@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCCEPDGPAA.dcholmes@optusnet.com.au>
	<aa067ea10607092150t6568161dt6362522957e6b3af@mail.gmail.com>
Message-ID: <1466c1d60607092214h2dc3cc74x4311aa7a29bf936d@mail.gmail.com>

A Repeater needs only a single runnable that it keeps repeating. No
strange things like resubmitting tasks or strange 'copyqueues'.

I'm still working on the code, so it could contain bugs.

---------------------------------------------------------------------

package org.jph.concurrent.repeater;

import org.jph.concurrent.LockUtil;
import org.jph.concurrent.StdThreadFactory;
import org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;

import java.util.HashSet;
import java.util.Iterator;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * The ThreadPoolRepeaterService is the default implementation of the
 * {@link RepeaterService}. It uses a threadpool.
 *
 * @author Peter Veentjer.
 */
public final class ThreadPoolRepeaterService implements RepeaterService {

	private final static Runnable DUMMY_TASK = new DummyTask();


	//number of threads.
	//this field has to be volatile because it is shared between different
	//threads.
	private volatile int _threadCount;

	//factory for new threads
	private final ThreadFactory _threadFactory;
	//Set containing all worker threads
	private final HashSet<Worker> _workers = new HashSet<Worker>();

	//Contains the current number of threads.
	private final AtomicInteger _currentThreadCount = new AtomicInteger(0);

	//Lifecycle state
	private volatile RepeaterServiceState _runstate =
RepeaterServiceState.NOT_STARTED;

	private final RelaxedAwaitableReference<Runnable> _awaitableTask =
new RelaxedAwaitableReference<Runnable>();

	private final Lock _mainLock = new ReentrantLock();

	/**
	 * Creates a StdThreadFactory with a single thread, a StdThreadFactory and
	 * no task to execute.
	 */
	public ThreadPoolRepeaterService() {
		this(1);
	}

	/**
	 * Creates a ThreadPoolRepeaterService with the given initial
parameters, a StdThreadFactory
	 * and no task to execute.
	 *
	 * @param threadCount the number of threads.
	 * @throws IllegalArgumentException if threadCount < 0.
	 */
	public ThreadPoolRepeaterService(int threadCount) {
		this(threadCount, new StdThreadFactory("repeaters"));
	}

	/**
	 * Creates a ThreadPoolRepeaterService
	 *
	 * @param threadCount   the number of threads.
	 * @param threadFactory the ThreadFactory that is used to create threads for
	 *                      the threadpool.
	 * @throws IllegalArgumentException if threadcount smaller than 0.
	 * @throws NullPointerException	 if threadFactory is null.
	 */
	public ThreadPoolRepeaterService(int threadCount, ThreadFactory
threadFactory) {
		this(threadCount, threadFactory, null);
	}

	/**
	 * Creates a new ThreadPoolRepeaterService (that is not started).
	 *
	 * @param threadCount   the number of threads to use.
	 * @param threadFactory the ThreadFactory to use for creating threads.
	 * @param runnable	  the task to repeat (can be null).
	 * @throws IllegalArgumentException if threadCount smaller than 0.
	 * @throws NullPointerException	 if threadFactory is null.
	 */
	public ThreadPoolRepeaterService(int threadCount, ThreadFactory
threadFactory, Runnable runnable) {
		if (threadFactory == null) throw new NullPointerException();
		if (threadCount < 0) throw new IllegalArgumentException();
		_threadCount = threadCount;
		_threadFactory = threadFactory;
		try {
			_awaitableTask.setNewReference(runnable);
		} catch (InterruptedException e) {
			e.printStackTrace();  //To change body of catch statement use File
| Settings | File Templates.
		}
	}

	/**
	 * Returns the number of threads. The returned value does not
	 * have to correspond with the actual number of running threads:
	 * if this method is called after the poolsize has been changed
	 * but before the change is picked up.
	 *
	 * @see #getCurrentThreadCount()
	 */
	public int getThreadCount() {
		return _threadCount;
	}

	/**
	 * Returns the current number of Running threads. This value can be stale
	 * if the threadcount has been changed in the meanwhile.
	 *
	 * @see #getThreadCount()
	 */
	public int getCurrentThreadCount() {
		return _currentThreadCount.intValue();
	}

	public void increaseThreadCount(int delta) {
		throw new UnsupportedOperationException();
	}

	/**
	 * Sets the number of threads this ThreadPoolRepeaterService uses to
	 * execute.
	 *
	 * @param newThreadCount the number of threads.
	 * @throws IllegalArgumentException if newThreadCount < 0.
	 */
	public void setThreadCount(int newThreadCount) {
		if (newThreadCount < 0) throw new IllegalArgumentException();

		_mainLock.lock();
		try {
			if (_runstate == RepeaterServiceState.NOT_STARTED) {
				//the Repeater isn`t running yet, the number of threads
				//can be increased because no threads are created yet.
				_threadCount = newThreadCount;
			} else if (_runstate != RepeaterServiceState.RUNNING) {
				//a task can only be repeated if this RepeaterService is running.
				String msg = "This RepeaterService doesn't accept new tasks to repeat";
				throw new RejectedExecutionException(msg);  //todo: exception
			} else {
				//the Repeater is running.
				int delta = newThreadCount - getCurrentThreadCount();
				if (delta == 0) {
					//the poolsize stays the same
					return;
				}

				if (delta > 0) {
					//additional threads have to be added
					for (int k = 0; k < delta; k++) {
						Thread thread = createAndRegisterWorker();
						thread.start();
					}
				} else {
					//threads have to be destroyed.
					Iterator<Worker> workerIt = _workers.iterator();
					for (int k = 0; k < -delta; k++) {
						Worker worker = workerIt.next();
						worker.die();
						_workers.remove(worker);
					}
				}
				_threadCount = newThreadCount;
			}

		} finally {
			_mainLock.unlock();
		}
	}


	/**
	 * Returns the ThreadFactory this ThreadPoolRepeaterService uses to create
	 * threads.
	 */
	public ThreadFactory getThreadFactory() {
		return _threadFactory;
	}

	public synchronized Runnable getTask() {
		try {
			return _awaitableTask.lendValue(-1, TimeUnit.MICROSECONDS);
		} catch (InterruptedException e) {
			throw new RuntimeException(e);//todo
		}
	}

	public RepeaterServiceState getState() {
		return _runstate;
	}

	/**
	 * Makes sure that the Repeater is ready for repeating. A Repeater is
	 * ready for repeating if:
	 * <ul>
	 * <li>if is has not been started yet. If this is the case, it is
	 * started.</li>
	 * <li>if it is started. It doesn't matter if it is started
	 * multiple times.
	 * </li>
	 * <ul>
	 * In all other cases, a RejectedExecutionException will be thrown.
	 * <p/>
	 * This call requires the mainlock, but doesn't lock it itself.
	 * So the caller is responsible for this task.
	 *
	 * @throws RejectedExecutionException if this Repeater is not in the correct
	 *                                    state to execute the task.
	 */
	private void ensureRepeaterReadyForRepeating() {
		switch (_runstate) {
			case NOT_STARTED:
				//the repeater has not been started, so start it.
				startRepeater();
				break;
			case RUNNING://everything is ok
				break;
			default:
				String msg = "This RepeaterService doesn't accept new tasks to repeat";
				throw new RejectedExecutionException(msg);
		}
	}

	public boolean repeat(Runnable task, long timeout, TimeUnit unit)
throws InterruptedException {
		if (task == null || unit == null) throw new NullPointerException();

		long timeoutNs = unit.toNanos(timeout);
		timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
		if (timeoutNs <= 0)
			return false; //the mainlock could not be acquired.

		try {
			ensureRepeaterReadyForRepeating();
			return _awaitableTask.tryPutReference(task, timeoutNs, TimeUnit.NANOSECONDS);
		} finally {
			_mainLock.unlock();
		}
	}

	public void repeat(Runnable task) throws InterruptedException {
		_mainLock.lockInterruptibly();
		try {
			ensureRepeaterReadyForRepeating();
			_awaitableTask.setNewReference(task);
		} finally {
			_mainLock.unlock();
		}
	}

	public void start() {
		try {
			_mainLock.lock();
			startRepeater();
		} finally {
			_mainLock.unlock();
		}
	}

	/**
	 * Starts this RepeaterService. This method doesn`t lock the mainLock,
	 * that is the responsibility of the caller of this method.
	 * <p/>
	 * If this method is called while the runstate is different
	 * than NOT_STARTED, then an IllegalStateException will be thrown.
	 */
	private void startRepeater() {
		if (_runstate != RepeaterServiceState.NOT_STARTED) throw new
IllegalStateException();

		_runstate = RepeaterServiceState.RUNNING;

		for (int k = 0; k < _threadCount; k++) {
			Thread thread = createAndRegisterWorker();
			thread.start();
		}
	}

	/**
	 * Creates a new (unstarted) worker and registers it.
	 *
	 * This method doesn`t lock the required resources, this is
	 * the task of the callee.
	 *
	 * @return the created worker Thread.
	 */
	private Thread createAndRegisterWorker() {
		Worker worker = new Worker();
		Thread thread = _threadFactory.newThread(worker);
		worker.setThread(thread);
		_workers.add(worker);
		_currentThreadCount.incrementAndGet();
		return thread;
	}

	/**
	 * Deregisters a Worker. The Worker is removed from the workers and if it is
	 * the last worker, and this ThreadPoolRepeaterService is terminating, it sets
	 * the state to terminated.
	 *
	 * This method is threadsafe (it locks the mainlock itself).
	 *
	 * @param worker
	 */
	private void deregisterWorker(Worker worker) {
		_mainLock.lock();

		try {
			//remove the worker
			_workers.remove(worker);

			boolean isLastWorker = _workers.isEmpty();
			boolean isTerminating = _runstate == RepeaterServiceState.TERMINATING;

			//if this ThreadPoolRepeaterService is shutting down, and there are
no more workers
			//then this ThreadPoolRepeaterService is terminated.
			if (isLastWorker && isTerminating)
				_runstate = RepeaterServiceState.TERMINATED;
		} finally {
			_mainLock.unlock();
		}

		_currentThreadCount.decrementAndGet();
	}

	public void shutdown() throws InterruptedException {
		_mainLock.lock();
		try {
			switch (_runstate) {
				case NOT_STARTED:
					//if the service has not been started, it can be terminated immediately.
					_runstate = RepeaterServiceState.TERMINATED;
					break;
				case RUNNING:
					if (getCurrentThreadCount() == 0) {
						//there are not workers, this service is terminated
						_runstate = RepeaterServiceState.TERMINATED;
					} else {
						//there are workers, this service is going in the terminating state
						//untill all workers are terminated.
						_runstate = RepeaterServiceState.TERMINATING;

						//insert a dummy task in the waitabletask. If a worker
						//is waiting for a task to execute, it gets this dummy task,
						//executes it and terminates.
						//If this dummy task isn`t added, it could happen a worker
						//keeps waiting for a task that is never going to be executed.
						//And this means this ThreadPoolRepeaterService is never going
to shutdown.
						_awaitableTask.setNewReference(DUMMY_TASK);
					}
					break;
				case TERMINATING:
					//nothing needs to be done, this ThreadPoolRepeaterService
already is shuttingdown.
					break;
				case TERMINATED:
					//nothing needs to be done. this ThreadPoolRepeaterService
already is shutdown
					break;
				default:
					throw new AssertionError();
			}
		} finally {
			_mainLock.unlock();
		}
	}

	//idea:shutdownAndWait

	private static class DummyTask implements Runnable {
		public void run() {
			//do nothing
		}
	}

	private class Worker implements Runnable {

		//a flag to indicate that this worker should stop
		//This field should be volatile because it is used in a multithreaded
		//environment.
		private volatile boolean _die = false;
		//the Thread that executes the Worker. This field is 'final'.
		private Thread _thread;

		/**
		 * Sets the threads that executes this Worker.
		 *
		 * @param thread
		 */
		private void setThread(Thread thread) {
			_thread = thread;
		}

		/**
		 * Signals the Worker it should stop working.
		 */
		private void die() {
			_die = true;
			_thread.interrupt();
		}

		public void run() {
			try {
				Runnable task = null;
				_awaitableTask.lendValue();
				while (_runstate == RepeaterServiceState.RUNNING && !_die) {
					try {
						task.run();
					} catch (RuntimeException ex) {
						//todo: error handeling
						ex.printStackTrace();
					} finally {
						_awaitableTask.returnValue(task);
					}

					task = _awaitableTask.lendValue();
				}

				_awaitableTask.returnValue(task);
			} catch (InterruptedException e) {
				//todo
			} finally {
				deregisterWorker(this);
			}
		}
	}
}

On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> >From what I gathered from Peter, the specific use of a ThreadPool
> "Repeating" executor was that increasing the corePoolSize would
> automagically increase the number of tasks being executed ("repeated"). This
> is semantically quite different from what a TPE does or is meant to do and
> perhaps that is where the confusion has arisen.
>
> Repeating tasks (sequentially requeing them) was not the direct impedence as
> that can easily be solved with the task resubmitting itself or a specialized
> impl of a blocking queue which keeps queuing the same task instance.
>
> This is what I gathered from the aether... =)
>
>
> On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> >
> > That may well be, but so far I don't have a complete view of either all
> your
> > requirements or all of Peter's, so it is hard to offer suggestions.
> >
> > Cheers,
> > David
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>

From dcholmes at optusnet.com.au  Mon Jul 10 01:44:19 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 15:44:19 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607092214h2dc3cc74x4311aa7a29bf936d@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEPEGPAA.dcholmes@optusnet.com.au>

Peter,

If a Repeater simply has one or more worker threads that forever repeat
executing the same task then it would seem to me that using a
ThreadPoolExecutor with a custom queue that always returns theTask is the
simplest way to go. The Repeater can pre-start core threads, or else submit
to seed the initial execution. Cancellation of a thread might be harder as
they will never be idle, but the queue can support checking for being
interrupted too.

But you know the details of how you want the Repeater to be able to
grow/shrink and perhaps those requirements don't map well to TPE. But then
again you could always grow/shrink by throwing away one TPE and replacing
with another :)

As I said I can't see the full set of requirements for this service.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> Veentjer
> Sent: Monday, 10 July 2006 3:15 PM
> To: Dhanji R. Prasanna; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
>
>
> A Repeater needs only a single runnable that it keeps repeating. No
> strange things like resubmitting tasks or strange 'copyqueues'.
>
> I'm still working on the code, so it could contain bugs.
>
> ---------------------------------------------------------------------
>
> package org.jph.concurrent.repeater;
>
> import org.jph.concurrent.LockUtil;
> import org.jph.concurrent.StdThreadFactory;
> import org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;
>
> import java.util.HashSet;
> import java.util.Iterator;
> import java.util.concurrent.RejectedExecutionException;
> import java.util.concurrent.ThreadFactory;
> import java.util.concurrent.TimeUnit;
> import java.util.concurrent.atomic.AtomicInteger;
> import java.util.concurrent.locks.Lock;
> import java.util.concurrent.locks.ReentrantLock;
>
> /**
>  * The ThreadPoolRepeaterService is the default implementation of the
>  * {@link RepeaterService}. It uses a threadpool.
>  *
>  * @author Peter Veentjer.
>  */
> public final class ThreadPoolRepeaterService implements RepeaterService {
>
> 	private final static Runnable DUMMY_TASK = new DummyTask();
>
>
> 	//number of threads.
> 	//this field has to be volatile because it is shared
> between different
> 	//threads.
> 	private volatile int _threadCount;
>
> 	//factory for new threads
> 	private final ThreadFactory _threadFactory;
> 	//Set containing all worker threads
> 	private final HashSet<Worker> _workers = new HashSet<Worker>();
>
> 	//Contains the current number of threads.
> 	private final AtomicInteger _currentThreadCount = new
> AtomicInteger(0);
>
> 	//Lifecycle state
> 	private volatile RepeaterServiceState _runstate =
> RepeaterServiceState.NOT_STARTED;
>
> 	private final RelaxedAwaitableReference<Runnable> _awaitableTask =
> new RelaxedAwaitableReference<Runnable>();
>
> 	private final Lock _mainLock = new ReentrantLock();
>
> 	/**
> 	 * Creates a StdThreadFactory with a single thread, a
> StdThreadFactory and
> 	 * no task to execute.
> 	 */
> 	public ThreadPoolRepeaterService() {
> 		this(1);
> 	}
>
> 	/**
> 	 * Creates a ThreadPoolRepeaterService with the given initial
> parameters, a StdThreadFactory
> 	 * and no task to execute.
> 	 *
> 	 * @param threadCount the number of threads.
> 	 * @throws IllegalArgumentException if threadCount < 0.
> 	 */
> 	public ThreadPoolRepeaterService(int threadCount) {
> 		this(threadCount, new StdThreadFactory("repeaters"));
> 	}
>
> 	/**
> 	 * Creates a ThreadPoolRepeaterService
> 	 *
> 	 * @param threadCount   the number of threads.
> 	 * @param threadFactory the ThreadFactory that is used to
> create threads for
> 	 *                      the threadpool.
> 	 * @throws IllegalArgumentException if threadcount smaller than 0.
> 	 * @throws NullPointerException	 if threadFactory is null.
> 	 */
> 	public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> threadFactory) {
> 		this(threadCount, threadFactory, null);
> 	}
>
> 	/**
> 	 * Creates a new ThreadPoolRepeaterService (that is not started).
> 	 *
> 	 * @param threadCount   the number of threads to use.
> 	 * @param threadFactory the ThreadFactory to use for
> creating threads.
> 	 * @param runnable	  the task to repeat (can be null).
> 	 * @throws IllegalArgumentException if threadCount smaller than 0.
> 	 * @throws NullPointerException	 if threadFactory is null.
> 	 */
> 	public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> threadFactory, Runnable runnable) {
> 		if (threadFactory == null) throw new NullPointerException();
> 		if (threadCount < 0) throw new IllegalArgumentException();
> 		_threadCount = threadCount;
> 		_threadFactory = threadFactory;
> 		try {
> 			_awaitableTask.setNewReference(runnable);
> 		} catch (InterruptedException e) {
> 			e.printStackTrace();  //To change body of
> catch statement use File
> | Settings | File Templates.
> 		}
> 	}
>
> 	/**
> 	 * Returns the number of threads. The returned value does not
> 	 * have to correspond with the actual number of running threads:
> 	 * if this method is called after the poolsize has been changed
> 	 * but before the change is picked up.
> 	 *
> 	 * @see #getCurrentThreadCount()
> 	 */
> 	public int getThreadCount() {
> 		return _threadCount;
> 	}
>
> 	/**
> 	 * Returns the current number of Running threads. This
> value can be stale
> 	 * if the threadcount has been changed in the meanwhile.
> 	 *
> 	 * @see #getThreadCount()
> 	 */
> 	public int getCurrentThreadCount() {
> 		return _currentThreadCount.intValue();
> 	}
>
> 	public void increaseThreadCount(int delta) {
> 		throw new UnsupportedOperationException();
> 	}
>
> 	/**
> 	 * Sets the number of threads this ThreadPoolRepeaterService uses to
> 	 * execute.
> 	 *
> 	 * @param newThreadCount the number of threads.
> 	 * @throws IllegalArgumentException if newThreadCount < 0.
> 	 */
> 	public void setThreadCount(int newThreadCount) {
> 		if (newThreadCount < 0) throw new
> IllegalArgumentException();
>
> 		_mainLock.lock();
> 		try {
> 			if (_runstate == RepeaterServiceState.NOT_STARTED) {
> 				//the Repeater isn`t running yet,
> the number of threads
> 				//can be increased because no
> threads are created yet.
> 				_threadCount = newThreadCount;
> 			} else if (_runstate !=
> RepeaterServiceState.RUNNING) {
> 				//a task can only be repeated if
> this RepeaterService is running.
> 				String msg = "This RepeaterService
> doesn't accept new tasks to repeat";
> 				throw new
> RejectedExecutionException(msg);  //todo: exception
> 			} else {
> 				//the Repeater is running.
> 				int delta = newThreadCount -
> getCurrentThreadCount();
> 				if (delta == 0) {
> 					//the poolsize stays the same
> 					return;
> 				}
>
> 				if (delta > 0) {
> 					//additional threads have
> to be added
> 					for (int k = 0; k < delta; k++) {
> 						Thread thread =
> createAndRegisterWorker();
> 						thread.start();
> 					}
> 				} else {
> 					//threads have to be destroyed.
> 					Iterator<Worker> workerIt =
> _workers.iterator();
> 					for (int k = 0; k < -delta; k++) {
> 						Worker worker =
> workerIt.next();
> 						worker.die();
> 						_workers.remove(worker);
> 					}
> 				}
> 				_threadCount = newThreadCount;
> 			}
>
> 		} finally {
> 			_mainLock.unlock();
> 		}
> 	}
>
>
> 	/**
> 	 * Returns the ThreadFactory this ThreadPoolRepeaterService
> uses to create
> 	 * threads.
> 	 */
> 	public ThreadFactory getThreadFactory() {
> 		return _threadFactory;
> 	}
>
> 	public synchronized Runnable getTask() {
> 		try {
> 			return _awaitableTask.lendValue(-1,
> TimeUnit.MICROSECONDS);
> 		} catch (InterruptedException e) {
> 			throw new RuntimeException(e);//todo
> 		}
> 	}
>
> 	public RepeaterServiceState getState() {
> 		return _runstate;
> 	}
>
> 	/**
> 	 * Makes sure that the Repeater is ready for repeating. A
> Repeater is
> 	 * ready for repeating if:
> 	 * <ul>
> 	 * <li>if is has not been started yet. If this is the case, it is
> 	 * started.</li>
> 	 * <li>if it is started. It doesn't matter if it is started
> 	 * multiple times.
> 	 * </li>
> 	 * <ul>
> 	 * In all other cases, a RejectedExecutionException will be thrown.
> 	 * <p/>
> 	 * This call requires the mainlock, but doesn't lock it itself.
> 	 * So the caller is responsible for this task.
> 	 *
> 	 * @throws RejectedExecutionException if this Repeater is
> not in the correct
> 	 *                                    state to execute the task.
> 	 */
> 	private void ensureRepeaterReadyForRepeating() {
> 		switch (_runstate) {
> 			case NOT_STARTED:
> 				//the repeater has not been
> started, so start it.
> 				startRepeater();
> 				break;
> 			case RUNNING://everything is ok
> 				break;
> 			default:
> 				String msg = "This RepeaterService
> doesn't accept new tasks to repeat";
> 				throw new RejectedExecutionException(msg);
> 		}
> 	}
>
> 	public boolean repeat(Runnable task, long timeout, TimeUnit unit)
> throws InterruptedException {
> 		if (task == null || unit == null) throw new
> NullPointerException();
>
> 		long timeoutNs = unit.toNanos(timeout);
> 		timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> 		if (timeoutNs <= 0)
> 			return false; //the mainlock could not be acquired.
>
> 		try {
> 			ensureRepeaterReadyForRepeating();
> 			return _awaitableTask.tryPutReference(task,
> timeoutNs, TimeUnit.NANOSECONDS);
> 		} finally {
> 			_mainLock.unlock();
> 		}
> 	}
>
> 	public void repeat(Runnable task) throws InterruptedException {
> 		_mainLock.lockInterruptibly();
> 		try {
> 			ensureRepeaterReadyForRepeating();
> 			_awaitableTask.setNewReference(task);
> 		} finally {
> 			_mainLock.unlock();
> 		}
> 	}
>
> 	public void start() {
> 		try {
> 			_mainLock.lock();
> 			startRepeater();
> 		} finally {
> 			_mainLock.unlock();
> 		}
> 	}
>
> 	/**
> 	 * Starts this RepeaterService. This method doesn`t lock
> the mainLock,
> 	 * that is the responsibility of the caller of this method.
> 	 * <p/>
> 	 * If this method is called while the runstate is different
> 	 * than NOT_STARTED, then an IllegalStateException will be thrown.
> 	 */
> 	private void startRepeater() {
> 		if (_runstate != RepeaterServiceState.NOT_STARTED) throw new
> IllegalStateException();
>
> 		_runstate = RepeaterServiceState.RUNNING;
>
> 		for (int k = 0; k < _threadCount; k++) {
> 			Thread thread = createAndRegisterWorker();
> 			thread.start();
> 		}
> 	}
>
> 	/**
> 	 * Creates a new (unstarted) worker and registers it.
> 	 *
> 	 * This method doesn`t lock the required resources, this is
> 	 * the task of the callee.
> 	 *
> 	 * @return the created worker Thread.
> 	 */
> 	private Thread createAndRegisterWorker() {
> 		Worker worker = new Worker();
> 		Thread thread = _threadFactory.newThread(worker);
> 		worker.setThread(thread);
> 		_workers.add(worker);
> 		_currentThreadCount.incrementAndGet();
> 		return thread;
> 	}
>
> 	/**
> 	 * Deregisters a Worker. The Worker is removed from the
> workers and if it is
> 	 * the last worker, and this ThreadPoolRepeaterService is
> terminating, it sets
> 	 * the state to terminated.
> 	 *
> 	 * This method is threadsafe (it locks the mainlock itself).
> 	 *
> 	 * @param worker
> 	 */
> 	private void deregisterWorker(Worker worker) {
> 		_mainLock.lock();
>
> 		try {
> 			//remove the worker
> 			_workers.remove(worker);
>
> 			boolean isLastWorker = _workers.isEmpty();
> 			boolean isTerminating = _runstate ==
> RepeaterServiceState.TERMINATING;
>
> 			//if this ThreadPoolRepeaterService is
> shutting down, and there are
> no more workers
> 			//then this ThreadPoolRepeaterService is terminated.
> 			if (isLastWorker && isTerminating)
> 				_runstate = RepeaterServiceState.TERMINATED;
> 		} finally {
> 			_mainLock.unlock();
> 		}
>
> 		_currentThreadCount.decrementAndGet();
> 	}
>
> 	public void shutdown() throws InterruptedException {
> 		_mainLock.lock();
> 		try {
> 			switch (_runstate) {
> 				case NOT_STARTED:
> 					//if the service has not
> been started, it can be terminated immediately.
> 					_runstate =
> RepeaterServiceState.TERMINATED;
> 					break;
> 				case RUNNING:
> 					if (getCurrentThreadCount() == 0) {
> 						//there are not
> workers, this service is terminated
> 						_runstate =
> RepeaterServiceState.TERMINATED;
> 					} else {
> 						//there are
> workers, this service is going in the terminating state
> 						//untill all
> workers are terminated.
> 						_runstate =
> RepeaterServiceState.TERMINATING;
>
> 						//insert a dummy
> task in the waitabletask. If a worker
> 						//is waiting for a
> task to execute, it gets this dummy task,
> 						//executes it and
> terminates.
> 						//If this dummy
> task isn`t added, it could happen a worker
> 						//keeps waiting for
> a task that is never going to be executed.
> 						//And this means
> this ThreadPoolRepeaterService is never going
> to shutdown.
>
> _awaitableTask.setNewReference(DUMMY_TASK);
> 					}
> 					break;
> 				case TERMINATING:
> 					//nothing needs to be done,
> this ThreadPoolRepeaterService
> already is shuttingdown.
> 					break;
> 				case TERMINATED:
> 					//nothing needs to be done.
> this ThreadPoolRepeaterService
> already is shutdown
> 					break;
> 				default:
> 					throw new AssertionError();
> 			}
> 		} finally {
> 			_mainLock.unlock();
> 		}
> 	}
>
> 	//idea:shutdownAndWait
>
> 	private static class DummyTask implements Runnable {
> 		public void run() {
> 			//do nothing
> 		}
> 	}
>
> 	private class Worker implements Runnable {
>
> 		//a flag to indicate that this worker should stop
> 		//This field should be volatile because it is used
> in a multithreaded
> 		//environment.
> 		private volatile boolean _die = false;
> 		//the Thread that executes the Worker. This field
> is 'final'.
> 		private Thread _thread;
>
> 		/**
> 		 * Sets the threads that executes this Worker.
> 		 *
> 		 * @param thread
> 		 */
> 		private void setThread(Thread thread) {
> 			_thread = thread;
> 		}
>
> 		/**
> 		 * Signals the Worker it should stop working.
> 		 */
> 		private void die() {
> 			_die = true;
> 			_thread.interrupt();
> 		}
>
> 		public void run() {
> 			try {
> 				Runnable task = null;
> 				_awaitableTask.lendValue();
> 				while (_runstate ==
> RepeaterServiceState.RUNNING && !_die) {
> 					try {
> 						task.run();
> 					} catch (RuntimeException ex) {
> 						//todo: error handeling
> 						ex.printStackTrace();
> 					} finally {
>
> _awaitableTask.returnValue(task);
> 					}
>
> 					task = _awaitableTask.lendValue();
> 				}
>
> 				_awaitableTask.returnValue(task);
> 			} catch (InterruptedException e) {
> 				//todo
> 			} finally {
> 				deregisterWorker(this);
> 			}
> 		}
> 	}
> }
>
> On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > >From what I gathered from Peter, the specific use of a ThreadPool
> > "Repeating" executor was that increasing the corePoolSize would
> > automagically increase the number of tasks being executed
> ("repeated"). This
> > is semantically quite different from what a TPE does or is
> meant to do and
> > perhaps that is where the confusion has arisen.
> >
> > Repeating tasks (sequentially requeing them) was not the direct
> impedence as
> > that can easily be solved with the task resubmitting itself or
> a specialized
> > impl of a blocking queue which keeps queuing the same task instance.
> >
> > This is what I gathered from the aether... =)
> >
> >
> > On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > >
> > > That may well be, but so far I don't have a complete view of
> either all
> > your
> > > requirements or all of Peter's, so it is hard to offer suggestions.
> > >
> > > Cheers,
> > > David
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From alarmnummer at gmail.com  Mon Jul 10 01:54:29 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 07:54:29 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEPEGPAA.dcholmes@optusnet.com.au>
References: <1466c1d60607092214h2dc3cc74x4311aa7a29bf936d@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEPEGPAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>

Use the right tool for the job. The executor isn't made for continuous
repetition of a task and if you have to use strange solutions you
aren't useing the right abstraction.

Another problem what if you want have at most a single 'instance' of a
runnable being active. With an executor this is difficult to realise,
with the repeater I use a 'StrictAwaitableReference'. All workers need
to return their task, so the strictawaitablereference uses a rw-lock
to make sure all old jobs are returned before a new one can be set. If
it is allowed that different runnables are running concurrently, I can
use a much cheaper lock: the RelaxedAwaitableReference.



On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Peter,
>
> If a Repeater simply has one or more worker threads that forever repeat
> executing the same task then it would seem to me that using a
> ThreadPoolExecutor with a custom queue that always returns theTask is the
> simplest way to go. The Repeater can pre-start core threads, or else submit
> to seed the initial execution. Cancellation of a thread might be harder as
> they will never be idle, but the queue can support checking for being
> interrupted too.
>
> But you know the details of how you want the Repeater to be able to
> grow/shrink and perhaps those requirements don't map well to TPE. But then
> again you could always grow/shrink by throwing away one TPE and replacing
> with another :)
>
> As I said I can't see the full set of requirements for this service.
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > Veentjer
> > Sent: Monday, 10 July 2006 3:15 PM
> > To: Dhanji R. Prasanna; concurrency-interest at cs.oswego.edu
> > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> >
> >
> > A Repeater needs only a single runnable that it keeps repeating. No
> > strange things like resubmitting tasks or strange 'copyqueues'.
> >
> > I'm still working on the code, so it could contain bugs.
> >
> > ---------------------------------------------------------------------
> >
> > package org.jph.concurrent.repeater;
> >
> > import org.jph.concurrent.LockUtil;
> > import org.jph.concurrent.StdThreadFactory;
> > import org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;
> >
> > import java.util.HashSet;
> > import java.util.Iterator;
> > import java.util.concurrent.RejectedExecutionException;
> > import java.util.concurrent.ThreadFactory;
> > import java.util.concurrent.TimeUnit;
> > import java.util.concurrent.atomic.AtomicInteger;
> > import java.util.concurrent.locks.Lock;
> > import java.util.concurrent.locks.ReentrantLock;
> >
> > /**
> >  * The ThreadPoolRepeaterService is the default implementation of the
> >  * {@link RepeaterService}. It uses a threadpool.
> >  *
> >  * @author Peter Veentjer.
> >  */
> > public final class ThreadPoolRepeaterService implements RepeaterService {
> >
> >       private final static Runnable DUMMY_TASK = new DummyTask();
> >
> >
> >       //number of threads.
> >       //this field has to be volatile because it is shared
> > between different
> >       //threads.
> >       private volatile int _threadCount;
> >
> >       //factory for new threads
> >       private final ThreadFactory _threadFactory;
> >       //Set containing all worker threads
> >       private final HashSet<Worker> _workers = new HashSet<Worker>();
> >
> >       //Contains the current number of threads.
> >       private final AtomicInteger _currentThreadCount = new
> > AtomicInteger(0);
> >
> >       //Lifecycle state
> >       private volatile RepeaterServiceState _runstate =
> > RepeaterServiceState.NOT_STARTED;
> >
> >       private final RelaxedAwaitableReference<Runnable> _awaitableTask =
> > new RelaxedAwaitableReference<Runnable>();
> >
> >       private final Lock _mainLock = new ReentrantLock();
> >
> >       /**
> >        * Creates a StdThreadFactory with a single thread, a
> > StdThreadFactory and
> >        * no task to execute.
> >        */
> >       public ThreadPoolRepeaterService() {
> >               this(1);
> >       }
> >
> >       /**
> >        * Creates a ThreadPoolRepeaterService with the given initial
> > parameters, a StdThreadFactory
> >        * and no task to execute.
> >        *
> >        * @param threadCount the number of threads.
> >        * @throws IllegalArgumentException if threadCount < 0.
> >        */
> >       public ThreadPoolRepeaterService(int threadCount) {
> >               this(threadCount, new StdThreadFactory("repeaters"));
> >       }
> >
> >       /**
> >        * Creates a ThreadPoolRepeaterService
> >        *
> >        * @param threadCount   the number of threads.
> >        * @param threadFactory the ThreadFactory that is used to
> > create threads for
> >        *                      the threadpool.
> >        * @throws IllegalArgumentException if threadcount smaller than 0.
> >        * @throws NullPointerException  if threadFactory is null.
> >        */
> >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > threadFactory) {
> >               this(threadCount, threadFactory, null);
> >       }
> >
> >       /**
> >        * Creates a new ThreadPoolRepeaterService (that is not started).
> >        *
> >        * @param threadCount   the number of threads to use.
> >        * @param threadFactory the ThreadFactory to use for
> > creating threads.
> >        * @param runnable        the task to repeat (can be null).
> >        * @throws IllegalArgumentException if threadCount smaller than 0.
> >        * @throws NullPointerException  if threadFactory is null.
> >        */
> >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > threadFactory, Runnable runnable) {
> >               if (threadFactory == null) throw new NullPointerException();
> >               if (threadCount < 0) throw new IllegalArgumentException();
> >               _threadCount = threadCount;
> >               _threadFactory = threadFactory;
> >               try {
> >                       _awaitableTask.setNewReference(runnable);
> >               } catch (InterruptedException e) {
> >                       e.printStackTrace();  //To change body of
> > catch statement use File
> > | Settings | File Templates.
> >               }
> >       }
> >
> >       /**
> >        * Returns the number of threads. The returned value does not
> >        * have to correspond with the actual number of running threads:
> >        * if this method is called after the poolsize has been changed
> >        * but before the change is picked up.
> >        *
> >        * @see #getCurrentThreadCount()
> >        */
> >       public int getThreadCount() {
> >               return _threadCount;
> >       }
> >
> >       /**
> >        * Returns the current number of Running threads. This
> > value can be stale
> >        * if the threadcount has been changed in the meanwhile.
> >        *
> >        * @see #getThreadCount()
> >        */
> >       public int getCurrentThreadCount() {
> >               return _currentThreadCount.intValue();
> >       }
> >
> >       public void increaseThreadCount(int delta) {
> >               throw new UnsupportedOperationException();
> >       }
> >
> >       /**
> >        * Sets the number of threads this ThreadPoolRepeaterService uses to
> >        * execute.
> >        *
> >        * @param newThreadCount the number of threads.
> >        * @throws IllegalArgumentException if newThreadCount < 0.
> >        */
> >       public void setThreadCount(int newThreadCount) {
> >               if (newThreadCount < 0) throw new
> > IllegalArgumentException();
> >
> >               _mainLock.lock();
> >               try {
> >                       if (_runstate == RepeaterServiceState.NOT_STARTED) {
> >                               //the Repeater isn`t running yet,
> > the number of threads
> >                               //can be increased because no
> > threads are created yet.
> >                               _threadCount = newThreadCount;
> >                       } else if (_runstate !=
> > RepeaterServiceState.RUNNING) {
> >                               //a task can only be repeated if
> > this RepeaterService is running.
> >                               String msg = "This RepeaterService
> > doesn't accept new tasks to repeat";
> >                               throw new
> > RejectedExecutionException(msg);  //todo: exception
> >                       } else {
> >                               //the Repeater is running.
> >                               int delta = newThreadCount -
> > getCurrentThreadCount();
> >                               if (delta == 0) {
> >                                       //the poolsize stays the same
> >                                       return;
> >                               }
> >
> >                               if (delta > 0) {
> >                                       //additional threads have
> > to be added
> >                                       for (int k = 0; k < delta; k++) {
> >                                               Thread thread =
> > createAndRegisterWorker();
> >                                               thread.start();
> >                                       }
> >                               } else {
> >                                       //threads have to be destroyed.
> >                                       Iterator<Worker> workerIt =
> > _workers.iterator();
> >                                       for (int k = 0; k < -delta; k++) {
> >                                               Worker worker =
> > workerIt.next();
> >                                               worker.die();
> >                                               _workers.remove(worker);
> >                                       }
> >                               }
> >                               _threadCount = newThreadCount;
> >                       }
> >
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >       }
> >
> >
> >       /**
> >        * Returns the ThreadFactory this ThreadPoolRepeaterService
> > uses to create
> >        * threads.
> >        */
> >       public ThreadFactory getThreadFactory() {
> >               return _threadFactory;
> >       }
> >
> >       public synchronized Runnable getTask() {
> >               try {
> >                       return _awaitableTask.lendValue(-1,
> > TimeUnit.MICROSECONDS);
> >               } catch (InterruptedException e) {
> >                       throw new RuntimeException(e);//todo
> >               }
> >       }
> >
> >       public RepeaterServiceState getState() {
> >               return _runstate;
> >       }
> >
> >       /**
> >        * Makes sure that the Repeater is ready for repeating. A
> > Repeater is
> >        * ready for repeating if:
> >        * <ul>
> >        * <li>if is has not been started yet. If this is the case, it is
> >        * started.</li>
> >        * <li>if it is started. It doesn't matter if it is started
> >        * multiple times.
> >        * </li>
> >        * <ul>
> >        * In all other cases, a RejectedExecutionException will be thrown.
> >        * <p/>
> >        * This call requires the mainlock, but doesn't lock it itself.
> >        * So the caller is responsible for this task.
> >        *
> >        * @throws RejectedExecutionException if this Repeater is
> > not in the correct
> >        *                                    state to execute the task.
> >        */
> >       private void ensureRepeaterReadyForRepeating() {
> >               switch (_runstate) {
> >                       case NOT_STARTED:
> >                               //the repeater has not been
> > started, so start it.
> >                               startRepeater();
> >                               break;
> >                       case RUNNING://everything is ok
> >                               break;
> >                       default:
> >                               String msg = "This RepeaterService
> > doesn't accept new tasks to repeat";
> >                               throw new RejectedExecutionException(msg);
> >               }
> >       }
> >
> >       public boolean repeat(Runnable task, long timeout, TimeUnit unit)
> > throws InterruptedException {
> >               if (task == null || unit == null) throw new
> > NullPointerException();
> >
> >               long timeoutNs = unit.toNanos(timeout);
> >               timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> >               if (timeoutNs <= 0)
> >                       return false; //the mainlock could not be acquired.
> >
> >               try {
> >                       ensureRepeaterReadyForRepeating();
> >                       return _awaitableTask.tryPutReference(task,
> > timeoutNs, TimeUnit.NANOSECONDS);
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >       }
> >
> >       public void repeat(Runnable task) throws InterruptedException {
> >               _mainLock.lockInterruptibly();
> >               try {
> >                       ensureRepeaterReadyForRepeating();
> >                       _awaitableTask.setNewReference(task);
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >       }
> >
> >       public void start() {
> >               try {
> >                       _mainLock.lock();
> >                       startRepeater();
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >       }
> >
> >       /**
> >        * Starts this RepeaterService. This method doesn`t lock
> > the mainLock,
> >        * that is the responsibility of the caller of this method.
> >        * <p/>
> >        * If this method is called while the runstate is different
> >        * than NOT_STARTED, then an IllegalStateException will be thrown.
> >        */
> >       private void startRepeater() {
> >               if (_runstate != RepeaterServiceState.NOT_STARTED) throw new
> > IllegalStateException();
> >
> >               _runstate = RepeaterServiceState.RUNNING;
> >
> >               for (int k = 0; k < _threadCount; k++) {
> >                       Thread thread = createAndRegisterWorker();
> >                       thread.start();
> >               }
> >       }
> >
> >       /**
> >        * Creates a new (unstarted) worker and registers it.
> >        *
> >        * This method doesn`t lock the required resources, this is
> >        * the task of the callee.
> >        *
> >        * @return the created worker Thread.
> >        */
> >       private Thread createAndRegisterWorker() {
> >               Worker worker = new Worker();
> >               Thread thread = _threadFactory.newThread(worker);
> >               worker.setThread(thread);
> >               _workers.add(worker);
> >               _currentThreadCount.incrementAndGet();
> >               return thread;
> >       }
> >
> >       /**
> >        * Deregisters a Worker. The Worker is removed from the
> > workers and if it is
> >        * the last worker, and this ThreadPoolRepeaterService is
> > terminating, it sets
> >        * the state to terminated.
> >        *
> >        * This method is threadsafe (it locks the mainlock itself).
> >        *
> >        * @param worker
> >        */
> >       private void deregisterWorker(Worker worker) {
> >               _mainLock.lock();
> >
> >               try {
> >                       //remove the worker
> >                       _workers.remove(worker);
> >
> >                       boolean isLastWorker = _workers.isEmpty();
> >                       boolean isTerminating = _runstate ==
> > RepeaterServiceState.TERMINATING;
> >
> >                       //if this ThreadPoolRepeaterService is
> > shutting down, and there are
> > no more workers
> >                       //then this ThreadPoolRepeaterService is terminated.
> >                       if (isLastWorker && isTerminating)
> >                               _runstate = RepeaterServiceState.TERMINATED;
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >
> >               _currentThreadCount.decrementAndGet();
> >       }
> >
> >       public void shutdown() throws InterruptedException {
> >               _mainLock.lock();
> >               try {
> >                       switch (_runstate) {
> >                               case NOT_STARTED:
> >                                       //if the service has not
> > been started, it can be terminated immediately.
> >                                       _runstate =
> > RepeaterServiceState.TERMINATED;
> >                                       break;
> >                               case RUNNING:
> >                                       if (getCurrentThreadCount() == 0) {
> >                                               //there are not
> > workers, this service is terminated
> >                                               _runstate =
> > RepeaterServiceState.TERMINATED;
> >                                       } else {
> >                                               //there are
> > workers, this service is going in the terminating state
> >                                               //untill all
> > workers are terminated.
> >                                               _runstate =
> > RepeaterServiceState.TERMINATING;
> >
> >                                               //insert a dummy
> > task in the waitabletask. If a worker
> >                                               //is waiting for a
> > task to execute, it gets this dummy task,
> >                                               //executes it and
> > terminates.
> >                                               //If this dummy
> > task isn`t added, it could happen a worker
> >                                               //keeps waiting for
> > a task that is never going to be executed.
> >                                               //And this means
> > this ThreadPoolRepeaterService is never going
> > to shutdown.
> >
> > _awaitableTask.setNewReference(DUMMY_TASK);
> >                                       }
> >                                       break;
> >                               case TERMINATING:
> >                                       //nothing needs to be done,
> > this ThreadPoolRepeaterService
> > already is shuttingdown.
> >                                       break;
> >                               case TERMINATED:
> >                                       //nothing needs to be done.
> > this ThreadPoolRepeaterService
> > already is shutdown
> >                                       break;
> >                               default:
> >                                       throw new AssertionError();
> >                       }
> >               } finally {
> >                       _mainLock.unlock();
> >               }
> >       }
> >
> >       //idea:shutdownAndWait
> >
> >       private static class DummyTask implements Runnable {
> >               public void run() {
> >                       //do nothing
> >               }
> >       }
> >
> >       private class Worker implements Runnable {
> >
> >               //a flag to indicate that this worker should stop
> >               //This field should be volatile because it is used
> > in a multithreaded
> >               //environment.
> >               private volatile boolean _die = false;
> >               //the Thread that executes the Worker. This field
> > is 'final'.
> >               private Thread _thread;
> >
> >               /**
> >                * Sets the threads that executes this Worker.
> >                *
> >                * @param thread
> >                */
> >               private void setThread(Thread thread) {
> >                       _thread = thread;
> >               }
> >
> >               /**
> >                * Signals the Worker it should stop working.
> >                */
> >               private void die() {
> >                       _die = true;
> >                       _thread.interrupt();
> >               }
> >
> >               public void run() {
> >                       try {
> >                               Runnable task = null;
> >                               _awaitableTask.lendValue();
> >                               while (_runstate ==
> > RepeaterServiceState.RUNNING && !_die) {
> >                                       try {
> >                                               task.run();
> >                                       } catch (RuntimeException ex) {
> >                                               //todo: error handeling
> >                                               ex.printStackTrace();
> >                                       } finally {
> >
> > _awaitableTask.returnValue(task);
> >                                       }
> >
> >                                       task = _awaitableTask.lendValue();
> >                               }
> >
> >                               _awaitableTask.returnValue(task);
> >                       } catch (InterruptedException e) {
> >                               //todo
> >                       } finally {
> >                               deregisterWorker(this);
> >                       }
> >               }
> >       }
> > }
> >
> > On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > > >From what I gathered from Peter, the specific use of a ThreadPool
> > > "Repeating" executor was that increasing the corePoolSize would
> > > automagically increase the number of tasks being executed
> > ("repeated"). This
> > > is semantically quite different from what a TPE does or is
> > meant to do and
> > > perhaps that is where the confusion has arisen.
> > >
> > > Repeating tasks (sequentially requeing them) was not the direct
> > impedence as
> > > that can easily be solved with the task resubmitting itself or
> > a specialized
> > > impl of a blocking queue which keeps queuing the same task instance.
> > >
> > > This is what I gathered from the aether... =)
> > >
> > >
> > > On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > > >
> > > > That may well be, but so far I don't have a complete view of
> > either all
> > > your
> > > > requirements or all of Peter's, so it is hard to offer suggestions.
> > > >
> > > > Cheers,
> > > > David
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > >
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From dcholmes at optusnet.com.au  Mon Jul 10 02:01:43 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 16:01:43 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEPFGPAA.dcholmes@optusnet.com.au>

The Repeater may well be the right abstraction for this, my point was why
not build it from TPE and a special queue and/or special task rather than
from "first principles"?

I'm curious about the use-cases for this.

Cheers,
David

> -----Original Message-----
> From: Peter Veentjer [mailto:alarmnummer at gmail.com]
> Sent: Monday, 10 July 2006 3:54 PM
> To: dholmes at ieee.org; concurrency-interest at altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
>
>
> Use the right tool for the job. The executor isn't made for continuous
> repetition of a task and if you have to use strange solutions you
> aren't useing the right abstraction.
>
> Another problem what if you want have at most a single 'instance' of a
> runnable being active. With an executor this is difficult to realise,
> with the repeater I use a 'StrictAwaitableReference'. All workers need
> to return their task, so the strictawaitablereference uses a rw-lock
> to make sure all old jobs are returned before a new one can be set. If
> it is allowed that different runnables are running concurrently, I can
> use a much cheaper lock: the RelaxedAwaitableReference.
>
>
>
> On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > Peter,
> >
> > If a Repeater simply has one or more worker threads that forever repeat
> > executing the same task then it would seem to me that using a
> > ThreadPoolExecutor with a custom queue that always returns
> theTask is the
> > simplest way to go. The Repeater can pre-start core threads, or
> else submit
> > to seed the initial execution. Cancellation of a thread might
> be harder as
> > they will never be idle, but the queue can support checking for being
> > interrupted too.
> >
> > But you know the details of how you want the Repeater to be able to
> > grow/shrink and perhaps those requirements don't map well to
> TPE. But then
> > again you could always grow/shrink by throwing away one TPE and
> replacing
> > with another :)
> >
> > As I said I can't see the full set of requirements for this service.
> >
> > Cheers,
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > > Veentjer
> > > Sent: Monday, 10 July 2006 3:15 PM
> > > To: Dhanji R. Prasanna; concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> > >
> > >
> > > A Repeater needs only a single runnable that it keeps repeating. No
> > > strange things like resubmitting tasks or strange 'copyqueues'.
> > >
> > > I'm still working on the code, so it could contain bugs.
> > >
> > > ---------------------------------------------------------------------
> > >
> > > package org.jph.concurrent.repeater;
> > >
> > > import org.jph.concurrent.LockUtil;
> > > import org.jph.concurrent.StdThreadFactory;
> > > import
> org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;
> > >
> > > import java.util.HashSet;
> > > import java.util.Iterator;
> > > import java.util.concurrent.RejectedExecutionException;
> > > import java.util.concurrent.ThreadFactory;
> > > import java.util.concurrent.TimeUnit;
> > > import java.util.concurrent.atomic.AtomicInteger;
> > > import java.util.concurrent.locks.Lock;
> > > import java.util.concurrent.locks.ReentrantLock;
> > >
> > > /**
> > >  * The ThreadPoolRepeaterService is the default implementation of the
> > >  * {@link RepeaterService}. It uses a threadpool.
> > >  *
> > >  * @author Peter Veentjer.
> > >  */
> > > public final class ThreadPoolRepeaterService implements
> RepeaterService {
> > >
> > >       private final static Runnable DUMMY_TASK = new DummyTask();
> > >
> > >
> > >       //number of threads.
> > >       //this field has to be volatile because it is shared
> > > between different
> > >       //threads.
> > >       private volatile int _threadCount;
> > >
> > >       //factory for new threads
> > >       private final ThreadFactory _threadFactory;
> > >       //Set containing all worker threads
> > >       private final HashSet<Worker> _workers = new HashSet<Worker>();
> > >
> > >       //Contains the current number of threads.
> > >       private final AtomicInteger _currentThreadCount = new
> > > AtomicInteger(0);
> > >
> > >       //Lifecycle state
> > >       private volatile RepeaterServiceState _runstate =
> > > RepeaterServiceState.NOT_STARTED;
> > >
> > >       private final RelaxedAwaitableReference<Runnable>
> _awaitableTask =
> > > new RelaxedAwaitableReference<Runnable>();
> > >
> > >       private final Lock _mainLock = new ReentrantLock();
> > >
> > >       /**
> > >        * Creates a StdThreadFactory with a single thread, a
> > > StdThreadFactory and
> > >        * no task to execute.
> > >        */
> > >       public ThreadPoolRepeaterService() {
> > >               this(1);
> > >       }
> > >
> > >       /**
> > >        * Creates a ThreadPoolRepeaterService with the given initial
> > > parameters, a StdThreadFactory
> > >        * and no task to execute.
> > >        *
> > >        * @param threadCount the number of threads.
> > >        * @throws IllegalArgumentException if threadCount < 0.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount) {
> > >               this(threadCount, new StdThreadFactory("repeaters"));
> > >       }
> > >
> > >       /**
> > >        * Creates a ThreadPoolRepeaterService
> > >        *
> > >        * @param threadCount   the number of threads.
> > >        * @param threadFactory the ThreadFactory that is used to
> > > create threads for
> > >        *                      the threadpool.
> > >        * @throws IllegalArgumentException if threadcount
> smaller than 0.
> > >        * @throws NullPointerException  if threadFactory is null.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > threadFactory) {
> > >               this(threadCount, threadFactory, null);
> > >       }
> > >
> > >       /**
> > >        * Creates a new ThreadPoolRepeaterService (that is not
> started).
> > >        *
> > >        * @param threadCount   the number of threads to use.
> > >        * @param threadFactory the ThreadFactory to use for
> > > creating threads.
> > >        * @param runnable        the task to repeat (can be null).
> > >        * @throws IllegalArgumentException if threadCount
> smaller than 0.
> > >        * @throws NullPointerException  if threadFactory is null.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > threadFactory, Runnable runnable) {
> > >               if (threadFactory == null) throw new
> NullPointerException();
> > >               if (threadCount < 0) throw new
> IllegalArgumentException();
> > >               _threadCount = threadCount;
> > >               _threadFactory = threadFactory;
> > >               try {
> > >                       _awaitableTask.setNewReference(runnable);
> > >               } catch (InterruptedException e) {
> > >                       e.printStackTrace();  //To change body of
> > > catch statement use File
> > > | Settings | File Templates.
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Returns the number of threads. The returned value does not
> > >        * have to correspond with the actual number of running threads:
> > >        * if this method is called after the poolsize has been changed
> > >        * but before the change is picked up.
> > >        *
> > >        * @see #getCurrentThreadCount()
> > >        */
> > >       public int getThreadCount() {
> > >               return _threadCount;
> > >       }
> > >
> > >       /**
> > >        * Returns the current number of Running threads. This
> > > value can be stale
> > >        * if the threadcount has been changed in the meanwhile.
> > >        *
> > >        * @see #getThreadCount()
> > >        */
> > >       public int getCurrentThreadCount() {
> > >               return _currentThreadCount.intValue();
> > >       }
> > >
> > >       public void increaseThreadCount(int delta) {
> > >               throw new UnsupportedOperationException();
> > >       }
> > >
> > >       /**
> > >        * Sets the number of threads this
> ThreadPoolRepeaterService uses to
> > >        * execute.
> > >        *
> > >        * @param newThreadCount the number of threads.
> > >        * @throws IllegalArgumentException if newThreadCount < 0.
> > >        */
> > >       public void setThreadCount(int newThreadCount) {
> > >               if (newThreadCount < 0) throw new
> > > IllegalArgumentException();
> > >
> > >               _mainLock.lock();
> > >               try {
> > >                       if (_runstate ==
> RepeaterServiceState.NOT_STARTED) {
> > >                               //the Repeater isn`t running yet,
> > > the number of threads
> > >                               //can be increased because no
> > > threads are created yet.
> > >                               _threadCount = newThreadCount;
> > >                       } else if (_runstate !=
> > > RepeaterServiceState.RUNNING) {
> > >                               //a task can only be repeated if
> > > this RepeaterService is running.
> > >                               String msg = "This RepeaterService
> > > doesn't accept new tasks to repeat";
> > >                               throw new
> > > RejectedExecutionException(msg);  //todo: exception
> > >                       } else {
> > >                               //the Repeater is running.
> > >                               int delta = newThreadCount -
> > > getCurrentThreadCount();
> > >                               if (delta == 0) {
> > >                                       //the poolsize stays the same
> > >                                       return;
> > >                               }
> > >
> > >                               if (delta > 0) {
> > >                                       //additional threads have
> > > to be added
> > >                                       for (int k = 0; k <
> delta; k++) {
> > >                                               Thread thread =
> > > createAndRegisterWorker();
> > >                                               thread.start();
> > >                                       }
> > >                               } else {
> > >                                       //threads have to be destroyed.
> > >                                       Iterator<Worker> workerIt =
> > > _workers.iterator();
> > >                                       for (int k = 0; k <
> -delta; k++) {
> > >                                               Worker worker =
> > > workerIt.next();
> > >                                               worker.die();
> > >                                               _workers.remove(worker);
> > >                                       }
> > >                               }
> > >                               _threadCount = newThreadCount;
> > >                       }
> > >
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >
> > >       /**
> > >        * Returns the ThreadFactory this ThreadPoolRepeaterService
> > > uses to create
> > >        * threads.
> > >        */
> > >       public ThreadFactory getThreadFactory() {
> > >               return _threadFactory;
> > >       }
> > >
> > >       public synchronized Runnable getTask() {
> > >               try {
> > >                       return _awaitableTask.lendValue(-1,
> > > TimeUnit.MICROSECONDS);
> > >               } catch (InterruptedException e) {
> > >                       throw new RuntimeException(e);//todo
> > >               }
> > >       }
> > >
> > >       public RepeaterServiceState getState() {
> > >               return _runstate;
> > >       }
> > >
> > >       /**
> > >        * Makes sure that the Repeater is ready for repeating. A
> > > Repeater is
> > >        * ready for repeating if:
> > >        * <ul>
> > >        * <li>if is has not been started yet. If this is the
> case, it is
> > >        * started.</li>
> > >        * <li>if it is started. It doesn't matter if it is started
> > >        * multiple times.
> > >        * </li>
> > >        * <ul>
> > >        * In all other cases, a RejectedExecutionException
> will be thrown.
> > >        * <p/>
> > >        * This call requires the mainlock, but doesn't lock it itself.
> > >        * So the caller is responsible for this task.
> > >        *
> > >        * @throws RejectedExecutionException if this Repeater is
> > > not in the correct
> > >        *                                    state to execute the task.
> > >        */
> > >       private void ensureRepeaterReadyForRepeating() {
> > >               switch (_runstate) {
> > >                       case NOT_STARTED:
> > >                               //the repeater has not been
> > > started, so start it.
> > >                               startRepeater();
> > >                               break;
> > >                       case RUNNING://everything is ok
> > >                               break;
> > >                       default:
> > >                               String msg = "This RepeaterService
> > > doesn't accept new tasks to repeat";
> > >                               throw new
> RejectedExecutionException(msg);
> > >               }
> > >       }
> > >
> > >       public boolean repeat(Runnable task, long timeout,
> TimeUnit unit)
> > > throws InterruptedException {
> > >               if (task == null || unit == null) throw new
> > > NullPointerException();
> > >
> > >               long timeoutNs = unit.toNanos(timeout);
> > >               timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> > >               if (timeoutNs <= 0)
> > >                       return false; //the mainlock could not
> be acquired.
> > >
> > >               try {
> > >                       ensureRepeaterReadyForRepeating();
> > >                       return _awaitableTask.tryPutReference(task,
> > > timeoutNs, TimeUnit.NANOSECONDS);
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       public void repeat(Runnable task) throws InterruptedException {
> > >               _mainLock.lockInterruptibly();
> > >               try {
> > >                       ensureRepeaterReadyForRepeating();
> > >                       _awaitableTask.setNewReference(task);
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       public void start() {
> > >               try {
> > >                       _mainLock.lock();
> > >                       startRepeater();
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Starts this RepeaterService. This method doesn`t lock
> > > the mainLock,
> > >        * that is the responsibility of the caller of this method.
> > >        * <p/>
> > >        * If this method is called while the runstate is different
> > >        * than NOT_STARTED, then an IllegalStateException will
> be thrown.
> > >        */
> > >       private void startRepeater() {
> > >               if (_runstate !=
> RepeaterServiceState.NOT_STARTED) throw new
> > > IllegalStateException();
> > >
> > >               _runstate = RepeaterServiceState.RUNNING;
> > >
> > >               for (int k = 0; k < _threadCount; k++) {
> > >                       Thread thread = createAndRegisterWorker();
> > >                       thread.start();
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Creates a new (unstarted) worker and registers it.
> > >        *
> > >        * This method doesn`t lock the required resources, this is
> > >        * the task of the callee.
> > >        *
> > >        * @return the created worker Thread.
> > >        */
> > >       private Thread createAndRegisterWorker() {
> > >               Worker worker = new Worker();
> > >               Thread thread = _threadFactory.newThread(worker);
> > >               worker.setThread(thread);
> > >               _workers.add(worker);
> > >               _currentThreadCount.incrementAndGet();
> > >               return thread;
> > >       }
> > >
> > >       /**
> > >        * Deregisters a Worker. The Worker is removed from the
> > > workers and if it is
> > >        * the last worker, and this ThreadPoolRepeaterService is
> > > terminating, it sets
> > >        * the state to terminated.
> > >        *
> > >        * This method is threadsafe (it locks the mainlock itself).
> > >        *
> > >        * @param worker
> > >        */
> > >       private void deregisterWorker(Worker worker) {
> > >               _mainLock.lock();
> > >
> > >               try {
> > >                       //remove the worker
> > >                       _workers.remove(worker);
> > >
> > >                       boolean isLastWorker = _workers.isEmpty();
> > >                       boolean isTerminating = _runstate ==
> > > RepeaterServiceState.TERMINATING;
> > >
> > >                       //if this ThreadPoolRepeaterService is
> > > shutting down, and there are
> > > no more workers
> > >                       //then this ThreadPoolRepeaterService
> is terminated.
> > >                       if (isLastWorker && isTerminating)
> > >                               _runstate =
> RepeaterServiceState.TERMINATED;
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >
> > >               _currentThreadCount.decrementAndGet();
> > >       }
> > >
> > >       public void shutdown() throws InterruptedException {
> > >               _mainLock.lock();
> > >               try {
> > >                       switch (_runstate) {
> > >                               case NOT_STARTED:
> > >                                       //if the service has not
> > > been started, it can be terminated immediately.
> > >                                       _runstate =
> > > RepeaterServiceState.TERMINATED;
> > >                                       break;
> > >                               case RUNNING:
> > >                                       if
> (getCurrentThreadCount() == 0) {
> > >                                               //there are not
> > > workers, this service is terminated
> > >                                               _runstate =
> > > RepeaterServiceState.TERMINATED;
> > >                                       } else {
> > >                                               //there are
> > > workers, this service is going in the terminating state
> > >                                               //untill all
> > > workers are terminated.
> > >                                               _runstate =
> > > RepeaterServiceState.TERMINATING;
> > >
> > >                                               //insert a dummy
> > > task in the waitabletask. If a worker
> > >                                               //is waiting for a
> > > task to execute, it gets this dummy task,
> > >                                               //executes it and
> > > terminates.
> > >                                               //If this dummy
> > > task isn`t added, it could happen a worker
> > >                                               //keeps waiting for
> > > a task that is never going to be executed.
> > >                                               //And this means
> > > this ThreadPoolRepeaterService is never going
> > > to shutdown.
> > >
> > > _awaitableTask.setNewReference(DUMMY_TASK);
> > >                                       }
> > >                                       break;
> > >                               case TERMINATING:
> > >                                       //nothing needs to be done,
> > > this ThreadPoolRepeaterService
> > > already is shuttingdown.
> > >                                       break;
> > >                               case TERMINATED:
> > >                                       //nothing needs to be done.
> > > this ThreadPoolRepeaterService
> > > already is shutdown
> > >                                       break;
> > >                               default:
> > >                                       throw new AssertionError();
> > >                       }
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       //idea:shutdownAndWait
> > >
> > >       private static class DummyTask implements Runnable {
> > >               public void run() {
> > >                       //do nothing
> > >               }
> > >       }
> > >
> > >       private class Worker implements Runnable {
> > >
> > >               //a flag to indicate that this worker should stop
> > >               //This field should be volatile because it is used
> > > in a multithreaded
> > >               //environment.
> > >               private volatile boolean _die = false;
> > >               //the Thread that executes the Worker. This field
> > > is 'final'.
> > >               private Thread _thread;
> > >
> > >               /**
> > >                * Sets the threads that executes this Worker.
> > >                *
> > >                * @param thread
> > >                */
> > >               private void setThread(Thread thread) {
> > >                       _thread = thread;
> > >               }
> > >
> > >               /**
> > >                * Signals the Worker it should stop working.
> > >                */
> > >               private void die() {
> > >                       _die = true;
> > >                       _thread.interrupt();
> > >               }
> > >
> > >               public void run() {
> > >                       try {
> > >                               Runnable task = null;
> > >                               _awaitableTask.lendValue();
> > >                               while (_runstate ==
> > > RepeaterServiceState.RUNNING && !_die) {
> > >                                       try {
> > >                                               task.run();
> > >                                       } catch (RuntimeException ex) {
> > >                                               //todo: error handeling
> > >                                               ex.printStackTrace();
> > >                                       } finally {
> > >
> > > _awaitableTask.returnValue(task);
> > >                                       }
> > >
> > >                                       task =
> _awaitableTask.lendValue();
> > >                               }
> > >
> > >                               _awaitableTask.returnValue(task);
> > >                       } catch (InterruptedException e) {
> > >                               //todo
> > >                       } finally {
> > >                               deregisterWorker(this);
> > >                       }
> > >               }
> > >       }
> > > }
> > >
> > > On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > > > >From what I gathered from Peter, the specific use of a ThreadPool
> > > > "Repeating" executor was that increasing the corePoolSize would
> > > > automagically increase the number of tasks being executed
> > > ("repeated"). This
> > > > is semantically quite different from what a TPE does or is
> > > meant to do and
> > > > perhaps that is where the confusion has arisen.
> > > >
> > > > Repeating tasks (sequentially requeing them) was not the direct
> > > impedence as
> > > > that can easily be solved with the task resubmitting itself or
> > > a specialized
> > > > impl of a blocking queue which keeps queuing the same task instance.
> > > >
> > > > This is what I gathered from the aether... =)
> > > >
> > > >
> > > > On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > > > >
> > > > > That may well be, but so far I don't have a complete view of
> > > either all
> > > > your
> > > > > requirements or all of Peter's, so it is hard to offer
> suggestions.
> > > > >
> > > > > Cheers,
> > > > > David
> > > > >
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > >
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > >
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > >
> > > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >


From alarmnummer at gmail.com  Mon Jul 10 02:09:51 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 08:09:51 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEPFGPAA.dcholmes@optusnet.com.au>
References: <1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEPFGPAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607092309radff216j19362be0e56b0171@mail.gmail.com>

I use it to wire up everything that needs to be repeated (but in most
cased blocks waiting for input).

I could use it to create JMS-listeners for example.

or check out the last code example in the following topic:
http://forum.springframework.org/showthread.php?t=26194&highlight=repeater

The parser is a component with a InputChannel (Takeable) that contains
messages and it also has 2 output channels (one for parsed messages,
and one for errors).

The parserrepeater is hooked up to the parser. The parser exposes an
axle (the parse method that blocks if no message are available on the
input channel) and the parserrepeater is the engine you hook up to
that axle. It gives a very clear design imho.


On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> The Repeater may well be the right abstraction for this, my point was why
> not build it from TPE and a special queue and/or special task rather than
> from "first principles"?
>
> I'm curious about the use-cases for this.
>
> Cheers,
> David
>
> > -----Original Message-----
> > From: Peter Veentjer [mailto:alarmnummer at gmail.com]
> > Sent: Monday, 10 July 2006 3:54 PM
> > To: dholmes at ieee.org; concurrency-interest at altair.cs.oswego.edu
> > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> >
> >
> > Use the right tool for the job. The executor isn't made for continuous
> > repetition of a task and if you have to use strange solutions you
> > aren't useing the right abstraction.
> >
> > Another problem what if you want have at most a single 'instance' of a
> > runnable being active. With an executor this is difficult to realise,
> > with the repeater I use a 'StrictAwaitableReference'. All workers need
> > to return their task, so the strictawaitablereference uses a rw-lock
> > to make sure all old jobs are returned before a new one can be set. If
> > it is allowed that different runnables are running concurrently, I can
> > use a much cheaper lock: the RelaxedAwaitableReference.
> >
> >
> >
> > On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> > > Peter,
> > >
> > > If a Repeater simply has one or more worker threads that forever repeat
> > > executing the same task then it would seem to me that using a
> > > ThreadPoolExecutor with a custom queue that always returns
> > theTask is the
> > > simplest way to go. The Repeater can pre-start core threads, or
> > else submit
> > > to seed the initial execution. Cancellation of a thread might
> > be harder as
> > > they will never be idle, but the queue can support checking for being
> > > interrupted too.
> > >
> > > But you know the details of how you want the Repeater to be able to
> > > grow/shrink and perhaps those requirements don't map well to
> > TPE. But then
> > > again you could always grow/shrink by throwing away one TPE and
> > replacing
> > > with another :)
> > >
> > > As I said I can't see the full set of requirements for this service.
> > >
> > > Cheers,
> > > David Holmes
> > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces at cs.oswego.edu
> > > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > > > Veentjer
> > > > Sent: Monday, 10 July 2006 3:15 PM
> > > > To: Dhanji R. Prasanna; concurrency-interest at cs.oswego.edu
> > > > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> > > >
> > > >
> > > > A Repeater needs only a single runnable that it keeps repeating. No
> > > > strange things like resubmitting tasks or strange 'copyqueues'.
> > > >
> > > > I'm still working on the code, so it could contain bugs.
> > > >
> > > > ---------------------------------------------------------------------
> > > >
> > > > package org.jph.concurrent.repeater;
> > > >
> > > > import org.jph.concurrent.LockUtil;
> > > > import org.jph.concurrent.StdThreadFactory;
> > > > import
> > org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;
> > > >
> > > > import java.util.HashSet;
> > > > import java.util.Iterator;
> > > > import java.util.concurrent.RejectedExecutionException;
> > > > import java.util.concurrent.ThreadFactory;
> > > > import java.util.concurrent.TimeUnit;
> > > > import java.util.concurrent.atomic.AtomicInteger;
> > > > import java.util.concurrent.locks.Lock;
> > > > import java.util.concurrent.locks.ReentrantLock;
> > > >
> > > > /**
> > > >  * The ThreadPoolRepeaterService is the default implementation of the
> > > >  * {@link RepeaterService}. It uses a threadpool.
> > > >  *
> > > >  * @author Peter Veentjer.
> > > >  */
> > > > public final class ThreadPoolRepeaterService implements
> > RepeaterService {
> > > >
> > > >       private final static Runnable DUMMY_TASK = new DummyTask();
> > > >
> > > >
> > > >       //number of threads.
> > > >       //this field has to be volatile because it is shared
> > > > between different
> > > >       //threads.
> > > >       private volatile int _threadCount;
> > > >
> > > >       //factory for new threads
> > > >       private final ThreadFactory _threadFactory;
> > > >       //Set containing all worker threads
> > > >       private final HashSet<Worker> _workers = new HashSet<Worker>();
> > > >
> > > >       //Contains the current number of threads.
> > > >       private final AtomicInteger _currentThreadCount = new
> > > > AtomicInteger(0);
> > > >
> > > >       //Lifecycle state
> > > >       private volatile RepeaterServiceState _runstate =
> > > > RepeaterServiceState.NOT_STARTED;
> > > >
> > > >       private final RelaxedAwaitableReference<Runnable>
> > _awaitableTask =
> > > > new RelaxedAwaitableReference<Runnable>();
> > > >
> > > >       private final Lock _mainLock = new ReentrantLock();
> > > >
> > > >       /**
> > > >        * Creates a StdThreadFactory with a single thread, a
> > > > StdThreadFactory and
> > > >        * no task to execute.
> > > >        */
> > > >       public ThreadPoolRepeaterService() {
> > > >               this(1);
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a ThreadPoolRepeaterService with the given initial
> > > > parameters, a StdThreadFactory
> > > >        * and no task to execute.
> > > >        *
> > > >        * @param threadCount the number of threads.
> > > >        * @throws IllegalArgumentException if threadCount < 0.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount) {
> > > >               this(threadCount, new StdThreadFactory("repeaters"));
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a ThreadPoolRepeaterService
> > > >        *
> > > >        * @param threadCount   the number of threads.
> > > >        * @param threadFactory the ThreadFactory that is used to
> > > > create threads for
> > > >        *                      the threadpool.
> > > >        * @throws IllegalArgumentException if threadcount
> > smaller than 0.
> > > >        * @throws NullPointerException  if threadFactory is null.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > > threadFactory) {
> > > >               this(threadCount, threadFactory, null);
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a new ThreadPoolRepeaterService (that is not
> > started).
> > > >        *
> > > >        * @param threadCount   the number of threads to use.
> > > >        * @param threadFactory the ThreadFactory to use for
> > > > creating threads.
> > > >        * @param runnable        the task to repeat (can be null).
> > > >        * @throws IllegalArgumentException if threadCount
> > smaller than 0.
> > > >        * @throws NullPointerException  if threadFactory is null.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > > threadFactory, Runnable runnable) {
> > > >               if (threadFactory == null) throw new
> > NullPointerException();
> > > >               if (threadCount < 0) throw new
> > IllegalArgumentException();
> > > >               _threadCount = threadCount;
> > > >               _threadFactory = threadFactory;
> > > >               try {
> > > >                       _awaitableTask.setNewReference(runnable);
> > > >               } catch (InterruptedException e) {
> > > >                       e.printStackTrace();  //To change body of
> > > > catch statement use File
> > > > | Settings | File Templates.
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Returns the number of threads. The returned value does not
> > > >        * have to correspond with the actual number of running threads:
> > > >        * if this method is called after the poolsize has been changed
> > > >        * but before the change is picked up.
> > > >        *
> > > >        * @see #getCurrentThreadCount()
> > > >        */
> > > >       public int getThreadCount() {
> > > >               return _threadCount;
> > > >       }
> > > >
> > > >       /**
> > > >        * Returns the current number of Running threads. This
> > > > value can be stale
> > > >        * if the threadcount has been changed in the meanwhile.
> > > >        *
> > > >        * @see #getThreadCount()
> > > >        */
> > > >       public int getCurrentThreadCount() {
> > > >               return _currentThreadCount.intValue();
> > > >       }
> > > >
> > > >       public void increaseThreadCount(int delta) {
> > > >               throw new UnsupportedOperationException();
> > > >       }
> > > >
> > > >       /**
> > > >        * Sets the number of threads this
> > ThreadPoolRepeaterService uses to
> > > >        * execute.
> > > >        *
> > > >        * @param newThreadCount the number of threads.
> > > >        * @throws IllegalArgumentException if newThreadCount < 0.
> > > >        */
> > > >       public void setThreadCount(int newThreadCount) {
> > > >               if (newThreadCount < 0) throw new
> > > > IllegalArgumentException();
> > > >
> > > >               _mainLock.lock();
> > > >               try {
> > > >                       if (_runstate ==
> > RepeaterServiceState.NOT_STARTED) {
> > > >                               //the Repeater isn`t running yet,
> > > > the number of threads
> > > >                               //can be increased because no
> > > > threads are created yet.
> > > >                               _threadCount = newThreadCount;
> > > >                       } else if (_runstate !=
> > > > RepeaterServiceState.RUNNING) {
> > > >                               //a task can only be repeated if
> > > > this RepeaterService is running.
> > > >                               String msg = "This RepeaterService
> > > > doesn't accept new tasks to repeat";
> > > >                               throw new
> > > > RejectedExecutionException(msg);  //todo: exception
> > > >                       } else {
> > > >                               //the Repeater is running.
> > > >                               int delta = newThreadCount -
> > > > getCurrentThreadCount();
> > > >                               if (delta == 0) {
> > > >                                       //the poolsize stays the same
> > > >                                       return;
> > > >                               }
> > > >
> > > >                               if (delta > 0) {
> > > >                                       //additional threads have
> > > > to be added
> > > >                                       for (int k = 0; k <
> > delta; k++) {
> > > >                                               Thread thread =
> > > > createAndRegisterWorker();
> > > >                                               thread.start();
> > > >                                       }
> > > >                               } else {
> > > >                                       //threads have to be destroyed.
> > > >                                       Iterator<Worker> workerIt =
> > > > _workers.iterator();
> > > >                                       for (int k = 0; k <
> > -delta; k++) {
> > > >                                               Worker worker =
> > > > workerIt.next();
> > > >                                               worker.die();
> > > >                                               _workers.remove(worker);
> > > >                                       }
> > > >                               }
> > > >                               _threadCount = newThreadCount;
> > > >                       }
> > > >
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >
> > > >       /**
> > > >        * Returns the ThreadFactory this ThreadPoolRepeaterService
> > > > uses to create
> > > >        * threads.
> > > >        */
> > > >       public ThreadFactory getThreadFactory() {
> > > >               return _threadFactory;
> > > >       }
> > > >
> > > >       public synchronized Runnable getTask() {
> > > >               try {
> > > >                       return _awaitableTask.lendValue(-1,
> > > > TimeUnit.MICROSECONDS);
> > > >               } catch (InterruptedException e) {
> > > >                       throw new RuntimeException(e);//todo
> > > >               }
> > > >       }
> > > >
> > > >       public RepeaterServiceState getState() {
> > > >               return _runstate;
> > > >       }
> > > >
> > > >       /**
> > > >        * Makes sure that the Repeater is ready for repeating. A
> > > > Repeater is
> > > >        * ready for repeating if:
> > > >        * <ul>
> > > >        * <li>if is has not been started yet. If this is the
> > case, it is
> > > >        * started.</li>
> > > >        * <li>if it is started. It doesn't matter if it is started
> > > >        * multiple times.
> > > >        * </li>
> > > >        * <ul>
> > > >        * In all other cases, a RejectedExecutionException
> > will be thrown.
> > > >        * <p/>
> > > >        * This call requires the mainlock, but doesn't lock it itself.
> > > >        * So the caller is responsible for this task.
> > > >        *
> > > >        * @throws RejectedExecutionException if this Repeater is
> > > > not in the correct
> > > >        *                                    state to execute the task.
> > > >        */
> > > >       private void ensureRepeaterReadyForRepeating() {
> > > >               switch (_runstate) {
> > > >                       case NOT_STARTED:
> > > >                               //the repeater has not been
> > > > started, so start it.
> > > >                               startRepeater();
> > > >                               break;
> > > >                       case RUNNING://everything is ok
> > > >                               break;
> > > >                       default:
> > > >                               String msg = "This RepeaterService
> > > > doesn't accept new tasks to repeat";
> > > >                               throw new
> > RejectedExecutionException(msg);
> > > >               }
> > > >       }
> > > >
> > > >       public boolean repeat(Runnable task, long timeout,
> > TimeUnit unit)
> > > > throws InterruptedException {
> > > >               if (task == null || unit == null) throw new
> > > > NullPointerException();
> > > >
> > > >               long timeoutNs = unit.toNanos(timeout);
> > > >               timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> > > >               if (timeoutNs <= 0)
> > > >                       return false; //the mainlock could not
> > be acquired.
> > > >
> > > >               try {
> > > >                       ensureRepeaterReadyForRepeating();
> > > >                       return _awaitableTask.tryPutReference(task,
> > > > timeoutNs, TimeUnit.NANOSECONDS);
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       public void repeat(Runnable task) throws InterruptedException {
> > > >               _mainLock.lockInterruptibly();
> > > >               try {
> > > >                       ensureRepeaterReadyForRepeating();
> > > >                       _awaitableTask.setNewReference(task);
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       public void start() {
> > > >               try {
> > > >                       _mainLock.lock();
> > > >                       startRepeater();
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Starts this RepeaterService. This method doesn`t lock
> > > > the mainLock,
> > > >        * that is the responsibility of the caller of this method.
> > > >        * <p/>
> > > >        * If this method is called while the runstate is different
> > > >        * than NOT_STARTED, then an IllegalStateException will
> > be thrown.
> > > >        */
> > > >       private void startRepeater() {
> > > >               if (_runstate !=
> > RepeaterServiceState.NOT_STARTED) throw new
> > > > IllegalStateException();
> > > >
> > > >               _runstate = RepeaterServiceState.RUNNING;
> > > >
> > > >               for (int k = 0; k < _threadCount; k++) {
> > > >                       Thread thread = createAndRegisterWorker();
> > > >                       thread.start();
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a new (unstarted) worker and registers it.
> > > >        *
> > > >        * This method doesn`t lock the required resources, this is
> > > >        * the task of the callee.
> > > >        *
> > > >        * @return the created worker Thread.
> > > >        */
> > > >       private Thread createAndRegisterWorker() {
> > > >               Worker worker = new Worker();
> > > >               Thread thread = _threadFactory.newThread(worker);
> > > >               worker.setThread(thread);
> > > >               _workers.add(worker);
> > > >               _currentThreadCount.incrementAndGet();
> > > >               return thread;
> > > >       }
> > > >
> > > >       /**
> > > >        * Deregisters a Worker. The Worker is removed from the
> > > > workers and if it is
> > > >        * the last worker, and this ThreadPoolRepeaterService is
> > > > terminating, it sets
> > > >        * the state to terminated.
> > > >        *
> > > >        * This method is threadsafe (it locks the mainlock itself).
> > > >        *
> > > >        * @param worker
> > > >        */
> > > >       private void deregisterWorker(Worker worker) {
> > > >               _mainLock.lock();
> > > >
> > > >               try {
> > > >                       //remove the worker
> > > >                       _workers.remove(worker);
> > > >
> > > >                       boolean isLastWorker = _workers.isEmpty();
> > > >                       boolean isTerminating = _runstate ==
> > > > RepeaterServiceState.TERMINATING;
> > > >
> > > >                       //if this ThreadPoolRepeaterService is
> > > > shutting down, and there are
> > > > no more workers
> > > >                       //then this ThreadPoolRepeaterService
> > is terminated.
> > > >                       if (isLastWorker && isTerminating)
> > > >                               _runstate =
> > RepeaterServiceState.TERMINATED;
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >
> > > >               _currentThreadCount.decrementAndGet();
> > > >       }
> > > >
> > > >       public void shutdown() throws InterruptedException {
> > > >               _mainLock.lock();
> > > >               try {
> > > >                       switch (_runstate) {
> > > >                               case NOT_STARTED:
> > > >                                       //if the service has not
> > > > been started, it can be terminated immediately.
> > > >                                       _runstate =
> > > > RepeaterServiceState.TERMINATED;
> > > >                                       break;
> > > >                               case RUNNING:
> > > >                                       if
> > (getCurrentThreadCount() == 0) {
> > > >                                               //there are not
> > > > workers, this service is terminated
> > > >                                               _runstate =
> > > > RepeaterServiceState.TERMINATED;
> > > >                                       } else {
> > > >                                               //there are
> > > > workers, this service is going in the terminating state
> > > >                                               //untill all
> > > > workers are terminated.
> > > >                                               _runstate =
> > > > RepeaterServiceState.TERMINATING;
> > > >
> > > >                                               //insert a dummy
> > > > task in the waitabletask. If a worker
> > > >                                               //is waiting for a
> > > > task to execute, it gets this dummy task,
> > > >                                               //executes it and
> > > > terminates.
> > > >                                               //If this dummy
> > > > task isn`t added, it could happen a worker
> > > >                                               //keeps waiting for
> > > > a task that is never going to be executed.
> > > >                                               //And this means
> > > > this ThreadPoolRepeaterService is never going
> > > > to shutdown.
> > > >
> > > > _awaitableTask.setNewReference(DUMMY_TASK);
> > > >                                       }
> > > >                                       break;
> > > >                               case TERMINATING:
> > > >                                       //nothing needs to be done,
> > > > this ThreadPoolRepeaterService
> > > > already is shuttingdown.
> > > >                                       break;
> > > >                               case TERMINATED:
> > > >                                       //nothing needs to be done.
> > > > this ThreadPoolRepeaterService
> > > > already is shutdown
> > > >                                       break;
> > > >                               default:
> > > >                                       throw new AssertionError();
> > > >                       }
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       //idea:shutdownAndWait
> > > >
> > > >       private static class DummyTask implements Runnable {
> > > >               public void run() {
> > > >                       //do nothing
> > > >               }
> > > >       }
> > > >
> > > >       private class Worker implements Runnable {
> > > >
> > > >               //a flag to indicate that this worker should stop
> > > >               //This field should be volatile because it is used
> > > > in a multithreaded
> > > >               //environment.
> > > >               private volatile boolean _die = false;
> > > >               //the Thread that executes the Worker. This field
> > > > is 'final'.
> > > >               private Thread _thread;
> > > >
> > > >               /**
> > > >                * Sets the threads that executes this Worker.
> > > >                *
> > > >                * @param thread
> > > >                */
> > > >               private void setThread(Thread thread) {
> > > >                       _thread = thread;
> > > >               }
> > > >
> > > >               /**
> > > >                * Signals the Worker it should stop working.
> > > >                */
> > > >               private void die() {
> > > >                       _die = true;
> > > >                       _thread.interrupt();
> > > >               }
> > > >
> > > >               public void run() {
> > > >                       try {
> > > >                               Runnable task = null;
> > > >                               _awaitableTask.lendValue();
> > > >                               while (_runstate ==
> > > > RepeaterServiceState.RUNNING && !_die) {
> > > >                                       try {
> > > >                                               task.run();
> > > >                                       } catch (RuntimeException ex) {
> > > >                                               //todo: error handeling
> > > >                                               ex.printStackTrace();
> > > >                                       } finally {
> > > >
> > > > _awaitableTask.returnValue(task);
> > > >                                       }
> > > >
> > > >                                       task =
> > _awaitableTask.lendValue();
> > > >                               }
> > > >
> > > >                               _awaitableTask.returnValue(task);
> > > >                       } catch (InterruptedException e) {
> > > >                               //todo
> > > >                       } finally {
> > > >                               deregisterWorker(this);
> > > >                       }
> > > >               }
> > > >       }
> > > > }
> > > >
> > > > On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > > > > >From what I gathered from Peter, the specific use of a ThreadPool
> > > > > "Repeating" executor was that increasing the corePoolSize would
> > > > > automagically increase the number of tasks being executed
> > > > ("repeated"). This
> > > > > is semantically quite different from what a TPE does or is
> > > > meant to do and
> > > > > perhaps that is where the confusion has arisen.
> > > > >
> > > > > Repeating tasks (sequentially requeing them) was not the direct
> > > > impedence as
> > > > > that can easily be solved with the task resubmitting itself or
> > > > a specialized
> > > > > impl of a blocking queue which keeps queuing the same task instance.
> > > > >
> > > > > This is what I gathered from the aether... =)
> > > > >
> > > > >
> > > > > On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > > > > >
> > > > > > That may well be, but so far I don't have a complete view of
> > > > either all
> > > > > your
> > > > > > requirements or all of Peter's, so it is hard to offer
> > suggestions.
> > > > > >
> > > > > > Cheers,
> > > > > > David
> > > > > >
> > > > > > _______________________________________________
> > > > > > Concurrency-interest mailing list
> > > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > > >
> > > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > > >
> > > > >
> > > > >
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > > >
> > > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
>
>

From dhanji at gmail.com  Mon Jul 10 02:18:11 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 10 Jul 2006 16:18:11 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>
References: <1466c1d60607092214h2dc3cc74x4311aa7a29bf936d@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEPEGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>
Message-ID: <aa067ea10607092318l38da0d62l5d40a259233ec247@mail.gmail.com>

On 7/10/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
>
>
> Another problem what if you want have at most a single 'instance' of a
> runnable being active. With an executor this is difficult to realise,
> with the repeater I use a 'StrictAwaitableReference'. All workers need
> to return their task, so the strictawaitablereference uses a rw-lock
> to make sure all old jobs are returned before a new one can be set. If
> it is allowed that different runnables are running concurrently, I can
> use a much cheaper lock: the RelaxedAwaitableReference.


At the risk of dragging this on further:
Afaics, what you describe above (with weak vs strong locking) is the job of
the blocking queue that holds and feeds new tasks.

On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > Peter,
> >
> > If a Repeater simply has one or more worker threads that forever repeat
> > executing the same task then it would seem to me that using a
> > ThreadPoolExecutor with a custom queue that always returns theTask is
> the
> > simplest way to go. The Repeater can pre-start core threads, or else
> submit
> > to seed the initial execution. Cancellation of a thread might be harder
> as
> > they will never be idle, but the queue can support checking for being
> > interrupted too.
> >
> > But you know the details of how you want the Repeater to be able to
> > grow/shrink and perhaps those requirements don't map well to TPE. But
> then
> > again you could always grow/shrink by throwing away one TPE and
> replacing
> > with another :)
> >
> > As I said I can't see the full set of requirements for this service.
> >
> > Cheers,
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu ]On Behalf Of Peter
> > > Veentjer
> > > Sent: Monday, 10 July 2006 3:15 PM
> > > To: Dhanji R. Prasanna; concurrency-interest at cs.oswego.edu
> > > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> > >
> > >
> > > A Repeater needs only a single runnable that it keeps repeating. No
> > > strange things like resubmitting tasks or strange 'copyqueues'.
> > >
> > > I'm still working on the code, so it could contain bugs.
> > >
> > > ---------------------------------------------------------------------
> > >
> > > package org.jph.concurrent.repeater ;
> > >
> > > import org.jph.concurrent.LockUtil;
> > > import org.jph.concurrent.StdThreadFactory;
> > > import org.jph.concurrent.awaitablereference.RelaxedAwaitableReference
> ;
> > >
> > > import java.util.HashSet;
> > > import java.util.Iterator;
> > > import java.util.concurrent.RejectedExecutionException;
> > > import java.util.concurrent.ThreadFactory;
> > > import java.util.concurrent.TimeUnit;
> > > import java.util.concurrent.atomic.AtomicInteger;
> > > import java.util.concurrent.locks.Lock;
> > > import java.util.concurrent.locks.ReentrantLock;
> > >
> > > /**
> > >  * The ThreadPoolRepeaterService is the default implementation of the
> > >  * {@link RepeaterService}. It uses a threadpool.
> > >  *
> > >  * @author Peter Veentjer.
> > >  */
> > > public final class ThreadPoolRepeaterService implements
> RepeaterService {
> > >
> > >       private final static Runnable DUMMY_TASK = new DummyTask();
> > >
> > >
> > >       //number of threads.
> > >       //this field has to be volatile because it is shared
> > > between different
> > >       //threads.
> > >       private volatile int _threadCount;
> > >
> > >       //factory for new threads
> > >       private final ThreadFactory _threadFactory;
> > >       //Set containing all worker threads
> > >       private final HashSet<Worker> _workers = new HashSet<Worker>();
> > >
> > >       //Contains the current number of threads.
> > >       private final AtomicInteger _currentThreadCount = new
> > > AtomicInteger(0);
> > >
> > >       //Lifecycle state
> > >       private volatile RepeaterServiceState _runstate =
> > > RepeaterServiceState.NOT_STARTED;
> > >
> > >       private final RelaxedAwaitableReference<Runnable> _awaitableTask
> =
> > > new RelaxedAwaitableReference<Runnable>();
> > >
> > >       private final Lock _mainLock = new ReentrantLock();
> > >
> > >       /**
> > >        * Creates a StdThreadFactory with a single thread, a
> > > StdThreadFactory and
> > >        * no task to execute.
> > >        */
> > >       public ThreadPoolRepeaterService() {
> > >               this(1);
> > >       }
> > >
> > >       /**
> > >        * Creates a ThreadPoolRepeaterService with the given initial
> > > parameters, a StdThreadFactory
> > >        * and no task to execute.
> > >        *
> > >        * @param threadCount the number of threads.
> > >        * @throws IllegalArgumentException if threadCount < 0.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount) {
> > >               this(threadCount, new StdThreadFactory("repeaters"));
> > >       }
> > >
> > >       /**
> > >        * Creates a ThreadPoolRepeaterService
> > >        *
> > >        * @param threadCount   the number of threads.
> > >        * @param threadFactory the ThreadFactory that is used to
> > > create threads for
> > >        *                      the threadpool.
> > >        * @throws IllegalArgumentException if threadcount smaller than
> 0.
> > >        * @throws NullPointerException  if threadFactory is null.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > threadFactory) {
> > >               this(threadCount, threadFactory, null);
> > >       }
> > >
> > >       /**
> > >        * Creates a new ThreadPoolRepeaterService (that is not
> started).
> > >        *
> > >        * @param threadCount   the number of threads to use.
> > >        * @param threadFactory the ThreadFactory to use for
> > > creating threads.
> > >        * @param runnable        the task to repeat (can be null).
> > >        * @throws IllegalArgumentException if threadCount smaller than
> 0.
> > >        * @throws NullPointerException  if threadFactory is null.
> > >        */
> > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > threadFactory, Runnable runnable) {
> > >               if (threadFactory == null) throw new
> NullPointerException();
> > >               if (threadCount < 0) throw new
> IllegalArgumentException();
> > >               _threadCount = threadCount;
> > >               _threadFactory = threadFactory;
> > >               try {
> > >                       _awaitableTask.setNewReference(runnable);
> > >               } catch (InterruptedException e) {
> > >                       e.printStackTrace();  //To change body of
> > > catch statement use File
> > > | Settings | File Templates.
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Returns the number of threads. The returned value does not
> > >        * have to correspond with the actual number of running threads:
>
> > >        * if this method is called after the poolsize has been changed
> > >        * but before the change is picked up.
> > >        *
> > >        * @see #getCurrentThreadCount()
> > >        */
> > >       public int getThreadCount() {
> > >               return _threadCount;
> > >       }
> > >
> > >       /**
> > >        * Returns the current number of Running threads. This
> > > value can be stale
> > >        * if the threadcount has been changed in the meanwhile.
> > >        *
> > >        * @see #getThreadCount()
> > >        */
> > >       public int getCurrentThreadCount() {
> > >               return _currentThreadCount.intValue();
> > >       }
> > >
> > >       public void increaseThreadCount(int delta) {
> > >               throw new UnsupportedOperationException();
> > >       }
> > >
> > >       /**
> > >        * Sets the number of threads this ThreadPoolRepeaterService
> uses to
> > >        * execute.
> > >        *
> > >        * @param newThreadCount the number of threads.
> > >        * @throws IllegalArgumentException if newThreadCount < 0.
> > >        */
> > >       public void setThreadCount(int newThreadCount) {
> > >               if (newThreadCount < 0) throw new
> > > IllegalArgumentException();
> > >
> > >               _mainLock.lock();
> > >               try {
> > >                       if (_runstate ==
> RepeaterServiceState.NOT_STARTED) {
> > >                               //the Repeater isn`t running yet,
> > > the number of threads
> > >                               //can be increased because no
> > > threads are created yet.
> > >                               _threadCount = newThreadCount;
> > >                       } else if (_runstate !=
> > > RepeaterServiceState.RUNNING) {
> > >                               //a task can only be repeated if
> > > this RepeaterService is running.
> > >                               String msg = "This RepeaterService
> > > doesn't accept new tasks to repeat";
> > >                               throw new
> > > RejectedExecutionException(msg);  //todo: exception
> > >                       } else {
> > >                               //the Repeater is running.
> > >                               int delta = newThreadCount -
> > > getCurrentThreadCount();
> > >                               if (delta == 0) {
> > >                                       //the poolsize stays the same
> > >                                       return;
> > >                               }
> > >
> > >                               if (delta > 0) {
> > >                                       //additional threads have
> > > to be added
> > >                                       for (int k = 0; k < delta; k++)
> {
> > >                                               Thread thread =
> > > createAndRegisterWorker();
> > >                                               thread.start();
> > >                                       }
> > >                               } else {
> > >                                       //threads have to be destroyed.
> > >                                       Iterator<Worker> workerIt =
> > > _workers.iterator();
> > >                                       for (int k = 0; k < -delta; k++)
> {
> > >                                               Worker worker =
> > > workerIt.next ();
> > >                                               worker.die();
> > >                                               _workers.remove(worker);
> > >                                       }
> > >                               }
> > >                               _threadCount = newThreadCount;
> > >                       }
> > >
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >
> > >       /**
> > >        * Returns the ThreadFactory this ThreadPoolRepeaterService
> > > uses to create
> > >        * threads.
> > >        */
> > >       public ThreadFactory getThreadFactory() {
> > >               return _threadFactory;
> > >       }
> > >
> > >       public synchronized Runnable getTask() {
> > >               try {
> > >                       return _awaitableTask.lendValue(-1,
> > > TimeUnit.MICROSECONDS);
> > >               } catch (InterruptedException e) {
> > >                       throw new RuntimeException(e);//todo
> > >               }
> > >       }
> > >
> > >       public RepeaterServiceState getState() {
> > >               return _runstate;
> > >       }
> > >
> > >       /**
> > >        * Makes sure that the Repeater is ready for repeating. A
> > > Repeater is
> > >        * ready for repeating if:
> > >        * <ul>
> > >        * <li>if is has not been started yet. If this is the case, it
> is
> > >        * started.</li>
> > >        * <li>if it is started. It doesn't matter if it is started
> > >        * multiple times.
> > >        * </li>
> > >        * <ul>
> > >        * In all other cases, a RejectedExecutionException will be
> thrown.
> > >        * <p/>
> > >        * This call requires the mainlock, but doesn't lock it itself.
> > >        * So the caller is responsible for this task.
> > >        *
> > >        * @throws RejectedExecutionException if this Repeater is
> > > not in the correct
> > >        *                                    state to execute the task.
> > >        */
> > >       private void ensureRepeaterReadyForRepeating() {
> > >               switch (_runstate) {
> > >                       case NOT_STARTED:
> > >                               //the repeater has not been
> > > started, so start it.
> > >                               startRepeater();
> > >                               break;
> > >                       case RUNNING://everything is ok
> > >                               break;
> > >                       default:
> > >                               String msg = "This RepeaterService
> > > doesn't accept new tasks to repeat";
> > >                               throw new
> RejectedExecutionException(msg);
> > >               }
> > >       }
> > >
> > >       public boolean repeat(Runnable task, long timeout, TimeUnit
> unit)
> > > throws InterruptedException {
> > >               if (task == null || unit == null) throw new
> > > NullPointerException();
> > >
> > >               long timeoutNs = unit.toNanos(timeout);
> > >               timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> > >               if (timeoutNs <= 0)
> > >                       return false; //the mainlock could not be
> acquired.
> > >
> > >               try {
> > >                       ensureRepeaterReadyForRepeating();
> > >                       return _awaitableTask.tryPutReference(task,
> > > timeoutNs, TimeUnit.NANOSECONDS);
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       public void repeat(Runnable task) throws InterruptedException {
> > >               _mainLock.lockInterruptibly();
> > >               try {
> > >                       ensureRepeaterReadyForRepeating();
> > >                       _awaitableTask.setNewReference(task);
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       public void start() {
> > >               try {
> > >                       _mainLock.lock();
> > >                       startRepeater();
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Starts this RepeaterService. This method doesn`t lock
> > > the mainLock,
> > >        * that is the responsibility of the caller of this method.
> > >        * <p/>
> > >        * If this method is called while the runstate is different
> > >        * than NOT_STARTED, then an IllegalStateException will be
> thrown.
> > >        */
> > >       private void startRepeater() {
> > >               if (_runstate != RepeaterServiceState.NOT_STARTED) throw
> new
> > > IllegalStateException();
> > >
> > >               _runstate = RepeaterServiceState.RUNNING;
> > >
> > >               for (int k = 0; k < _threadCount; k++) {
> > >                       Thread thread = createAndRegisterWorker();
> > >                       thread.start();
> > >               }
> > >       }
> > >
> > >       /**
> > >        * Creates a new (unstarted) worker and registers it.
> > >        *
> > >        * This method doesn`t lock the required resources, this is
> > >        * the task of the callee.
> > >        *
> > >        * @return the created worker Thread.
> > >        */
> > >       private Thread createAndRegisterWorker() {
> > >               Worker worker = new Worker();
> > >               Thread thread = _threadFactory.newThread(worker);
> > >               worker.setThread(thread);
> > >               _workers.add(worker);
> > >               _currentThreadCount.incrementAndGet();
> > >               return thread;
> > >       }
> > >
> > >       /**
> > >        * Deregisters a Worker. The Worker is removed from the
> > > workers and if it is
> > >        * the last worker, and this ThreadPoolRepeaterService is
> > > terminating, it sets
> > >        * the state to terminated.
> > >        *
> > >        * This method is threadsafe (it locks the mainlock itself).
> > >        *
> > >        * @param worker
> > >        */
> > >       private void deregisterWorker(Worker worker) {
> > >               _mainLock.lock();
> > >
> > >               try {
> > >                       //remove the worker
> > >                       _workers.remove(worker);
> > >
> > >                       boolean isLastWorker = _workers.isEmpty();
> > >                       boolean isTerminating = _runstate ==
> > > RepeaterServiceState.TERMINATING;
> > >
> > >                       //if this ThreadPoolRepeaterService is
> > > shutting down, and there are
> > > no more workers
> > >                       //then this ThreadPoolRepeaterService is
> terminated.
> > >                       if (isLastWorker && isTerminating)
> > >                               _runstate =
> RepeaterServiceState.TERMINATED;
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >
> > >               _currentThreadCount.decrementAndGet();
> > >       }
> > >
> > >       public void shutdown() throws InterruptedException {
> > >               _mainLock.lock();
> > >               try {
> > >                       switch (_runstate) {
> > >                               case NOT_STARTED:
> > >                                       //if the service has not
> > > been started, it can be terminated immediately.
> > >                                       _runstate =
> > > RepeaterServiceState.TERMINATED;
> > >                                       break;
> > >                               case RUNNING:
> > >                                       if (getCurrentThreadCount() ==
> 0) {
> > >                                               //there are not
> > > workers, this service is terminated
> > >                                               _runstate =
> > > RepeaterServiceState.TERMINATED;
> > >                                       } else {
> > >                                               //there are
> > > workers, this service is going in the terminating state
> > >                                               //untill all
> > > workers are terminated.
> > >                                               _runstate =
> > > RepeaterServiceState.TERMINATING;
> > >
> > >                                               //insert a dummy
> > > task in the waitabletask. If a worker
> > >                                               //is waiting for a
> > > task to execute, it gets this dummy task,
> > >                                               //executes it and
> > > terminates.
> > >                                               //If this dummy
> > > task isn`t added, it could happen a worker
> > >                                               //keeps waiting for
> > > a task that is never going to be executed.
> > >                                               //And this means
> > > this ThreadPoolRepeaterService is never going
> > > to shutdown.
> > >
> > > _awaitableTask.setNewReference(DUMMY_TASK);
> > >                                       }
> > >                                       break;
> > >                               case TERMINATING:
> > >                                       //nothing needs to be done,
> > > this ThreadPoolRepeaterService
> > > already is shuttingdown.
> > >                                       break;
> > >                               case TERMINATED:
> > >                                       //nothing needs to be done.
> > > this ThreadPoolRepeaterService
> > > already is shutdown
> > >                                       break;
> > >                               default:
> > >                                       throw new AssertionError();
> > >                       }
> > >               } finally {
> > >                       _mainLock.unlock();
> > >               }
> > >       }
> > >
> > >       //idea:shutdownAndWait
> > >
> > >       private static class DummyTask implements Runnable {
> > >               public void run() {
> > >                       //do nothing
> > >               }
> > >       }
> > >
> > >       private class Worker implements Runnable {
> > >
> > >               //a flag to indicate that this worker should stop
> > >               //This field should be volatile because it is used
> > > in a multithreaded
> > >               //environment.
> > >               private volatile boolean _die = false;
> > >               //the Thread that executes the Worker. This field
> > > is 'final'.
> > >               private Thread _thread;
> > >
> > >               /**
> > >                * Sets the threads that executes this Worker.
> > >                *
> > >                * @param thread
> > >                */
> > >               private void setThread(Thread thread) {
> > >                       _thread = thread;
> > >               }
> > >
> > >               /**
> > >                * Signals the Worker it should stop working.
> > >                */
> > >               private void die() {
> > >                       _die = true;
> > >                       _thread.interrupt();
> > >               }
> > >
> > >               public void run() {
> > >                       try {
> > >                               Runnable task = null;
> > >                               _awaitableTask.lendValue();
> > >                               while (_runstate ==
> > > RepeaterServiceState.RUNNING && !_die) {
> > >                                       try {
> > >                                               task.run();
> > >                                       } catch (RuntimeException ex) {
> > >                                               //todo: error handeling
> > >                                               ex.printStackTrace();
> > >                                       } finally {
> > >
> > > _awaitableTask.returnValue(task);
> > >                                       }
> > >
> > >                                       task =
> _awaitableTask.lendValue();
> > >                               }
> > >
> > >                               _awaitableTask.returnValue(task);
> > >                       } catch (InterruptedException e) {
> > >                               //todo
> > >                       } finally {
> > >                               deregisterWorker(this);
> > >                       }
> > >               }
> > >       }
> > > }
> > >
> > > On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> > > > >From what I gathered from Peter, the specific use of a ThreadPool
> > > > "Repeating" executor was that increasing the corePoolSize would
> > > > automagically increase the number of tasks being executed
> > > ("repeated"). This
> > > > is semantically quite different from what a TPE does or is
> > > meant to do and
> > > > perhaps that is where the confusion has arisen.
> > > >
> > > > Repeating tasks (sequentially requeing them) was not the direct
> > > impedence as
> > > > that can easily be solved with the task resubmitting itself or
> > > a specialized
> > > > impl of a blocking queue which keeps queuing the same task instance.
>
> > > >
> > > > This is what I gathered from the aether... =)
> > > >
> > > >
> > > > On 7/10/06, David Holmes <dcholmes at optusnet.com.au > wrote:
> > > > >
> > > > > That may well be, but so far I don't have a complete view of
> > > either all
> > > > your
> > > > > requirements or all of Peter's, so it is hard to offer
> suggestions.
> > > > >
> > > > > Cheers,
> > > > > David
> > > > >
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > >
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > >
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > >
> > > >
> > > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060710/cc951dc4/attachment-0001.html 

From alarmnummer at gmail.com  Mon Jul 10 02:23:30 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 08:23:30 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <aa067ea10607092318l38da0d62l5d40a259233ec247@mail.gmail.com>
References: <1466c1d60607092214h2dc3cc74x4311aa7a29bf936d@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEPEGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607092254o1d037f7cp1e65007a98d4dbe8@mail.gmail.com>
	<aa067ea10607092318l38da0d62l5d40a259233ec247@mail.gmail.com>
Message-ID: <1466c1d60607092323x375ff8d2haa82d543c7afe08d@mail.gmail.com>

Because the task never signal when they are finished, the queue
doesn't know when to release the new value.

With the repeater the task needs to be returned (when it is run) to
the awaitablereference. With the strict version it releases a
readlock. With the relaxed version it is ignored.

So with an executor this behaviour is more difficult to realise than
with a repeater.


On 7/10/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
>
>
> On 7/10/06, Peter Veentjer <alarmnummer at gmail.com > wrote:
> >
> > Another problem what if you want have at most a single 'instance' of a
> > runnable being active. With an executor this is difficult to realise,
> > with the repeater I use a 'StrictAwaitableReference'. All workers need
> > to return their task, so the strictawaitablereference uses a rw-lock
> > to make sure all old jobs are returned before a new one can be set. If
> > it is allowed that different runnables are running concurrently, I can
> > use a much cheaper lock: the RelaxedAwaitableReference.
>
>
> At the risk of dragging this on further:
> Afaics, what you describe above (with weak vs strong locking) is the job of
> the blocking queue that holds and feeds new tasks.
>
> > On 7/10/06, David Holmes < dcholmes at optusnet.com.au > wrote:
> > > Peter,
> > >
> > > If a Repeater simply has one or more worker threads that forever repeat
> > > executing the same task then it would seem to me that using a
> > > ThreadPoolExecutor with a custom queue that always returns theTask is
> the
> > > simplest way to go. The Repeater can pre-start core threads, or else
> submit
> > > to seed the initial execution. Cancellation of a thread might be harder
> as
> > > they will never be idle, but the queue can support checking for being
> > > interrupted too.
> > >
> > > But you know the details of how you want the Repeater to be able to
> > > grow/shrink and perhaps those requirements don't map well to TPE. But
> then
> > > again you could always grow/shrink by throwing away one TPE and
> replacing
> > > with another :)
> > >
> > > As I said I can't see the full set of requirements for this service.
> > >
> > > Cheers,
> > > David Holmes
> > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces at cs.oswego.edu
> > > > [mailto: concurrency-interest-bounces at cs.oswego.edu
> ]On Behalf Of Peter
> > > > Veentjer
> > > > Sent: Monday, 10 July 2006 3:15 PM
> > > > To: Dhanji R. Prasanna;
> concurrency-interest at cs.oswego.edu
> > > > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> > > >
> > > >
> > > > A Repeater needs only a single runnable that it keeps repeating. No
> > > > strange things like resubmitting tasks or strange 'copyqueues'.
> > > >
> > > > I'm still working on the code, so it could contain bugs.
> > > >
> > > >
> ---------------------------------------------------------------------
> > > >
> > > > package org.jph.concurrent.repeater ;
> > > >
> > > > import org.jph.concurrent.LockUtil;
> > > > import org.jph.concurrent.StdThreadFactory;
> > > > import
> org.jph.concurrent.awaitablereference.RelaxedAwaitableReference;
> > > >
> > > > import java.util.HashSet;
> > > > import java.util.Iterator;
> > > > import
> java.util.concurrent.RejectedExecutionException;
> > > > import java.util.concurrent.ThreadFactory;
> > > > import java.util.concurrent.TimeUnit;
> > > > import java.util.concurrent.atomic.AtomicInteger;
> > > > import java.util.concurrent.locks.Lock;
> > > > import java.util.concurrent.locks.ReentrantLock;
> > > >
> > > > /**
> > > >  * The ThreadPoolRepeaterService is the default implementation of the
> > > >  * {@link RepeaterService}. It uses a threadpool.
> > > >  *
> > > >  * @author Peter Veentjer.
> > > >  */
> > > > public final class ThreadPoolRepeaterService implements
> RepeaterService {
> > > >
> > > >       private final static Runnable DUMMY_TASK = new DummyTask();
> > > >
> > > >
> > > >       //number of threads.
> > > >       //this field has to be volatile because it is shared
> > > > between different
> > > >       //threads.
> > > >       private volatile int _threadCount;
> > > >
> > > >       //factory for new threads
> > > >       private final ThreadFactory _threadFactory;
> > > >       //Set containing all worker threads
> > > >       private final HashSet<Worker> _workers = new HashSet<Worker>();
> > > >
> > > >       //Contains the current number of threads.
> > > >       private final AtomicInteger _currentThreadCount = new
> > > > AtomicInteger(0);
> > > >
> > > >       //Lifecycle state
> > > >       private volatile RepeaterServiceState _runstate =
> > > > RepeaterServiceState.NOT_STARTED;
> > > >
> > > >       private final
> RelaxedAwaitableReference<Runnable> _awaitableTask =
> > > > new RelaxedAwaitableReference<Runnable>();
> > > >
> > > >       private final Lock _mainLock = new ReentrantLock();
> > > >
> > > >       /**
> > > >        * Creates a StdThreadFactory with a single thread, a
> > > > StdThreadFactory and
> > > >        * no task to execute.
> > > >        */
> > > >       public ThreadPoolRepeaterService() {
> > > >               this(1);
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a ThreadPoolRepeaterService with the given initial
> > > > parameters, a StdThreadFactory
> > > >        * and no task to execute.
> > > >        *
> > > >        * @param threadCount the number of threads.
> > > >        * @throws IllegalArgumentException if threadCount < 0.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount) {
> > > >               this(threadCount, new StdThreadFactory("repeaters"));
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a ThreadPoolRepeaterService
> > > >        *
> > > >        * @param threadCount   the number of threads.
> > > >        * @param threadFactory the ThreadFactory that is used to
> > > > create threads for
> > > >        *                      the threadpool.
> > > >        * @throws IllegalArgumentException if threadcount smaller than
> 0.
> > > >        * @throws NullPointerException  if threadFactory is null.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > > threadFactory) {
> > > >               this(threadCount, threadFactory, null);
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a new ThreadPoolRepeaterService (that is not
> started).
> > > >        *
> > > >        * @param threadCount   the number of threads to use.
> > > >        * @param threadFactory the ThreadFactory to use for
> > > > creating threads.
> > > >        * @param runnable        the task to repeat (can be null).
> > > >        * @throws IllegalArgumentException if threadCount smaller than
> 0.
> > > >        * @throws NullPointerException  if threadFactory is null.
> > > >        */
> > > >       public ThreadPoolRepeaterService(int threadCount, ThreadFactory
> > > > threadFactory, Runnable runnable) {
> > > >               if (threadFactory == null) throw new
> NullPointerException();
> > > >               if (threadCount < 0) throw new
> IllegalArgumentException();
> > > >               _threadCount = threadCount;
> > > >               _threadFactory = threadFactory;
> > > >               try {
> > > >
> _awaitableTask.setNewReference(runnable);
> > > >               } catch (InterruptedException e) {
> > > >                       e.printStackTrace();  //To change body of
> > > > catch statement use File
> > > > | Settings | File Templates.
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Returns the number of threads. The returned value does not
> > > >        * have to correspond with the actual number of running threads:
> > > >        * if this method is called after the poolsize has been changed
> > > >        * but before the change is picked up.
> > > >        *
> > > >        * @see #getCurrentThreadCount()
> > > >        */
> > > >       public int getThreadCount() {
> > > >               return _threadCount;
> > > >       }
> > > >
> > > >       /**
> > > >        * Returns the current number of Running threads. This
> > > > value can be stale
> > > >        * if the threadcount has been changed in the meanwhile.
> > > >        *
> > > >        * @see #getThreadCount()
> > > >        */
> > > >       public int getCurrentThreadCount() {
> > > >               return _currentThreadCount.intValue();
> > > >       }
> > > >
> > > >       public void increaseThreadCount(int delta) {
> > > >               throw new
> UnsupportedOperationException();
> > > >       }
> > > >
> > > >       /**
> > > >        * Sets the number of threads this ThreadPoolRepeaterService
> uses to
> > > >        * execute.
> > > >        *
> > > >        * @param newThreadCount the number of threads.
> > > >        * @throws IllegalArgumentException if newThreadCount < 0.
> > > >        */
> > > >       public void setThreadCount(int newThreadCount) {
> > > >               if (newThreadCount < 0) throw new
> > > > IllegalArgumentException();
> > > >
> > > >               _mainLock.lock();
> > > >               try {
> > > >                       if (_runstate ==
> RepeaterServiceState.NOT_STARTED) {
> > > >                               //the Repeater isn`t running yet,
> > > > the number of threads
> > > >                               //can be increased because no
> > > > threads are created yet.
> > > >                               _threadCount = newThreadCount;
> > > >                       } else if (_runstate !=
> > > > RepeaterServiceState.RUNNING) {
> > > >                               //a task can only be repeated if
> > > > this RepeaterService is running.
> > > >                               String msg = "This RepeaterService
> > > > doesn't accept new tasks to repeat";
> > > >                               throw new
> > > > RejectedExecutionException(msg);  //todo: exception
> > > >                       } else {
> > > >                               //the Repeater is running.
> > > >                               int delta = newThreadCount -
> > > > getCurrentThreadCount();
> > > >                               if (delta == 0) {
> > > >                                       //the poolsize
> stays the same
> > > >                                       return;
> > > >                               }
> > > >
> > > >                               if (delta > 0) {
> > > >                                       //additional
> threads have
> > > > to be added
> > > >                                       for (int k = 0;
> k < delta; k++) {
> > > >                                               Thread
> thread =
> > > > createAndRegisterWorker();
> > > >
> thread.start();
> > > >                                       }
> > > >                               } else {
> > > >                                       //threads have
> to be destroyed.
> > > >
> Iterator<Worker> workerIt =
> > > > _workers.iterator();
> > > >                                       for (int k = 0;
> k < -delta; k++) {
> > > >                                               Worker
> worker =
> > > > workerIt.next ();
> > > >
> worker.die();
> > > >
> _workers.remove(worker);
> > > >                                       }
> > > >                               }
> > > >                               _threadCount = newThreadCount;
> > > >                       }
> > > >
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >
> > > >       /**
> > > >        * Returns the ThreadFactory this ThreadPoolRepeaterService
> > > > uses to create
> > > >        * threads.
> > > >        */
> > > >       public ThreadFactory getThreadFactory() {
> > > >               return _threadFactory;
> > > >       }
> > > >
> > > >       public synchronized Runnable getTask() {
> > > >               try {
> > > >                       return _awaitableTask.lendValue(-1,
> > > > TimeUnit.MICROSECONDS);
> > > >               } catch (InterruptedException e) {
> > > >                       throw new RuntimeException(e);//todo
> > > >               }
> > > >       }
> > > >
> > > >       public RepeaterServiceState getState() {
> > > >               return _runstate;
> > > >       }
> > > >
> > > >       /**
> > > >        * Makes sure that the Repeater is ready for repeating. A
> > > > Repeater is
> > > >        * ready for repeating if:
> > > >        * <ul>
> > > >        * <li>if is has not been started yet. If this is the case, it
> is
> > > >        * started.</li>
> > > >        * <li>if it is started. It doesn't matter if it is started
> > > >        * multiple times.
> > > >        * </li>
> > > >        * <ul>
> > > >        * In all other cases, a RejectedExecutionException will be
> thrown.
> > > >        * <p/>
> > > >        * This call requires the mainlock, but doesn't lock it itself.
> > > >        * So the caller is responsible for this task.
> > > >        *
> > > >        * @throws RejectedExecutionException if this Repeater is
> > > > not in the correct
> > > >        *                                    state to
> execute the task.
> > > >        */
> > > >       private void ensureRepeaterReadyForRepeating()
> {
> > > >               switch (_runstate) {
> > > >                       case NOT_STARTED:
> > > >                               //the repeater has not been
> > > > started, so start it.
> > > >                               startRepeater();
> > > >                               break;
> > > >                       case RUNNING://everything is ok
> > > >                               break;
> > > >                       default:
> > > >                               String msg = "This RepeaterService
> > > > doesn't accept new tasks to repeat";
> > > >                               throw new
> RejectedExecutionException(msg);
> > > >               }
> > > >       }
> > > >
> > > >       public boolean repeat(Runnable task, long timeout, TimeUnit
> unit)
> > > > throws InterruptedException {
> > > >               if (task == null || unit == null) throw new
> > > > NullPointerException();
> > > >
> > > >               long timeoutNs = unit.toNanos(timeout);
> > > >               timeoutNs = LockUtil.tryLockNanos(_mainLock, timeoutNs);
> > > >               if (timeoutNs <= 0)
> > > >                       return false; //the mainlock could not be
> acquired.
> > > >
> > > >               try {
> > > >
> ensureRepeaterReadyForRepeating();
> > > >                       return
> _awaitableTask.tryPutReference(task,
> > > > timeoutNs, TimeUnit.NANOSECONDS);
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       public void repeat(Runnable task) throws InterruptedException {
> > > >               _mainLock.lockInterruptibly();
> > > >               try {
> > > >
> ensureRepeaterReadyForRepeating();
> > > >
> _awaitableTask.setNewReference(task);
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       public void start() {
> > > >               try {
> > > >                       _mainLock.lock();
> > > >                       startRepeater();
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Starts this RepeaterService. This method doesn`t lock
> > > > the mainLock,
> > > >        * that is the responsibility of the caller of this method.
> > > >        * <p/>
> > > >        * If this method is called while the runstate is different
> > > >        * than NOT_STARTED, then an IllegalStateException will be
> thrown.
> > > >        */
> > > >       private void startRepeater() {
> > > >               if (_runstate !=
> RepeaterServiceState.NOT_STARTED) throw new
> > > > IllegalStateException();
> > > >
> > > >               _runstate = RepeaterServiceState.RUNNING;
> > > >
> > > >               for (int k = 0; k < _threadCount; k++) {
> > > >                       Thread thread = createAndRegisterWorker();
> > > >                       thread.start();
> > > >               }
> > > >       }
> > > >
> > > >       /**
> > > >        * Creates a new (unstarted) worker and registers it.
> > > >        *
> > > >        * This method doesn`t lock the required resources, this is
> > > >        * the task of the callee.
> > > >        *
> > > >        * @return the created worker Thread.
> > > >        */
> > > >       private Thread createAndRegisterWorker() {
> > > >               Worker worker = new Worker();
> > > >               Thread thread =
> _threadFactory.newThread(worker);
> > > >               worker.setThread(thread);
> > > >               _workers.add(worker);
> > > >               _currentThreadCount.incrementAndGet();
> > > >               return thread;
> > > >       }
> > > >
> > > >       /**
> > > >        * Deregisters a Worker. The Worker is removed from the
> > > > workers and if it is
> > > >        * the last worker, and this ThreadPoolRepeaterService is
> > > > terminating, it sets
> > > >        * the state to terminated.
> > > >        *
> > > >        * This method is threadsafe (it locks the mainlock itself).
> > > >        *
> > > >        * @param worker
> > > >        */
> > > >       private void deregisterWorker(Worker worker) {
> > > >               _mainLock.lock();
> > > >
> > > >               try {
> > > >                       //remove the worker
> > > >                       _workers.remove(worker);
> > > >
> > > >                       boolean isLastWorker = _workers.isEmpty();
> > > >                       boolean isTerminating = _runstate ==
> > > > RepeaterServiceState.TERMINATING;
> > > >
> > > >                       //if this ThreadPoolRepeaterService is
> > > > shutting down, and there are
> > > > no more workers
> > > >                       //then this ThreadPoolRepeaterService is
> terminated.
> > > >                       if (isLastWorker && isTerminating)
> > > >                               _runstate =
> RepeaterServiceState.TERMINATED;
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >
> > > >               _currentThreadCount.decrementAndGet();
> > > >       }
> > > >
> > > >       public void shutdown() throws InterruptedException {
> > > >               _mainLock.lock();
> > > >               try {
> > > >                       switch (_runstate) {
> > > >                               case NOT_STARTED:
> > > >                                       //if the
> service has not
> > > > been started, it can be terminated immediately.
> > > >                                       _runstate =
> > > > RepeaterServiceState.TERMINATED;
> > > >                                       break;
> > > >                               case RUNNING:
> > > >                                       if
> (getCurrentThreadCount() == 0) {
> > > >                                               //there
> are not
> > > > workers, this service is terminated
> > > >
> _runstate =
> > > > RepeaterServiceState.TERMINATED;
> > > >                                       } else {
> > > >                                               //there
> are
> > > > workers, this service is going in the terminating state
> > > >
> //untill all
> > > > workers are terminated.
> > > >
> _runstate =
> > > > RepeaterServiceState.TERMINATING;
> > > >
> > > >
> //insert a dummy
> > > > task in the waitabletask. If a worker
> > > >                                               //is
> waiting for a
> > > > task to execute, it gets this dummy task,
> > > >
> //executes it and
> > > > terminates.
> > > >                                               //If
> this dummy
> > > > task isn`t added, it could happen a worker
> > > >                                               //keeps
> waiting for
> > > > a task that is never going to be executed.
> > > >                                               //And
> this means
> > > > this ThreadPoolRepeaterService is never going
> > > > to shutdown.
> > > >
> > > > _awaitableTask.setNewReference(DUMMY_TASK);
> > > >                                       }
> > > >                                       break;
> > > >                               case TERMINATING:
> > > >                                       //nothing needs
> to be done,
> > > > this ThreadPoolRepeaterService
> > > > already is shuttingdown.
> > > >                                       break;
> > > >                               case TERMINATED:
> > > >                                       //nothing needs
> to be done.
> > > > this ThreadPoolRepeaterService
> > > > already is shutdown
> > > >                                       break;
> > > >                               default:
> > > >                                       throw new
> AssertionError();
> > > >                       }
> > > >               } finally {
> > > >                       _mainLock.unlock();
> > > >               }
> > > >       }
> > > >
> > > >       //idea:shutdownAndWait
> > > >
> > > >       private static class DummyTask implements Runnable {
> > > >               public void run() {
> > > >                       //do nothing
> > > >               }
> > > >       }
> > > >
> > > >       private class Worker implements Runnable {
> > > >
> > > >               //a flag to indicate that this worker should stop
> > > >               //This field should be volatile because it is used
> > > > in a multithreaded
> > > >               //environment.
> > > >               private volatile boolean _die = false;
> > > >               //the Thread that executes the Worker. This field
> > > > is 'final'.
> > > >               private Thread _thread;
> > > >
> > > >               /**
> > > >                * Sets the threads that executes this Worker.
> > > >                *
> > > >                * @param thread
> > > >                */
> > > >               private void setThread(Thread thread) {
> > > >                       _thread = thread;
> > > >               }
> > > >
> > > >               /**
> > > >                * Signals the Worker it should stop working.
> > > >                */
> > > >               private void die() {
> > > >                       _die = true;
> > > >                       _thread.interrupt();
> > > >               }
> > > >
> > > >               public void run() {
> > > >                       try {
> > > >                               Runnable task = null;
> > > >                               _awaitableTask.lendValue();
> > > >                               while (_runstate ==
> > > > RepeaterServiceState.RUNNING && !_die) {
> > > >                                       try {
> > > >
> task.run();
> > > >                                       } catch
> (RuntimeException ex) {
> > > >                                               //todo:
> error handeling
> > > >
> ex.printStackTrace();
> > > >                                       } finally {
> > > >
> > > > _awaitableTask.returnValue(task);
> > > >                                       }
> > > >
> > > >                                       task =
> _awaitableTask.lendValue();
> > > >                               }
> > > >
> > > >
> _awaitableTask.returnValue(task);
> > > >                       } catch (InterruptedException e) {
> > > >                               //todo
> > > >                       } finally {
> > > >                               deregisterWorker(this);
> > > >                       }
> > > >               }
> > > >       }
> > > > }
> > > >
> > > > On 7/10/06, Dhanji R. Prasanna < dhanji at gmail.com> wrote:
> > > > > >From what I gathered from Peter, the specific use of a ThreadPool
> > > > > "Repeating" executor was that increasing the corePoolSize would
> > > > > automagically increase the number of tasks being executed
> > > > ("repeated"). This
> > > > > is semantically quite different from what a TPE does or is
> > > > meant to do and
> > > > > perhaps that is where the confusion has arisen.
> > > > >
> > > > > Repeating tasks (sequentially requeing them) was not the direct
> > > > impedence as
> > > > > that can easily be solved with the task resubmitting itself or
> > > > a specialized
> > > > > impl of a blocking queue which keeps queuing the same task instance.
> > > > >
> > > > > This is what I gathered from the aether... =)
> > > > >
> > > > >
> > > > > On 7/10/06, David Holmes < dcholmes at optusnet.com.au > wrote:
> > > > > >
> > > > > > That may well be, but so far I don't have a complete view of
> > > > either all
> > > > > your
> > > > > > requirements or all of Peter's, so it is hard to offer
> suggestions.
> > > > > >
> > > > > > Cheers,
> > > > > > David
> > > > > >
> > > > > > _______________________________________________
> > > > > > Concurrency-interest mailing list
> > > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > > >
> > > > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > > >
> > > > >
> > > > >
> > > > > _______________________________________________
> > > > > Concurrency-interest mailing list
> > > > > Concurrency-interest at altair.cs.oswego.edu
> > > > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > > > >
> > > > >
> > > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>

From dcholmes at optusnet.com.au  Mon Jul 10 02:34:43 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 16:34:43 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607092309radff216j19362be0e56b0171@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEPGGPAA.dcholmes@optusnet.com.au>

Peter,

> or check out the last code example in the following topic:
> http://forum.springframework.org/showthread.php?t=26194&highlight=repeater
>
> The parser is a component with a InputChannel (Takeable) that contains
> messages and it also has 2 output channels (one for parsed messages,
> and one for errors).
>
> The parserrepeater is hooked up to the parser. The parser exposes an
> axle (the parse method that blocks if no message are available on the
> input channel) and the parserrepeater is the engine you hook up to
> that axle. It gives a very clear design imho.

So if I'm understanding this right, what you have done is to invert the
classic producer consumer loop so that instead of having a consumer thread
doing:

   while ((parseTask = channel.take()) != STOP_TASK) { // just an example
       executeor.execute(new ParsingTask(parseTask));
   }

Your "executor" instead has worker threads that executes the same task
instance that has a blocking run() method of the form:

   while ((parseTask = channel.take()) != STOP_TASK) { // just an example
       parse(parseTask);
   }

Is that right?

Cheers,
David


From alarmnummer at gmail.com  Mon Jul 10 02:41:21 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 08:41:21 +0200
Subject: [concurrency-interest] Fwd:  Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607092340x32143033w4a13c014ca91dba1@mail.gmail.com>
References: <1466c1d60607092309radff216j19362be0e56b0171@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCKEPGGPAA.dcholmes@optusnet.com.au>
	<1466c1d60607092340x32143033w4a13c014ca91dba1@mail.gmail.com>
Message-ID: <1466c1d60607092341l3ee0740aybf074279f83fc300@mail.gmail.com>

---------- Forwarded message ----------
From: Peter Veentjer <alarmnummer at gmail.com>
Date: Jul 10, 2006 8:40 AM
Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
To: dholmes at ieee.org


The parseSingleMessage looks like this:

void parseSingleMessage(){
    Page page = pageInputChannel.take();
    try{
         ParsedPage parsedPage = parse(page);
         successOutputChannel.put(parsedPage);
    }catch(ParseException ex){
          errorOutputChannel.put(...);
    }
}

The parser doesn't do any looping itself.

This makes it very easy to test such components.

> So if I'm understanding this right, what you have done is to invert the
> classic producer consumer loop so that instead of having a consumer thread
> doing:
>
>    while ((parseTask = channel.take()) != STOP_TASK) { // just an example
>        executeor.execute(new ParsingTask(parseTask));
>    }
>
> Your "executor" instead has worker threads that executes the same task
> instance that has a blocking run() method of the form:
>
>    while ((parseTask = channel.take()) != STOP_TASK) { // just an example
>        parse(parseTask);
>    }
>
> Is that right?
>
> Cheers,
> David
>
>

From dcholmes at optusnet.com.au  Mon Jul 10 02:53:34 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Jul 2006 16:53:34 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEPGGPAA.dcholmes@optusnet.com.au>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPHGPAA.dcholmes@optusnet.com.au>

I wrote:
> So if I'm understanding this right, what you have done is to invert the
> classic producer consumer loop so that instead of having a consumer thread
> doing:
>
>    while ((parseTask = channel.take()) != STOP_TASK) { // just an example
>        executeor.execute(new ParsingTask(parseTask));
>    }

Just a note to the general audience that in this classic usage, the executor
repeatedly executes the same task logic, it just uses a different task
instance to hold the data for the current execution. This all seems to boil
down to how the current task execution gets its data.

Cheers,
David Holmes


From alarmnummer at gmail.com  Mon Jul 10 03:10:30 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 09:10:30 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEPHGPAA.dcholmes@optusnet.com.au>
References: <1466c1d60607092340x32143033w4a13c014ca91dba1@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEPHGPAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607100010y35dbadd2m9e6f9fb6221578b0@mail.gmail.com>

On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> Peter,
>
> Then it seems to me that what you are doing is going to extreme lengths to
> avoid creating a task instance per page.
I don't think I'm going to extreme lenghts. Creating a task instance
per page and resubmitting it I find more unnatural than using a
repeater. I'm still learning (a lot) about concurrency control and I
need structure that make it clear what I'm doing (concurrency control
is complex enough)  The Repeater gives me an bstraction that feels
natural for certain tasks.

And essentialy, a repeater or an executor with a copy queue is the
same. The copyqueue can be seen as an 'awaitablereference' because it
blocks if no value is available. And it sends back the same value if
one is available. So there is not much difference between the two
approaches.

I just needs something that feels more natural and gives me some
control on stuff I don't have with executors (like being
strict/nonstrict with concurrent tasks).

And I'm not a concurrency guru, I just love to work and think about
it. And that is why I need abstractions that feel natural.

Most "classic" executor usage in
> producer consumer problems involves executing the same task logic all the
> time - what changes is the data that the task operates on. You can easily
> reuse tasks instances if this generates too much garbage - afterall you only
> need as many task instances as there are worker threads.


>
> At the moment, based on what I'm reading, the repeater seems to be a
> solution to a problem of your own creation.
>
> Sorry if I'm still missing some issues here - lack of context always clouds
> such discussions. The discussions are enjoyable though. :)
>
> Cheers,
> David
>
> > -----Original Message-----
> > From: Peter Veentjer [mailto:alarmnummer at gmail.com]
> > Sent: Monday, 10 July 2006 4:41 PM
> > To: dholmes at ieee.org
> > Subject: Re: [concurrency-interest] Fwd: ThreadPoolTask
> >
> >
> > The parseSingleMessage looks like this:
> >
> > void parseSingleMessage(){
> >     Page page = pageInputChannel.take();
> >     try{
> >          ParsedPage parsedPage = parse(page);
> >          successOutputChannel.put(parsedPage);
> >     }catch(ParseException ex){
> >           errorOutputChannel.put(...);
> >     }
> > }
> >
> > The parser doesn't do any looping itself.
> >
> > This makes it very easy to test such components.
> >
> > > So if I'm understanding this right, what you have done is to invert the
> > > classic producer consumer loop so that instead of having a
> > consumer thread
> > > doing:
> > >
> > >    while ((parseTask = channel.take()) != STOP_TASK) { // just
> > an example
> > >        executeor.execute(new ParsingTask(parseTask));
> > >    }
> > >
> > > Your "executor" instead has worker threads that executes the same task
> > > instance that has a blocking run() method of the form:
> > >
> > >    while ((parseTask = channel.take()) != STOP_TASK) { // just
> > an example
> > >        parse(parseTask);
> > >    }
> > >
> > > Is that right?
> > >
> > > Cheers,
> > > David
> > >
> > >
>
>

From alarmnummer at gmail.com  Mon Jul 10 03:15:55 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Jul 2006 09:15:55 +0200
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEPHGPAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEPGGPAA.dcholmes@optusnet.com.au>
	<NFBBKALFDCPFIDBNKAPCMEPHGPAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607100015k5f7059cfoafce12c7be306d3f@mail.gmail.com>

With your example you need also an extra thread to suck on the channel
to retrieve messages and submit the task to the executor.

The executor is good for a push model and the repeater for a pull model.

On 7/10/06, David Holmes <dcholmes at optusnet.com.au> wrote:
> I wrote:
> > So if I'm understanding this right, what you have done is to invert the
> > classic producer consumer loop so that instead of having a consumer thread
> > doing:
> >
> >    while ((parseTask = channel.take()) != STOP_TASK) { // just an example
> >        executeor.execute(new ParsingTask(parseTask));
> >    }
>
> Just a note to the general audience that in this classic usage, the executor
> repeatedly executes the same task logic, it just uses a different task
> instance to hold the data for the current execution. This all seems to boil
> down to how the current task execution gets its data.
>
> Cheers,
> David Holmes
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From moran at gigaspaces.com  Mon Jul 10 05:05:24 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Mon, 10 Jul 2006 11:05:24 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock
 backport	non-matching signature
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>
Message-ID: <44B21854.1070106@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060710/fc2fbc80/attachment.html 

From holger at wizards.de  Mon Jul 10 11:39:05 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Mon, 10 Jul 2006 17:39:05 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport
 non-matching signature
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>
Message-ID: <44B27499.4070506@wizards.de>

David Holmes wrote:
> Holger Hoffstatte writes:
>> Maybe I'm missing something but why does the u.c ReentrantReadWriteLock
>> return the static inner class instead of the Read/WriteLock interfaces in
>> the first place?
> 
> I thought it was because the implementation classes had additional
> house-keeping methods that are not part of the Lock interface. But that
> isn't actually the case. The idea being that you could just type those
> classes directly without having to do a cast.

Maybe it was just an oversight. Still, the whole point of having
interfaces is to decouple from the concrete class. I remember when I tried
to make the backport run (at least partly) on native j.u.c. this was one
of the primary showstoppers, at least for me.

>> The incompatibility is a serious problem for everybody using
>> retrotranslator or -weaver, and will likely just force people to continue
>> using the backport.
> 
> I'm not familiar with those tools - what do they do? And why does this cause
> them a problem? Do they try to match j.u.c signatures to those found in the
> backport?

(see e.g. http://retrotranslator.sourceforge.net/)

Both wrangle 1.5-compiled classes back to 1.4 via bytecode rewriting,
either statically or at load time. In the case of the concurrent classes
that's pretty simple since just the package names have to be changed;
everything else is done by a small extension jar that contains the
appropriate new classes and methods, including annotations, the valueOf
wrapper caches etc. This is a highly efficient way to use quite a few good
parts of 1.5 and still deliver 1.4-compatible products to clients.

Regarding the incompatibility it seems Moran has found a good solution by
just referring to the interface in client code. (phew!)

cheers
Holger

From moran at gigaspaces.com  Tue Jul 11 04:22:33 2006
From: moran at gigaspaces.com (Moran Avigdor)
Date: Tue, 11 Jul 2006 10:22:33 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock backport
 non-matching signature
In-Reply-To: <44B27499.4070506@wizards.de>
References: <NFBBKALFDCPFIDBNKAPCKEPCGPAA.dcholmes@optusnet.com.au>
	<44B27499.4070506@wizards.de>
Message-ID: <44B35FC9.3050407@gigaspaces.com>

An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060711/722fbaa2/attachment.html 

From brian at quiotix.com  Tue Jul 11 16:26:14 2006
From: brian at quiotix.com (Brian Goetz)
Date: Tue, 11 Jul 2006 16:26:14 -0400
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
Message-ID: <44B40966.50908@quiotix.com>

>> Re auto-creation of pools, what is wrong with simply starting out with the
>> max-intended size? After all there is no cost associated with idle threads
> is
>> there?
> 
> Sure there is - they use up OS threads, stack space etc. If they didn't we
> wouldn't need thread pools we would just keep as many idle threads as we
> wanted.

Yes, and don't underestimate these costs!

On Linux versions prior to NTPL integration (three or four years ago?) 
there was an OS-imposed limit of less than 1000 threads per process. 
Other OSes may have similar limits.

Even ignoring OS limits, threads use memory and address space for their 
stacks.  Defaults are to use a few hundred K for stack space for each 
thread.  Dividing 256K (probably less than the default) into a 32 bit 
address space yields a hard cap of 16000 threads before you run out of 
address space -- ignoring whether or not you have enough memory to 
actually _use_ the threads.  (And in reality, much of that address space 
is not available to you, so the limit is lower.)

Threads are relatively expensive, that's why they are pooled.

From dhanji at gmail.com  Tue Jul 11 18:11:40 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 12 Jul 2006 08:11:40 +1000
Subject: [concurrency-interest] missed deadlines.
In-Reply-To: <44B40966.50908@quiotix.com>
References: <NFBBKALFDCPFIDBNKAPCEEOAGPAA.dcholmes@optusnet.com.au>
	<44B40966.50908@quiotix.com>
Message-ID: <aa067ea10607111511t4b51e317na39a859f366e329@mail.gmail.com>

On 7/12/06, Brian Goetz <brian at quiotix.com> wrote:
>
> >> Re auto-creation of pools, what is wrong with simply starting out with
> the
> >> max-intended size?
>
> Threads are relatively expensive, that's why they are pooled.
>

Yea thats fair about the space tradeoff, however the point I was getting at
was that since ScheduledThreadPoolExecutor does not allow for dynamically
growing the pool, you were better off starting at the maximum intended size.


In the context of the original questioner I believe he wanted to rig some
way of starting with a smaller sized STPE pool and resizing it later.  I
certainly did NOT imply that corePoolSize should be done away with. =)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060712/94bdd37b/attachment.html 

From dcholmes at optusnet.com.au  Mon Jul 10 22:58:11 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 11 Jul 2006 12:58:11 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607100010y35dbadd2m9e6f9fb6221578b0@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEPOGPAA.dcholmes@optusnet.com.au>

Peter,

> The Repeater gives me an bstraction that feels
> natural for certain tasks.

As I said previously I don't disagree with this. My point was that I still
think you can build your repeater out of an executor.

I also think some of the examples don't need to be thought of in terms of
Repeater, but that's just my view of the world :)

Cheers,
David


From dcholmes at optusnet.com.au  Mon Jul 10 22:53:33 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 11 Jul 2006 12:53:33 +1000
Subject: [concurrency-interest] Fwd: ThreadPoolTask
In-Reply-To: <1466c1d60607100015k5f7059cfoafce12c7be306d3f@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEPOGPAA.dcholmes@optusnet.com.au>

Peter Veentjer writes:
> With your example you need also an extra thread to suck on the channel
> to retrieve messages and submit the task to the executor.
>
> The executor is good for a push model and the repeater for a pull model.

I disagree. Having only one thread blocking waiting for new work is
typically a desirable characteristic. But there is no reason that the pool
threads can't block waiting for work either - depends on whether your pool
is dedicated to this kind of task or not.

Semantically you have to decide whether a "task" represents a one-off action
"process this data", or it is a repetitive action "keep processing data".

Cheers,
David


From dcholmes at optusnet.com.au  Mon Jul 10 22:37:13 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 11 Jul 2006 12:37:13 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matching signature
In-Reply-To: <44B27499.4070506@wizards.de>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEPNGPAA.dcholmes@optusnet.com.au>

Holger Hoffstatte writes:
> Maybe it was just an oversight. Still, the whole point of having
> interfaces is to decouple from the concrete class. I remember when I tried
> to make the backport run (at least partly) on native j.u.c. this was one
> of the primary showstoppers, at least for me.

co-variant return types means we can get the best of both worlds. The class
can declare that it returns a more specific type that the client may choose
to use, if there is something more specific that the client wants to use.
But the client is free to declare their variables as the less specific ie
interface, type.

This is no different to doing:

ReentrantLock l = new ReentrantLock();

rather than:

Lock l = new ReentrantLock();

You get to choose the type of your variables.

> Regarding the incompatibility it seems Moran has found a good solution by
> just referring to the interface in client code. (phew!)

That's good.

Cheers,
David


From dhanji at gmail.com  Thu Jul 13 19:03:19 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Fri, 14 Jul 2006 09:03:19 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matching signature
In-Reply-To: <NFBBKALFDCPFIDBNKAPCEEPNGPAA.dcholmes@optusnet.com.au>
References: <44B27499.4070506@wizards.de>
	<NFBBKALFDCPFIDBNKAPCEEPNGPAA.dcholmes@optusnet.com.au>
Message-ID: <aa067ea10607131603p3f655633k652589fc371377ec@mail.gmail.com>

Somewhat off topic--does anyone know if covariant return types support
boxing for primitives?
For instance can I return Serializable on an overriden int method?
(eclipse complains, but I know eclipse has plenty of bugs with its
"intelligent" sensing features)

On 7/11/06, David Holmes <dcholmes at optusnet.com.au> wrote:
>
> Holger Hoffstatte writes:
> > Maybe it was just an oversight. Still, the whole point of having
> > interfaces is to decouple from the concrete class. I remember when I
> tried
> > to make the backport run (at least partly) on native j.u.c. this was one
> > of the primary showstoppers, at least for me.
>
> co-variant return types means we can get the best of both worlds. The
> class
> can declare that it returns a more specific type that the client may
> choose
> to use, if there is something more specific that the client wants to use.
> But the client is free to declare their variables as the less specific ie
> interface, type.
>
> This is no different to doing:
>
> ReentrantLock l = new ReentrantLock();
>
> rather than:
>
> Lock l = new ReentrantLock();
>
> You get to choose the type of your variables.
>
> > Regarding the incompatibility it seems Moran has found a good solution
> by
> > just referring to the interface in client code. (phew!)
>
> That's good.
>
> Cheers,
> David
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060714/91f0205d/attachment.html 

From dcholmes at optusnet.com.au  Fri Jul 14 00:06:24 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 14 Jul 2006 14:06:24 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matching signature
In-Reply-To: <aa067ea10607131603p3f655633k652589fc371377ec@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEBMHAAA.dcholmes@optusnet.com.au>

Hmm that was a weird three-day lag in the emails getting through :)


No covariant return types don't support any coercion of the return type, the
overriding method's return type must be a subtype of the overridden method.

David
  -----Original Message-----
  From: Dhanji R. Prasanna [mailto:dhanji at gmail.com]
  Sent: Friday, 14 July 2006 9:03 AM
  To: dholmes at ieee.org
  Cc: Holger Hoffstatte; concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] ReentrantReadWriteLock backport
non-matching signature


  Somewhat off topic--does anyone know if covariant return types support
boxing for primitives?
  For instance can I return Serializable on an overriden int method?
  (eclipse complains, but I know eclipse has plenty of bugs with its
"intelligent" sensing features)


  On 7/11/06, David Holmes <dcholmes at optusnet.com.au> wrote:
    Holger Hoffstatte writes:
    > Maybe it was just an oversight. Still, the whole point of having
    > interfaces is to decouple from the concrete class. I remember when I
tried
    > to make the backport run (at least partly) on native j.u.c. this was
one
    > of the primary showstoppers, at least for me.

    co-variant return types means we can get the best of both worlds. The
class
    can declare that it returns a more specific type that the client may
choose
    to use, if there is something more specific that the client wants to
use.
    But the client is free to declare their variables as the less specific
ie
    interface, type.

    This is no different to doing:

    ReentrantLock l = new ReentrantLock();

    rather than:

    Lock l = new ReentrantLock();

    You get to choose the type of your variables.

    > Regarding the incompatibility it seems Moran has found a good solution
by
    > just referring to the interface in client code. (phew!)

    That's good.

    Cheers,
    David

    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at altair.cs.oswego.edu
    http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060714/e6da23bb/attachment.html 

From forax at univ-mlv.fr  Fri Jul 14 15:49:47 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri, 14 Jul 2006 21:49:47 +0200
Subject: [concurrency-interest] ReentrantReadWriteLock
 backport	non-matching signature
In-Reply-To: <aa067ea10607131603p3f655633k652589fc371377ec@mail.gmail.com>
References: <44B27499.4070506@wizards.de>	<NFBBKALFDCPFIDBNKAPCEEPNGPAA.dcholmes@optusnet.com.au>
	<aa067ea10607131603p3f655633k652589fc371377ec@mail.gmail.com>
Message-ID: <44B7F55B.7000401@univ-mlv.fr>

Dhanji R. Prasanna wrote:

> Somewhat off topic--does anyone know if covariant return types support 
> boxing for primitives?
> For instance can I return Serializable on an overriden int method?

your example is strange, Serializable is not  a subtype of int or even 
Integer.

JLS just allow covariant return type between objects, the idea behind is 
that the generated
bridge method can delegating but is not allowed to perform any processing
(perhaps in order to be suppressed at runtime by an intelligent VM)
so by example, this code doesn't compile :
class A {
  int f() {return 2;}
}
class B extends A {
  double f() { return 3.0; }
}

> (eclipse complains, but I know eclipse has plenty of bugs with its 
> "intelligent" sensing features)

eclipse use a builtin compiler and not javac so the bugs are not the same :)

>
> On 7/11/06, *David Holmes* <dcholmes at optusnet.com.au 
> <mailto:dcholmes at optusnet.com.au>> wrote:
>
>     Holger Hoffstatte writes:
>     > Maybe it was just an oversight. Still, the whole point of having
>     > interfaces is to decouple from the concrete class. I remember
>     when I tried
>     > to make the backport run (at least partly) on native j.u.c. this
>     was one
>     > of the primary showstoppers, at least for me.
>
>     co-variant return types means we can get the best of both worlds.
>     The class
>     can declare that it returns a more specific type that the client
>     may choose
>     to use, if there is something more specific that the client wants
>     to use.
>     But the client is free to declare their variables as the less
>     specific ie
>     interface, type.
>
>     This is no different to doing:
>
>     ReentrantLock l = new ReentrantLock();
>
>     rather than:
>
>     Lock l = new ReentrantLock();
>
>     You get to choose the type of your variables.
>
>     > Regarding the incompatibility it seems Moran has found a good
>     solution by
>     > just referring to the interface in client code. (phew!)
>
>     That's good.
>
>     Cheers,
>     David
>
R?mi Forax


From dhanji at gmail.com  Fri Jul 14 19:45:41 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sat, 15 Jul 2006 09:45:41 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock backport
	non-matching signature
In-Reply-To: <44B7F55B.7000401@univ-mlv.fr>
References: <44B27499.4070506@wizards.de>
	<NFBBKALFDCPFIDBNKAPCEEPNGPAA.dcholmes@optusnet.com.au>
	<aa067ea10607131603p3f655633k652589fc371377ec@mail.gmail.com>
	<44B7F55B.7000401@univ-mlv.fr>
Message-ID: <aa067ea10607141645l7b416d5cib841b4453ebae9a8@mail.gmail.com>

On 7/15/06, R?mi Forax <forax at univ-mlv.fr> wrote:
> Dhanji R. Prasanna wrote:
>
> > Somewhat off topic--does anyone know if covariant return types support
> > boxing for primitives?
> > For instance can I return Serializable on an overriden int method?
>
> your example is strange, Serializable is not  a subtype of int or even
> Integer.

Woops, reverse them--the question should have read "can you return int
on a Serializable?" (as Integer is a subtype of Serializable)
and the answer is no.


From dcholmes at optusnet.com.au  Fri Jul 14 22:25:20 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat, 15 Jul 2006 12:25:20 +1000
Subject: [concurrency-interest] ReentrantReadWriteLock
	backportnon-matching signature
In-Reply-To: <aa067ea10607141645l7b416d5cib841b4453ebae9a8@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIECIHAAA.dcholmes@optusnet.com.au>

> Woops, reverse them--the question should have read "can you return int
> on a Serializable?" (as Integer is a subtype of Serializable)
> and the answer is no.

I should have said however, that you could always return Integer for
Serializable and utilize autoboxing to get to/from int. Of course code that
only knows about the Serializable return type will require an explicit
Integer cast.

But this is really O-T now :)

David


From alarmnummer at gmail.com  Sun Jul 16 05:20:17 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sun, 16 Jul 2006 11:20:17 +0200
Subject: [concurrency-interest] thoughts about stackless languages?
Message-ID: <1466c1d60607160220w315bc9ecl901c7bdd0918894a@mail.gmail.com>

I was reading an article about stackless python. A stackless language
should be better scalable, more performant and more intuitive than the
classic multithreaded approach. What are the opinions about adding
stackless functionality to the java vm? Is it possible? Is it
desirable? Is it overrated?

From joe.bowbeer at gmail.com  Sun Jul 16 12:39:48 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Sun, 16 Jul 2006 09:39:48 -0700
Subject: [concurrency-interest] thoughts about stackless languages?
In-Reply-To: <1466c1d60607160220w315bc9ecl901c7bdd0918894a@mail.gmail.com>
References: <1466c1d60607160220w315bc9ecl901c7bdd0918894a@mail.gmail.com>
Message-ID: <31f2a7bd0607160939t441714d5r3f339c69cc77d484@mail.gmail.com>

On 7/16/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I was reading an article about stackless python. A stackless language
> should be better scalable, more performant and more intuitive than the
> classic multithreaded approach. What are the opinions about adding
> stackless functionality to the java vm? Is it possible? Is it
> desirable? Is it overrated?
>

Without a stack, flow of control is based on continuation passing style?

http://en.wikipedia.org/wiki/Continuation_passing_style

I think the "lazy" keyword in Oz is interesting, and its
implementation could be based on continuations.

"lazy" is covered in this short presentation on the design of Oz:

http://www.info.ucl.ac.be/~pvr/ircamTalk2006.pdf

It was interesting to me that mutable state and OO weren't mentioned
at all until the very end of the slides, and then were only mentioned
in passing (because, he claimed, mutable state is only needed for
modularity and none of the examples were big enough to need it).

Oz looks like fun.  I'd like to see it running on the JVM.

I saw this catchy title among the Oz papers, and was alarmed to read
that Peter Van Roy was discounting what I always considered to be a
sage verdict from Jim Waldo, et al:

Convergence in Language Design:
A Case of Lightning Striking Four Times in the Same Place

>From http://www.info.ucl.ac.be/~pvr/flopsPVRarticle.pdf

4 Network-Transparent Distributed Programming

This project was motivated by the desire to simplify distributed
programming by making a practical system that is both network
transparent and network aware. [...]

Some researchers have maintained that this cannot work; that network
transparency cannot be made practical, see, e.g., Waldo et al [28].
They cite four reasons: pointer arithmetic, partial failure, latency,
and concurrency. The first reason (pointer arithmetic) disappears if
the language has an abstract store. The second reason (partial
failure) requires a reflective fault model, which we designed for the
Distributed Oz language. The final two reasons (latency and
concurrency) lead to a layered language design. Let us examine each of
these reasons. Latency is a problem if the language relies primarily
on synchronized operations. In the terminology of Cardelli, latency is
a network awareness issue. The solution is that the language must make
asynchronous programming both simple and efficient.

--Joe

PS -

Scala is a language with an efficient "actor" implementation that does
run on the JVM.

http://en.wikipedia.org/wiki/Scala_programming_language

From dhanji at gmail.com  Sun Jul 16 21:37:21 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 17 Jul 2006 11:37:21 +1000
Subject: [concurrency-interest] thoughts about stackless languages?
In-Reply-To: <31f2a7bd0607160939t441714d5r3f339c69cc77d484@mail.gmail.com>
References: <1466c1d60607160220w315bc9ecl901c7bdd0918894a@mail.gmail.com>
	<31f2a7bd0607160939t441714d5r3f339c69cc77d484@mail.gmail.com>
Message-ID: <aa067ea10607161837l1841ba49ycb38e447a4a0eba4@mail.gmail.com>

On 7/17/06, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:
> On 7/16/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > classic multithreaded approach. What are the opinions about adding
> > stackless functionality to the java vm? Is it possible? Is it
> > desirable? Is it overrated?
> >
>

lazy evaluation in java would be great! You could work with infinitely
sized lists or arrays and not worry about memory issues.

Im really not sure how mutable states or scoped states are achieved in
a stackless machine, but I would assume they are "faked" (with
continuations as joe suggested). Python achieves this to a certain
extent even in its stackful version with the "yield" keyword.
But a zero-side effect paradigm, I feel, is at odds with the
imperative and OO bent of java.

Consider that a stackless machine also makes iteration difficult,
which is why looping is  faked with tail-recursion in languages like
haskell.

As for asynchronous programming, I think that can be achieved much
more naturally in java with the use of selectors (as is done in
java.nio). You're still a multithreaded language under the hood, but
it is an elegant solution.

From mike.quilleash at subexazure.com  Tue Jul 18 09:05:10 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Tue, 18 Jul 2006 09:05:10 -0400
Subject: [concurrency-interest] Visibility of lazy intialisation
Message-ID: <DAE04D9F6FD21448A220918A522FB60E0219935F@MI8NYCMAIL15.Mi8.com>

I have a static singleton that I want to lazy initialise.
 
Currently the code I have looks like this
 
 
private static Helper helper = null;
 
public synchronized static Helper getHelper() throws HelperException
{
  if ( helper == null )
  {
    Helper localHelper = new Helper();
    localHelper.initialise();
    helper = locaHelper;
  }
 
  return helper;
}
 
 
The initialise() function may throw an exception which I want to
propogate up and catch somewhere higher.  I'm wondering if it definately
the case that the helper variable will NOT be null if an exception is
thrown in the Helper constructor or initialise().  Can the JVM/OS/CPU
reorder the instructions so that helper is set before initialise is
executed?
 
Should I instead be using one of the static initialise idions, like a
static class?  My problem would then become how to catch the initialise
when it is in a static code block.
 
Cheers for any help/advice.
 

 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060718/906d3156/attachment.html 

From giuliano.mega at gmail.com  Tue Jul 18 10:18:12 2006
From: giuliano.mega at gmail.com (Giuliano Mega)
Date: Tue, 18 Jul 2006 11:18:12 -0300
Subject: [concurrency-interest] Visibility of lazy intialisation
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E0219935F@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E0219935F@MI8NYCMAIL15.Mi8.com>
Message-ID: <7547a9ff0607180718tcfbd368l492ae9c76a9aaaca@mail.gmail.com>

Hi Mike,

I may be wrong (in which case I'm sure I'll be corrected briefly), but
since correctly synchronized programs should appear to execute in
program order, I don't think that 'helper' could appear as non-null to
anyone (at least not in calls to 'getHelper'). You have to ensure,
however, that every access to helper occur inside a synchronized block
that refers to the same lock.

Best regards,

On 7/18/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>
>
> I have a static singleton that I want to lazy initialise.
>
> Currently the code I have looks like this
>
>
> private static Helper helper = null;
>
> public synchronized static Helper getHelper() throws HelperException
> {
>   if ( helper == null )
>   {
>     Helper localHelper = new Helper();
>     localHelper.initialise();
>     helper = locaHelper;
>   }
>
>   return helper;
> }
>
>
> The initialise() function may throw an exception which I want to propogate
> up and catch somewhere higher.  I'm wondering if it definately the case that
> the helper variable will NOT be null if an exception is thrown in the Helper
> constructor or initialise().  Can the JVM/OS/CPU reorder the instructions so
> that helper is set before initialise is executed?
>
> Should I instead be using one of the static initialise idions, like a static
> class?  My problem would then become how to catch the initialise when it is
> in a static code block.
>
> Cheers for any help/advice.
>
>
>  This e-mail is bound by the terms and conditions described at
> http://www.subexazure.com/mail-disclaimer.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


-- 
Giuliano Mega <giuliano at ime.usp.br>

From mike.quilleash at subexazure.com  Tue Jul 18 11:01:15 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Tue, 18 Jul 2006 11:01:15 -0400
Subject: [concurrency-interest] Visibility of lazy intialisation
Message-ID: <DAE04D9F6FD21448A220918A522FB60E02199519@MI8NYCMAIL15.Mi8.com>

I will only ever access the helper through getHelper() and Helper itself
can assumed to be threadsafe.  I just wonder if the following is
possible

1) getHelper() is called 
2) helper == null
3) localHelper created
4) helper = localHelper
5) localHelper.initialise()

Note 4 and 5 are out of order.  Can this happen or not?  I'm worried
about .initialise() throwing an exception and if it does can it leave
the helper variable not-null.

Cheers.

-----Original Message-----
From: Giuliano Mega [mailto:giuliano.mega at gmail.com] 
Sent: 18 July 2006 15:18
To: Mike Quilleash 
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Visibility of lazy intialisation

Hi Mike,

I may be wrong (in which case I'm sure I'll be corrected briefly), but
since correctly synchronized programs should appear to execute in
program order, I don't think that 'helper' could appear as non-null to
anyone (at least not in calls to 'getHelper'). You have to ensure,
however, that every access to helper occur inside a synchronized block
that refers to the same lock.

Best regards,

On 7/18/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>
>
> I have a static singleton that I want to lazy initialise.
>
> Currently the code I have looks like this
>
>
> private static Helper helper = null;
>
> public synchronized static Helper getHelper() throws HelperException {
>   if ( helper == null )
>   {
>     Helper localHelper = new Helper();
>     localHelper.initialise();
>     helper = locaHelper;
>   }
>
>   return helper;
> }
>
>
> The initialise() function may throw an exception which I want to 
> propogate up and catch somewhere higher.  I'm wondering if it 
> definately the case that the helper variable will NOT be null if an 
> exception is thrown in the Helper constructor or initialise().  Can 
> the JVM/OS/CPU reorder the instructions so that helper is set before
initialise is executed?
>
> Should I instead be using one of the static initialise idions, like a 
> static class?  My problem would then become how to catch the 
> initialise when it is in a static code block.
>
> Cheers for any help/advice.
>
>
>  This e-mail is bound by the terms and conditions described at 
> http://www.subexazure.com/mail-disclaimer.html
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>


--
Giuliano Mega <giuliano at ime.usp.br>


 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From pugh at cs.umd.edu  Tue Jul 18 11:41:42 2006
From: pugh at cs.umd.edu (Bill Pugh)
Date: Tue, 18 Jul 2006 08:41:42 -0700
Subject: [concurrency-interest] Visibility of lazy intialisation
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E02199519@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E02199519@MI8NYCMAIL15.Mi8.com>
Message-ID: <0C3BC8B8-94F1-4C15-B54B-B6B8E8E5BF64@cs.umd.edu>

Nope. Absolutely can't happen in any correctly working JVM.
And I haven't heard of any incorrectly working JVM's allowing this to  
happen.

Java semantics require that if a statement S1 throws an exception,  
none of
the actions that would be performed by statements after S1 are  
allowed to be visible.

	Bill


On Jul 18, 2006, at 8:01 AM, Mike Quilleash wrote:

> I will only ever access the helper through getHelper() and Helper  
> itself
> can assumed to be threadsafe.  I just wonder if the following is
> possible
>
> 1) getHelper() is called
> 2) helper == null
> 3) localHelper created
> 4) helper = localHelper
> 5) localHelper.initialise()
>
> Note 4 and 5 are out of order.  Can this happen or not?  I'm worried
> about .initialise() throwing an exception and if it does can it leave
> the helper variable not-null.
>
> Cheers.
>
> -----Original Message-----
> From: Giuliano Mega [mailto:giuliano.mega at gmail.com]
> Sent: 18 July 2006 15:18
> To: Mike Quilleash
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Visibility of lazy intialisation
>
> Hi Mike,
>
> I may be wrong (in which case I'm sure I'll be corrected briefly), but
> since correctly synchronized programs should appear to execute in
> program order, I don't think that 'helper' could appear as non-null to
> anyone (at least not in calls to 'getHelper'). You have to ensure,
> however, that every access to helper occur inside a synchronized block
> that refers to the same lock.
>
> Best regards,
>
> On 7/18/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>>
>>
>> I have a static singleton that I want to lazy initialise.
>>
>> Currently the code I have looks like this
>>
>>
>> private static Helper helper = null;
>>
>> public synchronized static Helper getHelper() throws  
>> HelperException {
>>   if ( helper == null )
>>   {
>>     Helper localHelper = new Helper();
>>     localHelper.initialise();
>>     helper = locaHelper;
>>   }
>>
>>   return helper;
>> }
>>
>>
>> The initialise() function may throw an exception which I want to
>> propogate up and catch somewhere higher.  I'm wondering if it
>> definately the case that the helper variable will NOT be null if an
>> exception is thrown in the Helper constructor or initialise().  Can
>> the JVM/OS/CPU reorder the instructions so that helper is set before
> initialise is executed?
>>
>> Should I instead be using one of the static initialise idions, like a
>> static class?  My problem would then become how to catch the
>> initialise when it is in a static code block.
>>
>> Cheers for any help/advice.
>>
>>
>>  This e-mail is bound by the terms and conditions described at
>> http://www.subexazure.com/mail-disclaimer.html
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
>
> --
> Giuliano Mega <giuliano at ime.usp.br>
>
>
>  This e-mail is bound by the terms and conditions described at  
> http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From Jan.Nielsen at sungardhe.com  Tue Jul 18 11:58:23 2006
From: Jan.Nielsen at sungardhe.com (Jan Nielsen)
Date: Tue, 18 Jul 2006 09:58:23 -0600
Subject: [concurrency-interest] Visibility of lazy intialisation
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E0219935F@MI8NYCMAIL15.Mi8.com>
Message-ID: <OF38847960.649049B4-ON872571AF.00575E43-872571AF.0057BD5B@sungardhe.com>

Mike,

For lazy initialization of singletons, consider using the Initialization 
on Demand Holder Idiom:

  http://en.wikipedia.org/wiki/Initialization_on_Demand_Holder_Idiom

-Jan

Jan Nielsen * System Architect * SunGard Higher Education * Tel +1 801 257 
4155 * Fax +1 801 485 6606 * jan.nielsen at sungardhe.com * www.sungardhe.com 
* 90 South 400 West, Suite 500, Salt Lake City, UT USA

CONFIDENTIALITY: This email (including any attachments) may contain 
confidential, proprietary and privileged information, and unauthorized 
disclosure or use is prohibited.  If you received this email in error, 
please notify the sender and delete this email from your system. Thank 
you.



"Mike Quilleash " <mike.quilleash at subexazure.com> 
Sent by: concurrency-interest-bounces at cs.oswego.edu
07/18/2006 07:05 AM

To
concurrency-interest at cs.oswego.edu
cc

Subject
[concurrency-interest] Visibility of lazy intialisation






I have a static singleton that I want to lazy initialise.
 
Currently the code I have looks like this
 
 
private static Helper helper = null;
 
public synchronized static Helper getHelper() throws HelperException
{
  if ( helper == null )
  {
    Helper localHelper = new Helper();
    localHelper.initialise();
    helper = locaHelper;
  }
 
  return helper;
}
 
 
The initialise() function may throw an exception which I want to propogate 
up and catch somewhere higher.  I'm wondering if it definately the case 
that the helper variable will NOT be null if an exception is thrown in the 
Helper constructor or initialise().  Can the JVM/OS/CPU reorder the 
instructions so that helper is set before initialise is executed?
 
Should I instead be using one of the static initialise idions, like a 
static class?  My problem would then become how to catch the initialise 
when it is in a static code block.
 
Cheers for any help/advice.
 
This e-mail is bound by the terms and conditions described at 
http://www.subexazure.com/mail-disclaimer.html
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



From mike.quilleash at subexazure.com  Tue Jul 18 11:54:19 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Tue, 18 Jul 2006 11:54:19 -0400
Subject: [concurrency-interest] Visibility of lazy intialisation
Message-ID: <DAE04D9F6FD21448A220918A522FB60E0219962E@MI8NYCMAIL15.Mi8.com>

Thanks for clearing that up.

Cheers for the help guys. 

-----Original Message-----
From: Bill Pugh [mailto:pugh at cs.umd.edu] 
Sent: 18 July 2006 16:42
To: Mike Quilleash 
Cc: Giuliano Mega; concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Visibility of lazy intialisation

Nope. Absolutely can't happen in any correctly working JVM.
And I haven't heard of any incorrectly working JVM's allowing this to
happen.

Java semantics require that if a statement S1 throws an exception, none
of the actions that would be performed by statements after S1 are
allowed to be visible.

	Bill


On Jul 18, 2006, at 8:01 AM, Mike Quilleash wrote:

> I will only ever access the helper through getHelper() and Helper 
> itself can assumed to be threadsafe.  I just wonder if the following 
> is possible
>
> 1) getHelper() is called
> 2) helper == null
> 3) localHelper created
> 4) helper = localHelper
> 5) localHelper.initialise()
>
> Note 4 and 5 are out of order.  Can this happen or not?  I'm worried 
> about .initialise() throwing an exception and if it does can it leave 
> the helper variable not-null.
>
> Cheers.
>
> -----Original Message-----
> From: Giuliano Mega [mailto:giuliano.mega at gmail.com]
> Sent: 18 July 2006 15:18
> To: Mike Quilleash
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Visibility of lazy intialisation
>
> Hi Mike,
>
> I may be wrong (in which case I'm sure I'll be corrected briefly), but

> since correctly synchronized programs should appear to execute in 
> program order, I don't think that 'helper' could appear as non-null to

> anyone (at least not in calls to 'getHelper'). You have to ensure, 
> however, that every access to helper occur inside a synchronized block

> that refers to the same lock.
>
> Best regards,
>
> On 7/18/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>>
>>
>> I have a static singleton that I want to lazy initialise.
>>
>> Currently the code I have looks like this
>>
>>
>> private static Helper helper = null;
>>
>> public synchronized static Helper getHelper() throws HelperException 
>> {
>>   if ( helper == null )
>>   {
>>     Helper localHelper = new Helper();
>>     localHelper.initialise();
>>     helper = locaHelper;
>>   }
>>
>>   return helper;
>> }
>>
>>
>> The initialise() function may throw an exception which I want to 
>> propogate up and catch somewhere higher.  I'm wondering if it 
>> definately the case that the helper variable will NOT be null if an 
>> exception is thrown in the Helper constructor or initialise().  Can 
>> the JVM/OS/CPU reorder the instructions so that helper is set before
> initialise is executed?
>>
>> Should I instead be using one of the static initialise idions, like a

>> static class?  My problem would then become how to catch the 
>> initialise when it is in a static code block.
>>
>> Cheers for any help/advice.
>>
>>
>>  This e-mail is bound by the terms and conditions described at 
>> http://www.subexazure.com/mail-disclaimer.html
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>
>
> --
> Giuliano Mega <giuliano at ime.usp.br>
>
>
>  This e-mail is bound by the terms and conditions described at 
> http://www.subexazure.com/mail-disclaimer.html
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html



From forax at univ-mlv.fr  Wed Jul 19 03:19:43 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Wed, 19 Jul 2006 09:19:43 +0200
Subject: [concurrency-interest] Visibility of lazy intialisation
In-Reply-To: <OF38847960.649049B4-ON872571AF.00575E43-872571AF.0057BD5B@sungardhe.com>
References: <OF38847960.649049B4-ON872571AF.00575E43-872571AF.0057BD5B@sungardhe.com>
Message-ID: <44BDDD0F.4090503@univ-mlv.fr>

Jan Nielsen a ?crit :
> Mike,
>
> For lazy initialization of singletons, consider using the Initialization 
> on Demand Holder Idiom:
>
>   http://en.wikipedia.org/wiki/Initialization_on_Demand_Holder_Idiom
>
> -Jan
>   
It's perhaps off topic but the code of the example can be improved.
The field LazyHolder.something doesn't need a public visibility
and is not declared final.

public class Something {
     private Something() {
     }
     
     private static class LazyHolder  {
       static final Something something = new Something();
     }
     
     public static Something getInstance() {
         return LazyHolder.something;
     }
 }

R?mi Forax


From alarmnummer at gmail.com  Wed Jul 19 10:50:18 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 19 Jul 2006 16:50:18 +0200
Subject: [concurrency-interest] javadoc upgrade for
	threadpoolexecutor.shutdown/shutdownnow
Message-ID: <1466c1d60607190750i12c5a76cyf2d15d8058d8e91f@mail.gmail.com>

I had a nice discussion with a colleague of mine about the
ThreadPoolExecutor and the shutdown/shutdownNow methods.

It wasn't clear that the shutdown method doesn't block but only
signals that the ThreadPoolExecutor  is going to shut down.

The shutdownNow method does block (untill all running tasks have
processed) and this wasn't very intuitive also.

So can the documentation be upgrades so they explain the blocking
behaviour of both methods?

From joe.bowbeer at gmail.com  Wed Jul 19 16:05:29 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 19 Jul 2006 13:05:29 -0700
Subject: [concurrency-interest] javadoc upgrade for
	threadpoolexecutor.shutdown/shutdownnow
In-Reply-To: <1466c1d60607190750i12c5a76cyf2d15d8058d8e91f@mail.gmail.com>
References: <1466c1d60607190750i12c5a76cyf2d15d8058d8e91f@mail.gmail.com>
Message-ID: <31f2a7bd0607191305s79108744o355d0ba298fb474c@mail.gmail.com>

On 7/19/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> I had a nice discussion with a colleague of mine about the
> ThreadPoolExecutor and the shutdown/shutdownNow methods.
>
> It wasn't clear that the shutdown method doesn't block but only
> signals that the ThreadPoolExecutor  is going to shut down.
>
> The shutdownNow method does block (untill all running tasks have
> processed) and this wasn't very intuitive also.
>
> So can the documentation be upgrades so they explain the blocking
> behaviour of both methods?
>

shutdownNow doesn't block either (and doesn't throw InterruptedException).

awaitTermination blocks (and throws InterruptedException).

We've just updated javadoc in ExecutorService, explaining what
shutdownNow does and adding a shutdownAndAwaitTermination example.

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ExecutorService.java

Is this sufficient, or should we add a link back to this in ThreadPoolExecutor?

--Joe

From forax at univ-mlv.fr  Fri Jul 21 08:30:18 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri, 21 Jul 2006 14:30:18 +0200
Subject: [concurrency-interest] Questions about ArrayDeque
Message-ID: <44C0C8DA.7070707@univ-mlv.fr>

I have take a look to java.util.ArrayDeque today, and i have some 
questions :

- Quoting the documentation :
  "This class is likely to be faster than {@link Stack} when used as a 
stack"
  I used to use an ArrayList to implement a stack and
  there is neither reference to ArrayList nor comparaison between
  ArrayList and ArrayDeque in the documentation
 
  Is ArrayList is faster than ArrayQueue when used as a stack ?

- I've found two methods (removeFirstOccurrence() and contains())
   with mostly the same code.
  Perhaps this code could be shared between them ?

R?mi Forax
  


 


From dl at cs.oswego.edu  Fri Jul 21 08:47:28 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Fri, 21 Jul 2006 08:47:28 -0400
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C0C8DA.7070707@univ-mlv.fr>
References: <44C0C8DA.7070707@univ-mlv.fr>
Message-ID: <44C0CCE0.9070806@cs.oswego.edu>

R?mi Forax wrote:
> I have take a look to java.util.ArrayDeque today, and i have some 
> questions :
> 
> - Quoting the documentation :
>   "This class is likely to be faster than {@link Stack} when used as a 
> stack"
>   I used to use an ArrayList to implement a stack and
>   there is neither reference to ArrayList nor comparaison between
>   ArrayList and ArrayDeque in the documentation
>  
>   Is ArrayList is faster than ArrayQueue when used as a stack ?
> 

ArrayDeque should be at least as fast as ArrayList when used as pure stack.
Please tell us if you find otherwise. If nothing else, ArrayDeque has more
appropriate method names for uses as stack and queue.


> - I've found two methods (removeFirstOccurrence() and contains())
>    with mostly the same code.
>   Perhaps this code could be shared between them ?

It is logistically tricky to share small bits of code within
core Java classes, since it can interfere with more important
goal of being able to completely replace internal implementations
of various classes over time.

-Doug




From forax at univ-mlv.fr  Fri Jul 21 10:07:18 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Fri, 21 Jul 2006 16:07:18 +0200
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C0CCE0.9070806@cs.oswego.edu>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>
Message-ID: <44C0DF96.5060503@univ-mlv.fr>

Doug Lea a ?crit :
> R?mi Forax wrote:
>> I have take a look to java.util.ArrayDeque today, and i have some 
>> questions :
>>
>> - Quoting the documentation :
>>   "This class is likely to be faster than {@link Stack} when used as 
>> a stack"
>>   I used to use an ArrayList to implement a stack and
>>   there is neither reference to ArrayList nor comparaison between
>>   ArrayList and ArrayDeque in the documentation
>>  
>>   Is ArrayList is faster than ArrayQueue when used as a stack ?
>>
>
> ArrayDeque should be at least as fast as ArrayList when used as pure 
> stack.
> Please tell us if you find otherwise. If nothing else, ArrayDeque has 
> more
> appropriate method names for uses as stack and queue.
Ok, else, ArrayList used toArray() in its constructor that takes a 
collection,
but ArrayDeque doesn't do the same trick, is there a reason ?

The code can be something like this one :
public ArrayDeque(Collection<? extends E> c) {
        int size=c.size();
        allocateElements(size);
        c.toArray(elements);
        tail=size;
}

>
>
>> - I've found two methods (removeFirstOccurrence() and contains())
>>    with mostly the same code.
>>   Perhaps this code could be shared between them ?
>
> It is logistically tricky to share small bits of code within
> core Java classes, since it can interfere with more important
> goal of being able to completely replace internal implementations
> of various classes over time.
Ok, it's an overall rule.

But in this peculiar case, the code that can be shared is precisely
a code related to the internal representation of ArrayDeque,
(it traverses the data structure to find the index of the first
occurence of an object).
So if the internal representation changes, this code may changed,
i don't see why it makes the class more difficult to maintain.

Is it because removeFirstOccurrence() is a method of Deque
and contains() a method of  Collection and you want
to keep them not linked.

>
> -Doug
>
>
R?mi Forax


From josh at bloch.us  Fri Jul 21 11:10:38 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 21 Jul 2006 08:10:38 -0700
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C0DF96.5060503@univ-mlv.fr>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>
	<44C0DF96.5060503@univ-mlv.fr>
Message-ID: <b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>

R?mi,


> Ok, else, ArrayList used toArray() in its constructor that takes a
> collection,
> but ArrayDeque doesn't do the same trick, is there a reason ?
>
> The code can be something like this one :
> public ArrayDeque(Collection<? extends E> c) {
>         int size=c.size();
>         allocateElements(size);
>         c.toArray(elements);
>         tail=size;
> }

Yes, there is a reason:  internally, ArrayDeque instances have arrays
whose size are a power of two, so the aforementioned trick wouldn't
work.

           Josh


From gregg at cytetech.com  Fri Jul 21 12:07:58 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 21 Jul 2006 11:07:58 -0500
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
References: <44C0C8DA.7070707@univ-mlv.fr>
	<44C0CCE0.9070806@cs.oswego.edu>	<44C0DF96.5060503@univ-mlv.fr>
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
Message-ID: <44C0FBDE.9020209@cytetech.com>



Joshua Bloch wrote:
> R?mi,
> 
> 
> 
>>Ok, else, ArrayList used toArray() in its constructor that takes a
>>collection,
>>but ArrayDeque doesn't do the same trick, is there a reason ?
>>
>>The code can be something like this one :
>>public ArrayDeque(Collection<? extends E> c) {
>>        int size=c.size();
>>        allocateElements(size);
>>        c.toArray(elements);
>>        tail=size;
>>}
> 
> 
> Yes, there is a reason:  internally, ArrayDeque instances have arrays
> whose size are a power of two, so the aforementioned trick wouldn't
> work.

It should be easy enough to find the correct power of two for allocating right? 
  Then the APIs would be consistent.  These odd implementation details creeping 
into the visible API really adds a lot of confusion.

Someones going to write some code to make it possible for them to stuff a 
Collection in.  Surely there's value in the class already having such an 
implementation?

Gregg Wonderly

From Martin.Buchholz at Sun.COM  Fri Jul 21 12:37:03 2006
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Fri, 21 Jul 2006 09:37:03 -0700
Subject: [concurrency-interest] Questions about ArrayDeque
Message-ID: <44C102AF.7060208@sun.com>

The code below is not correct if the argument collection c
changes in size while the constructor is running.

I tried to make the collection code more robust in the
face of such concurrent changes during mustang development.

6347106: (coll) Make ArrayList(Collection) more threadsafe
6355660: (coll) Vector(Collection) constructor is not thread safe
6394004: (coll) Thread-safety and Performance improvements to PriorityQueue

Martin

Josh/Remi write:

>Ok, else, ArrayList used toArray() in its constructor that takes a
>> collection,
>> but ArrayDeque doesn't do the same trick, is there a reason ?
>>
>> The code can be something like this one :
>> public ArrayDeque(Collection<? extends E> c) {
>>         int size=c.size();
>>         allocateElements(size);
>>         c.toArray(elements);
>>         tail=size;
>> }

Yes, there is a reason:  internally, ArrayDeque instances have arrays
whose size are a power of two, so the aforementioned trick wouldn't
work.


From josh at bloch.us  Fri Jul 21 12:40:53 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 21 Jul 2006 09:40:53 -0700
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C0FBDE.9020209@cytetech.com>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>
	<44C0DF96.5060503@univ-mlv.fr>
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
	<44C0FBDE.9020209@cytetech.com>
Message-ID: <b097ac510607210940u7b29ca38jec3ac909f0869e61@mail.gmail.com>

Gregg,

I'm not sure what you mean. R?mi was talking about implementation
details, not visible APIs.  He proposed a new implementation for an
existing constructor that was broken in two ways (one of which I
pointed out, and the other, Martin).

           Josh

On 7/21/06, Gregg Wonderly <gregg at cytetech.com> wrote:
>
>
> Joshua Bloch wrote:
> > R?mi,
> >
> >
> >
> >>Ok, else, ArrayList used toArray() in its constructor that takes a
> >>collection,
> >>but ArrayDeque doesn't do the same trick, is there a reason ?
> >>
> >>The code can be something like this one :
> >>public ArrayDeque(Collection<? extends E> c) {
> >>        int size=c.size();
> >>        allocateElements(size);
> >>        c.toArray(elements);
> >>        tail=size;
> >>}
> >
> >
> > Yes, there is a reason:  internally, ArrayDeque instances have arrays
> > whose size are a power of two, so the aforementioned trick wouldn't
> > work.
>
> It should be easy enough to find the correct power of two for allocating right?
>  Then the APIs would be consistent.  These odd implementation details creeping
> into the visible API really adds a lot of confusion.
>
> Someones going to write some code to make it possible for them to stuff a
> Collection in.  Surely there's value in the class already having such an
> implementation?
>
> Gregg Wonderly
>


From peger at automotive.com  Fri Jul 21 13:02:01 2006
From: peger at automotive.com (Patrick Eger)
Date: Fri, 21 Jul 2006 10:02:01 -0700
Subject: [concurrency-interest] Thread Pools
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1211E4E8@mail-001.corp.automotive.com>

Hi, I know this has come up again and again, (I think I brought it up
once or twice ;-) But are there any plans to add a
"preferExistingThreads()" to the ThreadPoolExecutor, to address the
issue of dynamic pool sizing, or is there any way I can extend these
classes to do such?

 

IE I would like a:

1) potentially infinite queue of tasks (currently using a
LinkedBlockingQueue)

2) executed by up to MAX threads concurrently

3) which go away after a period of inactivity, allowing the pool to
shrink to MIN (or zero) size

4) preferring to use already existing threads rather than creating new
ones

 

This is currently impossible with the current setup AFAICS; I have
continued to have to use my own thread pools because of this, though I
would love to switch to the standard JUC classes. #3 was covered in JDK
6 with the capability to allow core threads to timeout, but I cannot
find a way to make #4 possible with current JUC. The existing behaviour
will always end up creating CORE threads even though they are
unnecessary to execute existing work.

 

Thanks in advance for any replies.

 

 

Best Regards, 

 

Patrick

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060721/326e2546/attachment.html 

From gregg at cytetech.com  Fri Jul 21 13:57:50 2006
From: gregg at cytetech.com (Gregg Wonderly)
Date: Fri, 21 Jul 2006 12:57:50 -0500
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <b097ac510607210940u7b29ca38jec3ac909f0869e61@mail.gmail.com>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>	
	<44C0DF96.5060503@univ-mlv.fr>	
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>	
	<44C0FBDE.9020209@cytetech.com>
	<b097ac510607210940u7b29ca38jec3ac909f0869e61@mail.gmail.com>
Message-ID: <44C1159E.40202@cytetech.com>



Joshua Bloch wrote:
> I'm not sure what you mean. R?mi was talking about implementation
> details, not visible APIs.  He proposed a new implementation for an
> existing constructor that was broken in two ways (one of which I
> pointed out, and the other, Martin).

I think I missed part of the conversation.  Sorry for the interjection.

Gregg Wonderly

From joe.bowbeer at gmail.com  Fri Jul 21 15:54:12 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Fri, 21 Jul 2006 12:54:12 -0700
Subject: [concurrency-interest] Thread Pools
In-Reply-To: <31f2a7bd0607211222y2d52f33ct5e055fde588247e0@mail.gmail.com>
References: <A7487BEC58632D46B8C7E8BC69B3EB1211E4E8@mail-001.corp.automotive.com>
	<31f2a7bd0607211222y2d52f33ct5e055fde588247e0@mail.gmail.com>
Message-ID: <31f2a7bd0607211254h3edc99ebg8a5ab5aea5d5ab8b@mail.gmail.com>

On 7/21/06, Patrick Eger <peger at automotive.com> wrote:
>
> Hi, I know this has come up again and again, (I think I brought it up once
> or twice ;-) But are there any plans to add a "preferExistingThreads()" to
> the ThreadPoolExecutor, to address the issue of dynamic pool sizing, or is
> there any way I can extend these classes to do such?
>
> IE I would like a:
>
> 1) potentially infinite queue of tasks (currently using a
> LinkedBlockingQueue)
>
> 2) executed by up to MAX threads concurrently
>
> 3) which go away after a period of inactivity, allowing the pool to shrink
> to MIN (or zero) size
>
> 4) preferring to use already existing threads rather than creating new ones
>
> This is currently impossible with the current setup AFAICS; I have continued
> to have to use my own thread pools because of this, though I would love to
> switch to the standard JUC classes. #3 was covered in JDK 6 with the
> capability to allow core threads to timeout, but I cannot find a way to make
> #4 possible with current JUC. The existing behaviour will always end up
> creating CORE threads even though they are unnecessary to execute existing
> work.
>
> Thanks in advance for any replies.
>

To recap, the problem you're trying to overcome is that TPE prefers
(1) to create a core thread, (2) queue task, (3) create additional
thread.

In other words, MAX_THREADS is effectively ignored if queue is unbounded:

    ExecutorService newEgerThreadPool() {
        return new ThreadPoolExecutor(0, MAX_THREADS,
                                      60L, TimeUnit.SECONDS,
                                      new LinkedQueue<Runnable>());
    }

So you're requesting an option to switch priority of 2 and 3.

I can't address that but I do see a new allowCoreThreadTimeOut method
in the pipeline that might have the same effect:

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/
  => java/util/concurrent/ThreadPoolExecutor.java

pool.allowCoreThreadTimeOut(true) can be used to apply the time-out
policy to core threads as well, so long as the keepAliveTime value is
non-zero.

I think this might work:

    ExecutorService newEgerThreadPool() {
        ThreadPoolExecutor pool =
            new ThreadPoolExecutor(MAX_THREADS, MAX_THREADS,
                                      60L, TimeUnit.SECONDS,
                                      new LinkedQueue<Runnable>());
        pool.allowCoreThreadTimeOut(true);
        return pool;
    }

--Joe

From forax at univ-mlv.fr  Fri Jul 21 18:06:06 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Sat, 22 Jul 2006 00:06:06 +0200
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>	
	<44C0DF96.5060503@univ-mlv.fr>
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
Message-ID: <44C14FCE.9070703@univ-mlv.fr>

Joshua Bloch wrote:

> R?mi,
>
>
>> Ok, else, ArrayList used toArray() in its constructor that takes a
>> collection,
>> but ArrayDeque doesn't do the same trick, is there a reason ?
>>
>> The code can be something like this one :
>> public ArrayDeque(Collection<? extends E> c) {
>>         int size=c.size();
>>         allocateElements(size);
>>         c.toArray(elements);
>>         tail=size;
>> }
>
>
> Yes, there is a reason:  internally, ArrayDeque instances have arrays
> whose size are a power of two, so the aforementioned trick wouldn't
> work.

To josh, perhaps i am tired, but for me,  allocateElements() always 
allocates
a power of two size. The other invariant is that head and tail must be 
different
if the size is not empty, it seems to be the case.
So i continue to think that this implementation is valid.

To martin, i've always prefer an implementation that raise an exception
to a one that silently try to work if the class is not use in the required
condition.
The fact that the collection take as parameter can be modified
by another thread during the  execution of the constructor is
not allowed by the current implementation, so don't do this.
Furthermore neither head nor tail are declared volatile so
the test in addLast() that double the capacity can return
false even if tail is equals to head and the deque will be
in an instable state.
So i don't see why calling addAll() is better that what i propose.

>
>           Josh

R?mi Forax


From josh at bloch.us  Fri Jul 21 18:25:14 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 21 Jul 2006 15:25:14 -0700
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C14FCE.9070703@univ-mlv.fr>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>
	<44C0DF96.5060503@univ-mlv.fr>
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
	<44C14FCE.9070703@univ-mlv.fr>
Message-ID: <b097ac510607211525g5f459654gdacc4d907f41a8f6@mail.gmail.com>

R?mi,

On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
> To josh, perhaps i am tired, but for me,  allocateElements() always
> allocates
> a power of two size.

Fair enough...

> The other invariant is that head and tail must be
> different
> if the size is not empty, it seems to be the case.
> So i continue to think that this implementation is valid.

No.   Sun decided to make all collection "copy-constructors" robust to
concurrent modification of the argument.  This is wise, in light of
the fact that we now have true concurrent collections that cannot be
globally locked.  So Martin's objection is valid.

          Josh


From forax at univ-mlv.fr  Fri Jul 21 19:04:12 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Sat, 22 Jul 2006 01:04:12 +0200
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <b097ac510607211525g5f459654gdacc4d907f41a8f6@mail.gmail.com>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>	
	<44C0DF96.5060503@univ-mlv.fr>	
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>	
	<44C14FCE.9070703@univ-mlv.fr>
	<b097ac510607211525g5f459654gdacc4d907f41a8f6@mail.gmail.com>
Message-ID: <44C15D6C.9020701@univ-mlv.fr>

Joshua Bloch wrote:

> R?mi,
>
> On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>
>> To josh, perhaps i am tired, but for me,  allocateElements() always
>> allocates
>> a power of two size.
>
>
> Fair enough...
>
>> The other invariant is that head and tail must be
>> different
>> if the size is not empty, it seems to be the case.
>> So i continue to think that this implementation is valid.
>
>
> No.   Sun decided to make all collection "copy-constructors" robust to
> concurrent modification of the argument.  This is wise, in light of
> the fact that we now have true concurrent collections that cannot be
> globally locked.  So Martin's objection is valid.

sorry about my answer to martin, it was stupid.
ok, i understand now.
perhaps the third paragraph of java.util.Collection doc
can contain a line saying that copy constructor must rely on
the iterator of the collection taken as parameter.

>
>          Josh

R?mi Forax


From josh at bloch.us  Fri Jul 21 19:11:11 2006
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 21 Jul 2006 16:11:11 -0700
Subject: [concurrency-interest] Questions about ArrayDeque
In-Reply-To: <44C15D6C.9020701@univ-mlv.fr>
References: <44C0C8DA.7070707@univ-mlv.fr> <44C0CCE0.9070806@cs.oswego.edu>
	<44C0DF96.5060503@univ-mlv.fr>
	<b097ac510607210810g16a1114cu9c3da586f82a70fa@mail.gmail.com>
	<44C14FCE.9070703@univ-mlv.fr>
	<b097ac510607211525g5f459654gdacc4d907f41a8f6@mail.gmail.com>
	<44C15D6C.9020701@univ-mlv.fr>
Message-ID: <b097ac510607211611i56e2536fu5a3dc1947753ef90@mail.gmail.com>

R?mi,

Yes, I agree that the documentation could be improved.

         Josh

On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
> Joshua Bloch wrote:
>
> > R?mi,
> >
> > On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
> >
> >> To josh, perhaps i am tired, but for me,  allocateElements() always
> >> allocates
> >> a power of two size.
> >
> >
> > Fair enough...
> >
> >> The other invariant is that head and tail must be
> >> different
> >> if the size is not empty, it seems to be the case.
> >> So i continue to think that this implementation is valid.
> >
> >
> > No.   Sun decided to make all collection "copy-constructors" robust to
> > concurrent modification of the argument.  This is wise, in light of
> > the fact that we now have true concurrent collections that cannot be
> > globally locked.  So Martin's objection is valid.
>
> sorry about my answer to martin, it was stupid.
> ok, i understand now.
> perhaps the third paragraph of java.util.Collection doc
> can contain a line saying that copy constructor must rely on
> the iterator of the collection taken as parameter.
>
> >
> >          Josh
>
> R?mi Forax
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From peger at automotive.com  Fri Jul 21 22:04:36 2006
From: peger at automotive.com (Patrick Eger)
Date: Fri, 21 Jul 2006 19:04:36 -0700
Subject: [concurrency-interest] Thread Pools
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F4@mail-001.corp.automotive.com>

Thanks, I've tried this but it will create all MAX_THREADS before
reusing any of them, IE will still prefer creating a new thread before
reusing an existing (idle) one. I believe the old concurrent.jar has a
set of parameters that could produce this behaviour, but the newer, more
modular JUC design does not...

Best Regards,

Patrick 


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe
Bowbeer
Sent: Friday, July 21, 2006 12:54 PM
To: concurrency-interest
Subject: Re: [concurrency-interest] Thread Pools

On 7/21/06, Patrick Eger <peger at automotive.com> wrote:
>
> Hi, I know this has come up again and again, (I think I brought it up
once
> or twice ;-) But are there any plans to add a
"preferExistingThreads()" to
> the ThreadPoolExecutor, to address the issue of dynamic pool sizing,
or is
> there any way I can extend these classes to do such?
>
> IE I would like a:
>
> 1) potentially infinite queue of tasks (currently using a
> LinkedBlockingQueue)
>
> 2) executed by up to MAX threads concurrently
>
> 3) which go away after a period of inactivity, allowing the pool to
shrink
> to MIN (or zero) size
>
> 4) preferring to use already existing threads rather than creating new
ones
>
> This is currently impossible with the current setup AFAICS; I have
continued
> to have to use my own thread pools because of this, though I would
love to
> switch to the standard JUC classes. #3 was covered in JDK 6 with the
> capability to allow core threads to timeout, but I cannot find a way
to make
> #4 possible with current JUC. The existing behaviour will always end
up
> creating CORE threads even though they are unnecessary to execute
existing
> work.
>
> Thanks in advance for any replies.
>

To recap, the problem you're trying to overcome is that TPE prefers
(1) to create a core thread, (2) queue task, (3) create additional
thread.

In other words, MAX_THREADS is effectively ignored if queue is
unbounded:

    ExecutorService newEgerThreadPool() {
        return new ThreadPoolExecutor(0, MAX_THREADS,
                                      60L, TimeUnit.SECONDS,
                                      new LinkedQueue<Runnable>());
    }

So you're requesting an option to switch priority of 2 and 3.

I can't address that but I do see a new allowCoreThreadTimeOut method
in the pipeline that might have the same effect:

http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/
  => java/util/concurrent/ThreadPoolExecutor.java

pool.allowCoreThreadTimeOut(true) can be used to apply the time-out
policy to core threads as well, so long as the keepAliveTime value is
non-zero.

I think this might work:

    ExecutorService newEgerThreadPool() {
        ThreadPoolExecutor pool =
            new ThreadPoolExecutor(MAX_THREADS, MAX_THREADS,
                                      60L, TimeUnit.SECONDS,
                                      new LinkedQueue<Runnable>());
        pool.allowCoreThreadTimeOut(true);
        return pool;
    }

--Joe
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Sat Jul 22 07:56:06 2006
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 22 Jul 2006 07:56:06 -0400
Subject: [concurrency-interest] Thread Pools
In-Reply-To: <A7487BEC58632D46B8C7E8BC69B3EB1211E4E8@mail-001.corp.automotive.com>
References: <A7487BEC58632D46B8C7E8BC69B3EB1211E4E8@mail-001.corp.automotive.com>
Message-ID: <44C21256.5080306@cs.oswego.edu>

Patrick Eger wrote:
> 
> IE I would like a:
> 
> 1) potentially infinite queue of tasks (currently using a 
> LinkedBlockingQueue)
> 
> 2) executed by up to MAX threads concurrently
> 
> 3) which go away after a period of inactivity, allowing the pool to 
> shrink to MIN (or zero) size
> 
> 4) preferring to use already existing threads rather than creating new ones
> 


All but (4) are straightforward.

By (4) I assume you mean to use an existing thread only if
it is "idle". This is just about impossible to deterministically
guarantee, at least when using an unbounded queue.
The pool cannot know for sure whether an existing thread is idle.
It only knows whether there are fewer or more than target number
of threads, and whether the queue is full, which it never is for
unbounded ones. Problematic cases include those where an
idle-looking thread is in the process of dequeuing a task and
so will momentarily run it. You might be content with an
implementation that ignores such cases and approximates (4)
by for example, counting threads blocked on workQueue.take.
But it would probably be a bad idea for us to add such capabilities --
they invite a  stream of bug reports when "approximately" doesn't
cover particular use cases well. (For example, here, it is hard
to avoid the pathology of a large number of threads trying
to submit tasks at the same time, and all of them thinking that
they don't need to create a new thread because there is an idle one.)

ThreadPoolExecutor tries to cover as wide a set of use cases as
can all be handled by the same overall design. It does cover most
common uses. But even at that, we have had to revamp parts of the
implementation now and then to get rid of unwanted unforeseen
interactions among various parameters and methods.

So, if you really need this behavior, it looks like you will
need a custom implementation. Or you might decide that plain
newFixedThreadPools are OK for your application after all?

-Doug

From Martin.Buchholz at Sun.COM  Sat Jul 22 16:38:14 2006
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Sat, 22 Jul 2006 13:38:14 -0700
Subject: [concurrency-interest] ArrayDeque constructor thread safety
In-Reply-To: <mailman.1.1153584000.14634.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.1.1153584000.14634.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <44C28CB6.2030401@sun.com>



concurrency-interest-request at cs.oswego.edu wrote:
>>>On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>>>
>>>>To josh, perhaps i am tired, but for me,  allocateElements() always
>>>>allocates
>>>>a power of two size.
>>>
>>>Fair enough...
>>>
>>>>The other invariant is that head and tail must be
>>>>different
>>>>if the size is not empty, it seems to be the case.
>>>>So i continue to think that this implementation is valid.
>>>
>>>No.   Sun decided to make all collection "copy-constructors" robust to
>>>concurrent modification of the argument.  This is wise, in light of
>>>the fact that we now have true concurrent collections that cannot be
>>>globally locked.  So Martin's objection is valid.
>>sorry about my answer to martin, it was stupid.
>>ok, i understand now.
>>perhaps the third paragraph of java.util.Collection doc
>>can contain a line saying that copy constructor must rely on
>>the iterator of the collection taken as parameter.

If you look for tools that automatically find concurrency bugs
in Java, their No. 1 target was Vector(vector).  I was actually
more ambitious than relying on the iterator of the argument collection,
which is safe if the argument is a "concurrent" collection, but not
if it is a traditional "thread-safe" collection like Vector, since
the lock is not held while iterating.  The most reliable way to
get a snapshot of the elements in a collection with unknown concurrency
properties is to call its toArray method, and this is the
approach taken by Vector and ArrayList constructors.

ArrayDeque is still not safe in that sense.  ArrayDeque(vector)
may throw ConcurrentModificationException.  It's a bug.  Maybe.
Workaround: ArrayDeque(new ArrayList(vector))
Of course, we can easily fix ArrayDeque....if we don't care about
its performance.

Martin

From Martin.Buchholz at Sun.COM  Sun Jul 23 16:31:16 2006
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Sun, 23 Jul 2006 13:31:16 -0700
Subject: [concurrency-interest] Thread Pools
In-Reply-To: <mailman.1.1153584000.14634.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.1.1153584000.14634.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <44C3DC94.4000902@sun.com>



concurrency-interest-request at cs.oswego.edu wrote:
> Date: Sat, 22 Jul 2006 07:56:06 -0400
> From: Doug Lea <dl at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Thread Pools
> To: Patrick Eger <peger at automotive.com>
> Cc: concurrency-interest at cs.oswego.edu
> Message-ID: <44C21256.5080306 at cs.oswego.edu>
> Content-Type: text/plain; charset=windows-1252; format=flowed
> 
> Patrick Eger wrote:
>>IE I would like a:
>>
>>1) potentially infinite queue of tasks (currently using a 
>>LinkedBlockingQueue)
>>
>>2) executed by up to MAX threads concurrently
>>
>>3) which go away after a period of inactivity, allowing the pool to 
>>shrink to MIN (or zero) size
>>
>>4) preferring to use already existing threads rather than creating new ones
>>
> 
> 
> All but (4) are straightforward.
> 
> By (4) I assume you mean to use an existing thread only if
> it is "idle". This is just about impossible to deterministically
> guarantee, at least when using an unbounded queue.

> The pool cannot know for sure whether an existing thread is idle.
> It only knows whether there are fewer or more than target number
> of threads, and whether the queue is full, which it never is for
> unbounded ones. Problematic cases include those where an
> idle-looking thread is in the process of dequeuing a task and
> so will momentarily run it. You might be content with an
> implementation that ignores such cases and approximates (4)
> by for example, counting threads blocked on workQueue.take.
> But it would probably be a bad idea for us to add such capabilities --
> they invite a  stream of bug reports when "approximately" doesn't
> cover particular use cases well. (For example, here, it is hard
> to avoid the pathology of a large number of threads trying
> to submit tasks at the same time, and all of them thinking that
> they don't need to create a new thread because there is an idle one.)

I'm sympathetic to Patrick's suggestion; users generally
assume that ThreadPoolExecutor prefers reusing idle
threads.  I think we can avoid the above pathology by
simply checking queue size after enqueuing,
and changing our minds and adding a
new thread if the queue size is ever greater than 1.
Then at worst there will be one excess task waiting while all
workers are busy.

If we maintained good idleTaskCount statistics, we
could be more aggressive and only add a new thread if
idleTaskCount() < workQueue.size().

Maintaining an idle task count seems relatively expensive,
especially if the pool size is large.

Perhaps we could optimize it by
Try queue.poll(); if a task is available immediately, run it.
else increment idleCount while using timed poll() or take().

There are lots of design choices here.

Martin

> ThreadPoolExecutor tries to cover as wide a set of use cases as
> can all be handled by the same overall design. It does cover most
> common uses. But even at that, we have had to revamp parts of the
> implementation now and then to get rid of unwanted unforeseen
> interactions among various parameters and methods.
> 
> So, if you really need this behavior, it looks like you will
> need a custom implementation. Or you might decide that plain
> newFixedThreadPools are OK for your application after all?
> 
> -Doug

From dawidk at mathcs.emory.edu  Sun Jul 23 19:18:42 2006
From: dawidk at mathcs.emory.edu (Dawid Kurzyniec)
Date: Sun, 23 Jul 2006 19:18:42 -0400
Subject: [concurrency-interest] ConcurrentSkipListMap toArray() - "too" safe?
Message-ID: <44C403D2.4020706@mathcs.emory.edu>

Hello,

I noticed that ConcurrentSkipListMap in the JSR 166 CVS has been changed 
(back) so that toArray() methods take ArrayList snapshots. The comment 
says that it is in response to 6377302, "AbstractCollection.toArray is 
not safe for concurrent collections". But, the problem has been 
concurrently addressed in AbstractCollection.toArray; the method *is* 
now safe for concurrent collections, and it is so for 8 months now, as 
it appears to me. Does that mean that the extra snapshot in CSLMap is 
redundant? Or am I missing something?

Regards,
Dawid


From richard.zschech at mnetcorporation.com  Mon Jul 24 01:28:45 2006
From: richard.zschech at mnetcorporation.com (Richard Zschech)
Date: Mon, 24 Jul 2006 14:58:45 +0930
Subject: [concurrency-interest] BlockingQueue.drainTo question
Message-ID: <44C45A8D.3020606@mnetcorporation.com>

Hi,

I was wondering why BlockingQueue.drainTo doesn't block when there is 
nothing in the queue.

I am trying to write a basic producer / consumer program where the 
consumer most efficiently processes batches of objects at a time. I was 
hoping to use the drainTo method to extract a batch of objects to 
process for example:

    private BlockingQueue<Message> messages;

    public void run() {
        List<Message> batch = new ArrayList<Message>(BATCH_SIZE);
       
        while (run) {
            messages.drainTo(batch, BATCH_SIZE);
           
            for (Message message : batch) {
                System.out.println(message);
            }
           
            batch.clear();
        }
    }

The only solution I can think of is to insert 
"batch.add(messages.take())" which will block before a drainTo(batch, 
BATCH_SIZE-1) which will extract the rest of the batch.

Does this sound correct?
Is there a better way of doing this?

Thanks in advance,
 From Richard.

From forax at univ-mlv.fr  Mon Jul 24 05:00:40 2006
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Mon, 24 Jul 2006 11:00:40 +0200
Subject: [concurrency-interest] ArrayDeque constructor thread safety
In-Reply-To: <44C28CB6.2030401@sun.com>
References: <mailman.1.1153584000.14634.concurrency-interest@altair.cs.oswego.edu>
	<44C28CB6.2030401@sun.com>
Message-ID: <44C48C38.1030803@univ-mlv.fr>

Martin Buchholz a ?crit :
> concurrency-interest-request at cs.oswego.edu wrote:
>   
>>>> On 7/21/06, R?mi Forax <forax at univ-mlv.fr> wrote:
>>>>
>>>>         
>>>>> To josh, perhaps i am tired, but for me,  allocateElements() always
>>>>> allocates
>>>>> a power of two size.
>>>>>           
>>>> Fair enough...
>>>>
>>>>         
>>>>> The other invariant is that head and tail must be
>>>>> different
>>>>> if the size is not empty, it seems to be the case.
>>>>> So i continue to think that this implementation is valid.
>>>>>           
>>>> No.   Sun decided to make all collection "copy-constructors" robust to
>>>> concurrent modification of the argument.  This is wise, in light of
>>>> the fact that we now have true concurrent collections that cannot be
>>>> globally locked.  So Martin's objection is valid.
>>>>         
>>> sorry about my answer to martin, it was stupid.
>>> ok, i understand now.
>>> perhaps the third paragraph of java.util.Collection doc
>>> can contain a line saying that copy constructor must rely on
>>> the iterator of the collection taken as parameter.
>>>       
>
> If you look for tools that automatically find concurrency bugs
> in Java, their No. 1 target was Vector(vector).  I was actually
> more ambitious than relying on the iterator of the argument collection,
> which is safe if the argument is a "concurrent" collection, but not
> if it is a traditional "thread-safe" collection like Vector, since
> the lock is not held while iterating.  The most reliable way to
> get a snapshot of the elements in a collection with unknown concurrency
> properties is to call its toArray method, and this is the
> approach taken by Vector and ArrayList constructors.
>   
Another solution is to change the problem i.e. add a way to obtain 
concurrency property at runtime
using an interface like RandomAccess or perhaps better using a runtime 
visible annotation.

public enum ConcurrencyProperty **{
    NONE,
    SYNCHRONIZED,
    CONCURRENT
  }

  @Documented
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface ThreadSafe {
    ConcurrencyProperty value();
  }

In this case, "copy constructor" can choose to use AddAll or
toArray depending on the collection taken as argument.

I don't know if obtaining the value of an annotation at runtime
can be a performance bottleneck.

Another advantage of this solution is that a collection
marked with this annotation clearly documents
if a collection is or not thread safe.
Furthermore the compiler can try to
reports error in case of bad concurrency code
like with one

public void f() {
  Vector<String> v=new Vector();
  for(String s:v) {
     ...
  } // forget to synchronized the loop
} // the method is public.

Note that this solution also partially solve bug 6323374.

> ArrayDeque is still not safe in that sense.  ArrayDeque(vector)
> may throw ConcurrentModificationException.  It's a bug.  Maybe.
> Workaround: ArrayDeque(new ArrayList(vector))
> Of course, we can easily fix ArrayDeque....if we don't care about
> its performance.
>   
other workaround : use the annotation described above :)
> Martin
R?mi Forax


From mike.quilleash at subexazure.com  Mon Jul 24 06:51:11 2006
From: mike.quilleash at subexazure.com (Mike Quilleash )
Date: Mon, 24 Jul 2006 06:51:11 -0400
Subject: [concurrency-interest] Using ThreadGroup for logging
Message-ID: <DAE04D9F6FD21448A220918A522FB60E023766E2@MI8NYCMAIL15.Mi8.com>

I have read about ThreadGroups and I have found a use for them to solve
a problem I had.  I'd appreciate any comment on whether this is good/bad
and whether there is a better way as I have read that ThreadGroups are
bad, but this may just be because of stop/suspend etc and other dodgy
statistic functions that it supports.
 
I have a program that spawns indivudual tasks, each of which is designed
to do some piece of work.  Each task has a separate log file for logging
it's progress/error messages etc using Log4J.  The problem I have is
that these tasks use a fair few lower-level libraries which do logging
and I would like to trap the log messages from these libraries in the
task log.  To compound the issue sometimes these tasks create child
threads which use these libraries.  I want to avoid passing a Log object
around, especially into the libraries, and similarly don't want the
libraries calling out and fetching a the log from elsewhere.
 
So I came up with the idea of for each task creating a ThreadGroup and
the create the main task thread on this ThreadGroup (I don't use thread
pooling).  I then use a Log4J file appender to link to the task log and
add a filter for this appender to only accept messages from threads that
belong to the task ThreadGroup.  This way library functions can call
standard logging functions and messages get routed to the relevant task
logs by Thread(Group) without them having to know about the task
framework.
 
Appreciate any feedback/comments/better ideas.
 

 This e-mail is bound by the terms and conditions described at http://www.subexazure.com/mail-disclaimer.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20060724/9371c263/attachment.html 

From peger at automotive.com  Mon Jul 24 13:54:40 2006
From: peger at automotive.com (Patrick Eger)
Date: Mon, 24 Jul 2006 10:54:40 -0700
Subject: [concurrency-interest] Thread Pools
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F9@mail-001.corp.automotive.com>

I appreciate all your replies, and I definitely realize the design
tradeoffs that need to be made for the sake of efficiency. I believe I
tried to hack in the below "poll() before idling thread" + "keep approx
idle count" approach into the JDK code, though I was not very familiar
with the code and gave up quickly. 

Briefly, my use-case for having a thread pool behave as requested is
basically:

1) multiple thread pools (10 or so)
2) each with specific priority / thread group / naming / specific Thread
subclass factories
3) desire to let each pool grow very large (~1000 threads) due to
possibility of slow I/O in one or more of the pools & desire for maximum
concurrency in the tasks
4) pools hand off work between each other for roughly ~1000 concurrent
tasks

By not having #4 from previous message, the number of threads in the
system can peak up to 10K threads, even though there are only 1000
concurrent tasks. The conflicting needs are: 1) to have a large CORE
size for the pools to allow many concurrent threads when the I/O is
slow, but 2) to keep the average pool size low when the I/O is fast
(normal case), all the while 3) keeping the TOTAL thread count (globally
and per-pool) as low as reasonable. 

I won't say the architecture is ideal, but it is much easier to swap out
thread-pool implementations than it is to rewrite the app. Hope this
clarifies things a little.


Best Regards, 

Patrick


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Martin
Buchholz
Sent: Sunday, July 23, 2006 1:31 PM
To: concurrency-interest at cs.oswego.edu
Subject: [concurrency-interest] Thread Pools



concurrency-interest-request at cs.oswego.edu wrote:
> Date: Sat, 22 Jul 2006 07:56:06 -0400
> From: Doug Lea <dl at cs.oswego.edu>
> Subject: Re: [concurrency-interest] Thread Pools
> To: Patrick Eger <peger at automotive.com>
> Cc: concurrency-interest at cs.oswego.edu
> Message-ID: <44C21256.5080306 at cs.oswego.edu>
> Content-Type: text/plain; charset=windows-1252; format=flowed
> 
> Patrick Eger wrote:
>>IE I would like a:
>>
>>1) potentially infinite queue of tasks (currently using a 
>>LinkedBlockingQueue)
>>
>>2) executed by up to MAX threads concurrently
>>
>>3) which go away after a period of inactivity, allowing the pool to 
>>shrink to MIN (or zero) size
>>
>>4) preferring to use already existing threads rather than creating new
ones
>>
> 
> 
> All but (4) are straightforward.
> 
> By (4) I assume you mean to use an existing thread only if
> it is "idle". This is just about impossible to deterministically
> guarantee, at least when using an unbounded queue.

> The pool cannot know for sure whether an existing thread is idle.
> It only knows whether there are fewer or more than target number
> of threads, and whether the queue is full, which it never is for
> unbounded ones. Problematic cases include those where an
> idle-looking thread is in the process of dequeuing a task and
> so will momentarily run it. You might be content with an
> implementation that ignores such cases and approximates (4)
> by for example, counting threads blocked on workQueue.take.
> But it would probably be a bad idea for us to add such capabilities --
> they invite a  stream of bug reports when "approximately" doesn't
> cover particular use cases well. (For example, here, it is hard
> to avoid the pathology of a large number of threads trying
> to submit tasks at the same time, and all of them thinking that
> they don't need to create a new thread because there is an idle one.)

I'm sympathetic to Patrick's suggestion; users generally
assume that ThreadPoolExecutor prefers reusing idle
threads.  I think we can avoid the above pathology by
simply checking queue size after enqueuing,
and changing our minds and adding a
new thread if the queue size is ever greater than 1.
Then at worst there will be one excess task waiting while all
workers are busy.

If we maintained good idleTaskCount statistics, we
could be more aggressive and only add a new thread if
idleTaskCount() < workQueue.size().

Maintaining an idle task count seems relatively expensive,
especially if the pool size is large.

Perhaps we could optimize it by
Try queue.poll(); if a task is available immediately, run it.
else increment idleCount while using timed poll() or take().

There are lots of design choices here.

Martin

> ThreadPoolExecutor tries to cover as wide a set of use cases as
> can all be handled by the same overall design. It does cover most
> common uses. But even at that, we have had to revamp parts of the
> implementation now and then to get rid of unwanted unforeseen
> interactions among various parameters and methods.
> 
> So, if you really need this behavior, it looks like you will
> need a custom implementation. Or you might decide that plain
> newFixedThreadPools are OK for your application after all?
> 
> -Doug
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Mon Jul 24 14:08:34 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 24 Jul 2006 11:08:34 -0700
Subject: [concurrency-interest] Using ThreadGroup for logging
In-Reply-To: <DAE04D9F6FD21448A220918A522FB60E023766E2@MI8NYCMAIL15.Mi8.com>
References: <DAE04D9F6FD21448A220918A522FB60E023766E2@MI8NYCMAIL15.Mi8.com>
Message-ID: <31f2a7bd0607241108l3ee27f83m14c36ed7c8890df7@mail.gmail.com>

On 7/24/06, Mike Quilleash <mike.quilleash at subexazure.com> wrote:
>
> I have read about ThreadGroups and I have found a use for them to
> solve a problem I had.  I'd appreciate any comment on whether this
> is good/bad and whether there is a better way as I have read that
> ThreadGroups are bad, but this may just be because of stop/suspend
> etc and other dodgy statistic functions that it supports.
>

I don't see an issue with what you're doing, though we have been
trying to slowly obsolete ThreadGroup..

For an alternative, see section on "Using ThreadLocal to simplify
debug logging" in Threading Lightly, part 3:

http://www-128.ibm.com/developerworks/java/library/j-threads3.html

An InheritableThreadLocal would pass the log from parent to child.

I can't think of a great reason to switch to ThreadLocal.

--Joe

From joe.bowbeer at gmail.com  Mon Jul 24 14:22:55 2006
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Mon, 24 Jul 2006 11:22:55 -0700
Subject: [concurrency-interest] Thread Pools
In-Reply-To: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F4@mail-001.corp.automotive.com>
References: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F4@mail-001.corp.automotive.com>
Message-ID: <31f2a7bd0607241122t2c4cc723t4476abe972b19ffd@mail.gmail.com>

On 7/21/06, Patrick Eger <peger at automotive.com> wrote:
> Thanks, I've tried this but it will create all MAX_THREADS before
> reusing any of them, IE will still prefer creating a new thread before
> reusing an existing (idle) one.

Does lowering the linger time to almost nothing approximate the right behavior?

>From the description you sent today, I'm guessing that thread start-up
time is not a big performance factor.

From peger at automotive.com  Mon Jul 24 16:40:42 2006
From: peger at automotive.com (Patrick Eger)
Date: Mon, 24 Jul 2006 13:40:42 -0700
Subject: [concurrency-interest] Thread Pools
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1211E4FF@mail-001.corp.automotive.com>

A lower linger time does help out indeed with the thread count, however
in my case it almost degenerates into no thread pool at all (IE short
timeout + not re-using existing threads = lots of thread create/delete).

I can't say thread startup is *too* big of a deal, but it is noticeable
in our CPU timing (moreso on windows with it's not-so-hot threading). 


-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Joe
Bowbeer
Sent: Monday, July 24, 2006 11:23 AM
To: concurrency-interest
Subject: Re: [concurrency-interest] Thread Pools

On 7/21/06, Patrick Eger <peger at automotive.com> wrote:
> Thanks, I've tried this but it will create all MAX_THREADS before
> reusing any of them, IE will still prefer creating a new thread before
> reusing an existing (idle) one.

Does lowering the linger time to almost nothing approximate the right
behavior?

>From the description you sent today, I'm guessing that thread start-up
time is not a big performance factor.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From Martin.Buchholz at Sun.COM  Mon Jul 24 23:11:49 2006
From: Martin.Buchholz at Sun.COM (Martin Buchholz)
Date: Mon, 24 Jul 2006 20:11:49 -0700
Subject: [concurrency-interest] Thread Pools
In-Reply-To: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F9@mail-001.corp.automotive.com>
References: <A7487BEC58632D46B8C7E8BC69B3EB1211E4F9@mail-001.corp.automotive.com>
Message-ID: <44C58BF5.6060308@Sun.COM>



Patrick Eger wrote On 07/24/06 10:54,:
> I appreciate all your replies, and I definitely realize the design
> tradeoffs that need to be made for the sake of efficiency. I believe I
> tried to hack in the below "poll() before idling thread" + "keep approx
> idle count" approach into the JDK code, though I was not very familiar
> with the code and gave up quickly. 

ThreadPoolExecutor.java is one of the most difficult classes in the JDK.
An early dolphin snapshot should have a new and improved version,
for reasons unrelated to your request.

I just filed Sun bug:

6452337: ThreadPoolExecutor should prefer reusing idle threads
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6452337

Martin


From alarmnummer at gmail.com  Tue Jul 25 05:52:45 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 25 Jul 2006 11:52:45 +0200
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone method
	an implementation detail?
Message-ID: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>

I have a question about synchrone and asynchrone methods being an
implementation detail.

If you have an interface:

interface WaterCooker{
   void cook();
}

You could create different implementations. It is easy to make it a
synchronous call (the default approach) but it is also quite easy to
make it asynchrone (if the call has no return value). So it is
possible to let the implementation determine what kind of call you
get: synchrone or asynchrone.

Personally I'm not too happy with this 'transparancy'. I think it is
better that this behaviour is part of your interface definition. Why?
-of you don't know if  a call is asynchrone, some condition don't have
to success when you go to the next statement. In case of the
WaterCooker:

WaterCooker cooker = new WaterCooker();
Cup cup = new Cup();
cooker.cook();
cooker.fill(cup);

if you don't know the cook call is asynchrone, it could be you get
cold water in your cup.

-you don't know if you need to worry about concurrency control issues.
If some data is shared between the two threads, you system could be
subject to data corruption and other nasty stuff. This is something
you have to be aware of, and this means that it is part of the
definition of your interface (and not an implementation detail).

And there are other issues (bigger chance of deadlocks for example).

The reason why I'm asking this:
with modern frameworks like Spring it is very easy to 'enhance'
objects. You could wrap a synchronous call within a asynchronous
wrapper and inject the wrapper in every components that requires it.
The component itself is not aware that the call is asynchronone. So it
is very easy to make the choice between synchronous and asynchronous
evaluation just an implementation/configuration detail.

What are your thought about  the synchronous/asynchronous behaviour of
methods totally transparent?

From dcholmes at optusnet.com.au  Tue Jul 25 06:09:39 2006
From: dcholmes at optusnet.com.au (David Holmes)
Date: Tue, 25 Jul 2006 20:09:39 +1000
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>

Peter,

I'm opposed to this kind of transparency - I don't think it can be done. The
programming model is either synchronous or asynchronous you can't
arbitrarily switch between them unless you always assume asynchronous. But
then whenever you have an asynchronous call you ultimately need some kind of
synchronous method to "rendezvous" with the object again.

So my answer is: don't do this. It isn't an implementation detail it is part
of the specification of the API - after this method returns what do I know
about what should have happend to the object.

Now there are languages that allow things to happen asynchronously but they
also synchronize again when needed ie "wait by necessity".

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> Veentjer
> Sent: Tuesday, 25 July 2006 7:53 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
> methodan implementation detail?
>
>
> I have a question about synchrone and asynchrone methods being an
> implementation detail.
>
> If you have an interface:
>
> interface WaterCooker{
>    void cook();
> }
>
> You could create different implementations. It is easy to make it a
> synchronous call (the default approach) but it is also quite easy to
> make it asynchrone (if the call has no return value). So it is
> possible to let the implementation determine what kind of call you
> get: synchrone or asynchrone.
>
> Personally I'm not too happy with this 'transparancy'. I think it is
> better that this behaviour is part of your interface definition. Why?
> -of you don't know if  a call is asynchrone, some condition don't have
> to success when you go to the next statement. In case of the
> WaterCooker:
>
> WaterCooker cooker = new WaterCooker();
> Cup cup = new Cup();
> cooker.cook();
> cooker.fill(cup);
>
> if you don't know the cook call is asynchrone, it could be you get
> cold water in your cup.
>
> -you don't know if you need to worry about concurrency control issues.
> If some data is shared between the two threads, you system could be
> subject to data corruption and other nasty stuff. This is something
> you have to be aware of, and this means that it is part of the
> definition of your interface (and not an implementation detail).
>
> And there are other issues (bigger chance of deadlocks for example).
>
> The reason why I'm asking this:
> with modern frameworks like Spring it is very easy to 'enhance'
> objects. You could wrap a synchronous call within a asynchronous
> wrapper and inject the wrapper in every components that requires it.
> The component itself is not aware that the call is asynchronone. So it
> is very easy to make the choice between synchronous and asynchronous
> evaluation just an implementation/configuration detail.
>
> What are your thought about  the synchronous/asynchronous behaviour of
> methods totally transparent?
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From alarmnummer at gmail.com  Tue Jul 25 07:27:57 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 25 Jul 2006 13:27:57 +0200
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
Message-ID: <1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>

> I'm opposed to this kind of transparency - I don't think it can be done.
I agree it is a bad thing (nice to see I'm not crazy ). But it isn't
difficult to make a asynchronuos wrapper. And this is the problem:
because you can't see if you are dealing with a synchronous or
asynchronous method call, it makes the design a lot more complex. The
difficulty is that most developers don't see this increased complexity
and only see the easy of making a call asynchronous with a
asynchronous wrapper.

So my personal experience is that it is difficult to convince other developers.

> So my answer is: don't do this. It isn't an implementation detail it is part
> of the specification of the API - after this method returns what do I know
> about what should have happend to the object.

*nods his head*

> Now there are languages that allow things to happen asynchronously but they
> also synchronize again when needed ie "wait by necessity".
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > Veentjer
> > Sent: Tuesday, 25 July 2006 7:53 PM
> > To: concurrency-interest at cs.oswego.edu
> > Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
> > methodan implementation detail?
> >
> >
> > I have a question about synchrone and asynchrone methods being an
> > implementation detail.
> >
> > If you have an interface:
> >
> > interface WaterCooker{
> >    void cook();
> > }
> >
> > You could create different implementations. It is easy to make it a
> > synchronous call (the default approach) but it is also quite easy to
> > make it asynchrone (if the call has no return value). So it is
> > possible to let the implementation determine what kind of call you
> > get: synchrone or asynchrone.
> >
> > Personally I'm not too happy with this 'transparancy'. I think it is
> > better that this behaviour is part of your interface definition. Why?
> > -of you don't know if  a call is asynchrone, some condition don't have
> > to success when you go to the next statement. In case of the
> > WaterCooker:
> >
> > WaterCooker cooker = new WaterCooker();
> > Cup cup = new Cup();
> > cooker.cook();
> > cooker.fill(cup);
> >
> > if you don't know the cook call is asynchrone, it could be you get
> > cold water in your cup.
> >
> > -you don't know if you need to worry about concurrency control issues.
> > If some data is shared between the two threads, you system could be
> > subject to data corruption and other nasty stuff. This is something
> > you have to be aware of, and this means that it is part of the
> > definition of your interface (and not an implementation detail).
> >
> > And there are other issues (bigger chance of deadlocks for example).
> >
> > The reason why I'm asking this:
> > with modern frameworks like Spring it is very easy to 'enhance'
> > objects. You could wrap a synchronous call within a asynchronous
> > wrapper and inject the wrapper in every components that requires it.
> > The component itself is not aware that the call is asynchronone. So it
> > is very easy to make the choice between synchronous and asynchronous
> > evaluation just an implementation/configuration detail.
> >
> > What are your thought about  the synchronous/asynchronous behaviour of
> > methods totally transparent?
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From david at walend.net  Tue Jul 25 08:33:13 2006
From: david at walend.net (David Walend)
Date: Tue, 25 Jul 2006 08:33:13 -0400
Subject: [concurrency-interest] is choice between asynchrone/synchrone
	method an implementation detail?
In-Reply-To: <mailman.99.1153826882.14448.concurrency-interest@altair.cs.oswego.edu>
References: <mailman.99.1153826882.14448.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <2A97D49C-363B-4C94-BB4A-F96DA8870CA9@walend.net>

On Jul 25, 2006, at 7:28 AM, concurrency-interest- 
request at cs.oswego.edu wrote:

> From: "Peter Veentjer" <alarmnummer at gmail.com>
>
>> I'm opposed to this kind of transparency - I don't think it can be  
>> done.
> I agree it is a bad thing (nice to see I'm not crazy ). But it isn't
> difficult to make a asynchronuos wrapper. And this is the problem:
> because you can't see if you are dealing with a synchronous or
> asynchronous method call, it makes the design a lot more complex. The
> difficulty is that most developers don't see this increased complexity
> and only see the easy of making a call asynchronous with a
> asynchronous wrapper.
>
> So my personal experience is that it is difficult to convince other  
> developers.

Really? The developers I work with would prefer to live and die by  
the stack, and have to be dragged into any kind of asynchronous  
approach. We know if we blow it, we'll spend hours or weeks trying to  
bracket the problem, so we keep things obvious and segregated.  
Enforced reading of the high-level design and quick note in the  
JavaDoc seems to be enough to alert new team members: "Here there be  
dragons."

We use a services-and-messages idiom, which seems to make the  
concurrency issues very clear. On other projects I've used Runnables  
and worker threads. You'll almost always know where you stand with  
these two styles.

David Holmes is right -- asynchronous side effects are part of the API.

>>>
>>> WaterCooker cooker = new WaterCooker();
>>> Cup cup = new Cup();
>>> cooker.cook();
>>> cooker.fill(cup);

An asynchronous style would look more like

cooker.startCooking();  //not just cook()
you.readNewspaper();
cooker.waitUntilDone(); //have to wait for done before filling the cup
cooker.fill(cup);

Hope that helps,

Dave

David Walend
david at walend.net



From alarmnummer at gmail.com  Tue Jul 25 08:59:11 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Tue, 25 Jul 2006 14:59:11 +0200
Subject: [concurrency-interest] is choice between asynchrone/synchrone
	method an implementation detail?
In-Reply-To: <2A97D49C-363B-4C94-BB4A-F96DA8870CA9@walend.net>
References: <mailman.99.1153826882.14448.concurrency-interest@altair.cs.oswego.edu>
	<2A97D49C-363B-4C94-BB4A-F96DA8870CA9@walend.net>
Message-ID: <1466c1d60607250559r5e9a73dfyb033b407099255dc@mail.gmail.com>

On 7/25/06, David Walend <david at walend.net> wrote:
> On Jul 25, 2006, at 7:28 AM, concurrency-interest-
> request at cs.oswego.edu wrote:
>
> > From: "Peter Veentjer" <alarmnummer at gmail.com>
> >
> >> I'm opposed to this kind of transparency - I don't think it can be
> >> done.
> > I agree it is a bad thing (nice to see I'm not crazy ). But it isn't
> > difficult to make a asynchronuos wrapper. And this is the problem:
> > because you can't see if you are dealing with a synchronous or
> > asynchronous method call, it makes the design a lot more complex. The
> > difficulty is that most developers don't see this increased complexity
> > and only see the easy of making a call asynchronous with a
> > asynchronous wrapper.
> >
> > So my personal experience is that it is difficult to convince other
> > developers.
>
> Really? The developers I work with would prefer to live and die by
> the stack, and have to be dragged into any kind of asynchronous
> approach.

Don't get me wrong. Asynchronous calls are great. But it should be part
of the interface definition: you say that the cook method blocks
untill the water boils (synchronous) or you say: press the cook
button, but don't wait (the asynchronous call).

You can't add this behaviour transparent without creating difficult to
understand code and that is what I'm trying to discuss.

We know if we blow it, we'll spend hours or weeks trying to
> bracket the problem, so we keep things obvious and segregated.
> Enforced reading of the high-level design and quick note in the
> JavaDoc seems to be enough to alert new team members: "Here there be
> dragons."
>
> We use a services-and-messages idiom, which seems to make the
> concurrency issues very clear. On other projects I've used Runnables
> and worker threads. You'll almost always know where you stand with
> these two styles.
>
> David Holmes is right -- asynchronous side effects are part of the API.

Ok :) So we agree: asynchronous/synchronous calling of methods is not
a configuration/implementation detail but is part of the interface.

> Dave
>
> David Walend
> david at walend.net
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From brian at quiotix.com  Tue Jul 25 12:52:49 2006
From: brian at quiotix.com (Brian Goetz)
Date: Tue, 25 Jul 2006 12:52:49 -0400
Subject: [concurrency-interest] is choice between asynchrone/synchrone
 method an implementation detail?
In-Reply-To: <1466c1d60607250559r5e9a73dfyb033b407099255dc@mail.gmail.com>
References: <mailman.99.1153826882.14448.concurrency-interest@altair.cs.oswego.edu>	<2A97D49C-363B-4C94-BB4A-F96DA8870CA9@walend.net>
	<1466c1d60607250559r5e9a73dfyb033b407099255dc@mail.gmail.com>
Message-ID: <44C64C61.2030708@quiotix.com>

> Don't get me wrong. Asynchronous calls are great. But it should be part
> of the interface definition: you say that the cook method blocks
> untill the water boils (synchronous) or you say: press the cook
> button, but don't wait (the asynchronous call).

And blocking methods (those that wait for an action to occur in another 
thread) should strongly consider throwing InterruptedException, both to 
facilitate cancellation, and as a nice way of saying "I'm a blocking 
method."

From dhanji at gmail.com  Tue Jul 25 20:26:11 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 26 Jul 2006 10:26:11 +1000
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
	<1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>
Message-ID: <aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com>

I dont think I understand the question properly--the interface
specifies whether or not the method is asynchronous in its contract,
this is quite clear in documentation. Users of the interface know
this--whether they are wrappers or "end" users. If the wrapper exposes
the same interface to an end user but changes the semantics of the
method (i.e. from a- to synchronous) then the wrapper has broken the
contract. Otherwise the wrapper can simply expose a different
interface with the correct (a- or sync) contract.

What is the problem?

Java is strict evaluative so it does not make sense to talk about
method-granular promises. All methods evaluate to values, period.
Asynchronicity is an abstraction above the language layer and
therefore should be specified in the contract.

Plz let me know if Im missing something here-this sounds like
something fundamental to me!!

Dhanji.

On 7/25/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > I'm opposed to this kind of transparency - I don't think it can be done.
> I agree it is a bad thing (nice to see I'm not crazy ). But it isn't
> difficult to make a asynchronuos wrapper. And this is the problem:
> because you can't see if you are dealing with a synchronous or
> asynchronous method call, it makes the design a lot more complex. The
> difficulty is that most developers don't see this increased complexity
> and only see the easy of making a call asynchronous with a
> asynchronous wrapper.
>
> So my personal experience is that it is difficult to convince other developers.
>
> > So my answer is: don't do this. It isn't an implementation detail it is part
> > of the specification of the API - after this method returns what do I know
> > about what should have happend to the object.
>
> *nods his head*
>
> > Now there are languages that allow things to happen asynchronously but they
> > also synchronize again when needed ie "wait by necessity".
> >
> > Cheers,
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > > Veentjer
> > > Sent: Tuesday, 25 July 2006 7:53 PM
> > > To: concurrency-interest at cs.oswego.edu
> > > Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
> > > methodan implementation detail?
> > >
> > >
> > > I have a question about synchrone and asynchrone methods being an
> > > implementation detail.
> > >
> > > If you have an interface:
> > >
> > > interface WaterCooker{
> > >    void cook();
> > > }
> > >
> > > You could create different implementations. It is easy to make it a
> > > synchronous call (the default approach) but it is also quite easy to
> > > make it asynchrone (if the call has no return value). So it is
> > > possible to let the implementation determine what kind of call you
> > > get: synchrone or asynchrone.
> > >
> > > Personally I'm not too happy with this 'transparancy'. I think it is
> > > better that this behaviour is part of your interface definition. Why?
> > > -of you don't know if  a call is asynchrone, some condition don't have
> > > to success when you go to the next statement. In case of the
> > > WaterCooker:
> > >
> > > WaterCooker cooker = new WaterCooker();
> > > Cup cup = new Cup();
> > > cooker.cook();
> > > cooker.fill(cup);
> > >
> > > if you don't know the cook call is asynchrone, it could be you get
> > > cold water in your cup.
> > >
> > > -you don't know if you need to worry about concurrency control issues.
> > > If some data is shared between the two threads, you system could be
> > > subject to data corruption and other nasty stuff. This is something
> > > you have to be aware of, and this means that it is part of the
> > > definition of your interface (and not an implementation detail).
> > >
> > > And there are other issues (bigger chance of deadlocks for example).
> > >
> > > The reason why I'm asking this:
> > > with modern frameworks like Spring it is very easy to 'enhance'
> > > objects. You could wrap a synchronous call within a asynchronous
> > > wrapper and inject the wrapper in every components that requires it.
> > > The component itself is not aware that the call is asynchronone. So it
> > > is very easy to make the choice between synchronous and asynchronous
> > > evaluation just an implementation/configuration detail.
> > >
> > > What are your thought about  the synchronous/asynchronous behaviour of
> > > methods totally transparent?
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From alarmnummer at gmail.com  Wed Jul 26 00:54:20 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 26 Jul 2006 06:54:20 +0200
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com>
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
	<1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>
	<aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com>
Message-ID: <1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com>

On 7/26/06, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
> I dont think I understand the question properly--the interface
> specifies whether or not the method is asynchronous in its contract,
> this is quite clear in documentation. Users of the interface know
> this--whether they are wrappers or "end" users. If the wrapper exposes
> the same interface to an end user but changes the semantics of the
> method (i.e. from a- to synchronous) then the wrapper has broken the
> contract. Otherwise the wrapper can simply expose a different
> interface with the correct (a- or sync) contract.
>
> What is the problem?
The problem is that the synchrone/asynchrone behaviour of the method
isn't described in the interface. If it isn't described in the
interface I assume it is synchrone. And the original implementation
even is synchrone... but the wrapper makes it a asynchrone call. So
the caller expects a call to be synchrone but finds out it is
asynchrone instead,

The point I'm trying to make is that the choice of
synchrone/asynchrone is not an implementation/configuration detail,
but part of the definition of the function. And if I understand you
correctly, you agree :)

How you are going to implement the asynchrone call (after you know the
call is asynchrone) is just a configuration/implementation detail.

>
> Java is strict evaluative so it does not make sense to talk about
> method-granular promises. All methods evaluate to values, period.
Not void methods. These are the functions you 'could' make asynchrone
without anyone knowing.

> Asynchronicity is an abstraction above the language layer and
> therefore should be specified in the contract.
>
> Plz let me know if Im missing something here-this sounds like
> something fundamental to me!!
>
> Dhanji.
>
> On 7/25/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> > > I'm opposed to this kind of transparency - I don't think it can be done.
> > I agree it is a bad thing (nice to see I'm not crazy ). But it isn't
> > difficult to make a asynchronuos wrapper. And this is the problem:
> > because you can't see if you are dealing with a synchronous or
> > asynchronous method call, it makes the design a lot more complex. The
> > difficulty is that most developers don't see this increased complexity
> > and only see the easy of making a call asynchronous with a
> > asynchronous wrapper.
> >
> > So my personal experience is that it is difficult to convince other developers.
> >
> > > So my answer is: don't do this. It isn't an implementation detail it is part
> > > of the specification of the API - after this method returns what do I know
> > > about what should have happend to the object.
> >
> > *nods his head*
> >
> > > Now there are languages that allow things to happen asynchronously but they
> > > also synchronize again when needed ie "wait by necessity".
> > >
> > > Cheers,
> > > David Holmes
> > >
> > > > -----Original Message-----
> > > > From: concurrency-interest-bounces at cs.oswego.edu
> > > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Peter
> > > > Veentjer
> > > > Sent: Tuesday, 25 July 2006 7:53 PM
> > > > To: concurrency-interest at cs.oswego.edu
> > > > Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
> > > > methodan implementation detail?
> > > >
> > > >
> > > > I have a question about synchrone and asynchrone methods being an
> > > > implementation detail.
> > > >
> > > > If you have an interface:
> > > >
> > > > interface WaterCooker{
> > > >    void cook();
> > > > }
> > > >
> > > > You could create different implementations. It is easy to make it a
> > > > synchronous call (the default approach) but it is also quite easy to
> > > > make it asynchrone (if the call has no return value). So it is
> > > > possible to let the implementation determine what kind of call you
> > > > get: synchrone or asynchrone.
> > > >
> > > > Personally I'm not too happy with this 'transparancy'. I think it is
> > > > better that this behaviour is part of your interface definition. Why?
> > > > -of you don't know if  a call is asynchrone, some condition don't have
> > > > to success when you go to the next statement. In case of the
> > > > WaterCooker:
> > > >
> > > > WaterCooker cooker = new WaterCooker();
> > > > Cup cup = new Cup();
> > > > cooker.cook();
> > > > cooker.fill(cup);
> > > >
> > > > if you don't know the cook call is asynchrone, it could be you get
> > > > cold water in your cup.
> > > >
> > > > -you don't know if you need to worry about concurrency control issues.
> > > > If some data is shared between the two threads, you system could be
> > > > subject to data corruption and other nasty stuff. This is something
> > > > you have to be aware of, and this means that it is part of the
> > > > definition of your interface (and not an implementation detail).
> > > >
> > > > And there are other issues (bigger chance of deadlocks for example).
> > > >
> > > > The reason why I'm asking this:
> > > > with modern frameworks like Spring it is very easy to 'enhance'
> > > > objects. You could wrap a synchronous call within a asynchronous
> > > > wrapper and inject the wrapper in every components that requires it.
> > > > The component itself is not aware that the call is asynchronone. So it
> > > > is very easy to make the choice between synchronous and asynchronous
> > > > evaluation just an implementation/configuration detail.
> > > >
> > > > What are your thought about  the synchronous/asynchronous behaviour of
> > > > methods totally transparent?
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>

From dhanji at gmail.com  Wed Jul 26 01:11:29 2006
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Wed, 26 Jul 2006 15:11:29 +1000
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com>
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
	<1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>
	<aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com>
	<1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com>
Message-ID: <aa067ea10607252211p773537e2x7795a6acab218bc1@mail.gmail.com>

On 7/26/06, Peter Veentjer <alarmnummer at gmail.com> wrote:
> The point I'm trying to make is that the choice of
> synchrone/asynchrone is not an implementation/configuration detail,
> but part of the definition of the function. And if I understand you
> correctly, you agree :)

Yes, I suppose I do. =)

>
> How you are going to implement the asynchrone call (after you know the
> call is asynchrone) is just a configuration/implementation detail.
>

Afai concerned it is poor documentation that does not make clear what
the method is expected do. ;)

> >
> > Java is strict evaluative so it does not make sense to talk about
> > method-granular promises. All methods evaluate to values, period.
> Not void methods. These are the functions you 'could' make asynchrone
> without anyone knowing.
>

I disagree, because making them asynchronous if the contract reports
otherwise is fallacious and may break lexical guarantees. To take your
own example:

public interface CookableFood {
/**
  * When this method returns food is cooked
  */
  public void cook();
}

//usage scenario:
CookableFood c = CookerFactory.getMisbehavingImpl();

c.cook();
waiter.serveCookedFood(c); //c may not yet be cooked leading to a
synchronization requirement, thus breaking the contract set by
CookableFood

From alarmnummer at gmail.com  Wed Jul 26 01:22:28 2006
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Wed, 26 Jul 2006 07:22:28 +0200
Subject: [concurrency-interest] is choice beteen asynchrone/synchrone
	methodan implementation detail?
In-Reply-To: <aa067ea10607252211p773537e2x7795a6acab218bc1@mail.gmail.com>
References: <1466c1d60607250252w684a3238k67819e627b3d2472@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJIHAAA.dcholmes@optusnet.com.au>
	<1466c1d60607250427u41aa4522o26c1da96cd0b89c0@mail.gmail.com>
	<aa067ea10607251726h6b8b840dwa7dfabe1805c23f2@mail.gmail.com>
	<1466c1d60607252154w398cc012oaa80fc086b2042b8@mail.gmail.com>
	<aa067ea10607252211p773537e2x7795a6acab218bc1@mail.gmail.com>
Message-ID: <1466c1d60607252222p3acc1b3djd55e49b55b035ca4@mail.gmail.com>

> I disagree, because making them asynchronous if the contract reports
> otherwise is fallacious and may break lexical guarantees. To take your
> own example:
That is why the could is between quotes... you could... it doesn't
mean you should :)

>
> public interface CookableFood {
> /**
>   * When this method returns food is cooked
>   */
>   public void cook();
> }
>
> //usage scenario:
> CookableFood c = CookerFactory.getMisbehavingImpl();
>
> c.cook();
> waiter.serveCookedFood(c); //c may not yet be cooked leading to a
> synchronization requirement, thus breaking the contract set by
> CookableFood
>

From holger at wizards.de  Wed Jul 26 13:40:40 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Wed, 26 Jul 2006 19:40:40 +0200
Subject: [concurrency-interest] JCIP: queued logging - already done?
Message-ID: <44C7A918.5030508@wizards.de>


The very excellent JCIP book refers to a queueing logging mechanism as
example for various performance tricks, blocking queues etc. Surely
someone must have done this as a configurable log4j drop-in already? Any
pointers?

Holger

From holger at wizards.de  Wed Jul 26 14:24:43 2006
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Wed, 26 Jul 2006 20:24:43 +0200
Subject: [concurrency-interest] JCIP: queued logging - already done?
In-Reply-To: <44C7A918.5030508@wizards.de>
References: <44C7A918.5030508@wizards.de>
Message-ID: <44C7B36B.3050600@wizards.de>

Sorry for talking to myself here, but..

> The very excellent JCIP book refers to a queueing logging mechanism as
> example for various performance tricks, blocking queues etc. Surely
> someone must have done this as a configurable log4j drop-in already? Any
> pointers?

..all you need is org.apache.log4j.AsyncAppender. Duh! :)
Sorry for the noise.

Holger

