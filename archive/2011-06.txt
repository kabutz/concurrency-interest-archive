From aleksey.shipilev at gmail.com  Thu Jun  2 10:29:12 2011
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Thu, 2 Jun 2011 18:29:12 +0400
Subject: [concurrency-interest] ThreadLocalRandom initial seed
Message-ID: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>

Hi,

I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
reads: "ThreadLocalRandom is initialized with an internally generated
seed that may not otherwise be modified." I would expect TLR called in
several threads concurrently to have different global values. But
apparently the internal seed in TLR always has the same seed (which is
default value for long).

Is this intentional? Or just oversight that should be fixed?

I.e. I would expect my test [1] print all-different values per thread,
like regular Random does.

That's what happens now:

Regular thread-local Random
780
4307
9112
4368
6673
========
4143
4905
2331
154
2887
========
9586
6161
9948
4179
3608
========

ThreadLocalRandom
0
6118
1895
7186
7366
========
0
6118
1895
7186
7366
========
0
6118
1895
7186
7366
========

Thanks,
Aleksey.

[1]
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

public class Main {

    public static ThreadLocal<Random> random = new ThreadLocal<Random>() {
        @Override
        protected Random initialValue() {
            return new Random();
        }
    };

    public static void main(String[] args) throws InterruptedException {

        System.out.println("Regular thread-local Random");
        for (int i = 0; i < 3; i++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int c = 0; c < 5; c++) {
                        System.out.println(random.get().nextInt(10000));
                    }
                    System.out.println("========");
                }
            });
            t.start();
            t.join();
        }

        System.out.println("ThreadLocalRandom");
        for (int i = 0; i < 5; i++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int c = 0; c < 5; c++) {

System.out.println(ThreadLocalRandom.current().nextLong(10000));
                    }
                    System.out.println("========");
                }
            });
            t.start();
            t.join();
        }

    }

}

From kasper at kav.dk  Thu Jun  2 17:43:51 2011
From: kasper at kav.dk (Kasper Nielsen)
Date: Thu, 02 Jun 2011 23:43:51 +0200
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>
References: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>
Message-ID: <4DE80417.1050404@kav.dk>

Good catch,

that is definitely a bug.

Looks like the fix to
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6937857
introduced a non-compatible change by not calling setSeed() in 
Random(long seed) anymore.

Cheers
   Kasper

On 02-06-2011 16:29, Aleksey Shipilev wrote:
> Hi,
>
> I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
> reads: "ThreadLocalRandom is initialized with an internally generated
> seed that may not otherwise be modified." I would expect TLR called in
> several threads concurrently to have different global values. But
> apparently the internal seed in TLR always has the same seed (which is
> default value for long).
>
> Is this intentional? Or just oversight that should be fixed?
>
> I.e. I would expect my test [1] print all-different values per thread,
> like regular Random does.
>
> That's what happens now:
>
> Regular thread-local Random
> 780
> 4307
> 9112
> 4368
> 6673
> ========
> 4143
> 4905
> 2331
> 154
> 2887
> ========
> 9586
> 6161
> 9948
> 4179
> 3608
> ========
>
> ThreadLocalRandom
> 0
> 6118
> 1895
> 7186
> 7366
> ========
> 0
> 6118
> 1895
> 7186
> 7366
> ========
> 0
> 6118
> 1895
> 7186
> 7366
> ========
>
> Thanks,
> Aleksey.
>
> [1]
> import java.util.Random;
> import java.util.concurrent.ThreadLocalRandom;
>
> public class Main {
>
>      public static ThreadLocal<Random>  random = new ThreadLocal<Random>() {
>          @Override
>          protected Random initialValue() {
>              return new Random();
>          }
>      };
>
>      public static void main(String[] args) throws InterruptedException {
>
>          System.out.println("Regular thread-local Random");
>          for (int i = 0; i<  3; i++) {
>              Thread t = new Thread(new Runnable() {
>                  @Override
>                  public void run() {
>                      for (int c = 0; c<  5; c++) {
>                          System.out.println(random.get().nextInt(10000));
>                      }
>                      System.out.println("========");
>                  }
>              });
>              t.start();
>              t.join();
>          }
>
>          System.out.println("ThreadLocalRandom");
>          for (int i = 0; i<  5; i++) {
>              Thread t = new Thread(new Runnable() {
>                  @Override
>                  public void run() {
>                      for (int c = 0; c<  5; c++) {
>
> System.out.println(ThreadLocalRandom.current().nextLong(10000));
>                      }
>                      System.out.println("========");
>                  }
>              });
>              t.start();
>              t.join();
>          }
>
>      }
>
> }
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From davidcholmes at aapt.net.au  Thu Jun  2 18:09:16 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 3 Jun 2011 08:09:16 +1000
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <4DE80417.1050404@kav.dk>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEININAA.davidcholmes@aapt.net.au>

I thought this had been addressed by 6955840

http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6955840

"ThreadLocalRandom bug - overridden setSeed(long) method is not invoked for
java.util.Random(long)"

David

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kasper
> Nielsen
> Sent: Friday, 3 June 2011 7:44 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
>
>
> Good catch,
>
> that is definitely a bug.
>
> Looks like the fix to
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6937857
> introduced a non-compatible change by not calling setSeed() in
> Random(long seed) anymore.
>
> Cheers
>    Kasper
>
> On 02-06-2011 16:29, Aleksey Shipilev wrote:
> > Hi,
> >
> > I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
> > reads: "ThreadLocalRandom is initialized with an internally generated
> > seed that may not otherwise be modified." I would expect TLR called in
> > several threads concurrently to have different global values. But
> > apparently the internal seed in TLR always has the same seed (which is
> > default value for long).
> >
> > Is this intentional? Or just oversight that should be fixed?
> >
> > I.e. I would expect my test [1] print all-different values per thread,
> > like regular Random does.
> >
> > That's what happens now:
> >
> > Regular thread-local Random
> > 780
> > 4307
> > 9112
> > 4368
> > 6673
> > ========
> > 4143
> > 4905
> > 2331
> > 154
> > 2887
> > ========
> > 9586
> > 6161
> > 9948
> > 4179
> > 3608
> > ========
> >
> > ThreadLocalRandom
> > 0
> > 6118
> > 1895
> > 7186
> > 7366
> > ========
> > 0
> > 6118
> > 1895
> > 7186
> > 7366
> > ========
> > 0
> > 6118
> > 1895
> > 7186
> > 7366
> > ========
> >
> > Thanks,
> > Aleksey.
> >
> > [1]
> > import java.util.Random;
> > import java.util.concurrent.ThreadLocalRandom;
> >
> > public class Main {
> >
> >      public static ThreadLocal<Random>  random = new
> ThreadLocal<Random>() {
> >          @Override
> >          protected Random initialValue() {
> >              return new Random();
> >          }
> >      };
> >
> >      public static void main(String[] args) throws
> InterruptedException {
> >
> >          System.out.println("Regular thread-local Random");
> >          for (int i = 0; i<  3; i++) {
> >              Thread t = new Thread(new Runnable() {
> >                  @Override
> >                  public void run() {
> >                      for (int c = 0; c<  5; c++) {
> >
> System.out.println(random.get().nextInt(10000));
> >                      }
> >                      System.out.println("========");
> >                  }
> >              });
> >              t.start();
> >              t.join();
> >          }
> >
> >          System.out.println("ThreadLocalRandom");
> >          for (int i = 0; i<  5; i++) {
> >              Thread t = new Thread(new Runnable() {
> >                  @Override
> >                  public void run() {
> >                      for (int c = 0; c<  5; c++) {
> >
> > System.out.println(ThreadLocalRandom.current().nextLong(10000));
> >                      }
> >                      System.out.println("========");
> >                  }
> >              });
> >              t.start();
> >              t.join();
> >          }
> >
> >      }
> >
> > }
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From aleksey.shipilev at gmail.com  Fri Jun  3 01:22:33 2011
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Fri, 3 Jun 2011 09:22:33 +0400
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGEININAA.davidcholmes@aapt.net.au>
References: <4DE80417.1050404@kav.dk>
	<NFBBKALFDCPFIDBNKAPCGEININAA.davidcholmes@aapt.net.au>
Message-ID: <BANLkTineoA_eCsxve0j5QQ2n050XdUPhLg@mail.gmail.com>

Hi David, Kasper,

This issue is still reproduced on jdk7b144, as well as
bootclasspath'ed today's binary bundle of jsr166.jar. I guess it still
not fixed then.

-Aleksey.

On Fri, Jun 3, 2011 at 2:09 AM, David Holmes <davidcholmes at aapt.net.au> wrote:
> I thought this had been addressed by 6955840
>
> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6955840
>
> "ThreadLocalRandom bug - overridden setSeed(long) method is not invoked for
> java.util.Random(long)"
>
> David
>
>> -----Original Message-----
>> From: concurrency-interest-bounces at cs.oswego.edu
>> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kasper
>> Nielsen
>> Sent: Friday, 3 June 2011 7:44 AM
>> To: concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
>>
>>
>> Good catch,
>>
>> that is definitely a bug.
>>
>> Looks like the fix to
>> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6937857
>> introduced a non-compatible change by not calling setSeed() in
>> Random(long seed) anymore.
>>
>> Cheers
>> ? ?Kasper
>>
>> On 02-06-2011 16:29, Aleksey Shipilev wrote:
>> > Hi,
>> >
>> > I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
>> > reads: "ThreadLocalRandom is initialized with an internally generated
>> > seed that may not otherwise be modified." I would expect TLR called in
>> > several threads concurrently to have different global values. But
>> > apparently the internal seed in TLR always has the same seed (which is
>> > default value for long).
>> >
>> > Is this intentional? Or just oversight that should be fixed?
>> >
>> > I.e. I would expect my test [1] print all-different values per thread,
>> > like regular Random does.
>> >
>> > That's what happens now:
>> >
>> > Regular thread-local Random
>> > 780
>> > 4307
>> > 9112
>> > 4368
>> > 6673
>> > ========
>> > 4143
>> > 4905
>> > 2331
>> > 154
>> > 2887
>> > ========
>> > 9586
>> > 6161
>> > 9948
>> > 4179
>> > 3608
>> > ========
>> >
>> > ThreadLocalRandom
>> > 0
>> > 6118
>> > 1895
>> > 7186
>> > 7366
>> > ========
>> > 0
>> > 6118
>> > 1895
>> > 7186
>> > 7366
>> > ========
>> > 0
>> > 6118
>> > 1895
>> > 7186
>> > 7366
>> > ========
>> >
>> > Thanks,
>> > Aleksey.
>> >
>> > [1]
>> > import java.util.Random;
>> > import java.util.concurrent.ThreadLocalRandom;
>> >
>> > public class Main {
>> >
>> > ? ? ?public static ThreadLocal<Random> ?random = new
>> ThreadLocal<Random>() {
>> > ? ? ? ? ?@Override
>> > ? ? ? ? ?protected Random initialValue() {
>> > ? ? ? ? ? ? ?return new Random();
>> > ? ? ? ? ?}
>> > ? ? ?};
>> >
>> > ? ? ?public static void main(String[] args) throws
>> InterruptedException {
>> >
>> > ? ? ? ? ?System.out.println("Regular thread-local Random");
>> > ? ? ? ? ?for (int i = 0; i< ?3; i++) {
>> > ? ? ? ? ? ? ?Thread t = new Thread(new Runnable() {
>> > ? ? ? ? ? ? ? ? ?@Override
>> > ? ? ? ? ? ? ? ? ?public void run() {
>> > ? ? ? ? ? ? ? ? ? ? ?for (int c = 0; c< ?5; c++) {
>> >
>> System.out.println(random.get().nextInt(10000));
>> > ? ? ? ? ? ? ? ? ? ? ?}
>> > ? ? ? ? ? ? ? ? ? ? ?System.out.println("========");
>> > ? ? ? ? ? ? ? ? ?}
>> > ? ? ? ? ? ? ?});
>> > ? ? ? ? ? ? ?t.start();
>> > ? ? ? ? ? ? ?t.join();
>> > ? ? ? ? ?}
>> >
>> > ? ? ? ? ?System.out.println("ThreadLocalRandom");
>> > ? ? ? ? ?for (int i = 0; i< ?5; i++) {
>> > ? ? ? ? ? ? ?Thread t = new Thread(new Runnable() {
>> > ? ? ? ? ? ? ? ? ?@Override
>> > ? ? ? ? ? ? ? ? ?public void run() {
>> > ? ? ? ? ? ? ? ? ? ? ?for (int c = 0; c< ?5; c++) {
>> >
>> > System.out.println(ThreadLocalRandom.current().nextLong(10000));
>> > ? ? ? ? ? ? ? ? ? ? ?}
>> > ? ? ? ? ? ? ? ? ? ? ?System.out.println("========");
>> > ? ? ? ? ? ? ? ? ?}
>> > ? ? ? ? ? ? ?});
>> > ? ? ? ? ? ? ?t.start();
>> > ? ? ? ? ? ? ?t.join();
>> > ? ? ? ? ?}
>> >
>> > ? ? ?}
>> >
>> > }
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From davidcholmes at aapt.net.au  Fri Jun  3 02:43:17 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 3 Jun 2011 16:43:17 +1000
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <BANLkTineoA_eCsxve0j5QQ2n050XdUPhLg@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEJCINAA.davidcholmes@aapt.net.au>

Aleksey,

The problem is not the seed - all threads do get a distinct seed. The problem is that the first call to nextInt(n) is always returning zero - hence the sequence will always be the same. I haven't yet determined exactly what is going wrong.

David

> -----Original Message-----
> From: Aleksey Shipilev [mailto:aleksey.shipilev at gmail.com]
> Sent: Friday, 3 June 2011 3:23 PM
> To: dholmes at ieee.org
> Cc: Kasper Nielsen; concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
> 
> 
> Hi David, Kasper,
> 
> This issue is still reproduced on jdk7b144, as well as
> bootclasspath'ed today's binary bundle of jsr166.jar. I guess it still
> not fixed then.
> 
> -Aleksey.
> 
> On Fri, Jun 3, 2011 at 2:09 AM, David Holmes 
> <davidcholmes at aapt.net.au> wrote:
> > I thought this had been addressed by 6955840
> >
> > http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6955840
> >
> > "ThreadLocalRandom bug - overridden setSeed(long) method is not 
> invoked for
> > java.util.Random(long)"
> >
> > David
> >
> >> -----Original Message-----
> >> From: concurrency-interest-bounces at cs.oswego.edu
> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kasper
> >> Nielsen
> >> Sent: Friday, 3 June 2011 7:44 AM
> >> To: concurrency-interest at cs.oswego.edu
> >> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
> >>
> >>
> >> Good catch,
> >>
> >> that is definitely a bug.
> >>
> >> Looks like the fix to
> >> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6937857
> >> introduced a non-compatible change by not calling setSeed() in
> >> Random(long seed) anymore.
> >>
> >> Cheers
> >>    Kasper
> >>
> >> On 02-06-2011 16:29, Aleksey Shipilev wrote:
> >> > Hi,
> >> >
> >> > I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
> >> > reads: "ThreadLocalRandom is initialized with an internally generated
> >> > seed that may not otherwise be modified." I would expect TLR 
> called in
> >> > several threads concurrently to have different global values. But
> >> > apparently the internal seed in TLR always has the same seed 
> (which is
> >> > default value for long).
> >> >
> >> > Is this intentional? Or just oversight that should be fixed?
> >> >
> >> > I.e. I would expect my test [1] print all-different values 
> per thread,
> >> > like regular Random does.
> >> >
> >> > That's what happens now:
> >> >
> >> > Regular thread-local Random
> >> > 780
> >> > 4307
> >> > 9112
> >> > 4368
> >> > 6673
> >> > ========
> >> > 4143
> >> > 4905
> >> > 2331
> >> > 154
> >> > 2887
> >> > ========
> >> > 9586
> >> > 6161
> >> > 9948
> >> > 4179
> >> > 3608
> >> > ========
> >> >
> >> > ThreadLocalRandom
> >> > 0
> >> > 6118
> >> > 1895
> >> > 7186
> >> > 7366
> >> > ========
> >> > 0
> >> > 6118
> >> > 1895
> >> > 7186
> >> > 7366
> >> > ========
> >> > 0
> >> > 6118
> >> > 1895
> >> > 7186
> >> > 7366
> >> > ========
> >> >
> >> > Thanks,
> >> > Aleksey.
> >> >
> >> > [1]
> >> > import java.util.Random;
> >> > import java.util.concurrent.ThreadLocalRandom;
> >> >
> >> > public class Main {
> >> >
> >> >      public static ThreadLocal<Random>  random = new
> >> ThreadLocal<Random>() {
> >> >          @Override
> >> >          protected Random initialValue() {
> >> >              return new Random();
> >> >          }
> >> >      };
> >> >
> >> >      public static void main(String[] args) throws
> >> InterruptedException {
> >> >
> >> >          System.out.println("Regular thread-local Random");
> >> >          for (int i = 0; i<  3; i++) {
> >> >              Thread t = new Thread(new Runnable() {
> >> >                  @Override
> >> >                  public void run() {
> >> >                      for (int c = 0; c<  5; c++) {
> >> >
> >> System.out.println(random.get().nextInt(10000));
> >> >                      }
> >> >                      System.out.println("========");
> >> >                  }
> >> >              });
> >> >              t.start();
> >> >              t.join();
> >> >          }
> >> >
> >> >          System.out.println("ThreadLocalRandom");
> >> >          for (int i = 0; i<  5; i++) {
> >> >              Thread t = new Thread(new Runnable() {
> >> >                  @Override
> >> >                  public void run() {
> >> >                      for (int c = 0; c<  5; c++) {
> >> >
> >> > System.out.println(ThreadLocalRandom.current().nextLong(10000));
> >> >                      }
> >> >                      System.out.println("========");
> >> >                  }
> >> >              });
> >> >              t.start();
> >> >              t.join();
> >> >          }
> >> >
> >> >      }
> >> >
> >> > }
> >> > _______________________________________________
> >> > Concurrency-interest mailing list
> >> > Concurrency-interest at cs.oswego.edu
> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >> >
> >>
> >> _______________________________________________
> >> Concurrency-interest mailing list
> >> Concurrency-interest at cs.oswego.edu
> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >>
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> 



From aleksey.shipilev at gmail.com  Fri Jun  3 04:12:47 2011
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Fri, 3 Jun 2011 12:12:47 +0400
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEJCINAA.davidcholmes@aapt.net.au>
References: <BANLkTineoA_eCsxve0j5QQ2n050XdUPhLg@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCIEJCINAA.davidcholmes@aapt.net.au>
Message-ID: <BANLkTinms4ozEJsgiwsjO_o6t1fD88u7uQ@mail.gmail.com>

David,

I had checked out jsr166 source, instrumented TLR, and this is the output:

TLR.<init>(): rnd = 0
TLR.next(): rnd before = 0
TLR.next(): rnd after = 11
0
TLR.next(): rnd before = 11
TLR.next(): rnd after = 277363943098
6118
TLR.next(): rnd before = 277363943098
TLR.next(): rnd after = 11718085204285
1895
TLR.next(): rnd before = 11718085204285
TLR.next(): rnd after = 49720483695876
7186
TLR.next(): rnd before = 49720483695876
TLR.next(): rnd after = 102626409374399
7366

So, rnd (TLR's "seed") is always 0, and setSeed() is not being called
from super-Random. Forcibly setting rnd = System.nanoTime() in
TLR.<init>() helps.

-Aleksey.
On Fri, Jun 3, 2011 at 10:43 AM, David Holmes <davidcholmes at aapt.net.au> wrote:
> Aleksey,
>
> The problem is not the seed - all threads do get a distinct seed. The problem is that the first call to nextInt(n) is always returning zero - hence the sequence will always be the same. I haven't yet determined exactly what is going wrong.
>
> David
>
>> -----Original Message-----
>> From: Aleksey Shipilev [mailto:aleksey.shipilev at gmail.com]
>> Sent: Friday, 3 June 2011 3:23 PM
>> To: dholmes at ieee.org
>> Cc: Kasper Nielsen; concurrency-interest at cs.oswego.edu
>> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
>>
>>
>> Hi David, Kasper,
>>
>> This issue is still reproduced on jdk7b144, as well as
>> bootclasspath'ed today's binary bundle of jsr166.jar. I guess it still
>> not fixed then.
>>
>> -Aleksey.
>>
>> On Fri, Jun 3, 2011 at 2:09 AM, David Holmes
>> <davidcholmes at aapt.net.au> wrote:
>> > I thought this had been addressed by 6955840
>> >
>> > http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6955840
>> >
>> > "ThreadLocalRandom bug - overridden setSeed(long) method is not
>> invoked for
>> > java.util.Random(long)"
>> >
>> > David
>> >
>> >> -----Original Message-----
>> >> From: concurrency-interest-bounces at cs.oswego.edu
>> >> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Kasper
>> >> Nielsen
>> >> Sent: Friday, 3 June 2011 7:44 AM
>> >> To: concurrency-interest at cs.oswego.edu
>> >> Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed
>> >>
>> >>
>> >> Good catch,
>> >>
>> >> that is definitely a bug.
>> >>
>> >> Looks like the fix to
>> >> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6937857
>> >> introduced a non-compatible change by not calling setSeed() in
>> >> Random(long seed) anymore.
>> >>
>> >> Cheers
>> >> ? ?Kasper
>> >>
>> >> On 02-06-2011 16:29, Aleksey Shipilev wrote:
>> >> > Hi,
>> >> >
>> >> > I've been stumbled upon ThreadLocalRandom seed behavior. JavaDoc
>> >> > reads: "ThreadLocalRandom is initialized with an internally generated
>> >> > seed that may not otherwise be modified." I would expect TLR
>> called in
>> >> > several threads concurrently to have different global values. But
>> >> > apparently the internal seed in TLR always has the same seed
>> (which is
>> >> > default value for long).
>> >> >
>> >> > Is this intentional? Or just oversight that should be fixed?
>> >> >
>> >> > I.e. I would expect my test [1] print all-different values
>> per thread,
>> >> > like regular Random does.
>> >> >
>> >> > That's what happens now:
>> >> >
>> >> > Regular thread-local Random
>> >> > 780
>> >> > 4307
>> >> > 9112
>> >> > 4368
>> >> > 6673
>> >> > ========
>> >> > 4143
>> >> > 4905
>> >> > 2331
>> >> > 154
>> >> > 2887
>> >> > ========
>> >> > 9586
>> >> > 6161
>> >> > 9948
>> >> > 4179
>> >> > 3608
>> >> > ========
>> >> >
>> >> > ThreadLocalRandom
>> >> > 0
>> >> > 6118
>> >> > 1895
>> >> > 7186
>> >> > 7366
>> >> > ========
>> >> > 0
>> >> > 6118
>> >> > 1895
>> >> > 7186
>> >> > 7366
>> >> > ========
>> >> > 0
>> >> > 6118
>> >> > 1895
>> >> > 7186
>> >> > 7366
>> >> > ========
>> >> >
>> >> > Thanks,
>> >> > Aleksey.
>> >> >
>> >> > [1]
>> >> > import java.util.Random;
>> >> > import java.util.concurrent.ThreadLocalRandom;
>> >> >
>> >> > public class Main {
>> >> >
>> >> > ? ? ?public static ThreadLocal<Random> ?random = new
>> >> ThreadLocal<Random>() {
>> >> > ? ? ? ? ?@Override
>> >> > ? ? ? ? ?protected Random initialValue() {
>> >> > ? ? ? ? ? ? ?return new Random();
>> >> > ? ? ? ? ?}
>> >> > ? ? ?};
>> >> >
>> >> > ? ? ?public static void main(String[] args) throws
>> >> InterruptedException {
>> >> >
>> >> > ? ? ? ? ?System.out.println("Regular thread-local Random");
>> >> > ? ? ? ? ?for (int i = 0; i< ?3; i++) {
>> >> > ? ? ? ? ? ? ?Thread t = new Thread(new Runnable() {
>> >> > ? ? ? ? ? ? ? ? ?@Override
>> >> > ? ? ? ? ? ? ? ? ?public void run() {
>> >> > ? ? ? ? ? ? ? ? ? ? ?for (int c = 0; c< ?5; c++) {
>> >> >
>> >> System.out.println(random.get().nextInt(10000));
>> >> > ? ? ? ? ? ? ? ? ? ? ?}
>> >> > ? ? ? ? ? ? ? ? ? ? ?System.out.println("========");
>> >> > ? ? ? ? ? ? ? ? ?}
>> >> > ? ? ? ? ? ? ?});
>> >> > ? ? ? ? ? ? ?t.start();
>> >> > ? ? ? ? ? ? ?t.join();
>> >> > ? ? ? ? ?}
>> >> >
>> >> > ? ? ? ? ?System.out.println("ThreadLocalRandom");
>> >> > ? ? ? ? ?for (int i = 0; i< ?5; i++) {
>> >> > ? ? ? ? ? ? ?Thread t = new Thread(new Runnable() {
>> >> > ? ? ? ? ? ? ? ? ?@Override
>> >> > ? ? ? ? ? ? ? ? ?public void run() {
>> >> > ? ? ? ? ? ? ? ? ? ? ?for (int c = 0; c< ?5; c++) {
>> >> >
>> >> > System.out.println(ThreadLocalRandom.current().nextLong(10000));
>> >> > ? ? ? ? ? ? ? ? ? ? ?}
>> >> > ? ? ? ? ? ? ? ? ? ? ?System.out.println("========");
>> >> > ? ? ? ? ? ? ? ? ?}
>> >> > ? ? ? ? ? ? ?});
>> >> > ? ? ? ? ? ? ?t.start();
>> >> > ? ? ? ? ? ? ?t.join();
>> >> > ? ? ? ? ?}
>> >> >
>> >> > ? ? ?}
>> >> >
>> >> > }
>> >> > _______________________________________________
>> >> > Concurrency-interest mailing list
>> >> > Concurrency-interest at cs.oswego.edu
>> >> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >> >
>> >>
>> >> _______________________________________________
>> >> Concurrency-interest mailing list
>> >> Concurrency-interest at cs.oswego.edu
>> >> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >>
>> >
>> > _______________________________________________
>> > Concurrency-interest mailing list
>> > Concurrency-interest at cs.oswego.edu
>> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> >
>>
>
>


From mthornton at optrak.com  Fri Jun  3 04:57:46 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Fri, 03 Jun 2011 09:57:46 +0100
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEJCINAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCIEJCINAA.davidcholmes@aapt.net.au>
Message-ID: <4DE8A20A.2080809@optrak.com>

On 03/06/11 07:43, David Holmes wrote:
> Aleksey,
>
> The problem is not the seed - all threads do get a distinct seed. The problem is that the first call to nextInt(n) is always returning zero - hence the sequence will always be the same. I haven't yet determined exactly what is going wrong.
>
> David
>
ThreadLocalRandom uses its own seed, not the seed of the super class.

     ThreadLocalRandom() {
         super();
         initialized = true;
     }

This uselessly initialises the parent seed via the default constructor but leaves the real seed at zero.


     ThreadLocalRandom() {
         super(0); // don't bother generating a seed we don't use
	setSeed(System.nanoTime());
         initialized = true;
     }

Mark Thornton




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110603/ab22eb3d/attachment.html>

From davidcholmes at aapt.net.au  Fri Jun  3 07:38:34 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Fri, 3 Jun 2011 21:38:34 +1000
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <4DE8A20A.2080809@optrak.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEJDINAA.davidcholmes@aapt.net.au>

Thanks for correcxting me on that. This sure is confusing. It would seem
that  6955840 although trying to allow setSeed to be called from the random
constructor was completely pointless because Random stopped calling the
setSeed method.

I hope Martin is watching and can give some input here. It certainly seems
that we never properly initialize a ThreadLocalRandom!

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Mark
Thornton
  Sent: Friday, 3 June 2011 6:58 PM
  To: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] ThreadLocalRandom initial seed


  On 03/06/11 07:43, David Holmes wrote:
Aleksey,

The problem is not the seed - all threads do get a distinct seed. The
problem is that the first call to nextInt(n) is always returning zero -
hence the sequence will always be the same. I haven't yet determined exactly
what is going wrong.

David

ThreadLocalRandom uses its own seed, not the seed of the super class.


    ThreadLocalRandom() {
        super();
        initialized = true;
    }

This uselessly initialises the parent seed via the default constructor but
leaves the real seed at zero.


    ThreadLocalRandom() {
        super(0); // don't bother generating a seed we don't use
	setSeed(System.nanoTime());
        initialized = true;
    }

Mark Thornton



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110603/40f83f1a/attachment.html>

From mthornton at optrak.com  Fri Jun  3 09:11:37 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Fri, 03 Jun 2011 14:11:37 +0100
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEJDINAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCMEJDINAA.davidcholmes@aapt.net.au>
Message-ID: <4DE8DD89.6030304@optrak.com>

On 03/06/11 12:38, David Holmes wrote:
> Thanks for correcxting me on that. This sure is confusing. It would 
> seem that 6955840 although trying to allow setSeed to be called from 
> the random constructor was completely pointless because Random stopped 
> calling the setSeed method.
> I hope Martin is watching and can give some input here. It certainly 
> seems that we never properly initialize a ThreadLocalRandom!
> David
>
>
>          ThreadLocalRandom() {
>              super(0); // don't bother generating a seed we don't use
>     	setSeed(System.nanoTime());
>              initialized = true;
>          }
>
>     Mark Thornton
>

For people with very fast machines (and/or poor implementations of 
System.nanoTime()), the following initialisation may be better:

     private static final Random seedSource = new Random();

     ThreadLocalRandom() {
         super(0); // don't bother generating a seed we don't use
	setSeed(seedSource.nextLong());
         initialized = true;
     }


Mark

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110603/9ed53e75/attachment.html>

From martinrb at google.com  Fri Jun  3 17:35:52 2011
From: martinrb at google.com (Martin Buchholz)
Date: Fri, 3 Jun 2011 14:35:52 -0700
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>
References: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>
Message-ID: <BANLkTin=mj1+0+8GZLkmAFiT9WmUa8qg1GsSkBjQptEyVpGRaw@mail.gmail.com>

This is my fault.

As penance, here's a test for the TLR tck testcase:


Index: ThreadLocalRandomTest.java
===================================================================
RCS file: /export/home/jsr166/jsr166/jsr166/src/test/tck/ThreadLocalRandomTest.java,v
retrieving revision 1.10
diff -u -r1.10 ThreadLocalRandomTest.java
--- ThreadLocalRandomTest.java	31 May 2011 16:16:24 -0000	1.10
+++ ThreadLocalRandomTest.java	3 Jun 2011 21:29:51 -0000
@@ -6,6 +6,8 @@
 import junit.framework.*;
 import java.util.*;
 import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;

 public class ThreadLocalRandomTest extends JSR166TestCase {

@@ -252,4 +254,40 @@
         }
     }

+    /**
+     * Different threads produce different pseudo-random sequences
+     */
+    public void testDifferentSequences() {
+        // Don't use main thread's ThreadLocalRandom - it is likely to
+        // be polluted by previous tests.
+        final AtomicReference<ThreadLocalRandom> threadLocalRandom =
+            new AtomicReference<ThreadLocalRandom>();
+        final AtomicLong rand = new AtomicLong();
+
+        long firstRand = 0;
+        ThreadLocalRandom firstThreadLocalRandom = null;
+
+        final CheckedRunnable getRandomState = new CheckedRunnable() {
+            public void realRun() {
+                ThreadLocalRandom current = ThreadLocalRandom.current();
+                assertSame(current, ThreadLocalRandom.current());
+                assertNotSame(current, threadLocalRandom.get());
+                rand.set(current.nextLong());
+                threadLocalRandom.set(current);
+            }};
+
+        Thread first = newStartedThread(getRandomState);
+        awaitTermination(first);
+        firstRand = rand.get();
+        firstThreadLocalRandom = threadLocalRandom.get();
+
+        for (int i = 0; i < NCALLS; i++) {
+            Thread t = newStartedThread(getRandomState);
+            awaitTermination(t);
+            if (firstRand != rand.get())
+                return;
+        }
+        fail("all threads generate the same pseudo-random sequence");
+    }
+
 }


and here's a fix for Random.java:

I tried to save a couple of volatile writes in the common case, and
this is a slightly gross way of continuing to do that:
(of course, the "clean" version of this works as well)

diff --git a/src/share/classes/java/util/Random.java
b/src/share/classes/java/util/Random.java
--- a/src/share/classes/java/util/Random.java
+++ b/src/share/classes/java/util/Random.java
@@ -118,7 +118,13 @@
      * @see   #setSeed(long)
      */
     public Random(long seed) {
-        this.seed = new AtomicLong(initialScramble(seed));
+        if (getClass() == Random.class)
+            this.seed = new AtomicLong(initialScramble(seed));
+        else {
+            // subclass might have overriden setSeed
+            this.seed = new AtomicLong(0L);
+            setSeed(seed);
+        }
     }

     private static long initialScramble(long seed) {

From martinrb at google.com  Mon Jun  6 16:27:44 2011
From: martinrb at google.com (Martin Buchholz)
Date: Mon, 6 Jun 2011 13:27:44 -0700
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <BANLkTin=mj1+0+8GZLkmAFiT9WmUa8qg1GsSkBjQptEyVpGRaw@mail.gmail.com>
References: <BANLkTing9Vx0_zOpY_sS75e0eTReocfd+w@mail.gmail.com>
	<BANLkTin=mj1+0+8GZLkmAFiT9WmUa8qg1GsSkBjQptEyVpGRaw@mail.gmail.com>
Message-ID: <BANLkTi=E2rYKmoV27W_X4Z5VWsMTKRPM6XxQ_=sMqe3aanJm2w@mail.gmail.com>

On Fri, Jun 3, 2011 at 14:35, Martin Buchholz <martinrb at google.com> wrote:

jsr166 CVS now has a fixed version of Random.java that causes
ThreadLocalRandom to work correctly.

This bug in openjdk7 Random.java is a regression from openjdk6 because
jsr166 CVS ThreadLocalRandom works just fine with openjdk6 Random, but
not with openjdk7 Random.java.  Similarily for any other Random
subclass that relied on the Random constructor calling setSeed, which
is a reasonable expectation given the javadoc.

http://download.oracle.com/javase/7/docs/api/java/util/Random.html#Random(long)

@@ -118,7 +118,13 @@
      * @see   #setSeed(long)
      */
     public Random(long seed) {
-        this.seed = new AtomicLong(initialScramble(seed));
+        if (getClass() == Random.class)
+            this.seed = new AtomicLong(initialScramble(seed));
+        else {
+            // subclass might have overriden setSeed
+            this.seed = new AtomicLong();
+            setSeed(seed);
+        }
     }

     private static long initialScramble(long seed) {


Martin

> diff --git a/src/share/classes/java/util/Random.java
> b/src/share/classes/java/util/Random.java
> --- a/src/share/classes/java/util/Random.java
> +++ b/src/share/classes/java/util/Random.java
> @@ -118,7 +118,13 @@
> ? ? ?* @see ? #setSeed(long)
> ? ? ?*/
> ? ? public Random(long seed) {
> - ? ? ? ?this.seed = new AtomicLong(initialScramble(seed));
> + ? ? ? ?if (getClass() == Random.class)
> + ? ? ? ? ? ?this.seed = new AtomicLong(initialScramble(seed));
> + ? ? ? ?else {
> + ? ? ? ? ? ?// subclass might have overriden setSeed
> + ? ? ? ? ? ?this.seed = new AtomicLong(0L);
> + ? ? ? ? ? ?setSeed(seed);
> + ? ? ? ?}
> ? ? }
>
> ? ? private static long initialScramble(long seed) {
>


From davidcholmes at aapt.net.au  Mon Jun  6 16:38:14 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 7 Jun 2011 06:38:14 +1000
Subject: [concurrency-interest] ThreadLocalRandom initial seed
In-Reply-To: <BANLkTi=E2rYKmoV27W_X4Z5VWsMTKRPM6XxQ_=sMqe3aanJm2w@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMELEINAA.davidcholmes@aapt.net.au>

Martin,

> On Fri, Jun 3, 2011 at 14:35, Martin Buchholz <martinrb at google.com> wrote:
>
> jsr166 CVS now has a fixed version of Random.java that causes
> ThreadLocalRandom to work correctly.
>
> This bug in openjdk7 Random.java is a regression from openjdk6 because
> jsr166 CVS ThreadLocalRandom works just fine with openjdk6 Random, but
> not with openjdk7 Random.java.  Similarily for any other Random
> subclass that relied on the Random constructor calling setSeed, which
> is a reasonable expectation given the javadoc.

This was the subject of the original bug and it was deemed that the spec did
not require that the constructor call setSeed - it only had to act, with
respect to the Random class itself, as-if it had called setSeed.

We've ended up with a bit of a mess here, but it's been discovered too late.

David
-----


> http://download.oracle.com/javase/7/docs/api/java/util/Random.html
#Random(long)

@@ -118,7 +118,13 @@
      * @see   #setSeed(long)
      */
     public Random(long seed) {
-        this.seed = new AtomicLong(initialScramble(seed));
+        if (getClass() == Random.class)
+            this.seed = new AtomicLong(initialScramble(seed));
+        else {
+            // subclass might have overriden setSeed
+            this.seed = new AtomicLong();
+            setSeed(seed);
+        }
     }

     private static long initialScramble(long seed) {


Martin

> diff --git a/src/share/classes/java/util/Random.java
> b/src/share/classes/java/util/Random.java
> --- a/src/share/classes/java/util/Random.java
> +++ b/src/share/classes/java/util/Random.java
> @@ -118,7 +118,13 @@
> ? ? ?* @see ? #setSeed(long)
> ? ? ?*/
> ? ? public Random(long seed) {
> - ? ? ? ?this.seed = new AtomicLong(initialScramble(seed));
> + ? ? ? ?if (getClass() == Random.class)
> + ? ? ? ? ? ?this.seed = new AtomicLong(initialScramble(seed));
> + ? ? ? ?else {
> + ? ? ? ? ? ?// subclass might have overriden setSeed
> + ? ? ? ? ? ?this.seed = new AtomicLong(0L);
> + ? ? ? ? ? ?setSeed(seed);
> + ? ? ? ?}
> ? ? }
>
> ? ? private static long initialScramble(long seed) {
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From aleksey.shipilev at gmail.com  Wed Jun  8 02:48:25 2011
From: aleksey.shipilev at gmail.com (Aleksey Shipilev)
Date: Wed, 8 Jun 2011 10:48:25 +0400
Subject: [concurrency-interest] Multiton pattern and double-checked locking
Message-ID: <BANLkTi=Ezo_N6RY+e0TxUwsU3PMp5VSfXA@mail.gmail.com>

Hi,

One colleague of mine pointed out Multiton wikipedia article which
tries to do double-checked locking [1]. I see that code ultimately
broken for two reasons:
 a. unsynchronized HashMap.get() breaks out without proper
synchronization when another caller structurally modifies the map.
 b. there's no visibility guarantees for FooMultiton fields implied on
HashMap.put(K, V).

So, I'm trying to get my head around correct and fast Multiton
implementation. It boiled down to the code below:

public class FooMultiton {
    private static final ConcurrentMap<Object, Wrapper> instances =
new ConcurrentHashMap<>();

    private FooMultiton() {}

    public static FooMultiton getInstance(Object key) {
        FooMultiton instance = instances.get(key)
        if (instance == null) {
            // slow-path, need to atomically create
            Wrapper newWrap = new Wrapper();
            Wrapper extWrap = instances.putIfAbsent(key, newWrap);
            instance = (extWrap == null) ? newWrap.instance : extWrap.instance;
        }
        return instance;
    }

    private static class Wrapper {
        public final FooMultiton instance;

        public Wrapper(FooMultiton instance)  {
            // this code should enforce visibility of FooMultiton fields.
            // can use volatile, but apparently final field semantics
does the same thing
            // when I'm doing init in constructor
            FooMultiton t = new FooMultiton();
            t.set...();
            this.instance = t;
        }
    }

 }

Is it correct, or I'm missing something?

-Aleksey.


[1] see second code chunk, http://en.wikipedia.org/wiki/Multiton_pattern#Java

From joe.bowbeer at gmail.com  Wed Jun  8 03:58:05 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Wed, 8 Jun 2011 00:58:05 -0700
Subject: [concurrency-interest] Multiton pattern and double-checked
	locking
In-Reply-To: <BANLkTi=Ezo_N6RY+e0TxUwsU3PMp5VSfXA@mail.gmail.com>
References: <BANLkTi=Ezo_N6RY+e0TxUwsU3PMp5VSfXA@mail.gmail.com>
Message-ID: <BANLkTikxncsBmO3jExu+jP6sxOqd52PSgg@mail.gmail.com>

This looks like the Memoize pattern, which is implemented in JCiP using a
FutureTask instead of a custom wrapper.

http://jcip.net/listings.html

What you wrote looks OK as far as putIfAbsent is concerned.

However, the declaration of your Wrapper(...) constructor looks wrong.

Joe

On Tue, Jun 7, 2011 at 11:48 PM, Aleksey Shipilev wrote:

> Hi,
>
> One colleague of mine pointed out Multiton wikipedia article which
> tries to do double-checked locking [1]. I see that code ultimately
> broken for two reasons:
>  a. unsynchronized HashMap.get() breaks out without proper
> synchronization when another caller structurally modifies the map.
>  b. there's no visibility guarantees for FooMultiton fields implied on
> HashMap.put(K, V).
>
> So, I'm trying to get my head around correct and fast Multiton
> implementation. It boiled down to the code below:
>
> public class FooMultiton {
>    private static final ConcurrentMap<Object, Wrapper> instances =
> new ConcurrentHashMap<>();
>
>    private FooMultiton() {}
>
>    public static FooMultiton getInstance(Object key) {
>        FooMultiton instance = instances.get(key)
>        if (instance == null) {
>            // slow-path, need to atomically create
>            Wrapper newWrap = new Wrapper();
>            Wrapper extWrap = instances.putIfAbsent(key, newWrap);
>            instance = (extWrap == null) ? newWrap.instance :
> extWrap.instance;
>        }
>        return instance;
>    }
>
>    private static class Wrapper {
>        public final FooMultiton instance;
>
>        public Wrapper(FooMultiton instance)  {
>            // this code should enforce visibility of FooMultiton fields.
>            // can use volatile, but apparently final field semantics
> does the same thing
>            // when I'm doing init in constructor
>            FooMultiton t = new FooMultiton();
>            t.set...();
>            this.instance = t;
>        }
>    }
>
>  }
>
> Is it correct, or I'm missing something?
>
> -Aleksey.
>
>
> [1] see second code chunk,
> http://en.wikipedia.org/wiki/Multiton_pattern#Java
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110608/8e0f98af/attachment.html>

From joe.bowbeer at gmail.com  Tue Jun 14 12:53:33 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 14 Jun 2011 09:53:33 -0700
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>
	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
Message-ID: <BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>

"Parallel programming, once an obscure niche, is the focus of increasing
interest as multicore chips proliferate in ordinary PCs."

<http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economist.com/node/18750706?frsc=dg%7Ca>
http://www.economist.com/node/18750706?frsc=dg%7Ca

The article mentions Scala but not java.util.concurrent.

To me, this problem still seems more "derivative" of the technology and less
driven by consumer demand, and I'm disappointed that The Economist could not
find a more compelling statement.

Is this really a case of: To the man with a multi-headed hammer, every
problem looks like a multi-headed nail?

Maybe my mobile-shaded perspective will change now that multicores are
shipping on handsets...

Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/8c7e392c/attachment.html>

From tim at peierls.net  Tue Jun 14 14:36:00 2011
From: tim at peierls.net (Tim Peierls)
Date: Tue, 14 Jun 2011 14:36:00 -0400
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>
	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
	<BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>
Message-ID: <BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>

I didn't pick up the everything-is-a-nail vibe. The article just points out
that languages, programmers, and educators are unexpectedly playing catch-up
because of the proliferation of multicores on the desktop, something readers
of the Economist probably wouldn't know about without being in the biz.

--tim

On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> "Parallel programming, once an obscure niche, is the focus of increasing
> interest as multicore chips proliferate in ordinary PCs."
>
> <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economist.com/node/18750706?frsc=dg%7Ca>
> http://www.economist.com/node/18750706?frsc=dg%7Ca
>
> The article mentions Scala but not java.util.concurrent.
>
> To me, this problem still seems more "derivative" of the technology and
> less driven by consumer demand, and I'm disappointed that The Economist
> could not find a more compelling statement.
>
> Is this really a case of: To the man with a multi-headed hammer, every
> problem looks like a multi-headed nail?
>
> Maybe my mobile-shaded perspective will change now that multicores are
> shipping on handsets...
>
> Joe
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/ccc1da2b/attachment.html>

From joe.bowbeer at gmail.com  Tue Jun 14 14:48:58 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 14 Jun 2011 11:48:58 -0700
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>
	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
	<BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>
	<BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>
Message-ID: <BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>

The problem is always stated as "we have these multicores so now we have to
figure out how to use them".

On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:

> I didn't pick up the everything-is-a-nail vibe. The article just points out
> that languages, programmers, and educators are unexpectedly playing catch-up
> because of the proliferation of multicores on the desktop, something readers
> of the Economist probably wouldn't know about without being in the biz.
>
> --tim
>
> On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>
>> "Parallel programming, once an obscure niche, is the focus of increasing
>> interest as multicore chips proliferate in ordinary PCs."
>>
>> <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economist.com/node/18750706?frsc=dg%7Ca>
>> http://www.economist.com/node/18750706?frsc=dg%7Ca
>>
>> The article mentions Scala but not java.util.concurrent.
>>
>> To me, this problem still seems more "derivative" of the technology and
>> less driven by consumer demand, and I'm disappointed that The Economist
>> could not find a more compelling statement.
>>
>> Is this really a case of: To the man with a multi-headed hammer, every
>> problem looks like a multi-headed nail?
>>
>> Maybe my mobile-shaded perspective will change now that multicores are
>> shipping on handsets...
>>
>> Joe
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/ef310bea/attachment.html>

From gergg at cox.net  Tue Jun 14 16:32:26 2011
From: gergg at cox.net (Gregg Wonderly)
Date: Tue, 14 Jun 2011 15:32:26 -0500
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>	<BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>	<BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>
	<BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>
Message-ID: <4DF7C55A.4060201@cox.net>

On 6/14/2011 1:48 PM, Joe Bowbeer wrote:
> The problem is always stated as "we have these multicores so now we have to
> figure out how to use them".

This is my view point as well.  Even though Java had locking available to 
address the issue of multi-threading through multi-processor machines, the 
average java programmer had no access to such machines except in places like 
JavaEE environments, where there as limited access to "threading".

When the first multi-core machine experience landed on my desktop, it was 
amazing how many problems I found in software which had worked flawlessly 
before, simply because of visiblility, optmization (the rediculous volatile 
optimization to while(true)) as well as concurrent access on unlocked structures.

There were not "path" analysis tools (and I still don't see them today) which 
can exhaustively document the "single threaded" entry points into code so that 
you can say, hey, that's not used by a single thread, and fix the problems.

Sure, the chip manufactures think that it is great to add more cores to make 
"processors" "more performant", but developers can get no benefits from that 
simple step without a steep learning curve in something that many seemed to have 
never be trained in.

My view point is that more than 80% of the people that exist today as "software 
developers" are just "microsoft office plugin developers" or "self trained" "web 
developers" who have a very small set of skills in advanced computing 
engineering.  The end result, is that you can count on concurrency bugs, 
circular wait, and (with Java) visibility bugs in almost every application in 
the public computing infrastructure.

The other 20% are people working in real-time or classified/high performance 
projects which only hire people with demonstrated skill sets.

The other 80% just need a piece of paper with a degree name on it because the 
managers and coworkers don't really know what computer science is either.

There are little, isolated groups such as those on this list, who do have 
background schooling/training and knowledge about the issues.  But, it sure 
seems like there are so many broken software systems on so many consumer devices 
as well as out on the internet as "business apps", that something is still not 
right in the tooling and/or the training of software engineers.

This whole multi-core thing is a big problem in my books.  Especially when the 
developers are doing it themselves in each app they develop, and doubly so in 
integrations of multiple such applications/libraries.

The development of the Fork/Join stuff raises the bar on level of programming 
frameworks such that it makes it a little more possible to control things.  But, 
I still feel like we are creating ants and dropping them in the dirt, and then 
running around with poison, traps, shovels and the like, trying to keep them in 
or near the place we put them, and keep them alive, but not allowing them to 
proliferate too much such that the other ants are overwhelmed.

Something a lot higher level with much more specific patterns seems to still be 
needed, and as more people adopt the current leading edge tools, I'm betting 
that even more standardizations of helpful task management and work load control 
can occur.

Gregg Wonderly

>
> On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
>
>     I didn't pick up the everything-is-a-nail vibe. The article just points out
>     that languages, programmers, and educators are unexpectedly playing catch-up
>     because of the proliferation of multicores on the desktop, something readers
>     of the Economist probably wouldn't know about without being in the biz.
>
>     --tim
>
>     On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>
>         "Parallel programming, once an obscure niche, is the focus of increasing
>         interest as multicore chips proliferate in ordinary PCs."
>
>         <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economist.com/node/18750706?frsc=dg%7Ca>
>         http://www.economist.com/node/18750706?frsc=dg%7Ca
>
>         The article mentions Scala but not java.util.concurrent.
>
>         To me, this problem still seems more "derivative" of the technology and
>         less driven by consumer demand, and I'm disappointed that The Economist
>         could not find a more compelling statement.
>
>         Is this really a case of: To the man with a multi-headed hammer, every
>         problem looks like a multi-headed nail?
>
>         Maybe my mobile-shaded perspective will change now that multicores are
>         shipping on handsets...
>
>         Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From joe.bowbeer at gmail.com  Tue Jun 14 16:33:07 2011
From: joe.bowbeer at gmail.com (Joe Bowbeer)
Date: Tue, 14 Jun 2011 13:33:07 -0700
Subject: [concurrency-interest] Economist article
In-Reply-To: <02AA127CD8DCDE48BC7D2DFB6C87083A0D99C30F@nwt-s-mbx1.rocketsoftware.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>
	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
	<BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>
	<BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>
	<BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>
	<02AA127CD8DCDE48BC7D2DFB6C87083A0D99C30F@nwt-s-mbx1.rocketsoftware.com>
Message-ID: <BANLkTi=HvZB=1Z6v5c=8S4CbWdnkixESew@mail.gmail.com>

Given that CPUs are made *for* software, I'm not buying that it is
software's problem to legitimize the multicore design.

Software's problem is satisfying the needs of the users, and in my view, a
compelling statement of the problem would address that perspective.

Oh, well...

On Tue, Jun 14, 2011 at 12:37 PM, Gary Gregory wrote:

>  That is not how the Economist article states the problem. The article
> says that CPU speed has plateaued and that cores are now used to deliver
> more performance, if software is written to use them.
>
>
>
> Gary
>
>
>
> *On Behalf Of *Joe Bowbeer
> *Sent:* Tuesday, June 14, 2011 14:49 PM
> *To:* concurrency-interest
> *Subject:* Re: [concurrency-interest] Economist article
>
>
>
> The problem is always stated as "we have these multicores so now we have to
> figure out how to use them".
>
>
>
> On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
>
>  I didn't pick up the everything-is-a-nail vibe. The article just points
> out that languages, programmers, and educators are unexpectedly playing
> catch-up because of the proliferation of multicores on the desktop,
> something readers of the Economist probably wouldn't know about without
> being in the biz.
>
>
>
> --tim
>
> On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>
>   "Parallel programming, once an obscure niche, is the focus of increasing
> interest as multicore chips proliferate in ordinary PCs."
>
>
>
> http://www.economist.com/node/18750706?frsc=dg%7Ca
>
>
>
> The article mentions Scala but not java.util.concurrent.
>
>
>
> To me, this problem still seems more "derivative" of the technology and
> less driven by consumer demand, and I'm disappointed that The Economist
> could not find a more compelling statement.
>
>
>
> Is this really a case of: To the man with a multi-headed hammer, every
> problem looks like a multi-headed nail?
>
>
>
> Maybe my mobile-shaded perspective will change now that multicores are
> shipping on handsets...
>
>
>
> Joe
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/4df77fbb/attachment-0001.html>

From tim at peierls.net  Tue Jun 14 17:35:20 2011
From: tim at peierls.net (Tim Peierls)
Date: Tue, 14 Jun 2011 17:35:20 -0400
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTi=HvZB=1Z6v5c=8S4CbWdnkixESew@mail.gmail.com>
References: <78F1C759D89E1C44A6DD4C06B9A4B270C398F3394B@E2K7MBX.napier-mail.napier.ac.uk>
	<BANLkTikN-jAoPn9cSkAr11DRWSW8MNGT5w@mail.gmail.com>
	<BANLkTi=x4Rx4Gw0yUyz+ghbuHXx8EKizaw@mail.gmail.com>
	<BANLkTimPcbwKJfCbtYgNmdX1d5Kg2pCa-Q@mail.gmail.com>
	<BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>
	<02AA127CD8DCDE48BC7D2DFB6C87083A0D99C30F@nwt-s-mbx1.rocketsoftware.com>
	<BANLkTi=HvZB=1Z6v5c=8S4CbWdnkixESew@mail.gmail.com>
Message-ID: <BANLkTimF1mm_LVUnPcLzj_d9xf0Czdu-Hw@mail.gmail.com>

On Tue, Jun 14, 2011 at 4:33 PM, Joe Bowbeer <joe.bowbeer at gmail.com> wrote:

> Given that CPUs are made *for* software, I'm not buying that it is
> software's problem to legitimize the multicore design.
>
> Software's problem is satisfying the needs of the users, and in my view, a
> compelling statement of the problem would address that perspective.
>

The article reports, in terms that a layman can understand, how some current
trends in hardware have posed a problem for some software developers. Seems
unfair to blame the article for not tackling the larger subject of how
software can fail to meet the needs of its users.

If you were charged with fixing it to your satisfaction, would you rewrite
the article completely or just add a few sentences to prevent readers from
thinking the tail wags the dog?

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/faf524f9/attachment.html>

From davidcholmes at aapt.net.au  Tue Jun 14 18:02:00 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 15 Jun 2011 08:02:00 +1000
Subject: [concurrency-interest] Economist article
In-Reply-To: <BANLkTimazNAbvatUDy=T7+BP=BF=9Q6-jg@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOENKINAA.davidcholmes@aapt.net.au>

And it's always written as-if we'd never had multi-processors before we had
multi-core.

David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Joe Bowbeer
  Sent: Wednesday, 15 June 2011 4:49 AM
  To: concurrency-interest
  Subject: Re: [concurrency-interest] Economist article


  The problem is always stated as "we have these multicores so now we have
to figure out how to use them".


  On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
    I didn't pick up the everything-is-a-nail vibe. The article just points
out that languages, programmers, and educators are unexpectedly playing
catch-up because of the proliferation of multicores on the desktop,
something readers of the Economist probably wouldn't know about without
being in the biz.


    --tim


    On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:

      "Parallel programming, once an obscure niche, is the focus of
increasing interest as multicore chips proliferate in ordinary PCs."


      http://www.economist.com/node/18750706?frsc=dg%7Ca


      The article mentions Scala but not java.util.concurrent.


      To me, this problem still seems more "derivative" of the technology
and less driven by consumer demand, and I'm disappointed that The Economist
could not find a more compelling statement.


      Is this really a case of: To the man with a multi-headed hammer, every
problem looks like a multi-headed nail?


      Maybe my mobile-shaded perspective will change now that multicores are
shipping on handsets...


      Joe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110615/dfde3822/attachment.html>

From gregg at cytetech.com  Tue Jun 14 18:20:17 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 14 Jun 2011 17:20:17 -0500
Subject: [concurrency-interest] Economist article
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOENKINAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCOENKINAA.davidcholmes@aapt.net.au>
Message-ID: <4DF7DEA1.2010800@cytetech.com>

On 6/14/2011 5:02 PM, David Holmes wrote:
> And it's always written as-if we'd never had multi-processors before we had
> multi-core.

That's a fair viewpoint, but multi-processor machines were a rare occurrence. 
Only when multi-core hit the desktop was there plenty of places to "witness" the 
problems of single path software designs on multi-path processor systems.

In so many ways, multi-core was "sprung" on software developers and their 
development tool sets with little help and support for developers to understand 
and adequately "prove" software systems to be safe and operate as designed, really!

Gregg Wonderly

> David
>
>     -----Original Message-----
>     *From:* concurrency-interest-bounces at cs.oswego.edu
>     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *Joe Bowbeer
>     *Sent:* Wednesday, 15 June 2011 4:49 AM
>     *To:* concurrency-interest
>     *Subject:* Re: [concurrency-interest] Economist article
>
>     The problem is always stated as "we have these multicores so now we have to
>     figure out how to use them".
>
>     On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
>
>         I didn't pick up the everything-is-a-nail vibe. The article just points
>         out that languages, programmers, and educators are unexpectedly playing
>         catch-up because of the proliferation of multicores on the desktop,
>         something readers of the Economist probably wouldn't know about without
>         being in the biz.
>
>         --tim
>
>         On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>
>             "Parallel programming, once an obscure niche, is the focus of
>             increasing interest as multicore chips proliferate in ordinary PCs."
>
>             <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economist.com/node/18750706?frsc=dg%7Ca>
>             http://www.economist.com/node/18750706?frsc=dg%7Ca
>
>             The article mentions Scala but not java.util.concurrent.
>
>             To me, this problem still seems more "derivative" of the technology
>             and less driven by consumer demand, and I'm disappointed that The
>             Economist could not find a more compelling statement.
>
>             Is this really a case of: To the man with a multi-headed hammer,
>             every problem looks like a multi-headed nail?
>
>             Maybe my mobile-shaded perspective will change now that multicores
>             are shipping on handsets...
>
>             Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From davidcholmes at aapt.net.au  Tue Jun 14 18:30:11 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Wed, 15 Jun 2011 08:30:11 +1000
Subject: [concurrency-interest] Economist article
In-Reply-To: <4DF7DEA1.2010800@cytetech.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKENLINAA.davidcholmes@aapt.net.au>

Gregg,

Gregg Wonderly writes:
> On 6/14/2011 5:02 PM, David Holmes wrote:
> > And it's always written as-if we'd never had multi-processors
> > before we had multi-core.
>
> That's a fair viewpoint, but multi-processor machines were a rare
> occurrence.
> Only when multi-core hit the desktop was there plenty of places
> to "witness" the
> problems of single path software designs on multi-path processor systems.

Maybe it's an issue of terminology but dual-processor desktops were not that
rare 10 years ago (dual proc laptops maybe). Further, hyper-threaded systems
were far from rare and still exposed race conditions masked on true
uniprocessors.

Multi-core didn't come out of thin air from left field and take us by
surprise - well not some of "us" anyway.

I find all of these articles completely disengenous because they are written
as if MP/MT/MC is something brand new that has hit us unaware and that is
just a load of bulldust. Certainly the applicability of MP/MT/MC is
spreading and the number of cores is increasing, but the basic principles of
concurrent programming apply on 2 cores as well as 200 - it is scalability
and performance that suffers as the number of cores increases (with shared
memory multi-threading anyway).

David


> In so many ways, multi-core was "sprung" on software developers and their
> development tool sets with little help and support for developers
> to understand
> and adequately "prove" software systems to be safe and operate as
> designed, really!
>
> Gregg Wonderly
>
> > David
> >
> >     -----Original Message-----
> >     *From:* concurrency-interest-bounces at cs.oswego.edu
> >     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
> Behalf Of *Joe Bowbeer
> >     *Sent:* Wednesday, 15 June 2011 4:49 AM
> >     *To:* concurrency-interest
> >     *Subject:* Re: [concurrency-interest] Economist article
> >
> >     The problem is always stated as "we have these multicores
> so now we have to
> >     figure out how to use them".
> >
> >     On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
> >
> >         I didn't pick up the everything-is-a-nail vibe. The
> article just points
> >         out that languages, programmers, and educators are
> unexpectedly playing
> >         catch-up because of the proliferation of multicores on
> the desktop,
> >         something readers of the Economist probably wouldn't
> know about without
> >         being in the biz.
> >
> >         --tim
> >
> >         On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
> >
> >             "Parallel programming, once an obscure niche, is
> the focus of
> >             increasing interest as multicore chips proliferate
> in ordinary PCs."
> >
> >
> <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.ec
onomist.com/node/18750706?frsc=dg%7Ca>
>             http://www.economist.com/node/18750706?frsc=dg%7Ca
>
>             The article mentions Scala but not java.util.concurrent.
>
>             To me, this problem still seems more "derivative" of the
technology
>             and less driven by consumer demand, and I'm disappointed that
The
>             Economist could not find a more compelling statement.
>
>             Is this really a case of: To the man with a multi-headed
hammer,
>             every problem looks like a multi-headed nail?
>
>             Maybe my mobile-shaded perspective will change now that
multicores
>             are shipping on handsets...
>
>             Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From yshavit at akiban.com  Tue Jun 14 20:27:04 2011
From: yshavit at akiban.com (Yuval Shavit)
Date: Tue, 14 Jun 2011 20:27:04 -0400
Subject: [concurrency-interest] Economist article
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKENLINAA.davidcholmes@aapt.net.au>
References: <4DF7DEA1.2010800@cytetech.com>
	<NFBBKALFDCPFIDBNKAPCKENLINAA.davidcholmes@aapt.net.au>
Message-ID: <BANLkTikKiJ0hNUm7b9GFXnmwp7AB-BF=HQ@mail.gmail.com>

As I read it, the main point of the article wasn't that multithreading is
new. Rather, it's that that while you used to be able to write a
single-threaded app and expect it to double in speed in a couple years, you
can't do that any more. These days, if you want your app do run much faster
with the latest hardware, you're probably going to have to do some MT work.
Then they go on to describe a few of the problems the development community
faces in that task, and while they certainly paint with a broad brush, I
don't think they're being * disingenuous.* I'm sure biologists can point out
any number of flaws in the Economist's coverage of the latest virus
whatsahoosit, but I find it interesting to read about what's going on in
those fields at a high level without having to understand much biology.

On Tue, Jun 14, 2011 at 6:30 PM, David Holmes <davidcholmes at aapt.net.au>wrote:

> Gregg,
>
> Gregg Wonderly writes:
> > On 6/14/2011 5:02 PM, David Holmes wrote:
> > > And it's always written as-if we'd never had multi-processors
> > > before we had multi-core.
> >
> > That's a fair viewpoint, but multi-processor machines were a rare
> > occurrence.
> > Only when multi-core hit the desktop was there plenty of places
> > to "witness" the
> > problems of single path software designs on multi-path processor systems.
>
> Maybe it's an issue of terminology but dual-processor desktops were not
> that
> rare 10 years ago (dual proc laptops maybe). Further, hyper-threaded
> systems
> were far from rare and still exposed race conditions masked on true
> uniprocessors.
>
> Multi-core didn't come out of thin air from left field and take us by
> surprise - well not some of "us" anyway.
>
> I find all of these articles completely disengenous because they are
> written
> as if MP/MT/MC is something brand new that has hit us unaware and that is
> just a load of bulldust. Certainly the applicability of MP/MT/MC is
> spreading and the number of cores is increasing, but the basic principles
> of
> concurrent programming apply on 2 cores as well as 200 - it is scalability
> and performance that suffers as the number of cores increases (with shared
> memory multi-threading anyway).
>
> David
>
>
> > In so many ways, multi-core was "sprung" on software developers and their
> > development tool sets with little help and support for developers
> > to understand
> > and adequately "prove" software systems to be safe and operate as
> > designed, really!
> >
> > Gregg Wonderly
> >
> > > David
> > >
> > >     -----Original Message-----
> > >     *From:* concurrency-interest-bounces at cs.oswego.edu
> > >     [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
> > Behalf Of *Joe Bowbeer
> > >     *Sent:* Wednesday, 15 June 2011 4:49 AM
> > >     *To:* concurrency-interest
> > >     *Subject:* Re: [concurrency-interest] Economist article
> > >
> > >     The problem is always stated as "we have these multicores
> > so now we have to
> > >     figure out how to use them".
> > >
> > >     On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
> > >
> > >         I didn't pick up the everything-is-a-nail vibe. The
> > article just points
> > >         out that languages, programmers, and educators are
> > unexpectedly playing
> > >         catch-up because of the proliferation of multicores on
> > the desktop,
> > >         something readers of the Economist probably wouldn't
> > know about without
> > >         being in the biz.
> > >
> > >         --tim
> > >
> > >         On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
> > >
> > >             "Parallel programming, once an obscure niche, is
> > the focus of
> > >             increasing interest as multicore chips proliferate
> > in ordinary PCs."
> > >
> > >
> > <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.ec
> onomist.com/node/18750706?frsc=dg%7Ca>
> >             http://www.economist.com/node/18750706?frsc=dg%7Ca
> >
> >             The article mentions Scala but not java.util.concurrent.
> >
> >             To me, this problem still seems more "derivative" of the
> technology
> >             and less driven by consumer demand, and I'm disappointed that
> The
> >             Economist could not find a more compelling statement.
> >
> >             Is this really a case of: To the man with a multi-headed
> hammer,
> >             every problem looks like a multi-headed nail?
> >
> >             Maybe my mobile-shaded perspective will change now that
> multicores
> >             are shipping on handsets...
> >
> >             Joe
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110614/3d5316c6/attachment-0001.html>

From gregg at cytetech.com  Tue Jun 14 22:00:06 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 14 Jun 2011 21:00:06 -0500
Subject: [concurrency-interest] Economist article
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKENLINAA.davidcholmes@aapt.net.au>
References: <NFBBKALFDCPFIDBNKAPCKENLINAA.davidcholmes@aapt.net.au>
Message-ID: <4DF81226.4000202@cytetech.com>

David, I was lumping hyper-threaded in with multi-core, sorry for not being 
clear about that.  Yes, I agree that there were some choices of multi-processor 
support on desktops, but only in large software shops was that happening.  Those 
shops were producing the old "server systems" and "realtime/high performance" 
software systems where there wasn't "Java everywhere".  There was C and there 
was P-Threads and lots of stuff like that.  But, it was really not accessible to 
the common developer because there was all the "required documentation" and very 
painful C programming and "command line tools" and "that beasty Unix stuff" to 
worry about.

I'm all too aware of many things that did happen in large corporations with very 
narrow, vertical software systems.  Java made threading dead easy to "do", but 
not so simple to get "right" because the constructs were as low level as was 
possible.  The single threaded, linear software programming taught in many 
places only hinted at the possibility of having to deal with such issues, 
because, it was not common.

It may be that many people on this list feel like there is old hat.  I've been 
dealing with lots of problems in Java software systems, over the years, related 
to people not understanding concurrency.  It's a large problem related to 
relative experience and education for sure.   Developers had no choice in 
whether the hardware changed or not.  They had limited tools to test with, 
because it required that the hardware exist and be accessible.  It existed, but 
for a lot of people, it was not accessible.

The most telling evidence of the problem, for me, is the continued problems that 
people have using the hardware, no matter what software system you want to 
consider.  Everywhere I look, there are people having to deal with concurrency 
issues in software that were not there before the presence of wide spread 
multi-core/hyper-threaded processors.

Sure, new software has the benefit of being designed with "the knowledge" 
already present.  However, the skills and tools available still don't really 
match up to what developers need.

I'd really like to see people involved in developing Data Flow based solutions 
for studying code paths and finding multi-threaded access.  We should, by now, 
for example have required annotations for classes that are multi-threaded, as 
well as method annotations that define threading characteristics.  There should 
be tools that can analyze codebases with such things and say, for sure, that 
there are multi-threaded code paths, volatile access needs and everything that 
can go wrong, spelled out.

It's just nuts to not have such tools!  Why are we content to sit around and say 
that we can't possibly analyze code paths and that you can not test to prove 
that software is concurrency safe?  With data flow analysis, every path in 
software is reachable.  Are they all necessary to traverse, no, but we have the 
ability to use software tools to make the job easier.  It just needs to be 
tackled aggressively with the right focus.

This page, http://laser.cs.umass.edu/staticanalysis/ has an illustration that 
analysis can generate results.  There are, of course things starting to happen.

The illustrative properties of this article, for me, are real world statements 
of what is actually the issue, not what some people believe might be a way to 
look at the cause of problems which developers are experiencing regarding 
concurrency.

The problems are real, and are here and now.  Our current software systems are 
very deficient in helping developers to write correct concurrent software.  We 
think of concurrency problems as "indications of stupidity, or ignorance" 
instead of as "hard problems" which require tools.  In a sense, currency 
concurrency constructs and tools are almost like assembly programming with hand 
assembly.  We know all the details and demand that developers craft all the 
intricacies each and every time, and not make mistakes and not have tools, such 
as assemblers. The fork and join framework in Java is like an assembler.  It 
makes all the right instruction codes appear in the output, but still doesn't 
help to make sure that the ordering and machine (the application logic) 
dependent issues are taken care of.

Gregg

On 6/14/2011 5:30 PM, David Holmes wrote:
> Gregg,
>
> Gregg Wonderly writes:
>> On 6/14/2011 5:02 PM, David Holmes wrote:
>>> And it's always written as-if we'd never had multi-processors
>>> before we had multi-core.
>>
>> That's a fair viewpoint, but multi-processor machines were a rare
>> occurrence.
>> Only when multi-core hit the desktop was there plenty of places
>> to "witness" the
>> problems of single path software designs on multi-path processor systems.
>
> Maybe it's an issue of terminology but dual-processor desktops were not that
> rare 10 years ago (dual proc laptops maybe). Further, hyper-threaded systems
> were far from rare and still exposed race conditions masked on true
> uniprocessors.
>
> Multi-core didn't come out of thin air from left field and take us by
> surprise - well not some of "us" anyway.
>
> I find all of these articles completely disengenous because they are written
> as if MP/MT/MC is something brand new that has hit us unaware and that is
> just a load of bulldust. Certainly the applicability of MP/MT/MC is
> spreading and the number of cores is increasing, but the basic principles of
> concurrent programming apply on 2 cores as well as 200 - it is scalability
> and performance that suffers as the number of cores increases (with shared
> memory multi-threading anyway).
>
> David
>
>
>> In so many ways, multi-core was "sprung" on software developers and their
>> development tool sets with little help and support for developers
>> to understand
>> and adequately "prove" software systems to be safe and operate as
>> designed, really!
>>
>> Gregg Wonderly
>>
>>> David
>>>
>>>      -----Original Message-----
>>>      *From:* concurrency-interest-bounces at cs.oswego.edu
>>>      [mailto:concurrency-interest-bounces at cs.oswego.edu]*On
>> Behalf Of *Joe Bowbeer
>>>      *Sent:* Wednesday, 15 June 2011 4:49 AM
>>>      *To:* concurrency-interest
>>>      *Subject:* Re: [concurrency-interest] Economist article
>>>
>>>      The problem is always stated as "we have these multicores
>> so now we have to
>>>      figure out how to use them".
>>>
>>>      On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
>>>
>>>          I didn't pick up the everything-is-a-nail vibe. The
>> article just points
>>>          out that languages, programmers, and educators are
>> unexpectedly playing
>>>          catch-up because of the proliferation of multicores on
>> the desktop,
>>>          something readers of the Economist probably wouldn't
>> know about without
>>>          being in the biz.
>>>
>>>          --tim
>>>
>>>          On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>>>
>>>              "Parallel programming, once an obscure niche, is
>> the focus of
>>>              increasing interest as multicore chips proliferate
>> in ordinary PCs."
>>>
>>>
>> <http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.ec
> onomist.com/node/18750706?frsc=dg%7Ca>
>>              http://www.economist.com/node/18750706?frsc=dg%7Ca
>>
>>              The article mentions Scala but not java.util.concurrent.
>>
>>              To me, this problem still seems more "derivative" of the
> technology
>>              and less driven by consumer demand, and I'm disappointed that
> The
>>              Economist could not find a more compelling statement.
>>
>>              Is this really a case of: To the man with a multi-headed
> hammer,
>>              every problem looks like a multi-headed nail?
>>
>>              Maybe my mobile-shaded perspective will change now that
> multicores
>>              are shipping on handsets...
>>
>>              Joe
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
>


From mohanr at fss.co.in  Wed Jun 15 06:21:07 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Wed, 15 Jun 2011 15:51:07 +0530
Subject: [concurrency-interest] Economist article
In-Reply-To: <4DF7C55A.4060201@cox.net>
Message-ID: <E763DEAFE9F15749B22571A33E165D4C74ED90@fssbemail.fss.india>

Hi,

>in places like JavaEE environments, where there as limited access to
"threading".

This is still the case wherever we use app. servers. Right ? All the
software projects I have come across use them. I understand that this is
another hurdle in the path to the adoption of java.util.concurrent.

An example could be a ThreadLocal store that might not be cleaned up by
the pool implementation of the app. server. 

Thanks,
Mohan

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Gregg
Wonderly
Sent: Wednesday, June 15, 2011 2:02 AM
To: Joe Bowbeer
Cc: concurrency-interest
Subject: Re: [concurrency-interest] Economist article

On 6/14/2011 1:48 PM, Joe Bowbeer wrote:
> The problem is always stated as "we have these multicores so now we
have to
> figure out how to use them".

This is my view point as well.  Even though Java had locking available
to 
address the issue of multi-threading through multi-processor machines,
the 
average java programmer had no access to such machines except in places
like 
JavaEE environments, where there as limited access to "threading".

When the first multi-core machine experience landed on my desktop, it
was 
amazing how many problems I found in software which had worked
flawlessly 
before, simply because of visiblility, optmization (the rediculous
volatile 
optimization to while(true)) as well as concurrent access on unlocked
structures.

There were not "path" analysis tools (and I still don't see them today)
which 
can exhaustively document the "single threaded" entry points into code
so that 
you can say, hey, that's not used by a single thread, and fix the
problems.

Sure, the chip manufactures think that it is great to add more cores to
make 
"processors" "more performant", but developers can get no benefits from
that 
simple step without a steep learning curve in something that many seemed
to have 
never be trained in.

My view point is that more than 80% of the people that exist today as
"software 
developers" are just "microsoft office plugin developers" or "self
trained" "web 
developers" who have a very small set of skills in advanced computing 
engineering.  The end result, is that you can count on concurrency bugs,

circular wait, and (with Java) visibility bugs in almost every
application in 
the public computing infrastructure.

The other 20% are people working in real-time or classified/high
performance 
projects which only hire people with demonstrated skill sets.

The other 80% just need a piece of paper with a degree name on it
because the 
managers and coworkers don't really know what computer science is
either.

There are little, isolated groups such as those on this list, who do
have 
background schooling/training and knowledge about the issues.  But, it
sure 
seems like there are so many broken software systems on so many consumer
devices 
as well as out on the internet as "business apps", that something is
still not 
right in the tooling and/or the training of software engineers.

This whole multi-core thing is a big problem in my books.  Especially
when the 
developers are doing it themselves in each app they develop, and doubly
so in 
integrations of multiple such applications/libraries.

The development of the Fork/Join stuff raises the bar on level of
programming 
frameworks such that it makes it a little more possible to control
things.  But, 
I still feel like we are creating ants and dropping them in the dirt,
and then 
running around with poison, traps, shovels and the like, trying to keep
them in 
or near the place we put them, and keep them alive, but not allowing
them to 
proliferate too much such that the other ants are overwhelmed.

Something a lot higher level with much more specific patterns seems to
still be 
needed, and as more people adopt the current leading edge tools, I'm
betting 
that even more standardizations of helpful task management and work load
control 
can occur.

Gregg Wonderly

>
> On Tue, Jun 14, 2011 at 11:36 AM, Tim Peierls wrote:
>
>     I didn't pick up the everything-is-a-nail vibe. The article just
points out
>     that languages, programmers, and educators are unexpectedly
playing catch-up
>     because of the proliferation of multicores on the desktop,
something readers
>     of the Economist probably wouldn't know about without being in the
biz.
>
>     --tim
>
>     On Tue, Jun 14, 2011 at 12:53 PM, Joe Bowbeer wrote:
>
>         "Parallel programming, once an obscure niche, is the focus of
increasing
>         interest as multicore chips proliferate in ordinary PCs."
>
>
<http://www.economist.com/node/18750706?frsc=dg%7Ca><http://www.economis
t.com/node/18750706?frsc=dg%7Ca>
>         http://www.economist.com/node/18750706?frsc=dg%7Ca
>
>         The article mentions Scala but not java.util.concurrent.
>
>         To me, this problem still seems more "derivative" of the
technology and
>         less driven by consumer demand, and I'm disappointed that The
Economist
>         could not find a more compelling statement.
>
>         Is this really a case of: To the man with a multi-headed
hammer, every
>         problem looks like a multi-headed nail?
>
>         Maybe my mobile-shaded perspective will change now that
multicores are
>         shipping on handsets...
>
>         Joe
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest


From chris.hegarty at oracle.com  Thu Jun 16 12:37:13 2011
From: chris.hegarty at oracle.com (Chris Hegarty)
Date: Thu, 16 Jun 2011 17:37:13 +0100
Subject: [concurrency-interest] Code Review 7051516: ThreadLocalRandom
 seed is never initialized so all instances generate the same sequence
In-Reply-To: <27D69877-8389-4936-8EDA-9EA6FBDCB983@oracle.com>
References: <4DF9D87D.1090104@oracle.com>
	<27D69877-8389-4936-8EDA-9EA6FBDCB983@oracle.com>
Message-ID: <4DFA3139.6080206@oracle.com>

On 06/16/11 05:32 PM, Mike Duigou wrote:
> Hi Chris;
>
> The getClass() seems unnecessary. Why not :
>
>      public Random(long seed) {
>              this.seed = new AtomicLong();
>              setSeed(seed);
>      }
>
> or
>
> private final AtomicLong seed = new AtomicLong();
>
> public Random(long seed) {
>      setSeed(seed);
>      }
>
> Both of these would seem to have the same effect without needing to do the explicit class check.

The change ( originally from Martin ) tries to save a couple of volatile 
writes in the common case. Yes, it's not a pretty as it could be.

-Chris.

>
> Mike
>
> On Jun 16 2011, at 03:18 , Chris Hegarty wrote:
>
>> Hi,
>>
>> ThreadLocalRandom uses its own seed, not the seed of the super class.
>>
>>     ThreadLocalRandom() {
>>         super();
>>         initialized = true;
>>     }
>>
>> This uselessly initializes the parent seed via the default constructor but leaves the real seed at zero.
>>
>> Webrev:
>>   http://cr.openjdk.java.net/~chegar/7051516/jdk8_webrev.00/webrev/
>>
>> Note:
>>   This is a port of the fix from Doug's CVS to OpenJDK. A test has been added to Doug's CVS tck tests for ThreadLocalRandom, and I will file a CR against the JCK to have it pulled in to JCK8.
>>
>> -Chris.
>

From scolebourne at joda.org  Mon Jun 20 06:33:52 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 11:33:52 +0100
Subject: [concurrency-interest] Joda-Time immutability
Message-ID: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>

In Joda-Time way back when we structured the code in a complex manner
and then claimed immutability. This is causing difficulty to try and
obey proper immutability standards, and I'd like any ideas on fixes.

Consider the "immutable" class DateTime. The hierarchy is as follows:

AbstractInstant
AbstractDateTime
BaseDateTime
DateTime / MutableDateTime

https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base

The two Abstract prefixed classes are not an issue, as they just share
code and contain no state. However the BaseDateTime contains all the
state (and DateTime/MutableDateTime contain no state).

As a result of this (bad) design, the instance variables in
BaseDateTime are not final (as they need to be mutated by the
MutableDateTime subclass). The DateTime ("immutable") subclass is thus
storing its state in regular mutable variables in BaseDateTime. Under
the memory model, claiming DateTime as immutable is wrong.

Making changes to fix this is easy, however making changes and
preserving backwards compatibility (which is very important here) and
performance (also important) appears to be very tricky at the moment,
and thats what I'd like thoughts on.

Options considered:
a) Change BaseDateTime instance variables to final. No - it breaks the
mutable subclass

b) Move instance variables down from BaseDateTime to DateTime and
MutableDateTime. No - Serialization broken (deserialization contains
the data, but it tries to populate BaseDateTime, not DateTime).

c) Try to do something clever with serialization to read the fields in
manually. No - can't then store the read data as the instance variable
has to be final...

d) Change the instance variables to be volatile. Seems like an
overhead (especially for a performance sensitive class like this).
Doesn't seem ideal when 99% of the uses will use the "immuable" class
where its effectively final in nature.

Have I missed an idea? Is there any way to say at the end of a
constructor "please publish this state as I promise it won't change
later"?!

Stephen

From karmazilla at gmail.com  Mon Jun 20 07:00:54 2011
From: karmazilla at gmail.com (Christian Vest Hansen)
Date: Mon, 20 Jun 2011 13:00:54 +0200
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <BANLkTima77qWnfwWsMj4-gsECDUuAXwyUg@mail.gmail.com>

Any volatile write at the end of the DateTime constructors would order all
of the writes by the BaseDateTime constructors to happen-before a reference
to the constructed DateTime object is returned to the instantiator (if that
is a word).
You would thus end up with a safely published, effectively immutable object
*assuming* the `this` reference does not escape from the constructors.

On Mon, Jun 20, 2011 at 12:33, Stephen Colebourne <scolebourne at joda.org>wrote:

> In Joda-Time way back when we structured the code in a complex manner
> and then claimed immutability. This is causing difficulty to try and
> obey proper immutability standards, and I'd like any ideas on fixes.
>
> Consider the "immutable" class DateTime. The hierarchy is as follows:
>
> AbstractInstant
> AbstractDateTime
> BaseDateTime
> DateTime / MutableDateTime
>
>
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
>
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>
> The two Abstract prefixed classes are not an issue, as they just share
> code and contain no state. However the BaseDateTime contains all the
> state (and DateTime/MutableDateTime contain no state).
>
> As a result of this (bad) design, the instance variables in
> BaseDateTime are not final (as they need to be mutated by the
> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
> storing its state in regular mutable variables in BaseDateTime. Under
> the memory model, claiming DateTime as immutable is wrong.
>
> Making changes to fix this is easy, however making changes and
> preserving backwards compatibility (which is very important here) and
> performance (also important) appears to be very tricky at the moment,
> and thats what I'd like thoughts on.
>
> Options considered:
> a) Change BaseDateTime instance variables to final. No - it breaks the
> mutable subclass
>
> b) Move instance variables down from BaseDateTime to DateTime and
> MutableDateTime. No - Serialization broken (deserialization contains
> the data, but it tries to populate BaseDateTime, not DateTime).
>
> c) Try to do something clever with serialization to read the fields in
> manually. No - can't then store the read data as the instance variable
> has to be final...
>
> d) Change the instance variables to be volatile. Seems like an
> overhead (especially for a performance sensitive class like this).
> Doesn't seem ideal when 99% of the uses will use the "immuable" class
> where its effectively final in nature.
>
> Have I missed an idea? Is there any way to say at the end of a
> constructor "please publish this state as I promise it won't change
> later"?!
>
> Stephen
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
Venlig hilsen / Kind regards,
Christian Vest Hansen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/8f8b7807/attachment.html>

From dawid.weiss at gmail.com  Mon Jun 20 07:02:42 2011
From: dawid.weiss at gmail.com (Dawid Weiss)
Date: Mon, 20 Jun 2011 13:02:42 +0200
Subject: [concurrency-interest] ConcurrentHashMap: HashEntry.value
	potentially null to readers comment
Message-ID: <BANLkTime=3PQ14KoC39nRDmL6cdQCwjCxA@mail.gmail.com>

Hello everyone,

The questions concerning safe publication, final fields and visibility
pop up from time to time and I have tracked the list's archives, but
couldn't find an appropriate answer. So here is the question we have
been discussing with a friend of mine:

ConcurrentHashMap.HashEntry has the following fields:

        final K key;
        final int hash;
        volatile V value;
        final HashEntry<K,V> next;

the only constructor assigns them in this order:

            this.key = key;
            this.hash = hash;
            this.next = next;
            this.value = value;

it is clear to us that all final fields will be published safely; the
comment in that class states that:

     * Because the value field is volatile, not final, it is legal wrt
     * the Java Memory Model for an unsynchronized reader to see null

QUESTION 1. The first question is for the possible rationale of
publishing a reference to a partially constructed object to memory. As
compiler writers does anybody know when would such an optimization be
speeding up things or be at all advisable? Or is it just protecting
oneself against JMM memory model scenario that hardly ever takes place
in the real generated code (as actually stated in the comment to
readValueUnderLock)?

QUESTION 2. Would the above scenario change if we reordered
assignments so that volatile variable is assigned first (before final
fields)? As in here:

            this.value = value;
            this.key = key;
            this.hash = hash;
            this.next = next;

It is my understanding that final field assignments must precede the
publication of the object's reference; is this freely reorderable with
respect to volatile writes?

QUESTION 3. This one is about assignment piggybacking using volatiles.
If we had a hardware architecture that would allow selective cache
flushes (to single-cell memory addresses, for example), must writing
to a volatile enforce a flush of all of the thread's caches? Really?
If so the only "gain" over full monitors is no need for thread locking
(only a cache flush), right? I don't see the JLS stating such a thing,
but I admit the section about happens-before algebra is pretty dense
to me.

Thanks in advance for all the help or pointers to relevant discussion elsewhere.
Dawid


Dawid

From mthornton at optrak.com  Mon Jun 20 07:09:34 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Mon, 20 Jun 2011 12:09:34 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <4DFF2A6E.6070701@optrak.com>

On 20/06/11 11:33, Stephen Colebourne wrote:
> c) Try to do something clever with serialization to read the fields in
> manually. No - can't then store the read data as the instance variable
> has to be final...
You can use reflection to write to final fields. This permitted under 
the memory model subject to certain restrictions.

Mark Thornton


From daniel.yokomizo at gmail.com  Mon Jun 20 07:13:26 2011
From: daniel.yokomizo at gmail.com (Daniel Yokomizo)
Date: Mon, 20 Jun 2011 08:13:26 -0300
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <BANLkTi=vidCyj132htnk0tV8aRvMcB8aPg@mail.gmail.com>

On Jun 20, 2011 7:40 AM, "Stephen Colebourne" <scolebourne at joda.org> wrote:
>
> In Joda-Time way back when we structured the code in a complex manner
> and then claimed immutability. This is causing difficulty to try and
> obey proper immutability standards, and I'd like any ideas on fixes.
>
> Consider the "immutable" class DateTime. The hierarchy is as follows:
>
> AbstractInstant
> AbstractDateTime
> BaseDateTime
> DateTime / MutableDateTime
>
>
https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
>
https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>
> The two Abstract prefixed classes are not an issue, as they just share
> code and contain no state. However the BaseDateTime contains all the
> state (and DateTime/MutableDateTime contain no state).
>
> As a result of this (bad) design, the instance variables in
> BaseDateTime are not final (as they need to be mutated by the
> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
> storing its state in regular mutable variables in BaseDateTime. Under
> the memory model, claiming DateTime as immutable is wrong.
>
> Making changes to fix this is easy, however making changes and
> preserving backwards compatibility (which is very important here) and
> performance (also important) appears to be very tricky at the moment,
> and thats what I'd like thoughts on.
>
> Options considered:
> a) Change BaseDateTime instance variables to final. No - it breaks the
> mutable subclass
>
> b) Move instance variables down from BaseDateTime to DateTime and
> MutableDateTime. No - Serialization broken (deserialization contains
> the data, but it tries to populate BaseDateTime, not DateTime).
>
> c) Try to do something clever with serialization to read the fields in
> manually. No - can't then store the read data as the instance variable
> has to be final...

Wouldn't a serialization proxy (i.e. readResolve/writeReplace) solve this?

> d) Change the instance variables to be volatile. Seems like an
> overhead (especially for a performance sensitive class like this).
> Doesn't seem ideal when 99% of the uses will use the "immuable" class
> where its effectively final in nature.
>
> Have I missed an idea? Is there any way to say at the end of a
> constructor "please publish this state as I promise it won't change
> later"?!
>
> Stephen

Best regards,
Daniel Yokomizo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/ea09cb17/attachment.html>

From davidcholmes at aapt.net.au  Mon Jun 20 07:15:48 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Mon, 20 Jun 2011 21:15:48 +1000
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTima77qWnfwWsMj4-gsECDUuAXwyUg@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEAEIOAA.davidcholmes@aapt.net.au>

A volatile write would only work if there were a corresponding volatile read.

Final field semantics might give the necessary guarantee.

David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Christian Vest Hansen
  Sent: Monday, 20 June 2011 9:01 PM
  To: Stephen Colebourne
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] Joda-Time immutability


  Any volatile write at the end of the DateTime constructors would order all of the writes by the BaseDateTime constructors to happen-before a reference to the constructed DateTime object is returned to the instantiator (if that is a word).
  You would thus end up with a safely published, effectively immutable object *assuming* the `this` reference does not escape from the constructors.


  On Mon, Jun 20, 2011 at 12:33, Stephen Colebourne <scolebourne at joda.org> wrote:

    In Joda-Time way back when we structured the code in a complex manner
    and then claimed immutability. This is causing difficulty to try and
    obey proper immutability standards, and I'd like any ideas on fixes.

    Consider the "immutable" class DateTime. The hierarchy is as follows:

    AbstractInstant
    AbstractDateTime
    BaseDateTime
    DateTime / MutableDateTime

    https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
    https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base

    The two Abstract prefixed classes are not an issue, as they just share
    code and contain no state. However the BaseDateTime contains all the
    state (and DateTime/MutableDateTime contain no state).

    As a result of this (bad) design, the instance variables in
    BaseDateTime are not final (as they need to be mutated by the
    MutableDateTime subclass). The DateTime ("immutable") subclass is thus
    storing its state in regular mutable variables in BaseDateTime. Under
    the memory model, claiming DateTime as immutable is wrong.

    Making changes to fix this is easy, however making changes and
    preserving backwards compatibility (which is very important here) and
    performance (also important) appears to be very tricky at the moment,
    and thats what I'd like thoughts on.

    Options considered:
    a) Change BaseDateTime instance variables to final. No - it breaks the
    mutable subclass

    b) Move instance variables down from BaseDateTime to DateTime and
    MutableDateTime. No - Serialization broken (deserialization contains
    the data, but it tries to populate BaseDateTime, not DateTime).

    c) Try to do something clever with serialization to read the fields in
    manually. No - can't then store the read data as the instance variable
    has to be final...

    d) Change the instance variables to be volatile. Seems like an
    overhead (especially for a performance sensitive class like this).
    Doesn't seem ideal when 99% of the uses will use the "immuable" class
    where its effectively final in nature.

    Have I missed an idea? Is there any way to say at the end of a
    constructor "please publish this state as I promise it won't change
    later"?!

    Stephen
    _______________________________________________
    Concurrency-interest mailing list
    Concurrency-interest at cs.oswego.edu
    http://cs.oswego.edu/mailman/listinfo/concurrency-interest




  -- 
  Venlig hilsen / Kind regards,
  Christian Vest Hansen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/2da02c9a/attachment-0001.html>

From scolebourne at joda.org  Mon Jun 20 07:24:22 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 12:24:22 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEAEIOAA.davidcholmes@aapt.net.au>
References: <BANLkTima77qWnfwWsMj4-gsECDUuAXwyUg@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCAEAEIOAA.davidcholmes@aapt.net.au>
Message-ID: <BANLkTi=RTm5H0RHa1qAiVwjauNMgGxx2xw@mail.gmail.com>

So would this work at the end of the constructor?

class DateTime extends BaseDateTime {
  private transient volatile fixBadDesign;

  publc DateTime(long millis) {
    super(millis);
    fixbadDesign = this;
    DateTime fixed = fixbadDesign;
  }

}

I can't make the field final without breaking backwards compatibility
somewhere (its version 2.0, so I have some small ability to break 1%
of users, but I won't break the 99%, break serialization, or
compromise performance)

Stephen


On 20 June 2011 12:15, David Holmes <davidcholmes at aapt.net.au> wrote:
> A volatile write would only work if there were a corresponding volatile
> read.
>
> Final field semantics might give the necessary guarantee.
>
> David Holmes
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Christian
> Vest Hansen
> Sent: Monday, 20 June 2011 9:01 PM
> To: Stephen Colebourne
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Joda-Time immutability
>
> Any volatile write at the end of the DateTime constructors would order all
> of the writes by the BaseDateTime constructors to happen-before a reference
> to the constructed DateTime object is returned to the instantiator (if that
> is a word).
> You would thus end up with a safely published, effectively immutable object
> *assuming* the `this` reference does not escape from the constructors.
>
> On Mon, Jun 20, 2011 at 12:33, Stephen Colebourne <scolebourne at joda.org>
> wrote:
>>
>> In Joda-Time way back when we structured the code in a complex manner
>> and then claimed immutability. This is causing difficulty to try and
>> obey proper immutability standards, and I'd like any ideas on fixes.
>>
>> Consider the "immutable" class DateTime. The hierarchy is as follows:
>>
>> AbstractInstant
>> AbstractDateTime
>> BaseDateTime
>> DateTime / MutableDateTime
>>
>>
>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
>>
>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>>
>> The two Abstract prefixed classes are not an issue, as they just share
>> code and contain no state. However the BaseDateTime contains all the
>> state (and DateTime/MutableDateTime contain no state).
>>
>> As a result of this (bad) design, the instance variables in
>> BaseDateTime are not final (as they need to be mutated by the
>> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
>> storing its state in regular mutable variables in BaseDateTime. Under
>> the memory model, claiming DateTime as immutable is wrong.
>>
>> Making changes to fix this is easy, however making changes and
>> preserving backwards compatibility (which is very important here) and
>> performance (also important) appears to be very tricky at the moment,
>> and thats what I'd like thoughts on.
>>
>> Options considered:
>> a) Change BaseDateTime instance variables to final. No - it breaks the
>> mutable subclass
>>
>> b) Move instance variables down from BaseDateTime to DateTime and
>> MutableDateTime. No - Serialization broken (deserialization contains
>> the data, but it tries to populate BaseDateTime, not DateTime).
>>
>> c) Try to do something clever with serialization to read the fields in
>> manually. No - can't then store the read data as the instance variable
>> has to be final...
>>
>> d) Change the instance variables to be volatile. Seems like an
>> overhead (especially for a performance sensitive class like this).
>> Doesn't seem ideal when 99% of the uses will use the "immuable" class
>> where its effectively final in nature.
>>
>> Have I missed an idea? Is there any way to say at the end of a
>> constructor "please publish this state as I promise it won't change
>> later"?!
>>
>> Stephen
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> --
> Venlig hilsen / Kind regards,
> Christian Vest Hansen.
>

From r.spilker at topdesk.com  Mon Jun 20 07:45:02 2011
From: r.spilker at topdesk.com (Roel Spilker)
Date: Mon, 20 Jun 2011 13:45:02 +0200
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF2A6E.6070701@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com>
Message-ID: <4DFF32BE.6010405@topdesk.com>

IIRC, disallowing the setting of final fields by reflection was never  implemented, despite several bug reports, BECAUSE it is used indeserialization.


On 20-6-2011 13:09, Mark Thornton wrote:
> On 20/06/11 11:33, Stephen Colebourne wrote:
>> c) Try to do something clever with serialization to read the fields in
>> manually. No - can't then store the read data as the instance variable
>> has to be final...
> You can use reflection to write to final fields. This permitted under
> the memory model subject to certain restrictions.
>
> Mark Thornton
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From opinali at gmail.com  Mon Jun 20 09:03:43 2011
From: opinali at gmail.com (Osvaldo Doederlein)
Date: Mon, 20 Jun 2011 09:03:43 -0400
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF32BE.6010405@topdesk.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
Message-ID: <BANLkTi=11+A4f3MDTEdxKxGj_njDMiHSAw@mail.gmail.com>

IIRC serialization relies on Unsafe magic directly so it doesn't depend on
the public reflection APIs
 On Jun 20, 2011 7:49 AM, "Roel Spilker" <r.spilker at topdesk.com> wrote:
> IIRC, disallowing the setting of final fields by reflection was never
implemented, despite several bug reports, BECAUSE it is used
indeserialization.
>
>
> On 20-6-2011 13:09, Mark Thornton wrote:
>> On 20/06/11 11:33, Stephen Colebourne wrote:
>>> c) Try to do something clever with serialization to read the fields in
>>> manually. No - can't then store the read data as the instance variable
>>> has to be final...
>> You can use reflection to write to final fields. This permitted under
>> the memory model subject to certain restrictions.
>>
>> Mark Thornton
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/cd353661/attachment.html>

From linzuxiong1988 at gmail.com  Mon Jun 20 09:09:16 2011
From: linzuxiong1988 at gmail.com (zuxiong lin)
Date: Mon, 20 Jun 2011 21:09:16 +0800
Subject: [concurrency-interest] Please,
	help me about Servlet Concurrent Problem.
Message-ID: <BANLkTimJBVFBCt9z2wOjWPm-2EQNvBrSEQ@mail.gmail.com>

One thread use the new HashMap , no others , so each thread access one map
in the memory.
I actually want to ask like the servlet ,because the httpServlet  use
threads  in WebContainer  , such as tomcat , jboss .
Client A (Computer A) : http://8.8.8.8:8080/ListServelt?userId=001
Client B (Computer B) : http://8.8.8.8:8080/ListServelt?userId=009
So the thread A for Client A and the thread B for Client B access  the two
different map of the memory instance .
No concurrent enviroment because the two threads access their own map.
Right?Right?Right?

Codes :
public class ListServlet extends HttpServlet {
    private static final long serialVersionUID = 9035149672042103851L;
    protected void *service*(HttpServletRequest request,
            HttpServletResponse response) throws ServletException,
IOException {
        String userId = request.getParameter("userId");
        *Map files = GlobalContext.getServiceImpl().getFiles(userId);*
*        response.getWriter().print(files.toString());*
    }
}
public class ServiceImpl {
    public Map getFiles(String userId) {
       * Map m = new HashMap();*
*        m.put(userId, userId);*
*        return m;*
    }
}
public class GlobalContext {
    static ServiceImpl serviceImpl;
    static {
        serviceImpl = new ServiceImpl();
    }
    public static ServiceImpl getServiceImpl() {
        return serviceImpl;
    }
}

Have a good day.
Look forward your reply.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/924bb018/attachment.html>

From scolebourne at joda.org  Mon Jun 20 10:03:09 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 15:03:09 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF2A6E.6070701@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com>
Message-ID: <BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>

The "reflection can set final fields" comment was directed at
serialization, but has actually provided a reasonably acceptable
solution (thanks Mark).

Basically, I've made the fields final, and changed the setters to use
reflection (breaking the final restriction). Since 99% of use cases
are immutable, this will only impact the mutable users (a little bit
slower), and they should really move to the immutable classes
anyway...

I'd still like to know if my volatile write/read code posted earlier
would have been valid.

Stephen


On 20 June 2011 12:09, Mark Thornton <mthornton at optrak.com> wrote:
> On 20/06/11 11:33, Stephen Colebourne wrote:
>>
>> c) Try to do something clever with serialization to read the fields in
>> manually. No - can't then store the read data as the instance variable
>> has to be final...
>
> You can use reflection to write to final fields. This permitted under the
> memory model subject to certain restrictions.
>
> Mark Thornton
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From mthornton at optrak.com  Mon Jun 20 10:23:11 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Mon, 20 Jun 2011 15:23:11 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>
Message-ID: <4DFF57CF.2090903@optrak.com>

On 20/06/11 15:03, Stephen Colebourne wrote:
> The "reflection can set final fields" comment was directed at
> serialization, but has actually provided a reasonably acceptable
> solution (thanks Mark).
>
> Basically, I've made the fields final, and changed the setters to use
> reflection (breaking the final restriction). Since 99% of use cases
> are immutable, this will only impact the mutable users (a little bit
> slower), and they should really move to the immutable classes
> anyway...
>
> I'd still like to know if my volatile write/read code posted earlier
> would have been valid.
>
> Stephen
A potential catch with using reflection is when a SecurityManager is in use.

Mark


From scolebourne at joda.org  Mon Jun 20 10:33:17 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 15:33:17 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF57CF.2090903@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com>
	<BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>
	<4DFF57CF.2090903@optrak.com>
Message-ID: <BANLkTinau9Gk6OxLWF5GkfBFTZ4Qty1K5Q@mail.gmail.com>

On 20 June 2011 15:23, Mark Thornton <mthornton at optrak.com> wrote:
> On 20/06/11 15:03, Stephen Colebourne wrote:
>>
>> The "reflection can set final fields" comment was directed at
>> serialization, but has actually provided a reasonably acceptable
>> solution (thanks Mark).
>>
>> Basically, I've made the fields final, and changed the setters to use
>> reflection (breaking the final restriction). Since 99% of use cases
>> are immutable, this will only impact the mutable users (a little bit
>> slower), and they should really move to the immutable classes
>> anyway...
>>
> A potential catch with using reflection is when a SecurityManager is in use.

Agreed, but users can move to the immutable classes to avoid reflection.

Its a least worst option choice for a version 2.0.

Stephen

From mthornton at optrak.com  Mon Jun 20 11:06:13 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Mon, 20 Jun 2011 16:06:13 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<BANLkTikp-VvhKOtS1LWgivB92q1BQGreHQ@mail.gmail.com>
Message-ID: <4DFF61E5.2020406@optrak.com>

On 20/06/11 15:03, Stephen Colebourne wrote:
> The "reflection can set final fields" comment was directed at
> serialization, but has actually provided a reasonably acceptable
> solution (thanks Mark).
>
> Basically, I've made the fields final, and changed the setters to use
> reflection (breaking the final restriction). Since 99% of use cases
> are immutable, this will only impact the mutable users (a little bit
> slower), and they should really move to the immutable classes
> anyway...
Unfortunately I suspect that this approach doesn't meet the rules 
associated with using reflection to modify final fields. It is 
conceivable that a too clever JIT might inline a 'final' value and thus 
code might not see a change in a mutable date. However, you might get 
away with it as a transitional mechanism.

Mark


From szegedia at gmail.com  Mon Jun 20 12:52:19 2011
From: szegedia at gmail.com (Attila Szegedi)
Date: Mon, 20 Jun 2011 09:52:19 -0700
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF32BE.6010405@topdesk.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
Message-ID: <77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>

Well, to me it looks like it's implemented:

import java.lang.reflect.Field;

public class TestFinalField {
  public final int x = 1;

  public static void main(String[] args) throws Exception {
    TestFinalField tff = new TestFinalField();
    Field f = tff.getClass().getField("x");
    f.setAccessible(true);
    f.set(tff, 2);
    System.out.println(tff.x);
  }
}

This prints "1", and not "2". So, setting of a final field is actually silently ignored with setAccessible(true), for better or worse. Without setAccessible(), it will actually throw an exception. With the "final" qualifier removed from the field, it prints "2", as expected. I tested it with both latest Java 6 and on the b145 build of OpenJDK 7, and both behaves as described.

Attila.

On Jun 20, 2011, at 4:45 AM, Roel Spilker wrote:

> IIRC, disallowing the setting of final fields by reflection was never  implemented, despite several bug reports, BECAUSE it is used indeserialization.
> 
> 
> On 20-6-2011 13:09, Mark Thornton wrote:
>> On 20/06/11 11:33, Stephen Colebourne wrote:
>>> c) Try to do something clever with serialization to read the fields in
>>> manually. No - can't then store the read data as the instance variable
>>> has to be final...
>> You can use reflection to write to final fields. This permitted under
>> the memory model subject to certain restrictions.
>> 
>> Mark Thornton
>> 
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/2696325c/attachment.html>

From mthornton at optrak.com  Mon Jun 20 13:23:33 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Mon, 20 Jun 2011 18:23:33 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
Message-ID: <4DFF8215.7060609@optrak.com>

On 20/06/11 17:52, Attila Szegedi wrote:
> Well, to me it looks like it's implemented:
>
> import java.lang.reflect.Field;
>
> public class TestFinalField {
> publicfinalintx= 1;
>
> public static void main(String[] args) throws Exception {
>     TestFinalField tff = new TestFinalField();
>     Field f = tff.getClass().getField("x");
>     f.setAccessible(true);
>     f.set(tff, 2);
>     System.out.println(tff.x);
>   }
> }
>
> This prints "1", and not "2". So, setting of a final field is actually 
> *silently ignored* with setAccessible(true), for better or worse. 
> Without setAccessible(), it will actually throw an exception. With the 
> "final" qualifier removed from the field, it prints "2", as expected. 
> I tested it with both latest Java 6 and on the b145 build of OpenJDK 
> 7, and both behaves as described.
>
> Attila.
>
I think what is happening here is that the object is being updated, but 
the print statement is being 'optimised'.

Mark

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/f11ba984/attachment.html>

From scolebourne at joda.org  Mon Jun 20 13:32:38 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 18:32:38 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
Message-ID: <BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>

On 20 June 2011 17:52, Attila Szegedi <szegedia at gmail.com> wrote:
> Well, to me it looks like it's implemented:
> import java.lang.reflect.Field;
> public class TestFinalField {
> ? public final int x = 1;
> ? public static void main(String[] args) throws Exception {
> ? ? TestFinalField tff = new TestFinalField();
> ? ? Field f = tff.getClass().getField("x");
> ? ? f.setAccessible(true);
> ? ? f.set(tff, 2);
> ? ? System.out.println(tff.x);
> ? }
> }
> This prints "1", and not "2". So, setting of a final field is actually
> silently ignored with setAccessible(true), for better or worse. Without
> setAccessible(), it will actually throw an exception. With the "final"
> qualifier removed from the field, it prints "2", as expected. I tested it
> with both latest Java 6 and on the b145 build of OpenJDK 7, and both behaves
> as described.

Well thats weird, because my change works and passes the tests in Joda-Time.
https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4ef73b09e2be2f70001#diff-8

Anyone know what is going on? Can this be sufficiently relied on? I
haven't really got a workable alternative.

Stephen


From szegedia at gmail.com  Mon Jun 20 13:44:20 2011
From: szegedia at gmail.com (Attila Szegedi)
Date: Mon, 20 Jun 2011 10:44:20 -0700
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF8215.7060609@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
	<4DFF8215.7060609@optrak.com>
Message-ID: <2DD56E30-5419-403E-8B9F-C32CA3D27215@gmail.com>

You are right, Mark. If the field is read reflectively - replacing "tff.x" with "f.get(tff)" in the println invocation - to avoid any compile-time optimizations, it will actually print 2. 

Attila.

On Jun 20, 2011, at 10:23 AM, Mark Thornton wrote:

> On 20/06/11 17:52, Attila Szegedi wrote:
>> 
>> Well, to me it looks like it's implemented:
>> 
>> import java.lang.reflect.Field;
>> 
>> public class TestFinalField {
>>   public final int x = 1;
>> 
>>   public static void main(String[] args) throws Exception {
>>     TestFinalField tff = new TestFinalField();
>>     Field f = tff.getClass().getField("x");
>>     f.setAccessible(true);
>>     f.set(tff, 2);
>>     System.out.println(tff.x);
>>   }
>> }
>> 
>> This prints "1", and not "2". So, setting of a final field is actually silently ignored with setAccessible(true), for better or worse. Without setAccessible(), it will actually throw an exception. With the "final" qualifier removed from the field, it prints "2", as expected. I tested it with both latest Java 6 and on the b145 build of OpenJDK 7, and both behaves as described.
>> 
>> Attila.
>> 
> I think what is happening here is that the object is being updated, but the print statement is being 'optimised'.
> 
> Mark
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110620/24911f32/attachment.html>

From david.lloyd at redhat.com  Mon Jun 20 13:45:45 2011
From: david.lloyd at redhat.com (David M. Lloyd)
Date: Mon, 20 Jun 2011 12:45:45 -0500
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<4DFF32BE.6010405@topdesk.com>	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
	<BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
Message-ID: <4DFF8749.4000406@redhat.com>

On 06/20/2011 12:32 PM, Stephen Colebourne wrote:
> On 20 June 2011 17:52, Attila Szegedi<szegedia at gmail.com>  wrote:
>> Well, to me it looks like it's implemented:
>> import java.lang.reflect.Field;
>> public class TestFinalField {
>>    public final int x = 1;
>>    public static void main(String[] args) throws Exception {
>>      TestFinalField tff = new TestFinalField();
>>      Field f = tff.getClass().getField("x");
>>      f.setAccessible(true);
>>      f.set(tff, 2);
>>      System.out.println(tff.x);
>>    }
>> }
>> This prints "1", and not "2". So, setting of a final field is actually
>> silently ignored with setAccessible(true), for better or worse. Without
>> setAccessible(), it will actually throw an exception. With the "final"
>> qualifier removed from the field, it prints "2", as expected. I tested it
>> with both latest Java 6 and on the b145 build of OpenJDK 7, and both behaves
>> as described.
>
> Well thats weird, because my change works and passes the tests in Joda-Time.
> https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4ef73b09e2be2f70001#diff-8
>
> Anyone know what is going on? Can this be sufficiently relied on? I
> haven't really got a workable alternative.

AFAIK the only time you can count on this working is if you've 
constructed an object instance without calling its constructor (a la 
serialization).  In other words the JVM is allowed to assume that the 
final field won't change and optimize accordingly.

I wouldn't rely on this trick for updating a field outside of a 
readObject() method.

-- 
- DML

From pcj at roundroom.net  Mon Jun 20 14:02:53 2011
From: pcj at roundroom.net (Peter Jones)
Date: Mon, 20 Jun 2011 14:02:53 -0400
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
	<BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
Message-ID: <38C24AC3-C559-4104-825D-BEA425B858EE@roundroom.net>


On Jun 20, 2011, at 1:32 PM, Stephen Colebourne wrote:

> On 20 June 2011 17:52, Attila Szegedi <szegedia at gmail.com> wrote:
>> Well, to me it looks like it's implemented:
>> import java.lang.reflect.Field;
>> public class TestFinalField {
>>   public final int x = 1;
>>   public static void main(String[] args) throws Exception {
>>     TestFinalField tff = new TestFinalField();
>>     Field f = tff.getClass().getField("x");
>>     f.setAccessible(true);
>>     f.set(tff, 2);
>>     System.out.println(tff.x);
>>   }
>> }
>> This prints "1", and not "2". So, setting of a final field is actually
>> silently ignored with setAccessible(true), for better or worse. Without
>> setAccessible(), it will actually throw an exception. With the "final"
>> qualifier removed from the field, it prints "2", as expected. I tested it
>> with both latest Java 6 and on the b145 build of OpenJDK 7, and both behaves
>> as described.
> 
> Well thats weird, because my change works and passes the tests in Joda-Time.
> https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4ef73b09e2be2f70001#diff-8
> 
> Anyone know what is going on? Can this be sufficiently relied on? I
> haven't really got a workable alternative.

In the above case, because the field is initialized with a compile-time constant, the value must be inlined at regular accesses at compile time-- see JLS chapter 13, look for "constant variables".  Printing "f.get(tff)" should show that the field's value has in fact changed, even though code compiled with "tff.x" won't notice.  But I would guess that the instance fields you care about aren't initialized with constants.

-- Peter



From scolebourne at joda.org  Mon Jun 20 14:10:04 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Mon, 20 Jun 2011 19:10:04 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF8749.4000406@redhat.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
	<BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
	<4DFF8749.4000406@redhat.com>
Message-ID: <BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>

Java 7 Javadoc:
"If the underlying field is final, the method throws an
IllegalAccessException unless setAccessible(true) has succeeded for
this Field object and the field is non-static. Setting a final field
in this way is meaningful only during deserialization or
reconstruction of instances of classes with blank final fields, before
they are made available for access by other parts of a program. Use in
any other context may have unpredictable effects, including cases in
which other parts of a program continue to use the original value of
this field. "

So this approach fails. Back to square one.

Any other suggestions?

Does this work?

class DateTime extends BaseDateTime {
 private transient volatile fixBadDesign;

 publc DateTime(long millis) {
   super(millis);
   fixbadDesign = this;
   DateTime fixed = fixbadDesign;
 }

}

Stephen


On 20 June 2011 18:45, David M. Lloyd <david.lloyd at redhat.com> wrote:
> On 06/20/2011 12:32 PM, Stephen Colebourne wrote:
>>
>> On 20 June 2011 17:52, Attila Szegedi<szegedia at gmail.com> ?wrote:
>>>
>>> Well, to me it looks like it's implemented:
>>> import java.lang.reflect.Field;
>>> public class TestFinalField {
>>> ? public final int x = 1;
>>> ? public static void main(String[] args) throws Exception {
>>> ? ? TestFinalField tff = new TestFinalField();
>>> ? ? Field f = tff.getClass().getField("x");
>>> ? ? f.setAccessible(true);
>>> ? ? f.set(tff, 2);
>>> ? ? System.out.println(tff.x);
>>> ? }
>>> }
>>> This prints "1", and not "2". So, setting of a final field is actually
>>> silently ignored with setAccessible(true), for better or worse. Without
>>> setAccessible(), it will actually throw an exception. With the "final"
>>> qualifier removed from the field, it prints "2", as expected. I tested it
>>> with both latest Java 6 and on the b145 build of OpenJDK 7, and both
>>> behaves
>>> as described.
>>
>> Well thats weird, because my change works and passes the tests in
>> Joda-Time.
>>
>> https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4ef73b09e2be2f70001#diff-8
>>
>> Anyone know what is going on? Can this be sufficiently relied on? I
>> haven't really got a workable alternative.
>
> AFAIK the only time you can count on this working is if you've constructed
> an object instance without calling its constructor (a la serialization). ?In
> other words the JVM is allowed to assume that the final field won't change
> and optimize accordingly.
>
> I wouldn't rely on this trick for updating a field outside of a readObject()
> method.
>
> --
> - DML
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From eamonn.mcmanus at oracle.com  Mon Jun 20 15:26:58 2011
From: eamonn.mcmanus at oracle.com (Eamonn McManus)
Date: Mon, 20 Jun 2011 21:26:58 +0200
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>	<4DFF2A6E.6070701@optrak.com>
	<4DFF32BE.6010405@topdesk.com>	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>	<BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>	<4DFF8749.4000406@redhat.com>
	<BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>
Message-ID: <4DFF9F02.1040002@oracle.com>

I would suggest mirroring the mutable fields in BaseDateTime with final 
fields in DateTime. Since existing serialized instances of DateTime will 
not have these fields, you will need a readResolve method to set them in 
that case. In order for serialized instances of the new DateTime to work 
with older versions, you just need to set the BaseDateTime fields as 
well. Something like this:

public final class DateTime extends BaseDateTime {
     private final long millis;

     public DateTime(long millis) {
         super(millis);  // for serializing to old versions
         this.millis = millis;
     }

     @Override public void getMillis() {
         return this.millis;
     }

     private Object readResolve() {
         if (getMillis() != super.getMillis()) {
             // for deserializing from old versions
             return new DateTime(super.getMillis());
         } else {
             return this;
         }
     }
}

If the fields in question are references rather than primitives, or if 
DateTime is not final, then the considerations mentioned in Effective 
Java 2, item 77, apply.

?amonn

On 20/6/11 8:10 PM, Stephen Colebourne wrote:
> Java 7 Javadoc:
> "If the underlying field is final, the method throws an
> IllegalAccessException unless setAccessible(true) has succeeded for
> this Field object and the field is non-static. Setting a final field
> in this way is meaningful only during deserialization or
> reconstruction of instances of classes with blank final fields, before
> they are made available for access by other parts of a program. Use in
> any other context may have unpredictable effects, including cases in
> which other parts of a program continue to use the original value of
> this field. "
>
> So this approach fails. Back to square one.
>
> Any other suggestions?
>
> Does this work?
>
> class DateTime extends BaseDateTime {
>   private transient volatile fixBadDesign;
>
>   publc DateTime(long millis) {
>     super(millis);
>     fixbadDesign = this;
>     DateTime fixed = fixbadDesign;
>   }
>
> }
>
> Stephen
>
>
> On 20 June 2011 18:45, David M. Lloyd<david.lloyd at redhat.com>  wrote:
>> On 06/20/2011 12:32 PM, Stephen Colebourne wrote:
>>>
>>> On 20 June 2011 17:52, Attila Szegedi<szegedia at gmail.com>    wrote:
>>>>
>>>> Well, to me it looks like it's implemented:
>>>> import java.lang.reflect.Field;
>>>> public class TestFinalField {
>>>>    public final int x = 1;
>>>>    public static void main(String[] args) throws Exception {
>>>>      TestFinalField tff = new TestFinalField();
>>>>      Field f = tff.getClass().getField("x");
>>>>      f.setAccessible(true);
>>>>      f.set(tff, 2);
>>>>      System.out.println(tff.x);
>>>>    }
>>>> }
>>>> This prints "1", and not "2". So, setting of a final field is actually
>>>> silently ignored with setAccessible(true), for better or worse. Without
>>>> setAccessible(), it will actually throw an exception. With the "final"
>>>> qualifier removed from the field, it prints "2", as expected. I tested it
>>>> with both latest Java 6 and on the b145 build of OpenJDK 7, and both
>>>> behaves
>>>> as described.
>>>
>>> Well thats weird, because my change works and passes the tests in
>>> Joda-Time.
>>>
>>> https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4ef73b09e2be2f70001#diff-8
>>>
>>> Anyone know what is going on? Can this be sufficiently relied on? I
>>> haven't really got a workable alternative.
>>
>> AFAIK the only time you can count on this working is if you've constructed
>> an object instance without calling its constructor (a la serialization).  In
>> other words the JVM is allowed to assume that the final field won't change
>> and optimize accordingly.
>>
>> I wouldn't rely on this trick for updating a field outside of a readObject()
>> method.
>>
>> --
>> - DML
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From davidcholmes at aapt.net.au  Mon Jun 20 19:41:49 2011
From: davidcholmes at aapt.net.au (David Holmes)
Date: Tue, 21 Jun 2011 09:41:49 +1000
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEAHIOAA.davidcholmes@aapt.net.au>

Stephen Colebourne writes:
> Does this work?
>
> class DateTime extends BaseDateTime {
>  private transient volatile fixBadDesign;
>
>  publc DateTime(long millis) {
>    super(millis);
>    fixbadDesign = this;
>    DateTime fixed = fixbadDesign;
>  }
>
> }

No, writing to a volatile is not sufficient. As I said previously writing a
final field might suffice.

David

> Stephen
>
>
> On 20 June 2011 18:45, David M. Lloyd <david.lloyd at redhat.com> wrote:
> > On 06/20/2011 12:32 PM, Stephen Colebourne wrote:
> >>
> >> On 20 June 2011 17:52, Attila Szegedi<szegedia at gmail.com> ?wrote:
> >>>
> >>> Well, to me it looks like it's implemented:
> >>> import java.lang.reflect.Field;
> >>> public class TestFinalField {
> >>> ? public final int x = 1;
> >>> ? public static void main(String[] args) throws Exception {
> >>> ? ? TestFinalField tff = new TestFinalField();
> >>> ? ? Field f = tff.getClass().getField("x");
> >>> ? ? f.setAccessible(true);
> >>> ? ? f.set(tff, 2);
> >>> ? ? System.out.println(tff.x);
> >>> ? }
> >>> }
> >>> This prints "1", and not "2". So, setting of a final field is actually
> >>> silently ignored with setAccessible(true), for better or
> worse. Without
> >>> setAccessible(), it will actually throw an exception. With the "final"
> >>> qualifier removed from the field, it prints "2", as expected.
> I tested it
> >>> with both latest Java 6 and on the b145 build of OpenJDK 7, and both
> >>> behaves
> >>> as described.
> >>
> >> Well thats weird, because my change works and passes the tests in
> >> Joda-Time.
> >>
> >>
> https://github.com/JodaOrg/joda-time/commit/067983f2684fa9e9ca4af4
ef73b09e2be2f70001#diff-8
>>
>> Anyone know what is going on? Can this be sufficiently relied on? I
>> haven't really got a workable alternative.
>
> AFAIK the only time you can count on this working is if you've constructed
> an object instance without calling its constructor (a la serialization).
?In
> other words the JVM is allowed to assume that the final field won't change
> and optimize accordingly.
>
> I wouldn't rely on this trick for updating a field outside of a
readObject()
> method.
>
> --
> - DML
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest



From scolebourne at joda.org  Mon Jun 20 19:43:47 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Tue, 21 Jun 2011 00:43:47 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4DFF9F02.1040002@oracle.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4DFF2A6E.6070701@optrak.com> <4DFF32BE.6010405@topdesk.com>
	<77B9C96E-8888-4B1F-9A01-892C59FC99FC@gmail.com>
	<BANLkTimbqU5PYz5Zz3LOyEQ+0=9xMf43oA@mail.gmail.com>
	<4DFF8749.4000406@redhat.com>
	<BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>
	<4DFF9F02.1040002@oracle.com>
Message-ID: <BANLkTinbROmPfFDWjcb810YUMU6CumoOsw@mail.gmail.com>

On 20 June 2011 20:26, Eamonn McManus <eamonn.mcmanus at oracle.com> wrote:
> I would suggest mirroring the mutable fields in BaseDateTime with final
> fields in DateTime. Since existing serialized instances of DateTime will not
> have these fields, you will need a readResolve method to set them in that
> case. In order for serialized instances of the new DateTime to work with
> older versions, you just need to set the BaseDateTime fields as well.

This approach would probably work, but would double the memory usage
of the common immutable case. I don't mind doubling the memory in the
mutable case, and I may just have to (breaking the mutable
serialization too)

Stephen

From scolebourne at joda.org  Mon Jun 20 19:46:17 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Tue, 21 Jun 2011 00:46:17 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEAHIOAA.davidcholmes@aapt.net.au>
References: <BANLkTi=qTDyN1jYPpWYJXuz8unV1ZiPbVA@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCMEAHIOAA.davidcholmes@aapt.net.au>
Message-ID: <BANLkTi=pRVA-k+TTqTsN2d9Wx7b7dzB9Gw@mail.gmail.com>

On 21 June 2011 00:41, David Holmes <davidcholmes at aapt.net.au> wrote:
> Stephen Colebourne writes:
>> Does this work?
>>
>> class DateTime extends BaseDateTime {
>> ?private transient volatile fixBadDesign;
>>
>> ?publc DateTime(long millis) {
>> ? ?super(millis);
>> ? ?fixbadDesign = this;
>> ? ?DateTime fixed = fixbadDesign;
>> ?}
>>
>> }
>
> No, writing to a volatile is not sufficient. As I said previously writing a
> final field might suffice.

Thanks. Not sure if writing "this" to a "final" field is a useful solution yet.

Stephen


From mthornton at optrak.com  Tue Jun 21 02:27:46 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Tue, 21 Jun 2011 07:27:46 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <4E0039E2.2090102@optrak.com>

On 20/06/11 11:33, Stephen Colebourne wrote:
> In Joda-Time way back when we structured the code in a complex manner
> and then claimed immutability. This is causing difficulty to try and
> obey proper immutability standards, and I'd like any ideas on fixes.
>
> Consider the "immutable" class DateTime. The hierarchy is as follows:
>
> AbstractInstant
> AbstractDateTime
> BaseDateTime
> DateTime / MutableDateTime
>
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>
> The two Abstract prefixed classes are not an issue, as they just share
> code and contain no state. However the BaseDateTime contains all the
> state (and DateTime/MutableDateTime contain no state).
>
> As a result of this (bad) design, the instance variables in
> BaseDateTime are not final (as they need to be mutated by the
> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
> storing its state in regular mutable variables in BaseDateTime. Under
> the memory model, claiming DateTime as immutable is wrong.
A possible solution:

Make the fields in BaseDateTime final.
DateTime is left unchanged.
Duplicate the fields in MutableDateTime with getter/setters referring to 
the new (mutable) fields.

Add a readObject method to MutableDateTime which calls 
ObjectInputStream.readFields. If the new fields are present (test using 
GetFields.defaulted) then we are restoring from a serialization of the 
new form of the class; just restore them as usual. If the fields are 
missing, then the serialized form was from the old class, in this case 
copy the values from the immutable values in BaseDateTime.

Note I have not tried this.

Mark Thornton


From dl at cs.oswego.edu  Tue Jun 21 02:40:09 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 21 Jun 2011 02:40:09 -0400 (EDT)
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <43981.62.20.19.134.19.134.1308638409.squirrel@altair.cs.oswego.edu>

We hit issues like this all the time inside j.u.c code, where we can work
around expressivity limitations using jdk-internal Unsafe hacks. Despite a
fair amount of trying (e.g., proposed but scrapped  Fences API), we
haven't found a good way to support non-privilaged use. In the mean time,
the only officially sanctioned strategy is to declare the possibly-mutable
fields as volatile. You can additionally use AtomicXFieldUpdaters to
arrange weaker-than-volatile writes. However, currently, they encounter
more overhead in dynamic type checks than they usually save in underlying
fence costs. So I'd just use volatile and hope that someday we provide a
way to improve performance. Until then, on most machines and usage
patterns, you won't lose enough performance to justify any of the tricks
people have mentioned.

-Doug


> In Joda-Time way back when we structured the code in a complex manner
> and then claimed immutability. This is causing difficulty to try and
> obey proper immutability standards, and I'd like any ideas on fixes.
>
> Consider the "immutable" class DateTime. The hierarchy is as follows:
>
> AbstractInstant
> AbstractDateTime
> BaseDateTime
> DateTime / MutableDateTime
>
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>
> The two Abstract prefixed classes are not an issue, as they just share
> code and contain no state. However the BaseDateTime contains all the
> state (and DateTime/MutableDateTime contain no state).
>
> As a result of this (bad) design, the instance variables in
> BaseDateTime are not final (as they need to be mutated by the
> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
> storing its state in regular mutable variables in BaseDateTime. Under
> the memory model, claiming DateTime as immutable is wrong.
>
> Making changes to fix this is easy, however making changes and
> preserving backwards compatibility (which is very important here) and
> performance (also important) appears to be very tricky at the moment,
> and thats what I'd like thoughts on.
>
> Options considered:
> a) Change BaseDateTime instance variables to final. No - it breaks the
> mutable subclass
>
> b) Move instance variables down from BaseDateTime to DateTime and
> MutableDateTime. No - Serialization broken (deserialization contains
> the data, but it tries to populate BaseDateTime, not DateTime).
>
> c) Try to do something clever with serialization to read the fields in
> manually. No - can't then store the read data as the instance variable
> has to be final...
>
> d) Change the instance variables to be volatile. Seems like an
> overhead (especially for a performance sensitive class like this).
> Doesn't seem ideal when 99% of the uses will use the "immuable" class
> where its effectively final in nature.
>
> Have I missed an idea? Is there any way to say at the end of a
> constructor "please publish this state as I promise it won't change
> later"?!
>
> Stephen
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



From dl at cs.oswego.edu  Tue Jun 21 03:48:13 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 21 Jun 2011 03:48:13 -0400 (EDT)
Subject: [concurrency-interest] ConcurrentHashMap: HashEntry.value
 potentially null to readers comment
In-Reply-To: <BANLkTime=3PQ14KoC39nRDmL6cdQCwjCxA@mail.gmail.com>
References: <BANLkTime=3PQ14KoC39nRDmL6cdQCwjCxA@mail.gmail.com>
Message-ID: <26262.62.20.19.134.19.134.1308642493.squirrel@altair.cs.oswego.edu>

> Hello everyone,
>
> The questions concerning safe publication, final fields and visibility
> pop up from time to time and I have tracked the list's archives, but
> couldn't find an appropriate answer.

The last version of this discussion is hiding under an uninformative
subject line in the March 2011 archives, esp message 007799
http://cs.oswego.edu/pipermail/concurrency-interest/2011-March/007799.html

Btw, the jdk7 version of this class doesn't use this recheck, because we
now use a volatile read to allow for lazier initialization, which reduces
footptint.

-Doug

>
> ConcurrentHashMap.HashEntry has the following fields:
>
>         final K key;
>         final int hash;
>         volatile V value;
>         final HashEntry<K,V> next;
>
> the only constructor assigns them in this order:
>
>             this.key = key;
>             this.hash = hash;
>             this.next = next;
>             this.value = value;
>
> it is clear to us that all final fields will be published safely; the
> comment in that class states that:
>
>      * Because the value field is volatile, not final, it is legal wrt
>      * the Java Memory Model for an unsynchronized reader to see null
>
> QUESTION 1. The first question is for the possible rationale of
> publishing a reference to a partially constructed object to memory. As
> compiler writers does anybody know when would such an optimization be
> speeding up things or be at all advisable? Or is it just protecting
> oneself against JMM memory model scenario that hardly ever takes place
> in the real generated code (as actually stated in the comment to
> readValueUnderLock)?
>
> QUESTION 2. Would the above scenario change if we reordered
> assignments so that volatile variable is assigned first (before final
> fields)? As in here:
>
>             this.value = value;
>             this.key = key;
>             this.hash = hash;
>             this.next = next;
>
> It is my understanding that final field assignments must precede the
> publication of the object's reference; is this freely reorderable with
> respect to volatile writes?
>
> QUESTION 3. This one is about assignment piggybacking using volatiles.
> If we had a hardware architecture that would allow selective cache
> flushes (to single-cell memory addresses, for example), must writing
> to a volatile enforce a flush of all of the thread's caches? Really?
> If so the only "gain" over full monitors is no need for thread locking
> (only a cache flush), right? I don't see the JLS stating such a thing,
> but I admit the section about happens-before algebra is pretty dense
> to me.
>
> Thanks in advance for all the help or pointers to relevant discussion
> elsewhere.
> Dawid
>
>
> Dawid
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>



From dawid.weiss at gmail.com  Tue Jun 21 03:56:02 2011
From: dawid.weiss at gmail.com (Dawid Weiss)
Date: Tue, 21 Jun 2011 09:56:02 +0200
Subject: [concurrency-interest] ConcurrentHashMap: HashEntry.value
 potentially null to readers comment
In-Reply-To: <26262.62.20.19.134.19.134.1308642493.squirrel@altair.cs.oswego.edu>
References: <BANLkTime=3PQ14KoC39nRDmL6cdQCwjCxA@mail.gmail.com>
	<26262.62.20.19.134.19.134.1308642493.squirrel@altair.cs.oswego.edu>
Message-ID: <BANLkTi=gAkN3YJYH8=jR0seqrTwG_MYFnA@mail.gmail.com>

Thanks Doug, I appreciate your time. This quote is exactly what we were doing:

> In retrospect, I'm not so sure this was a good idea, since
> it leads people to come up with exotic theories.

Dawid

On Tue, Jun 21, 2011 at 9:48 AM, Doug Lea <dl at cs.oswego.edu> wrote:
>> Hello everyone,
>>
>> The questions concerning safe publication, final fields and visibility
>> pop up from time to time and I have tracked the list's archives, but
>> couldn't find an appropriate answer.
>
> The last version of this discussion is hiding under an uninformative
> subject line in the March 2011 archives, esp message 007799
> http://cs.oswego.edu/pipermail/concurrency-interest/2011-March/007799.html
>
> Btw, the jdk7 version of this class doesn't use this recheck, because we
> now use a volatile read to allow for lazier initialization, which reduces
> footptint.
>
> -Doug
>
>>
>> ConcurrentHashMap.HashEntry has the following fields:
>>
>> ? ? ? ? final K key;
>> ? ? ? ? final int hash;
>> ? ? ? ? volatile V value;
>> ? ? ? ? final HashEntry<K,V> next;
>>
>> the only constructor assigns them in this order:
>>
>> ? ? ? ? ? ? this.key = key;
>> ? ? ? ? ? ? this.hash = hash;
>> ? ? ? ? ? ? this.next = next;
>> ? ? ? ? ? ? this.value = value;
>>
>> it is clear to us that all final fields will be published safely; the
>> comment in that class states that:
>>
>> ? ? ?* Because the value field is volatile, not final, it is legal wrt
>> ? ? ?* the Java Memory Model for an unsynchronized reader to see null
>>
>> QUESTION 1. The first question is for the possible rationale of
>> publishing a reference to a partially constructed object to memory. As
>> compiler writers does anybody know when would such an optimization be
>> speeding up things or be at all advisable? Or is it just protecting
>> oneself against JMM memory model scenario that hardly ever takes place
>> in the real generated code (as actually stated in the comment to
>> readValueUnderLock)?
>>
>> QUESTION 2. Would the above scenario change if we reordered
>> assignments so that volatile variable is assigned first (before final
>> fields)? As in here:
>>
>> ? ? ? ? ? ? this.value = value;
>> ? ? ? ? ? ? this.key = key;
>> ? ? ? ? ? ? this.hash = hash;
>> ? ? ? ? ? ? this.next = next;
>>
>> It is my understanding that final field assignments must precede the
>> publication of the object's reference; is this freely reorderable with
>> respect to volatile writes?
>>
>> QUESTION 3. This one is about assignment piggybacking using volatiles.
>> If we had a hardware architecture that would allow selective cache
>> flushes (to single-cell memory addresses, for example), must writing
>> to a volatile enforce a flush of all of the thread's caches? Really?
>> If so the only "gain" over full monitors is no need for thread locking
>> (only a cache flush), right? I don't see the JLS stating such a thing,
>> but I admit the section about happens-before algebra is pretty dense
>> to me.
>>
>> Thanks in advance for all the help or pointers to relevant discussion
>> elsewhere.
>> Dawid
>>
>>
>> Dawid
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
>
>


From mthornton at optrak.com  Tue Jun 21 04:11:56 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Tue, 21 Jun 2011 09:11:56 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4E0039E2.2090102@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4E0039E2.2090102@optrak.com>
Message-ID: <4E00524C.8000202@optrak.com>

On 21/06/11 07:27, Mark Thornton wrote:
> On 20/06/11 11:33, Stephen Colebourne wrote:
>> In Joda-Time way back when we structured the code in a complex manner
>> and then claimed immutability. This is causing difficulty to try and
>> obey proper immutability standards, and I'd like any ideas on fixes.
>>
>> Consider the "immutable" class DateTime. The hierarchy is as follows:
>>
>> AbstractInstant
>> AbstractDateTime
>> BaseDateTime
>> DateTime / MutableDateTime
>>
>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time 
>>
>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base 
>>
>>
>> The two Abstract prefixed classes are not an issue, as they just share
>> code and contain no state. However the BaseDateTime contains all the
>> state (and DateTime/MutableDateTime contain no state).
>>
>> As a result of this (bad) design, the instance variables in
>> BaseDateTime are not final (as they need to be mutated by the
>> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
>> storing its state in regular mutable variables in BaseDateTime. Under
>> the memory model, claiming DateTime as immutable is wrong.
> A possible solution:
>
> Make the fields in BaseDateTime final.
> DateTime is left unchanged.
> Duplicate the fields in MutableDateTime with getter/setters referring 
> to the new (mutable) fields.
>
> Add a readObject method to MutableDateTime which calls 
> ObjectInputStream.readFields. If the new fields are present (test 
> using GetFields.defaulted) then we are restoring from a serialization 
> of the new form of the class; just restore them as usual. If the 
> fields are missing, then the serialized form was from the old class, 
> in this case copy the values from the immutable values in BaseDateTime.
>
> Note I have not tried this.
>
> Mark Thornton
>
An even simpler method would modify MutableDateTime as follows

public class MutableDateTime extends BaseDateTime {
    private long iMillis;
    private Chronology chronology;

    private void readObject(ObjectInputStream in) throws ... {
       iMillis = super.getMillis();
       chronology = super.getChronology();
       in.defaultReadObject();
    }

    public long getMillis() {return iMillis;}
    public Chronology getChronology() {return chronology;}

    // ...
}

This should be backward compatible with existing serialized instances 
while allowing the fields in BaseDateTime to be final. It comes at the 
expense of a slightly larger MutableDateTime object, and slightly slower 
deserialization.

Mark Thornton



From scolebourne at joda.org  Tue Jun 21 07:49:57 2011
From: scolebourne at joda.org (Stephen Colebourne)
Date: Tue, 21 Jun 2011 12:49:57 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4E00524C.8000202@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4E0039E2.2090102@optrak.com> <4E00524C.8000202@optrak.com>
Message-ID: <BANLkTikw8h4kSm1cm2Mf7n54oGfWQ7EHOQ@mail.gmail.com>

On 21 June 2011 09:11, Mark Thornton <mthornton at optrak.com> wrote:
> This should be backward compatible with existing serialized instances while
> allowing the fields in BaseDateTime to be final. It comes at the expense of
> a slightly larger MutableDateTime object, and slightly slower
> deserialization.

In the end, I think Doug's advice is probably right. Just use
volatile. I don't think its ideal, but it "Just Works", which is a
good thing in this codebase.

Mark, I think your change would work (and I like the neat set before
defaultReadFields). However it would have required any mutable
application subclass to be changed, which I was hoping to avoid.
Compared to the volatile approach I decided simple is best.

https://github.com/JodaOrg/joda-time/commit/67f1a30fc0fceda751b6347b2b16a5081878ac1e

Another variation which would also appear to work would be to change
the data storage in BaseDateTime to a transient final two element
array and use ObjectStreamField to read and write the existing
serialized format. (The final array would presumably keep immutability
happy, while the array settability even when final would keep the
mutable classes happy). But the complexity was considerably greater,
so volatile won (unless someone screams that it kills their
performance).

Thanks everyone for your thoughts.

Stephen

From gregg at cytetech.com  Tue Jun 21 09:13:29 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 21 Jun 2011 08:13:29 -0500
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4E00524C.8000202@optrak.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4E0039E2.2090102@optrak.com> <4E00524C.8000202@optrak.com>
Message-ID: <4E0098F9.3090100@cytetech.com>

On 6/21/2011 3:11 AM, Mark Thornton wrote:
> On 21/06/11 07:27, Mark Thornton wrote:
>> On 20/06/11 11:33, Stephen Colebourne wrote:
>>> In Joda-Time way back when we structured the code in a complex manner
>>> and then claimed immutability. This is causing difficulty to try and
>>> obey proper immutability standards, and I'd like any ideas on fixes.
>>>
>>> Consider the "immutable" class DateTime. The hierarchy is as follows:
>>>
>>> AbstractInstant
>>> AbstractDateTime
>>> BaseDateTime
>>> DateTime / MutableDateTime
>>>
>>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
>>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>>>
>>>
>>> The two Abstract prefixed classes are not an issue, as they just share
>>> code and contain no state. However the BaseDateTime contains all the
>>> state (and DateTime/MutableDateTime contain no state).
>>>
>>> As a result of this (bad) design, the instance variables in
>>> BaseDateTime are not final (as they need to be mutated by the
>>> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
>>> storing its state in regular mutable variables in BaseDateTime. Under
>>> the memory model, claiming DateTime as immutable is wrong.
>> A possible solution:
>>
>> Make the fields in BaseDateTime final.
>> DateTime is left unchanged.
>> Duplicate the fields in MutableDateTime with getter/setters referring to the
>> new (mutable) fields.
>>
>> Add a readObject method to MutableDateTime which calls
>> ObjectInputStream.readFields. If the new fields are present (test using
>> GetFields.defaulted) then we are restoring from a serialization of the new
>> form of the class; just restore them as usual. If the fields are missing, then
>> the serialized form was from the old class, in this case copy the values from
>> the immutable values in BaseDateTime.
>>
>> Note I have not tried this.
>>
>> Mark Thornton
>>
> An even simpler method would modify MutableDateTime as follows
>
> public class MutableDateTime extends BaseDateTime {
> private long iMillis;
> private Chronology chronology;
>
> private void readObject(ObjectInputStream in) throws ... {
> iMillis = super.getMillis();
> chronology = super.getChronology();
> in.defaultReadObject();
> }

When there is an object reference involved in this kind of change, we've always 
just done

private void readObject( ObjectInputStream in ) throws ... {

	in.defaultReadObject();

	// If this is the first time to deserialize with the new
	// mutable fields in place, copy the values from the old
	// final fields.
	if( chronology == null ) {
		iMillis = super.getMillis();
		chronology = super.getChronology();
	}
}

This is a little easier to understand so that people don't wonder why you are 
doing things out of order.  A comment on the other version would perhaps detail
what is important about the ordering of statements there too.

Gregg Wonderly

From gregg at cytetech.com  Tue Jun 21 09:17:45 2011
From: gregg at cytetech.com (Gregg Wonderly)
Date: Tue, 21 Jun 2011 08:17:45 -0500
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTikw8h4kSm1cm2Mf7n54oGfWQ7EHOQ@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4E0039E2.2090102@optrak.com> <4E00524C.8000202@optrak.com>
	<BANLkTikw8h4kSm1cm2Mf7n54oGfWQ7EHOQ@mail.gmail.com>
Message-ID: <4E0099F9.3070506@cytetech.com>

On 6/21/2011 6:49 AM, Stephen Colebourne wrote:
> On 21 June 2011 09:11, Mark Thornton<mthornton at optrak.com>  wrote:
>> This should be backward compatible with existing serialized instances while
>> allowing the fields in BaseDateTime to be final. It comes at the expense of
>> a slightly larger MutableDateTime object, and slightly slower
>> deserialization.
>
> In the end, I think Doug's advice is probably right. Just use
> volatile. I don't think its ideal, but it "Just Works", which is a
> good thing in this codebase.
>
> Mark, I think your change would work (and I like the neat set before
> defaultReadFields). However it would have required any mutable
> application subclass to be changed, which I was hoping to avoid.

This is one of the things about property pattern uses in Java that really 
creates problems for a lot of people.  It would be nice if field references 
would automatically translate to getter and setter calls when those methods are 
present in the class.  That would really help super class maintenance issues 
such as these be much easier to manage.

In some sense, there is also the argument that if you really want a property to 
be "public" then it should be accessed via getter/setter methods always.

Gregg Wonderly


From mthornton at optrak.com  Tue Jun 21 09:23:50 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Tue, 21 Jun 2011 14:23:50 +0100
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <4E0098F9.3090100@cytetech.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
	<4E0039E2.2090102@optrak.com> <4E00524C.8000202@optrak.com>
	<4E0098F9.3090100@cytetech.com>
Message-ID: <4E009B66.3060300@optrak.com>

On 21/06/11 14:13, Gregg Wonderly wrote:
> On 6/21/2011 3:11 AM, Mark Thornton wrote:
>> On 21/06/11 07:27, Mark Thornton wrote:
>>> On 20/06/11 11:33, Stephen Colebourne wrote:
>>>> In Joda-Time way back when we structured the code in a complex manner
>>>> and then claimed immutability. This is causing difficulty to try and
>>>> obey proper immutability standards, and I'd like any ideas on fixes.
>>>>
>>>> Consider the "immutable" class DateTime. The hierarchy is as follows:
>>>>
>>>> AbstractInstant
>>>> AbstractDateTime
>>>> BaseDateTime
>>>> DateTime / MutableDateTime
>>>>
>>>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time 
>>>>
>>>> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base 
>>>>
>>>>
>>>>
>>>> The two Abstract prefixed classes are not an issue, as they just share
>>>> code and contain no state. However the BaseDateTime contains all the
>>>> state (and DateTime/MutableDateTime contain no state).
>>>>
>>>> As a result of this (bad) design, the instance variables in
>>>> BaseDateTime are not final (as they need to be mutated by the
>>>> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
>>>> storing its state in regular mutable variables in BaseDateTime. Under
>>>> the memory model, claiming DateTime as immutable is wrong.
>>> A possible solution:
>>>
>>> Make the fields in BaseDateTime final.
>>> DateTime is left unchanged.
>>> Duplicate the fields in MutableDateTime with getter/setters 
>>> referring to the
>>> new (mutable) fields.
>>>
>>> Add a readObject method to MutableDateTime which calls
>>> ObjectInputStream.readFields. If the new fields are present (test using
>>> GetFields.defaulted) then we are restoring from a serialization of 
>>> the new
>>> form of the class; just restore them as usual. If the fields are 
>>> missing, then
>>> the serialized form was from the old class, in this case copy the 
>>> values from
>>> the immutable values in BaseDateTime.
>>>
>>> Note I have not tried this.
>>>
>>> Mark Thornton
>>>
>> An even simpler method would modify MutableDateTime as follows
>>
>> public class MutableDateTime extends BaseDateTime {
>> private long iMillis;
>> private Chronology chronology;
>>
>> private void readObject(ObjectInputStream in) throws ... {
>> iMillis = super.getMillis();
>> chronology = super.getChronology();
>> in.defaultReadObject();
>> }
>
> When there is an object reference involved in this kind of change, 
> we've always just done
>
> private void readObject( ObjectInputStream in ) throws ... {
>
>     in.defaultReadObject();
>
>     // If this is the first time to deserialize with the new
>     // mutable fields in place, copy the values from the old
>     // final fields.
>     if( chronology == null ) {
>         iMillis = super.getMillis();
>         chronology = super.getChronology();
>     }
> }
>
> This is a little easier to understand so that people don't wonder why 
> you are doing things out of order.  A comment on the other version 
> would perhaps detail
> what is important about the ordering of statements there too.
>
> Gregg Wonderly

That only works where the Object reference is non nullable. You could 
use the same technique with any field where the default value is 
invalid. You are quite right that the code should be documented, and 
especially the significance of the statement ordering. With just two 
fields I doubt there is much performance difference.

Mark





From brian at briangoetz.com  Tue Jun 21 19:35:42 2011
From: brian at briangoetz.com (Brian Goetz)
Date: Tue, 21 Jun 2011 19:35:42 -0400
Subject: [concurrency-interest] Joda-Time immutability
In-Reply-To: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
References: <BANLkTim+z_8vSTwneeP4MTq03iLoA+fciw@mail.gmail.com>
Message-ID: <4E012ACE.5080000@briangoetz.com>

Its not obvious that a combination of (b) and (c) can't work, with 
sufficient tweaking in readObject/writeObject/readResolve/writeReplace 
among the three classes.  What you want is for the deserialization to 
recognize whether this is an "old" or "new" serialized form, and behave 
accordingly.  A combination of logic in readObject (which can detect the 
serialized form) and readResolve (which will serve up an instance of a 
different class if it detects the old form) seems like it should do it.

> In Joda-Time way back when we structured the code in a complex manner
> and then claimed immutability. This is causing difficulty to try and
> obey proper immutability standards, and I'd like any ideas on fixes.
>
> Consider the "immutable" class DateTime. The hierarchy is as follows:
>
> AbstractInstant
> AbstractDateTime
> BaseDateTime
> DateTime / MutableDateTime
>
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time
> https://github.com/JodaOrg/joda-time/tree/master/src/main/java/org/joda/time/base
>
> The two Abstract prefixed classes are not an issue, as they just share
> code and contain no state. However the BaseDateTime contains all the
> state (and DateTime/MutableDateTime contain no state).
>
> As a result of this (bad) design, the instance variables in
> BaseDateTime are not final (as they need to be mutated by the
> MutableDateTime subclass). The DateTime ("immutable") subclass is thus
> storing its state in regular mutable variables in BaseDateTime. Under
> the memory model, claiming DateTime as immutable is wrong.
>
> Making changes to fix this is easy, however making changes and
> preserving backwards compatibility (which is very important here) and
> performance (also important) appears to be very tricky at the moment,
> and thats what I'd like thoughts on.
>
> Options considered:
> a) Change BaseDateTime instance variables to final. No - it breaks the
> mutable subclass
>
> b) Move instance variables down from BaseDateTime to DateTime and
> MutableDateTime. No - Serialization broken (deserialization contains
> the data, but it tries to populate BaseDateTime, not DateTime).
>
> c) Try to do something clever with serialization to read the fields in
> manually. No - can't then store the read data as the instance variable
> has to be final...
>
> d) Change the instance variables to be volatile. Seems like an
> overhead (especially for a performance sensitive class like this).
> Doesn't seem ideal when 99% of the uses will use the "immuable" class
> where its effectively final in nature.
>
> Have I missed an idea? Is there any way to say at the end of a
> constructor "please publish this state as I promise it won't change
> later"?!
>
> Stephen
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

From mohanr at fss.co.in  Wed Jun 22 00:55:43 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Wed, 22 Jun 2011 10:25:43 +0530
Subject: [concurrency-interest] Significance of volatile static
Message-ID: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>

Hi,

 

        I have read the presentation "Finalizers, Thread and the Java
memory model" by Hans J. Boehm and I can't claim to understand
everything but I have a question. 

 

I am a beginner and I am trying to understand what the author means by
this statement.

    "Store reference to object into volatile static, then

immediately clear it"

 

Is there any particular semantics associated with 'volatile static' and
the way it is used in this context ?

    

Thanks,

Mohan

 

 

Reachability, visibility solutions

 We want something that

 Ensures reachability

 Synchronizes to create a happens-before relationship

between ordinary methods and finalizer.

 Options provided by JSR133:

 Store into volatile field in ordinary method.

 Read field in finalizer.

 Store reference to object into volatile static, then

immediately clear it.

 Read volatile static in finalizer.

 Release lock on object at end of ordinary method.

 Acquire lock at beginning of finalizer.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110622/74d198d9/attachment.html>

From hans.boehm at hp.com  Wed Jun 22 19:59:41 2011
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 22 Jun 2011 23:59:41 +0000
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
References: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
Message-ID: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>

(A version of the slides are at http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/java_finalizers.pdf .  I couldn't immediately find the official JavaOne version anymore.)

The intent here is that you declare, say, "volatile static sv;" in the class with the finalizer, and then use

sv = this; sv = null;

at any point at  which you want to endure that the object is still considered reachable for finalization purposes, i.e. where keepAlive() is called.

The finalizer then reads sv.  This ensures that there is a happens-before relationship between the assignments and the finalizer, effectively preventing the finalizer from running too early.

This is about as ugly and disgusting as the solution based on synchronized, with the added misfeature that it introduces lots of cache contention, since everybody is writing to the same static variable.  Hence it's likely to make your application completely unscalable, if it wasn't already.

As far as I know, a real  fix for this has unfortunately never made it into the language specification.  (Doug?)  Doug had a proposal as part of the fence proposal.  But I think it ended up as collateral damage of that debate.  The current solutions to this problem are all both ugly and slow.  It's not hard to add something like keepAlive() to the, and make the result just ugly.  To also get rid of the ugliness we would need to stop the compiler from eliminating dead reference variables, at least in some contexts.  This would involve a smallish slowdown in a lot of code in order to support a fairly esoteric feature (finalizers and weak references).  Whether this is worthwhile is open to debate.

As it stands, I suspect little real code uses any of these techniques, and a lot of (most?) Java code using finalizers or weak references is still broken.  But it works correctly most of the time, especially on x86-32.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Mohan Radhakrishnan
Sent: Tuesday, June 21, 2011 9:56 PM
To: concurrency-interest
Subject: [concurrency-interest] Significance of volatile static

Hi,

        I have read the presentation "Finalizers, Thread and the Java memory model" by Hans J. Boehm and I can't claim to understand everything but I have a question.

I am a beginner and I am trying to understand what the author means by this statement.
    "Store reference to object into volatile static, then
immediately clear it"

Is there any particular semantics associated with 'volatile static' and the way it is used in this context ?

Thanks,
Mohan


Reachability, visibility solutions
 We want something that
 Ensures reachability
 Synchronizes to create a happens-before relationship
between ordinary methods and finalizer.
 Options provided by JSR133:
 Store into volatile field in ordinary method.
 Read field in finalizer.
 Store reference to object into volatile static, then
immediately clear it.
 Read volatile static in finalizer.
 Release lock on object at end of ordinary method.
 Acquire lock at beginning of finalizer.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110622/87bf10cd/attachment.html>

From mohanr at fss.co.in  Thu Jun 23 01:01:16 2011
From: mohanr at fss.co.in (Mohan Radhakrishnan)
Date: Thu, 23 Jun 2011 10:31:16 +0530
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <E763DEAFE9F15749B22571A33E165D4C7A34B1@fssbemail.fss.india>

I think I understand. It is just a way of ensuring the happens-before
relationship.

 

It think it cuts both ways. When code that uses finalizers are broken in
critical applications then it is serious. But techniques like this have
to be understood well by programmers with less experience before they
use them. Or else it is even more serious ! AFAIK developers are not
even aware about these points when working with a single CPU. Now I have
suddenly started using multi-core HP Blade servers for our Java
applications!!!!

 

Do these rules apply to Weak references ? As I understand they are also
a useful technique.

 

Thanks,

Mohan

 

________________________________

From: Boehm, Hans [mailto:hans.boehm at hp.com] 
Sent: Thursday, June 23, 2011 5:30 AM
To: Mohan Radhakrishnan; concurrency-interest
Subject: RE: Significance of volatile static

 

(A version of the slides are at
http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/java_finalizers.pd
f .  I couldn't immediately find the official JavaOne version anymore.)

 

The intent here is that you declare, say, "volatile static sv;" in the
class with the finalizer, and then use

 

sv = this; sv = null;

 

at any point at  which you want to endure that the object is still
considered reachable for finalization purposes, i.e. where keepAlive()
is called.

 

The finalizer then reads sv.  This ensures that there is a
happens-before relationship between the assignments and the finalizer,
effectively preventing the finalizer from running too early.

 

This is about as ugly and disgusting as the solution based on
synchronized, with the added misfeature that it introduces lots of cache
contention, since everybody is writing to the same static variable.
Hence it's likely to make your application completely unscalable, if it
wasn't already.

 

As far as I know, a real  fix for this has unfortunately never made it
into the language specification.  (Doug?)  Doug had a proposal as part
of the fence proposal.  But I think it ended up as collateral damage of
that debate.  The current solutions to this problem are all both ugly
and slow.  It's not hard to add something like keepAlive() to the, and
make the result just ugly.  To also get rid of the ugliness we would
need to stop the compiler from eliminating dead reference variables, at
least in some contexts.  This would involve a smallish slowdown in a lot
of code in order to support a fairly esoteric feature (finalizers and
weak references).  Whether this is worthwhile is open to debate.

 

As it stands, I suspect little real code uses any of these techniques,
and a lot of (most?) Java code using finalizers or weak references is
still broken.  But it works correctly most of the time, especially on
x86-32.

 

Hans

 

From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Mohan
Radhakrishnan
Sent: Tuesday, June 21, 2011 9:56 PM
To: concurrency-interest
Subject: [concurrency-interest] Significance of volatile static

 

Hi,

 

        I have read the presentation "Finalizers, Thread and the Java
memory model" by Hans J. Boehm and I can't claim to understand
everything but I have a question. 

 

I am a beginner and I am trying to understand what the author means by
this statement.

    "Store reference to object into volatile static, then

immediately clear it"

 

Is there any particular semantics associated with 'volatile static' and
the way it is used in this context ?

    

Thanks,

Mohan

 

 

Reachability, visibility solutions

 We want something that

 Ensures reachability

 Synchronizes to create a happens-before relationship

between ordinary methods and finalizer.

 Options provided by JSR133:

 Store into volatile field in ordinary method.

 Read field in finalizer.

 Store reference to object into volatile static, then

immediately clear it.

 Read volatile static in finalizer.

 Release lock on object at end of ordinary method.

 Acquire lock at beginning of finalizer.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110623/c65c24f4/attachment-0001.html>

From hans.boehm at hp.com  Thu Jun 23 01:42:32 2011
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 23 Jun 2011 05:42:32 +0000
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <E763DEAFE9F15749B22571A33E165D4C7A34B1@fssbemail.fss.india>
References: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
	<E763DEAFE9F15749B22571A33E165D4C7A34B1@fssbemail.fss.india>
Message-ID: <238A96A773B3934685A7269CC8A8D04272F42077BE@GVW0436EXB.americas.hpqcorp.net>

This problem also applies to java.lang.ref, since that can also be used to perform finalization-like actions, and the target of a weak reference may also appear unreachable while one of its methods is still running.

I'm not sure that multicores affect this problem fundamentally.  It can happen if you garbage collect at the wrong point on a uniprocessor, and then immediately switch to the finalization thread.  Perhaps it is easier to observe on a multicore processor, but I'm not sure.  I suspect it's rare and obscure enough that most observed failures are misattributed to alpha particles or the like.  A few weeks after I gave the talk someone within HP did point out that it finally explained an obscure problem they had been observing.

Hans

From: Mohan Radhakrishnan [mailto:mohanr at fss.co.in]
Sent: Wednesday, June 22, 2011 10:01 PM
To: Boehm, Hans; concurrency-interest
Subject: RE: Significance of volatile static

I think I understand. It is just a way of ensuring the happens-before relationship.

It think it cuts both ways. When code that uses finalizers are broken in critical applications then it is serious. But techniques like this have to be understood well by programmers with less experience before they use them. Or else it is even more serious ! AFAIK developers are not even aware about these points when working with a single CPU. Now I have suddenly started using multi-core HP Blade servers for our Java applications!!!!

Do these rules apply to Weak references ? As I understand they are also a useful technique.

Thanks,
Mohan

________________________________
From: Boehm, Hans [mailto:hans.boehm at hp.com]
Sent: Thursday, June 23, 2011 5:30 AM
To: Mohan Radhakrishnan; concurrency-interest
Subject: RE: Significance of volatile static

(A version of the slides are at http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/java_finalizers.pdf .  I couldn't immediately find the official JavaOne version anymore.)

The intent here is that you declare, say, "volatile static sv;" in the class with the finalizer, and then use

sv = this; sv = null;

at any point at  which you want to endure that the object is still considered reachable for finalization purposes, i.e. where keepAlive() is called.

The finalizer then reads sv.  This ensures that there is a happens-before relationship between the assignments and the finalizer, effectively preventing the finalizer from running too early.

This is about as ugly and disgusting as the solution based on synchronized, with the added misfeature that it introduces lots of cache contention, since everybody is writing to the same static variable.  Hence it's likely to make your application completely unscalable, if it wasn't already.

As far as I know, a real  fix for this has unfortunately never made it into the language specification.  (Doug?)  Doug had a proposal as part of the fence proposal.  But I think it ended up as collateral damage of that debate.  The current solutions to this problem are all both ugly and slow.  It's not hard to add something like keepAlive() to the, and make the result just ugly.  To also get rid of the ugliness we would need to stop the compiler from eliminating dead reference variables, at least in some contexts.  This would involve a smallish slowdown in a lot of code in order to support a fairly esoteric feature (finalizers and weak references).  Whether this is worthwhile is open to debate.

As it stands, I suspect little real code uses any of these techniques, and a lot of (most?) Java code using finalizers or weak references is still broken.  But it works correctly most of the time, especially on x86-32.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Mohan Radhakrishnan
Sent: Tuesday, June 21, 2011 9:56 PM
To: concurrency-interest
Subject: [concurrency-interest] Significance of volatile static

Hi,

        I have read the presentation "Finalizers, Thread and the Java memory model" by Hans J. Boehm and I can't claim to understand everything but I have a question.

I am a beginner and I am trying to understand what the author means by this statement.
    "Store reference to object into volatile static, then
immediately clear it"

Is there any particular semantics associated with 'volatile static' and the way it is used in this context ?

Thanks,
Mohan


Reachability, visibility solutions
 We want something that
 Ensures reachability
 Synchronizes to create a happens-before relationship
between ordinary methods and finalizer.
 Options provided by JSR133:
 Store into volatile field in ordinary method.
 Read field in finalizer.
 Store reference to object into volatile static, then
immediately clear it.
 Read volatile static in finalizer.
 Release lock on object at end of ordinary method.
 Acquire lock at beginning of finalizer.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110623/fbe41763/attachment.html>

From mthornton at optrak.com  Thu Jun 23 03:36:22 2011
From: mthornton at optrak.com (Mark Thornton)
Date: Thu, 23 Jun 2011 08:36:22 +0100
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
References: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
	<238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <4E02ECF6.2000303@optrak.com>

On 23/06/11 00:59, Boehm, Hans wrote:
>
> As it stands, I suspect little real code uses any of these techniques, 
> and a lot of (most?) Java code using finalizers or weak references is 
> still broken.  But it works correctly most of the time, especially on 
> x86-32.
>

Does the concurrent behaviour of x86-64 differ significantly from x86-32?

Mark Thornton
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110623/fe0493b1/attachment.html>

From hans.boehm at hp.com  Thu Jun 23 15:16:56 2011
From: hans.boehm at hp.com (Boehm, Hans)
Date: Thu, 23 Jun 2011 19:16:56 +0000
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <4E02ECF6.2000303@optrak.com>
References: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
	<238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
	<4E02ECF6.2000303@optrak.com>
Message-ID: <238A96A773B3934685A7269CC8A8D04272F4207C3A@GVW0436EXB.americas.hpqcorp.net>

This problem occurs if, during an execution of a method M on a finalizable object, the reference to this or to an argument of M no longer appear to the garbage collector to be reachable.  I think that most x86-32 calling conventions end up passing this pointers and arguments on the stack, and are unlikely to reuse that memory while the method is running.  Thus they're likely to be viewed as reachable by the collector, even after M is done accessing them (but may still be accessing other referenced objects, which would be cleaned up by the finalizer).

x86-64 calling conventions tend to call for passing such things in registers, where they are likely to be overwritten once they are no longer needed.  At that point, the garbage collector will no longer see the object itself as live, the finalizer may run and destroy referenced objects (like an underlying OS file object) which are still being accessed by the method.

Thus, I think things are significantly more likely to fail on x86-64 or RISC architectures, than on architectures like x86-32 that have very few general purpose registers.  But there is no guarantee that code ignoring this problem will work on either.

Hans

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Mark Thornton
Sent: Thursday, June 23, 2011 12:36 AM
To: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Significance of volatile static

On 23/06/11 00:59, Boehm, Hans wrote:


As it stands, I suspect little real code uses any of these techniques, and a lot of (most?) Java code using finalizers or weak references is still broken.  But it works correctly most of the time, especially on x86-32.

Does the concurrent behaviour of x86-64 differ significantly from x86-32?

Mark Thornton



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110623/712bdae1/attachment.html>

From dl at cs.oswego.edu  Sat Jun 25 13:30:29 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Sat, 25 Jun 2011 13:30:29 -0400
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
References: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
	<238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <4E061B35.2000705@cs.oswego.edu>

(Sorry for the delay; I was traveling.)

On 06/22/11 19:59, Boehm, Hans wrote:
> As far as I know, a real fix for this has unfortunately never made it into the
> language specification. (Doug?) Doug had a proposal as part of the fence
> proposal. But I think it ended up as collateral damage of that debate. The

Yes; exactly so. We will need to come up with a different way to
propose this for jdk8.

-Doug


> current solutions to this problem are all both ugly and slow. It?s not hard to
> add something like keepAlive() to the, and make the result just ugly. To also
> get rid of the ugliness we would need to stop the compiler from eliminating dead
> reference variables, at least in some contexts. This would involve a smallish
> slowdown in a lot of code in order to support a fairly esoteric feature
> (finalizers and weak references). Whether this is worthwhile is open to debate.




From sanchay.h at gmail.com  Sun Jun 26 06:30:08 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Sun, 26 Jun 2011 16:00:08 +0530
Subject: [concurrency-interest] Memory sensitive memoization
Message-ID: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>

Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a long
time to compute f(a1,a2), so I want to memoize it, but at the same time want
to make it memory sensitive, i.e., remove memoized entries to reclaim memory
if required. So keys as SoftReferences come to mind. Another requirement is
that this memoized cache should be thread safe, many threads will be writing
and reading from it. With all this in mind, I have the following questions:

1.  Is extra166y.CustomConcurrentHashMap stable enough to use in production?
Or shall I go with org.apache.commons.collections.map.ReferenceMap (and use
Collections.SynchronizedMap)? Or shall I consider writing my own
implementation.

2. Assuming CustomConcurrentHashMap, I have the following pattern in mind,

class Context{
  a1;
  a2;
  // equal and hashcode based on both a1,a2
}

*CustomConcurrentHashMap<Context,V> cache = new
CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,
extra166y.CustomConcurrentHashMap.Equivalence,
extra166y.CustomConcurrentHashMap.Strength,
extra166y.CustomConcurrentHashMap.Equivalence, int)><Context,V>*(
CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
.SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
.EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
.STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
0);

V f(a1,a2){
  Context ctx = new Context(a1,a2); //.......... 1.
  V ret = cache.get(ctx);                  //.......... 2.
  if (ret != null)                                 //.......... 3.
    return ret;                                   //.......... 4.
  // actually compute f(a1,a2);          //........... 5.
  ret.putIfAbsent(ctx, val);                //........... 6.
  return val;                                    //........... 7.
}

I think this pattern does the job, what do you guys suggest ? Is there a
more idiomatic way to doing memoization in Java ? Line 2. above relies on
the assumption that f(a1,a2) will never be null, which is fine, but can this
assumption be somehow avoided? Also at line 6. above I don't strictly need
putIfAbsent, should I just go for put (if it is cheaper) ?


3. Suppose thread t1 is busy computing f(5,10), meanwhile another thread t2
calls f(5,10), what can be done so that t2 waits for t1's computation to
finish and then just takes the value from the cache ? Note it is possible
that by the time t2 checks again, (5,10) is garbage collected and some t3
starts computing (5,10), so it would require a loop.

Thanks!
Sanchay
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/819ff5a7/attachment.html>

From tim at peierls.net  Sun Jun 26 08:59:44 2011
From: tim at peierls.net (Tim Peierls)
Date: Sun, 26 Jun 2011 08:59:44 -0400
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
Message-ID: <BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>

In this case, consider using Guava
MapMaker<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html?com/google/common/collect/MapMaker.html>.
The example in the javadoc is close to what you're looking for.

--tim

On Sun, Jun 26, 2011 at 6:30 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:

> Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a
> long time to compute f(a1,a2), so I want to memoize it, but at the same time
> want to make it memory sensitive, i.e., remove memoized entries to reclaim
> memory if required. So keys as SoftReferences come to mind. Another
> requirement is that this memoized cache should be thread safe, many threads
> will be writing and reading from it. With all this in mind, I have the
> following questions:
>
> 1.  Is extra166y.CustomConcurrentHashMap stable enough to use in
> production? Or shall I go with
> org.apache.commons.collections.map.ReferenceMap (and use
> Collections.SynchronizedMap)? Or shall I consider writing my own
> implementation.
>
> 2. Assuming CustomConcurrentHashMap, I have the following pattern in mind,
>
> class Context{
>   a1;
>   a2;
>   // equal and hashcode based on both a1,a2
> }
>
> *CustomConcurrentHashMap<Context,V> cache = new CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20int)>
> <Context,V>*(CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
> .SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
> .EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
> .STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
> 0);
>
> V f(a1,a2){
>   Context ctx = new Context(a1,a2); //.......... 1.
>   V ret = cache.get(ctx);                  //.......... 2.
>   if (ret != null)                                 //.......... 3.
>     return ret;                                   //.......... 4.
>   // actually compute f(a1,a2);          //........... 5.
>   ret.putIfAbsent(ctx, val);                //........... 6.
>   return val;                                    //........... 7.
> }
>
> I think this pattern does the job, what do you guys suggest ? Is there a
> more idiomatic way to doing memoization in Java ? Line 2. above relies on
> the assumption that f(a1,a2) will never be null, which is fine, but can this
> assumption be somehow avoided? Also at line 6. above I don't strictly need
> putIfAbsent, should I just go for put (if it is cheaper) ?
>
>
> 3. Suppose thread t1 is busy computing f(5,10), meanwhile another thread t2
> calls f(5,10), what can be done so that t2 waits for t1's computation to
> finish and then just takes the value from the cache ? Note it is possible
> that by the time t2 checks again, (5,10) is garbage collected and some t3
> starts computing (5,10), so it would require a loop.
>
> Thanks!
> Sanchay
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/aca03d08/attachment.html>

From sanchay.h at gmail.com  Sun Jun 26 09:43:13 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Sun, 26 Jun 2011 19:13:13 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
Message-ID: <BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>

Hi Tim,

According to my understanding, unfortunately, Guava MapMaker has a
limitation which makes it unusable in this instance:

*Note:* by default, the returned map uses equality comparisons (the
equals<http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)>
 method) to determine equality for keys or values. However, if
weakKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#weakKeys()>
 or softKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#softKeys()>
 was specified, the map uses identity (==) comparisons instead for keys.

Not sure why they have that limitation. I would want to use .equals for soft
keys.

Thanks!

On Sun, Jun 26, 2011 at 6:29 PM, Tim Peierls <tim at peierls.net> wrote:

> In this case, consider using Guava MapMaker<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html?com/google/common/collect/MapMaker.html>.
> The example in the javadoc is close to what you're looking for.
>
> --tim
>
> On Sun, Jun 26, 2011 at 6:30 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>
>> Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a
>> long time to compute f(a1,a2), so I want to memoize it, but at the same time
>> want to make it memory sensitive, i.e., remove memoized entries to reclaim
>> memory if required. So keys as SoftReferences come to mind. Another
>> requirement is that this memoized cache should be thread safe, many threads
>> will be writing and reading from it. With all this in mind, I have the
>> following questions:
>>
>> 1.  Is extra166y.CustomConcurrentHashMap stable enough to use in
>> production? Or shall I go with
>> org.apache.commons.collections.map.ReferenceMap (and use
>> Collections.SynchronizedMap)? Or shall I consider writing my own
>> implementation.
>>
>> 2. Assuming CustomConcurrentHashMap, I have the following pattern in mind,
>>
>> class Context{
>>   a1;
>>   a2;
>>   // equal and hashcode based on both a1,a2
>> }
>>
>> *CustomConcurrentHashMap<Context,V> cache = new CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20int)>
>> <Context,V>*(CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>> .SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
>> .EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>> .STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
>> 0);
>>
>> V f(a1,a2){
>>   Context ctx = new Context(a1,a2); //.......... 1.
>>   V ret = cache.get(ctx);                  //.......... 2.
>>   if (ret != null)                                 //.......... 3.
>>     return ret;                                   //.......... 4.
>>   // actually compute f(a1,a2);          //........... 5.
>>   ret.putIfAbsent(ctx, val);                //........... 6.
>>   return val;                                    //........... 7.
>> }
>>
>> I think this pattern does the job, what do you guys suggest ? Is there a
>> more idiomatic way to doing memoization in Java ? Line 2. above relies on
>> the assumption that f(a1,a2) will never be null, which is fine, but can this
>> assumption be somehow avoided? Also at line 6. above I don't strictly need
>> putIfAbsent, should I just go for put (if it is cheaper) ?
>>
>>
>> 3. Suppose thread t1 is busy computing f(5,10), meanwhile another thread
>> t2 calls f(5,10), what can be done so that t2 waits for t1's computation to
>> finish and then just takes the value from the cache ? Note it is possible
>> that by the time t2 checks again, (5,10) is garbage collected and some t3
>> starts computing (5,10), so it would require a loop.
>>
>> Thanks!
>> Sanchay
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/2f02b020/attachment-0001.html>

From crazybob at crazybob.org  Sun Jun 26 11:46:45 2011
From: crazybob at crazybob.org (Bob Lee)
Date: Sun, 26 Jun 2011 08:46:45 -0700
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
Message-ID: <BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>

Sounds like you want a soft reference to the values, not the keys (MapMaker
will remove the entire entry when the value gets reclaimed).

Bob

On Sun, Jun 26, 2011 at 6:43 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:

> Hi Tim,
>
> According to my understanding, unfortunately, Guava MapMaker has a
> limitation which makes it unusable in this instance:
>
> *Note:* by default, the returned map uses equality comparisons (the equals<http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)>
>  method) to determine equality for keys or values. However, if weakKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#weakKeys()>
>  or softKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#softKeys()>
>  was specified, the map uses identity (==) comparisons instead for keys.
>
> Not sure why they have that limitation. I would want to use .equals for
> soft keys.
>
> Thanks!
>
> On Sun, Jun 26, 2011 at 6:29 PM, Tim Peierls <tim at peierls.net> wrote:
>
>> In this case, consider using Guava MapMaker<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html?com/google/common/collect/MapMaker.html>.
>> The example in the javadoc is close to what you're looking for.
>>
>> --tim
>>
>> On Sun, Jun 26, 2011 at 6:30 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>>
>>> Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a
>>> long time to compute f(a1,a2), so I want to memoize it, but at the same time
>>> want to make it memory sensitive, i.e., remove memoized entries to reclaim
>>> memory if required. So keys as SoftReferences come to mind. Another
>>> requirement is that this memoized cache should be thread safe, many threads
>>> will be writing and reading from it. With all this in mind, I have the
>>> following questions:
>>>
>>> 1.  Is extra166y.CustomConcurrentHashMap stable enough to use in
>>> production? Or shall I go with
>>> org.apache.commons.collections.map.ReferenceMap (and use
>>> Collections.SynchronizedMap)? Or shall I consider writing my own
>>> implementation.
>>>
>>> 2. Assuming CustomConcurrentHashMap, I have the following pattern in
>>> mind,
>>>
>>> class Context{
>>>   a1;
>>>   a2;
>>>   // equal and hashcode based on both a1,a2
>>> }
>>>
>>> *CustomConcurrentHashMap<Context,V> cache = new CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20int)>
>>> <Context,V>*(CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>> .SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
>>> .EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>> .STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
>>> 0);
>>>
>>> V f(a1,a2){
>>>   Context ctx = new Context(a1,a2); //.......... 1.
>>>   V ret = cache.get(ctx);                  //.......... 2.
>>>   if (ret != null)                                 //.......... 3.
>>>     return ret;                                   //.......... 4.
>>>   // actually compute f(a1,a2);          //........... 5.
>>>   ret.putIfAbsent(ctx, val);                //........... 6.
>>>   return val;                                    //........... 7.
>>> }
>>>
>>> I think this pattern does the job, what do you guys suggest ? Is there a
>>> more idiomatic way to doing memoization in Java ? Line 2. above relies on
>>> the assumption that f(a1,a2) will never be null, which is fine, but can this
>>> assumption be somehow avoided? Also at line 6. above I don't strictly need
>>> putIfAbsent, should I just go for put (if it is cheaper) ?
>>>
>>>
>>> 3. Suppose thread t1 is busy computing f(5,10), meanwhile another thread
>>> t2 calls f(5,10), what can be done so that t2 waits for t1's computation to
>>> finish and then just takes the value from the cache ? Note it is possible
>>> that by the time t2 checks again, (5,10) is garbage collected and some t3
>>> starts computing (5,10), so it would require a loop.
>>>
>>> Thanks!
>>> Sanchay
>>>
>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/2c25dcd4/attachment.html>

From sanchay.h at gmail.com  Sun Jun 26 12:13:17 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Sun, 26 Jun 2011 21:43:17 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
Message-ID: <BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>

Hi Bob,

I would prefer soft reference to key, as just the keys themselves might be
too many.

Thanks,
Sanchay

On Sun, Jun 26, 2011 at 9:16 PM, Bob Lee <crazybob at crazybob.org> wrote:

> Sounds like you want a soft reference to the values, not the keys (MapMaker
> will remove the entire entry when the value gets reclaimed).
>
> Bob
>
>
> On Sun, Jun 26, 2011 at 6:43 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>
>> Hi Tim,
>>
>> According to my understanding, unfortunately, Guava MapMaker has a
>> limitation which makes it unusable in this instance:
>>
>> *Note:* by default, the returned map uses equality comparisons (the
>> equals<http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)>
>>  method) to determine equality for keys or values. However, if weakKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#weakKeys()>
>>  or softKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#softKeys()>
>>  was specified, the map uses identity (==) comparisons instead for keys.
>>
>> Not sure why they have that limitation. I would want to use .equals for
>> soft keys.
>>
>> Thanks!
>>
>> On Sun, Jun 26, 2011 at 6:29 PM, Tim Peierls <tim at peierls.net> wrote:
>>
>>> In this case, consider using Guava MapMaker<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html?com/google/common/collect/MapMaker.html>.
>>> The example in the javadoc is close to what you're looking for.
>>>
>>> --tim
>>>
>>> On Sun, Jun 26, 2011 at 6:30 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>>>
>>>> Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a
>>>> long time to compute f(a1,a2), so I want to memoize it, but at the same time
>>>> want to make it memory sensitive, i.e., remove memoized entries to reclaim
>>>> memory if required. So keys as SoftReferences come to mind. Another
>>>> requirement is that this memoized cache should be thread safe, many threads
>>>> will be writing and reading from it. With all this in mind, I have the
>>>> following questions:
>>>>
>>>> 1.  Is extra166y.CustomConcurrentHashMap stable enough to use in
>>>> production? Or shall I go with
>>>> org.apache.commons.collections.map.ReferenceMap (and use
>>>> Collections.SynchronizedMap)? Or shall I consider writing my own
>>>> implementation.
>>>>
>>>> 2. Assuming CustomConcurrentHashMap, I have the following pattern in
>>>> mind,
>>>>
>>>> class Context{
>>>>   a1;
>>>>   a2;
>>>>   // equal and hashcode based on both a1,a2
>>>> }
>>>>
>>>> *CustomConcurrentHashMap<Context,V> cache = new CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20int)>
>>>> <Context,V>*(CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>>> .SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
>>>> .EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>>> .STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
>>>> 0);
>>>>
>>>> V f(a1,a2){
>>>>   Context ctx = new Context(a1,a2); //.......... 1.
>>>>   V ret = cache.get(ctx);                  //.......... 2.
>>>>   if (ret != null)                                 //.......... 3.
>>>>     return ret;                                   //.......... 4.
>>>>   // actually compute f(a1,a2);          //........... 5.
>>>>   ret.putIfAbsent(ctx, val);                //........... 6.
>>>>   return val;                                    //........... 7.
>>>> }
>>>>
>>>> I think this pattern does the job, what do you guys suggest ? Is there a
>>>> more idiomatic way to doing memoization in Java ? Line 2. above relies on
>>>> the assumption that f(a1,a2) will never be null, which is fine, but can this
>>>> assumption be somehow avoided? Also at line 6. above I don't strictly need
>>>> putIfAbsent, should I just go for put (if it is cheaper) ?
>>>>
>>>>
>>>> 3. Suppose thread t1 is busy computing f(5,10), meanwhile another thread
>>>> t2 calls f(5,10), what can be done so that t2 waits for t1's computation to
>>>> finish and then just takes the value from the cache ? Note it is possible
>>>> that by the time t2 checks again, (5,10) is garbage collected and some t3
>>>> starts computing (5,10), so it would require a loop.
>>>>
>>>> Thanks!
>>>> Sanchay
>>>>
>>>>
>>>>
>>>> _______________________________________________
>>>> Concurrency-interest mailing list
>>>> Concurrency-interest at cs.oswego.edu
>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>
>>>>
>>>
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/d4e22904/attachment.html>

From sanchay.h at gmail.com  Sun Jun 26 12:17:09 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Sun, 26 Jun 2011 21:47:09 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
Message-ID: <BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>

Hi Bob,

Indeed, MapMaker's javadoc says:

If strong or weak references were requested, it is possible for a key or
value present in the the map to be reclaimed by the garbage collector. If
this happens, the entry automatically disappears from the map.

But I find this somewhat counter intuitive.

Thanks for pointing that out though!

- Sanchay

On Sun, Jun 26, 2011 at 9:43 PM, Sanchay Harneja <sanchay.h at gmail.com>wrote:

> Hi Bob,
>
> I would prefer soft reference to key, as just the keys themselves might be
> too many.
>
> Thanks,
> Sanchay
>
>
> On Sun, Jun 26, 2011 at 9:16 PM, Bob Lee <crazybob at crazybob.org> wrote:
>
>> Sounds like you want a soft reference to the values, not the keys
>> (MapMaker will remove the entire entry when the value gets reclaimed).
>>
>> Bob
>>
>>
>> On Sun, Jun 26, 2011 at 6:43 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>>
>>> Hi Tim,
>>>
>>> According to my understanding, unfortunately, Guava MapMaker has a
>>> limitation which makes it unusable in this instance:
>>>
>>> *Note:* by default, the returned map uses equality comparisons (the
>>> equals<http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)>
>>>  method) to determine equality for keys or values. However, if
>>> weakKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#weakKeys()>
>>>  or softKeys()<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/MapMaker.html#softKeys()>
>>>  was specified, the map uses identity (==) comparisons instead for keys.
>>>
>>> Not sure why they have that limitation. I would want to use .equals for
>>> soft keys.
>>>
>>> Thanks!
>>>
>>> On Sun, Jun 26, 2011 at 6:29 PM, Tim Peierls <tim at peierls.net> wrote:
>>>
>>>> In this case, consider using Guava MapMaker<http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/index.html?com/google/common/collect/MapMaker.html>.
>>>> The example in the javadoc is close to what you're looking for.
>>>>
>>>> --tim
>>>>
>>>> On Sun, Jun 26, 2011 at 6:30 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>>>>
>>>>> Suppose I have a pure method f, of 2 arguments, a1, a2. Now, it takes a
>>>>> long time to compute f(a1,a2), so I want to memoize it, but at the same time
>>>>> want to make it memory sensitive, i.e., remove memoized entries to reclaim
>>>>> memory if required. So keys as SoftReferences come to mind. Another
>>>>> requirement is that this memoized cache should be thread safe, many threads
>>>>> will be writing and reading from it. With all this in mind, I have the
>>>>> following questions:
>>>>>
>>>>> 1.  Is extra166y.CustomConcurrentHashMap stable enough to use in
>>>>> production? Or shall I go with
>>>>> org.apache.commons.collections.map.ReferenceMap (and use
>>>>> Collections.SynchronizedMap)? Or shall I consider writing my own
>>>>> implementation.
>>>>>
>>>>> 2. Assuming CustomConcurrentHashMap, I have the following pattern in
>>>>> mind,
>>>>>
>>>>> class Context{
>>>>>   a1;
>>>>>   a2;
>>>>>   // equal and hashcode based on both a1,a2
>>>>> }
>>>>>
>>>>> *CustomConcurrentHashMap<Context,V> cache = new
>>>>> CustomConcurrentHashMap<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.html#CustomConcurrentHashMap(extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20extra166y.CustomConcurrentHashMap.Strength,%20extra166y.CustomConcurrentHashMap.Equivalence,%20int)>
>>>>> <Context,V>*(CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>>>> .SOFT, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>
>>>>> .EQUALS, CustomConcurrentHashMap.Strength<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Strength.html>
>>>>> .STRONG, CustomConcurrentHashMap.Equivalence<http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/CustomConcurrentHashMap.Equivalence.html>.EQUALS,
>>>>> 0);
>>>>>
>>>>> V f(a1,a2){
>>>>>   Context ctx = new Context(a1,a2); //.......... 1.
>>>>>   V ret = cache.get(ctx);                  //.......... 2.
>>>>>   if (ret != null)                                 //.......... 3.
>>>>>     return ret;                                   //.......... 4.
>>>>>   // actually compute f(a1,a2);          //........... 5.
>>>>>   ret.putIfAbsent(ctx, val);                //........... 6.
>>>>>   return val;                                    //........... 7.
>>>>> }
>>>>>
>>>>> I think this pattern does the job, what do you guys suggest ? Is there
>>>>> a more idiomatic way to doing memoization in Java ? Line 2. above relies on
>>>>> the assumption that f(a1,a2) will never be null, which is fine, but can this
>>>>> assumption be somehow avoided? Also at line 6. above I don't strictly need
>>>>> putIfAbsent, should I just go for put (if it is cheaper) ?
>>>>>
>>>>>
>>>>> 3. Suppose thread t1 is busy computing f(5,10), meanwhile another
>>>>> thread t2 calls f(5,10), what can be done so that t2 waits for t1's
>>>>> computation to finish and then just takes the value from the cache ? Note it
>>>>> is possible that by the time t2 checks again, (5,10) is garbage collected
>>>>> and some t3 starts computing (5,10), so it would require a loop.
>>>>>
>>>>> Thanks!
>>>>> Sanchay
>>>>>
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> Concurrency-interest mailing list
>>>>> Concurrency-interest at cs.oswego.edu
>>>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>>>
>>>>>
>>>>
>>>
>>> _______________________________________________
>>> Concurrency-interest mailing list
>>> Concurrency-interest at cs.oswego.edu
>>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>>
>>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110626/8e20e080/attachment-0001.html>

From dhanji at gmail.com  Mon Jun 27 01:40:05 2011
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 27 Jun 2011 15:40:05 +1000
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
Message-ID: <BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>

On Mon, Jun 27, 2011 at 2:17 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:

> Hi Bob,
>
> Indeed, MapMaker's javadoc says:
>
> If strong or weak references were requested, it is possible for a key or
> value present in the the map to be reclaimed by the garbage collector. If
> this happens, the entry automatically disappears from the map.
>
> But I find this somewhat counter intuitive.
>

What other behavior could possibly be correct?

If you don't know what the key is anymore, you can't tell what value to
bring back... and it is effectively orphaned.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/d69379ba/attachment.html>

From sanchay.h at gmail.com  Mon Jun 27 02:57:12 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Mon, 27 Jun 2011 12:27:12 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
Message-ID: <BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>

> What other behavior could possibly be correct?
> If you don't know what the key is anymore, you can't tell what value to
bring back... and it is effectively orphaned.

I would like to think of it this way -
1. if keys are hard, but values soft, only values should be
garbage collectible
2. if keys are soft, but values hard, only keys should be garbage
collectible

Consequences (and side effects) should be understood by the user. For 1. I
might want the save the key permanently to distinguish the case of [first
time key] v/s [not first time, but garbage collected].

But the current behavior offered by guava is ok too. In fact I'm using,
(hopefully correctly), softValues() as a substitute for soft keys + key
comparison using .equals.

On a side note, from my little testing I get the impression that weak refs
are too aggressively garbage collected, whereas soft refs are only collected
at the very last moment (effectively crawling the application when memory
limit is hit).  Both don't work for our application. Think I would need a
more comprehensive caching strategy.

Thanks!
Sanchay


On Mon, Jun 27, 2011 at 11:10 AM, Dhanji R. Prasanna <dhanji at gmail.com>wrote:

>
>
> On Mon, Jun 27, 2011 at 2:17 AM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>
>> Hi Bob,
>>
>> Indeed, MapMaker's javadoc says:
>>
>> If strong or weak references were requested, it is possible for a key or
>> value present in the the map to be reclaimed by the garbage collector. If
>> this happens, the entry automatically disappears from the map.
>>
>> But I find this somewhat counter intuitive.
>>
>
> What other behavior could possibly be correct?
>
> If you don't know what the key is anymore, you can't tell what value to
> bring back... and it is effectively orphaned.
>
> Dhanji.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/5497da3b/attachment.html>

From dhanji at gmail.com  Mon Jun 27 03:12:29 2011
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 27 Jun 2011 17:12:29 +1000
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
Message-ID: <BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>

On Mon, Jun 27, 2011 at 4:57 PM, Sanchay Harneja <sanchay.h at gmail.com>wrote:

> > What other behavior could possibly be correct?
> > If you don't know what the key is anymore, you can't tell what value to
> bring back... and it is effectively orphaned.
>
> I would like to think of it this way -
> 1. if keys are hard, but values soft, only values should be
> garbage collectible
> 2. if keys are soft, but values hard, only keys should be garbage
> collectible
>
> Consequences (and side effects) should be understood by the user. For 1. I
> might want the save the key permanently to distinguish the case of [first
> time key] v/s [not first time, but garbage collected].
>

MapMaker (and any library for that matter) have no control over when
something is garbage collected. If you declare a key soft (or weak) it could
disappear at any time, MapMaker cannot expect to have the key sitting around
to call equals() against. If it holds on to the key, then it has hard
referenced it and this amounts to a memory leak.


> On a side note, from my little testing I get the impression that weak refs
> are too aggressively garbage collected, whereas soft refs are only collected
> at the very last moment (effectively crawling the application when memory
> limit is hit).  Both don't work for our application. Think I would need a
> more comprehensive caching strategy.
>

This is the nature of soft references vs weak references. Soft refs are kept
around until the JVM requires more memory (this is somewhat tuneable with a
free memory ratio, so softrefs can be claimed before hitting memory limits).
Your observation is actually the intended, documented behavior.

I would caution against using soft/weak references as an LRU caching
mechanism, having built many Java caches in heavily loaded environments, my
experience tells me that out-of-process caches (like memcached) are
generally better. Others may disagree, of course.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/fb140fb5/attachment.html>

From sanchay.h at gmail.com  Mon Jun 27 04:25:41 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Mon, 27 Jun 2011 13:55:41 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
Message-ID: <BANLkTin73oyeg19GVE+Ovvb7Bs24yZLUuw@mail.gmail.com>

Hi Dhanji,

The trouble point is, if I declare a key hard, it still disappears (if value
is declared soft); which might be fine depending on one's perspective.

Thanks for pointing me towards softrefs tuneable parameter!  I'll give it a
shot. But ultimately, I might go towards something like memcached, as you
suggest.

Regards,
Sanchay

On Mon, Jun 27, 2011 at 12:42 PM, Dhanji R. Prasanna <dhanji at gmail.com>wrote:

>
>
> On Mon, Jun 27, 2011 at 4:57 PM, Sanchay Harneja <sanchay.h at gmail.com>wrote:
>
>> > What other behavior could possibly be correct?
>> > If you don't know what the key is anymore, you can't tell what value to
>> bring back... and it is effectively orphaned.
>>
>> I would like to think of it this way -
>> 1. if keys are hard, but values soft, only values should be
>> garbage collectible
>> 2. if keys are soft, but values hard, only keys should be garbage
>> collectible
>>
>> Consequences (and side effects) should be understood by the user. For 1. I
>> might want the save the key permanently to distinguish the case of [first
>> time key] v/s [not first time, but garbage collected].
>>
>
> MapMaker (and any library for that matter) have no control over when
> something is garbage collected. If you declare a key soft (or weak) it could
> disappear at any time, MapMaker cannot expect to have the key sitting around
> to call equals() against. If it holds on to the key, then it has hard
> referenced it and this amounts to a memory leak.
>
>
>> On a side note, from my little testing I get the impression that weak refs
>> are too aggressively garbage collected, whereas soft refs are only collected
>> at the very last moment (effectively crawling the application when memory
>> limit is hit).  Both don't work for our application. Think I would need a
>> more comprehensive caching strategy.
>>
>
> This is the nature of soft references vs weak references. Soft refs are
> kept around until the JVM requires more memory (this is somewhat tuneable
> with a free memory ratio, so softrefs can be claimed before hitting memory
> limits). Your observation is actually the intended, documented behavior.
>
> I would caution against using soft/weak references as an LRU caching
> mechanism, having built many Java caches in heavily loaded environments, my
> experience tells me that out-of-process caches (like memcached) are
> generally better. Others may disagree, of course.
>
> Dhanji.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/4465eea0/attachment.html>

From dl at cs.oswego.edu  Mon Jun 27 08:04:44 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 27 Jun 2011 08:04:44 -0400
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
Message-ID: <4E0871DC.3030508@cs.oswego.edu>

On 06/27/11 02:57, Sanchay Harneja wrote:
> On a side note, from my little testing I get the impression that weak refs are
> too aggressively garbage collected, whereas soft refs are only collected at the
> very last moment (effectively crawling the application when memory limit is
> hit).  Both don't work for our application. Think I would need a more
> comprehensive caching strategy.

Yes. A "Cache" is basically an enhanced concurrent map with
an expiration policy. There are enough possibilities for how
to expose and support expiration to have led us to stall for
years on releasing one. We will revisit this for jdk8.
In the mean time, guava MapMaker is a reasonable choice
for many usages.

-Doug

From gdenys at yahoo.com  Mon Jun 27 09:12:25 2011
From: gdenys at yahoo.com (Geert Denys)
Date: Mon, 27 Jun 2011 06:12:25 -0700 (PDT)
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <238A96A773B3934685A7269CC8A8D04272F42077BE@GVW0436EXB.americas.hpqcorp.net>
References: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
	<E763DEAFE9F15749B22571A33E165D4C7A34B1@fssbemail.fss.india>
	<238A96A773B3934685A7269CC8A8D04272F42077BE@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <1309180345.65502.YahooMailNeo@web161220.mail.bf1.yahoo.com>

Hans,

We have seen this problem here, too. One test was failing fairly regularly on an 8 core build machine with a mysterious NPE. We weren't able to reproduce it easily on our own 4 core workstations. After a while we realized the finalizer of the object had been run, while another thread was still executing within a method of that object... It sounded hard-to-believe, but then I stumbled upon your paper and slide 31 was exactly the problem we were facing (even the methods names were almost the same:).

Regards,
Geert.


________________________________
From: "Boehm, Hans" <hans.boehm at hp.com>
To: Mohan Radhakrishnan <mohanr at fss.co.in>; concurrency-interest <concurrency-interest at cs.oswego.edu>
Sent: Thursday, June 23, 2011 7:42 AM
Subject: Re: [concurrency-interest] Significance of volatile static


This problem also applies to java.lang.ref, since that can also be used to perform finalization-like actions, and the target of a weak reference may also appear unreachable while one of its methods is still running.
?
I?m not sure that multicores affect this problem fundamentally.? It can happen if you garbage collect at the wrong point on a uniprocessor, and then immediately switch to the finalization thread.? Perhaps it is easier to observe on a multicore processor, but I?m not sure.? I suspect it?s rare and obscure enough that most observed failures are misattributed to alpha particles or the like.? A few weeks after I gave the talk someone within HP did point out that it finally explained an obscure problem they had been observing.
?
Hans
?
From:Mohan Radhakrishnan [mailto:mohanr at fss.co.in] 
Sent: Wednesday, June 22, 2011 10:01 PM
To: Boehm, Hans; concurrency-interest
Subject: RE: Significance of volatile static
?
I think I understand. It is just a way of ensuring the happens-before relationship.
?
It think it cuts both ways. When code that uses finalizers are broken in critical applications then it is serious. But techniques like this have to be understood well by programmers with less experience before they use them. Or else it is even more serious ! AFAIK developers are not even aware about these points when working with a single CPU. Now I have suddenly started using multi-core HP Blade servers for our Java applications!!!!
?
Do these rules apply to Weak references ? As I understand they are also a useful technique.
?
Thanks,
Mohan
?

________________________________

From:Boehm, Hans [mailto:hans.boehm at hp.com] 
Sent: Thursday, June 23, 2011 5:30 AM
To: Mohan Radhakrishnan; concurrency-interest
Subject: RE: Significance of volatile static
?
(A version of the slides are at http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/java_finalizers.pdf .? I couldn?t immediately find the official JavaOne version anymore.)
?
The intent here is that you declare, say, ?volatile static sv;? in the class with the finalizer, and then use
?
sv = this; sv = null;
?
at any point at? which you want to endure that the object is still considered reachable for finalization purposes, i.e. where keepAlive() is called.
?
The finalizer then reads sv.? This ensures that there is a happens-before relationship between the assignments and the finalizer, effectively preventing the finalizer from running too early.
?
This is about as ugly and disgusting as the solution based on synchronized, with the added misfeature that it introduces lots of cache contention, since everybody is writing to the same static variable.? Hence it?s likely to make your application completely unscalable, if it wasn?t already.
?
As far as I know, a real ?fix for this has unfortunately never made it into the language specification.? (Doug?)? Doug had a proposal as part of the fence proposal. ?But I think it ended up as collateral damage of that debate.? The current solutions to this problem are all both ugly and slow.? It?s not hard to add something like keepAlive() to the, and make the result just ugly.? To also get rid of the ugliness we would need to stop the compiler from eliminating dead reference variables, at least in some contexts.? This would involve a smallish slowdown in a lot of code in order to support a fairly esoteric feature (finalizers and weak references).? Whether this is worthwhile is open to debate.
?
As it stands, I suspect little real code uses any of these techniques, and a lot of (most?) Java code using finalizers or weak references is still broken.? But it works correctly most of the time, especially on x86-32.
?
Hans
?
From:concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Mohan Radhakrishnan
Sent: Tuesday, June 21, 2011 9:56 PM
To: concurrency-interest
Subject: [concurrency-interest] Significance of volatile static
?
Hi,
?
??????? I have read the presentation ?Finalizers, Thread and the Java memory model? by Hans J. Boehm and I can?t claim to understand everything but I have a question. 
?
I am a beginner and I am trying to understand what the author means by this statement.
??? ?Store reference to object into volatile static, then
immediately clear it?
?
Is there any particular semantics associated with ?volatile static? and the way it is used in this context ?
??? 
Thanks,
Mohan
?
?
Reachability, visibility solutions
?We want something that
?Ensures reachability
?Synchronizes to create a happens-before relationship
between ordinary methods and finalizer.
?Options provided by JSR133:
?Store into volatile field in ordinary method.
?Read field in finalizer.
?Store reference to object into volatile static, then
immediately clear it.
?Read volatile static in finalizer.
?Release lock on object at end of ordinary method.
?Acquire lock at beginning of finalizer.
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/07d3e2f2/attachment.html>

From blair at orcaware.com  Mon Jun 27 11:47:59 2011
From: blair at orcaware.com (Blair Zajac)
Date: Mon, 27 Jun 2011 08:47:59 -0700
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <4E0871DC.3030508@cs.oswego.edu>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<4E0871DC.3030508@cs.oswego.edu>
Message-ID: <500B99E1-D205-4BA5-BC69-659CFDD242EC@orcaware.com>


On Jun 27, 2011, at 5:04 AM, Doug Lea wrote:

> On 06/27/11 02:57, Sanchay Harneja wrote:
>> On a side note, from my little testing I get the impression that weak refs are
>> too aggressively garbage collected, whereas soft refs are only collected at the
>> very last moment (effectively crawling the application when memory limit is
>> hit).  Both don't work for our application. Think I would need a more
>> comprehensive caching strategy.
> 
> Yes. A "Cache" is basically an enhanced concurrent map with
> an expiration policy. There are enough possibilities for how
> to expose and support expiration to have led us to stall for
> years on releasing one. We will revisit this for jdk8.
> In the mean time, guava MapMaker is a reasonable choice
> for many usages.

As MapMaker has recently added support for specifying a maximum cache size and a #expireAfterAccess() method, are there other missing features you would want to see in jdk8?

Regards,
Blair



From dl at cs.oswego.edu  Mon Jun 27 12:57:04 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 27 Jun 2011 12:57:04 -0400
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <500B99E1-D205-4BA5-BC69-659CFDD242EC@orcaware.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<4E0871DC.3030508@cs.oswego.edu>
	<500B99E1-D205-4BA5-BC69-659CFDD242EC@orcaware.com>
Message-ID: <4E08B660.4010008@cs.oswego.edu>

On 06/27/11 11:47, Blair Zajac wrote:
>> Yes. A "Cache" is basically an enhanced concurrent map with an expiration
>> policy. There are enough possibilities for how to expose and support
>> expiration to have led us to stall for years on releasing one. We will
>> revisit this for jdk8. In the mean time, guava MapMaker is a reasonable
>> choice for many usages.
>
> As MapMaker has recently added support for specifying a maximum cache size
> and a #expireAfterAccess() method, are there other missing features you would
> want to see in jdk8?

Among other issues:
*  Should strict LRU be supported? (This can hurt scalability)
*  Should eviction (optionally?) be handled by a dedicated thread?
     (faster if extra cores are available, but unpredictable on
     overloaded systems)
* Are policies expressed via explicit weights? (requires a
   user defined weighting function)
* Should the API be compatible with JSR107?

-Doug




From szegedia at gmail.com  Mon Jun 27 13:27:08 2011
From: szegedia at gmail.com (Attila Szegedi)
Date: Mon, 27 Jun 2011 10:27:08 -0700
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
Message-ID: <1BF824F7-6A43-4815-AF13-6E919D67E704@gmail.com>

I used to be a big fan of using soft refs for memory-sensitive caching, but in most cases nowadays I prefer an explicitly sized LRU cache instead. 

As far as tuning for soft references is concerned, you should be aware of the following issues (specific to garbage collectors in Sun/Oracle HotSpot JVM):

- All references are cleared during a GC cycle. Therefore:
- if you're using a throughput collector (SerialGC, ParallelGC, or ParallelOldGC), regardless of your free memory ratio, refs in old generation are only cleared when memory fills up completely, as that's the only time old generation collector is run. For practical purposes, this means they're always cleared when free memory drops to zero. Not much granularity there; all soft caches in VM accumulate elements, and then when it's time for a full GC, they're all jettisoned. 
- The exception to above is when you have a different -Xms and -Xmx; at least on Server VM, the -XX:SoftRefLRUPolicyMSPerMB is interpreted against -Xmx, so when a full GC is triggered before your heap has reached its -Xmx size, some soft refs will actually survive.
- with CMS, you'll see a more fine-grained clearing of soft references, but as the additional objects in memory increase the pressure on the GC you'll usually need to add more memory, or set a more aggressive initiating occupancy threshold to make sure CMS can clear enough memory without hitting a concurrent mode failure. Basically, you need to find a balance between at least -XX:CMSInitiatingOccupancyFraction,  -Xmx, and -XX:SoftRefLRUPolicyMSPerMB such that you don't hit a full GC. That's hard. In practical cases, it often turns out easier to use an LRU internally and tune its size. YMMV.

- I have no practical experience with G1 collector, so can't speak about its interaction with soft refs, nor can I speak of soft ref behavior on non-HotSpot VMs.

Attila.

On Jun 27, 2011, at 12:12 AM, Dhanji R. Prasanna wrote:

> [?]
> 
> This is the nature of soft references vs weak references. Soft refs are kept around until the JVM requires more memory (this is somewhat tuneable with a free memory ratio, so softrefs can be claimed before hitting memory limits). Your observation is actually the intended, documented behavior.
> 
> I would caution against using soft/weak references as an LRU caching mechanism, having built many Java caches in heavily loaded environments, my experience tells me that out-of-process caches (like memcached) are generally better. Others may disagree, of course.
> 
> Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110627/34597205/attachment.html>

From dl at cs.oswego.edu  Mon Jun 27 19:42:18 2011
From: dl at cs.oswego.edu (Doug Lea)
Date: Mon, 27 Jun 2011 19:42:18 -0400
Subject: [concurrency-interest] Significance of volatile static
In-Reply-To: <238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
References: <E763DEAFE9F15749B22571A33E165D4C7A3129@fssbemail.fss.india>
	<238A96A773B3934685A7269CC8A8D04272F4207706@GVW0436EXB.americas.hpqcorp.net>
Message-ID: <4E09155A.50705@cs.oswego.edu>

On 06/22/11 19:59, Boehm, Hans wrote:
> (A version of the slides are at
> http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/java_finalizers.pdf .

>
> As far as I know, a real fix for this has unfortunately never made it into the
> language specification. (Doug?) Doug had a proposal as part of the fence
> proposal. But I think it ended up as collateral damage of that debate. T


I should have mentioned that if you define your own version
of reachabilityFence in the way suggested on Hans's slides:
     public static void reachabilityFence(Object ref) {
         synchronized (ref) {}
     }

Then all of the remarks about reachabilityFence in the
unreleased Fences API javadoc hold for it.
(http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/atomic/Fences.html)
This might for now be the best course of action.
Hopefully someday a more efficient implementation of such a method
will be supported in some class, somewhere.

And even as it stands, this is not usually a terrible
implementation -- most objects requiring reachability
fences are not parts of contention bottlenecks.

-Doug



From dhanji at gmail.com  Mon Jun 27 19:55:38 2011
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 28 Jun 2011 09:55:38 +1000
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <4E08B660.4010008@cs.oswego.edu>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<4E0871DC.3030508@cs.oswego.edu>
	<500B99E1-D205-4BA5-BC69-659CFDD242EC@orcaware.com>
	<4E08B660.4010008@cs.oswego.edu>
Message-ID: <BANLkTin8KBce52ZRVvV2E8Pv_UBTDiEPcQ@mail.gmail.com>

On Tue, Jun 28, 2011 at 2:57 AM, Doug Lea <dl at cs.oswego.edu> wrote:

> On 06/27/11 11:47, Blair Zajac wrote:
>
>> Yes. A "Cache" is basically an enhanced concurrent map with an expiration
>>> policy. There are enough possibilities for how to expose and support
>>> expiration to have led us to stall for years on releasing one. We will
>>> revisit this for jdk8. In the mean time, guava MapMaker is a reasonable
>>> choice for many usages.
>>>
>>
>> As MapMaker has recently added support for specifying a maximum cache size
>> and a #expireAfterAccess() method, are there other missing features you
>> would
>> want to see in jdk8?
>>
>
> Among other issues:
> *  Should strict LRU be supported? (This can hurt scalability)
> *  Should eviction (optionally?) be handled by a dedicated thread?
>    (faster if extra cores are available, but unpredictable on
>    overloaded systems)
>

We definitely pushed for explicit eviction for MapMaker. It had advantages
in controlling the aggressiveness with which entries are evicted (add more
threads by ratio, for example) and also for more predictable eviction in
highly controlled environments like AppEngine.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110628/98c42a6c/attachment.html>

From dhanji at gmail.com  Tue Jun 28 01:48:50 2011
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Tue, 28 Jun 2011 15:48:50 +1000
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <2B57071C-BBB8-441C-A00B-1237F0C31C4C@atlassian.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
	<2B57071C-BBB8-441C-A00B-1237F0C31C4C@atlassian.com>
Message-ID: <BANLkTinF5t--3i3i-Ek_n2GckSB1kzz5wA@mail.gmail.com>

On Tue, Jun 28, 2011 at 2:50 PM, Jed Wesley-Smith <
jwesleysmith at atlassian.com> wrote:

> We have found the hard way that using SoftReferences for what is
> essentially an application level concern (caching) is actually
> counter-productive for the most part. The problem being that they clear at
> the time when the application is under serious GC pressure, and there is no
> way to prioritise which ones get cleared. This means that caches start
> missing and expensive operations are performed right at the time when the
> application is under the most load, usually increasing the pressure on it.
>

Exactly, this was one of our most serious problems. Not all data LRU across
the same priority level. The problem with using SoftRefs for caching is that
it treats all memory as equal even across caches. There are also many many
other issues with softrefs, such as clearing overhead, clock timestamping,
the overhead of finalization (done in a single thread) and so on.


> I have heard several others (Cliff Click's "The JVM does what?" for
> instance, as well as various Google sources) express the same opinion, that
> SoftReferences are at best a somewhat illusory benefit.
>

Yep. There are others at Google who (reasonably) argue that efficient caches
can be built in Java but I was quite burned after deploying some of them in
production and argue against them often. I worked with a number of teams
(while at Google) managing very large Java deployments who had similar
conclusions to mine.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110628/48d6faca/attachment.html>

From elizarov at devexperts.com  Tue Jun 28 09:05:19 2011
From: elizarov at devexperts.com (Roman Elizarov)
Date: Tue, 28 Jun 2011 13:05:19 +0000
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <BANLkTinF5t--3i3i-Ek_n2GckSB1kzz5wA@mail.gmail.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
	<2B57071C-BBB8-441C-A00B-1237F0C31C4C@atlassian.com>
	<BANLkTinF5t--3i3i-Ek_n2GckSB1kzz5wA@mail.gmail.com>
Message-ID: <C248BCD79E2CBC4B93C0AE3B1E77E9A892FA27@RAVEN.office.devexperts.com>

We at Devexperts have come through the same experience. We were using SoftReferences for caching for a while and had found then inadequate for exactly the same reason. Now we use only size-limited LRU caches (sometimes they are also time-limited). We rarely use true LRU, though (due to cost of its maintenance in concurrent scenario). Usually it is some kind of approximate-LRU algorithm.

Sincerely,
Roman Elizarov

From: concurrency-interest-bounces at cs.oswego.edu [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Dhanji R. Prasanna
Sent: Tuesday, June 28, 2011 9:49 AM
To: Jed Wesley-Smith
Cc: Sanchay Harneja; concurrency-interest at cs.oswego.edu; Tim Peierls
Subject: Re: [concurrency-interest] Memory sensitive memoization


On Tue, Jun 28, 2011 at 2:50 PM, Jed Wesley-Smith <jwesleysmith at atlassian.com<mailto:jwesleysmith at atlassian.com>> wrote:
We have found the hard way that using SoftReferences for what is essentially an application level concern (caching) is actually counter-productive for the most part. The problem being that they clear at the time when the application is under serious GC pressure, and there is no way to prioritise which ones get cleared. This means that caches start missing and expensive operations are performed right at the time when the application is under the most load, usually increasing the pressure on it.

Exactly, this was one of our most serious problems. Not all data LRU across the same priority level. The problem with using SoftRefs for caching is that it treats all memory as equal even across caches. There are also many many other issues with softrefs, such as clearing overhead, clock timestamping, the overhead of finalization (done in a single thread) and so on.

I have heard several others (Cliff Click's "The JVM does what?" for instance, as well as various Google sources) express the same opinion, that SoftReferences are at best a somewhat illusory benefit.

Yep. There are others at Google who (reasonably) argue that efficient caches can be built in Java but I was quite burned after deploying some of them in production and argue against them often. I worked with a number of teams (while at Google) managing very large Java deployments who had similar conclusions to mine.

Dhanji.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110628/f26aa57d/attachment-0001.html>

From sanchay.h at gmail.com  Tue Jun 28 11:00:18 2011
From: sanchay.h at gmail.com (Sanchay Harneja)
Date: Tue, 28 Jun 2011 20:30:18 +0530
Subject: [concurrency-interest] Memory sensitive memoization
In-Reply-To: <C248BCD79E2CBC4B93C0AE3B1E77E9A892FA27@RAVEN.office.devexperts.com>
References: <BANLkTintmP8a0_02Sr_HtXZ=DkLsyySkrQ@mail.gmail.com>
	<BANLkTinyXeirb2Vj_G0fCRXos_XGqag6BA@mail.gmail.com>
	<BANLkTi=MR_-bCkULzrDQP2TN_-Du9td=CQ@mail.gmail.com>
	<BANLkTinGNREFMs-DxvgosU__T1Hf0WWodg@mail.gmail.com>
	<BANLkTimL=yh0VFV+tfFH8HseEdJYqi98NQ@mail.gmail.com>
	<BANLkTi=6jGWD_OpdVwRLn4zFueaFzNwx4Q@mail.gmail.com>
	<BANLkTikKx1Cv2N+WDXq5MpjbKL48GJ5fhg@mail.gmail.com>
	<BANLkTi=dtA8nOv4qg8mmyaGUMbv+Bt4FZA@mail.gmail.com>
	<BANLkTin53BtO4J4FBNK93tEM9O5XsBhoRQ@mail.gmail.com>
	<2B57071C-BBB8-441C-A00B-1237F0C31C4C@atlassian.com>
	<BANLkTinF5t--3i3i-Ek_n2GckSB1kzz5wA@mail.gmail.com>
	<C248BCD79E2CBC4B93C0AE3B1E77E9A892FA27@RAVEN.office.devexperts.com>
Message-ID: <BANLkTim26jmniUrhmYUw4jYehQN30-9c0Q@mail.gmail.com>

For the time being we are thinking of going with the following approach -
1. Use MapMaker with hard keys, soft values.
2. At regular intervals poll process heap used ratio (using
java.lang.management). If more than certain threshold, manually clear out
some entries in the cache.

This solution gives us good amount of flexibility. We cannot afford to go
LRU and put a size cap on our caches - since we cannot predict the size of
our caches, or the number of caches for that matter !

Thanks!
Sanchay

On Tue, Jun 28, 2011 at 6:35 PM, Roman Elizarov <elizarov at devexperts.com>wrote:

>  We at Devexperts have come through the same experience. We were using
> SoftReferences for caching for a while and had found then inadequate for
> exactly the same reason. Now we use only size-limited LRU caches (sometimes
> they are also time-limited). We rarely use true LRU, though (due to cost of
> its maintenance in concurrent scenario). Usually it is some kind of
> approximate-LRU algorithm.****
>
> ** **
>
> Sincerely,****
>
> Roman Elizarov****
>
> ** **
>
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu] *On Behalf Of *Dhanji R.
> Prasanna
> *Sent:* Tuesday, June 28, 2011 9:49 AM
> *To:* Jed Wesley-Smith
> *Cc:* Sanchay Harneja; concurrency-interest at cs.oswego.edu; Tim Peierls
> *Subject:* Re: [concurrency-interest] Memory sensitive memoization****
>
> ** **
>
> ** **
>
> On Tue, Jun 28, 2011 at 2:50 PM, Jed Wesley-Smith <
> jwesleysmith at atlassian.com> wrote:****
>
> We have found the hard way that using SoftReferences for what is
> essentially an application level concern (caching) is actually
> counter-productive for the most part. The problem being that they clear at
> the time when the application is under serious GC pressure, and there is no
> way to prioritise which ones get cleared. This means that caches start
> missing and expensive operations are performed right at the time when the
> application is under the most load, usually increasing the pressure on it.
> ****
>
> ** **
>
> Exactly, this was one of our most serious problems. Not all data LRU across
> the same priority level. The problem with using SoftRefs for caching is that
> it treats all memory as equal even across caches. There are also many many
> other issues with softrefs, such as clearing overhead, clock timestamping,
> the overhead of finalization (done in a single thread) and so on.****
>
>  ****
>
>  I have heard several others (Cliff Click's "The JVM does what?" for
> instance, as well as various Google sources) express the same opinion, that
> SoftReferences are at best a somewhat illusory benefit.****
>
>  ** **
>
> Yep. There are others at Google who (reasonably) argue that efficient
> caches can be built in Java but I was quite burned after deploying some of
> them in production and argue against them often. I worked with a number of
> teams (while at Google) managing very large Java deployments who had similar
> conclusions to mine.****
>
> ** **
>
> Dhanji.****
>
> ** **
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20110628/caf8ce35/attachment.html>

