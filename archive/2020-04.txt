From nigro.fra at gmail.com  Sun Apr  5 07:23:20 2020
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Sun, 5 Apr 2020 13:23:20 +0200
Subject: [concurrency-interest] custom Nano time provider
Message-ID: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>

Hi folks,

In the recent period I am working on some high availability solution in the
project I currently work and I have noticed how is important for testing
purposes to use custom System::currentTimeMillis and System::nanoTime
providers to trigger specific reproducible conditions: there is any plan to
allow something similar in some of the concurrent primitive that make uses
of such functions?
I believe this could help both implementors and users.


Thanks,
Franz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200405/b8b665df/attachment.htm>

From me at yawk.at  Sun Apr  5 07:33:57 2020
From: me at yawk.at (Jonas Konrad)
Date: Sun, 5 Apr 2020 13:33:57 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
Message-ID: <733a0b25-67dc-ca48-6cb0-ffa5a46776c6@yawk.at>

Java 8 introduced the java.time.Clock API. This can replace 
currentTimeMillis for ease of testing.

I don't think such an API exists for nanoTime. I'm not sure how 
realistic such an API would be since users of nanoTime are presumably 
interested in accuracy.

- Jonas

On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
> Hi folks,
> 
> In the recent period I am working on some high availability solution in 
> the project I currently work and I have noticed how is important for 
> testing purposes to use custom System::currentTimeMillis and 
> System::nanoTime providers to trigger specific reproducible conditions: 
> there is any plan to allow something similar in some of the concurrent 
> primitive that make uses of such functions?
> I believe this could help both implementors and users.
> 
> 
> Thanks,
> Franz
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> 

From nigro.fra at gmail.com  Sun Apr  5 07:44:54 2020
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Sun, 5 Apr 2020 13:44:54 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <733a0b25-67dc-ca48-6cb0-ffa5a46776c6@yawk.at>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <733a0b25-67dc-ca48-6cb0-ffa5a46776c6@yawk.at>
Message-ID: <CAKxGtTWo9=2GwaBm8jemanBjWzbiiW7Lp-kkV1FW8=aQykJnEA@mail.gmail.com>

Thanks Jonas,

I am aware of such API, but my request is to allow the existing primitives
that uses System::nanoTime and System::currentTimeMillis (eg many lock
implementations) to uses a custom time provider.

Il dom 5 apr 2020, 13:34 Jonas Konrad via Concurrency-interest <
concurrency-interest at cs.oswego.edu> ha scritto:

> Java 8 introduced the java.time.Clock API. This can replace
> currentTimeMillis for ease of testing.
>
> I don't think such an API exists for nanoTime. I'm not sure how
> realistic such an API would be since users of nanoTime are presumably
> interested in accuracy.
>
> - Jonas
>
> On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
> > Hi folks,
> >
> > In the recent period I am working on some high availability solution in
> > the project I currently work and I have noticed how is important for
> > testing purposes to use custom System::currentTimeMillis and
> > System::nanoTime providers to trigger specific reproducible conditions:
> > there is any plan to allow something similar in some of the concurrent
> > primitive that make uses of such functions?
> > I believe this could help both implementors and users.
> >
> >
> > Thanks,
> > Franz
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at cs.oswego.edu
> > http://cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200405/3b889155/attachment.htm>

From valentin.male.kovalenko at gmail.com  Sun Apr  5 17:15:47 2020
From: valentin.male.kovalenko at gmail.com (Valentin Kovalenko)
Date: Sun, 5 Apr 2020 15:15:47 -0600
Subject: [concurrency-interest] custom Nano time provider
Message-ID: <CAO-wXwJgx=3vU+LtFXNE_mdcNSA=nBR+M2NiL8hNv78j+8duCg@mail.gmail.com>

Yes, having the ability to control the flow of time as perceived by JDK
concurrency classes would facilitate writing concurrency tests. Though I
hope that those classes do not use currentTimeMilllis under the hood
because it shouldn't be used to measure duration. And those 3rd party
classes that need to use currentTimeMillis (e.g. Spring cron-style
scheduling) can use Clock and provide ways of supplying custom Clock
implementations.

Valentin

------------------------------


Message: 3
Date: Sun, 5 Apr 2020 13:44:54 +0200
From: Francesco Nigro <nigro.fra at gmail.com>
To: Jonas Konrad <me at yawk.at>
Cc: concurrency-interest <concurrency-interest at cs.oswego.edu>
Subject: Re: [concurrency-interest] custom Nano time provider
Message-ID:
        <CAKxGtTWo9=2GwaBm8jemanBjWzbiiW7Lp-kkV1FW8=aQykJnEA at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

Thanks Jonas,

I am aware of such API, but my request is to allow the existing primitives
that uses System::nanoTime and System::currentTimeMillis (eg many lock
implementations) to uses a custom time provider
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200405/3e08475f/attachment.htm>

From peter.levart at gmail.com  Mon Apr  6 05:55:50 2020
From: peter.levart at gmail.com (Peter Levart)
Date: Mon, 6 Apr 2020 11:55:50 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
Message-ID: <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>

You could perhaps use bytecode instrumentation 
(https://www.baeldung.com/java-instrumentation) to "patch" System class 
and redirect/delegate it's execution to your custom time source.

Peter

On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
> Hi folks,
>
> In the recent period I am working on some high availability solution 
> in the project I currently work and I have noticed how is important 
> for testing purposes to use custom System::currentTimeMillis and 
> System::nanoTime providers to trigger specific reproducible 
> conditions: there is any plan to allow something similar in some of 
> the concurrent primitive that make uses of such functions?
> I believe this could help both implementors and users.
>
>
> Thanks,
> Franz
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/f15a4440/attachment.htm>

From tg at freigmbh.de  Mon Apr  6 06:53:04 2020
From: tg at freigmbh.de (Thorsten)
Date: Mon, 6 Apr 2020 12:53:04 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
Message-ID: <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>

Hello

To expand on Peters answer: For testing purpose to get reproducible 
results you might to look into some mocking frameworks.

For example in jmockit i can just do this

final MockUp mockUp =new MockUp(System.class) {
     @Mock long nanoTime() {
         return 1234; }
}; System.out.println(" = " + System.nanoTime());

Boom custom nanoTime Provider.

Best regards,

Thorsten Goetzke

Am 06/04/2020 um 11:55 schrieb Peter Levart via Concurrency-interest:
> You could perhaps use bytecode instrumentation 
> (https://www.baeldung.com/java-instrumentation) to "patch" System 
> class and redirect/delegate it's execution to your custom time source.
>
> Peter
>
> On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
>> Hi folks,
>>
>> In the recent period I am working on some high availability solution 
>> in the project I currently work and I have noticed how is important 
>> for testing purposes to use custom System::currentTimeMillis and 
>> System::nanoTime providers to trigger specific reproducible 
>> conditions: there is any plan to allow something similar in some of 
>> the concurrent primitive that make uses of such functions?
>> I believe this could help both implementors and users.
>>
>>
>> Thanks,
>> Franz
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/dff0369f/attachment.htm>

From oleksandr.otenko at gmail.com  Mon Apr  6 08:18:56 2020
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 6 Apr 2020 13:18:56 +0100
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
 <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>
Message-ID: <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>

How does that work for a sequence of timestamps you want to feed? (Assuming
you will need some j.u.c.Queue for this...)

Alex

On Mon, 6 Apr 2020, 11:54 Thorsten via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

> Hello
>
> To expand on Peters answer: For testing purpose to get reproducible
> results you might to look into some mocking frameworks.
>
> For example in jmockit i can just do this
>
> final MockUp mockUp = new MockUp(System.class) {
>     @Mock    long nanoTime() {
>         return 1234;    }
> };System.out.println(" = " + System.nanoTime());
>
> Boom custom nanoTime Provider.
>
> Best regards,
>
> Thorsten Goetzke
> Am 06/04/2020 um 11:55 schrieb Peter Levart via Concurrency-interest:
>
> You could perhaps use bytecode instrumentation (
> https://www.baeldung.com/java-instrumentation) to "patch" System class
> and redirect/delegate it's execution to your custom time source.
>
> Peter
>
> On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
>
> Hi folks,
>
> In the recent period I am working on some high availability solution in
> the project I currently work and I have noticed how is important for
> testing purposes to use custom System::currentTimeMillis and
> System::nanoTime providers to trigger specific reproducible conditions:
> there is any plan to allow something similar in some of the concurrent
> primitive that make uses of such functions?
> I believe this could help both implementors and users.
>
>
> Thanks,
> Franz
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> _______________________________________________
> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/c334d49b/attachment-0001.htm>

From nigro.fra at gmail.com  Mon Apr  6 08:26:39 2020
From: nigro.fra at gmail.com (Francesco Nigro)
Date: Mon, 6 Apr 2020 14:26:39 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
 <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>
 <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>
Message-ID: <CAKxGtTUV4ZjA1Hq39gZ6ENCV9s2WcZf4eh45=rmNOZss7rWXAA@mail.gmail.com>

@Alex Otenko <oleksandr.otenko at gmail.com>
I was gong to write exactly the same :)

That's why I still think it would beneficial to have something different
from a mocked solution, but a proper API extension that unify the usage of
temporal info.
>From the POV of performance it shouldn't be a big problem, given that a
real system is supposed to always use a single provide (and implementor)
making the actual call always monomorphic and (given that should just wrap
System::nanotTime)
trivially inlineable.

Il giorno lun 6 apr 2020 alle ore 14:19 Alex Otenko <
oleksandr.otenko at gmail.com> ha scritto:

> How does that work for a sequence of timestamps you want to feed?
> (Assuming you will need some j.u.c.Queue for this...)
>
> Alex
>
> On Mon, 6 Apr 2020, 11:54 Thorsten via Concurrency-interest, <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Hello
>>
>> To expand on Peters answer: For testing purpose to get reproducible
>> results you might to look into some mocking frameworks.
>>
>> For example in jmockit i can just do this
>>
>> final MockUp mockUp = new MockUp(System.class) {
>>     @Mock    long nanoTime() {
>>         return 1234;    }
>> };System.out.println(" = " + System.nanoTime());
>>
>> Boom custom nanoTime Provider.
>>
>> Best regards,
>>
>> Thorsten Goetzke
>> Am 06/04/2020 um 11:55 schrieb Peter Levart via Concurrency-interest:
>>
>> You could perhaps use bytecode instrumentation (
>> https://www.baeldung.com/java-instrumentation) to "patch" System class
>> and redirect/delegate it's execution to your custom time source.
>>
>> Peter
>>
>> On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
>>
>> Hi folks,
>>
>> In the recent period I am working on some high availability solution in
>> the project I currently work and I have noticed how is important for
>> testing purposes to use custom System::currentTimeMillis and
>> System::nanoTime providers to trigger specific reproducible conditions:
>> there is any plan to allow something similar in some of the concurrent
>> primitive that make uses of such functions?
>> I believe this could help both implementors and users.
>>
>>
>> Thanks,
>> Franz
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/7024b910/attachment.htm>

From tg at freigmbh.de  Mon Apr  6 08:51:15 2020
From: tg at freigmbh.de (Thorsten)
Date: Mon, 6 Apr 2020 14:51:15 +0200
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
 <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>
 <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>
Message-ID: <78098310-cd94-0dfa-542b-30acc71c929a@freigmbh.de>

You can replace 1234 with whatever logic you want ,  so  yes a queue 
seems a natural choice

final MockUp mockUp =new MockUp(System.class) {
     private final Queue<Long>objects =new LinkedBlockingQueue(List.of(12L, 144L)); @Mock long nanoTime() {
         return objects.poll(); }
}; System.out.println(" = " + System.nanoTime()); //12 System.out.println(" = " + System.nanoTime()); // 144 System.out.println(" = " + System.nanoTime()); // dies miserably

Or he what about this

final MockUp mockUp =new MockUp(System.class) {
     private final Iterator<Long>objects = LongStream.iterate(20, x -> x +1).iterator(); @Mock long nanoTime() {
         return objects.next(); }
};

 > That's why I still think it would beneficial to have something 
different from a mocked solution, but a proper API extension that unify 
the usage of temporal info.

I kind of fail to see how that would work differently from what you can 
do with Mocks.  You get your callback and you can do whatever you want 
and if your code is stupid enough you might blow up your application ;)

I dont't whant to argue about this, just showcasing for reference that 
one can return reproducible values from System#nanoTime without to much 
effort and without requiring a new API.

Best regards,

Thorsten

Am 06/04/2020 um 14:18 schrieb Alex Otenko:
> How does that work for a sequence of timestamps you want to feed? 
> (Assuming you will need some j.u.c.Queue for this...)
>
> Alex
>
> On Mon, 6 Apr 2020, 11:54 Thorsten via Concurrency-interest, 
> <concurrency-interest at cs.oswego.edu 
> <mailto:concurrency-interest at cs.oswego.edu>> wrote:
>
>     Hello
>
>     To expand on Peters answer: For testing purpose to get
>     reproducible results you might to look into some mocking frameworks.
>
>     For example in jmockit i can just do this
>
>     final MockUp mockUp =new MockUp(System.class) {
>          @Mock long nanoTime() {
>              return 1234; }
>     }; System.out.println(" = " + System.nanoTime());
>
>     Boom custom nanoTime Provider.
>
>     Best regards,
>
>     Thorsten Goetzke
>
>     Am 06/04/2020 um 11:55 schrieb Peter Levart via Concurrency-interest:
>>     You could perhaps use bytecode instrumentation
>>     (https://www.baeldung.com/java-instrumentation) to "patch" System
>>     class and redirect/delegate it's execution to your custom time
>>     source.
>>
>>     Peter
>>
>>     On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
>>>     Hi folks,
>>>
>>>     In the recent period I am working on some high availability
>>>     solution in the project I currently work and I have noticed how
>>>     is important for testing purposes to use custom
>>>     System::currentTimeMillis and System::nanoTime providers to
>>>     trigger specific reproducible conditions: there is any plan to
>>>     allow something similar in some of the concurrent primitive that
>>>     make uses of such functions?
>>>     I believe this could help both implementors and users.
>>>
>>>
>>>     Thanks,
>>>     Franz
>>>
>>>     _______________________________________________
>>>     Concurrency-interest mailing list
>>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>     _______________________________________________
>>     Concurrency-interest mailing list
>>     Concurrency-interest at cs.oswego.edu  <mailto:Concurrency-interest at cs.oswego.edu>
>>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at cs.oswego.edu
>     <mailto:Concurrency-interest at cs.oswego.edu>
>     http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/8373c769/attachment.htm>

From oleksandr.otenko at gmail.com  Mon Apr  6 09:30:25 2020
From: oleksandr.otenko at gmail.com (Alex Otenko)
Date: Mon, 6 Apr 2020 14:30:25 +0100
Subject: [concurrency-interest] custom Nano time provider
In-Reply-To: <78098310-cd94-0dfa-542b-30acc71c929a@freigmbh.de>
References: <CAKxGtTVU_ic1kOdPL6XLgD2O5VNVyKkU7n8xnrqTVzS2jQoAvQ@mail.gmail.com>
 <bf1c4427-deee-4118-35a9-916546542e7d@gmail.com>
 <0dd0a8e3-c03c-43c3-0de7-a9d5d88aef7f@freigmbh.de>
 <CANkgWKj1Ujhmx9Ud-yAn36UDOGfNb303x46bR-kxmSFQuXgOWA@mail.gmail.com>
 <78098310-cd94-0dfa-542b-30acc71c929a@freigmbh.de>
Message-ID: <CANkgWKi7AmZreKkr8R3j8w2WA6ZvU_=CawPq79PYs4F6Bz9obQ@mail.gmail.com>

Well, mock will work only if you know the Queue is not going to call
nanoTime. As such, this is a dangerous assumption.

Alex

On Mon, 6 Apr 2020, 13:52 Thorsten via Concurrency-interest, <
concurrency-interest at cs.oswego.edu> wrote:

> You can replace 1234 with whatever logic you want ,  so  yes a queue seems
> a natural choice
>
> final MockUp mockUp = new MockUp(System.class) {
>     private final Queue<Long> objects = new LinkedBlockingQueue(List.of(12L, 144L));    @Mock    long nanoTime() {
>         return objects.poll();    }
> };System.out.println(" = " + System.nanoTime()); //12System.out.println(" = " + System.nanoTime()); // 144System.out.println(" = " + System.nanoTime()); // dies miserably
>
> Or he what about this
>
> final MockUp mockUp = new MockUp(System.class) {
>     private final Iterator<Long> objects = LongStream.iterate(20, x -> x + 1).iterator();    @Mock    long nanoTime() {
>         return objects.next();    }
> };
>
> > That's why I still think it would beneficial to have something different
> from a mocked solution, but a proper API extension that unify the usage of
> temporal info.
>
> I kind of fail to see how that would work differently from what you can do
> with Mocks.  You get your callback and you can do whatever you want and if
> your code is stupid enough you might blow up your application ;)
>
> I dont't whant to argue about this, just showcasing for reference that one
> can return reproducible values from System#nanoTime without to much effort
> and without requiring a new API.
>
> Best regards,
>
> Thorsten
> Am 06/04/2020 um 14:18 schrieb Alex Otenko:
>
> How does that work for a sequence of timestamps you want to feed?
> (Assuming you will need some j.u.c.Queue for this...)
>
> Alex
>
> On Mon, 6 Apr 2020, 11:54 Thorsten via Concurrency-interest, <
> concurrency-interest at cs.oswego.edu> wrote:
>
>> Hello
>>
>> To expand on Peters answer: For testing purpose to get reproducible
>> results you might to look into some mocking frameworks.
>>
>> For example in jmockit i can just do this
>>
>> final MockUp mockUp = new MockUp(System.class) {
>>     @Mock    long nanoTime() {
>>         return 1234;    }
>> };System.out.println(" = " + System.nanoTime());
>>
>> Boom custom nanoTime Provider.
>>
>> Best regards,
>>
>> Thorsten Goetzke
>> Am 06/04/2020 um 11:55 schrieb Peter Levart via Concurrency-interest:
>>
>> You could perhaps use bytecode instrumentation (
>> https://www.baeldung.com/java-instrumentation) to "patch" System class
>> and redirect/delegate it's execution to your custom time source.
>>
>> Peter
>>
>> On 4/5/20 1:23 PM, Francesco Nigro via Concurrency-interest wrote:
>>
>> Hi folks,
>>
>> In the recent period I am working on some high availability solution in
>> the project I currently work and I have noticed how is important for
>> testing purposes to use custom System::currentTimeMillis and
>> System::nanoTime providers to trigger specific reproducible conditions:
>> there is any plan to allow something similar in some of the concurrent
>> primitive that make uses of such functions?
>> I believe this could help both implementors and users.
>>
>>
>> Thanks,
>> Franz
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>>
>>
>> _______________________________________________
>> Concurrency-interest mailing listConcurrency-interest at cs.oswego.eduhttp://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at cs.oswego.edu
>> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200406/03951ba4/attachment-0001.htm>

From ludwig.mark at siemens.com  Wed Apr 15 16:45:55 2020
From: ludwig.mark at siemens.com (Ludwig, Mark)
Date: Wed, 15 Apr 2020 20:45:55 +0000
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
Message-ID: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>

Greetings,

I hope this is a suitable topic for this list.

We are wondering if we need to arrange for some explicit synchronization in a Servlet Filter's doFilter() method to safely refer to an instance variable that was set in the init() method.

We can't find any mention of this, and without forcing memory fences, are concerned that we're asking for trouble downstream somewhere.

(I think this works, consistently, in practice, "by accident," because there is enough synchronization required between when the container instantiates the filter and calls init() in one thread and when the first doFilter() call comes along in a worker thread.  It seems to me that just having a worker thread pick up a request from a shared queue involves synchronization that "covers" this need in that thread.)

Thanks,

Mark Ludwig

Siemens Digital Industries Software
Lifecycle Collaboration
5939 Rice Creek Parkway
Shoreview, MN  55126 United States
Tel.      :+1 (651) 855-6140
Fax      :+1 (651) 855-6280
ludwig.mark at siemens.com <mailto:ludwig.mark at siemens.com>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200415/294f72f8/attachment.htm>

From tim at peierls.net  Wed Apr 15 17:12:50 2020
From: tim at peierls.net (Tim Peierls)
Date: Wed, 15 Apr 2020 17:12:50 -0400
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
Message-ID: <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>

I’d be inclined to trust this line in the Javadoc
<https://github.com/javaee/servlet-spec/blob/d3d0f3ba4dc9256122f01ebdd4be4fae2a586df3/src/main/java/javax/servlet/Filter.java#L58-L60>
:

The init method must complete successfully before the filter is asked to do
any filtering work.

"Complete successfully before" falls short of specifying that there is a
*happens-before* edge between the actions in init() and those in doFilter(),
but it’s hard to imagine an implementation for which that wouldn't be the
case.

—tim


On Wed, Apr 15, 2020 at 4:46 PM Ludwig, Mark via Concurrency-interest <
concurrency-interest at cs.oswego.edu> wrote:

> Greetings,
>
>
>
> I hope this is a suitable topic for this list.
>
>
>
> We are wondering if we need to arrange for some explicit synchronization
> in a Servlet Filter’s doFilter() method to safely refer to an instance
> variable that was set in the init() method.
>
>
>
> We can’t find any mention of this, and without forcing memory fences, are
> concerned that we’re asking for trouble downstream somewhere.
>
>
>
> (I think this works, consistently, in practice, “by accident,” because
> there is enough synchronization required between when the container
> instantiates the filter and calls init() in one thread and when the first
> doFilter() call comes along in a worker thread.  It seems to me that just
> having a worker thread pick up a request from a shared queue involves
> synchronization that “covers” this need in that thread.)
>
>
>
> Thanks,
>
>
>
> Mark Ludwig
>
>
>
> Siemens Digital Industries Software
>
> Lifecycle Collaboration
>
> 5939 Rice Creek Parkway
>
> Shoreview, MN  55126 United States
>
> Tel.      :+1 (651) 855-6140
>
> Fax      :+1 (651) 855-6280
>
> ludwig.mark at siemens.com
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at cs.oswego.edu
> http://cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200415/96c38166/attachment.htm>

From ludwig.mark at siemens.com  Tue Apr 28 07:58:20 2020
From: ludwig.mark at siemens.com (Ludwig, Mark)
Date: Tue, 28 Apr 2020 11:58:20 +0000
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
 <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
Message-ID: <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>

Thank you.  My most-paranoid architect doesn't consider that language a
sufficient guarantee, so we’re going with another pattern I started using about
15 years ago, after I got my head around the final field semantics in Java
[1.]5, for lock-free "steady state" access elsewhere in our product.

I am interested in a little review of this pattern by JLS & JMM experts here.

Below is an example showing the design, in the context of the Filter interface.
Is there a name for this sort of design that uses a race that leads to the
exact, same data through different classes' methods – one synchronized and the
other unsynchronized?  The code below compiles.

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

/**
* Show steady-state lock-free access to data in doFilter
*/

class ShowDataAccess implements Filter
{
   private DataAccessor data = new SynchronizedDataAccessor();

   public void init(final FilterConfig config) throws ServletException
   {
      data.setAll(config);
   }

   public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain chain)
         throws IOException, ServletException
   {
      System.out.println("doFilter config: " + data.getConfig());
   }

   public void destroy()
   {
      data = new SynchronizedDataAccessor();
   }

   private interface DataAccessor
   {
      public void setAll (FilterConfig config);
      public FilterConfig getConfig();
   }

   private class UnsynchronizedDataAccessor implements DataAccessor
   {
      private final FilterConfig config;
      public UnsynchronizedDataAccessor(FilterConfig config)
      {
         this.config = config;
      }
      public void setAll(FilterConfig config)
      {
         throw new UnsupportedOperationException("Logic error");
      }
      public FilterConfig getConfig()
      {
         return config;
      }
   }

   private class SynchronizedDataAccessor implements DataAccessor
   {
      public synchronized void setAll(FilterConfig config)
      {
         data = new UnsynchronizedDataAccessor(config); // Replace reference in parent that led here
      }
      public synchronized FilterConfig getConfig()
      {
         return data.getConfig();
      }
   }
}

Thanks,
Mark

From: Tim Peierls <tim at peierls.net>
Sent: Wednesday, April 15, 2020 4:13 PM
To: Ludwig, Mark (DI SW LCS APPS CG&C) <ludwig.mark at siemens.com>
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Guarantees around Servlet Filter initialization that sets an instance variable?


I’d be inclined to trust this line in the Javadoc<https://github.com/javaee/servlet-spec/blob/d3d0f3ba4dc9256122f01ebdd4be4fae2a586df3/src/main/java/javax/servlet/Filter.java#L58-L60>:

The init method must complete successfully before the filter is asked to do any filtering work.

"Complete successfully before" falls short of specifying that there is a happens-before edge between the actions in init() and those in doFilter(), but it’s hard to imagine an implementation for which that wouldn't be the case.

—tim


On Wed, Apr 15, 2020 at 4:46 PM Ludwig, Mark via Concurrency-interest <concurrency-interest at cs.oswego.edu<mailto:concurrency-interest at cs.oswego.edu>> wrote:
Greetings,

I hope this is a suitable topic for this list.

We are wondering if we need to arrange for some explicit synchronization in a Servlet Filter’s doFilter() method to safely refer to an instance variable that was set in the init() method.

We can’t find any mention of this, and without forcing memory fences, are concerned that we’re asking for trouble downstream somewhere.

(I think this works, consistently, in practice, “by accident,” because there is enough synchronization required between when the container instantiates the filter and calls init() in one thread and when the first doFilter() call comes along in a worker thread.  It seems to me that just having a worker thread pick up a request from a shared queue involves synchronization that “covers” this need in that thread.)

Thanks,

Mark Ludwig

Siemens Digital Industries Software
Lifecycle Collaboration
5939 Rice Creek Parkway
Shoreview, MN  55126 United States
Tel.      :+1 (651) 855-6140
Fax      :+1 (651) 855-6280
ludwig.mark at siemens.com <mailto:ludwig.mark at siemens.com>

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at cs.oswego.edu<mailto:Concurrency-interest at cs.oswego.edu>
http://cs.oswego.edu/mailman/listinfo/concurrency-interest
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://cs.oswego.edu/pipermail/concurrency-interest/attachments/20200428/9d858f89/attachment-0001.htm>

From kasperni at gmail.com  Tue Apr 28 10:20:53 2020
From: kasperni at gmail.com (Kasper Nielsen)
Date: Tue, 28 Apr 2020 15:20:53 +0100
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
 <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>
Message-ID: <CAPs61528G3ZjDcU7+tYBBuAL3b5ZDjxgZLKYGCsyRZN7uKwcvg@mail.gmail.com>

On Tue, 28 Apr 2020 at 13:00, Ludwig, Mark via Concurrency-interest
<concurrency-interest at cs.oswego.edu> wrote:
>
> Thank you.  My most-paranoid architect doesn't consider that language a
>
> sufficient guarantee, so we’re going with another pattern I started using about
>
> 15 years ago, after I got my head around the final field semantics in Java
>
> [1.]5, for lock-free "steady state" access elsewhere in our product.
>
>
>
> I am interested in a little review of this pattern by JLS & JMM experts here.

Hi Mark

I agree with Tim you are wasting your time with this. I can't think of any sane
implementation where you would run into any issue.
The chance of you introducing a bug with a homegrown solution is a lot bigger
than this ever being a problem.

But if you really believe that there might be an issue with memory effects just
declare:

class ShowDataAccess
  volatile field FilterConfig;

and you should be safe.

The code you posted it basically good old double-checked-locking [1] in
disguise. There is no happens-before relationship between
SynchronizedDataAccessor.setAll and subsequent calls to
UnsynchronizedDataAccessor.getConfig. So you have accomplished nothing. Other
than confusing your co-workers.

/Kasper

[1] https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html

From ludwig.mark at siemens.com  Tue Apr 28 11:32:27 2020
From: ludwig.mark at siemens.com (Ludwig, Mark)
Date: Tue, 28 Apr 2020 15:32:27 +0000
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <CAPs61528G3ZjDcU7+tYBBuAL3b5ZDjxgZLKYGCsyRZN7uKwcvg@mail.gmail.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
 <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>
 <CAPs61528G3ZjDcU7+tYBBuAL3b5ZDjxgZLKYGCsyRZN7uKwcvg@mail.gmail.com>
Message-ID: <BC5672F8AD4C054BAF167C9801500D1A0179039496@USSLMMBX004.net.plm.eds.com>

Thank you.  I have a follow-up question....

> From: Kasper Nielsen <kasperni at gmail.com>, Tuesday, April 28, 2020 9:21 AM
> 
> The code you posted it basically good old double-checked-locking [1] in
> disguise. There is no happens-before relationship between
> SynchronizedDataAccessor.setAll and subsequent calls to
> UnsynchronizedDataAccessor.getConfig. So you have accomplished nothing.
> Other
> than confusing your co-workers.

I think you're saying I misunderstand this language (from
https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5):

------------------------------------------------------------
final fields also allow programmers to implement thread-safe
immutable objects without synchronization. A thread-safe
immutable object is seen as immutable by all threads, even
if a data race is used to pass references to the immutable
object between threads. This can provide safety guarantees
against misuse of an immutable class by incorrect or
malicious code. final fields must be used correctly to
provide a guarantee of immutability.

An object is considered to be completely initialized when
its constructor finishes. A thread that can only see a
reference to an object after that object has been completely
initialized is guaranteed to see the correctly initialized
values for that object's final fields.

The usage model for final fields is a simple one: Set the
final fields for an object in that object's constructor; and
do not write a reference to the object being constructed in
a place where another thread can see it before the object's
constructor is finished. If this is followed, then when the
object is seen by another thread, that thread will always
see the correctly constructed version of that object's final
fields. It will also see versions of any object or array
referenced by those final fields that are at least as
up-to-date as the final fields are.
------------------------------------------------------------

At the end of the reference you sent, the following 
seems to support what I'm trying to do:
------------------------------------------------------------
Double-Checked Locking Immutable Objects

If Helper is an immutable object, such that all of the
fields of Helper are final, then double-checked locking will
work without having to use volatile fields. The idea is that
a reference to an immutable object (such as a String or an
Integer) should behave in much the same way as an int or
float; reading and writing references to immutable objects
are atomic.
------------------------------------------------------------

Is the following statement not effectively atomic -- can the
'data' reference point to the not-completely-initialized
UnsynchronizedDataAccessor object?

         data = new UnsynchronizedDataAccessor(config);

I thought the effectively-atomic behavior derives from an
update of a reference always being atomic; the rest from
construction of an object with only final fields being
effectively atomic, which I thought was guaranteed by the
statements in the JLS I referenced above, because the
constructed UnsynchronizedDataAccessor object only has final
fields.

I appreciate being educated/disabused....

Thanks!
Mark

From kasperni at gmail.com  Tue Apr 28 12:02:30 2020
From: kasperni at gmail.com (Kasper Nielsen)
Date: Tue, 28 Apr 2020 17:02:30 +0100
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <BC5672F8AD4C054BAF167C9801500D1A0179039496@USSLMMBX004.net.plm.eds.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
 <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>
 <CAPs61528G3ZjDcU7+tYBBuAL3b5ZDjxgZLKYGCsyRZN7uKwcvg@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A0179039496@USSLMMBX004.net.plm.eds.com>
Message-ID: <CAPs61505-N=gR8oJf-meSDfTPBKRqx825Urz6QqOb1vy-GK2Qg@mail.gmail.com>

Hi Mark,

This is all getting theoretical, as you are unlikely to experience
this in practice.
But you don't know how FilterConfig is implemented. Your logic relies on the
fact the FilterConfig itself can be used racely. Maybe it has non-final fields.
You just don't know.

/Kasper

On Tue, 28 Apr 2020 at 16:33, Ludwig, Mark <ludwig.mark at siemens.com> wrote:
>
> Thank you.  I have a follow-up question....
>
> > From: Kasper Nielsen <kasperni at gmail.com>, Tuesday, April 28, 2020 9:21 AM
> >
> > The code you posted it basically good old double-checked-locking [1] in
> > disguise. There is no happens-before relationship between
> > SynchronizedDataAccessor.setAll and subsequent calls to
> > UnsynchronizedDataAccessor.getConfig. So you have accomplished nothing.
> > Other
> > than confusing your co-workers.
>
> I think you're saying I misunderstand this language (from
> https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.5):
>
> ------------------------------------------------------------
> final fields also allow programmers to implement thread-safe
> immutable objects without synchronization. A thread-safe
> immutable object is seen as immutable by all threads, even
> if a data race is used to pass references to the immutable
> object between threads. This can provide safety guarantees
> against misuse of an immutable class by incorrect or
> malicious code. final fields must be used correctly to
> provide a guarantee of immutability.
>
> An object is considered to be completely initialized when
> its constructor finishes. A thread that can only see a
> reference to an object after that object has been completely
> initialized is guaranteed to see the correctly initialized
> values for that object's final fields.
>
> The usage model for final fields is a simple one: Set the
> final fields for an object in that object's constructor; and
> do not write a reference to the object being constructed in
> a place where another thread can see it before the object's
> constructor is finished. If this is followed, then when the
> object is seen by another thread, that thread will always
> see the correctly constructed version of that object's final
> fields. It will also see versions of any object or array
> referenced by those final fields that are at least as
> up-to-date as the final fields are.
> ------------------------------------------------------------
>
> At the end of the reference you sent, the following
> seems to support what I'm trying to do:
> ------------------------------------------------------------
> Double-Checked Locking Immutable Objects
>
> If Helper is an immutable object, such that all of the
> fields of Helper are final, then double-checked locking will
> work without having to use volatile fields. The idea is that
> a reference to an immutable object (such as a String or an
> Integer) should behave in much the same way as an int or
> float; reading and writing references to immutable objects
> are atomic.
> ------------------------------------------------------------
>
> Is the following statement not effectively atomic -- can the
> 'data' reference point to the not-completely-initialized
> UnsynchronizedDataAccessor object?
>
>          data = new UnsynchronizedDataAccessor(config);
>
> I thought the effectively-atomic behavior derives from an
> update of a reference always being atomic; the rest from
> construction of an object with only final fields being
> effectively atomic, which I thought was guaranteed by the
> statements in the JLS I referenced above, because the
> constructed UnsynchronizedDataAccessor object only has final
> fields.
>
> I appreciate being educated/disabused....
>
> Thanks!
> Mark

From ludwig.mark at siemens.com  Tue Apr 28 20:49:12 2020
From: ludwig.mark at siemens.com (Ludwig, Mark)
Date: Wed, 29 Apr 2020 00:49:12 +0000
Subject: [concurrency-interest] Guarantees around Servlet Filter
 initialization that sets an instance variable?
In-Reply-To: <CAPs61505-N=gR8oJf-meSDfTPBKRqx825Urz6QqOb1vy-GK2Qg@mail.gmail.com>
References: <BC5672F8AD4C054BAF167C9801500D1A0178F6D155@USSLMMBX004.net.plm.eds.com>
 <CA+F8eeR3akO2c4tXs1g1-2ZpOcW7RYzVZg3Dgf0Q091j+2kH9g@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A01790391EB@USSLMMBX004.net.plm.eds.com>
 <CAPs61528G3ZjDcU7+tYBBuAL3b5ZDjxgZLKYGCsyRZN7uKwcvg@mail.gmail.com>
 <BC5672F8AD4C054BAF167C9801500D1A0179039496@USSLMMBX004.net.plm.eds.com>
 <CAPs61505-N=gR8oJf-meSDfTPBKRqx825Urz6QqOb1vy-GK2Qg@mail.gmail.com>
Message-ID: <BC5672F8AD4C054BAF167C9801500D1A01790396AC@USSLMMBX004.net.plm.eds.com>

> From: Kasper Nielsen <kasperni at gmail.com>, Tuesday, April 28, 2020 11:03 AM
> 
> Hi Mark,
> 
> This is all getting theoretical, as you are unlikely to experience
> this in practice.
> But you don't know how FilterConfig is implemented. Your logic relies on the
> fact the FilterConfig itself can be used racely. Maybe it has non-final fields.
> You just don't know.
> 
> /Kasper

Hi Kasper,

Thank you.  Sorry, but in my attempt to present a simple
example, I unintentionally misled by using FilterConfig as
the thing that's being stored and retrieved.  In fact, some
int and boolean values are calculated from the contents of
the FilterConfig, and they are stored and retrieved.  I
didn't want to add yet another object into the example, but
I should have....

I know this is theoretical.  This is a very simple example,
compared to the data actually involved in this pattern.  I
agree that it's overkill, that none of this is necessary,
but faced with an insistent architect, I have a very real
risk with scalability on my customers' big, non-Intel
machines (Solaris on SPARC, AIX on POWER, and HP-UX on
Itanium, to be precise).  Maybe using volatile is okay, but
can anyone tell me how the barrier it imposes will scale on
all these different architectures?

I am only trying to get a "read" on this approach, somewhat
generally -- really, whether there are restrictions on
reordering to prevent the traditional problem with
double-checked locking.

Since you only expressed concerned about something that's
(unfortunately) irrelevant (sorry, again), I believe I have
my answer.  Anyway, I realized there is the statement that
init() completes before any doFilter() calls, so /that/
ensures that the constructor has completed and the object is
fully initialized, before it's possible for doFilter() to
pick up the reference.  It might not be the precise
definition of happens-before that you'd like to see, but
it's good enough for me.

Thanks again,
Mark


