From yechielf at gigaspaces.com  Sun Mar  2 09:19:50 2008
From: yechielf at gigaspaces.com (Yechiel Feffer)
Date: Sun, 2 Mar 2008 16:19:50 +0200
Subject: [concurrency-interest] questions regarding object creation
Message-ID: <3623E06481E65B45866CB3AF32C4FA87D68167@hercules.gspaces.com>

1.	is the "new" operation concurrent ? i.e. assuming the class has
already been introduced to the jvm, is the object creation concurrent to
other objects creation ?
2.	is creation of an object that implements an interface more
expensive than creation of , say the same object  which does not
implement one ?
3.	same goes for inheritance- how extra-costly is it ?

 

 

Thanks,

Yechiel      

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080302/98f5ce82/attachment.html 

From forax at univ-mlv.fr  Sun Mar  2 21:37:04 2008
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Mon, 03 Mar 2008 03:37:04 +0100
Subject: [concurrency-interest] questions regarding object creation
In-Reply-To: <3623E06481E65B45866CB3AF32C4FA87D68167@hercules.gspaces.com>
References: <3623E06481E65B45866CB3AF32C4FA87D68167@hercules.gspaces.com>
Message-ID: <47CB6450.10804@univ-mlv.fr>

Yechiel Feffer a ?crit :
>
>    1. is the "new" operation concurrent ? i.e. assuming the class has
>       already been introduced to the jvm, is the object creation
>       concurrent to other objects creation ?
>
Yes, because GCs are copying-collectors, new is performed using a CAS .
Moreover, some VMs use  a heap by thread.
see http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html 
(search TLAB).
>
>   1.
>
>
>    2. is creation of an object that implements an interface more
>       expensive than creation of , say the same object  which does not
>       implement one ?
>
no.
>
>   1.
>
>
>    2. same goes for inheritance- how extra-costly is it ?
>
no.
see http://en.wikipedia.org/wiki/Virtual_table
>
>   1.
>
>
>  
>
>  
>
> Thanks,
>
> Yechiel     
>
cheers,
R?mi

From dhanji at gmail.com  Wed Mar  5 19:09:02 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 6 Mar 2008 11:09:02 +1100
Subject: [concurrency-interest] atomicity and volatile
Message-ID: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>

Hi I have a volatile field being incremented by multiple threads:
public class MyCounter {
    private volatile int count;

    public void increment() {
         count++
    }

}

Am I correct in assuming that multiple threads could clobber each others
increments since count++ is not an atomic operation relative to all threads
calling increment? Even though the value of count is coherent between
threads when it is read...

So for instance:

thread A enters increment(), reads count as 0
MEANWHILE thread B enters increment(), also reads 0 in count (since thread A
has not yet set count to 1) and writes 1 to count.
thread A overwrites the value in count (which is already 1) with 1.

Therefore thread A clobbers thread B's increment work. Does that make sense?

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/876f0822/attachment.html 

From pugh at cs.umd.edu  Wed Mar  5 19:14:16 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Wed, 5 Mar 2008 19:14:16 -0500
Subject: [concurrency-interest] atomicity and volatile
In-Reply-To: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
References: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
Message-ID: <6862C125-E4A6-4588-92E4-A6893B86CA71@cs.umd.edu>

Yep.

Don't do that.

Use AtomicInteger instead. Or use some form of locking/synchronization.

Bill Pugh

On Mar 5, 2008, at 7:09 PM, Dhanji R. Prasanna wrote:

> Hi I have a volatile field being incremented by multiple threads:
>
> public class MyCounter {
>     private volatile int count;
>
>     public void increment() {
>          count++
>     }
>
> }
>
> Am I correct in assuming that multiple threads could clobber each  
> others increments since count++ is not an atomic operation relative  
> to all threads calling increment? Even though the value of count is  
> coherent between threads when it is read...
>
> So for instance:
>
> thread A enters increment(), reads count as 0
> MEANWHILE thread B enters increment(), also reads 0 in count (since  
> thread A has not yet set count to 1) and writes 1 to count.
> thread A overwrites the value in count (which is already 1) with 1.
>
> Therefore thread A clobbers thread B's increment work. Does that  
> make sense?
>
> Dhanji.
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dhanji at gmail.com  Wed Mar  5 19:15:47 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 6 Mar 2008 11:15:47 +1100
Subject: [concurrency-interest] atomicity and volatile
In-Reply-To: <6862C125-E4A6-4588-92E4-A6893B86CA71@cs.umd.edu>
References: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
	<6862C125-E4A6-4588-92E4-A6893B86CA71@cs.umd.edu>
Message-ID: <aa067ea10803051615j5d9cc2c5s4d429b87bc156bf8@mail.gmail.com>

On Thu, Mar 6, 2008 at 11:14 AM, Bill Pugh <pugh at cs.umd.edu> wrote:

> Yep.
>
> Don't do that.
>
> Use AtomicInteger instead. Or use some form of locking/synchronization.


Gotcha, am writing about it so wanted a sanity check =)
Thanks!

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/72a74626/attachment.html 

From tim at peierls.net  Wed Mar  5 19:18:27 2008
From: tim at peierls.net (Tim Peierls)
Date: Wed, 5 Mar 2008 19:18:27 -0500
Subject: [concurrency-interest] atomicity and volatile
In-Reply-To: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
References: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
Message-ID: <63b4e4050803051618y40aa1971v22f32b30eef66c63@mail.gmail.com>

Yes, you're correct.

On Wed, Mar 5, 2008 at 7:09 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

> Hi I have a volatile field being incremented by multiple threads:
> public class MyCounter {
>     private volatile int count;
>
>     public void increment() {
>          count++
>     }
>
> }
>
> Am I correct in assuming that multiple threads could clobber each others
> increments since count++ is not an atomic operation relative to all threads
> calling increment? Even though the value of count is coherent between
> threads when it is read...
>
> So for instance:
>
> thread A enters increment(), reads count as 0
> MEANWHILE thread B enters increment(), also reads 0 in count (since thread
> A has not yet set count to 1) and writes 1 to count.
> thread A overwrites the value in count (which is already 1) with 1.
>
> Therefore thread A clobbers thread B's increment work. Does that make
> sense?
>
> Dhanji.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080305/81bf64d4/attachment.html 

From crazybob at crazybob.org  Wed Mar  5 19:18:49 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Wed, 5 Mar 2008 16:18:49 -0800
Subject: [concurrency-interest] atomicity and volatile
In-Reply-To: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
References: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>
Message-ID: <a74683f90803051618t692ede2as2ada99414eb2a668@mail.gmail.com>

On Wed, Mar 5, 2008 at 4:09 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

> Am I correct in assuming that multiple threads could clobber each others
> increments since count++ is not an atomic operation relative to all threads
> calling increment?
>

You care correct--volatile here is not atomic. If you want the operation to
be atomic, you could use AtomicInteger.incrementAndGet().

Bob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080305/b328c089/attachment.html 

From jason.greene at redhat.com  Wed Mar  5 20:20:09 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 05 Mar 2008 19:20:09 -0600
Subject: [concurrency-interest] atomicity and volatile
In-Reply-To: <aa067ea10803051615j5d9cc2c5s4d429b87bc156bf8@mail.gmail.com>
References: <aa067ea10803051609y47dcbfb1va823fc292b322687@mail.gmail.com>	<6862C125-E4A6-4588-92E4-A6893B86CA71@cs.umd.edu>
	<aa067ea10803051615j5d9cc2c5s4d429b87bc156bf8@mail.gmail.com>
Message-ID: <47CF46C9.9040603@redhat.com>

Dhanji R. Prasanna wrote:
> 
> 
> On Thu, Mar 6, 2008 at 11:14 AM, Bill Pugh <pugh at cs.umd.edu 
> <mailto:pugh at cs.umd.edu>> wrote:
> 
>     Yep.
> 
>     Don't do that.
> 
>     Use AtomicInteger instead. Or use some form of locking/synchronization.
> 
>  
> Gotcha, am writing about it so wanted a sanity check =)
> Thanks!

I recommend getting a copy of JCIP[1].

[1] http://www.javaconcurrencyinpractice.com/

-- 
Jason T. Greene
JBoss, a division of Red Hat

From dhanji at gmail.com  Wed Mar  5 21:30:59 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 6 Mar 2008 13:30:59 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe publication
	question
Message-ID: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>

Hello again,

This question has been bugging me for a *long* time. Nobody (and no docs)
seem to adequately address this problem for me.
Spring's DispatcherServlet:
http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
...has several non-volatile, non-final fields for various pluggable services
(ThemeResolver, ViewResolver, etc.). These are set by equally various
private unsynchronized methods which cascade down from HttpServlet.init(),
itself also unsynchronized.

The problem I have is that this seems like it could lead to incoherent
values between the startup thread's view of DispatcherServlet and any
subsequent request threads. Since there is no lock or synchronization, I
cannot find a guarantee that request threads will see the value set in the
init thread (even though they are chronologically sequenced ok). All these
fields are also non-volatile. It looks like a classic unsafe publication
problem to me.

Worse, there are no default values, so request threads could end up biting
NPEs.

This seems like a gross flaw in code that's deployed virtually everywhere.
Why isn't there more clamor about this? Or am I just totally nuts (I *hope*
so)?
I know Tim has talked for a long time about (lack of) safe publication
guarantees in the Spring injector itself... but I could not find any
concrete examples.

@Jason: Yes I have JCiP, though it was hell finding it in Australian book
stores--thanks for the reck! =)

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/2da5f8d2/attachment.html 

From jason.greene at redhat.com  Wed Mar  5 22:43:34 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Wed, 05 Mar 2008 21:43:34 -0600
Subject: [concurrency-interest] Spring DispatcherServlet safe
 publication question
In-Reply-To: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
Message-ID: <47CF6866.204@redhat.com>

Hi Dhanji,

This is OK, since the servlet spec guarantees that init() is called only 
once, and before any requests are serviced.

Dhanji R. Prasanna wrote:
> Hello again,
> 
> This question has been bugging me for a *long* time. Nobody (and no 
> docs) seem to adequately address this problem for me.
> 
> Spring's 
> DispatcherServlet: http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
> ...has several non-volatile, non-final fields for various pluggable 
> services (ThemeResolver, ViewResolver, etc.). These are set by equally 
> various private unsynchronized methods which cascade down from 
> HttpServlet.init(), itself also unsynchronized.
> 
> The problem I have is that this seems like it could lead to incoherent 
> values between the startup thread's view of DispatcherServlet and any 
> subsequent request threads. Since there is no lock or synchronization, I 
> cannot find a guarantee that request threads will see the value set in 
> the init thread (even though they are chronologically sequenced ok). All 
> these fields are also non-volatile. It looks like a classic unsafe 
> publication problem to me.
> 
> Worse, there are no default values, so request threads could end up 
> biting NPEs.
> 
> This seems like a gross flaw in code that's deployed virtually 
> everywhere. Why isn't there more clamor about this? Or am I just totally 
> nuts (I *hope* so)?
> I know Tim has talked for a long time about (lack of) safe publication 
> guarantees in the Spring injector itself... but I could not find any 
> concrete examples.
> 
> @Jason: Yes I have JCiP, though it was hell finding it in Australian 
> book stores--thanks for the reck! =)
> 
> Dhanji.
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


-- 
Jason T. Greene
JBoss, a division of Red Hat

From dhanji at gmail.com  Thu Mar  6 02:45:02 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 6 Mar 2008 18:45:02 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <47CF6866.204@redhat.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<47CF6866.204@redhat.com>
Message-ID: <aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>

Jason:
But the fields are not volatile, is there a guarantee that subsequent
request threads will see the value set by init()?
Dhanji.

On Thu, Mar 6, 2008 at 2:43 PM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> Hi Dhanji,
>
> This is OK, since the servlet spec guarantees that init() is called only
> once, and before any requests are serviced.
>
> Dhanji R. Prasanna wrote:
> > Hello again,
> >
> > This question has been bugging me for a *long* time. Nobody (and no
> > docs) seem to adequately address this problem for me.
> >
> > Spring's
> > DispatcherServlet:
> http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
> > ...has several non-volatile, non-final fields for various pluggable
> > services (ThemeResolver, ViewResolver, etc.). These are set by equally
> > various private unsynchronized methods which cascade down from
> > HttpServlet.init(), itself also unsynchronized.
> >
> > The problem I have is that this seems like it could lead to incoherent
> > values between the startup thread's view of DispatcherServlet and any
> > subsequent request threads. Since there is no lock or synchronization, I
> > cannot find a guarantee that request threads will see the value set in
> > the init thread (even though they are chronologically sequenced ok). All
> > these fields are also non-volatile. It looks like a classic unsafe
> > publication problem to me.
> >
> > Worse, there are no default values, so request threads could end up
> > biting NPEs.
> >
> > This seems like a gross flaw in code that's deployed virtually
> > everywhere. Why isn't there more clamor about this? Or am I just totally
> > nuts (I *hope* so)?
> > I know Tim has talked for a long time about (lack of) safe publication
> > guarantees in the Spring injector itself... but I could not find any
> > concrete examples.
> >
> > @Jason: Yes I have JCiP, though it was hell finding it in Australian
> > book stores--thanks for the reck! =)
> >
> > Dhanji.
> >
> >
> > ------------------------------------------------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> --
> Jason T. Greene
> JBoss, a division of Red Hat
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/c84a24aa/attachment.html 

From dhanji at gmail.com  Thu Mar  6 02:58:08 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Thu, 6 Mar 2008 18:58:08 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<47CF6866.204@redhat.com>
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>
Message-ID: <aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>

Or is it because the servlet container's startup thread locks (presumably)
when going thru init?
Dhanji.

On Thu, Mar 6, 2008 at 6:45 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

> Jason:
> But the fields are not volatile, is there a guarantee that subsequent
> request threads will see the value set by init()?
> Dhanji.
>
>
> On Thu, Mar 6, 2008 at 2:43 PM, Jason T. Greene <jason.greene at redhat.com>
> wrote:
>
> > Hi Dhanji,
> >
> > This is OK, since the servlet spec guarantees that init() is called only
> > once, and before any requests are serviced.
> >
> > Dhanji R. Prasanna wrote:
> > > Hello again,
> > >
> > > This question has been bugging me for a *long* time. Nobody (and no
> > > docs) seem to adequately address this problem for me.
> > >
> > > Spring's
> > > DispatcherServlet:
> > http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
> > > ...has several non-volatile, non-final fields for various pluggable
> > > services (ThemeResolver, ViewResolver, etc.). These are set by equally
> > > various private unsynchronized methods which cascade down from
> > > HttpServlet.init(), itself also unsynchronized.
> > >
> > > The problem I have is that this seems like it could lead to incoherent
> > > values between the startup thread's view of DispatcherServlet and any
> > > subsequent request threads. Since there is no lock or synchronization,
> > I
> > > cannot find a guarantee that request threads will see the value set in
> > > the init thread (even though they are chronologically sequenced ok).
> > All
> > > these fields are also non-volatile. It looks like a classic unsafe
> > > publication problem to me.
> > >
> > > Worse, there are no default values, so request threads could end up
> > > biting NPEs.
> > >
> > > This seems like a gross flaw in code that's deployed virtually
> > > everywhere. Why isn't there more clamor about this? Or am I just
> > totally
> > > nuts (I *hope* so)?
> > > I know Tim has talked for a long time about (lack of) safe publication
> > > guarantees in the Spring injector itself... but I could not find any
> > > concrete examples.
> > >
> > > @Jason: Yes I have JCiP, though it was hell finding it in Australian
> > > book stores--thanks for the reck! =)
> > >
> > > Dhanji.
> > >
> > >
> > >
> > ------------------------------------------------------------------------
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> > --
> > Jason T. Greene
> > JBoss, a division of Red Hat
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/1b73d657/attachment.html 

From tim at peierls.net  Thu Mar  6 07:41:42 2008
From: tim at peierls.net (Tim Peierls)
Date: Thu, 6 Mar 2008 07:41:42 -0500
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<47CF6866.204@redhat.com>
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>
	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>
Message-ID: <63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>

On Thu, Mar 6, 2008 at 2:58 AM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

> Or is it because the servlet container's startup thread locks (presumably)
> when going thru init?


That wouldn't be enough, there would have to be a matching lock around every
service call.

Last time I looked, the Servlet spec stopped short of saying that there is a
happens-before edge between init() and service(). (The word "before" without
the "happens-" prefix doesn't count.) It's possible that this has been
tightened up, but my own habit is to be extra cautious, and to synchronize
access to (or make volatile) all non-final fields of a servlet.

As JCiP 4.5.1 points out, however, sometimes you have to assume, when
dealing with ambiguous documentation, that a framework is doing the right
thing, because it makes no sense for it to do otherwise. And gazillions of
happy Spring users haven't complained yet. :-)

--tim


On Thu, Mar 6, 2008 at 6:45 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:
>
> > Jason:
> > But the fields are not volatile, is there a guarantee that subsequent
> > request threads will see the value set by init()?
> > Dhanji.
> >
> >
> > On Thu, Mar 6, 2008 at 2:43 PM, Jason T. Greene <jason.greene at redhat.com>
> > wrote:
> >
> > > Hi Dhanji,
> > >
> > > This is OK, since the servlet spec guarantees that init() is called
> > > only
> > > once, and before any requests are serviced.
> > >
> > > Dhanji R. Prasanna wrote:
> > > > Hello again,
> > > >
> > > > This question has been bugging me for a *long* time. Nobody (and no
> > > > docs) seem to adequately address this problem for me.
> > > >
> > > > Spring's
> > > > DispatcherServlet:
> > > http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
> > > > ...has several non-volatile, non-final fields for various pluggable
> > > > services (ThemeResolver, ViewResolver, etc.). These are set by
> > > equally
> > > > various private unsynchronized methods which cascade down from
> > > > HttpServlet.init(), itself also unsynchronized.
> > > >
> > > > The problem I have is that this seems like it could lead to
> > > incoherent
> > > > values between the startup thread's view of DispatcherServlet and
> > > any
> > > > subsequent request threads. Since there is no lock or
> > > synchronization, I
> > > > cannot find a guarantee that request threads will see the value set
> > > in
> > > > the init thread (even though they are chronologically sequenced ok).
> > > All
> > > > these fields are also non-volatile. It looks like a classic unsafe
> > > > publication problem to me.
> > > >
> > > > Worse, there are no default values, so request threads could end up
> > > > biting NPEs.
> > > >
> > > > This seems like a gross flaw in code that's deployed virtually
> > > > everywhere. Why isn't there more clamor about this? Or am I just
> > > totally
> > > > nuts (I *hope* so)?
> > > > I know Tim has talked for a long time about (lack of) safe
> > > publication
> > > > guarantees in the Spring injector itself... but I could not find any
> > > > concrete examples.
> > > >
> > > > @Jason: Yes I have JCiP, though it was hell finding it in Australian
> > > > book stores--thanks for the reck! =)
> > > >
> > > > Dhanji.
> > > >
> > > >
> > > >
> > > ------------------------------------------------------------------------
> > > >
> > > > _______________________________________________
> > > > Concurrency-interest mailing list
> > > > Concurrency-interest at altair.cs.oswego.edu
> > > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > > --
> > > Jason T. Greene
> > > JBoss, a division of Red Hat
> > >
> >
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/b53b6568/attachment.html 

From jason.greene at redhat.com  Thu Mar  6 10:43:51 2008
From: jason.greene at redhat.com (Jason T. Greene)
Date: Thu, 06 Mar 2008 09:43:51 -0600
Subject: [concurrency-interest] Spring DispatcherServlet safe
 publication question
In-Reply-To: <63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>	
	<47CF6866.204@redhat.com>	
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>	
	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>
	<63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>
Message-ID: <47D01137.7040307@redhat.com>

Tim Peierls wrote:
> On Thu, Mar 6, 2008 at 2:58 AM, Dhanji R. Prasanna <dhanji at gmail.com 
> <mailto:dhanji at gmail.com>> wrote:
> 
>     Or is it because the servlet container's startup thread locks
>     (presumably) when going thru init?
> 
> 
> That wouldn't be enough, there would have to be a matching lock around 
> every service call.

Not true. As long as the instance fields are not yet visible (published) 
to other threads, and they are never written to afterwards they are 
effectively immutable.

> Last time I looked, the Servlet spec stopped short of saying that there 
> is a happens-before edge between init() and service(). (The word 
> "before" without the "happens-" prefix doesn't count.) It's possible 
> that this has been tightened up, but my own habit is to be extra 
> cautious, and to synchronize access to (or make volatile) all non-final 
> fields of a servlet.

Since the spec requires init() to be ran only once and complete before 
any service method is called, and since instance fields are only ever 
accessed by service methods, they can be effectively immutable. I do 
agree the spec should make this more clear. I will email the servlet EG 
about that.

> As JCiP 4.5.1 points out, however, sometimes you have to assume, when 
> dealing with ambiguous documentation, that a framework is doing the 
> right thing, because it makes no sense for it to do otherwise. And 
> gazillions of happy Spring users haven't complained yet. :-)

It's funny that you bring this up, because I took a look at the tomcat 
source, and sadly they are using DCL to meet the init() requirements 
(will file a bug on this) :(

if (instance == null) {
   synchronized (this) {
     if (instance == null) {
       try {
         instance = loadServlet();
       } catch (ServletException e) {
         throw e;
       } catch (Throwable e) {
         throw new ServletException(..., e);
       }
     }
   }
}

So, your suggestion of guarding against broken containers with a 
volatile isn't so bad.

-- 
Jason T. Greene
JBoss, a division of Red Hat

From tim at peierls.net  Thu Mar  6 11:00:03 2008
From: tim at peierls.net (Tim Peierls)
Date: Thu, 6 Mar 2008 11:00:03 -0500
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <47D01137.7040307@redhat.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<47CF6866.204@redhat.com>
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>
	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>
	<63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>
	<47D01137.7040307@redhat.com>
Message-ID: <63b4e4050803060800w229514fqfd9f7bb2df107c79@mail.gmail.com>

On Thu, Mar 6, 2008 at 10:43 AM, Jason T. Greene <jason.greene at redhat.com>
wrote:

> Tim Peierls wrote:
> > On Thu, Mar 6, 2008 at 2:58 AM, Dhanji R. Prasanna <dhanji at gmail.com
> > <mailto:dhanji at gmail.com>> wrote:
> >
> >     Or is it because the servlet container's startup thread locks
> (presumably) when going thru init?
> >
> >
> > That wouldn't be enough, there would have to be a matching lock around
> every service call.
>
> Not true. As long as the instance fields are not yet visible (published)
> to other threads, and they are never written to afterwards they are
> effectively immutable.


Circular reasoning: You can't guarantee that those writes aren't yet visible
to other reading threads unless there is a *happens-before* relationship
between init() and service(), and the spec isn't clear about that. I
understand the intent, but ... horseshoes and hand-grenades.


Since the spec requires init() to be ran only once and complete before any
> service method is called,


There's that pesky "before" again. If only the spec used *happens-before* or
something equivalent to it.



> and since instance fields are only ever
> accessed by service methods, they can be effectively immutable. I do
> agree the spec should make this more clear. I will email the servlet EG
> about that.


Thanks!



> > As JCiP 4.5.1 points out, however, sometimes you have to assume, when
> > dealing with ambiguous documentation, that a framework is doing the
> > right thing, because it makes no sense for it to do otherwise. And
> > gazillions of happy Spring users haven't complained yet. :-)
>
> It's funny that you bring this up, because I took a look at the tomcat
> source, and sadly they are using DCL to meet the init() requirements
> (will file a bug on this) :(
>
> if (instance == null) {
>   synchronized (this) {
>     if (instance == null) {
>       try {
>         instance = loadServlet();
>       } catch (ServletException e) {
>         throw e;
>       } catch (Throwable e) {
>         throw new ServletException(..., e);
>       }
>     }
>   }
> }
>
> So, your suggestion of guarding against broken containers with a volatile
> isn't so bad.
>

Thanks, again! :-)

--tim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080306/8db5d561/attachment.html 

From pavitar at pramati.com  Fri Mar  7 04:04:00 2008
From: pavitar at pramati.com (Pavitar Singh)
Date: Fri, 7 Mar 2008 14:34:00 +0530 (IST)
Subject: [concurrency-interest] Significance of volatile for Objects
Message-ID: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>

Hi,

If i have something like this:

volatile Map data = new HashMap();

then what are the gurantees provided by volatile.

I know this is wrong usage of volatile. But i just wanted to know
gurantees provided by volatile in case of Objects.

Regards
Pavitar

From dcholmes at optusnet.com.au  Fri Mar  7 04:58:28 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Fri, 7 Mar 2008 19:58:28 +1000
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCKENEHKAA.dcholmes@optusnet.com.au>

It isn't a wrong usage per-se - you've just declared that a field of
reference type is volatile. This is no different to any other field type -
the meaning of volatile doesn't change.

The guarantees you get are as usual: a write to a volatile happens-before a
subsequent read of that written value. What that means for your program
depends on how the program reads/writes the volatile.

One idiom is to use the field as a "memory barrier" by doing:

data = data; // volatile read and write

to induce a happens-before ordering between code blocks. If I recall
correctly the Guava language (a variant of Java that disallows data races)
used this idiom.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Pavitar
> Singh
> Sent: Friday, 7 March 2008 7:04 PM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] Significance of volatile for Objects
>
>
> Hi,
>
> If i have something like this:
>
> volatile Map data = new HashMap();
>
> then what are the gurantees provided by volatile.
>
> I know this is wrong usage of volatile. But i just wanted to know
> gurantees provided by volatile in case of Objects.
>
> Regards
> Pavitar
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From alarmnummer at gmail.com  Fri Mar  7 05:01:06 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Fri, 7 Mar 2008 11:01:06 +0100
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
Message-ID: <1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>

Volatile helps to prevent 2 issues:

reorderings
visibility.

Reordering:
it prevents that the created hashmap is assigned to the data variable,
before the constructor has run. So it prevents other threads from
seeing a partly constructed hashmap.

Visibility:
It makes sure that thread that reads data, sees the most recently
written value of data. It also makes sure that the reading thread sees
all values written (e.g. the member variables of the hashmap) before
the writing thread did the write to data. This last behavior is
available since Java 1.5 (JMM 133). It is a technique that can be used
to 'transfer' objects from one thread to another in a thread safe
manner. A BlockingQueue for example support this behavior.

For more information I suggest "Java Concurrency in Practice"

PS:
I know you made the remark, but for other less experienced developers
reading this thread.. the example is not threadsafe because HashMap is
not threadsafe. So its internal structure could be corrupted by
concurrent access.

On Fri, Mar 7, 2008 at 10:04 AM, Pavitar Singh <pavitar at pramati.com> wrote:
> Hi,
>
>  If i have something like this:
>
>  volatile Map data = new HashMap();
>
>  then what are the gurantees provided by volatile.
>
>  I know this is wrong usage of volatile. But i just wanted to know
>  gurantees provided by volatile in case of Objects.
>
>  Regards
>  Pavitar
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From mthornton at optrak.co.uk  Fri Mar  7 05:23:35 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Fri, 07 Mar 2008 10:23:35 +0000
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
	<1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
Message-ID: <47D117A7.9070404@optrak.co.uk>

Peter Veentjer wrote:
> PS:
> I know you made the remark, but for other less experienced developers
> reading this thread.. the example is not threadsafe because HashMap is
> not threadsafe. So its internal structure could be corrupted by
> concurrent access.
>
>   
I think it would be safe provided no writes to the HashMap happen after 
the volatile assignment, and that it was safely created prior to that 
point. There are Map's which aren't threadsafe even for reading, but as 
far as I know HashMap is not one of them.

Mark Thornton


From alarmnummer at gmail.com  Fri Mar  7 05:51:46 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Fri, 7 Mar 2008 11:51:46 +0100
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <47D117A7.9070404@optrak.co.uk>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
	<1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
	<47D117A7.9070404@optrak.co.uk>
Message-ID: <1466c1d60803070251m64df4140ob2f877f31248a48c@mail.gmail.com>

Under the condition that no writes are made after the initialization,
you are completely right.

On Fri, Mar 7, 2008 at 11:23 AM, Mark Thornton <mthornton at optrak.co.uk> wrote:
> Peter Veentjer wrote:
>  > PS:
>  > I know you made the remark, but for other less experienced developers
>  > reading this thread.. the example is not threadsafe because HashMap is
>  > not threadsafe. So its internal structure could be corrupted by
>  > concurrent access.
>  >
>  >
>  I think it would be safe provided no writes to the HashMap happen after
>  the volatile assignment, and that it was safely created prior to that
>  point. There are Map's which aren't threadsafe even for reading, but as
>  far as I know HashMap is not one of them.
>
>  Mark Thornton
>
>
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From pavitar at pramati.com  Fri Mar  7 06:19:43 2008
From: pavitar at pramati.com (Pavitar Singh)
Date: Fri, 7 Mar 2008 16:49:43 +0530 (IST)
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
	<1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
Message-ID: <1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>

Hi,

Thanks for your explanations.

When i read JMM about Happens Before Relationships:

It says:

A write to a volatile field happens before every subsequent read of that
volatile.

But then doing operation on HashMap like put. It doesnt mean write to the
volatile field.Siimilarly a get shouldnt mean read from volatile.Is it
correct or i am missing something here.


Regards
Pavitar


> Volatile helps to prevent 2 issues:
>
> reorderings
> visibility.
>
> Reordering:
> it prevents that the created hashmap is assigned to the data variable,
> before the constructor has run. So it prevents other threads from
> seeing a partly constructed hashmap.
>
> Visibility:
> It makes sure that thread that reads data, sees the most recently
> written value of data. It also makes sure that the reading thread sees
> all values written (e.g. the member variables of the hashmap) before
> the writing thread did the write to data. This last behavior is
> available since Java 1.5 (JMM 133). It is a technique that can be used
> to 'transfer' objects from one thread to another in a thread safe
> manner. A BlockingQueue for example support this behavior.
>
> For more information I suggest "Java Concurrency in Practice"
>
> PS:
> I know you made the remark, but for other less experienced developers
> reading this thread.. the example is not threadsafe because HashMap is
> not threadsafe. So its internal structure could be corrupted by
> concurrent access.
>
> On Fri, Mar 7, 2008 at 10:04 AM, Pavitar Singh <pavitar at pramati.com>
> wrote:
>> Hi,
>>
>>  If i have something like this:
>>
>>  volatile Map data = new HashMap();
>>
>>  then what are the gurantees provided by volatile.
>>
>>  I know this is wrong usage of volatile. But i just wanted to know
>>  gurantees provided by volatile in case of Objects.
>>
>>  Regards
>>  Pavitar
>>  _______________________________________________
>>  Concurrency-interest mailing list
>>  Concurrency-interest at altair.cs.oswego.edu
>>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>>
>


From dhanji at gmail.com  Fri Mar  7 07:18:49 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Fri, 7 Mar 2008 23:18:49 +1100
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
	<1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
	<1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>
Message-ID: <aa067ea10803070418u184cb53ej239c5c72f253d619@mail.gmail.com>

On Fri, Mar 7, 2008 at 10:19 PM, Pavitar Singh <pavitar at pramati.com> wrote:

> Hi,
>
> Thanks for your explanations.
>
> When i read JMM about Happens Before Relationships:
>
> It says:
>
> A write to a volatile field happens before every subsequent read of that
> volatile.
>
> But then doing operation on HashMap like put. It doesnt mean write to the
> volatile field.Siimilarly a get shouldnt mean read from volatile.Is it
> correct or i am missing something here.


Correct, the volatile field holds a reference to a hashmap, but reads and
writes to the hashmap itself are subject to its own synchronization
concerns. Hence, synchronized and ConcurrentHashMap.

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080307/fa21043d/attachment.html 

From alarmnummer at gmail.com  Fri Mar  7 07:47:35 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Fri, 7 Mar 2008 13:47:35 +0100
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com>
	<1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com>
	<1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>
Message-ID: <1466c1d60803070447l12b60bd6v16c88246995b31db@mail.gmail.com>

>  But then doing operation on HashMap like put. It doesnt mean write to the
>  volatile field.Siimilarly a get shouldnt mean read from volatile.

That is correct. If one thread does a put (so a write inside the
internals of the hashmap) and another thread does a get (so a read
from the internals of the hashmap) there could be visibility problems
because there is no happens before relation between the put and the
get (there is no happens before relation between 2 reads of the same
volatile variable).

So:
-changes made to the internal structure of the hashmap done by the
write, don't have to be visiblity when you do a get.
-objects placed in the put can't be safely passed from one thread to
another because of the lack of the happens before relation.

So if you are lucky enough to have missed the 'classic' concurrency
problems with this hashmap, there are still JMM problems.



Is it
>  correct or i am missing something here.
>
>
>  Regards
>  Pavitar
>
>
>
>
>  > Volatile helps to prevent 2 issues:
>  >
>  > reorderings
>  > visibility.
>  >
>  > Reordering:
>  > it prevents that the created hashmap is assigned to the data variable,
>  > before the constructor has run. So it prevents other threads from
>  > seeing a partly constructed hashmap.
>  >
>  > Visibility:
>  > It makes sure that thread that reads data, sees the most recently
>  > written value of data. It also makes sure that the reading thread sees
>  > all values written (e.g. the member variables of the hashmap) before
>  > the writing thread did the write to data. This last behavior is
>  > available since Java 1.5 (JMM 133). It is a technique that can be used
>  > to 'transfer' objects from one thread to another in a thread safe
>  > manner. A BlockingQueue for example support this behavior.
>  >
>  > For more information I suggest "Java Concurrency in Practice"
>  >
>  > PS:
>  > I know you made the remark, but for other less experienced developers
>  > reading this thread.. the example is not threadsafe because HashMap is
>  > not threadsafe. So its internal structure could be corrupted by
>  > concurrent access.
>  >
>  > On Fri, Mar 7, 2008 at 10:04 AM, Pavitar Singh <pavitar at pramati.com>
>  > wrote:
>  >> Hi,
>  >>
>  >>  If i have something like this:
>  >>
>  >>  volatile Map data = new HashMap();
>  >>
>  >>  then what are the gurantees provided by volatile.
>  >>
>  >>  I know this is wrong usage of volatile. But i just wanted to know
>  >>  gurantees provided by volatile in case of Objects.
>  >>
>  >>  Regards
>  >>  Pavitar
>  >>  _______________________________________________
>  >>  Concurrency-interest mailing list
>  >>  Concurrency-interest at altair.cs.oswego.edu
>  >>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >>
>  >
>
>

From rune at philosof.dk  Fri Mar  7 09:19:20 2008
From: rune at philosof.dk (Rune Schjellerup Philosof)
Date: Fri, 07 Mar 2008 15:19:20 +0100
Subject: [concurrency-interest] ParallelArray classcastexception.
Message-ID: <47D14EE8.5080406@philosof.dk>

Hello all

How come this throws Exception in thread "Thread-5" 
java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [[F

        Scan[] scans;
        ForkJoinPool fjp = new ForkJoinPool();
        ParallelArray<Scan> scanarray = 
ParallelArray.createFromCopy(scans, fjp);
        ParallelArray<float[]> tmp = scanarray.withMapping(new 
Ops.Op<Scan, float[]>() {
            @Override
            public float[] op(Scan scan) {
                float[][] raw = scan.getSpectrum();
                return Spectrum.Resample(raw, _mzRange, 
_resamplingFrequency);
            }
        }).all();
        float[][] resampledSpectra = tmp.getArray();   <--- exception

where:
float[] org.fhcrc.cpl.viewer.feature.Spectrum.Resample(float[][] 
spectrum, FloatRange r, int resolution);

and scans contain an actual array and the resample method normally works.

--
Regards
Rune

From jnguyen at automotive.com  Fri Mar  7 12:15:05 2008
From: jnguyen at automotive.com (Joe Nguyen)
Date: Fri, 7 Mar 2008 09:15:05 -0800
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <1466c1d60803070447l12b60bd6v16c88246995b31db@mail.gmail.com>
References: <59877.61.17.46.85.1204880640.squirrel@mail.pramati.com><1466c1d60803070201r18622d67we9d4643bae1d597b@mail.gmail.com><1364.192.168.2.107.1204888783.squirrel@mail.pramati.com>
	<1466c1d60803070447l12b60bd6v16c88246995b31db@mail.gmail.com>
Message-ID: <A7487BEC58632D46B8C7E8BC69B3EB1206534A0A@mail-001.corp.automotive.com>

Therefore, volatile in this case doesn't guarantee the visibility then
(even in java 1.5)?

"Visibility:
It makes sure that thread that reads data, sees the most recently
written value of data. It also makes sure that the reading thread sees
all values written (e.g. the member variables of the hashmap) before the
writing thread did the write to data. This last behavior is available
since Java 1.5 (JMM 133). It is a technique that can be used to
'transfer' objects from one thread to another in a thread safe manner. A
BlockingQueue for example support this behavior."

-----Original Message-----
From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Peter
Veentjer
Sent: Friday, March 07, 2008 4:48 AM
To: pavitar at pramati.com
Cc: concurrency-interest at cs.oswego.edu
Subject: Re: [concurrency-interest] Significance of volatile for Objects

>  But then doing operation on HashMap like put. It doesnt mean write to
the
>  volatile field.Siimilarly a get shouldnt mean read from volatile.

That is correct. If one thread does a put (so a write inside the
internals of the hashmap) and another thread does a get (so a read
from the internals of the hashmap) there could be visibility problems
because there is no happens before relation between the put and the
get (there is no happens before relation between 2 reads of the same
volatile variable).

So:
-changes made to the internal structure of the hashmap done by the
write, don't have to be visiblity when you do a get.
-objects placed in the put can't be safely passed from one thread to
another because of the lack of the happens before relation.

So if you are lucky enough to have missed the 'classic' concurrency
problems with this hashmap, there are still JMM problems.



Is it
>  correct or i am missing something here.
>
>
>  Regards
>  Pavitar
>
>
>
>
>  > Volatile helps to prevent 2 issues:
>  >
>  > reorderings
>  > visibility.
>  >
>  > Reordering:
>  > it prevents that the created hashmap is assigned to the data
variable,
>  > before the constructor has run. So it prevents other threads from
>  > seeing a partly constructed hashmap.
>  >
>  > Visibility:
>  > It makes sure that thread that reads data, sees the most recently
>  > written value of data. It also makes sure that the reading thread
sees
>  > all values written (e.g. the member variables of the hashmap)
before
>  > the writing thread did the write to data. This last behavior is
>  > available since Java 1.5 (JMM 133). It is a technique that can be
used
>  > to 'transfer' objects from one thread to another in a thread safe
>  > manner. A BlockingQueue for example support this behavior.
>  >
>  > For more information I suggest "Java Concurrency in Practice"
>  >
>  > PS:
>  > I know you made the remark, but for other less experienced
developers
>  > reading this thread.. the example is not threadsafe because HashMap
is
>  > not threadsafe. So its internal structure could be corrupted by
>  > concurrent access.
>  >
>  > On Fri, Mar 7, 2008 at 10:04 AM, Pavitar Singh
<pavitar at pramati.com>
>  > wrote:
>  >> Hi,
>  >>
>  >>  If i have something like this:
>  >>
>  >>  volatile Map data = new HashMap();
>  >>
>  >>  then what are the gurantees provided by volatile.
>  >>
>  >>  I know this is wrong usage of volatile. But i just wanted to know
>  >>  gurantees provided by volatile in case of Objects.
>  >>
>  >>  Regards
>  >>  Pavitar
>  >>  _______________________________________________
>  >>  Concurrency-interest mailing list
>  >>  Concurrency-interest at altair.cs.oswego.edu
>  >>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>  >>
>  >
>
>
_______________________________________________
Concurrency-interest mailing list
Concurrency-interest at altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From larryr at saturn.sdsu.edu  Fri Mar  7 13:30:14 2008
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Fri, 07 Mar 2008 10:30:14 -0800
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <A7487BEC58632D46B8C7E8BC69B3EB1206534A0A@mail-001.corp.automotive.com>
Message-ID: <1204914614.515695.29859.nullmailer@home35>


> volatile in this case doesn't guarantee the visibility[?]

I think intuitively a definition "volatile Map data;"
says the object referenced by "data" may get changed
by another thread, but it really just means another
thread may make "data" reference a different object,
and says nothing about changes to the object at all.
So invoking methods does nothing as far as visibility.

Kind of like in C++
   Map const * data;
vs
   Map * const data;


Larry


From dcholmes at optusnet.com.au  Fri Mar  7 15:58:01 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat, 8 Mar 2008 06:58:01 +1000
Subject: [concurrency-interest] Significance of volatile for Objects
In-Reply-To: <A7487BEC58632D46B8C7E8BC69B3EB1206534A0A@mail-001.corp.automotive.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCENIHKAA.dcholmes@optusnet.com.au>

The visibility guarantees come from the interaction of volatile writes and
volatile reads. In this code fragment there is only one volatile write -
when the HashMap is created. Thus as Peter states the newly created HashMap
is visible to subsequent accesses.

But any operations on the HashMap only involve a volatile read, so there are
no further visibility guarantees.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Joe
> Nguyen
> Sent: Saturday, 8 March 2008 3:15 AM
> To: Peter Veentjer; pavitar at pramati.com
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Significance of volatile for Objects
>
>
> Therefore, volatile in this case doesn't guarantee the visibility then
> (even in java 1.5)?
>
> "Visibility:
> It makes sure that thread that reads data, sees the most recently
> written value of data. It also makes sure that the reading thread sees
> all values written (e.g. the member variables of the hashmap) before the
> writing thread did the write to data. This last behavior is available
> since Java 1.5 (JMM 133). It is a technique that can be used to
> 'transfer' objects from one thread to another in a thread safe manner. A
> BlockingQueue for example support this behavior."
>
> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf Of Peter
> Veentjer
> Sent: Friday, March 07, 2008 4:48 AM
> To: pavitar at pramati.com
> Cc: concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] Significance of volatile for Objects
>
> >  But then doing operation on HashMap like put. It doesnt mean write to
> the
> >  volatile field.Siimilarly a get shouldnt mean read from volatile.
>
> That is correct. If one thread does a put (so a write inside the
> internals of the hashmap) and another thread does a get (so a read
> from the internals of the hashmap) there could be visibility problems
> because there is no happens before relation between the put and the
> get (there is no happens before relation between 2 reads of the same
> volatile variable).
>
> So:
> -changes made to the internal structure of the hashmap done by the
> write, don't have to be visiblity when you do a get.
> -objects placed in the put can't be safely passed from one thread to
> another because of the lack of the happens before relation.
>
> So if you are lucky enough to have missed the 'classic' concurrency
> problems with this hashmap, there are still JMM problems.
>
>
>
> Is it
> >  correct or i am missing something here.
> >
> >
> >  Regards
> >  Pavitar
> >
> >
> >
> >
> >  > Volatile helps to prevent 2 issues:
> >  >
> >  > reorderings
> >  > visibility.
> >  >
> >  > Reordering:
> >  > it prevents that the created hashmap is assigned to the data
> variable,
> >  > before the constructor has run. So it prevents other threads from
> >  > seeing a partly constructed hashmap.
> >  >
> >  > Visibility:
> >  > It makes sure that thread that reads data, sees the most recently
> >  > written value of data. It also makes sure that the reading thread
> sees
> >  > all values written (e.g. the member variables of the hashmap)
> before
> >  > the writing thread did the write to data. This last behavior is
> >  > available since Java 1.5 (JMM 133). It is a technique that can be
> used
> >  > to 'transfer' objects from one thread to another in a thread safe
> >  > manner. A BlockingQueue for example support this behavior.
> >  >
> >  > For more information I suggest "Java Concurrency in Practice"
> >  >
> >  > PS:
> >  > I know you made the remark, but for other less experienced
> developers
> >  > reading this thread.. the example is not threadsafe because HashMap
> is
> >  > not threadsafe. So its internal structure could be corrupted by
> >  > concurrent access.
> >  >
> >  > On Fri, Mar 7, 2008 at 10:04 AM, Pavitar Singh
> <pavitar at pramati.com>
> >  > wrote:
> >  >> Hi,
> >  >>
> >  >>  If i have something like this:
> >  >>
> >  >>  volatile Map data = new HashMap();
> >  >>
> >  >>  then what are the gurantees provided by volatile.
> >  >>
> >  >>  I know this is wrong usage of volatile. But i just wanted to know
> >  >>  gurantees provided by volatile in case of Objects.
> >  >>
> >  >>  Regards
> >  >>  Pavitar
> >  >>  _______________________________________________
> >  >>  Concurrency-interest mailing list
> >  >>  Concurrency-interest at altair.cs.oswego.edu
> >  >>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >  >>
> >  >
> >
> >
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From dl at cs.oswego.edu  Sun Mar  9 11:02:21 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 09 Mar 2008 11:02:21 -0400
Subject: [concurrency-interest] ParallelDoubleArray and BLAS level 1
In-Reply-To: <47C6625E.8020106@kav.dk>
References: <47C6625E.8020106@kav.dk>
Message-ID: <47D3FBFD.6010600@cs.oswego.edu>

Kasper Nielsen wrote:
> Wow, this list is quite at the moment.

(I have been completely swamped with unrelated things. I hope
to get back to regular updates of ParallelArray etc in the
coming weeks though.)

> 
> 
> Those place where I couldn't get away with using 
> ParallelDoubleArrayWithBounds I've used a ParallelDoubleArray.
> It was primarily because I had to swap transformed elements between two 
> arrays. Some better methods for this would be nice.

Such as?

> 
> There was only 1 operation I had to implement sequential 'idamax' which 
> returns the minimum index having the maximum absolute value.

This is a good candidate for ParallelDoubleArray as well.

> 
> All the BLAS routines takes an increment as an argument. 

Right. This is where the ambitions of ParallelDoubleArray fall
short of what you want, in part because it is not clear what
the best approach is. Should a dense matrix be packed into
a single-dimensional array (in which case you would want
"stride" arguments to traverse columns), or a Java array-of-arrays
(which can encounter much more indexing overhead)?
This issue has haunted people for years, since neither is
ideal. There was a JavaGrande effort and even a proposed JSR for
standardizing approaches, but nothing ever became of them.

> 
> but of course if we add this, next time I would want some way to select
> a bounded box in an array. So I'll probably end up with implementing 
> this myself in my Matrix library.
> 

Yes. Probably slices etc would fit in better for classes that
focus primarily on the linear algebra aspects of Matrices
rather than all the filtering, mapping, etc supported by
ParallelXArray. For example, it would probably be fine for
matrix classes for almost any loop to have a non-unit stride,
but this rarely makes sense for ParallelXArrays serving as
Collections.


-Doug


From dl at cs.oswego.edu  Sun Mar  9 16:58:13 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Sun, 09 Mar 2008 16:58:13 -0400
Subject: [concurrency-interest] ParallelArray classcastexception.
In-Reply-To: <47D14EE8.5080406@philosof.dk>
References: <47D14EE8.5080406@philosof.dk>
Message-ID: <47D44F65.9050107@cs.oswego.edu>

Rune Schjellerup Philosof wrote:
> Hello all
> 
> How come this throws Exception in thread "Thread-5" 
> java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [[F
> 
>         Scan[] scans;
>         ForkJoinPool fjp = new ForkJoinPool();
>         ParallelArray<Scan> scanarray = 
> ParallelArray.createFromCopy(scans, fjp);
>         ParallelArray<float[]> tmp = scanarray.withMapping(new 
> Ops.Op<Scan, float[]>() {
>             @Override
>             public float[] op(Scan scan) {
>                 float[][] raw = scan.getSpectrum();
>                 return Spectrum.Resample(raw, _mzRange, 
> _resamplingFrequency);
>             }
>         }).all();

You should use the elementType version of "all" here. As in:
   .all(float[].class);
Otherwise the array is an Object array, where each of the
objects here is a float[]. Which is fine except for the Java casting
rules for arrays, which cause exception on your next line:

>         float[][] resampledSpectra = tmp.getArray();   <--- exception
> 

And actually, even this wasn't handled consistently, but now is
in updated jar.

-Doug


From neal at gafter.com  Sun Mar  9 18:05:17 2008
From: neal at gafter.com (Neal Gafter)
Date: Sun, 9 Mar 2008 15:05:17 -0700
Subject: [concurrency-interest] ParallelArray classcastexception.
In-Reply-To: <47D44F65.9050107@cs.oswego.edu>
References: <47D14EE8.5080406@philosof.dk> <47D44F65.9050107@cs.oswego.edu>
Message-ID: <15e8b9d20803091505k3a671f34i18666dfeb530c34f@mail.gmail.com>

FJ is cheating with erasure, resulting in possible class cast exceptions
that demonstrate that the casts are not typesafe.  Specifically:

    public static <T> ParallelArray<T> create
        (int size, Class<? super T> elementType,
         ForkJoinExecutor executor) {
        T[] array = *(T[])*Array.newInstance(elementType, size);
        return new ParallelArray<T>(executor, array, size);
    }
    public static <T> ParallelArray<T> createEmpty
        (int size, Class<? super T> elementType,
         ForkJoinExecutor executor) {
        T[] array = *(T[])*Array.newInstance(elementType, size);
        return new ParallelArray<T>(executor, array, 0);
    }

These casts are not safe, as elementType is only guaranteed to be of some
supertype of T, not a subtype of T.

Elsewhere, there are Object[]s being cast to T[].  This isn't typesafe if
those arrays (or their types) are ever exposed, which they are.

This is the kind of code that will make it painful to add reification.

-Neal

On Sun, Mar 9, 2008 at 1:58 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> Rune Schjellerup Philosof wrote:
> > Hello all
> >
> > How come this throws Exception in thread "Thread-5"
> > java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [[F
> >
> >         Scan[] scans;
> >         ForkJoinPool fjp = new ForkJoinPool();
> >         ParallelArray<Scan> scanarray =
> > ParallelArray.createFromCopy(scans, fjp);
> >         ParallelArray<float[]> tmp = scanarray.withMapping(new
> > Ops.Op<Scan, float[]>() {
> >             @Override
> >             public float[] op(Scan scan) {
> >                 float[][] raw = scan.getSpectrum();
> >                 return Spectrum.Resample(raw, _mzRange,
> > _resamplingFrequency);
> >             }
> >         }).all();
>
> You should use the elementType version of "all" here. As in:
>   .all(float[].class);
> Otherwise the array is an Object array, where each of the
> objects here is a float[]. Which is fine except for the Java casting
> rules for arrays, which cause exception on your next line:
>
> >         float[][] resampledSpectra = tmp.getArray();   <--- exception
> >
>
> And actually, even this wasn't handled consistently, but now is
> in updated jar.
>
> -Doug
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080309/66028298/attachment.html 

From jed at atlassian.com  Sun Mar  9 23:18:41 2008
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Mon, 10 Mar 2008 14:18:41 +1100
Subject: [concurrency-interest] Spring DispatcherServlet
 safe	publication question
In-Reply-To: <63b4e4050803060800w229514fqfd9f7bb2df107c79@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>	<47CF6866.204@redhat.com>	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>	<63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>	<47D01137.7040307@redhat.com>
	<63b4e4050803060800w229514fqfd9f7bb2df107c79@mail.gmail.com>
Message-ID: <47D4A891.5060504@atlassian.com>

As far as I am aware, the DispatcherServlet is actually initialised by 
Spring (at least in terms of the setters being called). Spring 
components with setter injection are initialised correctly (with 
happens-before semantics) and are subsequently effectively immutable as 
long as no client code changes the references. It's one of the things I 
hate about setter injection that you have to trust the framework to do 
the right thing.

So, it has nothing to do with the Servlet spec - it's entirely down to 
Spring.

Tim Peierls wrote:
> On Thu, Mar 6, 2008 at 10:43 AM, Jason T. Greene 
> <jason.greene at redhat.com <mailto:jason.greene at redhat.com>> wrote:
>
>     Tim Peierls wrote:
>     > On Thu, Mar 6, 2008 at 2:58 AM, Dhanji R. Prasanna
>     <dhanji at gmail.com <mailto:dhanji at gmail.com>
>     > <mailto:dhanji at gmail.com <mailto:dhanji at gmail.com>>> wrote:
>     >
>     >     Or is it because the servlet container's startup thread
>     locks (presumably) when going thru init?
>     >
>     >
>     > That wouldn't be enough, there would have to be a matching lock
>     around every service call.
>
>     Not true. As long as the instance fields are not yet visible
>     (published)
>     to other threads, and they are never written to afterwards they are
>     effectively immutable.
>
>
> Circular reasoning: You can't guarantee that those writes aren't yet 
> visible to other reading threads unless there is a /happens-before/ 
> relationship between init() and service(), and the spec isn't clear 
> about that. I understand the intent, but ... horseshoes and hand-grenades.
>
>
>     Since the spec requires init() to be ran only once and complete
>     before any service method is called, 
>
>
> There's that pesky "before" again. If only the spec used 
> /happens-before/ or something equivalent to it.
>
>  
>
>     and since instance fields are only ever
>     accessed by service methods, they can be effectively immutable. I do
>     agree the spec should make this more clear. I will email the
>     servlet EG
>     about that.
>
>
> Thanks!
>
>  
>
>     > As JCiP 4.5.1 points out, however, sometimes you have to assume,
>     when
>     > dealing with ambiguous documentation, that a framework is doing the
>     > right thing, because it makes no sense for it to do otherwise. And
>     > gazillions of happy Spring users haven't complained yet. :-)
>
>     It's funny that you bring this up, because I took a look at the tomcat
>     source, and sadly they are using DCL to meet the init() requirements
>     (will file a bug on this) :(
>
>     if (instance == null) {
>       synchronized (this) {
>         if (instance == null) {
>           try {
>             instance = loadServlet();
>           } catch (ServletException e) {
>             throw e;
>           } catch (Throwable e) {
>             throw new ServletException(..., e);
>           }
>         }
>       }
>     }
>
>     So, your suggestion of guarding against broken containers with a
>     volatile isn't so bad.
>
>
> Thanks, again! :-)
>
> --tim
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


From dhanji at gmail.com  Sun Mar  9 23:49:55 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 10 Mar 2008 14:49:55 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <47D4A891.5060504@atlassian.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<47CF6866.204@redhat.com>
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>
	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>
	<63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>
	<47D01137.7040307@redhat.com>
	<63b4e4050803060800w229514fqfd9f7bb2df107c79@mail.gmail.com>
	<47D4A891.5060504@atlassian.com>
Message-ID: <aa067ea10803092049j41811413rdfcc7ada1f01513c@mail.gmail.com>

On Mon, Mar 10, 2008 at 2:18 PM, Jed Wesley-Smith <jed at atlassian.com> wrote:
>
>
> So, it has nothing to do with the Servlet spec - it's entirely down to
> Spring.


Well, where is spring obtaining it's init thread? =)

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080310/1144122f/attachment.html 

From crazybob at crazybob.org  Mon Mar 10 00:20:39 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Sun, 9 Mar 2008 20:20:39 -0800
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
Message-ID: <a74683f90803092120v3bf07972wbbb9e75ed38dbd31@mail.gmail.com>

As a practical matter, it would seem either:

a) The init thread calls init() and then passes the servlet instance off to
request threads in a thread safe way.

or

b) All threads have access to the servlet and the init thread notifies the
request threads that they can call service().

Either way, I think it's safe, right?

Bob

On Wed, Mar 5, 2008 at 6:30 PM, Dhanji R. Prasanna <dhanji at gmail.com> wrote:

> Hello again,
>
> This question has been bugging me for a *long* time. Nobody (and no docs)
> seem to adequately address this problem for me.
> Spring's DispatcherServlet:
> http://fisheye1.cenqua.com/browse/springframework/spring/src/org/springframework/web/servlet/DispatcherServlet.java?r=1.100
> ...has several non-volatile, non-final fields for various pluggable
> services (ThemeResolver, ViewResolver, etc.). These are set by equally
> various private unsynchronized methods which cascade down from
> HttpServlet.init(), itself also unsynchronized.
>
> The problem I have is that this seems like it could lead to incoherent
> values between the startup thread's view of DispatcherServlet and any
> subsequent request threads. Since there is no lock or synchronization, I
> cannot find a guarantee that request threads will see the value set in the
> init thread (even though they are chronologically sequenced ok). All these
> fields are also non-volatile. It looks like a classic unsafe publication
> problem to me.
>
> Worse, there are no default values, so request threads could end up biting
> NPEs.
>
> This seems like a gross flaw in code that's deployed virtually everywhere.
> Why isn't there more clamor about this? Or am I just totally nuts (I *hope*
> so)?
> I know Tim has talked for a long time about (lack of) safe publication
> guarantees in the Spring injector itself... but I could not find any
> concrete examples.
>
> @Jason: Yes I have JCiP, though it was hell finding it in Australian book
> stores--thanks for the reck! =)
>
> Dhanji.
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080309/6d09f88f/attachment.html 

From dhanji at gmail.com  Mon Mar 10 00:58:47 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Mon, 10 Mar 2008 15:58:47 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <a74683f90803092120v3bf07972wbbb9e75ed38dbd31@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>
	<a74683f90803092120v3bf07972wbbb9e75ed38dbd31@mail.gmail.com>
Message-ID: <aa067ea10803092158k11e005e4m171aea84f52302dc@mail.gmail.com>

On Mon, Mar 10, 2008 at 3:20 PM, Bob Lee <crazybob at crazybob.org> wrote:

> As a practical matter, it would seem either:
>
> a) The init thread calls init() and then passes the servlet instance off
> to request threads in a thread safe way.
>
> or
>
> b) All threads have access to the servlet and the init thread notifies the
> request threads that they can call service().


So, the servlet is instantiated in StandardWrapper.allocate() using
double-checked locking (as Jason noted) on a non-volatile variable,
"instance". Method getServlet() is a dumb getter that returns a reference to
"instance".

Im not sure if allocate() is guaranteed to be called only once, i.e. by one
thread (I mean, what's the point of DCLing if it is)? And the servlet spec
only requires that the init() method be called once. Which happens as
expected.

Therefore reading threads (or any subsequent thread calling allocate() ) can
see a partially constructed servlet instance--correct?

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080310/36873e84/attachment-0001.html 

From jed at atlassian.com  Mon Mar 10 01:06:32 2008
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Mon, 10 Mar 2008 16:06:32 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
 publication question
In-Reply-To: <aa067ea10803092049j41811413rdfcc7ada1f01513c@mail.gmail.com>
References: <aa067ea10803051830t19a322bew220460684c0b3d35@mail.gmail.com>	
	<47CF6866.204@redhat.com>	
	<aa067ea10803052345gbdd78e7j63fc377ddcad3e9b@mail.gmail.com>	
	<aa067ea10803052358s6f9ea5ccx803d2d4abf35aa22@mail.gmail.com>	
	<63b4e4050803060441v7d3b8741had67c89452b081f3@mail.gmail.com>	
	<47D01137.7040307@redhat.com>	
	<63b4e4050803060800w229514fqfd9f7bb2df107c79@mail.gmail.com>	
	<47D4A891.5060504@atlassian.com>
	<aa067ea10803092049j41811413rdfcc7ada1f01513c@mail.gmail.com>
Message-ID: <47D4C1D8.3030102@atlassian.com>

Dhanji R. Prasanna wrote:

> On Mon, Mar 10, 2008 at 2:18 PM, Jed Wesley-Smith <jed at atlassian.com 
> <mailto:jed at atlassian.com>> wrote:
>
>
>     So, it has nothing to do with the Servlet spec - it's entirely down to
>     Spring.
>
>
> Well, where is spring obtaining it's init thread? =)
>
> Dhanji.

Actually, having a quick look at the code (rather than just wildly 
speculating), it does look like it is all actually initiated from the 
init method. In which case I don't know how or if Spring makes its usual 
ordering guarantees.

All that being said, as Jason points out the spec _does_ make some 
assurance of precedence although as Tim says this isn't _explicit_. 
SRV2.3.3 says: "After a servlet is properly initialized, the servlet 
container may use it to handle client
requests". The key being "after ... properly initialized" - I would 
posit that most servlet containers would implement a _happens before_ 
relationship here,  therefore all will be well. Otherwise they would 
certainly be open to the charge that they are not fulfilling the spec. I 
haven't had a look at any servlet container code though.

cheers,
jed.

From dcholmes at optusnet.com.au  Mon Mar 10 01:23:37 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 10 Mar 2008 15:23:37 +1000
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <47D4C1D8.3030102@atlassian.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIENNHKAA.dcholmes@optusnet.com.au>

Jed Wesley-Smith wrote:
> The key being "after ... properly initialized" - I would
> posit that most servlet containers would implement a _happens before_
> relationship here,  therefore all will be well.

I would posit that servlet containers would need to implement a
happens-before relationship here, but whether the writers of such servlet
containers are actually aware of that need, is a different matter entirely.
;-)

Safe-publication is the forgotten topic of "Threads 101" :(

Cheers,
David Holmes


From jed at atlassian.com  Mon Mar 10 02:32:40 2008
From: jed at atlassian.com (Jed Wesley-Smith)
Date: Mon, 10 Mar 2008 17:32:40 +1100
Subject: [concurrency-interest] Spring DispatcherServlet safe
 publication question
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIENNHKAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCIENNHKAA.dcholmes@optusnet.com.au>
Message-ID: <47D4D608.70905@atlassian.com>

David Holmes wrote:
> Jed Wesley-Smith wrote:
>   
>> The key being "after ... properly initialized" - I would
>> posit that most servlet containers would implement a _happens before_
>> relationship here,  therefore all will be well.
>>     
>
> I would posit that servlet containers would need to implement a
> happens-before relationship here, but whether the writers of such servlet
> containers are actually aware of that need, is a different matter entirely.
> ;-)
>   

hehe. My initial posit was based on the assumption (dangerous I know) 
that there is quite likely _some kind_ of synchronisation around the 
initialisation of the Servlet instances that causes this happens-before 
relationship _not necessarily directly related to the spec_. I.e. 
Servlets generally work as much perhaps by accident as by design :-)

As support for this argument I was going to present Tomcat's 
org.apache.catalina.core.StandardWrapper class that caches a Servlet 
instance (if it doesn't implement SingleThreadedModel). When I looked I 
saw the following:

    public Servlet allocate() {
        ...
            // Load and initialize our instance if necessary
            if (instance == null) {
                synchronized (this) {
                    if (instance == null) {
                        try {
                            instance = loadServlet();
                        } catch (Exceptions etc) {}
                    }
                }
            }
        ...
            return (instance);
        ...
    }

The instance variable is (of course) not volatile.

I am now backing away slowly and quietly.

> Safe-publication is the forgotten topic of "Threads 101" :(
>   

Unfortunately and clearly true.

From alarmnummer at gmail.com  Mon Mar 10 04:51:15 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Mon, 10 Mar 2008 09:51:15 +0100
Subject: [concurrency-interest] Spring DispatcherServlet safe
	publication question
In-Reply-To: <47D4D608.70905@atlassian.com>
References: <NFBBKALFDCPFIDBNKAPCIENNHKAA.dcholmes@optusnet.com.au>
	<47D4D608.70905@atlassian.com>
Message-ID: <1466c1d60803100151o2c582950of5db9fec71937ed7@mail.gmail.com>

The code looks a lot like the double checked locking problem

There is one visibility problem at least:
There is no (visible) happens before relation between the write to the
instance variable and the read of the instance variable in the
outermost if(instance==null) check. So it could be that changes made
in the loadServlet are not visible in threads that access the instance
once it has been created.

And gobbling up an exception? My god.. that is asking for problems

On Mon, Mar 10, 2008 at 7:32 AM, Jed Wesley-Smith <jed at atlassian.com> wrote:
> David Holmes wrote:
>  > Jed Wesley-Smith wrote:
>  >
>  >> The key being "after ... properly initialized" - I would
>  >> posit that most servlet containers would implement a _happens before_
>  >> relationship here,  therefore all will be well.
>  >>
>  >
>  > I would posit that servlet containers would need to implement a
>  > happens-before relationship here, but whether the writers of such servlet
>  > containers are actually aware of that need, is a different matter entirely.
>  > ;-)
>  >
>
>  hehe. My initial posit was based on the assumption (dangerous I know)
>  that there is quite likely _some kind_ of synchronisation around the
>  initialisation of the Servlet instances that causes this happens-before
>  relationship _not necessarily directly related to the spec_. I.e.
>  Servlets generally work as much perhaps by accident as by design :-)
>
>  As support for this argument I was going to present Tomcat's
>  org.apache.catalina.core.StandardWrapper class that caches a Servlet
>  instance (if it doesn't implement SingleThreadedModel). When I looked I
>  saw the following:
>
>     public Servlet allocate() {
>         ...
>             // Load and initialize our instance if necessary
>
>             if (instance == null) {
>                 synchronized (this) {
>                     if (instance == null) {
>                         try {
>                             instance = loadServlet();
>                         } catch (Exceptions etc) {}
>                     }
>                 }
>             }
>         ...
>             return (instance);
>         ...
>     }
>
>  The instance variable is (of course) not volatile.
>
>  I am now backing away slowly and quietly.
>
>
>  > Safe-publication is the forgotten topic of "Threads 101" :(
>  >
>
>  Unfortunately and clearly true.
>
>
> _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>

From r.samuel.klatchko at gmail.com  Tue Mar 11 08:22:11 2008
From: r.samuel.klatchko at gmail.com (R Samuel Klatchko)
Date: Tue, 11 Mar 2008 17:52:11 +0530
Subject: [concurrency-interest] visibility vs. cache coherency
Message-ID: <8eddd5030803110522o6ffa1b76wa0e1d0ee9a14f58c@mail.gmail.com>

Hi all-

I apologize if this has already been discussed on the list but there does
not appear to be a way to search the list archives.  I also did some
googling but could not find an answer.

I am confused about how visibility problems can occur in a cache coherent
system.  Do visibility problems only occur in non cache coherent
architectures?  Or can visibility problems still occur even with cache
coherence do to something that I don't yet understand.

Any help or pointers to documents will be appreciated.

samuel
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080311/3295d359/attachment.html 

From rune at philosof.dk  Tue Mar 11 10:16:12 2008
From: rune at philosof.dk (Rune Schjellerup Philosof)
Date: Tue, 11 Mar 2008 15:16:12 +0100
Subject: [concurrency-interest] ParallelFloatArray
Message-ID: <47D6942C.7000401@philosof.dk>

Hello

ParallelFloatArray isn't provided because you assume people only use double?
It would be useful for me to have a ParallelFloatArray since I don't 
feel like refactoring everywhere I use float and especially not the 
libraries that return floats.
Copying all my float arrays to double arrays and back again seems very 
counterproductive.

--
Regards
Rune


From larryr at saturn.sdsu.edu  Tue Mar 11 12:02:31 2008
From: larryr at saturn.sdsu.edu (Larry Riedel)
Date: Tue, 11 Mar 2008 09:02:31 -0700
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <8eddd5030803110522o6ffa1b76wa0e1d0ee9a14f58c@mail.gmail.com>
Message-ID: <1205251351.155634.26338.nullmailer@home35>


> there does not appear to be a way to search
> the list archives.  I also did some googling

I think adding this to the google search may help
    concurrency-interest site:cs.oswego.edu


Larry


From tom.seelbach at gmail.com  Tue Mar 11 15:06:05 2008
From: tom.seelbach at gmail.com (Tom Seelbach)
Date: Tue, 11 Mar 2008 15:06:05 -0400
Subject: [concurrency-interest] backport: what is the best way to
	acknowledge usage of backport?
Message-ID: <47D6D81D.70400@gmail.com>

Hi,
Apache Axis2 was recently updated to depend on backport-util-concurrent 
3.1 instead of 2.2.   Axis2 distribute a copy of a backport license like 
this:    
http://svn.apache.org/viewvc/webservices/axis2/trunk/java/legal/backport-util-concurrent-LICENSE.txt?revision=553578&view=markup

Looks like its outdated.  I looked at the backport 3.1 code and README 
and it seems that the attribution to Sun for the CopyOnWriteArrayList 
hasn't been needed since 2.0_01?

Could someone recommend the best way to update the axis2 license for 
backport?
I see some relevant info in 3 files: LEGAL, README.html (License 
section) and LICENSE.html.
It's kinda confusing to have the legal and license info in 3 files.
Maybe it's best that in axis2 we combine them like this:

========================================================
Acknowledgements:
backport-util-concurrent is based in large part on the public
domain sources from:
    1) JSR166,
    2) package dl.util.concurrent,
    3) Doug Lea's "collections" package.

This software is released to the public domain
( http://creativecommons.org/licenses/publicdomain )
in the spirit of the original code written by Doug Lea.
The code can be used for any purpose, modified, and redistributed
without acknowledgment. No warranty is provided, either express or implied.

Following  is a copy of http://creativecommons.org/licenses/publicdomain

Creative Commons Public Domain
Copyright-Only Dedication (based on United States law) or Public Domain 
Certification

The person or persons who have associated work with this document
(the "Dedicator" or "Certifier") hereby either (a) certifies that, to the
best of his knowledge, the work of authorship identified is in the
public domain of the country from which the work is published, or (b)
hereby dedicates whatever copyright the dedicators holds in the work of
authorship identified below (the "Work") to the public domain. A
certifier, moreover, dedicates any copyright interest he may have in the
associated work, and for these purposes, is described as a "dedicator"
below.

A certifier has taken reasonable steps to verify
the copyright status of this work. Certifier recognizes that his good
faith efforts may not shield him from liability if in fact the work
certified is not in the public domain.

Dedicator makes this dedication for the benefit of the public at large and
to the detriment of the Dedicator's heirs and successors. Dedicator intends
this dedication to be an overt act of relinquishment in perpetuity of
all present and future rights under copyright law, whether vested or
contingent, in the Work. Dedicator understands that such relinquishment
of all rights includes the relinquishment of all rights to enforce (by
lawsuit or otherwise) those copyrights in the Work.

Dedicator recognizes that, once placed in the public domain, the Work may be
freely reproduced, distributed, transmitted, used, modified, built
upon, or otherwise exploited by anyone for any purpose, commercial or
non-commercial, and in any way, including by methods that have not yet
been invented or conceived.
===============================

Does this make sense?
thanks,
Tom



From dcholmes at optusnet.com.au  Tue Mar 11 19:53:14 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 12 Mar 2008 09:53:14 +1000
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <1205251351.155634.26338.nullmailer@home35>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEODHKAA.dcholmes@optusnet.com.au>

Also you'll find more details/discussion on the Java Memory Model list:

http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion

The simple (and therefore potentially misleading) answer is that hardware
cache coherent systems don't introduce visibility problems related to the
operation of memory at the hardware level. Systems that require software
directed cache coherency (the alpha architecture is an example) can have
visibility problems if the compiler doesn't generate those coherency
instructions where they are needed.

But aside from the hardware level, visibility arises from the actions of the
VM and in particular the code generated by the JIT. For example, without
something forcing it to do otherwise (i.e. a happens-before ordering) the
JIT might cache a read of a field in a register and not reload it, thereby
missing concurrent updates to that field.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Larry
> Riedel
> Sent: Wednesday, 12 March 2008 2:03 AM
> To: Concurrency-interest at cs.oswego.edu
> Cc: R Samuel Klatchko
> Subject: Re: [concurrency-interest] visibility vs. cache coherency
>
>
>
> > there does not appear to be a way to search
> > the list archives.  I also did some googling
>
> I think adding this to the google search may help
>     concurrency-interest site:cs.oswego.edu
>
>
> Larry
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl at cs.oswego.edu  Tue Mar 11 20:20:26 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Tue, 11 Mar 2008 20:20:26 -0400
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <47D6942C.7000401@philosof.dk>
References: <47D6942C.7000401@philosof.dk>
Message-ID: <47D721CA.8050600@cs.oswego.edu>

Rune Schjellerup Philosof wrote:
> Hello
> 
> ParallelFloatArray isn't provided because you assume people only use double?

Not exactly. It isn't provided because the number of support classes
goes up with the square of the number of primitive specializations
provided (each multiplied by filter and mapping views). Stopping
at one integral type (long) and one floating (double) is not ideal,
but the alternative of adding thousands of lines of nearly
redundant code to support float (and int and then what about the
others) is even less ideal.

There are some further discussions of this in the list archives.
We wish we knew a good way out of this.

> Copying all my float arrays to double arrays and back again seems very 
> counterproductive.
> 

And worse, copying is a sequential bottleneck.

-Doug

From r.samuel.klatchko at gmail.com  Wed Mar 12 02:54:19 2008
From: r.samuel.klatchko at gmail.com (R Samuel Klatchko)
Date: Wed, 12 Mar 2008 12:24:19 +0530
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEODHKAA.dcholmes@optusnet.com.au>
References: <1205251351.155634.26338.nullmailer@home35>
	<NFBBKALFDCPFIDBNKAPCOEODHKAA.dcholmes@optusnet.com.au>
Message-ID: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>

David-

Thanks for the info.

While I know this discussion group prefers to focus on the JMM/JSR-133, I am
looking to understand what is going on at the hardware level (both because I
like to learn how things work and because I still continue to work in C/C++
so until it has a better memory model, how hardware works will help me
there).

It sounds to me like it is fair to say that if the hardware you are running
on supports hardware cache coherency and if data is written to memory, there
should not be visibility problems.  What I am wondering about is whether
thread 1 can change memory location L from V to V' yet thread 2 continues to
read the value V from L for an unbounded time.

I am not thinking about short delays due to memory latency issues or
ordering problems.  I am also not thinking about issues where thread 2 never
sees the value from thread 1 because thread 3 also wrote the same memory
location around the same time and thread 2 sees that value.

Finally, does anyone know how prevalent hardware cache coherent systems are
as compared to software directed cache coherent systems?

Thanks,
samuel


On Wed, Mar 12, 2008 at 5:23 AM, David Holmes <dcholmes at optusnet.com.au>
wrote:

> Also you'll find more details/discussion on the Java Memory Model list:
>
> http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion
>
> The simple (and therefore potentially misleading) answer is that hardware
> cache coherent systems don't introduce visibility problems related to the
> operation of memory at the hardware level. Systems that require software
> directed cache coherency (the alpha architecture is an example) can have
> visibility problems if the compiler doesn't generate those coherency
> instructions where they are needed.
>
> But aside from the hardware level, visibility arises from the actions of
> the
> VM and in particular the code generated by the JIT. For example, without
> something forcing it to do otherwise (i.e. a happens-before ordering) the
> JIT might cache a read of a field in a register and not reload it, thereby
> missing concurrent updates to that field.
>
> Cheers,
> David Holmes
>
> > -----Original Message-----
> > From: concurrency-interest-bounces at cs.oswego.edu
> > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Larry
> > Riedel
> > Sent: Wednesday, 12 March 2008 2:03 AM
> > To: Concurrency-interest at cs.oswego.edu
> > Cc: R Samuel Klatchko
> > Subject: Re: [concurrency-interest] visibility vs. cache coherency
> >
> >
> >
> > > there does not appear to be a way to search
> > > the list archives.  I also did some googling
> >
> > I think adding this to the google search may help
> >     concurrency-interest site:cs.oswego.edu
> >
> >
> > Larry
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080312/ea1a42ee/attachment.html 

From dcholmes at optusnet.com.au  Wed Mar 12 03:19:31 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 12 Mar 2008 17:19:31 +1000
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>

Samuel,

If you don't care about latency or ordering issues (which tend to be exactly
the things we do care about!) then visibility on a hardware cache coherent
system is not an issue - a write to a variable will become visible within a
bounded time.

I'm not sure which architectures mandate hardware cache coherency, vs.
implementations of those architectures that happen to provide them. The
Alpha architecture is the main example I know of a system that supports
software coherency. If you need more details I'd suggest visiting a computer
architecture forum/newsgroup; or else go grab the relevant architecture
specifications if you can (IA32, IA64, PPC are readily available online -
not sure about SPARC.)

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of R Samuel
Klatchko
  Sent: Wednesday, 12 March 2008 4:54 PM
  To: Concurrency-interest at cs.oswego.edu
  Cc: dholmes at ieee.org
  Subject: Re: [concurrency-interest] visibility vs. cache coherency



  David-

  Thanks for the info.

  While I know this discussion group prefers to focus on the JMM/JSR-133, I
am looking to understand what is going on at the hardware level (both
because I like to learn how things work and because I still continue to work
in C/C++ so until it has a better memory model, how hardware works will help
me there).

  It sounds to me like it is fair to say that if the hardware you are
running on supports hardware cache coherency and if data is written to
memory, there should not be visibility problems.  What I am wondering about
is whether thread 1 can change memory location L from V to V' yet thread 2
continues to read the value V from L for an unbounded time.

  I am not thinking about short delays due to memory latency issues or
ordering problems.  I am also not thinking about issues where thread 2 never
sees the value from thread 1 because thread 3 also wrote the same memory
location around the same time and thread 2 sees that value.

  Finally, does anyone know how prevalent hardware cache coherent systems
are as compared to software directed cache coherent systems?

  Thanks,
  samuel



  On Wed, Mar 12, 2008 at 5:23 AM, David Holmes <dcholmes at optusnet.com.au>
wrote:

    Also you'll find more details/discussion on the Java Memory Model list:

    http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion

    The simple (and therefore potentially misleading) answer is that
hardware
    cache coherent systems don't introduce visibility problems related to
the
    operation of memory at the hardware level. Systems that require software
    directed cache coherency (the alpha architecture is an example) can have
    visibility problems if the compiler doesn't generate those coherency
    instructions where they are needed.

    But aside from the hardware level, visibility arises from the actions of
the
    VM and in particular the code generated by the JIT. For example, without
    something forcing it to do otherwise (i.e. a happens-before ordering)
the
    JIT might cache a read of a field in a register and not reload it,
thereby
    missing concurrent updates to that field.

    Cheers,
    David Holmes


    > -----Original Message-----
    > From: concurrency-interest-bounces at cs.oswego.edu
    > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Larry
    > Riedel
    > Sent: Wednesday, 12 March 2008 2:03 AM
    > To: Concurrency-interest at cs.oswego.edu

    > Cc: R Samuel Klatchko
    > Subject: Re: [concurrency-interest] visibility vs. cache coherency
    >
    >
    >
    > > there does not appear to be a way to search
    > > the list archives.  I also did some googling
    >
    > I think adding this to the google search may help
    >     concurrency-interest site:cs.oswego.edu
    >
    >
    > Larry
    >

    > _______________________________________________
    > Concurrency-interest mailing list
    > Concurrency-interest at altair.cs.oswego.edu
    > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080312/8532406c/attachment-0001.html 

From r.samuel.klatchko at gmail.com  Wed Mar 12 03:47:40 2008
From: r.samuel.klatchko at gmail.com (R Samuel Klatchko)
Date: Wed, 12 Mar 2008 13:17:40 +0530
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
References: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
Message-ID: <8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>

David-

Sorry, I didn't explain myself well.  It's not that I don't care about
ordering and latency; rather, I am just trying to understand why things
happen and believe I already understand what causes ordering/latency
issues.  But I was always baffled by why visibility problems could occur
(other then visibility problems caused by compiler/VM optimizations) with
cache coherency (everything I have found and read so far on cache coherency
not only focus on hardware based, but don't even mention software directed
coherency).

Thanks for all your help.

samuel


On Wed, Mar 12, 2008 at 12:49 PM, David Holmes <dcholmes at optusnet.com.au>
wrote:

>  Samuel,
>
> If you don't care about latency or ordering issues (which tend to be
> exactly the things we do care about!) then visibility on a hardware cache
> coherent system is not an issue - a write to a variable will become visible
> within a bounded time.
>
> I'm not sure which architectures mandate hardware cache coherency, vs.
> implementations of those architectures that happen to provide them. The
> Alpha architecture is the main example I know of a system that supports
> software coherency. If you need more details I'd suggest visiting a computer
> architecture forum/newsgroup; or else go grab the relevant architecture
> specifications if you can (IA32, IA64, PPC are readily available online -
> not sure about SPARC.)
>
> Cheers,
> David Holmes
>
> -----Original Message-----
> *From:* concurrency-interest-bounces at cs.oswego.edu [mailto:
> concurrency-interest-bounces at cs.oswego.edu]*On Behalf Of *R Samuel
> Klatchko
> *Sent:* Wednesday, 12 March 2008 4:54 PM
> *To:* Concurrency-interest at cs.oswego.edu
> *Cc:* dholmes at ieee.org
> *Subject:* Re: [concurrency-interest] visibility vs. cache coherency
>
>
> David-
>
> Thanks for the info.
>
> While I know this discussion group prefers to focus on the JMM/JSR-133, I
> am looking to understand what is going on at the hardware level (both
> because I like to learn how things work and because I still continue to work
> in C/C++ so until it has a better memory model, how hardware works will help
> me there).
>
> It sounds to me like it is fair to say that if the hardware you are
> running on supports hardware cache coherency and if data is written to
> memory, there should not be visibility problems.  What I am wondering about
> is whether thread 1 can change memory location L from V to V' yet thread 2
> continues to read the value V from L for an unbounded time.
>
> I am not thinking about short delays due to memory latency issues or
> ordering problems.  I am also not thinking about issues where thread 2 never
> sees the value from thread 1 because thread 3 also wrote the same memory
> location around the same time and thread 2 sees that value.
>
> Finally, does anyone know how prevalent hardware cache coherent systems
> are as compared to software directed cache coherent systems?
>
> Thanks,
> samuel
>
>
> On Wed, Mar 12, 2008 at 5:23 AM, David Holmes <dcholmes at optusnet.com.au>
> wrote:
>
> > Also you'll find more details/discussion on the Java Memory Model list:
> >
> > http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion
> >
> > The simple (and therefore potentially misleading) answer is that
> > hardware
> > cache coherent systems don't introduce visibility problems related to
> > the
> > operation of memory at the hardware level. Systems that require software
> > directed cache coherency (the alpha architecture is an example) can have
> > visibility problems if the compiler doesn't generate those coherency
> > instructions where they are needed.
> >
> > But aside from the hardware level, visibility arises from the actions of
> > the
> > VM and in particular the code generated by the JIT. For example, without
> > something forcing it to do otherwise (i.e. a happens-before ordering)
> > the
> > JIT might cache a read of a field in a register and not reload it,
> > thereby
> > missing concurrent updates to that field.
> >
> > Cheers,
> > David Holmes
> >
> > > -----Original Message-----
> > > From: concurrency-interest-bounces at cs.oswego.edu
> > > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Larry
> > > Riedel
> > > Sent: Wednesday, 12 March 2008 2:03 AM
> > > To: Concurrency-interest at cs.oswego.edu
> >  > Cc: R Samuel Klatchko
> > > Subject: Re: [concurrency-interest] visibility vs. cache coherency
> > >
> > >
> > >
> > > > there does not appear to be a way to search
> > > > the list archives.  I also did some googling
> > >
> > > I think adding this to the google search may help
> > >     concurrency-interest site:cs.oswego.edu
> > >
> > >
> > > Larry
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080312/4e0786d6/attachment.html 

From dcholmes at optusnet.com.au  Wed Mar 12 04:54:56 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Wed, 12 Mar 2008 18:54:56 +1000
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEOHHKAA.dcholmes@optusnet.com.au>

:-) Google "software cache coherency". Here's the first hit:

"Software Cache Coherence for Large Scale Multiprocessors"

http://citeseer.ist.psu.edu/kontothanassis94software.html

Cheers,
David
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of R Samuel
Klatchko
  Sent: Wednesday, 12 March 2008 5:48 PM
  To: dholmes at ieee.org
  Cc: Concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] visibility vs. cache coherency



  David-

  Sorry, I didn't explain myself well.  It's not that I don't care about
ordering and latency; rather, I am just trying to understand why things
happen and believe I already understand what causes ordering/latency issues.
But I was always baffled by why visibility problems could occur (other then
visibility problems caused by compiler/VM optimizations) with cache
coherency (everything I have found and read so far on cache coherency not
only focus on hardware based, but don't even mention software directed
coherency).

  Thanks for all your help.

  samuel



  On Wed, Mar 12, 2008 at 12:49 PM, David Holmes <dcholmes at optusnet.com.au>
wrote:

    Samuel,

    If you don't care about latency or ordering issues (which tend to be
exactly the things we do care about!) then visibility on a hardware cache
coherent system is not an issue - a write to a variable will become visible
within a bounded time.

    I'm not sure which architectures mandate hardware cache coherency, vs.
implementations of those architectures that happen to provide them. The
Alpha architecture is the main example I know of a system that supports
software coherency. If you need more details I'd suggest visiting a computer
architecture forum/newsgroup; or else go grab the relevant architecture
specifications if you can (IA32, IA64, PPC are readily available online -
not sure about SPARC.)

    Cheers,
    David Holmes
      -----Original Message-----
      From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of R Samuel
Klatchko
      Sent: Wednesday, 12 March 2008 4:54 PM
      To: Concurrency-interest at cs.oswego.edu

      Cc: dholmes at ieee.org
      Subject: Re: [concurrency-interest] visibility vs. cache coherency



      David-

      Thanks for the info.

      While I know this discussion group prefers to focus on the
JMM/JSR-133, I am looking to understand what is going on at the hardware
level (both because I like to learn how things work and because I still
continue to work in C/C++ so until it has a better memory model, how
hardware works will help me there).

      It sounds to me like it is fair to say that if the hardware you are
running on supports hardware cache coherency and if data is written to
memory, there should not be visibility problems.  What I am wondering about
is whether thread 1 can change memory location L from V to V' yet thread 2
continues to read the value V from L for an unbounded time.

      I am not thinking about short delays due to memory latency issues or
ordering problems.  I am also not thinking about issues where thread 2 never
sees the value from thread 1 because thread 3 also wrote the same memory
location around the same time and thread 2 sees that value.

      Finally, does anyone know how prevalent hardware cache coherent
systems are as compared to software directed cache coherent systems?

      Thanks,
      samuel



      On Wed, Mar 12, 2008 at 5:23 AM, David Holmes
<dcholmes at optusnet.com.au> wrote:

        Also you'll find more details/discussion on the Java Memory Model
list:


http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion

        The simple (and therefore potentially misleading) answer is that
hardware
        cache coherent systems don't introduce visibility problems related
to the
        operation of memory at the hardware level. Systems that require
software
        directed cache coherency (the alpha architecture is an example) can
have
        visibility problems if the compiler doesn't generate those coherency
        instructions where they are needed.

        But aside from the hardware level, visibility arises from the
actions of the
        VM and in particular the code generated by the JIT. For example,
without
        something forcing it to do otherwise (i.e. a happens-before
ordering) the
        JIT might cache a read of a field in a register and not reload it,
thereby
        missing concurrent updates to that field.

        Cheers,
        David Holmes


        > -----Original Message-----
        > From: concurrency-interest-bounces at cs.oswego.edu
        > [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of
Larry
        > Riedel
        > Sent: Wednesday, 12 March 2008 2:03 AM
        > To: Concurrency-interest at cs.oswego.edu

        > Cc: R Samuel Klatchko
        > Subject: Re: [concurrency-interest] visibility vs. cache coherency
        >
        >
        >
        > > there does not appear to be a way to search
        > > the list archives.  I also did some googling
        >
        > I think adding this to the google search may help
        >     concurrency-interest site:cs.oswego.edu
        >
        >
        > Larry
        >

        > _______________________________________________
        > Concurrency-interest mailing list
        > Concurrency-interest at altair.cs.oswego.edu
        > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest





-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080312/1d2979e9/attachment-0001.html 

From mthornton at optrak.co.uk  Wed Mar 12 05:24:18 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Wed, 12 Mar 2008 09:24:18 +0000
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <47D721CA.8050600@cs.oswego.edu>
References: <47D6942C.7000401@philosof.dk> <47D721CA.8050600@cs.oswego.edu>
Message-ID: <47D7A142.6020000@optrak.co.uk>

Doug Lea wrote:
> There are some further discussions of this in the list archives.
> We wish we knew a good way out of this.
>   
Extending generics to primitives would be a good way. It ought to be
possible in combination with reification (type available at runtime).
The JVM would then automatically generate those combinations which were
actually used by a process. I think this would offer greater
simplification of the fork-join package than the closure proposals.

Mark Thornton



From dl at cs.oswego.edu  Wed Mar 12 06:47:47 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Wed, 12 Mar 2008 06:47:47 -0400
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <47D7A142.6020000@optrak.co.uk>
References: <47D6942C.7000401@philosof.dk> <47D721CA.8050600@cs.oswego.edu>
	<47D7A142.6020000@optrak.co.uk>
Message-ID: <47D7B4D3.8030702@cs.oswego.edu>

Mark Thornton wrote:
> Doug Lea wrote:
>> There are some further discussions of this in the list archives.
>> We wish we knew a good way out of this.
>>   
> Extending generics to primitives would be a good way. It ought to be
> possible in combination with reification (type available at runtime).
> The JVM would then automatically generate those combinations which were
> actually used by a process. I think this would offer greater
> simplification of the fork-join package than the closure proposals.
> 

Right. I agree.
I meant that we wish we knew a good way out of this that
we could implement tomorrow :-)

-Doug


From J.Sevcik at sms.ed.ac.uk  Wed Mar 12 06:47:44 2008
From: J.Sevcik at sms.ed.ac.uk (Jaroslav Sevcik)
Date: Wed, 12 Mar 2008 10:47:44 +0000
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
References: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>	<NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
	<8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
Message-ID: <47D7B4D0.4050908@sms.ed.ac.uk>

Hi Samuel,

it depends on what you mean by 'visibility problems'. If you just mean 
something that is not sequentially consistent, here is a classical 
example (which is not completely artificial, just think of x as some 
'data' pointer and of y as a 'ready' flag):

Initially, x=y=0,
Thread 1: x = 1; y = 1
Thread 2: r1 = y; r2 = x

The result in question is r1 == 1 && r2 == 0.

Sequential consistency does not allow this. No interleaving leads to 
this result.

On the other hand, cache coherency does not prohibit this result in 
general. Note that processors often implement something stronger than 
cache coherence, so I believe that some (many?) cache coherent 
processors actually prohibit this outcome in their memory models. Here 
is a very short, incomplete, but hopefully correct overview (all 
processors below are cache coherent, Java Memory Model is not):

Intel Itanium: Allowed, see "A Formal Specification of Intel Itanium 
Processor Family Memory Ordering", 
http://www.intel.com/design/itanium/downloads/25142901.pdf, page 20, 
Table 4.

Intel 64 (x86), AMD: Prohibited, see  "Intel 64 Architecture Memory 
Ordering White Paper", 
http://www.intel.com/products/processor/manuals/318147.pdf, page  8, 
Table 2.1.

Sparc TSO: Prohibited,  see "The SPARC Architecture Manual, Version v9", 
http://www.sparc.org/standards/SPARCV9.pdf, Appendix D. TSO should be 
strictly stronger  than Intel 64.

Java Memory Model: Allowed. Just commit all the writes first, and then 
all the reads. "Java Language Specification, Third Edition", chapter 17 
(http://java.sun.com/docs/books/jls/third_edition/html/memory.html).

Another good source for Intel 64 is Richard Hudson's talk on "IA memory 
ordering", http://www.youtube.com/watch?v=WUfvvFD5tAA.

And of course, there is Doug Lea's cookbook 
(http://g.oswego.edu/dl/jmm/cookbook.html), which contains some more 
links to architecture specifications.

For more in-depth  discussion of cache coherency and its difference from 
other memory models I would recommend the PhD dissertation of Jalal 
Kawash: "Limitations and Capabilities of Weak Memory Consistency 
Systems", http://pages.cpsc.ucalgary.ca/~kawash/papers/dissertation.pdf.

I hope this helps.

Jaroslav

R Samuel Klatchko wrote:
>
> David-
>
> Sorry, I didn't explain myself well.  It's not that I don't care about 
> ordering and latency; rather, I am just trying to understand why 
> things happen and believe I already understand what causes 
> ordering/latency issues.  But I was always baffled by why visibility 
> problems could occur (other then visibility problems caused by 
> compiler/VM optimizations) with cache coherency (everything I have 
> found and read so far on cache coherency not only focus on hardware 
> based, but don't even mention software directed coherency).
>
> Thanks for all your help.
>
> samuel
>
>
> On Wed, Mar 12, 2008 at 12:49 PM, David Holmes 
> <dcholmes at optusnet.com.au <mailto:dcholmes at optusnet.com.au>> wrote:
>
>     Samuel,
>      
>     If you don't care about latency or ordering issues (which tend to
>     be exactly the things we do care about!) then visibility on a
>     hardware cache coherent system is not an issue - a write to a
>     variable will become visible within a bounded time.
>      
>     I'm not sure which architectures mandate hardware cache coherency,
>     vs. implementations of those architectures that happen to provide
>     them. The Alpha architecture is the main example I know of a
>     system that supports software coherency. If you need more details
>     I'd suggest visiting a computer architecture forum/newsgroup; or
>     else go grab the relevant architecture specifications if you can
>     (IA32, IA64, PPC are readily available online - not sure about SPARC.)
>      
>     Cheers,
>     David Holmes
>
>         -----Original Message-----
>         *From:* concurrency-interest-bounces at cs.oswego.edu
>         <mailto:concurrency-interest-bounces at cs.oswego.edu>
>         [mailto:concurrency-interest-bounces at cs.oswego.edu
>         <mailto:concurrency-interest-bounces at cs.oswego.edu>]*On Behalf
>         Of *R Samuel Klatchko
>         *Sent:* Wednesday, 12 March 2008 4:54 PM
>         *To:* Concurrency-interest at cs.oswego.edu
>         <mailto:Concurrency-interest at cs.oswego.edu>
>         *Cc:* dholmes at ieee.org <mailto:dholmes at ieee.org>
>         *Subject:* Re: [concurrency-interest] visibility vs. cache
>         coherency
>
>
>         David-
>
>         Thanks for the info.
>
>         While I know this discussion group prefers to focus on the
>         JMM/JSR-133, I am looking to understand what is going on at
>         the hardware level (both because I like to learn how things
>         work and because I still continue to work in C/C++ so until it
>         has a better memory model, how hardware works will help me there).
>
>         It sounds to me like it is fair to say that if the hardware
>         you are running on supports hardware cache coherency and if
>         data is written to memory, there should not be visibility
>         problems.  What I am wondering about is whether thread 1 can
>         change memory location L from V to V' yet thread 2 continues
>         to read the value V from L for an unbounded time.
>
>         I am not thinking about short delays due to memory latency
>         issues or ordering problems.  I am also not thinking about
>         issues where thread 2 never sees the value from thread 1
>         because thread 3 also wrote the same memory location around
>         the same time and thread 2 sees that value.
>
>         Finally, does anyone know how prevalent hardware cache
>         coherent systems are as compared to software directed cache
>         coherent systems?
>
>         Thanks,
>         samuel
>
>
>         On Wed, Mar 12, 2008 at 5:23 AM, David Holmes
>         <dcholmes at optusnet.com.au <mailto:dcholmes at optusnet.com.au>>
>         wrote:
>
>             Also you'll find more details/discussion on the Java
>             Memory Model list:
>
>             http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion
>
>             The simple (and therefore potentially misleading) answer
>             is that hardware
>             cache coherent systems don't introduce visibility problems
>             related to the
>             operation of memory at the hardware level. Systems that
>             require software
>             directed cache coherency (the alpha architecture is an
>             example) can have
>             visibility problems if the compiler doesn't generate those
>             coherency
>             instructions where they are needed.
>
>             But aside from the hardware level, visibility arises from
>             the actions of the
>             VM and in particular the code generated by the JIT. For
>             example, without
>             something forcing it to do otherwise (i.e. a
>             happens-before ordering) the
>             JIT might cache a read of a field in a register and not
>             reload it, thereby
>             missing concurrent updates to that field.
>
>             Cheers,
>             David Holmes
>
>             > -----Original Message-----
>             > From: concurrency-interest-bounces at cs.oswego.edu
>             <mailto:concurrency-interest-bounces at cs.oswego.edu>
>             > [mailto:concurrency-interest-bounces at cs.oswego.edu
>             <mailto:concurrency-interest-bounces at cs.oswego.edu>]On
>             Behalf Of Larry
>             > Riedel
>             > Sent: Wednesday, 12 March 2008 2:03 AM
>             > To: Concurrency-interest at cs.oswego.edu
>             <mailto:Concurrency-interest at cs.oswego.edu>
>             > Cc: R Samuel Klatchko
>             > Subject: Re: [concurrency-interest] visibility vs. cache
>             coherency
>             >
>             >
>             >
>             > > there does not appear to be a way to search
>             > > the list archives.  I also did some googling
>             >
>             > I think adding this to the google search may help
>             >     concurrency-interest site:cs.oswego.edu
>             <http://cs.oswego.edu>
>             >
>             >
>             > Larry
>             >
>             > _______________________________________________
>             > Concurrency-interest mailing list
>             > Concurrency-interest at altair.cs.oswego.edu
>             <mailto:Concurrency-interest at altair.cs.oswego.edu>
>             >
>             http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


From Online at stolsvik.com  Wed Mar 12 07:14:28 2008
From: Online at stolsvik.com (=?UTF-8?B?RW5kcmUgU3TDuGxzdmlr?=)
Date: Wed, 12 Mar 2008 12:14:28 +0100
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
Message-ID: <47D7BB14.1040801@Stolsvik.com>

David Holmes wrote:
> Samuel,
>  
> If you don't care about latency or ordering issues (which tend to be 
> exactly the things we do care about!) then visibility on a hardware 
> cache coherent system is not an issue - a write to a variable will 
> become visible within a bounded time.

What if, as you mention, the compiler caches the variable in some 
register, and this happens to be within some main loop of the program? 
Without explicit happens-before edges (syncs, locks or volatiles) 
between the threads concerned, couldn't this variable just be cached 
literally forever - in regards to the program flow?

PS: This might be interesting:
  http://www.cs.umd.edu/~pugh/java/memoryModel/issues.pdf

Endre.

From jseigh_cp00 at xemaps.com  Wed Mar 12 07:24:49 2008
From: jseigh_cp00 at xemaps.com (Joseph Seigh)
Date: Wed, 12 Mar 2008 06:24:49 -0500
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
References: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
	<8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
Message-ID: <47D7BD81.8030900@xemaps.com>

R Samuel Klatchko wrote:
>
> David-
>
> Sorry, I didn't explain myself well.  It's not that I don't care about 
> ordering and latency; rather, I am just trying to understand why 
> things happen and believe I already understand what causes 
> ordering/latency issues.  But I was always baffled by why visibility 
> problems could occur (other then visibility problems caused by 
> compiler/VM optimizations) with cache coherency (everything I have 
> found and read so far on cache coherency not only focus on hardware 
> based, but don't even mention software directed coherency).

Most cache implementations are transparent, meaning you can't detect the 
presence of cache except
for performance effects.  It may be that the memory model has build into 
it some observable effects
of cache such as allowing reads of stale data but you'd have a lot of 
work factoring out the differences
in behavior w/ and w/o cache.

It only matters if you're implementing synchronization constructs.  If 
you're doing that then you
need to know what you're doing and I don't mean the memory model but 
what the actual
synchronization guarantees are.  The latter is a bit difficult since 
there aren't exactly a lot of
formal definitions of synchronization laying about that you can work off of.

--
Joe Seigh

From tom.seelbach at gmail.com  Wed Mar 12 08:11:29 2008
From: tom.seelbach at gmail.com (Tom Seelbach)
Date: Wed, 12 Mar 2008 08:11:29 -0400
Subject: [concurrency-interest] backport: what is the best way to
	acknowledge usage of backport?
Message-ID: <47D7C871.9010207@gmail.com>

Hi,
Apache Axis2 was recently updated to depend on backport-util-concurrent 
3.1 instead of 2.2.   Axis2 distributes a copy of a backport license 
like this:    
http://svn.apache.org/viewvc/webservices/axis2/trunk/java/legal/backport-util-concurrent-LICENSE.txt?revision=553578&view=markup 


Looks like its outdated.  I looked at the backport 3.1 code and README 
and it seems that the attribution to Sun for the CopyOnWriteArrayList 
hasn't been needed since 2.0_01?

Could someone recommend the best way to update the axis2 license for 
backport?
I see some relevant info in 3 files: LEGAL, README.html (License 
section) and LICENSE.html.
It's kinda confusing to have the legal and license info in 3 files.
Maybe it's best that in axis2 we combine them like this:

========================================================
Acknowledgements:
backport-util-concurrent is based in large part on the public
domain sources from:
   1) JSR166,
   2) package dl.util.concurrent,
   3) Doug Lea's "collections" package.

This software is released to the public domain
( http://creativecommons.org/licenses/publicdomain )
in the spirit of the original code written by Doug Lea.
The code can be used for any purpose, modified, and redistributed
without acknowledgment. No warranty is provided, either express or implied.

Following  is a copy of http://creativecommons.org/licenses/publicdomain

Creative Commons Public Domain
Copyright-Only Dedication (based on United States law) or Public Domain 
Certification

The person or persons who have associated work with this document
(the "Dedicator" or "Certifier") hereby either (a) certifies that, to the
best of his knowledge, the work of authorship identified is in the
public domain of the country from which the work is published, or (b)
hereby dedicates whatever copyright the dedicators holds in the work of
authorship identified below (the "Work") to the public domain. A
certifier, moreover, dedicates any copyright interest he may have in the
associated work, and for these purposes, is described as a "dedicator"
below.

A certifier has taken reasonable steps to verify
the copyright status of this work. Certifier recognizes that his good
faith efforts may not shield him from liability if in fact the work
certified is not in the public domain.

Dedicator makes this dedication for the benefit of the public at large and
to the detriment of the Dedicator's heirs and successors. Dedicator intends
this dedication to be an overt act of relinquishment in perpetuity of
all present and future rights under copyright law, whether vested or
contingent, in the Work. Dedicator understands that such relinquishment
of all rights includes the relinquishment of all rights to enforce (by
lawsuit or otherwise) those copyrights in the Work.

Dedicator recognizes that, once placed in the public domain, the Work 
may be
freely reproduced, distributed, transmitted, used, modified, built
upon, or otherwise exploited by anyone for any purpose, commercial or
non-commercial, and in any way, including by methods that have not yet
been invented or conceived.
===============================

Does this make sense?
thanks,
Tom


From phil.goodwin at gmail.com  Wed Mar 12 14:37:47 2008
From: phil.goodwin at gmail.com (Phil Goodwin)
Date: Wed, 12 Mar 2008 11:37:47 -0700
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <47D721CA.8050600@cs.oswego.edu>
References: <47D6942C.7000401@philosof.dk> <47D721CA.8050600@cs.oswego.edu>
Message-ID: <3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>

On Tue, Mar 11, 2008 at 5:20 PM, Doug Lea <dl at cs.oswego.edu> wrote:

> Rune Schjellerup Philosof wrote:
>


> > ParallelFloatArray isn't provided because you assume people only use
> double?
>
> Not exactly. It isn't provided because the number of support classes
> goes up with the square of the number of primitive specializations
> provided (each multiplied by filter and mapping views). Stopping
> at one integral type (long) and one floating (double) is not ideal,
> but the alternative of adding thousands of lines of nearly
> redundant code to support float (and int and then what about the
> others) is even less ideal.
>
> There are some further discussions of this in the list archives.
> We wish we knew a good way out of this.


Would you consider adding code generation to the development/build process?
The String Template library that comes with ANTLR seems like the right kind
of solution for this problem. Both the code and the tests could be
generated. The cleanest way to go seems to be to generate the code into the
source tree in a pre-build step and to keep both under revision control.
Then you can distribute the generated code just as if it had been written by
hand. After the initial set up cost the burden of maintaining the code
across all primitive types nearly approaches that of maintaining it for a
single type.

Phil
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080312/0c740f04/attachment.html 

From mthornton at optrak.co.uk  Wed Mar 12 15:20:01 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Wed, 12 Mar 2008 19:20:01 +0000
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>
References: <47D6942C.7000401@philosof.dk> <47D721CA.8050600@cs.oswego.edu>
	<3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>
Message-ID: <47D82CE1.9020901@optrak.co.uk>

Phil Goodwin wrote:
> On Tue, Mar 11, 2008 at 5:20 PM, Doug Lea <dl at cs.oswego.edu 
> <mailto:dl at cs.oswego.edu>> wrote:
>
>     Rune Schjellerup Philosof wrote:
>
>  
>
>     > ParallelFloatArray isn't provided because you assume people only
>     use double?
>
>     Not exactly. It isn't provided because the number of support classes
>     goes up with the square of the number of primitive specializations
>     provided (each multiplied by filter and mapping views). Stopping
>     at one integral type (long) and one floating (double) is not ideal,
>     but the alternative of adding thousands of lines of nearly
>     redundant code to support float (and int and then what about the
>     others) is even less ideal.
>
>     There are some further discussions of this in the list archives.
>     We wish we knew a good way out of this.
>
>
> Would you consider adding code generation to the development/build 
> process? The String Template library that comes with ANTLR seems like 
> the right kind of solution for this problem. Both the code and the 
> tests could be generated. The cleanest way to go seems to be to 
> generate the code into the source tree in a pre-build step and to keep 
> both under revision control. Then you can distribute the generated 
> code just as if it had been written by hand. After the initial set up 
> cost the burden of maintaining the code across all primitive types 
> nearly approaches that of maintaining it for a single type.
>
> Phil
The NIO *Buffer classes seem to be generated in this way. However in our 
case you still get the explosion of interfaces and methods in the 
JavaDoc even if you don't have to write all the implementations.

Mark Thornton


From hans.boehm at hp.com  Wed Mar 12 15:25:44 2008
From: hans.boehm at hp.com (Boehm, Hans)
Date: Wed, 12 Mar 2008 19:25:44 +0000
Subject: [concurrency-interest] visibility vs. cache coherency
In-Reply-To: <47D7B4D0.4050908@sms.ed.ac.uk>
References: <8eddd5030803112354u1f4e0be7he79aebda57f95f32@mail.gmail.com>
	<NFBBKALFDCPFIDBNKAPCOEOGHKAA.dcholmes@optusnet.com.au>
	<8eddd5030803120047j3135c509q80865e437445e474@mail.gmail.com>
	<47D7B4D0.4050908@sms.ed.ac.uk>
Message-ID: <EB8E0FF63AB2414693DB20D50E863AE81384EEC3@G3W0634.americas.hpqcorp.net>

At the hardware level, my understanding is that a big issue is the presence of write buffers, which may delay making stores visible to the cache that participates in the coherency protocol.  The 1995 tutorial by Adve and Gharachorloo ("Shared Memory Consistency Models: A Tutorial") is another good starting place.

Hans

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu] On Behalf
> Of Jaroslav Sevcik
> Sent: Wednesday, March 12, 2008 3:48 AM
> To: rsk at moocat.org
> Cc: Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] visibility vs. cache coherency
>
> Hi Samuel,
>
> it depends on what you mean by 'visibility problems'. If you
> just mean something that is not sequentially consistent, here
> is a classical example (which is not completely artificial,
> just think of x as some 'data' pointer and of y as a 'ready' flag):
>
> Initially, x=y=0,
> Thread 1: x = 1; y = 1
> Thread 2: r1 = y; r2 = x
>
> The result in question is r1 == 1 && r2 == 0.
>
> Sequential consistency does not allow this. No interleaving
> leads to this result.
>
> On the other hand, cache coherency does not prohibit this
> result in general. Note that processors often implement
> something stronger than cache coherence, so I believe that
> some (many?) cache coherent processors actually prohibit this
> outcome in their memory models. Here is a very short,
> incomplete, but hopefully correct overview (all processors
> below are cache coherent, Java Memory Model is not):
>
> Intel Itanium: Allowed, see "A Formal Specification of Intel
> Itanium Processor Family Memory Ordering",
> http://www.intel.com/design/itanium/downloads/25142901.pdf,
> page 20, Table 4.
>
> Intel 64 (x86), AMD: Prohibited, see  "Intel 64 Architecture
> Memory Ordering White Paper",
> http://www.intel.com/products/processor/manuals/318147.pdf,
> page  8, Table 2.1.
>
> Sparc TSO: Prohibited,  see "The SPARC Architecture Manual,
> Version v9", http://www.sparc.org/standards/SPARCV9.pdf,
> Appendix D. TSO should be strictly stronger  than Intel 64.
>
> Java Memory Model: Allowed. Just commit all the writes first,
> and then all the reads. "Java Language Specification, Third
> Edition", chapter 17
> (http://java.sun.com/docs/books/jls/third_edition/html/memory.html).
>
> Another good source for Intel 64 is Richard Hudson's talk on
> "IA memory ordering", http://www.youtube.com/watch?v=WUfvvFD5tAA.
>
> And of course, there is Doug Lea's cookbook
> (http://g.oswego.edu/dl/jmm/cookbook.html), which contains
> some more links to architecture specifications.
>
> For more in-depth  discussion of cache coherency and its
> difference from other memory models I would recommend the PhD
> dissertation of Jalal
> Kawash: "Limitations and Capabilities of Weak Memory
> Consistency Systems",
> http://pages.cpsc.ucalgary.ca/~kawash/papers/dissertation.pdf.
>
> I hope this helps.
>
> Jaroslav
>
> R Samuel Klatchko wrote:
> >
> > David-
> >
> > Sorry, I didn't explain myself well.  It's not that I don't
> care about
> > ordering and latency; rather, I am just trying to understand why
> > things happen and believe I already understand what causes
> > ordering/latency issues.  But I was always baffled by why
> visibility
> > problems could occur (other then visibility problems caused by
> > compiler/VM optimizations) with cache coherency (everything I have
> > found and read so far on cache coherency not only focus on hardware
> > based, but don't even mention software directed coherency).
> >
> > Thanks for all your help.
> >
> > samuel
> >
> >
> > On Wed, Mar 12, 2008 at 12:49 PM, David Holmes
> > <dcholmes at optusnet.com.au <mailto:dcholmes at optusnet.com.au>> wrote:
> >
> >     Samuel,
> >
> >     If you don't care about latency or ordering issues
> (which tend to
> >     be exactly the things we do care about!) then visibility on a
> >     hardware cache coherent system is not an issue - a write to a
> >     variable will become visible within a bounded time.
> >
> >     I'm not sure which architectures mandate hardware cache
> coherency,
> >     vs. implementations of those architectures that happen
> to provide
> >     them. The Alpha architecture is the main example I know of a
> >     system that supports software coherency. If you need
> more details
> >     I'd suggest visiting a computer architecture forum/newsgroup; or
> >     else go grab the relevant architecture specifications if you can
> >     (IA32, IA64, PPC are readily available online - not sure about
> > SPARC.)
> >
> >     Cheers,
> >     David Holmes
> >
> >         -----Original Message-----
> >         *From:* concurrency-interest-bounces at cs.oswego.edu
> >         <mailto:concurrency-interest-bounces at cs.oswego.edu>
> >         [mailto:concurrency-interest-bounces at cs.oswego.edu
> >
> <mailto:concurrency-interest-bounces at cs.oswego.edu>]*On Behalf
> >         Of *R Samuel Klatchko
> >         *Sent:* Wednesday, 12 March 2008 4:54 PM
> >         *To:* Concurrency-interest at cs.oswego.edu
> >         <mailto:Concurrency-interest at cs.oswego.edu>
> >         *Cc:* dholmes at ieee.org <mailto:dholmes at ieee.org>
> >         *Subject:* Re: [concurrency-interest] visibility vs. cache
> >         coherency
> >
> >
> >         David-
> >
> >         Thanks for the info.
> >
> >         While I know this discussion group prefers to focus on the
> >         JMM/JSR-133, I am looking to understand what is going on at
> >         the hardware level (both because I like to learn how things
> >         work and because I still continue to work in C/C++
> so until it
> >         has a better memory model, how hardware works will
> help me there).
> >
> >         It sounds to me like it is fair to say that if the hardware
> >         you are running on supports hardware cache coherency and if
> >         data is written to memory, there should not be visibility
> >         problems.  What I am wondering about is whether thread 1 can
> >         change memory location L from V to V' yet thread 2 continues
> >         to read the value V from L for an unbounded time.
> >
> >         I am not thinking about short delays due to memory latency
> >         issues or ordering problems.  I am also not thinking about
> >         issues where thread 2 never sees the value from thread 1
> >         because thread 3 also wrote the same memory location around
> >         the same time and thread 2 sees that value.
> >
> >         Finally, does anyone know how prevalent hardware cache
> >         coherent systems are as compared to software directed cache
> >         coherent systems?
> >
> >         Thanks,
> >         samuel
> >
> >
> >         On Wed, Mar 12, 2008 at 5:23 AM, David Holmes
> >         <dcholmes at optusnet.com.au <mailto:dcholmes at optusnet.com.au>>
> >         wrote:
> >
> >             Also you'll find more details/discussion on the Java
> >             Memory Model list:
> >
> >
> >
> http://mailman.cs.umd.edu/mailman/listinfo/javamemorymodel-discussion
> >
> >             The simple (and therefore potentially misleading) answer
> >             is that hardware
> >             cache coherent systems don't introduce
> visibility problems
> >             related to the
> >             operation of memory at the hardware level. Systems that
> >             require software
> >             directed cache coherency (the alpha architecture is an
> >             example) can have
> >             visibility problems if the compiler doesn't
> generate those
> >             coherency
> >             instructions where they are needed.
> >
> >             But aside from the hardware level, visibility
> arises from
> >             the actions of the
> >             VM and in particular the code generated by the JIT. For
> >             example, without
> >             something forcing it to do otherwise (i.e. a
> >             happens-before ordering) the
> >             JIT might cache a read of a field in a register and not
> >             reload it, thereby
> >             missing concurrent updates to that field.
> >
> >             Cheers,
> >             David Holmes
> >
> >             > -----Original Message-----
> >             > From: concurrency-interest-bounces at cs.oswego.edu
> >             <mailto:concurrency-interest-bounces at cs.oswego.edu>
> >             > [mailto:concurrency-interest-bounces at cs.oswego.edu
> >             <mailto:concurrency-interest-bounces at cs.oswego.edu>]On
> >             Behalf Of Larry
> >             > Riedel
> >             > Sent: Wednesday, 12 March 2008 2:03 AM
> >             > To: Concurrency-interest at cs.oswego.edu
> >             <mailto:Concurrency-interest at cs.oswego.edu>
> >             > Cc: R Samuel Klatchko
> >             > Subject: Re: [concurrency-interest]
> visibility vs. cache
> >             coherency
> >             >
> >             >
> >             >
> >             > > there does not appear to be a way to search
> >             > > the list archives.  I also did some googling
> >             >
> >             > I think adding this to the google search may help
> >             >     concurrency-interest site:cs.oswego.edu
> >             <http://cs.oswego.edu>
> >             >
> >             >
> >             > Larry
> >             >
> >             > _______________________________________________
> >             > Concurrency-interest mailing list
> >             > Concurrency-interest at altair.cs.oswego.edu
> >             <mailto:Concurrency-interest at altair.cs.oswego.edu>
> >             >
> >
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >
> ----------------------------------------------------------------------
> > --
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From holger at wizards.de  Wed Mar 12 15:33:19 2008
From: holger at wizards.de (=?ISO-8859-1?Q?Holger_Hoffst=E4tte?=)
Date: Wed, 12 Mar 2008 20:33:19 +0100
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>
References: <47D6942C.7000401@philosof.dk> <47D721CA.8050600@cs.oswego.edu>
	<3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>
Message-ID: <47D82FFF.8060604@wizards.de>

Phil Goodwin wrote:
> On Tue, Mar 11, 2008 at 5:20 PM, Doug Lea <dl at cs.oswego.edu 
> <mailto:dl at cs.oswego.edu>> wrote:
> 
>     Not exactly. It isn't provided because the number of support classes
>     goes up with the square of the number of primitive specializations
>     provided (each multiplied by filter and mapping views). Stopping[..]
> 
> Would you consider adding code generation to the development/build 
> process? The String Template library that comes with ANTLR seems like 
> the right kind of solution for this problem. Both the code and the tests 

A great suggestion. The fastutil library (http://fastutil.dsi.unimi.it/) 
does exactly that (though not with StringTemplate) and it works very well; 
the generated code is fully typesafe and even has covariant return types. 
The only downside is the huge size of the jar due to the number of 
generated classes, though this is generally not a runtime problem.
It would certainly drastically reduce the maintenance efforts; I recently 
checked out the source for jsr166y and was surprised by the huge number of 
type safety warnings and inconistencies.

-h

From dl at cs.oswego.edu  Thu Mar 13 07:13:22 2008
From: dl at cs.oswego.edu (Doug Lea)
Date: Thu, 13 Mar 2008 07:13:22 -0400
Subject: [concurrency-interest] ParallelFloatArray
In-Reply-To: <47D82FFF.8060604@wizards.de>
References: <47D6942C.7000401@philosof.dk>
	<47D721CA.8050600@cs.oswego.edu>	<3dbbdf1d0803121137n346b010dycf165f435d4d67a7@mail.gmail.com>
	<47D82FFF.8060604@wizards.de>
Message-ID: <47D90C52.5000300@cs.oswego.edu>

Holger Hoffst?tte wrote:
>>
>> Would you consider adding code generation to the development/build 
>> process? The String Template library that comes with ANTLR seems like 
>> the right kind of solution for this problem. Both the code and the tests 
> 
> A great suggestion. The fastutil library (http://fastutil.dsi.unimi.it/) 
> does exactly that (though not with StringTemplate) and it works very well; 
> the generated code is fully typesafe and even has covariant return types. 

Parallel*Array would encounter problems that they don't though,
because of all the cross-dependencies among classes. For
example pa.withMapping(doubleFunction).withMapping(floatFunction)....
Under anything less than language-level integration of primitives
with generics, we'd need to make some API compromises to avoid
at least some of them. This may still be worth doing though.

BTW, for one-shots of this kind of problem, check out
Paul Tyma's ClassHat: http://www.classhat.com/ (This URL seems
not to be working today.)

> It would certainly drastically reduce the maintenance efforts; I recently 
> checked out the source for jsr166y and was surprised by the huge number of 
> type safety warnings and inconistencies.
> 

Some of these are inevitable any time you mix generics with arrays. But
there are a few needless ones that can/will be removed by adjusting some
parameter types etc.

-Doug





From pugh at cs.umd.edu  Fri Mar 14 15:28:30 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Fri, 14 Mar 2008 15:28:30 -0400
Subject: [concurrency-interest] New bug pattern, way to common
Message-ID: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>

I identified a new concurrency bug pattern that is way too common:

Synchronizing on a field in order to prevent concurrent access to that  
field.

For example:
   /**
      * Add a lifecycle event listener to this component.
      *
      * @param listener The listener to add
      */
     public void addInstanceListener(InstanceListener listener) {

       synchronized (listeners) {
           InstanceListener results[] =
             new InstanceListener[listeners.length + 1];
           for (int i = 0; i < listeners.length; i++)
               results[i] = listeners[i];
           results[listeners.length] = listener;
           listeners = results;
       }

     }

There are 26 occurrences of this pattern in apache-tomcat.

Of course, if the field in question is of type Boolean, it becomes  
exceptionally problematical.

Bill

From crazybob at crazybob.org  Fri Mar 14 16:08:02 2008
From: crazybob at crazybob.org (Bob Lee)
Date: Fri, 14 Mar 2008 13:08:02 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
Message-ID: <a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>

Nice one.

On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu> wrote:

> I identified a new concurrency bug pattern that is way too common:
>
> Synchronizing on a field in order to prevent concurrent access to that
> field.
>
> For example:
>   /**
>      * Add a lifecycle event listener to this component.
>      *
>      * @param listener The listener to add
>      */
>     public void addInstanceListener(InstanceListener listener) {
>
>       synchronized (listeners) {
>           InstanceListener results[] =
>             new InstanceListener[listeners.length + 1];
>           for (int i = 0; i < listeners.length; i++)
>               results[i] = listeners[i];
>           results[listeners.length] = listener;
>           listeners = results;
>       }
>
>     }
>
> There are 26 occurrences of this pattern in apache-tomcat.
>
> Of course, if the field in question is of type Boolean, it becomes
> exceptionally problematical.
>
> Bill
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080314/f2b18db1/attachment.html 

From josh at bloch.us  Fri Mar 14 16:32:57 2008
From: josh at bloch.us (Joshua Bloch)
Date: Fri, 14 Mar 2008 13:32:57 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
Message-ID: <b097ac510803141332l78600fabv5026d2941f6a3a9c@mail.gmail.com>

Bill,

Ouch!  "Synchronize only on final fields."

          Josh

P.S.  (No, I hadn't said that previously, but I will now.)



On Fri, Mar 14, 2008 at 1:08 PM, Bob Lee <crazybob at crazybob.org> wrote:

> Nice one.
>
>
> On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu> wrote:
>
> > I identified a new concurrency bug pattern that is way too common:
> >
> > Synchronizing on a field in order to prevent concurrent access to that
> > field.
> >
> > For example:
> >   /**
> >      * Add a lifecycle event listener to this component.
> >      *
> >      * @param listener The listener to add
> >      */
> >     public void addInstanceListener(InstanceListener listener) {
> >
> >       synchronized (listeners) {
> >           InstanceListener results[] =
> >             new InstanceListener[listeners.length + 1];
> >           for (int i = 0; i < listeners.length; i++)
> >               results[i] = listeners[i];
> >           results[listeners.length] = listener;
> >           listeners = results;
> >       }
> >
> >     }
> >
> > There are 26 occurrences of this pattern in apache-tomcat.
> >
> > Of course, if the field in question is of type Boolean, it becomes
> > exceptionally problematical.
> >
> > Bill
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080314/6ade018c/attachment.html 

From mthornton at optrak.co.uk  Fri Mar 14 16:44:42 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Fri, 14 Mar 2008 20:44:42 +0000
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
Message-ID: <47DAE3BA.8010907@optrak.co.uk>

Bill Pugh wrote:
> I identified a new concurrency bug pattern that is way too common:
>
> Synchronizing on a field in order to prevent concurrent access to that  
> field.
>
>   
Intellij IDEA gives a warning if you synchronize on a non final field.

Mark Thornton


From Thomas.Hawtin at Sun.COM  Fri Mar 14 17:56:07 2008
From: Thomas.Hawtin at Sun.COM (Thomas Hawtin)
Date: Fri, 14 Mar 2008 14:56:07 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
Message-ID: <47DAF477.4010808@Sun.COM>

Bob Lee wrote:
> Nice one.
> 
> On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu 
> <mailto:pugh at cs.umd.edu>> wrote:
> 
>     I identified a new concurrency bug pattern that is way too common:
> 
>     Synchronizing on a field in order to prevent concurrent access to that
>     field.

I think it was Bitter Java that had an example of a read-write lock 
which did the same thing. You'd think that class would take care to get 
it right.

Tom Hawtin

From dcholmes at optusnet.com.au  Sat Mar 15 03:49:35 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sat, 15 Mar 2008 17:49:35 +1000
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEPDHKAA.dcholmes@optusnet.com.au>

Bill Pugh writes:
> I identified a new concurrency bug pattern that is way too common:
>
> Synchronizing on a field in order to prevent concurrent access to that
> field.
>
> For example:
>    /**
>       * Add a lifecycle event listener to this component.
>       *
>       * @param listener The listener to add
>       */
>      public void addInstanceListener(InstanceListener listener) {
>
>        synchronized (listeners) {
>            InstanceListener results[] =
>              new InstanceListener[listeners.length + 1];
>            for (int i = 0; i < listeners.length; i++)
>                results[i] = listeners[i];
>            results[listeners.length] = listener;
>            listeners = results;
>        }
>
>      }
>
> There are 26 occurrences of this pattern in apache-tomcat.
>
> Of course, if the field in question is of type Boolean, it becomes
> exceptionally problematical.

I've seen the Boolean case a number of times in forum postings. Typically it
is used with a wait/notify predicated on the Boolean's value. So at least in
that case you get an IllegalMonitorStateException. Though the posters are
always baffled as to why.

Now for the folks out there that are still new to all this and can't quite
see what the problem is, consider this: Suppose listeners refers to array A
and Thread-1 is busy making a new array B, when Thread-2 tries to do the
same. Thread-2 blocks on the lock for array A. When Thread-1 is done with
the copy it sets listeners to refer to array B and releases the lock on
array A. Thread-2 now locks array A and then starts to make a copy of array
B. Meanwhile Thread-3 comes along and grabs the lock of array B and so two
threads are now making copies of array B because they are using different
locks. At a minimum one of the new listeners will get lost, and its possible
that one thread will get ArrayIndexOutOfBoundsException as the listeners
reference (and hence the length) can change at any point during the method.
Ouch indeed!

Plus there are memory model issues due to synchronization on different
locks - but the lack of mutual exclusion is much more serious.

Nice catch Bill!

Cheers,
David Holmes


From jmanson at cs.umd.edu  Sun Mar 16 15:15:36 2008
From: jmanson at cs.umd.edu (Jeremy Manson)
Date: Sun, 16 Mar 2008 12:15:36 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <b097ac510803141332l78600fabv5026d2941f6a3a9c@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>	<a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
	<b097ac510803141332l78600fabv5026d2941f6a3a9c@mail.gmail.com>
Message-ID: <47DD71D8.7020504@cs.umd.edu>

Josh,

The following may be obvious. :)

I think that is only part of the answer.  In this case, you really want 
a completely separate object ("private ReentrantLock listenersLock") 
that controls the synchronization on listeners.

I think we need to emphasize that synchronization is orthogonal to 
program logic and data.  Not that this is a particularly original 
observation, but I think Java made a mistake by integrating 
synchronization and control logic.  We see it over and over again in 
this notion that objects provide their own synchronization.

There are other benefits to this approach, too, like the fact that you 
have much better control over the lock of an entirely separate lock 
object than you do over an arbitrary instance of an object whose methods 
may acquire its lock.

					Jeremy

Joshua Bloch wrote:
> Bill,
>  
> Ouch!  "Synchronize only on final fields."
>  
>           Josh
>  
> P.S.  (No, I hadn't said that previously, but I will now.)
> 
> 
>  
> On Fri, Mar 14, 2008 at 1:08 PM, Bob Lee <crazybob at crazybob.org 
> <mailto:crazybob at crazybob.org>> wrote:
> 
>     Nice one.
> 
> 
>     On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu
>     <mailto:pugh at cs.umd.edu>> wrote:
> 
>         I identified a new concurrency bug pattern that is way too common:
> 
>         Synchronizing on a field in order to prevent concurrent access
>         to that
>         field.
> 
>         For example:
>           /**
>              * Add a lifecycle event listener to this component.
>              *
>              * @param listener The listener to add
>              */
>             public void addInstanceListener(InstanceListener listener) {
> 
>               synchronized (listeners) {
>                   InstanceListener results[] =
>                     new InstanceListener[listeners.length + 1];
>                   for (int i = 0; i < listeners.length; i++)
>                       results[i] = listeners[i];
>                   results[listeners.length] = listener;
>                   listeners = results;
>               }
> 
>             }
> 
>         There are 26 occurrences of this pattern in apache-tomcat.
> 
>         Of course, if the field in question is of type Boolean, it becomes
>         exceptionally problematical.
> 
>         Bill
>         _______________________________________________
>         Concurrency-interest mailing list
>         Concurrency-interest at altair.cs.oswego.edu
>         <mailto:Concurrency-interest at altair.cs.oswego.edu>
>         http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> 
> 
> 
> ------------------------------------------------------------------------
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From josh at bloch.us  Sun Mar 16 15:57:16 2008
From: josh at bloch.us (Joshua Bloch)
Date: Sun, 16 Mar 2008 12:57:16 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <47DD71D8.7020504@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
	<b097ac510803141332l78600fabv5026d2941f6a3a9c@mail.gmail.com>
	<47DD71D8.7020504@cs.umd.edu>
Message-ID: <b097ac510803161257n4e5670dcm706aacc39bd1222@mail.gmail.com>

Jeremy,

No worries, I've always believed that.

        Josh

On Sun, Mar 16, 2008 at 12:15 PM, Jeremy Manson <jmanson at cs.umd.edu> wrote:

> Josh,
>
> The following may be obvious. :)
>
> I think that is only part of the answer.  In this case, you really want
> a completely separate object ("private ReentrantLock listenersLock")
> that controls the synchronization on listeners.
>
> I think we need to emphasize that synchronization is orthogonal to
> program logic and data.  Not that this is a particularly original
> observation, but I think Java made a mistake by integrating
> synchronization and control logic.  We see it over and over again in
> this notion that objects provide their own synchronization.
>
> There are other benefits to this approach, too, like the fact that you
> have much better control over the lock of an entirely separate lock
> object than you do over an arbitrary instance of an object whose methods
> may acquire its lock.
>
>                                        Jeremy
>
> Joshua Bloch wrote:
> > Bill,
> >
> > Ouch!  "Synchronize only on final fields."
> >
> >           Josh
> >
> > P.S.  (No, I hadn't said that previously, but I will now.)
> >
> >
> >
> > On Fri, Mar 14, 2008 at 1:08 PM, Bob Lee <crazybob at crazybob.org
> > <mailto:crazybob at crazybob.org>> wrote:
> >
> >     Nice one.
> >
> >
> >     On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu
> >     <mailto:pugh at cs.umd.edu>> wrote:
> >
> >         I identified a new concurrency bug pattern that is way too
> common:
> >
> >         Synchronizing on a field in order to prevent concurrent access
> >         to that
> >         field.
> >
> >         For example:
> >           /**
> >              * Add a lifecycle event listener to this component.
> >              *
> >              * @param listener The listener to add
> >              */
> >             public void addInstanceListener(InstanceListener listener) {
> >
> >               synchronized (listeners) {
> >                   InstanceListener results[] =
> >                     new InstanceListener[listeners.length + 1];
> >                   for (int i = 0; i < listeners.length; i++)
> >                       results[i] = listeners[i];
> >                   results[listeners.length] = listener;
> >                   listeners = results;
> >               }
> >
> >             }
> >
> >         There are 26 occurrences of this pattern in apache-tomcat.
> >
> >         Of course, if the field in question is of type Boolean, it
> becomes
> >         exceptionally problematical.
> >
> >         Bill
> >         _______________________________________________
> >         Concurrency-interest mailing list
> >         Concurrency-interest at altair.cs.oswego.edu
> >         <mailto:Concurrency-interest at altair.cs.oswego.edu>
> >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> >     _______________________________________________
> >     Concurrency-interest mailing list
> >     Concurrency-interest at altair.cs.oswego.edu
> >     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>  >     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
> >
> > ------------------------------------------------------------------------
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080316/78eb52a4/attachment.html 

From alarmnummer at gmail.com  Sun Mar 16 17:08:49 2008
From: alarmnummer at gmail.com (Peter Veentjer)
Date: Sun, 16 Mar 2008 16:08:49 -0500
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <b097ac510803161257n4e5670dcm706aacc39bd1222@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<a74683f90803141308w40d897bep13e140f53f767b91@mail.gmail.com>
	<b097ac510803141332l78600fabv5026d2941f6a3a9c@mail.gmail.com>
	<47DD71D8.7020504@cs.umd.edu>
	<b097ac510803161257n4e5670dcm706aacc39bd1222@mail.gmail.com>
Message-ID: <1466c1d60803161408g36b436c7paa157dff79c1c441@mail.gmail.com>

Besides the neat race problem, there also is a visiblity problem:
there is no happens before relation between the write and the read of
the listeners field. I just checked the sourcecode of InstanceSupport
of Tomcat and the listeners field is not volatile.

http://jsourcery.com/api/apache/jakarta/tomcat/6.0.10/org/apache/catalina/util/InstanceSupport.source.html#j1338697154

Using a final CopyOnWriteArrayList list would have been a better
solution than the current approach.

On Sun, Mar 16, 2008 at 2:57 PM, Joshua Bloch <josh at bloch.us> wrote:
> Jeremy,
>
> No worries, I've always believed that.
>
>         Josh
>
>
>
> On Sun, Mar 16, 2008 at 12:15 PM, Jeremy Manson <jmanson at cs.umd.edu> wrote:
>
> > Josh,
> >
> > The following may be obvious. :)
> >
> > I think that is only part of the answer.  In this case, you really want
> > a completely separate object ("private ReentrantLock listenersLock")
> > that controls the synchronization on listeners.
> >
> > I think we need to emphasize that synchronization is orthogonal to
> > program logic and data.  Not that this is a particularly original
> > observation, but I think Java made a mistake by integrating
> > synchronization and control logic.  We see it over and over again in
> > this notion that objects provide their own synchronization.
> >
> > There are other benefits to this approach, too, like the fact that you
> > have much better control over the lock of an entirely separate lock
> > object than you do over an arbitrary instance of an object whose methods
> > may acquire its lock.
> >
> >                                        Jeremy
> >
> >
> > Joshua Bloch wrote:
> > > Bill,
> > >
> > > Ouch!  "Synchronize only on final fields."
> > >
> > >           Josh
> > >
> > > P.S.  (No, I hadn't said that previously, but I will now.)
> > >
> > >
> > >
> > > On Fri, Mar 14, 2008 at 1:08 PM, Bob Lee <crazybob at crazybob.org
> >
> > > <mailto:crazybob at crazybob.org>> wrote:
> > >
> > >     Nice one.
> > >
> > >
> > >     On Fri, Mar 14, 2008 at 12:28 PM, Bill Pugh <pugh at cs.umd.edu
> >
> > >     <mailto:pugh at cs.umd.edu>> wrote:
> > >
> > >         I identified a new concurrency bug pattern that is way too
> common:
> > >
> > >         Synchronizing on a field in order to prevent concurrent access
> > >         to that
> > >         field.
> > >
> > >         For example:
> > >           /**
> > >              * Add a lifecycle event listener to this component.
> > >              *
> > >              * @param listener The listener to add
> > >              */
> > >             public void addInstanceListener(InstanceListener listener) {
> > >
> > >               synchronized (listeners) {
> > >                   InstanceListener results[] =
> > >                     new InstanceListener[listeners.length + 1];
> > >                   for (int i = 0; i < listeners.length; i++)
> > >                       results[i] = listeners[i];
> > >                   results[listeners.length] = listener;
> > >                   listeners = results;
> > >               }
> > >
> > >             }
> > >
> > >         There are 26 occurrences of this pattern in apache-tomcat.
> > >
> > >         Of course, if the field in question is of type Boolean, it
> becomes
> > >         exceptionally problematical.
> > >
> > >         Bill
> > >         _______________________________________________
> > >         Concurrency-interest mailing list
> > >         Concurrency-interest at altair.cs.oswego.edu
> > >         <mailto:Concurrency-interest at altair.cs.oswego.edu>
> >
> > >
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> > >     _______________________________________________
> > >     Concurrency-interest mailing list
> > >     Concurrency-interest at altair.cs.oswego.edu
> > >     <mailto:Concurrency-interest at altair.cs.oswego.edu>
> >
> >
> >
> > >     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> > >
> > >
> > >
> > > ------------------------------------------------------------------------
> > >
> > > _______________________________________________
> > > Concurrency-interest mailing list
> > > Concurrency-interest at altair.cs.oswego.edu
> > > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>
>
> _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

From David.Biesack at sas.com  Tue Mar 18 13:24:57 2008
From: David.Biesack at sas.com (David J. Biesack)
Date: Tue, 18 Mar 2008 13:24:57 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <mailman.1.1205596801.22613.concurrency-interest@altair.cs.oswego.edu>
	(concurrency-interest-request@cs.oswego.edu)
References: <mailman.1.1205596801.22613.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <u4pb4lzbq.fsf@sas.com>


> Date: Fri, 14 Mar 2008 15:28:30 -0400
> From: Bill Pugh <pugh at cs.umd.edu>
> Subject: [concurrency-interest] New bug pattern, way to common
> 
> I identified a new concurrency bug pattern that is way too common:
> 
> Synchronizing on a field in order to prevent concurrent access to that  
> field.
>
>       synchronized (listeners) {
>           ...
>           listeners = results;
>       }

Bill;

Since you said

> There are 26 occurrences of this pattern in apache-tomcat.

I assumed FindBugs found these 26 occurrences.

However, when I tried it, this code is not flagged by FindBugs (1.3.2) as a ML_SYNC_ON_UPDATED_FIELD

  http://findbugs.sourceforge.net/bugDescriptions.html#ML_SYNC_ON_UPDATED_FIELD

  "ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)

   This method synchronizes on an object references from a mutable field.
   This is unlikely to have useful semantics, since different threads
   may be synchronizing on different objects."

(it's entirely possible I've not configured FindBugs correctly...)

-- 
David J. Biesack     SAS Institute Inc.
(919) 531-7771       SAS Campus Drive
http://www.sas.com   Cary, NC 27513

From jdmarshall at gmail.com  Wed Mar 19 16:40:45 2008
From: jdmarshall at gmail.com (jason marshall)
Date: Wed, 19 Mar 2008 13:40:45 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <NFBBKALFDCPFIDBNKAPCCEPDHKAA.dcholmes@optusnet.com.au>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<NFBBKALFDCPFIDBNKAPCCEPDHKAA.dcholmes@optusnet.com.au>
Message-ID: <3cf41bb90803191340v2d7e50ep4df7b885fd312bad@mail.gmail.com>

In encouraging the other David to file a bug against Findbugs, I had a
"wait, what?" moment, but I realized my mistake.  I see on a re-read
of the thread that you described it here.  I just wanted to restate it
to make sure I have the right of it:

Happens-before doesn't save a thread that has already blocked waiting
on a monitor, because the variable has already been dereferenced.

-Jason

On Sat, Mar 15, 2008 at 12:49 AM, David Holmes <dcholmes at optusnet.com.au> wrote:
> Bill Pugh writes:
>  > I identified a new concurrency bug pattern that is way too common:
>  >
>  > Synchronizing on a field in order to prevent concurrent access to that
>  > field.
>  >
>  > For example:
>  >    /**
>  >       * Add a lifecycle event listener to this component.
>  >       *
>  >       * @param listener The listener to add
>  >       */
>  >      public void addInstanceListener(InstanceListener listener) {
>  >
>  >        synchronized (listeners) {
>  >            InstanceListener results[] =
>  >              new InstanceListener[listeners.length + 1];
>  >            for (int i = 0; i < listeners.length; i++)
>  >                results[i] = listeners[i];
>  >            results[listeners.length] = listener;
>  >            listeners = results;
>  >        }
>  >
>  >      }
>  >
>  > There are 26 occurrences of this pattern in apache-tomcat.
>  >
>  > Of course, if the field in question is of type Boolean, it becomes
>  > exceptionally problematical.
>
>  I've seen the Boolean case a number of times in forum postings. Typically it
>  is used with a wait/notify predicated on the Boolean's value. So at least in
>  that case you get an IllegalMonitorStateException. Though the posters are
>  always baffled as to why.
>
>  Now for the folks out there that are still new to all this and can't quite
>  see what the problem is, consider this: Suppose listeners refers to array A
>  and Thread-1 is busy making a new array B, when Thread-2 tries to do the
>  same. Thread-2 blocks on the lock for array A. When Thread-1 is done with
>  the copy it sets listeners to refer to array B and releases the lock on
>  array A. Thread-2 now locks array A and then starts to make a copy of array
>  B. Meanwhile Thread-3 comes along and grabs the lock of array B and so two
>  threads are now making copies of array B because they are using different
>  locks. At a minimum one of the new listeners will get lost, and its possible
>  that one thread will get ArrayIndexOutOfBoundsException as the listeners
>  reference (and hence the length) can change at any point during the method.
>  Ouch indeed!
>
>  Plus there are memory model issues due to synchronization on different
>  locks - but the lack of mutual exclusion is much more serious.
>
>  Nice catch Bill!
>
>  Cheers,
>  David Holmes
>
>
>
>  _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
- Jason

From dcholmes at optusnet.com.au  Wed Mar 19 19:35:55 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 20 Mar 2008 09:35:55 +1000
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <3cf41bb90803191340v2d7e50ep4df7b885fd312bad@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCGEPPHKAA.dcholmes@optusnet.com.au>

Right - I think :) Happens-before doesn't really come into it here - once
you are on the monitor queue, the reference you used to access the object on
which monitor you are now waiting, is of no consequence and any change to
the value of that reference has no affect on you.

David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of jason
> marshall
> Sent: Thursday, 20 March 2008 6:41 AM
> To: Concurrency-interest at cs.oswego.edu
> Subject: Re: [concurrency-interest] New bug pattern, way to common
>
>
> In encouraging the other David to file a bug against Findbugs, I had a
> "wait, what?" moment, but I realized my mistake.  I see on a re-read
> of the thread that you described it here.  I just wanted to restate it
> to make sure I have the right of it:
>
> Happens-before doesn't save a thread that has already blocked waiting
> on a monitor, because the variable has already been dereferenced.
>
> -Jason
>
> On Sat, Mar 15, 2008 at 12:49 AM, David Holmes
> <dcholmes at optusnet.com.au> wrote:
> > Bill Pugh writes:
> >  > I identified a new concurrency bug pattern that is way too common:
> >  >
> >  > Synchronizing on a field in order to prevent concurrent
> access to that
> >  > field.
> >  >
> >  > For example:
> >  >    /**
> >  >       * Add a lifecycle event listener to this component.
> >  >       *
> >  >       * @param listener The listener to add
> >  >       */
> >  >      public void addInstanceListener(InstanceListener listener) {
> >  >
> >  >        synchronized (listeners) {
> >  >            InstanceListener results[] =
> >  >              new InstanceListener[listeners.length + 1];
> >  >            for (int i = 0; i < listeners.length; i++)
> >  >                results[i] = listeners[i];
> >  >            results[listeners.length] = listener;
> >  >            listeners = results;
> >  >        }
> >  >
> >  >      }
> >  >
> >  > There are 26 occurrences of this pattern in apache-tomcat.
> >  >
> >  > Of course, if the field in question is of type Boolean, it becomes
> >  > exceptionally problematical.
> >
> >  I've seen the Boolean case a number of times in forum
> postings. Typically it
> >  is used with a wait/notify predicated on the Boolean's value.
> So at least in
> >  that case you get an IllegalMonitorStateException. Though the
> posters are
> >  always baffled as to why.
> >
> >  Now for the folks out there that are still new to all this and
> can't quite
> >  see what the problem is, consider this: Suppose listeners
> refers to array A
> >  and Thread-1 is busy making a new array B, when Thread-2 tries
> to do the
> >  same. Thread-2 blocks on the lock for array A. When Thread-1
> is done with
> >  the copy it sets listeners to refer to array B and releases the lock on
> >  array A. Thread-2 now locks array A and then starts to make a
> copy of array
> >  B. Meanwhile Thread-3 comes along and grabs the lock of array
> B and so two
> >  threads are now making copies of array B because they are
> using different
> >  locks. At a minimum one of the new listeners will get lost,
> and its possible
> >  that one thread will get ArrayIndexOutOfBoundsException as the
> listeners
> >  reference (and hence the length) can change at any point
> during the method.
> >  Ouch indeed!
> >
> >  Plus there are memory model issues due to synchronization on different
> >  locks - but the lack of mutual exclusion is much more serious.
> >
> >  Nice catch Bill!
> >
> >  Cheers,
> >  David Holmes
> >
> >
> >
> >  _______________________________________________
> >  Concurrency-interest mailing list
> >  Concurrency-interest at altair.cs.oswego.edu
> >  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
>
>
>
> --
> - Jason
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From David.Biesack at sas.com  Thu Mar 20 13:17:23 2008
From: David.Biesack at sas.com (David J. Biesack)
Date: Thu, 20 Mar 2008 13:17:23 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <mailman.1.1206028801.5854.concurrency-interest@altair.cs.oswego.edu>
	(concurrency-interest-request@cs.oswego.edu)
References: <mailman.1.1206028801.5854.concurrency-interest@altair.cs.oswego.edu>
Message-ID: <ulk4dl3h8.fsf@sas.com>


> Date: Wed, 19 Mar 2008 13:40:45 -0700
> From: "jason marshall" <jdmarshall at gmail.com>
> Subject: Re: [concurrency-interest] New bug pattern, way to common
> To: Concurrency-interest at cs.oswego.edu
> 
> In encouraging the other David to file a bug against Findbugs,

For reference: after Jason confirmed it wasn't a DUE, I filed the FindBugs bug:
http://sourceforge.net/tracker/index.php?func=detail&aid=1920108&group_id=96405&atid=614693

-- 
David J. Biesack     SAS Institute Inc.
(919) 531-7771       SAS Campus Drive
http://www.sas.com   Cary, NC 27513

From jason_mehrens at hotmail.com  Fri Mar 21 14:01:03 2008
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Fri, 21 Mar 2008 13:01:03 -0500
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
Message-ID: <BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>


Another broken pattern that findbugs (1.1.3) doesn't catch is using getClass() and synchronized.  Since getClass() doesn't always return the Class object that defines the static field (because of a sub class) it is a case of synchronized on different objects.  This may not be common but it is broken.
 
The following is an example, the original was from "yet another broken double checked locking attempt":
 
public class NonFinalClassShouldUseClassLiteral {  private static int count;
  public NonFinalClassShouldUseClassLiteral() {    synchronized (getClass()) {      count++;    }  }}
 
Jason
_________________________________________________________________
Test your Star IQ
http://club.live.com/red_carpet_reveal.aspx?icid=redcarpet_HMTAGMAR
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080321/0ba748b4/attachment.html 

From dhanji at gmail.com  Fri Mar 21 18:53:38 2008
From: dhanji at gmail.com (Dhanji R. Prasanna)
Date: Sat, 22 Mar 2008 08:53:38 +1000
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
Message-ID: <aa067ea10803211553j5737c9a5m13e5a90b4c069f73@mail.gmail.com>

On Sat, Mar 22, 2008 at 4:01 AM, Jason Mehrens <jason_mehrens at hotmail.com>
wrote:

>  Another broken pattern that findbugs (1.1.3) doesn't catch is using
> getClass() and synchronized.  Since getClass() doesn't always return the
> Class object that defines the static field (because of a sub class) it is a
> case of synchronized on different objects.  This may not be common but it is
> broken.
>
> The following is an example, the original was from "yet another broken
> double checked locking attempt":
>
> public class NonFinalClassShouldUseClassLiteral {
>   private static int count;
>   public NonFinalClassShouldUseClassLiteral() {
>     synchronized (getClass()) {
>       count++;
>     }
>   }
> }
>
>
>

Good catch! Probably a very marginal case?

I think an inspection for instance field = Logger.getLogger(getClass()) may
also be worthwhile (though OT).

Dhanji.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080322/8f506557/attachment.html 

From forax at univ-mlv.fr  Sat Mar 22 09:15:06 2008
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Sat, 22 Mar 2008 14:15:06 +0100
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
Message-ID: <47E5065A.5060502@univ-mlv.fr>

Jason Mehrens a ?crit :
> Another broken pattern that findbugs (1.1.3) doesn't catch is using 
> getClass() and synchronized.  Since getClass() doesn't always return 
> the Class object that defines the static field (because of a sub 
> class) it is a case of synchronized on different objects.  This may 
> not be common but it is broken.
This case is cover by a more general rule: don't synchronized on 
internable object
like Class, String, wrappers (Integer, etc.).
>  
> The following is an example, the original was from "yet another broken 
> double checked locking attempt":
>  
> public class NonFinalClassShouldUseClassLiteral {
>   private static int count;
>   public NonFinalClassShouldUseClassLiteral() {
>     synchronized (getClass()) {
>       count++;
>     }
>   }
> }
>
>  
> Jason
R?mi

From pugh at cs.umd.edu  Sat Mar 22 10:57:30 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sat, 22 Mar 2008 10:57:30 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <47E5065A.5060502@univ-mlv.fr>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<47E5065A.5060502@univ-mlv.fr>
Message-ID: <8FA32AF1-1DE5-4266-A42D-13139C7BF92A@cs.umd.edu>

No, because using the synchronized modifier on a static method  
synchronizes
on the Class object.

While this does allow for malicious code to perform denial of service  
attacks,
the Java platform is pretty wide open to that.



	Bill


On Mar 22, 2008, at 9:15 AM, R?mi Forax wrote:

> Jason Mehrens a ?crit :
>> Another broken pattern that findbugs (1.1.3) doesn't catch is using
>> getClass() and synchronized.  Since getClass() doesn't always return
>> the Class object that defines the static field (because of a sub
>> class) it is a case of synchronized on different objects.  This may
>> not be common but it is broken.
> This case is cover by a more general rule: don't synchronized on
> internable object
> like Class, String, wrappers (Integer, etc.).
>>
>> The following is an example, the original was from "yet another  
>> broken
>> double checked locking attempt":
>>
>> public class NonFinalClassShouldUseClassLiteral {
>>  private static int count;
>>  public NonFinalClassShouldUseClassLiteral() {
>>    synchronized (getClass()) {
>>      count++;
>>    }
>>  }
>> }
>>
>>
>> Jason
> R?mi
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest



From forax at univ-mlv.fr  Sat Mar 22 12:02:55 2008
From: forax at univ-mlv.fr (=?ISO-8859-1?Q?R=E9mi_Forax?=)
Date: Sat, 22 Mar 2008 17:02:55 +0100
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <8FA32AF1-1DE5-4266-A42D-13139C7BF92A@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<47E5065A.5060502@univ-mlv.fr>
	<8FA32AF1-1DE5-4266-A42D-13139C7BF92A@cs.umd.edu>
Message-ID: <47E52DAF.3000007@univ-mlv.fr>

Bill Pugh a ?crit :
> No, because using the synchronized modifier on a static method 
> synchronizes
> on the Class object.
yes, i know that (JLS 8.4.3.6).
>
> While this does allow for malicious code to perform denial of service 
> attacks,
> the Java platform is pretty wide open to that.
The problem is that malicious code can be written without any bad intent.

I've seen an example two months ago in a code using a cache to speedup 
some reflection calls
and cause a deadlock between a synchronized static method and a synchronized
block on the same Class objet( used as a value in the cache).

I prefer to stick to that simple rule :
  only synchronize on a non public visible final object.

Note that this rule disallows synchronization on "this" too, which suffers
the same problem.

I understand that pratically FindBugs can't raise a warning on all
synchronized methods because it's a common Java idiom but i think that
allowing synchronized on a method was a bad design decision.

>
>
>
>     Bill
R?mi
>
>
> On Mar 22, 2008, at 9:15 AM, R?mi Forax wrote:
>
>> Jason Mehrens a ?crit :
>>> Another broken pattern that findbugs (1.1.3) doesn't catch is using
>>> getClass() and synchronized.  Since getClass() doesn't always return
>>> the Class object that defines the static field (because of a sub
>>> class) it is a case of synchronized on different objects.  This may
>>> not be common but it is broken.
>> This case is cover by a more general rule: don't synchronized on
>> internable object
>> like Class, String, wrappers (Integer, etc.).
>>>
>>> The following is an example, the original was from "yet another broken
>>> double checked locking attempt":
>>>
>>> public class NonFinalClassShouldUseClassLiteral {
>>>  private static int count;
>>>  public NonFinalClassShouldUseClassLiteral() {
>>>    synchronized (getClass()) {
>>>      count++;
>>>    }
>>>  }
>>> }
>>>
>>>
>>> Jason
>> R?mi
>> _______________________________________________
>> Concurrency-interest mailing list
>> Concurrency-interest at altair.cs.oswego.edu
>> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>


From pugh at cs.umd.edu  Sat Mar 22 17:50:01 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sat, 22 Mar 2008 17:50:01 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
Message-ID: <8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>

Thanks for the suggestion. We found lots of occurrences of this bug  
pattern, including 23 in JDK 1.5 and 1.6:

This includes the following code in java.awt.Label (and similar code  
in most of the AWT components):

      private static final String base = "label";
      private static int nameCounter = 0;
      String constructComponentName() {
         synchronized (getClass()) {
             return base + nameCounter++;
         }
      }

The awt Component ones have been cleaned up in JDK 1.7, but 4 remain:

M M WL: Sychronization on getClass rather than class literal in  
sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]
H M WL: Sychronization on getClass rather than class literal in new  
sun.misc.Timer(Timeable, long)  At Timer.java:[line 166]
H M WL: Sychronization on getClass rather than class literal in  
sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 611]
H M WL: Sychronization on getClass rather than class literal in  
sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 629]


This detector will be in 1.3.3 final (and in rc2).

	Bill



On Mar 21, 2008, at 2:01 PM, Jason Mehrens wrote:

> Another broken pattern that findbugs (1.1.3) doesn't catch is using  
> getClass() and synchronized.  Since getClass() doesn't always return  
> the Class object that defines the static field (because of a sub  
> class) it is a case of synchronized on different objects.  This may  
> not be common but it is broken.
>
> The following is an example, the original was from "yet another  
> broken double checked locking attempt":
>
> public class NonFinalClassShouldUseClassLiteral {
>   private static int count;
>   public NonFinalClassShouldUseClassLiteral() {
>     synchronized (getClass()) {
>       count++;
>     }
>   }
> }
>
>
> Jason
>
> Test your Star IQ Play now!

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080322/27188dfb/attachment.html 

From hanson.char at gmail.com  Sun Mar 23 10:11:50 2008
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 23 Mar 2008 07:11:50 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
Message-ID: <ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>

I agree it's a bug pattern, but for argument sake, synchronizing on
getClass() isn't necessarily a bug.  Right ?  See example below that
synchronizes on counting the number of time the instance of a specific class
is constructed.  There isn't any bug there, or is there ?

Hanson

class A {
    private static int count;

    A() {
        synchronized(getClass()) { inc(); }
    }

    protected void inc() { count++; }
}

class B extends A {
     private static int count;
     @Override protected void inc() { count++; }
}

On Sat, Mar 22, 2008 at 2:50 PM, Bill Pugh <pugh at cs.umd.edu> wrote:

> Thanks for the suggestion. We found lots of occurrences of this bug
> pattern, including 23 in JDK 1.5 and 1.6:
> This includes the following code in java.awt.Label (and similar code in
> most of the AWT components):
>
>      private static final String base = "label";
>      private static int nameCounter = 0;
>      String constructComponentName() {
>         synchronized (getClass()) {
>             return base + nameCounter++;
>         }
>      }
>
> The awt Component ones have been cleaned up in JDK 1.7, but 4 remain:
>
> M M WL: Sychronization on getClass rather than class literal in
> sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]
> H M WL: Sychronization on getClass rather than class literal in new
> sun.misc.Timer(Timeable, long)  At Timer.java:[line 166]
> H M WL: Sychronization on getClass rather than class literal in
> sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 611]
> H M WL: Sychronization on getClass rather than class literal in
> sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 629]
>
>
> This detector will be in 1.3.3 final (and in rc2).
>
> Bill
>
>
>
> On Mar 21, 2008, at 2:01 PM, Jason Mehrens wrote:
>
> Another broken pattern that findbugs (1.1.3) doesn't catch is using
> getClass() and synchronized.  Since getClass() doesn't always return the
> Class object that defines the static field (because of a sub class) it is a
> case of synchronized on different objects.  This may not be common but it is
> broken.
>
> The following is an example, the original was from "yet another broken
> double checked locking attempt":
>
> public class NonFinalClassShouldUseClassLiteral {
>   private static int count;
>   public NonFinalClassShouldUseClassLiteral() {
>     synchronized (getClass()) {
>       count++;
>     }
>   }
> }
>
>
> Jason
>
> ------------------------------
> Test your Star IQ Play now!<http://club.live.com/red_carpet_reveal.aspx?icid=redcarpet_HMTAGMAR>
>
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080323/b1d2c874/attachment.html 

From tim at peierls.net  Sun Mar 23 10:56:34 2008
From: tim at peierls.net (Tim Peierls)
Date: Sun, 23 Mar 2008 10:56:34 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
Message-ID: <63b4e4050803230756q5bef8719yd0a090525a652e37@mail.gmail.com>

Your example calls an overridden method in the constructor of A.

On 3/23/08, Hanson Char <hanson.char at gmail.com> wrote:
> I agree it's a bug pattern, but for argument sake, synchronizing on
> getClass() isn't necessarily a bug.  Right ?  See example below that
> synchronizes on counting the number of time the instance of a specific class
> is constructed.  There isn't any bug there, or is there ?
>
> Hanson
>
> class A {
>     private static int count;
>
>     A() {
>         synchronized(getClass()) { inc(); }
>     }
>
>     protected void inc() { count++; }
> }
>
> class B extends A {
>      private static int count;
>      @Override protected void inc() { count++; }
> }
>
> On Sat, Mar 22, 2008 at 2:50 PM, Bill Pugh <pugh at cs.umd.edu> wrote:
>
> > Thanks for the suggestion. We found lots of occurrences of this bug
> > pattern, including 23 in JDK 1.5 and 1.6:
> > This includes the following code in java.awt.Label (and similar code in
> > most of the AWT components):
> >
> >      private static final String base = "label";
> >      private static int nameCounter = 0;
> >      String constructComponentName() {
> >         synchronized (getClass()) {
> >             return base + nameCounter++;
> >         }
> >      }
> >
> > The awt Component ones have been cleaned up in JDK 1.7, but 4 remain:
> >
> > M M WL: Sychronization on getClass rather than class literal in
> > sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]
> > H M WL: Sychronization on getClass rather than class literal in new
> > sun.misc.Timer(Timeable, long)  At Timer.java:[line 166]
> > H M WL: Sychronization on getClass rather than class literal in
> > sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 611]
> > H M WL: Sychronization on getClass rather than class literal in
> > sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 629]
> >
> >
> > This detector will be in 1.3.3 final (and in rc2).
> >
> > Bill
> >
> >
> >
> > On Mar 21, 2008, at 2:01 PM, Jason Mehrens wrote:
> >
> > Another broken pattern that findbugs (1.1.3) doesn't catch is using
> > getClass() and synchronized.  Since getClass() doesn't always return the
> > Class object that defines the static field (because of a sub class) it is
> a
> > case of synchronized on different objects.  This may not be common but it
> is
> > broken.
> >
> > The following is an example, the original was from "yet another broken
> > double checked locking attempt":
> >
> > public class NonFinalClassShouldUseClassLiteral {
> >   private static int count;
> >   public NonFinalClassShouldUseClassLiteral() {
> >     synchronized (getClass()) {
> >       count++;
> >     }
> >   }
> > }
> >
> >
> > Jason
> >
> > ------------------------------
> > Test your Star IQ Play
> now!<http://club.live.com/red_carpet_reveal.aspx?icid=redcarpet_HMTAGMAR>
> >
> >
> >
> > _______________________________________________
> > Concurrency-interest mailing list
> > Concurrency-interest at altair.cs.oswego.edu
> > http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
> >
> >
>

From blanshlu at netscape.net  Sun Mar 23 11:16:00 2008
From: blanshlu at netscape.net (Luke Blanshard)
Date: Sun, 23 Mar 2008 10:16:00 -0500
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
Message-ID: <47E67430.8020408@netscape.net>

This is still buggy.  Suppose you added class C extends A, and have 
thread 1 create an A and thread 2 create a C.  Now the inc method will 
be able to run simultaneously in both threads.

It would only make sense to synchronize on getClass if there were "class 
instance" variables in Java, as in some variants of Smalltalk.

Hanson Char wrote:
> I agree it's a bug pattern, but for argument sake, synchronizing on 
> getClass() isn't necessarily a bug.  Right ?  See example below that 
> synchronizes on counting the number of time the instance of a specific 
> class is constructed.  There isn't any bug there, or is there ?
>
> Hanson
>
> class A {
>     private static int count;
>
>     A() {
>         synchronized(getClass()) { inc(); }
>     }
>
>     protected void inc() { count++; }
> }
>
> class B extends A {
>      private static int count;
>      @Override protected void inc() { count++; }
> }
>
> On Sat, Mar 22, 2008 at 2:50 PM, Bill Pugh <pugh at cs.umd.edu 
> <mailto:pugh at cs.umd.edu>> wrote:
>
>     Thanks for the suggestion. We found lots of occurrences of this
>     bug pattern, including 23 in JDK 1.5 and 1.6:
>
>     This includes the following code in java.awt.Label (and similar
>     code in most of the AWT components):
>
>          private static final String base = "label";
>          private static int nameCounter = 0;
>          String constructComponentName() {
>             synchronized (getClass()) {
>                 return base + nameCounter++;
>             }
>          }
>
>     The awt Component ones have been cleaned up in JDK 1.7, but 4 remain:
>
>     M M WL: Sychronization on getClass rather than class literal in
>     sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]
>     H M WL: Sychronization on getClass rather than class literal in
>     new sun.misc.Timer(Timeable, long)  At Timer.java:[line 166]
>     H M WL: Sychronization on getClass rather than class literal in
>     sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 611]
>     H M WL: Sychronization on getClass rather than class literal in
>     sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 629]
>
>
>     This detector will be in 1.3.3 final (and in rc2).
>
>     Bill
>
>
>
>     On Mar 21, 2008, at 2:01 PM, Jason Mehrens wrote:
>>     Another broken pattern that findbugs (1.1.3) doesn't catch is
>>     using getClass() and synchronized.  Since getClass() doesn't
>>     always return the Class object that defines the static field
>>     (because of a sub class) it is a case of synchronized on
>>     different objects.  This may not be common but it is broken.
>>      
>>     The following is an example, the original was from "yet another
>>     broken double checked locking attempt":
>>      
>>     public class NonFinalClassShouldUseClassLiteral {
>>       private static int count;
>>       public NonFinalClassShouldUseClassLiteral() {
>>         synchronized (getClass()) {
>>           count++;
>>         }
>>       }
>>     }
>>
>>      
>>     Jason
>>
>>     ------------------------------------------------------------------------
>>     Test your Star IQ Play now!
>>     <http://club.live.com/red_carpet_reveal.aspx?icid=redcarpet_HMTAGMAR>
>
>
>     _______________________________________________
>     Concurrency-interest mailing list
>     Concurrency-interest at altair.cs.oswego.edu
>     <mailto:Concurrency-interest at altair.cs.oswego.edu>
>     http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>   


From pugh at cs.umd.edu  Sun Mar 23 12:17:23 2008
From: pugh at cs.umd.edu (Bill Pugh)
Date: Sun, 23 Mar 2008 12:17:23 -0400
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
Message-ID: <04AA83CD-FA01-4BD2-B9C9-B36A0C22CEDA@cs.umd.edu>

This isn't a data race, and synchronizing on getClass() isn't always  
wrong.

But it is a bug pattern.

Most of the time you see it, the coder is doing something stupid, not  
clever. And even in the cases where the developer careful crafted the  
code and understands what he is doing, it is likely to confuse anyone  
who has to maintain that code later.

So we'll flag it in FindBugs. Somethings flagged by FindBugs aren't  
bugs, and don't need to be fixed.

Bill


On Mar 23, 2008, at 10:11 AM, Hanson Char wrote:

> I agree it's a bug pattern, but for argument sake, synchronizing on  
> getClass() isn't necessarily a bug.  Right ?  See example below that  
> synchronizes on counting the number of time the instance of a  
> specific class is constructed.  There isn't any bug there, or is  
> there ?
>
> Hanson
>
> class A {
>     private static int count;
>
>     A() {
>         synchronized(getClass()) { inc(); }
>     }
>
>     protected void inc() { count++; }
> }
>
> class B extends A {
>      private static int count;
>      @Override protected void inc() { count++; }
> }
>
> On Sat, Mar 22, 2008 at 2:50 PM, Bill Pugh <pugh at cs.umd.edu> wrote:
> Thanks for the suggestion. We found lots of occurrences of this bug  
> pattern, including 23 in JDK 1.5 and 1.6:
>
> This includes the following code in java.awt.Label (and similar code  
> in most of the AWT components):
>
>      private static final String base = "label";
>      private static int nameCounter = 0;
>      String constructComponentName() {
>         synchronized (getClass()) {
>             return base + nameCounter++;
>         }
>      }
>
> The awt Component ones have been cleaned up in JDK 1.7, but 4 remain:
>
> M M WL: Sychronization on getClass rather than class literal in  
> sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]
> H M WL: Sychronization on getClass rather than class literal in new  
> sun.misc.Timer(Timeable, long)  At Timer.java:[line 166]
> H M WL: Sychronization on getClass rather than class literal in  
> sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 611]
> H M WL: Sychronization on getClass rather than class literal in  
> sun.misc.TimerTickThread.returnToPool()  At Timer.java:[line 629]
>
>
> This detector will be in 1.3.3 final (and in rc2).
>
> 	Bill
>
>
>
> On Mar 21, 2008, at 2:01 PM, Jason Mehrens wrote:
>> Another broken pattern that findbugs (1.1.3) doesn't catch is using  
>> getClass() and synchronized.  Since getClass() doesn't always  
>> return the Class object that defines the static field (because of a  
>> sub class) it is a case of synchronized on different objects.  This  
>> may not be common but it is broken.
>>
>> The following is an example, the original was from "yet another  
>> broken double checked locking attempt":
>>
>> public class NonFinalClassShouldUseClassLiteral {
>>   private static int count;
>>   public NonFinalClassShouldUseClassLiteral() {
>>     synchronized (getClass()) {
>>       count++;
>>     }
>>   }
>> }
>>
>>
>> Jason
>>
>> Test your Star IQ Play now!
>
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080323/5565b2f3/attachment.html 

From Thomas.Hawtin at Sun.COM  Sun Mar 23 12:53:46 2008
From: Thomas.Hawtin at Sun.COM (Tom Hawtin)
Date: Sun, 23 Mar 2008 16:53:46 +0000
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
Message-ID: <47E68B1A.3050103@sun.com>

Bill Pugh wrote:
> 
> M M WL: Sychronization on getClass rather than class literal in 
> sun.applet.AppletPanel$9.run()  At AppletPanel.java:[line 1041]

Fortunately this one is in an anonymous inner class and also in a sun.* 
package (not a public API and not accessible from untrusted code). But 
as an anonymous inner class it seems to be an odd thing to want to do 
(although you can't use the .class notation in such a context). Looking 
at the code it seems to be locking the wrong object. It should be doing 
AppletPanel.this.getClass() (or rather AppletPanel.class or, if it were 
made final, classloaders). Getting the wrong this in an anonymous inner 
class isn't uncommon either, particularly when any Object will do.

Tom Hawtin

From gregg at cytetech.com  Sun Mar 23 14:19:31 2008
From: gregg at cytetech.com (Gregg Wonderly)
Date: Sun, 23 Mar 2008 13:19:31 -0500
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <47E67430.8020408@netscape.net>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
	<47E67430.8020408@netscape.net>
Message-ID: <47E69F33.1010303@cytetech.com>

Luke Blanshard wrote:
> This is still buggy.  Suppose you added class C extends A, and have 
> thread 1 create an A and thread 2 create a C.  Now the inc method will 
> be able to run simultaneously in both threads.
> 
> It would only make sense to synchronize on getClass if there were "class 
> instance" variables in Java, as in some variants of Smalltalk.

I don't know that I have a great example of when this behavior would actually be 
  correct.  It seems like findbugs could alert one to refererences to non-final 
or non-private references within synchronized(getClass()) blocks.  I.e. 
getClass() is okay as long as it's referencing things that only this "Class" 
instance can see.  As in this example, that would include instance variables as 
well as methods.  If increment() were final or private, then it's reference 
would be okay.  It might also be okay to reference methods that were abstract. 
So, I'm not sure that this could be called a problem coding practice as much as 
an advanced coding construct that needs careful attention to use correctly.

Gregg Wonderly

From jdmarshall at gmail.com  Sun Mar 23 14:57:24 2008
From: jdmarshall at gmail.com (jason marshall)
Date: Sun, 23 Mar 2008 11:57:24 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <47E69F33.1010303@cytetech.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
	<47E67430.8020408@netscape.net> <47E69F33.1010303@cytetech.com>
Message-ID: <3cf41bb90803231157s5ae18785td1840c132981837f@mail.gmail.com>

I can only recall using synchronize(getClass()) willfully in one
scenario (a couple occasions), and that was when I was building tables
of metadata about classes.

I don' tend to use class metadata in that manner anymore, so I haven't
used it in quite some time.  But I bet plenty of frameworks still do.
Especially class manipulation kits, but I suspect Hibernate does as
well.

On Sun, Mar 23, 2008 at 11:19 AM, Gregg Wonderly <gregg at cytetech.com> wrote:
> Luke Blanshard wrote:
>  > This is still buggy.  Suppose you added class C extends A, and have
>  > thread 1 create an A and thread 2 create a C.  Now the inc method will
>  > be able to run simultaneously in both threads.
>  >
>  > It would only make sense to synchronize on getClass if there were "class
>  > instance" variables in Java, as in some variants of Smalltalk.
>
>  I don't know that I have a great example of when this behavior would actually be
>   correct.  It seems like findbugs could alert one to refererences to non-final
>  or non-private references within synchronized(getClass()) blocks.  I.e.
>  getClass() is okay as long as it's referencing things that only this "Class"
>  instance can see.  As in this example, that would include instance variables as
>  well as methods.  If increment() were final or private, then it's reference
>  would be okay.  It might also be okay to reference methods that were abstract.
>  So, I'm not sure that this could be called a problem coding practice as much as
>  an advanced coding construct that needs careful attention to use correctly.
>
>  Gregg Wonderly
>
>
> _______________________________________________
>  Concurrency-interest mailing list
>  Concurrency-interest at altair.cs.oswego.edu
>  http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>



-- 
- Jason

From jason_mehrens at hotmail.com  Mon Mar 24 11:10:42 2008
From: jason_mehrens at hotmail.com (Jason Mehrens)
Date: Mon, 24 Mar 2008 10:10:42 -0500
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <3cf41bb90803231157s5ae18785td1840c132981837f@mail.gmail.com>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
	<47E67430.8020408@netscape.net> <47E69F33.1010303@cytetech.com> 
	<3cf41bb90803231157s5ae18785td1840c132981837f@mail.gmail.com>
Message-ID: <BLU134-W4165A4A84305C65123498983FD0@phx.gbl>


I assume you were doing something like:
void fn(Object that) {
  synchronize(that.getClass()) {
  }
}
 
and not:
void fn(Object that) {
  synchronize(this.getClass()) {
  }
}
Jason
> Date: Sun, 23 Mar 2008 11:57:24 -0700> From: jdmarshall at gmail.com> To: concurrency-interest at cs.oswego.edu> Subject: Re: [concurrency-interest] New bug pattern, way to common> > I can only recall using synchronize(getClass()) willfully in one> scenario (a couple occasions), and that was when I was building tables> of metadata about classes.> > I don' tend to use class metadata in that manner anymore, so I haven't> used it in quite some time. But I bet plenty of frameworks still do.> Especially class manipulation kits, but I suspect Hibernate does as> well.
_________________________________________________________________
Watch ?Cause Effect,? a show about real people making a real difference.  Learn more.
http://im.live.com/Messenger/IM/MTV/?source=text_watchcause
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080324/18ec1f17/attachment.html 

From jdmarshall at gmail.com  Tue Mar 25 00:52:13 2008
From: jdmarshall at gmail.com (jason marshall)
Date: Mon, 24 Mar 2008 21:52:13 -0700
Subject: [concurrency-interest] New bug pattern, way to common
In-Reply-To: <BLU134-W4165A4A84305C65123498983FD0@phx.gbl>
References: <51A14CE8-BAC8-4F81-9DB9-27E18F8DDFD8@cs.umd.edu>
	<BLU134-W301EB574D1D239B0CD93E083010@phx.gbl>
	<8F489A3A-C122-4534-A94E-C84E499CF150@cs.umd.edu>
	<ca53c8f80803230711v363442c6u8ef2e339e30c87e1@mail.gmail.com>
	<47E67430.8020408@netscape.net> <47E69F33.1010303@cytetech.com>
	<3cf41bb90803231157s5ae18785td1840c132981837f@mail.gmail.com>
	<BLU134-W4165A4A84305C65123498983FD0@phx.gbl>
Message-ID: <3cf41bb90803242152p2945d9b4h5738fdc4197d190d@mail.gmail.com>

Yes, in the bad old days when reflection cost over 100x what it does now.

Today I'd just guard the insert if I was writing the same code, and
just speculatively do the lookup work every time I discovered that the
data was missing.


Or more likely, I just would find something else to work on :)


-Jason


On Mon, Mar 24, 2008 at 8:10 AM, Jason Mehrens
<jason_mehrens at hotmail.com> wrote:
>
>  I assume you were doing something like:
>  void fn(Object that) {
>    synchronize(that.getClass()) {
>    }
>  }
>
>  and not:
>  void fn(Object that) {
>    synchronize(this.getClass()) {
>    }
>  }
>
>  Jason
>
>
> > Date: Sun, 23 Mar 2008 11:57:24 -0700
> > From: jdmarshall at gmail.com
> > To: concurrency-interest at cs.oswego.edu
>
> > Subject: Re: [concurrency-interest] New bug pattern, way to common
> >
> > I can only recall using synchronize(getClass()) willfully in one
> > scenario (a couple occasions), and that was when I was building tables
> > of metadata about classes.
> >
> > I don' tend to use class metadata in that manner anymore, so I haven't
> > used it in quite some time. But I bet plenty of frameworks still do.
> > Especially class manipulation kits, but I suspect Hibernate does as
> > well.
>
>
>
> ________________________________
> Watch "Cause Effect," a show about real people making a real difference.
> Learn more.



-- 
- Jason

From jnewsham at referentia.com  Wed Mar 26 17:02:13 2008
From: jnewsham at referentia.com (Jim Newsham)
Date: Wed, 26 Mar 2008 11:02:13 -1000
Subject: [concurrency-interest] jvm hang
Message-ID: <063c01c88f84$ad9b99d0$8700a8c0@referentia.com>

 

Hi everyone,

 

I apologize if this is not the best place to ask, but I don't know any
better resources (suggestions welcome).  Our application appears to hang the
JVM (1.6.0_02) pretty well, during application startup.  I am not able to
reproduce the problem on my machine (in fact, it does not occur on most
machines), but it occurs pretty frequently on a machine which I
unfortunately don't have direct access to.  Our application performs socket
operations (tcp and udp).  When the udp operations are disabled within the
app, the problem seems to go away, although that does not prove that it is
the cause of the problem.  

 

In this case, hanging means our application freezes and no further log
output is observed (including exceptions which might indicate a cause).  In
fact, the hang is so severe that jstat and jconsole are not able to connect
to the jvm.  I don't have detailed knowledge of the debug architecture, but
if jstat and jconsole fail to connect, it seems to me that there's a pretty
severe problem.  

 

In an attempt to get a thread dump, I added some code to our startup
sequence which starts a thread to perform a thread dump after some
command-line specified delay.  While waiting for the delay to elapse, it
prints countdown information to stderr ("dumping in 60 seconds". "dumping in
55 seconds". etc.).  However, this thread hangs too!  In other words, we see
the first few countdown messages, but no more.  Note that this thread does
not perform any locking and does not access external libraries; it only
sleeps in a loop until the time has elapsed, then uses java's ThreadMXBean
to get thread dump info.

 

Does this sound like a JVM bug to you?  Are there any known bugs in this JVM
version which could account for this problem?  We haven't tried a more
recent version yet because we are releasing within just a few weeks and have
been developing/testing on a single JVM version.

 

Thanks,

Jim

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080326/f70430aa/attachment.html 

From dcholmes at optusnet.com.au  Wed Mar 26 21:11:24 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Thu, 27 Mar 2008 11:11:24 +1000
Subject: [concurrency-interest] jvm hang
In-Reply-To: <063c01c88f84$ad9b99d0$8700a8c0@referentia.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEAMHLAA.dcholmes@optusnet.com.au>

Hi Jim,

Not really the right place so please respond off-list.

What platform are you on ? There are additional tools available on Solaris,
and some less good ones on linux, but little on Windows.

You might want to check out the J2SE Troubleshooting Guide for general
guidance:

http://java.sun.com/javase/6/webnotes/trouble/

The symptoms you describe sound like the system is hanging at a safepoint,
and I think there was a fix related to that in a later 6.0 update. But
that's a wild stab in the dark at this stage :)

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Jim Newsham
  Sent: Thursday, 27 March 2008 7:02 AM
  To: concurrency-interest at cs.oswego.edu
  Subject: [concurrency-interest] jvm hang




  Hi everyone,



  I apologize if this is not the best place to ask, but I don't know any
better resources (suggestions welcome).  Our application appears to hang the
JVM (1.6.0_02) pretty well, during application startup.  I am not able to
reproduce the problem on my machine (in fact, it does not occur on most
machines), but it occurs pretty frequently on a machine which I
unfortunately don't have direct access to.  Our application performs socket
operations (tcp and udp).  When the udp operations are disabled within the
app, the problem seems to go away, although that does not prove that it is
the cause of the problem.



  In this case, hanging means our application freezes and no further log
output is observed (including exceptions which might indicate a cause).  In
fact, the hang is so severe that jstat and jconsole are not able to connect
to the jvm.  I don't have detailed knowledge of the debug architecture, but
if jstat and jconsole fail to connect, it seems to me that there's a pretty
severe problem.



  In an attempt to get a thread dump, I added some code to our startup
sequence which starts a thread to perform a thread dump after some
command-line specified delay.  While waiting for the delay to elapse, it
prints countdown information to stderr ("dumping in 60 seconds". "dumping in
55 seconds". etc.).  However, this thread hangs too!  In other words, we see
the first few countdown messages, but no more.  Note that this thread does
not perform any locking and does not access external libraries; it only
sleeps in a loop until the time has elapsed, then uses java's ThreadMXBean
to get thread dump info.



  Does this sound like a JVM bug to you?  Are there any known bugs in this
JVM version which could account for this problem?  We haven't tried a more
recent version yet because we are releasing within just a few weeks and have
been developing/testing on a single JVM version.



  Thanks,

  Jim


-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080327/72cef06a/attachment.html 

From hontvari3 at solware.com  Fri Mar 28 17:37:20 2008
From: hontvari3 at solware.com (Hontvari Jozsef)
Date: Fri, 28 Mar 2008 22:37:20 +0100
Subject: [concurrency-interest] enable / disable interrupt
Message-ID: <47ED6510.5030101@solware.com>

I have read an elegant solution to the problem of interrupting a thread 
running third party code. The third party code may not respond in the 
expected way to the interrupt. One solution can be to run the third 
party code in a different thread, but this may make the code ugly and 
may double the count of threads. The proposed solution is to use a 
Thread subclass which overrides the interrupt method and adds functions 
to enable and disable interrupts.

It is in the book "Multithreaded Programming with JAVA Technology" by 
Bil Lewis; Daniel J. Berg:

public class InterruptibleThread extends Thread {
private boolean interruptsEnabled = false;
private boolean interruptPending = false;


public static void enableInterrupts() {
  InterruptibleThread self = InterruptibleThread.currentThread();

  synchronized (self) {
    self.interruptsEnabled = true;
    if (self.interruptPending) self.interrupt();
    self.interruptPending = false;
  }
}

public static void disableInterrupts() {
  InterruptibleThread self = InterruptibleThread.currentThread();

  synchronized (self) {
    if (interrupted()) self.interruptPending = true;
    self.interruptsEnabled = false;
  }
}

public synchronized void interrupt() {
  if (interruptsEnabled)
    super.interrupt();
  else
    interruptPending = true;
}


This book is relatively old, from 1999, but I don't find the idea 
implemented anywhere else. It seems to be so useful that if it does work 
then I would expect these functions to be included in the Java API 
already. But they aren't there of course. Is there something 
fundamentally wrong with this idea?


From dcholmes at optusnet.com.au  Sat Mar 29 21:21:25 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun, 30 Mar 2008 11:21:25 +1000
Subject: [concurrency-interest] enable / disable interrupt
In-Reply-To: <47ED6510.5030101@solware.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEBEHLAA.dcholmes@optusnet.com.au>

I think Bil's proposal is fairly unique, I've never seen it arise since
then - I was one of the four main reviewers of the book (as was Doug Lea).
Bil came at this from a POSIX threads background where there is an ability
to enable and defer asynchronous cancellation (which is very important). Bil
extended that to Java thread interruption through his simple subclass
implementation.

And that was that, it has never really been raised as an issue since. With
so few methods actively supporting interruption, and given that interruption
is synchronous anyway, then deferring interruption is rarely needed and
fairly easily accommodated - taking wait() as an example, you are waiting in
a loop - if you receive InterruptedException and want to keep waiting then
you flag the fact the interrupt occurred, and re-wait. You can then chose to
re-assert the interrupt, or rethrow the IE later.

Now if interruptible I/O had become common-place then perhaps the ability to
defer interrupts would have been more critical. But interruptible I/O was a
flawed idea that was only ever (partially) implemented on one platform (and
caused a lot of grief).

The main problem with third-party code is where they consume interrupts -
and Bil's proposal doesn't help much in that regard. Or perhaps it does. If
you assumed third-party code could not be trusted and you always deferred
interrupts while executing it, then upon return the interrupt would still be
pending and so would not be lost. But that would also deny the ability for
third-party code to respond to interrupts, so what gain in one place you
lose in another. And custom thread classes could track interrupts in other
ways.

Cheers,
David Holmes

> -----Original Message-----
> From: concurrency-interest-bounces at cs.oswego.edu
> [mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hontvari
> Jozsef
> Sent: Saturday, 29 March 2008 7:37 AM
> To: concurrency-interest at cs.oswego.edu
> Subject: [concurrency-interest] enable / disable interrupt
>
>
> I have read an elegant solution to the problem of interrupting a thread
> running third party code. The third party code may not respond in the
> expected way to the interrupt. One solution can be to run the third
> party code in a different thread, but this may make the code ugly and
> may double the count of threads. The proposed solution is to use a
> Thread subclass which overrides the interrupt method and adds functions
> to enable and disable interrupts.
>
> It is in the book "Multithreaded Programming with JAVA Technology" by
> Bil Lewis; Daniel J. Berg:
>
> public class InterruptibleThread extends Thread {
> private boolean interruptsEnabled = false;
> private boolean interruptPending = false;
>
>
> public static void enableInterrupts() {
>   InterruptibleThread self = InterruptibleThread.currentThread();
>
>   synchronized (self) {
>     self.interruptsEnabled = true;
>     if (self.interruptPending) self.interrupt();
>     self.interruptPending = false;
>   }
> }
>
> public static void disableInterrupts() {
>   InterruptibleThread self = InterruptibleThread.currentThread();
>
>   synchronized (self) {
>     if (interrupted()) self.interruptPending = true;
>     self.interruptsEnabled = false;
>   }
> }
>
> public synchronized void interrupt() {
>   if (interruptsEnabled)
>     super.interrupt();
>   else
>     interruptPending = true;
> }
>
>
> This book is relatively old, from 1999, but I don't find the idea
> implemented anywhere else. It seems to be so useful that if it does work
> then I would expect these functions to be included in the Java API
> already. But they aren't there of course. Is there something
> fundamentally wrong with this idea?
>
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest at altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From hanson.char at gmail.com  Sat Mar 29 23:42:22 2008
From: hanson.char at gmail.com (Hanson Char)
Date: Sat, 29 Mar 2008 20:42:22 -0700
Subject: [concurrency-interest] enable / disable interrupt
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEBEHLAA.dcholmes@optusnet.com.au>
References: <47ED6510.5030101@solware.com>
	<NFBBKALFDCPFIDBNKAPCAEBEHLAA.dcholmes@optusnet.com.au>
Message-ID: <ca53c8f80803292042r6832cd7au97a523ab35a4699@mail.gmail.com>

Hi David,


> But interruptible I/O was a
> flawed idea that was only ever (partially) implemented on one platform
> (and
> caused a lot of grief).


Why is interruptible I/O a flowed idea ?  Could you point me to more
information on this ?  Recently I realized there is no other way to
explicitly unblock a thread blocking on a socket read besides from another
thread, besides closing the underlying socket.  Not Thread.interrupt() or
even Thread.stop() would help in such scenario, potentially creating a black
hole of resource leakage.  I have been contemplating along the line of
implementing a form of general interruptible network I/O using such
socketing-closing technique, regardless of whether the socket was created
with any so_timeout a priori.

Hanson Char
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080329/8c7e1284/attachment.html 

From dcholmes at optusnet.com.au  Sun Mar 30 00:15:05 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Sun, 30 Mar 2008 14:15:05 +1000
Subject: [concurrency-interest] Interruptible I/O (was RE: enable / disable
	interrupt
In-Reply-To: <ca53c8f80803292042r6832cd7au97a523ab35a4699@mail.gmail.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEBHHLAA.dcholmes@optusnet.com.au>

Hi Hanson,

Interruptible I/O was a flawed idea because it didn't take into account what
state the underlying I/O "stream" was left in. It was conceived in terms of
simple reads and writes of N bytes and the InteruptibleIOException would
report have many bytes out of N had not been sent at the time of the
interrupt. That works okay at the lowest level of a protocol, but the
information is useless at higher-levels - imagine a HTTP GET request that is
interrupted and all it knows is that 23 bytes were left - 23 bytes of what?
the header, some protocol layer in the packet? what? And if a thread now
tries to read from that same stream what is it going to read? The next
missing byte of something. Basically once you interrupt a thread doing I/O
on a stream then the stream should be considered unusable.

Given that the real aim of interruptible I/O was for threads to unblock from
calls that weren't going to get serviced, there were better/safer ways to do
that:
- timeouts on the underlying socket operations
- closing the socket/stream

(Though for a long time there were issues - and maybe still are - because
Java didn't expose the APIs to set timeouts in all places that you'd want
them. And the close() semantics took some effort to get right on all
platforms.)

When the NIO API's were defined for InterruptibleChannels they took the same
approach: interrupt means close. So interrupting a thread blocked on an
InterruptibleChannel closes the channel. That way there is no issue about
what state the channel is left in.

I know this crops up from time to time. One of the most detailed write-ups
occurs in the evaluation for bug 4154947. In other bug reports you'll see
that this was eventually deprecated in the sense that Sun were never going
to try to implement it or support it. Even so, it is only in JDK 7 that
interruptible I/O will be disabled by default on Solaris. Things change over
time, particularly in relation to OS support etc. It turns out that its
fairly easy on Windows to allow a thread to be unblocked while waiting on
IO - you just do a waitForMultipleObjects on the IO handler and an interrupt
Event object. But that doesn't address the underlying issue with the state
of the stream.

Also as you note, nothing else gets you out of a blocked I/O operation, not
even Thread.stop - another reason the deprecation of Thread.stop was no
great loss.

Cheers,
David Holmes
  -----Original Message-----
  From: concurrency-interest-bounces at cs.oswego.edu
[mailto:concurrency-interest-bounces at cs.oswego.edu]On Behalf Of Hanson Char
  Sent: Sunday, 30 March 2008 1:42 PM
  To: dholmes at ieee.org
  Cc: concurrency-interest at cs.oswego.edu
  Subject: Re: [concurrency-interest] enable / disable interrupt


  Hi David,


    But interruptible I/O was a
    flawed idea that was only ever (partially) implemented on one platform
(and
    caused a lot of grief).

  Why is interruptible I/O a flowed idea ?  Could you point me to more
information on this ?  Recently I realized there is no other way to
explicitly unblock a thread blocking on a socket read besides from another
thread, besides closing the underlying socket.  Not Thread.interrupt() or
even Thread.stop() would help in such scenario, potentially creating a black
hole of resource leakage.  I have been contemplating along the line of
implementing a form of general interruptible network I/O using such
socketing-closing technique, regardless of whether the socket was created
with any so_timeout a priori.

  Hanson Char






-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080330/05505e85/attachment.html 

From mthornton at optrak.co.uk  Sun Mar 30 04:34:02 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Sun, 30 Mar 2008 09:34:02 +0100
Subject: [concurrency-interest] Interruptible I/O (was RE: enable /
 disable interrupt
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAEBHHLAA.dcholmes@optusnet.com.au>
References: <NFBBKALFDCPFIDBNKAPCAEBHHLAA.dcholmes@optusnet.com.au>
Message-ID: <47EF507A.6060401@optrak.co.uk>

David Holmes wrote:
> (Though for a long time there were issues - and maybe still are - 
> because Java didn't expose the APIs to set timeouts in all places that 
> you'd want them. And the close() semantics took some effort to get 
> right on all platforms.)
You still can't set time-outs on file operations, which is a pity in the 
case of network based files.

Mark Thornton


From hanson.char at gmail.com  Sun Mar 30 11:34:56 2008
From: hanson.char at gmail.com (Hanson Char)
Date: Sun, 30 Mar 2008 08:34:56 -0700
Subject: [concurrency-interest] Interruptible I/O (was RE: enable /
	disable interrupt
In-Reply-To: <47EF507A.6060401@optrak.co.uk>
References: <NFBBKALFDCPFIDBNKAPCAEBHHLAA.dcholmes@optusnet.com.au>
	<47EF507A.6060401@optrak.co.uk>
Message-ID: <ca53c8f80803300834h1e6e4315t9326c1b6173c9b27@mail.gmail.com>

True.  But since any file or network operation ultimately involves either an
input or output stream, if a separate thread is scheduled to execute upon a
timeout to close the stream, any blocking in-flight operations can be
unblocked, and therefore "interruptable".  Right ?

Hanson Char

On Sun, Mar 30, 2008 at 1:34 AM, Mark Thornton <mthornton at optrak.co.uk>
wrote:

> David Holmes wrote:
> > (Though for a long time there were issues - and maybe still are -
> > because Java didn't expose the APIs to set timeouts in all places that
> > you'd want them. And the close() semantics took some effort to get
> > right on all platforms.)
> You still can't set time-outs on file operations, which is a pity in the
> case of network based files.
>
> Mark Thornton
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: /pipermail/attachments/20080330/f82862bc/attachment.html 

From mthornton at optrak.co.uk  Sun Mar 30 11:46:31 2008
From: mthornton at optrak.co.uk (Mark Thornton)
Date: Sun, 30 Mar 2008 16:46:31 +0100
Subject: [concurrency-interest] Interruptible I/O (was RE: enable /
 disable interrupt
In-Reply-To: <ca53c8f80803300834h1e6e4315t9326c1b6173c9b27@mail.gmail.com>
References: <NFBBKALFDCPFIDBNKAPCAEBHHLAA.dcholmes@optusnet.com.au>	
	<47EF507A.6060401@optrak.co.uk>
	<ca53c8f80803300834h1e6e4315t9326c1b6173c9b27@mail.gmail.com>
Message-ID: <47EFB5D7.6050604@optrak.co.uk>

Hanson Char wrote:
> True.  But since any file or network operation ultimately involves 
> either an input or output stream, if a separate thread is scheduled to 
> execute upon a timeout to close the stream, any blocking in-flight 
> operations can be unblocked, and therefore "interruptable".  Right ?
>
> Hanson Char
>
> On Sun, Mar 30, 2008 at 1:34 AM, Mark Thornton <mthornton at optrak.co.uk 
> <mailto:mthornton at optrak.co.uk>> wrote:
>
>     David Holmes wrote:
>     > (Though for a long time there were issues - and maybe still are -
>     > because Java didn't expose the APIs to set timeouts in all
>     places that
>     > you'd want them. And the close() semantics took some effort to get
>     > right on all platforms.)
>     You still can't set time-outs on file operations, which is a pity
>     in the
>     case of network based files.
>
>     Mark Thornton
>
That is true of the nio based operations, but I think it was undefined 
for the original io classes. I seem to remember that there was at least 
one implementation where that approach did not work. Hopefully someone 
will be along to tell us which implementation that was and whether it is 
still true.

Mark Thornton

From dcholmes at optusnet.com.au  Sun Mar 30 18:47:20 2008
From: dcholmes at optusnet.com.au (David Holmes)
Date: Mon, 31 Mar 2008 08:47:20 +1000
Subject: [concurrency-interest] Interruptible I/O (was RE: enable /
	disable interrupt
In-Reply-To: <47EFB5D7.6050604@optrak.co.uk>
Message-ID: <NFBBKALFDCPFIDBNKAPCEEBIHLAA.dcholmes@optusnet.com.au>

Mark,

Mark Thornton wrote:
> That is true of the nio based operations, but I think it was undefined
> for the original io classes. I seem to remember that there was at least
> one implementation where that approach did not work. Hopefully someone
> will be along to tell us which implementation that was and whether it is
> still true.

Do you mean that "unblocking on close()" was not defined for the original
I/O classes ? That's true - it was a semantic that crept in over time, and
it took a while for it to be applied correctly on all platforms. The history
here is rather torturous to piece together but it's all in the bug parade
somewhere. Certainly "unblock on close()" has been the intended semantic for
a long time now.

Having a seperate thread asynchronously do the close() is not equivalent to
having a timeout on the operation in the first place, but it should unblock
the target - not that it is particularly convenient to setup and you always
have the inherent race-condition between the thread doing the close() and
the thread operating on the stream. The thread may even be unblocked and
processing data at the time the close() occurs. :(

I don't know whether something like NFS even exposes a way to set a timeout.
AFAIK to all the library code in between it is transparent whether or not a
file is local or remote.

Cheers,
David Holmes


