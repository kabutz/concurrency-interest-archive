From gergg@cox.net  Sun Jan  4 05:38:13 2004
From: gergg@cox.net (Gregg Wonderly)
Date: Sat, 3 Jan 2004 23:38:13 -0600
Subject: [concurrency-interest] AtomicInteger and AtomicLong should implement Number
Message-ID: <000501c3d284$f287fbe0$6401a8c0@Gregg>

It seems really odd to not have these two classes implement Number.  Is this an oversight, or am I missing something?

Gregg


From larryr@saturn.sdsu.edu  Sun Jan  4 09:14:26 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 4 Jan 2004 09:14:26 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <000501c3d284$f287fbe0$6401a8c0@Gregg>
Message-ID: <20040104091426.18864.qmail@home19.riedel.org>

> It seems really odd to not have [AtomicInteger and
> AtomicLong] implement Number.

Let me count the ways Java is odd or just plain lame.  I would
like to imagine the new stuff tries not to be encumbered by
antediluvian cruft like java.lang.Number, which is a Class,
not an Interface, and thus kind of Useless, thanks to the Java
precept that multiple inheritance of implementation is Evil,
leaving us with objects and "containers" duct taped together
with byzantine naming conventions, "dynamic Proxy"s, etc.


Larry


From tim@peierls.net  Sun Jan  4 12:56:34 2004
From: tim@peierls.net (Tim Peierls)
Date: Sun, 04 Jan 2004 07:56:34 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <20040104091426.18864.qmail@home19.riedel.org>
References: <20040104091426.18864.qmail@home19.riedel.org>
Message-ID: <3FF80D82.3080703@peierls.net>

Gregg Wonderly wrote:
>>It seems really odd to not have [AtomicInteger and
>>AtomicLong] implement Number.

Larry Riedel wrote:
> Let me count the ways Java is odd or just plain lame.  I would
> like to imagine the new stuff tries not to be encumbered by
> antediluvian cruft like java.lang.Number, which is a Class,
> not an Interface, and thus kind of Useless, thanks to the Java
> precept that multiple inheritance of implementation is Evil,
> leaving us with objects and "containers" duct taped together
> with byzantine naming conventions, "dynamic Proxy"s, etc.

And there's the less colorful reason that Number is implemented
in the JDK only by immutable classes, which the AtomicXXX
classes are most definitely not.

--tim



From david@walend.net  Sun Jan  4 20:41:03 2004
From: david@walend.net (David Walend)
Date: Sun, 04 Jan 2004 15:41:03 -0500
Subject: [concurrency-interest] Re: Fun with AbstractQueuedSynchronizers (Doug Lea)
References: <20031230170001.4901.30207.Mailman@altair.cs.oswego.edu>
Message-ID: <3FF87A5F.7010902@walend.net>

concurrency-interest-request@cs.oswego.edu wrote:

>From: Doug Lea <dl@cs.oswego.edu>
>Date: Tue, 30 Dec 2003 11:55:24 -0500
>To: concurrency-interest@altair.cs.oswego.edu
>Subject: [concurrency-interest] Fun with AbstractQueuedSynchronizers
>
>
>We've been fine-tuning AbstractQueuedSynchronizer and checking out
>whether it serves as a useful basis for various custom sync utilities
>and locks that we don't otherwise provide.  An example of one of these
>is below.  I couldn't figure out what to do with it after making it,
>so decided to post it here.
>
>It's an analog of a WIN32 "Consumable" Event, that can be done in only
>a few lines of implementation code, plus declarations and relays to
>tie these to public methods.  (We once contemplated providing
>something like this class in j.u.c. The reason we don't is that there
>are only rare occasions when you'd prefer to use this over a
>Semaphore, which is normally a better choice because it doen't "lose"
>signals.)
>  
>
Doug,

I think these will be handy for state-focused systems (as opposed to 
event-focused, where Semaphore is a better fit).  These systems tend to 
have something akin to a dog that can carry more than one newspaper.

An (possibly real-world) example: I've got one system that produces new 
jobs, and another that consumes all the available jobs as a batch. The 
producer and consumer share a ConsumedIndicator. The producer set()s it 
whenever it produces a job. The consumer await()s whenever it's not 
doing jobs.

A "nice-to-have" class. If I'm the only one who likes it, maybe save it 
for the next dluc as an example of how to use Sync.

Why "set()" and "await()"? To avoid confusion with "wait()", "notify()" 
and "notifyAll()" ?

Thanks,

Dave

-- 
David Walend
david@walend.net
http://www.walend.net



From gregg.wonderly@pobox.com  Mon Jan  5 03:08:05 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Sun, 04 Jan 2004 21:08:05 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <20040104091426.18864.qmail@home19.riedel.org>
References: <20040104091426.18864.qmail@home19.riedel.org>
Message-ID: <3FF8D515.4020209@cox.net>


Larry Riedel wrote:
>>It seems really odd to not have [AtomicInteger and
>>AtomicLong] implement Number.
> 
> Let me count the ways Java is odd or just plain lame.  I would
> like to imagine the new stuff tries not to be encumbered by
> antediluvian cruft like java.lang.Number, which is a Class,
> not an Interface, and thus kind of Useless, thanks to the Java
> precept that multiple inheritance of implementation is Evil,
> leaving us with objects and "containers" duct taped together
> with byzantine naming conventions, "dynamic Proxy"s, etc.

You know, I actually never noticed that Number was actually an abstract 
class.

Okay, so let me ask a different question.  Why can't this JSR fix this 
discrepency and change Number to an interface and provide a new abstract 
base class if that is still appropriate?

If all we do in JSRs is create new code and never fix the old cruft, 
then how will things ever get better?

Gregg


From gregg.wonderly@pobox.com  Mon Jan  5 03:13:05 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Sun, 04 Jan 2004 21:13:05 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <3FF8D515.4020209@cox.net>
References: <20040104091426.18864.qmail@home19.riedel.org> <3FF8D515.4020209@cox.net>
Message-ID: <3FF8D641.3070807@cox.net>


Gregg Wonderly wrote:
> Okay, so let me ask a different question.  Why can't this JSR fix this 
> discrepency and change Number to an interface and provide a new abstract 
> base class if that is still appropriate?

I recognize that this would not be a backward compatible change.  I 
wonder how many people would have extended Number...


From dholmes@dltech.com.au  Mon Jan  5 03:40:13 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Mon, 5 Jan 2004 13:40:13 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <3FF8D641.3070807@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCKEMGDLAA.dholmes@dltech.com.au>

> I recognize that this would not be a backward compatible change.  I
> wonder how many people would have extended Number...

Ignoring issues of whether Number should have been an interface, and
whether all Numbers must be immutable, exactly why do you think
AtomicInteger and AtomicLong should be Numbers?

AtomicInteger and AtomicLong are not numeric types, ala Integer, Long,
Float, BigDecimal etc, but simply utility classes to access int or
long values in an atomic way.

David Holmes


From larryr@saturn.sdsu.edu  Mon Jan  5 04:32:08 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 5 Jan 2004 04:32:08 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEMGDLAA.dholmes@dltech.com.au>
Message-ID: <20040105043208.32742.qmail@home19.riedel.org>

> Ignoring issues of whether Number should have been an interface,
> and whether all Numbers must be immutable, exactly why do you
> think AtomicInteger and AtomicLong should be Numbers?
> 
> AtomicInteger and AtomicLong are not numeric types, ala Integer,
> Long, Float, BigDecimal etc, but simply utility classes to access
> int or long values in an atomic way.

Speaking only for myself, from my exposure to, I guess 1000s of
class/interface/type names, and a few nearly ubiquitous naming
patterns/conventions, I can imagine someone seeing "AtomicInteger" and
"AtomicLong" and expecting/inferring they are a kind of Integer and
Long, respectively.  Since Integer, Long, and their lot are "Numbers",
I think it is natural to imagine that AtomicInteger and AtomicLong are
likely also "Number"s, perhaps they would be "AtomicNumbers".

In a context where there is something called AtomicReference, which
is a reference to an object, I would expect an object which holds
a reference to an object which is an Integer to be either of type
IntegerAtomicReference, or maybe AtomicIntegerReference, perhaps,
similar to "IntegerValue" in the standard Java JDI (JPDA) package.

In "AtomicInteger", my gut reaction is to think "Atomic" is an
adjective, and "Integer" is a noun, since that is how I almost
always see those words, so I can definitely see thinking an
"AtomicInteger" is an Integer which is Atomic, but then again that
seems kind of meaningless to me, and so I guess I would not try to
intuit whatever meaning may be there, and instead I would go to the
docos to figure out what an "AtomicInteger" is.

I feel pretty sure I could figure out what an IntegerAtomicReference
is, or maybe even an IntegerAtomic, figuring "Atomic" when used as a
noun says "an Atomic object contains an object reference which can
be updated atomically", and so an IntegerAtomic object "contains an
Integer object reference which can be updated atomically".


Larry


From dholmes@dltech.com.au  Mon Jan  5 05:36:51 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Mon, 5 Jan 2004 15:36:51 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040105043208.32742.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEMJDLAA.dholmes@dltech.com.au>

Larry Riedel wrote:
> Speaking only for myself, from my exposure to, I guess 1000s of
> class/interface/type names, and a few nearly ubiquitous naming
> patterns/conventions, I can imagine someone seeing
> "AtomicInteger" and "AtomicLong" and expecting/inferring they are a
kind of
> Integer and Long, respectively.

I agree that seeing the name alone might lead to that inference -
though it would seem more likely to lead to the inference that AtomicX
is a subtype of class X. My query was based on the premise that the
person asking the question was familiar with the descriptions of all
classes involved.

It would perhaps have been better to use AtomicInt rather than
AtomicInteger, and perhaps even better to use AtomicXValue as you
suggested. But I would hope that reading the class docs will quickly
dispel any confusion without the need to rename these classes at this
stage.

David Holmes


From larryr@saturn.sdsu.edu  Mon Jan  5 06:07:23 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 5 Jan 2004 06:07:23 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCMEMJDLAA.dholmes@dltech.com.au>
Message-ID: <20040105060723.576.qmail@home19.riedel.org>

> > I can imagine someone seeing "AtomicInteger" and "AtomicLong" and
> > expecting/inferring they are a kind of Integer and Long, respectively.
> 
> I agree that seeing the name alone might lead to that inference -
> though it would seem more likely to lead to the inference that AtomicX
> is a subtype of class X.

I would call a subtype of class X, "a kind of X", and I think it
would be correct to say an instance of that subtype "is" an X, in
the "Liskov Substitution Principle" sense.


> I would hope that reading the class docs will quickly dispel any
> confusion without the need to rename these classes at this stage.

I very much hope that reading the class docs will dispel any
confusion regardless of how obtusely the class is named, and
because of my unbridled optimism about "generics" in Java, I
think it does not matter what these particular names are. :)


Larry


From dholmes@dltech.com.au  Mon Jan  5 06:29:44 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Mon, 5 Jan 2004 16:29:44 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040105060723.576.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEMLDLAA.dholmes@dltech.com.au>

> I would call a subtype of class X, "a kind of X", and I think it
> would be correct to say an instance of that subtype "is" an X, in
> the "Liskov Substitution Principle" sense.

Sorry I didn't make the point very clearly, the original argument
went:

AtomicInteger is a kind of Integer
Integer is a kind of Number
=> AtomicInteger is a kind of Number

eg. class AtomicInteger extends/implements Number { ... }

where the more direct inference would simply be that:

 class AtomicInteger extends Integer

(and thereby is also a Number).


I wish that generics could have made this naming issue moot. :(

David Holmes


From gregg.wonderly@pobox.com  Mon Jan  5 14:47:11 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 05 Jan 2004 08:47:11 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCKEMGDLAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCKEMGDLAA.dholmes@dltech.com.au>
Message-ID: <3FF978EF.60309@cox.net>


David Holmes wrote:

>>I recognize that this would not be a backward compatible change.  I
>>wonder how many people would have extended Number...
> 
> 
> Ignoring issues of whether Number should have been an interface, and
> whether all Numbers must be immutable, exactly why do you think
> AtomicInteger and AtomicLong should be Numbers?

I have numerous applications in multithreaded environments where 
integers and floating point numbers are used to track the values of 
external entities.  These applications use XML and other descriptive 
mechanisms to create forumla to relate these values in useful ways 
(volume/unit-time etc.).  What I see happening is that users of my 
applications will look at these classes as useful ways to accomidate 
synchronized programming involving calculations with numeric values.  I 
can currently use the 'is a Number' test to accomodate a wide range of 
numeric values in the low level evaluation code.

If I have to add support for these classes, I will not have a generic 
reference type to make the processing of these values easily accomodated.

It appears to me that these two classes are used largely for counting 
semaphore type operations.  My software is used in such ways that the 
statistics present in these values would be very useful for status 
monitoring of systems that use these classes.

> AtomicInteger and AtomicLong are not numeric types, ala Integer, Long,
> Float, BigDecimal etc, but simply utility classes to access int or
> long values in an atomic way.

But they contain values that might be referenced in such a way, and 
having to have two references to the same value by doing

	AtomicInteger i1 = new AtomicInteger(0);
	... and later...
	externalRef = new Integer( i1.get() );

is not going to produce high quality applications.

Think about someone instrumenting their application (perhaps with JMX) 
and how effectively they could extract statistics about all the classes 
in this JSR to 'see' where resource contention is occuring because of 
synchronization issues.

If it seems late to change java.lang.Number, then let's think about 
replicating that class as an interface somewhere in the package tree
so that there is a greater opportunity to reduce the total number of 
class names that an application has to be aware of to 'see' into 
applications written with these classes.

In particular, remote applications (Jini, JMX etc), beg us all to 
consider just how different we should make the interface to any class we 
would use in these environments.

I would imagine a lot of people taking these classes and using them in 
unimaginable ways because everyone will see the word Atomic in the name 
and think wow this will keep be from spewing 'synchronized' all over my 
code.  Then, others of the numerically minded type will see 'Integer' 
and 'Long', and say wow, "Number"s this will let me have lots of 
calculating threads that can just bang on these values and I won't have 
to worry about 'synchronized'.

Think big, design with a simple API...



From larryr@saturn.sdsu.edu  Mon Jan  5 19:11:02 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 5 Jan 2004 19:11:02 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEMLDLAA.dholmes@dltech.com.au>
Message-ID: <20040105191102.1432.qmail@home19.riedel.org>

> the original argument went:
> 
> AtomicInteger is a kind of Integer
> Integer is a kind of Number
> => AtomicInteger is a kind of Number
> eg. class AtomicInteger extends/implements Number { ... }
> 
> where the more direct inference would simply be that:
>  class AtomicInteger extends Integer
> (and thereby is also a Number).

The reason I avoid even suggesting "extend"ing from a class is that
Java has not traditionally provided support for multiple inheritance
of implemention, which has lead to using naming conventions and/or
runtime gyrations to produce an object which looks and behaves as
though its class Q had inherited implemention from class X and class
Y, but which, from the point of view of the language/compiler, is
unrelated to class X or class Y.  As an application programmer I
still think of that object as being "an X" or "a kind of X" because
that is the intent, even though Java says it is neither.  If Number
was an interface, and Integer was an interface, then I /would/ think
it might be nice to see "interface AtomicInteger extends Integer".

I myself often wind up doing what I think was suggested elsewhere
in this thread, which is to just take the method signature of a
class and copy it into an interface ("INumber" or whatever) and have
the class implement that interface, if I am at liberty to do that.
This also helps me avoid the problem of having to answer questions
from maintenance programmers and users of an API like "in class Q,
why do you inherit from class X and delegate to objects of class Y
and class Z rather than inheriting from class Y and delegating to
objects of class X and class Z, or inheriting from class Z ...",
and having to say "Java only lets me inherit from one, so I had to
pick one, so I rolled the dice and it came up 'X'".  That does not
go over too well when someone says "but I have a bunch of code which
expects to receive a Y object, and your object is an X object, even
though it has all the methods of a Y and behaves just like a Y".
I would rather just forget the class "extend"ing altogether.

If I just avoid "extend"ing classes, and either going with all
interfaces or naming conventions (a J2EE approach) it makes
this kind of thing less confusing, because at least it is lame in
a consistent rather than arbitrary way.  But when a third-party
library like the JDK says "Number is a class, Integer is a class
(which extends Number), AtomicInteger is a class (which wraps an
Integer), but an AtomicInteger is not an Integer or Number", I guess
it is time to go write more wrappers to get around JDK obliqueness.
I would like to mention that I think the people in the JCP/JSR
groups are doing an outstanding job of making the best new stuff,
given the obscenely ugly JDK 1.[01] and Java language legacy, and
it looks to me like most of the inelegances in JSR-166 are a result
of that legacy, not because of poor working group decision making.


Larry


From dholmes@dltech.com.au  Mon Jan  5 23:11:48 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 6 Jan 2004 09:11:48 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040105191102.1432.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCAENCDLAA.dholmes@dltech.com.au>

Larry Riedel wrote:
> The reason I avoid even suggesting "extend"ing from a class is that
> Java has not traditionally provided support for multiple inheritance
> of implemention, which has lead to using naming conventions and/or
> runtime gyrations to produce an object which looks and behaves as
> though its class Q had inherited implemention from class X and class
> Y, but which, from the point of view of the language/compiler, is
> unrelated to class X or class Y.

I'm not going to debate the merits or otherwise of Java's object
model, but I want to clarify some intentions:

The AtomicX classes are "wrappers" for accessing primitive values or
references using atomic instructions. AtomicInteger is not a wrapper
for java.lang.Integer and the name was not meant to imply that. The
atomic classes allow for lock-free synchronization in some situations
(though actual lock-freedom is a quality of implementation issue).

That said I'm still digesting Gregg's detailed comments.

David Holmes


From dawidk@mathcs.emory.edu  Tue Jan  6 03:27:06 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 5 Jan 2004 22:27:06 -0500
Subject: [concurrency-interest] ITL and revised ThreadContext
Message-ID: <000001c3d404$f762c970$16fb8caa@mathcs.emory.edu>

Here is the problem that I have in my application. 

I have an asynchronous RMI library. When the remote async call is
initiated by the client, the invocation request is wrapped into a
FutureTask, and then passed on to an executor. Hence, the actual call
occurs in a thread different than the initiator thread. 

The library allows user to provide custom transport protocol layer, via
custom RMI socket factories known from standard RMI. I want to use this
mechanism to enable SSL connections to a secure service which requires
clients to authenticate themselves. Client application may have multiple
threads of execution, each of them has its own X.509 identity (stored in
a thread-local) and makes calls to the secure service.

To achieve that, I defined SSLSocketFactory which creates SSL sockets
using X.509 identity fetched from a thread-local during factory
construction. However, here comes the problem. The common case in RMI is
that remote method called on a remote stub returns another remote stub
as a result. When we make such a call, the resulting stub (and factory
which sits inside it) is constructed by the thread which is processing
the call in question. In case of an async call, it is a thread supplied
by the executor, and it does not have proper X.509 ID set. It leads to
"UnmarshallException: cannot determine client ID.".

The missing link is propagation of a thread local from call-initiating
thread to the executor thread. Usually, I was able to workaround such
issues using specific knowledge about the thread-local that needed to be
propagated. But here, the RMI library has no knowledge of specific
socket factories, hence it has no idea which thread-locals they depend
on.


Given the above example, and unless somebody can offer a reasonable
workaround, I would like to propose a revised (weakened) version of the
ThreadContext idea. The weakening here is that only the inheritable
thread locals are propagated:

/**
 * Represents the snapshot of a inheritable state of a thread. 
 * The inheritable state consists of inherited thread local values, 
 * context class loader, and priority.
 */
public class ThreadContext {

    /**
     * Returns the snapshot of the inheritable stat of the current
thread.
     * Note that this method does not have race condition problems as it

     * accesses only the *current* thread.
     */
    public static ThreadContext getContext() { ... }

    /**
     * Performs a given task within this context, as if by a new thread
created
     * by the original thread. (The "as if" means "with context class
loader,
     * priority, and inherited thread locals of".)
     */
    public void perform(final Runnable task) { ... }
}

Please note that the properties delegated by the ThreadContext are
subset of those which newly created threads inherit from their parent
threads anyway.

This solution does not suffer from race conditions, and it does not
propagate more data than normal thread creation, so, for Heaven's sake,
please tell me what's possibly wrong with it before you reject it :)

And in response to earlier comments:

Tim Peierls:
> The implementation of perform(Runnable) copies ThreadLocalMaps, whose 
> size is unpredictable, so this is not necessarily a lightweight call. 

I seems to me that application which has very large number of
thread-local variables (rather than few variables pointing to large data
structures) is ill-conceived and will probably suffer from more serious
bottlenecks (e.g. lookup costs). Also, the perform(Runnable) is more
lightweight than a thread construction which, too, copies inheritable
thread locals.

Tim Peierls:
> apparently the temporary adoption of another thread's ThreadLocals
raises 
> thorny issues. Josh Bloch's brief summary was that "it causes more
problems 
> than it solves."

If Josh Bloch says so, he is probably right (what does he think about
the weakened version, anyway?) but since it would definitely solve MY
problems, I insist on being explained where the thorns are :)

Seriously, I could see problems with my original proposal: it would
break the assertion that an object stored in a thread local is not
accessible to other threads unless the reference is explicitly leaked
out; this assertion blessed "synchronized-less" access. But there never
was such assertion for inheritable thread locals, so the revised
proposal is not prone to this.

Doug Lea:
> For example, a one-time ITL "capture" doesn't address requests to 
> save/restore across tasks, which can otherwise only be done one-by-one

> inside ThreadPoolExecutor before/after methods.

I am not fully familiar with the issue, but if I understand correctly,
it is about tasks or executors which maintain "thread local state"
between calls. If so, why can't the task/executor create the thread
snapshot on task completion, then perform the next task within that
snapshot, then remember the new snapshot on completion, and so on, thus
passing the state from call to call as a ThreadContext?...

Regards,
Dawid


From larryr@saturn.sdsu.edu  Tue Jan  6 04:13:35 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 6 Jan 2004 04:13:35 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCAENCDLAA.dholmes@dltech.com.au>
Message-ID: <20040106041335.3193.qmail@home19.riedel.org>

> The AtomicX classes are "wrappers" for accessing primitive values or
> references using atomic instructions. AtomicInteger is not a wrapper
> for java.lang.Integer and the name was not meant to imply that. The
> atomic classes allow for lock-free synchronization in some situations
> (though actual lock-freedom is a quality of implementation issue).

My impression, as someone who would just be an application
programmer using stuff in java.util.concurrent, is that
AtomicInteger is in essence providing "atomic test and set" of a
numeric value, a most fundamental operation.  If so, then I think in
the context of an "object-oriented" style API it might be natural
to hope an AtomicInteger would provide a way to /be/ the value it
contains, in the same way an Integer does.  It is because of this
impression I have that I think it makes sense to wonder "why is an
AtomicInteger not a Number" (the topic of this thread).  Just from
looking at the JDK, I think one good answer could be "because legacy
issues with Number make it undesirable from an implementation point
of view"; but it would still make sense to me to try to provide
/some/ shared ancestor type which provides a /single/ way to get
the value from an Integer /or/ an AtomicInteger.  However, if there
is an expectation that the AtomicInteger will not be the means for
seeing the value, then I guess whatever else is taking care of that
should worry about how to "be" the value.  Also, I have no idea how
this all fits in with "autoboxing"-- maybe it is all moot because
there will just be an "operator int()" or something like that?


Larry


From dholmes@dltech.com.au  Tue Jan  6 04:56:24 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 6 Jan 2004 14:56:24 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <3FF978EF.60309@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCMENGDLAA.dholmes@dltech.com.au>

Gregg Wonderly wrote:
> But they contain values that might be referenced in such a way, and
> having to have two references to the same value by doing
>
> 	AtomicInteger i1 = new AtomicInteger(0);
> 	... and later...
> 	externalRef = new Integer( i1.get() );
>
> is not going to produce high quality applications.

If you are currently doing calculations with ints and floats, then
presumably you must convert to Integer and Float at some point to
externalize those values (I presume this because Integer et al are
immutable and not conducive to use directly in calculations). If so,
then you would replace those int's (there's no atomic float support)
with AtomicIntegers where appropriate and then convert the
AtomicInteger to an Integer when needed - there's no extra step just a
different starting point.

> I would imagine a lot of people taking these classes and
> using them in unimaginable ways because everyone will see
> the word Atomic in the name and think wow this will keep be
> from spewing 'synchronized' all over my code.

They would be mistaken in many cases. Any kind of calculation using
concurrently updating values will likely require atomicity that can't
be achieved by accessing the individual values atomically.

The uses for these classes are fairly simple in the direct sense. The
algorithms that utilise them can be extremely sophisticated of course.

> Then, others of the numerically minded type will see 'Integer'
> and 'Long', and say wow, "Number"s this will let me have lots of
> calculating threads that can just bang on these values and
> I won't have to worry about 'synchronized'.

Given that Integer and Long et al are immutable anyone associating
AtomicInteger with Integer and AtomicLong with Long should immediately
become extremely puzzled as they wonder what it is about an immutable
value that needs to be made atomic ;-)

I could buy into your argument if we were talking about existing
general-purpose arithmetic classes, but we're not, we're talking about
the immutable wrapper classes. And AtomicInteger and AtomicLong do not
even pertain to Integer and Long but to int and long.

So while I can envisage a world with a broad range of numerical
support classes where AtomicX forms part of the spectrum, that is not
the world we have in Java today and it's not the world AtomicInteger
and AtomicLong were designed for.

The only thing that Number gives you is the ability to convert to any
of the primitive numeric types and that is of extremely limited
usefulness.

I am becoming more convinced however that we should change the names
to AtomicIntValue and AtomicLongValue just to avoid the possibility of
associating these with Integer and Long.

Cheers,
David Holmes


From dholmes@dltech.com.au  Tue Jan  6 05:09:20 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 6 Jan 2004 15:09:20 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040106041335.3193.qmail@home19.riedel.org>
Message-ID: <NFBBKALFDCPFIDBNKAPCGENHDLAA.dholmes@dltech.com.au>

Larry Riedel wrote:
> but it would still make sense to me to try to provide
> /some/ shared ancestor type which provides a /single/ way to get
> the value from an Integer /or/ an AtomicInteger.

The fact that this makes sense concerns me, because there was never an
intent to associate AtomicInteger with Integer or AtomicLong with
Long, or to suggest that one might ever want to replace an Integer by
an AtomicInteger etc. Will changing the names to AtomicIntValue and
AtomicLongValue break this association?

Would it also help clarify things if I said that what some people
really wanted to do was introduce an 'atomic' field modifier and
introduce a test-and-set operator, but there was no way that was going
to happen so we had to define the AtomicX classes?

Cheers,
David Holmes


From larryr@saturn.sdsu.edu  Tue Jan  6 08:09:48 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 6 Jan 2004 08:09:48 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCGENHDLAA.dholmes@dltech.com.au>
Message-ID: <20040106080948.4134.qmail@home19.riedel.org>


> > but it would still make sense to me to try to provide
> > /some/ shared ancestor type which provides a /single/ way to get
> > the value from an Integer /or/ an AtomicInteger.
> 
> The fact that this makes sense concerns me, because there was never an
> intent to associate AtomicInteger with Integer or AtomicLong with
> Long, or to suggest that one might ever want to replace an Integer by
> an AtomicInteger etc. Will changing the names to AtomicIntValue and
> AtomicLongValue break this association?
> 
> Would it also help clarify things if I said that what some people
> really wanted to do was introduce an 'atomic' field modifier and
> introduce a test-and-set operator, but there was no way that was
> going to happen so we had to define the AtomicX classes?

With Integer vs "AtomicIntValue", I am imagining that while there is
some stuff to do with how/when/if the value gets changed, the bottom
line is there is a single primitive "int" value somewhere, and it is
the value of that int which is the critical piece of information, and
from the point of view of something which just wants to know what the
value is, it makes no difference whether the value is under the control
of an Integer or an AtomicIntValue, or whatever.  I think this would be
the basis of any (mis)understanding I have.

I know when it comes to parallel threads accessing some value there
is some stuff about memory barriers and "volatile" and "synchronized"
and I need to do things the right way in my code if I want to make
sure the threads see uptodate values; but the type of the value is
the type of the value, regardless.  If instead of a language thing
"volatile int i", there was a "VolatileIntValue i", I would still think
the fundamental value is an "int" and I want to be able to use it as
an int.  Otherwise it would seem to me like the tail is wagging the dog.

As far as replacing "Integer" with "AtomicInteger", I would expect that
to be equivalent to if there was a keyword "atomic" and I was thinking
about replacing "int i" with "atomic int i".  Sure that seems like
something I would like to do if it means I could get rid of some extra
code I had written to ensure atomic updates to "i" before the "atomic"
feature became part of the language.

(I treat "Integer" and "int" as the same, because my expectation has
been that auto(un)?boxing with JDK 1.5 will make that effectively true)


Larry


From Mark.Moir@Sun.COM  Tue Jan  6 18:38:06 2004
From: Mark.Moir@Sun.COM (Mark Moir)
Date: Tue, 06 Jan 2004 13:38:06 -0500
Subject: [concurrency-interest] Workshop on Concurrency and Synchronization in Java Programs
Message-ID: <3FFB008E.9030405@sun.com>

Dear Colleagues

Apologies if you get multiple copies of this announcement.

Please see the CFP below for the 2004 Workshop on Concurrency and 
Synchronization in Java Programs to be held in conjunction with
ACM Symposium on Principles of Distributed Computing in Newfoundland
this coming July.  Please consider submitting a paper, and encourage
your students and colleagues to do the same!  The CFP is also at

   http://www.podc.org/podc2004/JavaWorkshop-cfp.txt

The deadline for submissions is April 4th, but authors wishing to have 
their papers considered for a joint session with PODC must submit to 
PODC by its regular deadline.  For details, see

   http://www.podc.org/podc2004

Cheers

Mark


     Workshop on Concurrency and Synchronization in Java Programs

                   St John's, Newfoundland, Canada

                            24-25 July 2004


SCOPE

Synchronization is fast becoming  a major performance and design issue
for concurrent  programming on modern architectures.   With the advent
of  JSR166,  the  new  Java(TM)  Concurrency  Package,  new  low-level
synchronization  primitives   and  high-level  constructs   are  being
introduced  into the Java  language. In  light of  these developments,
there is a unique window of opportunity for the Java Community and the
PODC  community  to join  forces  in  evaluating  and planning  future
directions for synchronization in general, and Java synchronization in
particular.  The goal of this  workshop is to bring about a productive
interaction  between   members  of  the   two  communities,  targeting
interesting  synchronization problems, solutions,  constructs, models,
and other core aspects of synchronization in Java programs.


TOPICS

Contributions are solicited in all areas related to synchronization in
concurrent  Java  programs.   While  synchronization in  Java  Virtual
Machine  implementations directly related  to synchronization  in Java
programs  is   also  of  interest,  papers  whose   primary  focus  is
synchronization  in other  parts of  a  Java Virtual  Machine are  not
appropriate.

Specific topics of interest include, but are not limited to:

  - use of JSR166 (Java Concurrency Package) features
  - implementation of JSR166 features in JVMs
  - scalability
  - concurrent data structure implementations in Java programs
  - case studies
  - nonblocking synchronization
  - Java Memory Model
  - synchronization constructs, e.g., software transactional memory
  - language and semantics ("what if"s)
  - Java synchronization vs. synchronization in alternative environments
  - compiler transformations
  - effect of garbage collection on difficulty of synchronization
  - performance and scalability analysis techniques
  - performance and scalability studies of important applications
  - hard synchronization problems without adequate solutions


PAPER SUBMISSION

Submitted papers should be  orginal, unpublished work.  The main focus
in selecting workshop contributions will be the intrinsic interest and
timeliness of the  work, so authors are encouraged  to submit polished
descriptions  of  work  in  progress  as  well  as  papers  describing
completed projects.

Accepted papers will be  included in an informal workshop proceedings,
and can subsequently be submitted to more formal publication venues if
this is allowed by the rules of those venues.  Papers can be submitted
to  both PODC  and the  workshop, and  if appropriate  submissions are
accepted to both, a special joint session will be included in the PODC
program.  Authors wishing  to have their papers considered  for such a
session  should submit  their paper  separately to  both PODC  and the
workshop,  indicating  on  the  cover  page  of  each  that  they  are
interested in the joint session.  Papers accepted to the joint session
will be  published in the PODC  proceedings as usual,  and in addition
will  have   their  abstracts  published  in   the  informal  workshop
proceedings.  A special journal  issue associated with the workshop is
being considered.

All submissions will  be handled electronically and must  be in PDF or
PostScript format. Papers must not  exceed 10 pages (US "Letter" size,
8.5 x 11 inches) including text, figures and references. The font size
must be at least 11 points.


ELECTRONIC SUBMISSIONS INSTRUCTIONS

   - to be announced


IMPORTANT DATES

   - Feb 15, 2004      Deadline for submission to PODC (and joint session)
   - April 4th, 2004   Deadline for submission to workshop
   - June 1st, 2004    Acceptance/rejection notifications
   - June 18th, 2004   Camera-ready papers due
   - July 24-25  2004  Workshop in Newfoundland


PROGRAM CO-CHAIRS:

Mark Moir          Nir Shavit
Mark.Moir@Sun.COM  Nir.Shavit@Sun.Com
Sun Microsystems Laboratories
1 Network Drive
Burlington, MA 01803
USA


PROGRAM COMMITTEE

David Bacon, IBM
Hans Boehm, HP
Josh Bloch, Sun
David Detlefs, Sun Labs
Tim Harris, Cambridge University
Maurice Herlihy, Brown University
David Holmes, DLTeCH Pty Ltd
Doug Lea, SUNY Oswego
Mark Moir, Sun Labs (Co-Chair)
Vivek Sarkar, IBM
Nir Shavit, Sun Labs (Co-Chair)
Martin Rinard, MIT
Jan Vitek, Purdue University


From gregg.wonderly@pobox.com  Tue Jan  6 19:32:42 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Tue, 06 Jan 2004 13:32:42 -0600
Subject: [ David Holmes ] [concurrency-interest] Re: AtomicInteger and
 AtomicLong should implement Number
In-Reply-To: Your message of Tue, 06 Jan 2004 14:56:24 +1000.
 <NFBBKALFDCPFIDBNKAPCMENGDLAA.dholmes@dltech.com.au>
Message-ID: <7660.1073417562@skymaster.cytetech.com>

>Gregg Wonderly wrote:
>> But they contain values that might be referenced in such a way, and
>> having to have two references to the same value by doing
>>
>> 	AtomicInteger i1 = new AtomicInteger(0);
>> 	... and later...
>> 	externalRef = new Integer( i1.get() );
>>
>> is not going to produce high quality applications.
>
>If you are currently doing calculations with ints and floats, then
>presumably you must convert to Integer and Float at some point to
>externalize those values (I presume this because Integer et al are
>immutable and not conducive to use directly in calculations). If so,
>then you would replace those int's (there's no atomic float support)
>with AtomicIntegers where appropriate and then convert the
>AtomicInteger to an Integer when needed - there's no extra step just a
>different starting point.

One of the potential uses is to write data to a database and objects must be 
converted to java.sql data types to do this.  Number types are automatically 
converted already.  Another use is reflection.  Where, a value is converted to 
a string to be written to a properties file or some other textual 
representation.  In both of these cases, the lack of 'is a Number' increases 
the complexity of the code involved.

>
>> I would imagine a lot of people taking these classes and
>> using them in unimaginable ways because everyone will see
>> the word Atomic in the name and think wow this will keep be
>> from spewing 'synchronized' all over my code.
>
>They would be mistaken in many cases. Any kind of calculation using
>concurrently updating values will likely require atomicity that can't
>be achieved by accessing the individual values atomically.

Imagine parallel operating threads that are measuring some parameter and 
recording that value in a sum.  AtomicX.getAndAdd() provides a way to do this 
summing with synchronization.

>The uses for these classes are fairly simple in the direct sense. The
>algorithms that utilise them can be extremely sophisticated of course.
>
>> Then, others of the numerically minded type will see 'Integer'
>> and 'Long', and say wow, "Number"s this will let me have lots of
>> calculating threads that can just bang on these values and
>> I won't have to worry about 'synchronized'.
>
>Given that Integer and Long et al are immutable anyone associating
>AtomicInteger with Integer and AtomicLong with Long should immediately
>become extremely puzzled as they wonder what it is about an immutable
>value that needs to be made atomic ;-)

Yes, a lot of people use the Number subclasses to do math and do have to 
recreate the result Object.  That is one of the issues.  But, my main interest 
is in arriving at a solution to all the referential uses of these values.  In 
the lowest level of my expression evaluation, you will find (as you might 
imagine) code of the form

	new Double(((Number)obj1).doubleValue() * ((Number)obj2).doubleValue())

The cast to Number and the promotion to double are simplifying capabilities. 

>I could buy into your argument if we were talking about existing
>general-purpose arithmetic classes, but we're not, we're talking about
>the immutable wrapper classes. And AtomicInteger and AtomicLong do not
>even pertain to Integer and Long but to int and long.

I don't know what kind of software you have written or used the Number 
descendants with, but I have used these values all over the software that I 
have because I have Hashtable and Vector and List objects that must have 
objects in them.  So, anyplace that I have numeric values, I have to use these 
classes.  So, for me, these are general-purpose arithmetic classes because I
do have to use them in lots of places.  The fact that the Number subclasses 
are immutable is an issue in and of itself.  But, it does provide a 
simplifying capability for security implementation and for some optimizations.

>So while I can envisage a world with a broad range of numerical
>support classes where AtomicX forms part of the spectrum, that is not
>the world we have in Java today and it's not the world AtomicInteger
>and AtomicLong were designed for.
>
>The only thing that Number gives you is the ability to convert to any
>of the primitive numeric types and that is of extremely limited
>usefulness.

It depends on what types of applications you write.  I sounds like you may not 
have encountered applications that utilize JDBC and/or reflection techniques 
to carry data types around.  Anything that provides a generic value transport 
or coversion mechanism as part of its API is saddled with this issue, and it 
is those types of applications that I am trying to bring forward as issues for 
these two classes.

I also believe that it would be wise to provide a 'double' value version of 
these classes and make them even more generic in expected use.

>I am becoming more convinced however that we should change the names
>to AtomicIntValue and AtomicLongValue just to avoid the possibility of
>associating these with Integer and Long.

I think that this doesn't change the use cases that people will find for these 
classes.  I think you are underestimating the needs that people will see these 
classes filling.

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From hans_boehm@hp.com  Tue Jan  6 21:16:35 2004
From: hans_boehm@hp.com (Boehm, Hans)
Date: Tue, 6 Jan 2004 13:16:35 -0800
Subject: [ David Holmes ] [concurrency-interest] Re: AtomicInteger and
 AtomicLong should implement Number
Message-ID: <0C3EFB691636964BBF914AE56AE83A89501EC0@hplex4.hpl.hp.com>

If I understand this correctly, it seems to me that the real question here
is whether inheritance from java.lang.Number was intended to imply immutability.
The spec doesn't currently say so.  According to the spec, it implies only
convertibility to numeric types, a condition that should clearly be satisfied by
AtomicInteger and AtomicLong.

Thus it seems to me that either:

1) AtomicInteger and AtomicLong should inherit from Number, or

2) The description of java.lang.Number should specify that subclasses of Number
should be immutable.

In either case, it appears to me that a change is required to keep this from getting ugly.

Hans

From dholmes@dltech.com.au  Tue Jan  6 23:23:56 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 7 Jan 2004 09:23:56 +1000
Subject: [ David Holmes ] [concurrency-interest] Re: AtomicInteger and  AtomicLong should implement Number
In-Reply-To: <7660.1073417562@skymaster.cytetech.com>
Message-ID: <NFBBKALFDCPFIDBNKAPCCEOADLAA.dholmes@dltech.com.au>

Gregg Wonderly wrote:
> One of the potential uses is to write data to a database
> and objects must be converted to java.sql data types to do this.
> Number types are automatically converted already.
> Another use is reflection.  Where, a value is converted to
> a string to be written to a properties file or some other textual
> representation.  In both of these cases, the lack of 'is a
> Number' increases the complexity of the code involved.

I'm coming from a position where I see the atomic classes as
specialized syntax for atomically accessing primitive fields. The fact
that we end up with objects is an implementation artefact. I fully
realize there are places where primitives must be objectified to be
used, but I didn't consider direct use of the AtomicX objects as
replacements for current use of Integer et al. I've expected people to
just use get() and turn that into an Integer or Long if needed (though
most usage contexts I'm involved in don't need that - I write
"systems" code, though I have used java.sql in a past life).

What I'm realising from this discussion is that people may well see
AtomicInteger and AtomicLong as mutable replacements for Integer and
Long, even in contexts where the atomicity may not be needed. That
wasn't a usage that I had contemplated - and it does concern me a bit.
Arguably Java needs mutable arithmetic objects but that wasn't what we
set out to do with the atomic classes. We're not trying to fix the
numeric type hierarchy here and I for one would rather not do anything
that suggests that we are.

Code that wants to utilise the atomic classes will be rewritten anyway
and if an AtomicInteger has to be converted to an Integer at some
stage then I don't think that is unreasonable, as an int would have to
have been converted to an Integer too.

> So, anyplace that I have numeric values, I have to use these
> classes.  So, for me, these are general-purpose arithmetic
> classes because I do have to use them in lots of places.

They are general purpose wrapper classes - they objectify primitive
numeric types. To be general-purpose arithmetic classes I'd expect
them to support arithmetic (think C++, operator overloading etc).

> I also believe that it would be wise to provide a 'double'
> value version of
> these classes and make them even more generic in expected use.

As far as I am aware you cannot provide AtomicFloat/Double without
using locks. So while we could define such classes it would be
misleading, and not commensurate with the goals of JSR-166. I can see,
from your perspective, how having such a class would make the type
hierarchy more complete - but we're not trying to define a numeric
type hierarchy here.

Cheers,
David Holmes

Cheers,


From dl@cs.oswego.edu  Wed Jan  7 00:55:26 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 6 Jan 2004 19:55:26 -0500
Subject: [concurrency-interest] Re: AtomicInteger and
 AtomicLong should implement Number
In-Reply-To: <0C3EFB691636964BBF914AE56AE83A89501EC0@hplex4.hpl.hp.com>
References: <0C3EFB691636964BBF914AE56AE83A89501EC0@hplex4.hpl.hp.com>
Message-ID: <16379.22782.14117.510679@altair.cs.oswego.edu>

The package documentation for atomics has the main rationale
for not relating AtomicInteger etc to Number:

     ... And atomic classes are not general purpose replacements for
     java.lang.Integer and related classes. They do NOT define methods
     such as hashCode and compareTo. (Because atomic variables are
     expected to be mutated, they are poor choices for hash table
     keys.) Additionally, classes are provided only for those types
     that are commonly useful as atomics. For example, there is no
     atomic class for representing byte. In those infrequent cases
     where you would like to do so, you can use an AtomicInteger to
     hold byte values, and cast appropriately. Similarly, you can hold
     floating point types using Float.floatToIntBits and
     Float.intBitstoFloat conversions.

Note in particular that AtomicInteger cannot be a Number because it
would break the hashcode contract. And it would not have a symmetric
equals method.  

(Also note that AtomicReference is not a java.lang.ref.Reference.)

My first version of AtomicInteger actually was called AtomicInt, which
at the time sounded like a good indicator of difference.  But this ran
against the strange but consistent convention of spelling out Integer
when it appears in Java class names. And no such naming trick is
available to indicate that AtomicLong is not related to Long.

Things might have been different had there been pre-existing classes
MutableInteger, MutableLong, etc, but there aren't.

So my current view is still that the names of these classes are about
the best we can do.

-Doug

From gregg.wonderly@pobox.com  Wed Jan  7 03:38:03 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 06 Jan 2004 21:38:03 -0600
Subject: [concurrency-interest] Re: AtomicInteger and	  AtomicLong should
 implement Number
In-Reply-To: <16379.22782.14117.510679@altair.cs.oswego.edu>
References: <0C3EFB691636964BBF914AE56AE83A89501EC0@hplex4.hpl.hp.com> <16379.22782.14117.510679@altair.cs.oswego.edu>
Message-ID: <3FFB7F1B.9020002@cox.net>

Doug Lea wrote:

> The package documentation for atomics has the main rationale
> for not relating AtomicInteger etc to Number:
> 
>      ... And atomic classes are not general purpose replacements for
>      java.lang.Integer and related classes. They do NOT define methods
>      such as hashCode and compareTo. (Because atomic variables are
>      expected to be mutated, they are poor choices for hash table
>      keys.) Additionally, classes are provided only for those types
>      that are commonly useful as atomics. For example, there is no
>      atomic class for representing byte. In those infrequent cases
>      where you would like to do so, you can use an AtomicInteger to
>      hold byte values, and cast appropriately. Similarly, you can hold
>      floating point types using Float.floatToIntBits and
>      Float.intBitstoFloat conversions.

I have heard a lot of explanations about why you all didn't expect that 
these types would be construed as 'Number' values.  But I guess I still 
do not see why that can not be Number implementations.  Your planned use 
of these values is fine with me.  But, I really think there is a large 
value in the presence of these classes and I really think they should be 
Number values.  I also think that there should be an AtomicDouble as 
well.  I understand that these are new/different uses than what was planned.

What I want to encourage is that these other uses are just as valid and 
I think that if this gap isn't closed, that we'll end up with a new set 
of such classes somewhere else that will more completely fill this void 
and then we'll have the disparity that I'd like to avoid.

Gregg


From dawidk@mathcs.emory.edu  Wed Jan  7 05:00:57 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 7 Jan 2004 00:00:57 -0500
Subject: [concurrency-interest] Re: AtomicInteger and  AtomicLong should implement Number
In-Reply-To: <16379.22782.14117.510679@altair.cs.oswego.edu>
Message-ID: <000001c3d4db$3e83d7a0$abfa8caa@mathcs.emory.edu>

> (...)
> Note in particular that AtomicInteger cannot be a Number 
> because it would break the hashcode contract. And it would 
> not have a symmetric equals method.  

I completely agree with EG in this case. The only gain of using AtomicX
classes as Numbers is a syntactic sugar, anyway. Baited by that sugar,
people would start abusing them by using them as mutable primitive
wrappers in non-concurrent settings. This is clearly not the purpose of
those classes (if only because of their package location), and it should
not be encouraged. In concurrent end-user applications, the object model
is usually much coarser than single numeric values; it tends to have
specialized classes (possibly having atomic fields) and those classes
may implement any contract you like; e.g. there may be accessor methods
which return values of atomic fields as Numbers if you like. Given that,
and the fact that the syntactic sugar will actually be provided in 1.5
by autoboxing, the discussion almost comes down to whether .get() should
be explicit in the code or not. In his last posting, Doug Lea provided
quite strong semantical arguments to support the EG position on that,
which in my humble opinion should conclude this thread.

Regards to all,
Dawid Kurzyniec


From larryr@saturn.sdsu.edu  Wed Jan  7 06:46:50 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 7 Jan 2004 06:46:50 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <16379.22782.14117.510679@altair.cs.oswego.edu>
Message-ID: <20040107064650.9037.qmail@home19.riedel.org>

> AtomicInteger cannot be a Number because it would break the
> hashcode contract.

Is there something besides the contract which says that
two object values which would be equals() must have the
same hashCode()?  It seems like that could be satisfied
by returning "get()".


> And it would not have a symmetric equals method.  

Less symmetric than for Long and Integer, which are both Numbers
and for which neither equals() or compareTo() claim to work
when one Number is an Integer and the other is a Long?  I would
expect that at any given instant, for AtomicInteger objects
a and b, a.equals(b) would be equal to b.equals(a), using a
straightforward implementation of equals().  No?


> Things might have been different had there been pre-existing
> classes MutableInteger, MutableLong, etc, but there aren't.

In JDK 1.4, CharBuffer has a method asReadOnlyBuffer() which
returns another CharBuffer object, or maybe the same one, if
it was already ReadOnly.  In general a CharBuffer object may
or may not be mutable.  CharBuffer has hashCode(), equals(),
and compareTo(), and those things return meaningful values
in just those contexts where they should be expected to, and
they are documented as such. There is no "MutableCharBuffer",
"WritableCharBuffer", no "ReadOnlyCharBuffer"... there is
CharBuffer.  Maybe the CharBuffer is mutable, and maybe it
is not.  The JDK trusts me to make it work.  I like that.

I guess the value returned by get() of an AtomicInteger object
may not be the same the next time I call it, so if it has an
"intValue()" method from Number which just returns "get()",
I may end up with a Number reference which does not always
give the same value from intValue().  I think I can be
trusted to deal with that and make it work.

I got the impression that with JDK 1.5 there was going to be a
continued recognition that getting hamstrung by the compiler or
runtime system is not something which makes programmers more
productive, and it is nice to avoid an API design approach "you
should not want to do that, or at least you probably should not,
most of the time, and if you did it would probably be because
you are confused or ignorant, therefore you may not do it,
even though you asked to be able to do it and it would not
be particularly cumbersome or difficult to allow it".


> ... AtomicLong is not related to Long.

I guess maybe it would be like "it looks like a duck, and
quacks like a duck, but it was born with no legs, so it doesnt
walk like a duck, and so should not be treated as equivalent to,
or even similar to, a duck, even though the behavior of a duck
with no legs would be indistinguishable in practice".  It looks
to me like an AtomicLong object which was never modified after
a certain time T, and had a "longValue()" from Number which it
implemented using "get()", it would look, from the point of
view of a user of a Number, amazingly similar to a Long.  No?


No matter what happens, I feel confident saying whatever comes
out of JSR-166 will be better than anything I would have
come up with... but that does not mean it could not be better.


Larry


From miles@milessabin.com  Wed Jan  7 08:31:23 2004
From: miles@milessabin.com (Miles Sabin)
Date: Wed, 7 Jan 2004 08:31:23 +0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <16379.22782.14117.510679@altair.cs.oswego.edu>
References: <0C3EFB691636964BBF914AE56AE83A89501EC0@hplex4.hpl.hp.com> <16379.22782.14117.510679@altair.cs.oswego.edu>
Message-ID: <200401070831.24161.miles@milessabin.com>

Doug Lea wrote,
> Note in particular that AtomicInteger cannot be a Number because it
> would break the hashcode contract. And it would not have a symmetric
> equals method.
>
> (Also note that AtomicReference is not a java.lang.ref.Reference.)

It might be helpful to note that AtomicReference<T> doesn't extend T. T 
isn't a supertype of AtomicReference<T> because Ts are values and 
AtomicReference<T>s are references to values, and values and references 
to values have fundamentally different characteristics. And since 
AtomicReference<T> doesn't extend T there's no reason to expect it to 
extend any supertype of T other than Object either.

The analogy then is that AtomicInteger is roughly logically equivalent 
to AtomicReference<Integer> hence it's not an Integer, in which case 
there's no reason to suppose it's a Number either.

Maybe it'd reduce confusion (at the cost of keystrokes) to rename 
AtomicInteger et al to AtomicIntegerReference?

Cheers,


Miles



From David.Biesack@sas.com  Wed Jan  7 18:05:27 2004
From: David.Biesack@sas.com (David J. Biesack)
Date: Wed, 7 Jan 2004 13:05:27 -0500 (EST)
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number (Miles Sabin)
In-Reply-To: <20040107170000.6782.14618.Mailman@altair.cs.oswego.edu>
 (concurrency-interest-request@cs.oswego.edu)
References: <20040107170000.6782.14618.Mailman@altair.cs.oswego.edu>
Message-ID: <200401071805.i07I5RP08224@mozart.unx.sas.com>

> From: Miles Sabin <miles@milessabin.com>
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
> Date: Wed, 7 Jan 2004 08:31:23 +0000
> 
> It might be helpful to note that AtomicReference<T> doesn't extend T. T 
> isn't a supertype of AtomicReference<T> because Ts are values and 
> AtomicReference<T>s are references to values, and values and references 
> to values have fundamentally different characteristics. And since 
> AtomicReference<T> doesn't extend T there's no reason to expect it to 
> extend any supertype of T other than Object either.

> The analogy then is that AtomicInteger is roughly logically equivalent 
> to AtomicReference<Integer> hence it's not an Integer, in which case 
> there's no reason to suppose it's a Number either.

Actually, AtomicInteger is more analogous to AtomicReference<int>
not AtomicReference<Integer>. But int is not a reference type.

As per the package doc

  "Atomics are not used very often in application-level classes. They
  are designed primarily as building blocks for implementing
  non-blocking data structures and related infrastructure classes."

Thus, these classes are not used in contexts where Number and its
subclasses are useful; i.e. not as wrappers for primitives to store
in collections, etc.

That's why there is no AtomicFloat/AtomicDouble. To further the
distinction, the value method is 'int get()', not 'int intValue()', and
AtomicInteger does not implement Comparable. This all feels right to me.

One option (which I offer but do not support) is to rename this as
AtomicInt (*not* AtomicIntegerReference!) to emphasize the int value.
The "problem" still exists for AtomicLong/AtomicBoolean. The other
reason I don't support this option is that I think the name
'AtomicInteger' reflects the fact that it holds an "integer" value,
thereby hiding to the implementation detail that it uses an int. (Too
bad the javadoc is more explicit: "... maintains an <tt>int</tt> value...")
Maybe AtomicLong should really be AtomicLongInteger :-)

I agree it is sufficient to let the Javadoc clarify the intent and use.
It may be worth adding a brief paragraph to the package doc.

> Miles

-- 
David J. Biesack     SAS Institute Inc.
R&D Java Strategist  SAS Campus Drive Cary, NC 27513
(919) 531-7771       http://www.sas.com


From larryr@saturn.sdsu.edu  Wed Jan  7 18:13:58 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 7 Jan 2004 18:13:58 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <200401070831.24161.miles@milessabin.com>
Message-ID: <20040107181358.11641.qmail@home19.riedel.org>

> > (Also note that AtomicReference is not a java.lang.ref.Reference.)
> 
> It might be helpful to note that AtomicReference<T> doesn't extend T. T 
> isn't a supertype of AtomicReference<T> because Ts are values and 
> AtomicReference<T>s are references to values, and values and references 
> to values have fundamentally different characteristics. And since 
> AtomicReference<T> doesn't extend T there's no reason to expect it to 
> extend any supertype of T other than Object either.
> 
> The analogy then is that AtomicInteger is roughly logically equivalent 
> to AtomicReference<Integer> hence it's not an Integer, in which case 
> there's no reason to suppose it's a Number either.

My understanding is that Integer and AtomicInteger are both thought to
contain a primitive (JLS 4.2) value, not a reference (JLS 4.3) value,
and AtomicReference contains a reference value, not a primitive value.
If indeed an AtomicInteger contained a reference to an object, and the
get() method returned that object reference, and there were no methods
(addAndGet(), getAndIncrement() et al) short-circuiting to numeric
primitive values (JLS 4.2.1 and 4.2.3), then I think it would make sense
to say that AtomicInteger is equivalent to an AtomicReference<T> where
T is Integer.  But AtomicInteger, AtomicLong, etc, DO contain methods
peculiar to numeric primitives, so clearly those classes are NOT simply
an AtomicReference for a reference value which happens to be to an
Integer object, Long object, etc.

IF AtomicInteger only had the methods of AtomicReference, with the
type "V" replace by "Integer", then I think there would be much less
confusion than with the proposed hybridized classes which sort of look
like like AtomicReference, and sort of look like an object-oriented
version of a numeric type for a language which does not have operator
overloading.  Conversely, if an attempt was made to meaningfully add
methods addAndGet(), getAndIncrement() et al from AtomicInteger to
AtomicReference, with "int" replaced by "V", then I think it might
become more clear that there is something fundamentally different
about an AtomicInteger from an AtomicReference, and that difference
is what may make some people be inclined to say it looks to them like
AtomicInteger has had features added to it which make it perform like
an object-oriented version of a numeric value, which up until now was a
role assigned to the "Number" class, and that might lead to a feeling
that "AtomicInteger and AtomicLong should implement Number".


Larry


From kchhabria@apogent.com  Wed Jan  7 21:43:39 2004
From: kchhabria@apogent.com (Chhabria, Kavita - Apogent)
Date: Wed, 7 Jan 2004 16:43:39 -0500
Subject: [concurrency-interest] How to handle multiple different requests and still have a thread
 dedicated to monitoring timeouts in the background.
Message-ID: <BC657EA146456941BBF2BD5819DD602208CA91@usmi0022k36.is.apogent.com>

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C3D567.501AD770
Content-Type: text/plain

Greetings Everyone:
 
I have a need to design a class that receives different kinds of jabber
messages.  Based on the content of the jabber messages, different
actions/tasks have to be executed.  I have to create a new user request
object for every new request that is valid that is sent via a jabber
message.  These requests are valid only for a certain period of time.  So,
for every new request that was created, i have to have a thread that willl
continuously loop through all the user request instances and check if they
have timed out.  If a user request has timed out, it needs to be removed
from the database.  
 
How should I design my classes such that I have these different runnable
commands that are executed upon receiving different jabber messages, and
then simultaneously one thread needs to constantly monitor the timeout
values for the user request objects that were created.  Should I create this
thread as a daemon thread or are there any other options within the
concurrent.util package that I am unaware of.
 
Thanks a lot,
 
Kavita Chhabria
Systems Developer
Apogent Technologies
(269) 544-7515
 <mailto:kchhabria@apogent.com> kchhabria@apogent.com
 

------_=_NextPart_001_01C3D567.501AD770
Content-Type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii">
<TITLE>Message</TITLE>

<META content="MSHTML 6.00.2800.1276" name=GENERATOR></HEAD>
<BODY>
<DIV><FONT face=Arial size=2><SPAN class=456153521-07012004>Greetings 
Everyone:</SPAN></FONT></DIV>
<DIV><FONT face=Arial size=2><SPAN 
class=456153521-07012004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=Arial size=2><SPAN class=456153521-07012004>I have a need to 
design a class that receives different kinds of jabber messages.&nbsp; Based on 
the content of the jabber messages, different actions/tasks have to be 
executed.&nbsp; I have to create a new user request object for every new request 
that is valid that is sent via a jabber message.&nbsp; These requests are valid 
only for a certain period of time.&nbsp; So, for every new request that was 
created, i have to have a thread that willl continuously loop through all the 
user request instances and check if they have timed out.&nbsp; If a user request 
has timed out, it needs to be removed from the database.&nbsp; 
</SPAN></FONT></DIV>
<DIV><FONT face=Arial size=2><SPAN 
class=456153521-07012004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=Arial size=2><SPAN class=456153521-07012004>How should I design 
my classes such that I have these different runnable commands that are executed 
upon receiving different jabber messages, and then simultaneously one thread 
needs to constantly monitor the timeout values for the user request objects that 
were created.&nbsp; Should I create this thread as a daemon thread or are there 
any other options within the concurrent.util package that I am unaware 
of.</SPAN></FONT></DIV>
<DIV><FONT face=Arial size=2><SPAN 
class=456153521-07012004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=Arial size=2><SPAN class=456153521-07012004>Thanks a 
lot,</SPAN></FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV align=left><FONT face=Arial size=2>Kavita Chhabria</FONT></DIV>
<DIV align=left><FONT face=Arial size=2>Systems Developer</FONT></DIV>
<DIV align=left><FONT face=Arial size=2>Apogent Technologies</FONT></DIV>
<DIV align=left><FONT face=Arial size=2>(269) 544-7515</FONT></DIV>
<DIV align=left><A href="mailto:kchhabria@apogent.com"><FONT face=Arial 
size=2>kchhabria@apogent.com</FONT></A></DIV>
<DIV>&nbsp;</DIV></BODY></HTML>

------_=_NextPart_001_01C3D567.501AD770--

From olivier.dupuy@hrdc-drhc.gc.ca  Wed Jan  7 23:18:41 2004
From: olivier.dupuy@hrdc-drhc.gc.ca (olivier.dupuy@hrdc-drhc.gc.ca)
Date: Wed, 7 Jan 2004 18:18:41 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
Message-ID: <0691D2A40A12164D88BC675BC8C4815C165ECD@NCEV02.hrdc-drhc.net>


	Hi,


>> I also believe that it would be wise to provide a 'double'
>> value version of
>> these classes and make them even more generic in expected use.
>> Gregg

> As far as I am aware you cannot provide AtomicFloat/Double without
> using locks. So while we could define such classes it would be
> misleading, and not commensurate with the goals of JSR-166. I can see,
> from your perspective, how having such a class would make the type
> hierarchy more complete - but we're not trying to define a numeric
> type hierarchy here.
> David

>      where you would like to do so, you can use an AtomicInteger to
>      hold byte values, and cast appropriately. Similarly, you can hold
>      floating point types using Float.floatToIntBits and
>      Float.intBitstoFloat conversions.
Doug

I agree with Gregg, this AtomicDouble should exist, even if this implies to use a lock as mentionned later by David. This way the 'family' will be complete. Even if the AtomicXXX were intended for a different use, this will avoid developers the creation of AtomicFloat/Double classes which could be broken. It's conceivable that someone will have to upgrade the AtomicInteger/Long to some floating type. We also do not want to play with Integer/Float bit conversion. If the class is using a lock and has other differences related to performance and others, mention it in the javadoc.


For the Number aspect, it is just too bad that Number is not an interface instead of a class. My opinion is that it's safer to not extend Number and to create your own wrapper around AtomicXXX if you really need to have a Number compatible class with an atomic access. 


For hashCode() and compareTo(), we don't define them and it's perfectly in line with the contract as defined in Object.
<<However>>, I would expect toString() of the AtomicXXX classes to return a String in the same format as the XXX.toString() for its current content. Currently it must be some kind of garbage with the address.
Your opinion ?


Olivier DUPUY 


From olivier.dupuy@hrdc-drhc.gc.ca  Wed Jan  7 23:23:16 2004
From: olivier.dupuy@hrdc-drhc.gc.ca (olivier.dupuy@hrdc-drhc.gc.ca)
Date: Wed, 7 Jan 2004 18:23:16 -0500
Subject: [concurrency-interest] Constructors of AtomicXXX and AtomicXXXArray
Message-ID: <0691D2A40A12164D88BC675BC8C4815C165ED1@NCEV02.hrdc-drhc.net>

Hi


I have found no reference to these topics in the archive of the mailing list

The AtomicXXXArray classes do not have a constructor taking an array
of XXX (Integer/int or equivalent). I agree that this array could be modified
while the constructor is populating it's 'internal' array by copying/cloning.
Is it why this constructor does not exist even if I see a use for it to avoid
a big loop duplicated in different places ? Moreover, the external loop does
not prevent a modification of the array content during the 'copy' if another
thread has access to it. So why not to add it ?

Your opinion about the usefulness of this ?



AtomicXXX constructors accept only a single primitive argument at this time.
If you look at Number(s) (even if I am not interested in extending Number)
you will see constructors taking a String and parsing it.
This constructor is not difficult to write just calling the XXX constructor
and another AtomicXXX constructor taking a String and a radix could also be useful.
The initial value of the AtomicXXX could come from a Properties/ResourceBundle
and could be in decimal, hexa...

I am not knowledgeable about auto(un)boxing (the link below seems old)
but I see nothing about automated String parsing (String -> some primitive type)
http://www.jcp.org/aboutJava/communityprocess/jsr/tiger/autoboxing.html

Your opinion about the usefulness of this ?


Olivier DUPUY



From dholmes@dltech.com.au  Thu Jan  8 00:07:56 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 8 Jan 2004 10:07:56 +1000
Subject: [concurrency-interest] Constructors of AtomicXXX and AtomicXXXArray
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C165ED1@NCEV02.hrdc-drhc.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCMEPCDLAA.dholmes@dltech.com.au>

Olivier,

> The AtomicXXXArray classes do not have a constructor taking an array
> of XXX (Integer/int or equivalent).

I have not encountered a context where there is a need to initialize
an atomic "array" from an existing array. That's not to say it doesn't
exist, but there are no use cases that highlighted the need for it. Do
you have an actual use case for this?

> AtomicXXX constructors accept only a single primitive
> argument at this time.
> If you look at Number(s) (even if I am not interested in
> extending Number)
> you will see constructors taking a String and parsing it.

 new AtomicInteger(Integer.parseInt(theString, theRadix))

There's no need to burden a class with conversion facilities when the
conversions already exist (and in a fuller form) elsewhere.

> I am not knowledgeable about auto(un)boxing (the link below
> seems old)
> but I see nothing about automated String parsing (String ->
> some primitive type)
> http://www.jcp.org/aboutJava/communityprocess/jsr/tiger/auto
> boxing.html
>
> Your opinion about the usefulness of this ?

String parsing typically has application specific error-handling
associated with it, so you're much better off doing the conversion
yourself. Just my opinion.

David Holmes


From olivier.dupuy@hrdc-drhc.gc.ca  Thu Jan  8 00:37:28 2004
From: olivier.dupuy@hrdc-drhc.gc.ca (olivier.dupuy@hrdc-drhc.gc.ca)
Date: Wed, 7 Jan 2004 19:37:28 -0500
Subject: [concurrency-interest] Constructors of AtomicXXX and AtomicXXXArray
Message-ID: <0691D2A40A12164D88BC675BC8C4815C165ED3@NCEV02.hrdc-drhc.net>


>> The AtomicXXXArray classes do not have a constructor taking an array
>> of XXX (Integer/int or equivalent).
>
>I have not encountered a context where there is a need to initialize
>an atomic "array" from an existing array. That's not to say it doesn't
>exist, but there are no use cases that highlighted the need for it. Do
>you have an actual use case for this?

David, 

No I don't have a use case at this time but why would you like to create an
AtomicIntegerArray if you don't populate it after with ints, shortly or not.
This is my point. Who would populate this array ? Multiple threads would mean
that they would have to know where they are storing their
value. It makes certainly more sense to initialize this from the start.

A possible example of an Atomic array could be some kind of 
exchange array between 2 systems, like the MIB used in SNMP. 
The client and the server can both modify and read the value and 
these operations are atomic.
Not sure that it's the best example but the array in this case
would be populated by the 'server' at initialization time.


For the constructors with the String, I confess that it's just a convenience
method to keep the code more compact but this can be managed with the
existing classes.

Olivier Dupuy



From dholmes@dltech.com.au  Thu Jan  8 01:11:22 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 8 Jan 2004 11:11:22 +1000
Subject: [concurrency-interest] Constructors of AtomicXXX and AtomicXXXArray
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C165ED3@NCEV02.hrdc-drhc.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCAEPFDLAA.dholmes@dltech.com.au>

Olivier Dupuy wrote:
> No I don't have a use case at this time but why would you
> like to create an AtomicIntegerArray if you don't populate it after
with
> ints, shortly or not.

Because the initial value of zero is all I need :) Consider using an
AtomicIntegerArray for per-thread counters. Each worker thread
increments an AtomicInteger based on that thread's index on each task
it completes. A management thread goes through and checks the counts,
perhaps changing some internal settings based on what it finds. Zero
is the only initialization I need in that case.

> This is my point. Who would populate this array ?

The thread that creates it can populate it using a loop before
publishing the reference.

We're trying to avoid unnecessary/inessential changes to the API's at
this late stage of the game - hence the request for a use case - but
I've been informed that "we" should have thought of this anyway and
that it may be more efficient to internalize the array initialization.
Hence your suggestion seems to have been accepted.

Thanks.

David Holmes



From dl@cs.oswego.edu  Thu Jan  8 01:18:45 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 7 Jan 2004 20:18:45 -0500
Subject: [concurrency-interest] Constructors of AtomicXXX and AtomicXXXArray
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C165ED3@NCEV02.hrdc-drhc.net>
References: <0691D2A40A12164D88BC675BC8C4815C165ED3@NCEV02.hrdc-drhc.net>
Message-ID: <16380.45045.809192.406318@altair.cs.oswego.edu>


The unsurprising main moral of the week is that once people have a
chance to use early access releases, they suddenly have more comments
and suggestions. 

As David just mentioned, it is a hard time for us to deal with this
because we are supposed to be all done.  But this one is both a good
idea and a small enough change that we ought to somehow be able to get
it into Tiger:

> The AtomicXXXArray classes do not have a constructor taking an array
> of XXX (Integer/int or equivalent). 

Yeah, they ought to. I don't know what I was thinking not to include
one. Not only is it handy, but initialization (as opposed to any other
bulk array operation that might apply here) can be done more
efficiently internally that you could yourself by looping over
elements.

If you look at the current API snapshot, you'll see these new
constructors.  And if you grab the updated jsr166.jar file, you can
start using them with the early-access release
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

Thanks!

-Doug


From levmatta@uol.com.br  Thu Jan  8 01:25:30 2004
From: levmatta@uol.com.br (=?iso-8859-1?Q?Lu=EDs_Matta?=)
Date: Wed, 7 Jan 2004 23:25:30 -0200
Subject: [concurrency-interest] Custom Lock
References: <20040107170000.6782.14618.Mailman@altair.cs.oswego.edu>
Message-ID: <000501c3d586$4e6bd6d0$0200a8c0@lepc>

Hello all,
    I felt pressured, so I'm releasing a prototype of a Lock that does
priority invertion.
Please consider, only, the algoritm and what I had to do to get to it.
One can find about priority invertion in Silberschatz (problably Tanenbaum)
or any book about
realtime (including Real Time Java spec). It's fundemental, specially if you
have threads with differente
priorities competing for the same resource (than it's a must have).


        private final AtomicInteger priority = new
AtomicInteger(Thread.MIN_PRIORITY);

        private AtomicReference<Thread> owner = new
AtomicReference<Thread>();

        public int acquireExclusiveState(boolean isQueued, int acquires) {
            Thread curr = Thread.currentThread();
            assert acquires == 1; // Does not use multiple acquires
            int result = state().compareAndSet(0, 1)? 0 : -1;
            if (result>-1){//thread safe (reentrant) code inside here (if
threads were corrected)
                priority.set(curr.getPriority());//there is not a big care
about this value
                owner.set(curr);//you may notice that I never reset owner to
null
            }else{
                synchronized(this){
                    int pri = curr.getPriority();
                    int delta = pri - priority.get();
                    if (delta>0){
                        curr.setPriority(pri+delta);
                    }
                }
            }
            return result;
        }

        public boolean releaseExclusiveState(int releases) {
            boolean result = state().compareAndSet(1,0);
            if (result){//thread safe (reentrant) code inside here (if
threads were corrected)

owner.get().setPriority(priority.getAndSet(Thread.MIN_PRIORITY));
                //if this value is inapropriate then it will be corrected by
other locks
                //if it isn't corrected then it should be greater than the
original
                //(I'm not making a big fuss because for a proper
implementation I need better API support)
            }
            return result;
        }

Why my needs are not meat: (although I'm not going to use the code above)
    - There are pleanty compareAndSets or incAnd.. or decAnd, but no
ifgreaterSet, ifsmallerSet and so on
       (I have no ideia if theres is atomic opcodes for these operations)
    - AbstractQueuedSynchronizer doesn't hold its owner (and I did a terible
job trying)
    - Thread has no atomic operation with its Priority, maybe someone has te
influence to add this (preferably using my first proposal)
    - no control over the Queu, please insert a non final class for the Queu
node, so people can add behavior to it
       (and a field to hold the queu node class so you can use it, in your
final methods)

Thanks every one.
Luis

PSA: I would like to see a owned Lock example using
AbstractQueuedSynchronizer, anyone??



From dl@cs.oswego.edu  Thu Jan  8 01:44:00 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 7 Jan 2004 20:44:00 -0500
Subject: [concurrency-interest] Custom Lock
In-Reply-To: <000501c3d586$4e6bd6d0$0200a8c0@lepc>
References: <20040107170000.6782.14618.Mailman@altair.cs.oswego.edu>
 <000501c3d586$4e6bd6d0$0200a8c0@lepc>
Message-ID: <16380.46560.984147.623133@altair.cs.oswego.edu>


Building a priority-inversion lock using AbstractQueuedSynchronizer
looks possible but not easy. AQS builds-in the use of a FIFO queue,
not a priority queue. If you have a small number of priorities (which
you do if you are using 1-10 java.lang.Thread priorities), one way to
go about it would be to use an array of instances of an AQS
specialized to deal with each level.  Then you would need to build
something on top of this that manages the priority inversion, and
releases from the right queue upon lock release.

I'm not sure this design is worth pursuing though.  Beware that
priority settings are only rough scheduling hints in Java. On many
systems, setting priorities has practically no impact on scheduling, so
there is little sense in building a complicated lock mechanism here.

BTW, after testing it out with various example usages, we recently
changed some method names in AbstractQueuedSynchronizer and added a
few others to make it a bit more straightforward to use.

-Doug

From dholmes@dltech.com.au  Thu Jan  8 02:09:16 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Thu, 8 Jan 2004 12:09:16 +1000
Subject: [concurrency-interest] Custom Lock
In-Reply-To: <000501c3d586$4e6bd6d0$0200a8c0@lepc>
Message-ID: <NFBBKALFDCPFIDBNKAPCOEPHDLAA.dholmes@dltech.com.au>

Luis,

>     I felt pressured, so I'm releasing a prototype of a
> Lock that does priority invertion.

You mean a lock that tries to reduce, or bound priority inversion - in
this case by trying to use form of priority inheritance. The classic
algorithms for Priority Inversion Avoidance are Priority Inheritance
Protocol (PIP) and Priority Ceiling Protocol (PCP), though in practice
system tends to use PIP and a simpler form of PCP known as Priority
Ceiling Emulation Protocol.

> Please consider, only, the algoritm and what I had to do to
> get to it.

The simple algorithm for PIP assumes an environment where priorities
can not be changed by the application. It also assumes that only one
lock at a time may be held. In general Java and in the Real-Time
Specification for Java (RTSJ) neither of these assumptions hold and an
implementation of PIP is much more complex that what you outline. You
need a concept of base and active priority and you need full control
over all priority changes so that you can propagate inherited
priorities when needed, and restore priorities correctly when
releasing a lock.

Priority ceiling emulation is a bit simpler as transitivity has to be
factored in when you work out what the ceiling priorities are for each
lock, but you still need full control over priority changes.

> Why my needs are not meat: (although I'm not going to use
> the code above)
>     - There are pleanty compareAndSets or incAnd.. or decAnd, but no
> ifgreaterSet, ifsmallerSet and so on

Typically you read the current value atomically, perform the some
application logic based on the current value and finally set a new
value if the original hasn't changed ie.

  int curr = val.get();
  if (curr < threshHold)
     if (val.compareset(curr, f(curr))) ...
     else ...
  else
     if (val.compareandset(curr, y(curr))) ...
     else ...

>     - AbstractQueuedSynchronizer doesn't hold its owner
> (and I did a terible job trying)

See ReentrantLock for an owned lock using AQS.

>     - Thread has no atomic operation with its Priority,

No it doesn't. setPriority is not even atomic with respect to
getPriority. You would need to control the thread types used and
redefine special purpose methods to manipulate priority the way you
want - but yu can't override the existing final methods. But even then
the VM can ignore your careful priority manipulations.

>     - no control over the Queu, please insert a non final
> class for the Queu node, so people can add behavior to it

As Doug mentioned AQS provides FIFO queuing. Trying to abstract out
the queueing from AQS is not practical because of its specialized
nature, hence you'd either have to use multiple AQS's as Doug
suggested or use the existing AQS as a model for building a
priority-queue version

Priority inversion avoidance in a JVM is not possible without some VM
support and characteristics. In particular without strict priority
preemptive scheduling, priority inversion avoidance techniques are a
waste of time.

For the record I have implemented PIP for an RTSJ implementation based
on user-level threads.

David Holmes


From dl@cs.oswego.edu  Thu Jan  8 02:09:59 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 7 Jan 2004 21:09:59 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C165ECD@NCEV02.hrdc-drhc.net>
References: <0691D2A40A12164D88BC675BC8C4815C165ECD@NCEV02.hrdc-drhc.net>
Message-ID: <16380.48119.566502.546117@altair.cs.oswego.edu>

> I agree with Gregg, this AtomicDouble should exist

No way!

I did add to package spec:
  ... and doubles using <tt>Double.doubleToLongBits</tt> and
  <tt>Double.longBitsToDouble</tt> conversions.

This way, you don't need locks, just conversions. So, if someone would
like to make a set of classes that internally use the basic
cababilities of AtomicX to, say, make a full set of Number subclasses,
we give them all of the mechanism to efficiently do so. But we
still don't think it is good idea to do it otherwise.

Given that we are not going to change the names, superclasses, etc of
the AtomicX classes, can anyone suggest some additional wording we can
put in the package documentation to make sure people are not confused
about them?  (It is OK if they are not happy, we just don't want them
confused :-)



-Doug

From bjornoh@mi.uib.no  Thu Jan  8 08:58:20 2004
From: bjornoh@mi.uib.no (=?ISO-8859-1?Q?Bj=F8rn-Ove_Heimsund?=)
Date: Thu, 8 Jan 2004 09:58:20 +0100 (CET)
Subject: [concurrency-interest] The default thread factory
Message-ID: <Pine.LNX.4.53.0401080932420.8264@matteus.mi.uib.no>

Hi,

The default thread factory returned by Executors creates user (not deamon)
threads. As such, an ExecutorService which uses this default factory must
have its shutdown method called so that the program may terminate.

I am wondering about the rationale for this decision. Why not use deamon
threads by default? (I know that I can provide my own thread factory)

-- 
Bjrn-Ove Heimsund
Centre for Integrated Petroleum Research
University of Bergen, Norway

Bjorn-Ove.Heimsund@uib.no
(+47) 555 84962


From brian@quiotix.com  Thu Jan  8 11:55:44 2004
From: brian@quiotix.com (Brian Goetz)
Date: Thu, 8 Jan 2004 03:55:44 -0800
Subject: [concurrency-interest] The default thread factory
In-Reply-To: <Pine.LNX.4.53.0401080932420.8264@matteus.mi.uib.no>
References: <Pine.LNX.4.53.0401080932420.8264@matteus.mi.uib.no>
Message-ID: <20040108115544.GC32127@lx.quiotix.com>

> The default thread factory returned by Executors creates user (not deamon)
> threads. As such, an ExecutorService which uses this default factory must
> have its shutdown method called so that the program may terminate.
> 
> I am wondering about the rationale for this decision. Why not use deamon
> threads by default? (I know that I can provide my own thread factory)

This was an issue of some debate in the Expert Group.  Here is one
of the arguments against making the default daemon=true.  Consider
this case: 

main() { 
  Executor e = Executors.newFixedThreadPool(N_THREADS);
  e.execute(aTask);
  e.execute(anotherTask);
  ...
  e.execute(oneMoreTask);
  e.shutdown();
}

With a thread factory which creates threads as daemon threads, if
there were no other threads besides the main thread, the program might
exit before all tasks had executed, in a confusing and race-prone
manner.  






From hans_boehm@hp.com  Thu Jan  8 22:50:36 2004
From: hans_boehm@hp.com (Boehm, Hans)
Date: Thu, 8 Jan 2004 14:50:36 -0800
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong shoul
 d implement Number
Message-ID: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com>

[I think my last attempt to post this is still awaiting moderation
due to a slightly different sender address.
This was in reply to Doug's message about the hashcode contract.]

I think we're still interpreting Number in different ways.  I see
nothing in the spec that requires equals() on subclasses of Number
to reflect numeric equality.  I agree that for AtomicInteger that
wouldn't be desirable.

I reread the number spec and it still seems to imply nothing but
convertibility to numeric types, in spite of its name.  If there is
agreement that it was intended to imply more than that, it would
be good to know what it is, and I wish it were stated somewhere.

If someone can point to a stated property that is violated by having
AtomicInteger inherit from Number, implement the Number methods, but
leave the default implementations of equals() and hashCode() in place, I'd
be happy to change my mind.

It seems to me that both interpretations of the Number class (is an
immutable number vs. can be converted to numeric types) make sense and
are useful.  (Perhaps both should be interfaces, but I don't see
why that's relevant to this discussion.)

Hans

From dl@cs.oswego.edu  Fri Jan  9 00:25:27 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 8 Jan 2004 19:25:27 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com>
References: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com>
Message-ID: <16381.62711.33389.14435@altair.cs.oswego.edu>

> I think my last attempt to post this is still awaiting moderation
> due to a slightly different sender address.

(Worse, I think it got flushed by mistake when discarding some of the
spam that comes into this list. Sorry!)

You are right about Number: Unlike all of its subclasses, it doesn't
make any requirements about hashcodes, mutability, equals, etc.  So
AtomicInteger and AtomicLong COULD subclass from Number.  And we in
the EG are still discussing this, although still leaning against
it. But the reasons at this point boil down to taste. We need a
knockdown argument one way or the other about this to make a confident
decision. Anyone got one?

Some excerpts of discussions:


> I don't think a lot of thought went into Number, so we're basically 
> looking for meaning in chicken entrails.  It is currently the case that 
> all J2SE subclasses of Number are immutable, but Number has a (public) 
> default parameterless constructor (almost certainly accidental, and 
> undocumented to boot), so you can make your own mutable subclass if you 
> like.  

> I don't think we'd be sacrificing any great invariant by having 
> AtomicInteger extend Number, but just because you can do a thing doesn't 
> mean you should.  I think the question is, does having AtomicInteger 
> (and pals) extend Number foster a programming style that we like, or one 
> that we dislike?  Does it have any compelling performance advantages?  I 
> think the answers are "one that we dislike" and "no."  

>  Encouraging use of AtomicInteger as a mutable replacement for
> Integer is not a good thing in my view. Further the only way to use
> numbers in a "generic" fashion is to promote everything to double and
> that's not something I'd want to encourage. When/if-ever there is a
> more complete numeric type hierarchy in Java we can slot in the atomic
> classes (though that would also suggest we provide atomic float/double
> classes).

> Either the Number class spec should say that it is the base class
> for immutable numerical values, or we should subclass from it.

> Regardless of whether the Number class javadoc comment can be changed,
> it's a bad idea for any class to extend an abstract class that takes the
> trouble to list its concrete subclasses in its class javadoc comment,
> especially if the extension is fundamentally different from the listed
> concrete subclasses.

> Byte, Double, Float, Integer, Long, and Short don't bother to document
> their immutability at all, so the absence of such documentation on
> Number doesn't imply mutability. (BigDecimal and BigInteger correctly
> say "immutable" right up front, thanks to Josh.)


From larryr@saturn.sdsu.edu  Fri Jan  9 01:07:10 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 9 Jan 2004 01:07:10 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <16380.48119.566502.546117@altair.cs.oswego.edu>
Message-ID: <20040109010710.18135.qmail@home19.riedel.org>

> Given that we are not going to change the names, superclasses,
> etc of the AtomicX classes, can anyone suggest some additional
> wording we can put in the package documentation to make sure
> people are not confused about them?

I think it would help me to have something to the effect of:

    The role of an AtomicInteger object is to provide separation
    of concerns between representation of a numeric value and
    concurrent access to that value.  In performing this role,
    an AtomicInteger object is analogous to an int /variable/,
    not an int /value/, and consequently an AtomicInteger object
    is not itself directly convertible or comparable to an int
    value, an Integer, a Number, or any kind of value.  However
    the value of the variable represented by the AtomicInteger
    object is always immediately available via the get() method.


If I may presume to express an opinion based on "taste", if it was
up to me to simply decide yes/no without any further comment about
whether or not AtomicInteger will extend Number (or Integer for that
matter), I would say unequivocally _no_ it will not.  However my
reasoning would have nothing to do with whether or not AtomicInteger
objects and numeric values should be homologous, because I very much
think they should be; I just think "Number" is a turd and I would
not want to smell its stink on AtomicInteger.


Larry


From dl@cs.oswego.edu  Fri Jan  9 01:53:12 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 8 Jan 2004 20:53:12 -0500
Subject: [concurrency-interest] ITL and revised ThreadContext
In-Reply-To: <000001c3d404$f762c970$16fb8caa@mathcs.emory.edu>
References: <000001c3d404$f762c970$16fb8caa@mathcs.emory.edu>
Message-ID: <16382.2440.859012.869219@altair.cs.oswego.edu>

Dawid,

As always, I'm truly sympathetic about the problems you and others
face trying to develop efficient secure middleware. But, as always,
there are a lot of forces opposing simple solutions.

Your revised proposal does look like it meets some of the objections
in previous exchanges. I think the main remaining one is defining
exactly what is in ThreadContext. To do this right, class Thread would
either need to be a subclass of ThreadContext, or have a guaranteed
ThreadContext constituent. Otherwise, there would be two unrelated
classes that would need to be kept in sync, which is asking for
trouble. (And at this point is not something we can sneak into JSR166.)

While I'm at it.... It occurred to me after our last set of
discussions on related issues that, while it would be out of scope for
JSR166, a reasonable path to solution might be to introduce a new
variant AccessController.doPrivileged method, say

  doPrivileged(PrivilegedAction action, Thread context)

With the requirement(?) that the context thread is no longer alive.

This would act like the current doPrivileged, except that it uses not
only the supplied ACC (of the thread), but also ITLs, priorities,
etc. Doing it this way would reduce pressure to define a explicit
ThreadContext class. A non-running thread used only for its context
would not need to occupy noticeably more resources than would a
ThreadContext object.  This would also evade the issue of exactly what
should be in a ThreadContext class.  This seems promising to me, in
part because it places the security issues in AccessController, where
they belong. Unfortunately for the short term. we in JSR166 can't do
anything along these lines.

-Doug

From blanshlu@netscape.net  Fri Jan  9 03:39:42 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Thu, 08 Jan 2004 21:39:42 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <16381.62711.33389.14435@altair.cs.oswego.edu>
References: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com> <16381.62711.33389.14435@altair.cs.oswego.edu>
Message-ID: <3FFE227E.1090109@netscape.net>

dl@cs.oswego.edu wrote:

>... But the reasons at this point boil down to taste. We need a
>knockdown argument one way or the other about this to make a confident
>decision. Anyone got one?
>  
>
Not I.  But I would point out that this entire thread is predicated on 
taste: the idea that AtomicInteger must be a kind of Integer because of 
its name.  I doubt that making it a Number would alleviate that 
particular confusion.

I don't think you will find a "knockdown argument" for this issue.  You 
could plausibly go either way with this.  However, I suspect that you 
have more support on this list than you have seen expressed for your 
collective inclination to not conflate AtomicInteger and AtomicLong with 
Number.  Just because it's possible doesn't mean it's a good API.

With autoboxing, converting an AtomicInteger to an Integer is trivial.  
And if someone really wanted a Number that was mutable, well, there's 
apparently nothing stopping him from making one.  Doesn't sound like a 
great idea to me.  But if you made AtomicInteger into a Number, you'd be 
putting your imprimatur on exactly that idea.

Luke Blanshard


From gregg.wonderly@pobox.com  Fri Jan  9 04:57:12 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Thu, 08 Jan 2004 22:57:12 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <16381.62711.33389.14435@altair.cs.oswego.edu>
References: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com> <16381.62711.33389.14435@altair.cs.oswego.edu>
Message-ID: <3FFE34A8.9020703@cox.net>


Doug Lea wrote:
> We need a
> knockdown argument one way or the other about this to make a confident
> decision. Anyone got one?

I'll comment on some of the EG discussion, but I don't think I have any 
new/different to really add.  I think this would be a good thing to do. 
  I don't know that it is the 'right' thing to do, because I can't see 
into the future.  But, my gut feeling is that there are enough things 
about this change, for my use of these classes, that it would be valuable.

>>I don't think a lot of thought went into Number, so we're basically 
>>looking for meaning in chicken entrails.  It is currently the case that 
>>all J2SE subclasses of Number are immutable, but Number has a (public) 
>>default parameterless constructor (almost certainly accidental, and 
>>undocumented to boot), so you can make your own mutable subclass if you 
>>like.  

Since Number was in from the beginning, and Java was a pot of stew over 
an open flame between the 0.9 and the 1.0 release, I wouldn't expect 
Number to be much more than a guess at what would be needed.

>>I don't think we'd be sacrificing any great invariant by having 
>>AtomicInteger extend Number, but just because you can do a thing doesn't 
>>mean you should.  I think the question is, does having AtomicInteger 
>>(and pals) extend Number foster a programming style that we like, or one 
>>that we dislike?  Does it have any compelling performance advantages?  I 
>>think the answers are "one that we dislike" and "no."  

Being the usage police is an interesting job.  Sun has tried with the 
release of many technologies, based on java, to direct new markets. 
They wanted Java to be used in applets in 1.0.  But, AWT sucked and 
caused java programs to crash or lock up the computer.  All the non-GUI 
code was fairly usable, so suddenly, Java went server side where it has 
been predominent since.  But, slowly, it is floating into the desktop 
again.  There are similar stories for Jini in devices, etc.  I don't 
think you can, or should try to be looking at what you can keep from 
happening.  I, personally find it more exciting to see what I can enable.

>> Encouraging use of AtomicInteger as a mutable replacement for
>>Integer is not a good thing in my view. Further the only way to use
>>numbers in a "generic" fashion is to promote everything to double and
>>that's not something I'd want to encourage. When/if-ever there is a
>>more complete numeric type hierarchy in Java we can slot in the atomic
>>classes (though that would also suggest we provide atomic float/double
>>classes).

In the world of computer science, there have been predominately 2 
classes of 'real' numbers.  Integer and Floating Point.  There are lots 
of sizes and repesentations for each.  In the Java language, what the 
Number classes present to the world is what will be there for a long 
time to come.  Why?  Because thats what non-numerical analysis 
programmers are going to use for simple numeric values.  They don't know 
better or different.

Of course, I am still guessing, but this is what I see happening.  This 
part of the language is just too imbedded in the implementation details 
to really be reworked anytime soon.  And, I don't think that having 
these classes extend Number complicates, inhibits or otherwise makes 
them any uglier than they already are.  I think it helps them have a 
more Java feel and less of a limited utility class feel.

>>Regardless of whether the Number class javadoc comment can be changed,
>>it's a bad idea for any class to extend an abstract class that takes the
>>trouble to list its concrete subclasses in its class javadoc comment,
>>especially if the extension is fundamentally different from the listed
>>concrete subclasses.

This is a documentation issue, not a technical reason to not subclass it 
seems to me.

>>Byte, Double, Float, Integer, Long, and Short don't bother to document
>>their immutability at all, so the absence of such documentation on
>>Number doesn't imply mutability. (BigDecimal and BigInteger correctly
>>say "immutable" right up front, thanks to Josh.)

Whether or not a numeric value is immutable, it can still be used in 
expressions and in diagnostic messages, as an argument to a method etc.

A big thrust of jdk1.5 is programmer friendliness.  Things are supposed 
to be easier to do.  Having to spray

	new Integer( atomicIntForSomeUse.get() )

all over the place, doesn't make the job any easier.

Syntactic sugar is not what this is.  This is programming hassle.  I 
could, in fact create a whole new package of classes that provide the 
atomic operations and which inherit from Number.  The question is should 
everyone that needs this, have to do it.  Should I have to create a 
java.net project so that I can share this code and champion its use, 
then start a JSR that will be added to a JDK in another 2-3 years etc. 
I don't think that all of that hassel is any better than the arguments 
put forward.

On a related note, the more I look at these classes the more I think it 
is a mistake not to qualify the get() method as getInt() and getLong() 
so that the reader knows the size of what they are retrieving.  If they 
are changed to extend Number, I would suggest that get() be renamed to 
intValue() and longValue() respectfully.

There are clearly a lot of emotions mixed up in all the discussion here. 
Hopefully, the right decision can be made.  And, I am not suggesting 
that I know what's right.  I'm saying that whichever way is decided, we 
all get to live with for the next several years.  Hopefully that will be 
the right decision!

Gregg


From joshua.bloch@sun.com  Fri Jan  9 05:29:50 2004
From: joshua.bloch@sun.com (Joshua Bloch)
Date: Fri, 09 Jan 2004 00:29:50 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <3FFE34A8.9020703@cox.net>
References: <0C3EFB691636964BBF914AE56AE83A89501EC4@hplex4.hpl.hp.com> <16381.62711.33389.14435@altair.cs.oswego.edu> <3FFE34A8.9020703@cox.net>
Message-ID: <3FFE3C4E.5070100@sun.com>

Gregg,

>
> A big thrust of jdk1.5 is programmer friendliness.  Things are 
> supposed to be easier to do.  Having to spray
>
>     new Integer( atomicIntForSomeUse.get() )
>
> all over the place, doesn't make the job any easier.

You don't have to.  Autoboxing does most of the work for you.  (You do 
need to say "get()," but not "new Integer()".)

     Regards,

     Josh



From larryr@saturn.sdsu.edu  Fri Jan  9 07:15:13 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 9 Jan 2004 07:15:13 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <3FFE227E.1090109@netscape.net>
Message-ID: <20040109071513.19329.qmail@home19.riedel.org>

> I would point out that this entire thread is predicated on 
> taste: the idea that AtomicInteger must be a kind of Integer
> because of its name.

???

My impression is there is a feeling that if the raison d'etre of an
object in a system is to be the custodian of a single numeric value,
it would be nice if it provided access to the value in a way which is
consistent with other objects in the system which perform that role.

For developing software which would read the value in a context
where the modification semantics for the value are irrelevant, I
would not care what is the name of the class which was used to
instantiate the object (eg AtomicInteger) if I could reference
it through a variable whose type is an ancestor of it, a type
whose purpose is to directly represent numeric values.

In the case of AtomicInteger, it appears there will be no such
ancestor type.  My impression is that this thread is about the
desirability of accessing the numeric value through a variable
of a single type which is universally used to represent numeric
values directly (if there was such a type).


Larry


From dawidk@mathcs.emory.edu  Fri Jan  9 08:11:52 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri, 9 Jan 2004 03:11:52 -0500
Subject: [concurrency-interest] ITL and revised ThreadContext
In-Reply-To: <16382.2440.859012.869219@altair.cs.oswego.edu>
Message-ID: <000401c3d688$3fc446f0$18fa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Doug Lea
> Sent: Thursday, January 08, 2004 8:53 PM
> To: Dawid Kurzyniec
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] ITL and revised ThreadContext
> 
> 
> 
> Dawid,
> 
> As always, I'm truly sympathetic about the problems you and 
> others face trying to develop efficient secure middleware. 
> But, as always, there are a lot of forces opposing simple solutions.
> 
> Your revised proposal does look like it meets some of the 
> objections in previous exchanges. I think the main remaining 
> one is defining exactly what is in ThreadContext. To do this 
> right, class Thread would either need to be a subclass of 
> ThreadContext, or have a guaranteed ThreadContext 
> constituent. Otherwise, there would be two unrelated classes 
> that would need to be kept in sync, which is asking for 
> trouble. (And at this point is not something we can sneak 
> into JSR166.)

(Quick note: inheritance does not seem right since the relation is not
that thread "is" the context but more that context is an immutable
"snapshot" of a thread inheritable state. My original proposal, whether
it makes sense or not, was to make Context an inner class of Thread, and
to define "getCurrentContext()" and "perform()" as static methods of
Thread).

I understand and appreciate the reasons why you don't want to push it
into JSR166 at this late stage. Pity I haven't got into the trouble a
year earlier - then maybe I have succeeded by now in lobbying you into
the idea :)

Nevertheless, your response suggests that the main objections against
this proposal are not that the approach is incorrect or bad, but that
there is simply not enough time to complete (and gain some confidence
about) the design for inclusion in incoming 1.5 release. Assuming that
the work on java.util.concurrent will continue, however, I am asking you
to not forget about us, poor middleware people, and come back to the ITL
issue eventually. (Hopefully this mailing list will continue to work as
a j.u.c. users forum).

In the meantime, I think I have found a workaround which should work for
me at the moment (with JDK 1.4, or even earlier). It seems to be
possible to define a ThreadContext utility class as I am describing
completely in a user space, and to furnish a subclass of
InheritableThreadLocal in a way that such ThreadContext propagates those
locals. This does not help with legacy code which uses
j.l.InheritableThreadLocals, but nevertheless it enables new code to be
written to work with thread pools and propagating the locals as long as
they are created as instances of the new subclass. I will probably
submit the (surprisingly compact) implementation, to get some feedback
and maybe for the benefit of other people who also miss that feature,
once I become convinced that it works as expected.

> While I'm at it.... It occurred to me after our last set of 
> discussions on related issues that, while it would be out of 
> scope for JSR166, a reasonable path to solution might be to 
> introduce a new variant AccessController.doPrivileged method, say
> 
>   doPrivileged(PrivilegedAction action, Thread context)
> 
> With the requirement(?) that the context thread is no longer alive.
> 
> This would act like the current doPrivileged, except that it 
> uses not only the supplied ACC (of the thread), but also 
> ITLs, priorities, etc. Doing it this way would reduce 
> pressure to define a explicit ThreadContext class. A 
> non-running thread used only for its context would not need 
> to occupy noticeably more resources than would a 
> ThreadContext object.  This would also evade the issue of 
> exactly what should be in a ThreadContext class.  This seems 
> promising to me, in part because it places the security 
> issues in AccessController, where they belong. Unfortunately 
> for the short term. we in JSR166 can't do anything along these lines.

Well, unfortunately this would still be pretty useless in the
applications of the sort I am developing, since they need to propagate
properties of alive threads. If you relaxed it to allow threads which
are not _yet_ alive, it would work: I could create a new child thread,
do not start it, and use it as a thread context, thus propagating
inheritable locals of the original, still alive thread. But then it
would be prone to races when the thread is started asynchronously (which
possibly could be prevented by doing extra locking between
AccessController and Thread classes). Either way it would be a rather
nasty hack (I appreciate now how you are sympathetic about the problem
if you're suggesting things like that :) I mean, requirement to give a
dead thread as an argument is rather odd from the API user point of
view. Well, maybe the user-space workaround I am testing now will prove
to be sufficient, given that the use of InheritableThreadLocal subclass
is widely acceptable.

Having the ThreadContext as a kind of generalization of
AccessControlContext is an intruquing idea though. I hope we will come
back to this at appropriate time.

Kind regards to everybody,
Dawid Kurzyniec


From dawidk@mathcs.emory.edu  Fri Jan  9 09:05:29 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri, 9 Jan 2004 04:05:29 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <3FFE227E.1090109@netscape.net>
Message-ID: <000501c3d68f$bc14e820$18fa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Luke Blanshard
> Sent: Thursday, January 08, 2004 10:40 PM
> To: dl@altair.cs.oswego.edu
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 
> 
> dl@cs.oswego.edu wrote:
> 
> >... But the reasons at this point boil down to taste. We need a 
> >knockdown argument one way or the other about this to make a 
> confident 
> >decision. Anyone got one?
> >  
> >
> Not I.  But I would point out that this entire thread is 
> predicated on 
> taste: the idea that AtomicInteger must be a kind of Integer 
> because of 
> its name.  I doubt that making it a Number would alleviate that 
> particular confusion.
> 
> I don't think you will find a "knockdown argument" for this 
> issue.  You 
> could plausibly go either way with this.  However, I suspect that you 
> have more support on this list than you have seen expressed for your 
> collective inclination to not conflate AtomicInteger and 
> AtomicLong with 
> Number.  Just because it's possible doesn't mean it's a good API.

I agree. People tend to keep quiet when they agree with EG and when it
stands its ground :)

Anyway, I must say I am surprised by the heat of the argument over such
a minor detail, which does not even belong to a concurrency API. People
somehow survived 8 years of Java, writing a quality software, without
autoboxing; apparently, it is not so critical part of the Java
technology and it was not the most wanted improvement. Given that the
proposed "AtomicX" modification would have much smaller syntactic impact
than autoboxing, I conclude that the claims that it is so badly needed
by the community are rather exaggerated. Also, as I said before, I would
be careful estimating usefulness of "AtomicX" classes at the layers of
business logic and presentation, which have to do with number
conversion. However, once the classes inherit from Number, we will be
stuck with that forever (it is always easier to add something later than
to remove it).

And when one has a "gut feeling" (but lacks a "knockdown argument") that
something should be done differently in the JSR 166 (as happened to me
many times, and is still happening sometimes), one also has to put on a
weight the "gut feeling" of people who spent last X years of their lives
designing and refining this API and gaining user feedback.

Regards,
Dawid Kurzyniec


From David.Biesack@sas.com  Fri Jan  9 14:17:43 2004
From: David.Biesack@sas.com (David J. Biesack)
Date: Fri, 9 Jan 2004 09:17:43 -0500 (EST)
Subject: [concurrency-interest] AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040109081200.27614.29460.Mailman@altair.cs.oswego.edu>
 (concurrency-interest-request@cs.oswego.edu)
References: <20040109081200.27614.29460.Mailman@altair.cs.oswego.edu>
Message-ID: <200401091417.i09EHhP21546@mozart.unx.sas.com>

On small bit of trivia to add to the discussion: 

org.omg.CORBA.IntHolder and the other mutable numeric holder classes
do not extend Number either. Of course, I'm not claiming they were
designed well (it defines public int value field, after all!).
Note also that the name is IntHolder and not IntegerHolder,
another departure from Integer/AtomiInteger

-- 
David J. Biesack     SAS Institute Inc.
R&D Java Strategist  SAS Campus Drive Cary, NC 27513
(919) 531-7771       http://www.sas.com


From ccox@tripos.com  Fri Jan  9 16:07:34 2004
From: ccox@tripos.com (Curt Cox)
Date: Fri, 9 Jan 2004 10:07:34 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <16381.62711.33389.14435@altair.cs.oswego.edu>
Message-ID: <MDEIJLCNINPJGNEJMGODEECBCHAA.ccox@tripos.com>

"We need a knockdown argument one way or the other about this
to make a confident decision. Anyone got one?"

I'll bite.

Making AtomicInteger extend Number violate wouldn't violate
any method contracts.  It wouldn't introduce any methods that
would be prone to misuse.  In short, extending Number
doesn't make AtomicInteger error-prone.

Failing to make AtomicInteger extend Number seems to be
claiming that AtomicIntegerS can't be treated as numbers.
It complicates code that could otherwise be generically
written to Number.  If AtomicIntegers can't be treated as
numbers, then the documentation of both Number and
AtomicInteger need to explain why that is.

Of course the same arguments can be made for AtomicIntegerS
being Comparable.  Why aren't AtomicIntegerS comparable? 

Thanks,
Curt





From Darron_Shaffer@stercomm.com  Fri Jan  9 16:28:30 2004
From: Darron_Shaffer@stercomm.com (Shaffer, Darron)
Date: Fri, 9 Jan 2004 10:28:30 -0600
Subject: [concurrency-interest] More on: AtomicInteger and AtomicLong should implement Numbe
Message-ID: <D0E281E7D3C7164399488D7AD8BEEFEB01C14FC2@scidalmsg02.csg.stercomm.com>

As I see it,  most of what this JSR deals with is "detail" oriented
programming: get this tricky locking situation right.

This discussion is more about programming in the large: how to deal with
this object when I don't know or care to know precisely what it is.  Try to
think about opening up possibilities.

For example, assume a pretty-print utility that is given an object reference
and uses reflection to produce a human readable output of it and all it's
members, recursively.  Probably for debug purposes.

It could work like this:

	For each field,
	    if it implements PrettyPrintable
	        invoke field.prettyPrint()
                else if it implements Collection
                    get an iterator, and recurse over each member.
                else if it implements Number
                    do some sort of numeric formatting
                else
                    invoke field.toString()

The point being, by not grouping all of the "AtomicNumber" classes under
some interface or baseclass they are harder to seperate out in this type of
model.  Number is the obvious existing candidate.  (OK, Number should
probably be an interface named something like "ConvertableToNumber" -- but
we can't fix everything).

Also consider that there may be some use of generics where a class is
declared:

	class Foo <T extends Number> { ... }

Are you certain there is no useful case where an AtomicLong would be used
here?

I'm not saying that these particular examples are correct, just that SOMEONE
will want to do SOMETHING along these lines.  Should it be possible?



From blanshlu@netscape.net  Fri Jan  9 16:55:35 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Fri, 09 Jan 2004 11:55:35 -0500
Subject: [concurrency-interest] More on: AtomicInteger and AtomicLong should implement Numbe
Message-ID: <1D23E46B.616240B0.00948489@netscape.net>

"Shaffer, Darron" <Darron_Shaffer@stercomm.com> wrote:
>...I'm not saying that these particular examples are correct, just that SOMEONE
>will want to do SOMETHING along these lines.  Should it be possible?

I don't see why it should be.  I believe that these atomic classes should not be used interchangeably with the built-in primitive wrappers.  Why?  Because their purpose is to facilitate concurrent programming, and if they're used interchangeably with the built-in primitive wrappers, then they are being used for a different purpose.

Will this decision make someone's life harder?  Conceivably.  But not probably.  The atomic classes should always be used privately, as part of some other object's private state, and not exposed to the outside world where they might be provided to something like a formatter.  Making them Numbers would suggest to programmers that they could reasonably expose them to the outside world, which would be wrong.

Luke Blanshard

__________________________________________________________________
New! Unlimited Netscape Internet Service.
Only $9.95 a month -- Sign up today at http://isp.netscape.com/register
Act now to get a personalized email address!

Netscape. Just the Net You Need.

From dawidk@mathcs.emory.edu  Fri Jan  9 17:33:16 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri, 9 Jan 2004 12:33:16 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <MDEIJLCNINPJGNEJMGODEECBCHAA.ccox@tripos.com>
Message-ID: <000001c3d6d6$ac66ceb0$f2fc8caa@mathcs.emory.edu>

> Of course the same arguments can be made for AtomicIntegerS 
> being Comparable.  Why aren't AtomicIntegerS comparable? 

Because you cannot rely on the result of the comparison anyway, since
the values may be immediately changed by other threads after you compare
but before you use the comparison result. To avoid this, you would have
to use locking, and those classes exist precisely to avoid locking.

In particular, comparable suggests that you can sort objects of this
type, and the sort operation assumes that these objects are constant (at
least for some time), which is clearly the opposite of why those classes
are to be used. Again, you would have to lock to make sure that the
values do not change at least _during_ sorting. 

> In short, extending Number doesn't make AtomicInteger error-prone.

Sorting or comparing mutable values is extremely error prone.


Also, to argue on the "philosophical" level why numbers in Java are
immutable: 2 is a number, and 3 is a number, but something which can be
sometimes 2 and sometimes 3 is not a number, it is a variable (or number
holder which you can query for its momentary value). Java builds upon
that definition: everything that extends the Number is immutable. This,
for instance, allows to sort arrays of numbers regardless of the actual
type. Proposed change would violate this.

Regards,
Dawid


From Costin.Cozianu@tabs.toshiba.com  Fri Jan  9 18:35:28 2004
From: Costin.Cozianu@tabs.toshiba.com (Costin.Cozianu@tabs.toshiba.com)
Date: Fri, 9 Jan 2004 10:35:28 -0800
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
Message-ID: <OF23A4F8E6.D76190EE-ON88256E16.00648EF0@TABSMFP.NET>

You cannot sort, and neither can you take the hashcode based on content,
nor you can use the content for Maps (you can use the object identity for
that, but that's not Number).

Traditionally Number classes have been always considered wrapper of
primitive values, and although not documented black on white in the
contract, the habits of Java programmers are also important, as per the
principle of least surprise. We wouldn't want some new linux distribution
to put configuration files in /tmp.

And I don't know why this discussion is important, because I haven't seen
in ages (or maybe I haven't seen at all), an interface using Number for
parameters. And if I see one, when I pass a Number in there, I might be
suspicious that it may legitimately be used for hashing or comparison, or
all other long term, so I'd avoid as a matter of principle to pass in a
mutable value, even a mutable value that is typically modified from other
threads, therefore even if the module that I'm using is not using it beyond
the scope of the current call, it should be safe.

That there might be some usages where passing an AtomicXXX, rather than
AtomicXXX.xxxValue() may be provably safe, I have no doubt, but I really
wonder whether it really makes such a big performance difference. As Java
has always erred on the side of caution, as opposed to performance, I'd
rather not want that some programmer be so concerned with performance that
he will want to pass an AtomicXXX directly where a Number is expected.

Just my 2c,

Best,
Costin Cozianu



                                                                                                                       
                      "Dawid Kurzyniec"                                                                                
                      <dawidk@mathcs.emory.edu>             To:      <concurrency-interest@altair.cs.oswego.edu>       
                      Sent by:                              cc:                                                        
                      concurrency-interest-admin@cs         Subject: RE: [concurrency-interest] Re: AtomicInteger and  
                      .oswego.edu                           AtomicLong should implement Number                         
                                                                                                                       
                                                                                                                       
                      01/09/2004 09:33 AM                                                                              
                                                                                                                       
                                                                                                                       





> Of course the same arguments can be made for AtomicIntegerS
> being Comparable.  Why aren't AtomicIntegerS comparable?

Because you cannot rely on the result of the comparison anyway, since
the values may be immediately changed by other threads after you compare
but before you use the comparison result. To avoid this, you would have
to use locking, and those classes exist precisely to avoid locking.

In particular, comparable suggests that you can sort objects of this
type, and the sort operation assumes that these objects are constant (at
least for some time), which is clearly the opposite of why those classes
are to be used. Again, you would have to lock to make sure that the
values do not change at least _during_ sorting.

> In short, extending Number doesn't make AtomicInteger error-prone.

Sorting or comparing mutable values is extremely error prone.


Also, to argue on the "philosophical" level why numbers in Java are
immutable: 2 is a number, and 3 is a number, but something which can be
sometimes 2 and sometimes 3 is not a number, it is a variable (or number
holder which you can query for its momentary value). Java builds upon
that definition: everything that extends the Number is immutable. This,
for instance, allows to sort arrays of numbers regardless of the actual
type. Proposed change would violate this.

Regards,
Dawid

_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest






From larryr@saturn.sdsu.edu  Fri Jan  9 18:45:34 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 9 Jan 2004 18:45:34 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <000001c3d6d6$ac66ceb0$f2fc8caa@mathcs.emory.edu>
Message-ID: <20040109184534.21670.qmail@home19.riedel.org>

> Sorting or comparing mutable values is extremely error prone.

It had not occurred to me that only immutable objects should be
created by classes which implement Comparable.  This sounds like
something that should definitely be in the API documentation for
Comparable; and I think it makes sense to also have ByteBuffer
(etc) updated to throw an exception if compareTo() is invoked
for a ByteBuffer which is not ReadOnly.


> > Of course the same arguments can be made for AtomicIntegerS 
> > being Comparable.  Why aren't AtomicIntegerS comparable? 
> 
> Because you cannot rely on the result of the comparison
> anyway, since the values may be immediately changed by other
> threads after you compare but before you use the comparison
> result. To avoid this, you would have to use locking, and
> those classes exist precisely to avoid locking.

It is not my impression it is generally accepted that unless
there is a problem, the relative ordering of any two objects
now and later must be the same.  Currently Java in particular
seems to acknowledge that during the normal course of events,
the relative ordering of two objects may change.

I would expect developers to use their objects in a sane way,
and I think the language/API should primarily try to facilitate
that, not try to preclude them from doing things which might
be a mistake in some contexts.


Larry


From larryr@saturn.sdsu.edu  Fri Jan  9 19:09:56 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 9 Jan 2004 19:09:56 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <200401091417.i09EHhP21546@mozart.unx.sas.com>
Message-ID: <20040109190956.21831.qmail@home19.riedel.org>

> org.omg.CORBA.IntHolder and the other mutable numeric holder
> classes do not extend Number either.

My understanding was/is that the *Holder classes are to provide
an adaptor for the impedance mismatch between parameter passing
in CORBA vs Java, specifically that Java does not provide any
sort of call-by-reference/call-by-return/out/inout facility
for its own method invocations, but CORBA does; but anyway my
impression is the *Holder classes were not really meant for
developers to use in their code to build applications, are they?


Larry


From dawidk@mathcs.emory.edu  Fri Jan  9 19:25:34 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Fri, 9 Jan 2004 14:25:34 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040109184534.21670.qmail@home19.riedel.org>
References: <20040109184534.21670.qmail@home19.riedel.org>
Message-ID: <200401091425.34163.dawidk@mathcs.emory.edu>

On Friday 09 January 2004 01:45 pm, Larry Riedel wrote:
> I would expect developers to use their objects in a sane way,
> and I think the language/API should primarily try to facilitate
> that, not try to preclude them from doing things which might
> be a mistake in some contexts.

Well, the point here is that those things would be a mistake in _all_ the 
contexts for which AtomicX classes are designed, as they exist to support 
unsynchronized concurrent modifications.

The comparable etc. exist for classes which are either immutable (from the 
comparison point of view) or at least with the mutability under control of 
the application (via either confinement or synchronization), so that the 
comparison results may be relied upon for some definite period of time. 
AtomicX have the exactly opposite intent: to facilitate concurrent 
modifications assuming lack of confinement or synchronization.

Please refer to "Concurrent Programming in Java" (ISBN 0-201-31009-0) for 
details.

Regards,
Dawid Kurzyniec


From dl@cs.oswego.edu  Fri Jan  9 20:07:06 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Fri, 9 Jan 2004 15:07:06 -0500
Subject: [concurrency-interest] More on: AtomicInteger and AtomicLong should implement Numbe
In-Reply-To: <D0E281E7D3C7164399488D7AD8BEEFEB01C14FC2@scidalmsg02.csg.stercomm.com>
References: <D0E281E7D3C7164399488D7AD8BEEFEB01C14FC2@scidalmsg02.csg.stercomm.com>
Message-ID: <16383.2538.557934.69034@altair.cs.oswego.edu>

Thanks for all the comments. We've so far established (among other
things) that:

  1. AtomicInteger etc should each have a toString method that returns
     stringified current value. (As implied by Darron Shaffer.) And
     they now do have them.  We can act quickly when something is
     obviously right.

  2. AtomicInteger etc should NOT implement Comparable
     (Thanks to Dawid Kurzyniec.)

  3. If there exists code that tests for "instanceof Number" to make
     assumptions about immutability, equals, or hashCode , then it
     would be a disservice to subclass Number here. If there is any
     JDK code that does this, it would be a big disservice. (But I don't
     think there is.)

Costin asks:

> And I don't know why this discussion is important,

Well, probably not too important, but we're taking it seriously anyway
because it is probably representative of reactions we might expect
from casual users. The expert users can clearly cope either way.


-Doug

From ccox@tripos.com  Fri Jan  9 20:16:28 2004
From: ccox@tripos.com (Curt Cox)
Date: Fri, 9 Jan 2004 14:16:28 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <000001c3d6d6$ac66ceb0$f2fc8caa@mathcs.emory.edu>
Message-ID: <MDEIJLCNINPJGNEJMGODCECECHAA.ccox@tripos.com>

"Also, to argue on the "philosophical" level why numbers in Java are
immutable: 2 is a number, and 3 is a number, but something which can be
sometimes 2 and sometimes 3 is not a number, it is a variable (or number
holder which you can query for its momentary value). Java builds upon
that definition: everything that extends the Number is immutable. This,
for instance, allows to sort arrays of numbers regardless of the actual
type. Proposed change would violate this."

This argument is compelling.  If it is the rationale for not using
number as a base class, then Number should document that restriction.
If there really is a consensus among Java programmers that Number
implies immutability, then there should be little argument about
adding this advice (there is no possible enforcement) to the Javadoc
for Number.  Of course AtomicX should contain reciprocal documentation
since it won't be readily apparent (consider this discussion as proof)
why an AtomicX isn't a Number.

Likewise for Comparable.  If AtomicX aren't Comparable because they are
mutable, then Comparable should at least mention mutability.  There
should be reciprocal documentation in AtomicX explaining why they are
not Comparable.

Failure to do all of this will result in several bugs being filed on
Bug Parade (no, not by me) about how AtomicX should be Comparable and
Numbers.  This will be compounded by duplicate filings and countless
programmer hours spent searching the bug database prior to filing
bugs.

It would violate the principle:

"It is OK if they are not happy, we just don't want them confused." 




From larryr@saturn.sdsu.edu  Fri Jan  9 21:34:24 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 9 Jan 2004 21:34:24 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <200401091425.34163.dawidk@mathcs.emory.edu>
Message-ID: <20040109213424.22300.qmail@home19.riedel.org>

> AtomicX classes [are designed / exist] to support unsynchronized
> concurrent modifications.

It seems evident to me that the Atomic* classes are a way for
the Java language/API to provide efficient access to whatever
"test-and-set", "compare-and-swap", "read-modify-write",
"fetch-and-store", etc, style operations are provided by the
CPUs of the host; they do not in and of themselves provide any
new basic functionality, just a potentially dramatic performance
optimization for cases where an entity/object is accessed often,
and there may be a thread which tries to change its state to a
different state based on its current state while other threads
are trying to access the object, and the semantics for deciding
to change the object state map sufficiently cleanly to the
underlying test-and-set paradigm.


> The comparable etc. exist for classes which are either immutable
> (from the comparison point of view) or at least with the
> mutability under control of the application (via either
> confinement or synchronization), so that the comparison results
> may be relied upon for some definite period of time.  AtomicX
> have the exactly opposite intent: to facilitate concurrent
> modifications assuming lack of confinement or synchronization.

It looks to me like think AtomicX provide a specific simple case of
confinement/synchronization under the control of the application
which happens to map cleanly to instructions which can be performed
orders of magnitude more quickly by the JVM or CPU than if they were
implemented them using the Java language level equivalents.  I do not
think they change the fundamental nature of the entities for which they
are providing that particular case of confinement/synchronization, or
that those entities which would benefit from the use of that efficient
implementation are necessarily inherently different in practice from
those which would not.

It think it makes sense for there to be a class which can perform
a sequence of operations efficiently, and I think it makes sense to
have an instance of that class which associates itself with a
particular entity on which it will be performing those operations.
I just do not like the idea in the case of AtomicX of imposing any
more semantic/logical/homological assumptions/constraints than are
made by, say, System.arraycopy().  "Mechanism, not policy", I
guess, makes sense to me when it comes to API design.


Larry


From gregg.wonderly@pobox.com  Sat Jan 10 00:52:04 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Fri, 09 Jan 2004 18:52:04 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <000001c3d6d6$ac66ceb0$f2fc8caa@mathcs.emory.edu>
References: <000001c3d6d6$ac66ceb0$f2fc8caa@mathcs.emory.edu>
Message-ID: <3FFF4CB4.8020102@cox.net>


Dawid Kurzyniec wrote:
> Also, to argue on the "philosophical" level why numbers in Java are
> immutable: 2 is a number, and 3 is a number, but something which can be
> sometimes 2 and sometimes 3 is not a number, it is a variable (or number
> holder which you can query for its momentary value). Java builds upon
> that definition: everything that extends the Number is immutable. This,
> for instance, allows to sort arrays of numbers regardless of the actual
> type. Proposed change would violate this.

What your suggesting is that somehow we already know every single use 
case of every single moment that these values will be used, and that 
there will never be a moment that the programmer will know what they are 
doing and can in fact compare, sort, manipulate or examine them.

An example that comes to my mind is instrumentation.  If I am counting 
some things and then wish to 'pause', sort and examine, I should be able 
to do that using a programming model that is recognizable.  If these 
objects are not Number decendents, then suddenly all kinds of friendly 
comparison, trending, graphing etc code has to suddenly be replicated 
just to accomidate these values.

Gregg


From dl@cs.oswego.edu  Sat Jan 10 15:06:17 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 10 Jan 2004 10:06:17 -0500
Subject: [concurrency-interest] More on: AtomicInteger and AtomicLong should implement Numbe
In-Reply-To: <16383.2538.557934.69034@altair.cs.oswego.edu>
References: <D0E281E7D3C7164399488D7AD8BEEFEB01C14FC2@scidalmsg02.csg.stercomm.com>
 <16383.2538.557934.69034@altair.cs.oswego.edu>
Message-ID: <16384.5353.687018.655012@altair.cs.oswego.edu>

I wrote...

>  but we're taking it seriously anyway
> because it is probably representative of reactions we might expect
> from casual users.

which of course was NOT to imply that people posting one opinion or
another about it are merely casual users. (Sorry to anyone who took
this the wrong way!) Just that, as before, new users will have one
expectation or another about it, and will probably be confused, and
we'd like to avoid this.

While I'm at it: Could someone who favors subclassing Number try
writing sample AtomicInteger/AtomicLong javadoc that would deconfuse
those new users who are NOT expecting it.  And keep it really short
and obvious so people might actually notice it?

-Doug


From gregg.wonderly@pobox.com  Sat Jan 10 15:57:46 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Sat, 10 Jan 2004 09:57:46 -0600
Subject: [concurrency-interest] More on: AtomicInteger and AtomicLong
 should implement Numbe
In-Reply-To: <16384.5353.687018.655012@altair.cs.oswego.edu>
References: <D0E281E7D3C7164399488D7AD8BEEFEB01C14FC2@scidalmsg02.csg.stercomm.com>	<16383.2538.557934.69034@altair.cs.oswego.edu> <16384.5353.687018.655012@altair.cs.oswego.edu>
Message-ID: <400020FA.4050209@cox.net>


Doug Lea wrote:
> While I'm at it: Could someone who favors subclassing Number try
> writing sample AtomicInteger/AtomicLong javadoc that would deconfuse
> those new users who are NOT expecting it.  And keep it really short
> and obvious so people might actually notice it?

In an attempt to cover all the issues summarily I would write something 
like:

Concerning Number subclassing: This class subclasses Number to provide 
the convenience of those methods for access to the value within.  This 
class is mutable, unlike the native Java type Number implementations. 
Instances of this class are therefore not intended to be casually passed 
around into contexts where the mutability might be unexpected.

Gregg


From dl@cs.oswego.edu  Sun Jan 11 01:28:16 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 10 Jan 2004 20:28:16 -0500
Subject: [concurrency-interest] AtomicInteger and AtomicLong extend Number
Message-ID: <16384.42672.867196.869952@altair.cs.oswego.edu>

Since the aesthetic and logical arguments continue to be split, I
decided to go the empirical route.  I spent a while googling usages of
Number out there.  This made it a surprisingly easy call (even given
my resistance to it). AtomicInteger and AtomicLong should both extend
Number:

* There are at least dozens of other numerically-based classes out
there that extend Number including mutable classes, and including
carefully constructed, useful-looking classes. So there is clear
precedent.

* There is a lot more code out there than I would have thought that
probes for "instanceof Number" in order to extract numbers from
arbitrary classes. Most of this looks useful enough to not get in the
way of.

* While I saw mistakes here and there in code that probes for
instanceof Number, I didn't seem any that would be any more likely to
trigger for atomics than for most any other Number class.  (The most
common mistake was trying to distinguish floating vs integral Number
types. There doesn't seem to be a correct way to do this given only
what Number provides.  It is possible though to determine whether a
Number holds an integral (<64bit) value, which is probably what people
want to check but don't. Also, there are mistakes due to forgetting
that not all longs will fit exactly into doubles. It would be nice if
the Number class provided some static utility methods to help avoid
people making errors along these lines.)

* The Atomic classes still should not, and will not, implement
Comparable, or define value-based hashCode and equals methods.  The
most prevalant non-JDK Number classes out there seem to be the Mutable
(MuShort, MuInteger etc) classes used by Apache and JBoss. They do
additionally support Comparable and define value-based hashCodes and
equals methods. But all are defined in ways that work as naively
expected in at best a very narrow range of contexts.  As we've noted,
such problems would be compounded for atomics, and usages would almost
never be correct.

-Doug

From Shyam.Ramamurthy@oracle.com  Mon Jan 12 03:27:33 2004
From: Shyam.Ramamurthy@oracle.com (Shyam)
Date: Sun, 11 Jan 2004 20:27:33 -0700
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
References: <20040109213424.22300.qmail@home19.riedel.org>
Message-ID: <40021425.6090607@oracle.com>


Larry Riedel wrote:

>>    
>>
>It looks to me like think AtomicX provide a specific simple case of
>confinement/synchronization under the control of the application
>which happens to map cleanly to instructions which can be performed
>orders of magnitude more quickly by the JVM or CPU than if they were
>implemented them using the Java language level equivalents.  I do not
>think they change the fundamental nature of the entities for which they
>are providing that particular case of confinement/synchronization, or
>that those entities which would benefit from the use of that efficient
>implementation are necessarily inherently different in practice from
>those which would not.
>  
>

A tangential comment on this : Would it make sense to have XYZ.atomicX 
that would return a atomic version of X akin to 
Collections.synchronizedMap?

Thanks,
Shyam

-- 
------------------------------------------------------------------------------
Shyam S Ramamurthy                                     Phone : +91 80 5108 2208
Principal Member (Tech Staff)                                  +91 80 550  9360
Systems Engineering & OAP                                      Ext 2208
Platfroms Technology Group
Oracle India Private Limited
------------------------------------------------------------------------------
Disclaimer: Opinions expressed in this mail are mine, and may not
be those of Oracle Corporation.
------------------------------------------------------------------------------ 




From larryr@saturn.sdsu.edu  Mon Jan 12 07:47:07 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 12 Jan 2004 07:47:07 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <40021425.6090607@oracle.com>
Message-ID: <20040112074707.2564.qmail@home19.riedel.org>

> Would it make sense to have XYZ.atomicX that would return a
> atomic version of X akin to Collections.synchronizedMap?

Something like XYZ.atomicXYZ() which would return a reference
to an object of the same type but with atomic access semantics?

I think it would be great to be able to get nice support for that
kind of approach to atomic access.  I would welcome an approach
which treats atomic access as orthogonal to the type system,
so for example the java.util.concurrent support for atomicity
would be explicitly agnostic to whether developers will properly
utilize compareTo(), equals(), hashCode(), etc, for objects with
some atomic access semantics.

But it looks to me like things are not going that way, for example it
appears AtomicInteger will provide intValue(), but will not provide
the corresponding obvious(*) implementations of compareTo(), equals(),
and hashCode(), because "usages would almost never be correct".  MY
assumption would be that with competent software engineers at the helm,
which I think should be a fundamental assumption behind ALL API design,
usages would be as correct as they are with anything else.

(*) essentially:

        int compareTo(Object that):
            thatValue = (Number)that.intValue();
            thisValue = this.intValue();
            if (thisValue == thatValue)
                return 0;
            else
                return (thisValue < thatValue) ? -1 : 1;

        boolean equals(Object that):
            return (((Number)that).intValue() == this.intValue());

        int hashCode():
            return intValue();

    Given what I would assert to be a widespread understanding that
    classes which implement Comparable and provide their own equals()
    and hashCode() are not necessarily immutable, and consequently the
    above implementations are not deterministic in the general case,
    I think developers would have no problem understanding that will
    continue to be true in the case of classes with some efficiently
    atomic methods, especially since it would presumably be documented
    as such, like the way those methods are documented with ByteBuffer.


Larry


From dl@cs.oswego.edu  Mon Jan 12 11:19:36 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 12 Jan 2004 06:19:36 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040112074707.2564.qmail@home19.riedel.org>
References: <40021425.6090607@oracle.com>
 <20040112074707.2564.qmail@home19.riedel.org>
Message-ID: <16386.33480.292613.285785@altair.cs.oswego.edu>

> But it looks to me like things are not going that way, for example it
> appears AtomicInteger will provide intValue(), but will not provide
> the corresponding obvious(*) implementations of compareTo(), equals(),
> and hashCode(), because "usages would almost never be correct".  MY
> assumption would be that with competent software engineers at the helm,
> which I think should be a fundamental assumption behind ALL API design,
> usages would be as correct as they are with anything else.


The rationale isn't based on competence.  While I can't think offhand
of any application where I'd use AtomicIntegers as keys in a hash
table (HashMap, Hashtable, ConcurrentHashMap), if I did, I would
surely want to be able to find them even if they changed value. Using
the default identity-based hashCode and equals methods provides this;
so normal usages would almost always be correct, while with
value-based versions, they almost never would be. And given this,
because you aren't supposed to define a compareTo that returns 0
(equals) in different cases than when equals returns true, the only
option is not to provide it.

-Doug

From dl@cs.oswego.edu  Mon Jan 12 13:12:23 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 12 Jan 2004 08:12:23 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <40021425.6090607@oracle.com>
References: <20040109213424.22300.qmail@home19.riedel.org>
 <40021425.6090607@oracle.com>
Message-ID: <16386.40247.749221.682067@altair.cs.oswego.edu>

> A tangential comment on this : Would it make sense to have XYZ.atomicX 
> that would return a atomic version of X akin to 
> Collections.synchronizedMap?

We actually do something like this, although not so conveniently, for
more varieties of "X" than you probably had in mind.  Explaining this
requires some backing up...

As it says in the atomics package docs, an atomic is basically just a
volatile variable supporting an extra operation, CAS (compareAndSet),
with two variants plus some derived forms. Further, only variables of
some volatile types and be atomic. You can't CAS a byte, char or short
variable because of type-width issues, and can't reliably CAS a float
or double because of floating point equality issues (e.g.,
NaNs). These restrictions are merely hardware artifacts on modern
processors, but don't have decent workarounds, so we don't try to
cover them up.

In a language that was designed from the ground up to support this,
CAS might be a syntactic form.  Although coming up with good syntax is
itself challenging. The best I recall anyone being able to come up
with is "var ?= expected? newValue", which is not only strange
looking, but doesn't supply the boolean success/failure flag that you
usually need.

Because we couldn't do this syntactically, and because CAS is an
"lvalue" operation, not a function, we instead have to supply a range
of forms that cover all the cases that can arise: The most commonly
used are the stand-alone single-variable classes like AtomicInteger.
Similarly for array elements, with AtomicIntegerArray etc.  But you
can also "latch on" CAS capabilities to any existing volatile field of
any class using the reflection-based AtomicIntegerFieldUpdater etc. It
would have in principle minimally sufficed to support only the updater
versions, but not only are they very awkward to use, they can in some
contexts encounter noticeable reflection-based overhead. 

So, depending on the "X" you have in mind, one of these versions will
apply to give you an atomic form of that X. I don't see a way to make
a uniform API that figures out which of these versions to create though.

As irregular extensions to the otherwise regular structure of single
variables, arrays, and fields of int, long, and reference, we provide
AtomicBoolean, AtomicMarkedReference, and AtomicStampedReference that
deal only with single variables, but cannot be made to apply to arrays
or fields. These are special-cased because on some platforms, some
JVMs may be able to deal with them more efficiently than you could
yourself by building them from the other supplied classes.

Digressing: The implementation side of this is a very similar story.
It might have been nicest to add CAS bytecodes, but instead, in the
reference implmentation (hotspot), we rely on an internal
intrinsics-extension glue API (wrongly/misleadingly called "Unsafe")
that allows trusted code in JDK java.* packages to issue what amounts
to bytecode extensions that understood only by a particular JVM.

Further digressing: The intrinsics API was originally developed mainly
to conjunction with the java.nio package, that presented similar
problems in sometimes needing to deal with direct-mapped IO buffers,
etc in ways that cannot be expressed using bytecodes. Given the
resistance to changing/adding JVM bytecodes, this API probably ought
to be reworked and standardized in some future JCP JSR as an
alternative providing a uniform basis for low-level extensions. But
the cases where this is needed are rare enough that it might not be
worth the effort to standardize.  (Most such cases can be handled
using JNI, which is already standardized, but for atomics, nio
buffers, etc., you need the JVM to "understand" the operation
semantics to implement them efficiently.)

-Doug

From larryr@saturn.sdsu.edu  Mon Jan 12 16:48:01 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 12 Jan 2004 16:48:01 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <16386.33480.292613.285785@altair.cs.oswego.edu>
Message-ID: <20040112164801.4264.qmail@home19.riedel.org>

> [You] aren't supposed to define a compareTo that returns 0
> (equals) in different cases than when equals returns true

I would agree that I would expect them to typically be the same,
and when they are not, I find it reasonable to put what the API
documentation for compareTo() recommends: "Note: this class has
a natural ordering that is inconsistent with equals."  However
in the case of an object where the only issue is that it is not
strictly immutable, I would be inclined to go ahead and just have
((compareTo(x) == 0) <=> equals(x)), and take the risk that if 
there is an object in a hashtable and its value changes, it may
may not be findable using the same key value as before.


> > But it looks to me like things are not going that way, for example
> > it appears AtomicInteger will provide intValue(), but will not
> > provide the corresponding obvious(*) implementations of compareTo(),
> > equals(), and hashCode(), because "usages would almost never be
> > correct".  MY assumption would be that with competent software
> > engineers at the helm, which I think should be a fundamental
> > assumption behind ALL API design, usages would be as correct as they
> > are with anything else.
>
> [If I used] AtomicIntegers as keys in a hash table (HashMap,
> Hashtable, ConcurrentHashMap), I would surely want to be able to find
> them even if they changed value. Using the default identity-based
> hashCode and equals methods provides this; so normal usages would
> almost always be correct, while with value-based versions, they almost
> never would be.

I would say it would, regardless of anything to do with atomic vs not
atomic, be an inauspicious decision to use an object as a key in a
hashtable during a period of time when its value as a key might change
during the normal/expected course of events in the application.  So it
makes sense to me that the hashCode() documentation for ByteBuffer says,
"Because buffer hash codes are content-dependent, it is inadvisable to use
buffers as keys in hash maps or similar data structures unless it is known
that their contents will not change."  I like that it is left up to the
engineer/developer to be responsible for determining when it makes sense
to use an object which is not strictly immutable as a key in a hashtable.

Ruby has "rehash".  I recommend adding that. 8-)
http://www.rubycentral.com/book/ref_c_hash.html#Hash.rehash


Larry


From dawidk@mathcs.emory.edu  Mon Jan 12 21:42:16 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 12 Jan 2004 16:42:16 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040112164801.4264.qmail@home19.riedel.org>
References: <20040112164801.4264.qmail@home19.riedel.org>
Message-ID: <200401121642.16386.dawidk@mathcs.emory.edu>

On Monday 12 January 2004 11:48 am, Larry Riedel wrote:
> I would say it would, regardless of anything to do with atomic vs not
> atomic, be an inauspicious decision to use an object as a key in a
> hashtable during a period of time when its value as a key might change
> during the normal/expected course of events in the application.  

I have said it before: It HAS to do with atomic, since they are provided 
SPECIFICALLY to support unsynchronized concurrent modifications. If you don't 
have multiple threads sharing the mutable variable (that's what confinement 
is about, BTW), you didn't need the atomic class in the first place. If you 
have multiple threads sharing the variable, there is NO period of time when 
the value-based hashcode can be relied upon as constant unless you perform 
locking (synchronization) which again defeats the purpose of using atomic 
class.

On the other hand, I can imagine usage scenarios described by Doug where I'd 
put the atomic variable in the hashtable treating the variable as a shared 
*container*, depending on the default, identity-based implementation of 
equals().

BTW, that's yet another reason why I was opposing to the inheritance of 
atomics from Number: I was afraid that it would open this Pandora's box: "how 
come it is a number and it is not comparable?" etc.

Regards,
D


From larryr@saturn.sdsu.edu  Tue Jan 13 00:46:59 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 13 Jan 2004 00:46:59 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <200401121642.16386.dawidk@mathcs.emory.edu>
Message-ID: <20040113004659.5867.qmail@home19.riedel.org>

> > I would say it would, regardless of anything to do with atomic vs not
> > atomic, be an inauspicious decision to use an object as a key in a
> > hashtable during a period of time when its value as a key might change
> > during the normal/expected course of events in the application.
> 
> I have said it before: It HAS to do with atomic, since they are provided
> SPECIFICALLY to support unsynchronized concurrent modifications.

When I invoke compareAndSet(), I expect it to be functionally
equivalent to if its implementation did indeed do Java language level
synchronization; I would use the java.util.concurrent.Atomic* version
because it is (presumably) implemented to do that orders of magnitude
more quickly than if it used Java language level synchronization
because it is a particular scenario which has [hardware] support.


>                                                                 If you
> don't have multiple threads sharing the mutable variable (that's what
> confinement is about, BTW), you didn't need the atomic class in the
> first place. If you have multiple threads sharing the variable, there
> is NO period of time when the value-based hashcode can be relied upon
> as constant unless you perform locking (synchronization) which again
> defeats the purpose of using atomic class.

I imagine something like the following:  I have an object whose state
is queried often, maybe from one thread, maybe from another, and on
average the state of the object changes relatively seldom and relatively
predictably (deterministically), or maybe it never changes unless
something unusual happens.  When a decision is made to change the state
of the object, that decision and the new state are based in part on
what the existing state is believed to be.  There is no single thread
dedicated to (or with an exclusive mandate for) changing the state.
When the state does change, it must change directly from one correct
state to another.

For this particular application it may be very unlikely or almost
inconceivable that between the time a thread queries the state of the
object and commands the object to change its state, some other thread
commands the object to change state, but it COULD happen, and the
atomicity of that pair (query+command) of operations needs to be ensured
to preserve the invariants.  If for this application the query+command
pair fits the "compareAndSet" paradigm of Atomic*, I would like to use
that, because it seems like a simple/easy way to get good performance.

Besides the frequent querying of the object state, there are various things
the application does which leverages the fact that the state of the object
seldom (if ever) changes, by assuming the state will be constant during a
sequence of operations, or maybe it is virtually guaranteed to take place
between state changes because the completion of the sequence of operations
is one of the logical criteria affecting the decision to change the state of
the object.  Or maybe for some things the application does not mind if the
state changes and, for example, it cannot find an object in a hashtable--
maybe it just reverts to an iterator or some other alternative approach, or
just gives up until next time.

I prefer not to have the language/API preclude me from making my own
decisions about when to use the Atomic* classes and when to use a
hashCode() value which in the general case is not guaranteed to be
constant.  I am not meaning to say there is no clean/simple/efficient
way (or BETTER way) than the above to get the same end result for the
particular application, maybe having a single official state value
snapshot, or a single update thread.  I just think using the Atomic* is
a simple, natural, reasonable way to do it, and I have not seen anything
to make me think it should not be a supported way to do it.


Larry


From dl@cs.oswego.edu  Tue Jan 13 01:19:07 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 12 Jan 2004 20:19:07 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040112164801.4264.qmail@home19.riedel.org>
References: <16386.33480.292613.285785@altair.cs.oswego.edu>
 <20040112164801.4264.qmail@home19.riedel.org>
Message-ID: <16387.18315.803334.826261@altair.cs.oswego.edu>

> and take the risk that if 
> there is an object in a hashtable and its value changes, it may
> may not be findable using the same key value as before.

Under the current scheme, anyone who want to use an AtomicInteger
with value-based semantics as a key in a hash table, only has
to say "get()"

  table.put(myAtomicInteger.get(), something); // value-based

 versus, for identity-based, table.put(myAtomicInteger, something); 

Autoboxing takes care of the rest in the value case. And there's no
risk in not finding it again in case the variable changes value.
Similarly for contexts using Comparable.

What could be nicer? :-)

-Doug



From gregg.wonderly@pobox.com  Tue Jan 13 03:40:39 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 12 Jan 2004 21:40:39 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <200401121642.16386.dawidk@mathcs.emory.edu>
References: <20040112164801.4264.qmail@home19.riedel.org> <200401121642.16386.dawidk@mathcs.emory.edu>
Message-ID: <400368B7.6080504@cox.net>


Dawid Kurzyniec wrote:
> On the other hand, I can imagine usage scenarios described by Doug where I'd 
> put the atomic variable in the hashtable treating the variable as a shared 
> *container*, depending on the default, identity-based implementation of 
> equals().
> 
> BTW, that's yet another reason why I was opposing to the inheritance of 
> atomics from Number: I was afraid that it would open this Pandora's box: "how 
> come it is a number and it is not comparable?" etc.

Here is what I am going to do with Atomics.

I am going to use them to instrument some applications that are very 
thread intensive.  I will have hundreds of these objects active in many 
cases.  Most will be in arrays or vectors for global reachability, but 
will be referenced directly by threads that need them.  Occasionally, I 
will lock things down, do some calculations, sorting and comparing and 
then reconfigure the system to improve performance.

Without compareTo and equals as value based, I will have to write a bit 
more code to dive into the values directly.  The native Number 
implementations follow the value contract that I thinks makes sense.

I have been bit by putting more than one instance of 'new Integer(42)' 
as the key in a hashtable.  It gets even worse when you use the native 
Number values in a swing JTree node.  The nodes values are keys to 
hashtables that find the node components with parallel vectors to 
maintain ordering.  You get the right number of tree 'rows', but only 
one of the rows will have the value drawn correctly because the 
hashtable will always find the last added node with the same key.

There is good reason, both for, and against making these objects 
implement compareTo() and equals() with the value.  Because so many 
people have probably already adopted practices of wrapping Number 
implementations in other objects to create unique values, I think it 
makes sense to roll with the flow and make these classes implement a 
value based compareTo and equals.

If you leave the default in place, there is no ordering defined right? 
So the only thing that is left is a comparison that is identical to == I 
believe.  I.e. will it not be the case that

	AtomicInteger1.equals(AtomicInteger2)
		IFF
	AtomicInteger1 == AtomicInteger2

These things really are numeric values.  I think it would be best to 
complete the contract and make them feel like numeric values.

Gregg


From dawidk@mathcs.emory.edu  Tue Jan 13 04:09:25 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 12 Jan 2004 23:09:25 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040113004659.5867.qmail@home19.riedel.org>
Message-ID: <000101c3d98b$0c52f270$9efa8caa@mathcs.emory.edu>

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Larry Riedel
> Sent: Monday, January 12, 2004 7:47 PM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 
> 
> 
> > > I would say it would, regardless of anything to do with atomic vs 
> > > not atomic, be an inauspicious decision to use an object 
> as a key in 
> > > a hashtable during a period of time when its value as a key might 
> > > change during the normal/expected course of events in the 
> > > application.
> > 
> > I have said it before: It HAS to do with atomic, since they are 
> > provided SPECIFICALLY to support unsynchronized concurrent 
> > modifications.
> 
> When I invoke compareAndSet(), I expect it to be functionally 
> equivalent to if its implementation did indeed do Java 
> language level synchronization; I would use the 
> java.util.concurrent.Atomic* version because it is 
> (presumably) implemented to do that orders of magnitude more 
> quickly than if it used Java language level synchronization 
> because it is a particular scenario which has [hardware] support.

The atomicity provided by Atomic* classes is not sufficient alone to
allow you to rely on equals() or Comparable. When you use comparisons
(e.g. when you sort or when you use maps), you have to ensure that the
value does not change during the whole operation, i.e. the whole thing
from comparing to putting the value into the hash table to using it and
removing it, or the whole "sort" operation, must be performed while the
value does not change. Am I stating the obvious here?...

> I imagine something like the following:  I have an object 
> whose state is queried often, maybe from one thread, maybe 
> from another, and on average the state of the object changes 
> relatively seldom and relatively predictably 
> (deterministically), or maybe it never changes unless 
> something unusual happens.  When a decision is made to change 
> the state of the object, that decision and the new state are 
> based in part on what the existing state is believed to be.  
> There is no single thread dedicated to (or with an exclusive 
> mandate for) changing the state. When the state does change, 
> it must change directly from one correct state to another.
> 
> For this particular application it may be very unlikely or 
> almost inconceivable that between the time a thread queries 
> the state of the object and commands the object to change its 
> state, some other thread commands the object to change state, 
> but it COULD happen, and the atomicity of that pair 
> (query+command) of operations needs to be ensured to preserve 
> the invariants.  If for this application the query+command 
> pair fits the "compareAndSet" paradigm of Atomic*, I would 
> like to use that, because it seems like a simple/easy way to 
> get good performance.

No problem with that. No need for hashCode() or comparable so far, too.

> Besides the frequent querying of the object state, there are 
> various things the application does which leverages the fact 
> that the state of the object seldom (if ever) changes, by 
> assuming the state will be constant during a sequence of 
> operations, or maybe it is virtually guaranteed to take place 
> between state changes because the completion of the sequence 
> of operations is one of the logical criteria affecting the 
> decision to change the state of the object.  

If you know that the value will not change, you could (and should) use
the momentary value obtained by .get() as a hashtable key, as Doug Lea
suggested. 

Also, this actually looks to me more like a scenario for an
identity-based key rather than value-based key, i.e. why would you map
something to the volatile state rather than to the object itself?... But
nevertheless, even if it was indeed something you wanted to do, use
get() in this case.

> Or maybe for 
> some things the application does not mind if the state 
> changes and, for example, it cannot find an object in a 
> hashtable-- maybe it just reverts to an iterator or some 
> other alternative approach, or just gives up until next time.

This is absolutely wrong, erroneous approach. The behavior of Map when
keys change in respect to equals(), hashCode() or compareTo() is
undefined and the application should never allow it to happen. For
HashMap, you will end up with a stale entry which cannot be located
using either the original or the new key, yet somehow it will be
reported by containsValue() -- a clear inconsistency. For TreeMap, the
result is even more severe, since other mappings become affected -- you
will mess up a whole portion of the map just by messing up a single key.

> I prefer not to have the language/API preclude me from making 
> my own decisions about when to use the Atomic* classes and 
> when to use a
> hashCode() value which in the general case is not guaranteed 
> to be constant.  I am not meaning to say there is no 
> clean/simple/efficient way (or BETTER way) than the above to 
> get the same end result for the particular application, maybe 
> having a single official state value snapshot, or a single 
> update thread.  I just think using the Atomic* is a simple, 
> natural, reasonable way to do it, and I have not seen 
> anything to make me think it should not be a supported way to do it.

I claim that there is not a single legitimate use of value-based
comparison methods for AtomicX classes, and this claim so far has not
been proven wrong. Even if there was (but there isn't), it would be much
less common than default, identity-based comparison. Why making things
harder in cases which actually may be useful? And even if there was no
use of identity-based comparison either, the danger of misleading people
into using atomics as keys in maps (and severely hurt themselves as a
result) is enough to me to object supporting it.

Regards,
Dawid


From gregg.wonderly@pobox.com  Tue Jan 13 04:10:06 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 12 Jan 2004 22:10:06 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <16387.18315.803334.826261@altair.cs.oswego.edu>
References: <16386.33480.292613.285785@altair.cs.oswego.edu>	<20040112164801.4264.qmail@home19.riedel.org> <16387.18315.803334.826261@altair.cs.oswego.edu>
Message-ID: <40036F9E.2060705@cox.net>


Doug Lea wrote:

>>and take the risk that if 
>>there is an object in a hashtable and its value changes, it may
>>may not be findable using the same key value as before.
> 
> 
> Under the current scheme, anyone who want to use an AtomicInteger
> with value-based semantics as a key in a hash table, only has
> to say "get()"
> 
>   table.put(myAtomicInteger.get(), something); // value-based

In applications where I am already doing this with other Number 
implementations, the native value is already in the box.  So, what your 
saying is that it makes more since to do

	table.put(NumberRef.intValue(), something)

and let autoboxing create a completely new object that is separate from 
and apart from the value I already have?

I think that is shortsighted.  I really do understand what you're trying 
to prevent from happening.  I just don't think that the safeguards that 
you are trying to put in place have any real value proposition to the 
use of these classes compared to the value that having the value based 
equals and compareTo would.

Gregg


From dawidk@mathcs.emory.edu  Tue Jan 13 04:43:19 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Mon, 12 Jan 2004 23:43:19 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <400368B7.6080504@cox.net>
Message-ID: <000201c3d98f$c5a743d0$9efa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Gregg Wonderly
> Sent: Monday, January 12, 2004 10:41 PM

> Here is what I am going to do with Atomics.
> 
> I am going to use them to instrument some applications that are very 
> thread intensive.  I will have hundreds of these objects 
> active in many 
> cases.  Most will be in arrays or vectors for global 
> reachability, but 
> will be referenced directly by threads that need them.  
> Occasionally, I 
> will lock things down, do some calculations, sorting and 
> comparing and 
> then reconfigure the system to improve performance.
> 
> Without compareTo and equals as value based, I will have to 
> write a bit 
> more code to dive into the values directly.  

Yes, a get() call - that's even more than a bit, it is 5*8 = 40 bits ;)

Not to mention that it actually may _improve_ performance to copy values
into int[] arrays and sort them using Arrays.sort() rather than
performing sort directly on object arrays.

> I have been bit by putting more than one instance of 'new 
> Integer(42)' 
> as the key in a hashtable.  

You would be hit much more badly by mutable keys. Se my response to
Larry's e-mail.

> It gets even worse when you use 
> the native 
> Number values in a swing JTree node.  The nodes values are keys to 
> hashtables that find the node components with parallel vectors to 
> maintain ordering.  You get the right number of tree 'rows', but only 
> one of the rows will have the value drawn correctly because the 
> hashtable will always find the last added node with the same key.

The idea behind Numbers is that 42 _is_ 42. The 42 number is
(conceptually) the same object as any other 42 number. If you put
objects to the JTree node, you want to put _different_ objects there,
don't you? (I understand though that it can be misleading, but that's
apparently the model of JTree, and alternatives would likely be much
worse)

> There is good reason, both for, and against making these objects 
> implement compareTo() and equals() with the value.  Because so many 
> people have probably already adopted practices of wrapping Number 
> implementations in other objects to create unique values, I think it 
> makes sense to roll with the flow and make these classes implement a 
> value based compareTo and equals.

It is a very different situation; Numbers are safe as map keys, atomics
are definitely not. (See my response to Larry's e-mail).

> 
> If you leave the default in place, there is no ordering 
> defined right? 
> So the only thing that is left is a comparison that is 
> identical to == I 
> believe.  I.e. will it not be the case that
> 
> 	AtomicInteger1.equals(AtomicInteger2)
> 		IFF
> 	AtomicInteger1 == AtomicInteger2

Precisely.

> These things really are numeric values.  I think it would be best to 
> complete the contract and make them feel like numeric values.

That's what I meant by a Pandora's box ;)

I personally believe that they're not numeric values, but holders of
numeric values. The relation to Number class, approved by the EG, is
merely a convenience. But again, the decision to be made (or already
made) is based not merely on our taste or beliefs but on careful
evaluation of benefits, drawbacks, possible usage scenarios, and dangers
of possible misuse. Let us keep focused and not reiterate.

Regards,
Dawid


From larryr@saturn.sdsu.edu  Tue Jan 13 07:32:17 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 13 Jan 2004 07:32:17 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <000101c3d98b$0c52f270$9efa8caa@mathcs.emory.edu>
Message-ID: <20040113073217.7064.qmail@home19.riedel.org>

> > Besides the frequent querying of the object state, there are 
> > various things the application does which leverages the fact 
> > that the state of the object seldom (if ever) changes, by 
> > assuming the state will be constant during a sequence of 
> > operations, or maybe it is virtually guaranteed to take place 
> > between state changes because the completion of the sequence 
> > of operations is one of the logical criteria affecting the 
> > decision to change the state of the object.  
> 
> If you know that the value will not change, you could (and should)
> use the momentary value obtained by .get() as a hashtable key

My perspective is that a sine qua non of this thread ("AtomicInteger
and AtomicLong should implement Number") is the idea of assumption of
the type of the guarded/wrapped entity by the class of wrapper object.
I consider a method which returns a snapshot of the state of the
guarded entity to be pretty much orthogonal to that, to some extent
similar to the idea of using clone() instead of intValue().


> I claim that there is not a single legitimate use of value-based
> comparison methods for AtomicX classes, and this claim so far has
> not been proven wrong.

Such an opinion cannot be proved right or wrong.  My opinion is that
in the case of a class whose instances each provide an atomic access
wrapper/guard for an instance of particular type of entity, it is useful
and valuable for that class to assume the type of the entity, so that
the atomicity is adjunctive rather than disjunctive.  I believe my
opinion cannot be proved right or wrong either, although that does not
mean it is not a lame opinion. :)


Larry


From gregg.wonderly@pobox.com  Tue Jan 13 14:24:51 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 13 Jan 2004 08:24:51 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <000201c3d98f$c5a743d0$9efa8caa@mathcs.emory.edu>
References: <000201c3d98f$c5a743d0$9efa8caa@mathcs.emory.edu>
Message-ID: <4003FFB3.2030808@cox.net>


Dawid Kurzyniec wrote:
> Yes, a get() call - that's even more than a bit, it is 5*8 = 40 bits ;)
> 
> Not to mention that it actually may _improve_ performance to copy values
> into int[] arrays and sort them using Arrays.sort() rather than
> performing sort directly on object arrays.

Performance is not the primary issue here.  The primary issue for me is 
that I am going to have to synchronize through memory allocation to 
create all these new objects.  I am also going to expand the JVM's 
memory use to have to representations of the same thing.  There seems 
little advantage to this.

>>I have been bit by putting more than one instance of 'new 
>>Integer(42)' 
>>as the key in a hashtable.  
> 
> You would be hit much more badly by mutable keys. Se my response to
> Larry's e-mail.

But, I would completely understand this issue, and I would get to deal 
with the results.  I don't think that we can protect people from poor 
programming habbits.  I am sure that there have already been people who 
have had the experienec of creating mutal objects that they have used as 
keys in maps and lost the objects.

I do not think that making these classes not have a value based equals 
and compareTo will keep all mutable classes from being misused.  Thus, I 
see little value in this attempt at policing misuse.

> The idea behind Numbers is that 42 _is_ 42. The 42 number is
> (conceptually) the same object as any other 42 number. If you put
> objects to the JTree node, you want to put _different_ objects there,
> don't you? (I understand though that it can be misleading, but that's
> apparently the model of JTree, and alternatives would likely be much
> worse)

The idea behind AtomicX is that it is whatever value it currently holds. 
  Whether I change that value occasionaly, continuously is not defined 
by the class.  Each application will do something different.

In queuing theory, we all know that if you have 100 threads that are all
in the same process loop, all influenced by the same relative latencies, 
that eventually all threads will end up waiting back to back at any 
synchronized section of code if there is any significant difference in 
the relative latency of any particular section.

synchronization puts the breaks on effective load distribution with a 
multithreaded pattern.  Thus, these objects should not implicitly or 
explicitly require the user to inject any synchronization into their 
application.  Memory allocation is one of the predominant 
synchronization latencies in a multi-threaded highly dynamic 
application.  In embedded applications on microcontollers, memory is at 
a premium in general.  Also, the use of the GC is something that is 
generally avoided.  With RT-JAVA, there is opportunity to separate 
threads from the GC.  But, as soon as any thread has to allocate a 
mirror object for one of these objects, on a repeated bases, you've 
impacted the application big time, in this type of environment.

> It is a very different situation; Numbers are safe as map keys, atomics
> are definitely not. (See my response to Larry's e-mail).

That is a single pattern which may or may not be the predominate use of 
these classes.  I think that its shortsighted to keep throwing this 
single issue up as THE ARGUMENT.

> That's what I meant by a Pandora's box ;)

Its only Pandora's box if there is good lively discussion.  I think that 
is what is happening. API development in a vacuum can typically result 
in APIs that belong "in a vacuum".  If everybody gets a chance to voice 
their opinion, then the API gets to be improved where the arguments hold 
value.  This is a good thing!

> I personally believe that they're not numeric values, but holders of
> numeric values. The relation to Number class, approved by the EG, is
> merely a convenience. But again, the decision to be made (or already
> made) is based not merely on our taste or beliefs but on careful
> evaluation of benefits, drawbacks, possible usage scenarios, and dangers
> of possible misuse. Let us keep focused and not reiterate.

Okay, no more arguments about "AtomicX as a hashmap key" :-) Let's try 
and find some other issue besides how mutability inpacts these classes 
as keys to see if there is a strong case for not making equals and 
compareTo be value based.

Gregg


From dawidk@mathcs.emory.edu  Tue Jan 13 16:54:39 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 13 Jan 2004 11:54:39 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040113073217.7064.qmail@home19.riedel.org>
Message-ID: <000201c3d9f5$f060da80$a0fa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Larry Riedel
> Sent: Tuesday, January 13, 2004 2:32 AM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number

> My perspective is that a sine qua non of this thread 
> ("AtomicInteger and AtomicLong should implement Number") is 
> the idea of assumption of the type of the guarded/wrapped 
> entity by the class of wrapper object. 

The type of the guarded object is a mutable primitive value. By your
argument, the type of the wrapper is also, conceptually, a mutable
primitive. But mutable things have no place in hashing and sorting
algorithms. Ergo: atomics should not provide value-based comparison.

> 
> > I claim that there is not a single legitimate use of value-based 
> > comparison methods for AtomicX classes, and this claim so 
> far has not 
> > been proven wrong.
> 
> Such an opinion cannot be proved right or wrong.  

If it was wrong, it would be easy to prove just by showing a
counterexample :)

Regards,
Dawid


From dawidk@mathcs.emory.edu  Tue Jan 13 16:54:39 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 13 Jan 2004 11:54:39 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <4003FFB3.2030808@cox.net>
Message-ID: <000301c3d9f5$f1b287d0$a0fa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Gregg Wonderly
> Sent: Tuesday, January 13, 2004 9:25 AM
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 
> 
> 
> 
> Dawid Kurzyniec wrote:
> > Yes, a get() call - that's even more than a bit, it is 5*8 
> = 40 bits 
> > ;)
> > 
> > Not to mention that it actually may _improve_ performance to copy 
> > values into int[] arrays and sort them using Arrays.sort() 
> rather than 
> > performing sort directly on object arrays.
> 
> Performance is not the primary issue here.  The primary issue 
> for me is 
> that I am going to have to synchronize through memory allocation to 
> create all these new objects.  I am also going to expand the JVM's 
> memory use to have to representations of the same thing.  There seems 
> little advantage to this.

Unless you use some sort of a GUI (and if you did you'd not worry about
memory footprint of number wrappers), you probably don't need to create
wrappers at all, just use primitive values returned by get() -- this
induces no memory allocation whatsoever. You may need to allocate some
primitive arrays if you want to sort, but otherwise you would likely
have to allocate lists of objects for the same purpose. And, because you
have snapshots copied, you can actually release locks much earlier (or
even not lock at all) as you are able to process (sort, display,
analyze) the shapshot values while the program is running.

> I don't think that we can protect people from poor 
> programming habbits.  I am sure that there have already been 
> people who 
> have had the experienec of creating mutal objects that they 
> have used as 
> keys in maps and lost the objects.

People with intentions to do so will be able to abuse (or find a way to
abuse) any single API. But the key assumption about the JSR166 audience
is that most programmers will want to write correct programs. Thus, API
should not endorse techniques which always (or in vast majority of
cases) lead to incorrect programs.

> I do not think that making these classes not have a value 
> based equals 
> and compareTo will keep all mutable classes from being 
> misused.  Thus, I 
> see little value in this attempt at policing misuse.

Other mutable classes and existing misuses are irrelevant to this API.
All that matters is that this API by itself does not endorse incorrect
techniques. Your argument is like "there is so much flaky code out
there; why don't we produce some more then?"

> The idea behind AtomicX is that it is whatever value it 
> currently holds. 

Again, this is your feeling, not neccessarily a fact (otherwise we would
not have this discussion).

> That (hashtables, sort - DK) is a single pattern which may or may not
be the 
> predominate use of 
> these classes.  I think that its shortsighted to keep throwing this 
> single issue up as THE ARGUMENT.
> (...)
> Okay, no more arguments about "AtomicX as a hashmap key" :-) 
> Let's try 
> and find some other issue besides how mutability inpacts 
> these classes 
> as keys to see if there is a strong case for not making equals and 
> compareTo be value based.

>From the Object.hashCode javadoc:
"This method is supported for the benefit of hashtables such as those
provided by <code>java.util.Hashtable</code>"

>From the Comparable javadoc:
"Lists (and arrays) of objects that implement this interface can be
sorted automatically by <tt>Collections.sort</tt> (and
<tt>Arrays.sort</tt>). Objects that implement this interface can be used
as keys in a sorted map or elements in a sorted set, without the need to
specify a comparator.<p>"

Conclusion: sorting (or maintaining a total order) IS a predominant (if
not the only) use of Comparable. Hash maps and sets ARE a predominant
use of hashCode. Hence, these usage patterns are essential to evaluate
appropriateness of value-based comparison for atomics.

> API development in a vacuum can 
> typically result 
> in APIs that belong "in a vacuum".  If everybody gets a 
> chance to voice 
> their opinion, then the API gets to be improved where the 
> arguments hold 
> value.  This is a good thing!

This is an open forum; opinions have been voiced, quite exhaustively in
fact. But we should respect the authority of the Expert Group, too. The
moment they decide, there is little point in continuing the argument
(unless someone has something really new to say).

Regards,
Dawid


From mohammed@intalio.com  Tue Jan 13 17:53:31 2004
From: mohammed@intalio.com (Riad Mohammed)
Date: Tue, 13 Jan 2004 09:53:31 -0800
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should  implement Number
In-Reply-To: <20040113142501.15405.34250.Mailman@altair.cs.oswego.edu>
Message-ID: <CMEMJHFCBBNFBEIDFDINEEHJCAAA.mohammed@intalio.com>

Gregg Wonderly wrote:
>
> Dawid Kurzyniec wrote:
>
>
> > It is a very different situation; Numbers are safe as map keys, atomics
> > are definitely not. (See my response to Larry's e-mail).
>
> That is a single pattern which may or may not be the predominate use of
> these classes.  I think that its shortsighted to keep throwing this
> single issue up as THE ARGUMENT.

I have to agree.

There is no restriction on mutable objects being used as map keys beyond
general good programming practice. But it does not follow that if a mutable
object is used a key then it is always a bad programming practice.

The use case would be that at some point my internal AtomicX is no longer
being changed and I want to use it a key. One way is to make an immutable
object with AtomicX value and the other is to use the AtomicX object as the
key directly. The former is the safest but since my internal implementation
has the knowledge that the AtomicX is not being changed then the immutable
object creation is an unnecessary step.

If I receive a Number, the abstract class, from an external source and I
want to use that object as a map key then I have to make an immutable copy
anyway whether or not AtomicX implements requisite methods.

Riad


From dawidk@mathcs.emory.edu  Tue Jan 13 18:26:39 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 13 Jan 2004 13:26:39 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should  implement Number
In-Reply-To: <CMEMJHFCBBNFBEIDFDINEEHJCAAA.mohammed@intalio.com>
References: <CMEMJHFCBBNFBEIDFDINEEHJCAAA.mohammed@intalio.com>
Message-ID: <200401131326.40095.dawidk@mathcs.emory.edu>

On Tuesday 13 January 2004 12:53 pm, Riad Mohammed wrote:
> Gregg Wonderly wrote:
> > Dawid Kurzyniec wrote:
> > > It is a very different situation; Numbers are safe as map keys, atomics
> > > are definitely not. (See my response to Larry's e-mail).
> >
> > That is a single pattern which may or may not be the predominate use of
> > these classes.  I think that its shortsighted to keep throwing this
> > single issue up as THE ARGUMENT.
>
> I have to agree.
>
> There is no restriction on mutable objects being used as map keys beyond
> general good programming practice. But it does not follow that if a mutable
> object is used a key then it is always a bad programming practice.

It is always a bad programming practice (actually, an error) if it is possible 
for the value to change _while_ it is used as a key. (Again, I gave details 
in my response to Larry's e-mail).

> The use case would be that at some point my internal AtomicX is no longer
> being changed and I want to use it a key. One way is to make an immutable
> object with AtomicX value and the other is to use the AtomicX object as the
> key directly. The former is the safest but since my internal implementation
> has the knowledge that the AtomicX is not being changed then the immutable
> object creation is an unnecessary step.

So let me try to summarize this:
1) the purpose of atomic classes is to allow atomic, unsynchronized concurrent 
modifications.
2) the only non-erroneous usage scenario of value-based comparison (for 
atomics in particular) is if it is guaranteed that the comparisons yield 
consistent results during the usage, i.e. values do not change during the 
usage.
3) there exist valid usage scenarios where it is preferable to use default, 
identity-based comparison of atomics (see previous Doug Lea's e-mail). 

Given that the behavior of 2) can be obtained with "get()" in a safer way 
(which, for instance, does not break if semantics of the program change in 
the future, allowing the atomic value to change), and that 2) in principle 
conflicts with the purpose of atomics defined in 1), and that 3) seems more 
likely than 2), I argue that the default comparison for atomics should be 
identity-based.

Regards,
Dawid


From eross@m-qube.com  Tue Jan 13 18:39:06 2004
From: eross@m-qube.com (Elias Ross)
Date: 13 Jan 2004 10:39:06 -0800
Subject: [concurrency-interest] PooledExector -- not clear on execute() + waitWhenBlocked()
Message-ID: <1074019146.16219.409.camel@localhost.localdomain>

I've been trying to fix a bug in JBoss's JMS implementation.  I am
assuming during the Runnable.run() method an unchecked exception gets
thrown or the Thread.interrupt() is called and the pool eventually
becomes smaller and unusable.  Looking at the PooledExector class, it
isn't clear why this would be the case.  There are no obvious JavaDoc
statements that explain this sort of thing can happen.


Here is an example program.  Under 

import
EDU.oswego.cs.dl.util.concurrent.*;                                                                                                                                                               
public class PoolTest {
                                                                                                                                                               
  public class Task implements Runnable {
    public void run() {
      System.out.println("run");
      // throw new RuntimeException();
      Thread.currentThread().interrupt();
    }
  }

  public static void main(String args[]) {
    new PoolTest();
  }

  public PoolTest() {
    PooledExecutor pe = new PooledExecutor(3);
    pe.waitWhenBlocked();
    while (true) {
      try {
        pe.execute(new Task());
      } catch (Exception e) {
      }
    }
  }
}

[eross@dhcppc3 test]$ java -version
java version "1.4.1"
Java(TM) 2 Runtime Environment, Standard Edition (build
Blackdown-1.4.1-01)
Java HotSpot(TM) Client VM (build Blackdown-1.4.1-01, mixed mode)

Release 1.3.2 of concurrent.jar



From dholmes@dltech.com.au  Tue Jan 13 22:34:46 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Wed, 14 Jan 2004 08:34:46 +1000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <4003FFB3.2030808@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCIEDCDMAA.dholmes@dltech.com.au>

Just 2c on one aspect of this:

> Gregg Wonderly wrote:
> Performance is not the primary issue here.  The primary
> issue for me is
> that I am going to have to synchronize through memory allocation to
> create all these new objects.  I am also going to expand the JVM's
> memory use to have to representations of the same thing.
> There seems little advantage to this.

Isn't this argument a bit overstated given that you must change your
applications to use AtomicInteger anyway?

If you currently use "int" values as your mutable entities you would
have to wrap these as Integer at some stage. Now you would use
AtomicInteger and still have to wrap at the same stage.

If you currently use Integer objects and perform calculations then you
must be creating new Integer objects for results. Replacing Integer
with AtomicInteger can remove the need for intermediate Integer
objects, but you still need the final Integer to hold the result from
get().

Anyway this point is moot now that AtomicInteger will extend Number.

David Holmes


From gregg.wonderly@pobox.com  Wed Jan 14 01:03:50 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 13 Jan 2004 19:03:50 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <NFBBKALFDCPFIDBNKAPCIEDCDMAA.dholmes@dltech.com.au>
References: <NFBBKALFDCPFIDBNKAPCIEDCDMAA.dholmes@dltech.com.au>
Message-ID: <40049576.6090002@cox.net>


David Holmes wrote:
> Just 2c on one aspect of this:
> 
> 
>>Gregg Wonderly wrote:
>>Performance is not the primary issue here.  The primary
>>issue for me is
>>that I am going to have to synchronize through memory allocation to
>>create all these new objects.  I am also going to expand the JVM's
>>memory use to have to representations of the same thing.
>>There seems little advantage to this.
> 
> 
> Isn't this argument a bit overstated given that you must change your
> applications to use AtomicInteger anyway?

What I am refering to is copies of AtomicX values just so that I have a 
Number implementation that has compareTo() and equals() as value based.

> If you currently use "int" values as your mutable entities you would
> have to wrap these as Integer at some stage. Now you would use
> AtomicInteger and still have to wrap at the same stage.

I already have a Number implementation in AtomicX.  Now I am going to 
have to copy that Object to have an Object that has value based 
comparison right?

> If you currently use Integer objects and perform calculations then you
> must be creating new Integer objects for results. Replacing Integer
> with AtomicInteger can remove the need for intermediate Integer
> objects, but you still need the final Integer to hold the result from
> get().

I don't need a value from get() with these objects extending Number if 
they are also Comparable and have value based equals()

> Anyway this point is moot now that AtomicInteger will extend Number.

No, I talking about the specific instance of private code that uses 
Number based values that now must be changed to be different about the 
use of Object.equals because these Number implementations don't have a 
value based .equals().

Gregg


From gregg.wonderly@pobox.com  Wed Jan 14 01:07:58 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Tue, 13 Jan 2004 19:07:58 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <000301c3d9f5$f1b287d0$a0fa8caa@mathcs.emory.edu>
References: <000301c3d9f5$f1b287d0$a0fa8caa@mathcs.emory.edu>
Message-ID: <4004966E.2080308@cox.net>


Dawid Kurzyniec wrote:
>>Performance is not the primary issue here.  The primary issue 
>>for me is 
>>that I am going to have to synchronize through memory allocation to 
>>create all these new objects.  I am also going to expand the JVM's 
>>memory use to have to representations of the same thing.  There seems 
>>little advantage to this.
> 
> 
> Unless you use some sort of a GUI (and if you did you'd not worry about
> memory footprint of number wrappers), you probably don't need to create
> wrappers at all, just use primitive values returned by get() -- this
> induces no memory allocation whatsoever. 

I have existing code that has the following logic in it.

	if( NumberImpl1.equals(NumberImpl2) ) {
		...
	}

How am I going to reuse this code without doing

	new Integer( AtomicInteger1.intValue() )

some place so that the equals will work with value based comparison?


From dawidk@mathcs.emory.edu  Wed Jan 14 03:38:25 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Tue, 13 Jan 2004 22:38:25 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <4004966E.2080308@cox.net>
Message-ID: <000001c3da4f$df8e43a0$27fa8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Gregg Wonderly
> Sent: Tuesday, January 13, 2004 8:08 PM
> To: Dawid Kurzyniec
> Cc: concurrency-interest@altair.cs.oswego.edu
> Subject: Re: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 
> 
> I have existing code that has the following logic in it.
> 
> 	if( NumberImpl1.equals(NumberImpl2) ) {
> 		...
> 	}

If you have code like that, which does arithmetic on number wrappers
rather than on flat primitives, you can't seriously claim that this
particular application is concerned about memory allocation overhead
caused by the wrappers. Apparently, the authors of that code didn't
think of it as a big deal. If so, the use of get() should be no problem
here even if you have to depend on autoboxing. If they were wrong, the
problem lies in their code and it should not be cured by bending the
general-purpose concurrency API.

BTW. I believe that allocation of primitive wrappers is extremely well
optimized in Java, since those are final classes (no virtual method
table, size precisely known) and since it is such a common pattern. I
wouldn't be surprised if in fact most short-lived usages of numeric
wrappers were optimized by JIT to the point where there was no heap
memory allocation whatsoever. Does somebody know if "autoboxing" JSR
group have some actual benchmark results?...

Regards,
Dawid


From larryr@saturn.sdsu.edu  Wed Jan 14 03:51:49 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 14 Jan 2004 03:51:49 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <4004966E.2080308@cox.net>
Message-ID: <20040114035149.11337.qmail@home19.riedel.org>

> I have existing code that has the following logic in it.
> 	if( NumberImpl1.equals(NumberImpl2) ) {
> 		...
> 	}
> How am I going to reuse this code without doing

I think in any specific case it is not going to a big problem, just one
more little thing which makes using Java seem to be a pain in the ass
for no good reason.  I think C++ was the same way, CORBA... where the
language/framework developers had such myopia and fixation on specific
semantic minutiae of particular situations to not see that really the
only overall viable solution is for everything to be transparently simple
and utterly, pervasively, unrelentingly consistent, leaving very few API
design decisions to be made on a case by case basis since the need for
transparency and universal consistency take away all the flexibility.

>From that point of view, Java was DOA, obscenely convoluted and inconsistent
from the beginning; but Java was cross-platform and free to use, and
had static type checking, garbage collection, fairly simple mostly
working degenerate multiprocessing support, and a commitment to provide
implementations for a rich set of officially sanctioned APIs.  I think those
things still set Java apart, regardless of how crappy it otherwise is,
although it seems to me there is a pretty good chance that C# and dotNET
will eventually supplant Java because they provide those good things in what
I think is a more simple, consistent, intuitive way.  For example I like
the System.Threading.Interlocked.CompareExchange stuff in dotNET because it
seems to come closer to providing just what it needs to provide related to
atomicity (test-and-set); no less, and especially no more.


Larry



From shanir@cs.tau.ac.il  Tue Jan 13 17:08:52 2004
From: shanir@cs.tau.ac.il (Nir Shavit)
Date: Tue, 13 Jan 2004 12:08:52 -0500
Subject: [concurrency-interest] Re: Concurrency-interest digest, Vol 1 #201 - 7 msgs
In-Reply-To: <20040112170001.3805.14043.Mailman@altair.cs.oswego.edu>
References: <20040112170001.3805.14043.Mailman@altair.cs.oswego.edu>
Message-ID: <40042624.5050907@cs.tau.ac.il>

Ori, I will call you tomorrow, I will have mor etime to talk then, hope 
tahts ok, Nir

concurrency-interest-request@cs.oswego.edu wrote:

>Send Concurrency-interest mailing list submissions to
>	concurrency-interest@altair.cs.oswego.edu
>
>To subscribe or unsubscribe via the World Wide Web, visit
>	http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest
>or, via email, send a message with subject or body 'help' to
>	concurrency-interest-request@altair.cs.oswego.edu
>
>You can reach the person managing the list at
>	concurrency-interest-admin@altair.cs.oswego.edu
>
>When replying, please edit your Subject line so it is more specific
>than "Re: Contents of Concurrency-interest digest..."
>
>
>Today's Topics:
>
>   1. Re: Re: AtomicInteger and AtomicLong should
>       implement Number (Shyam)
>   2. Re: AtomicInteger and AtomicLong should implement Number (Larry Riedel)
>   3. Re: Re: AtomicInteger and AtomicLong should implement Number (Doug Lea)
>   4. Re: Re: AtomicInteger and AtomicLong should
>       implement Number (Doug Lea)
>   5. Re: AtomicInteger and AtomicLong should implement Number (Larry Riedel)
>
>--__--__--
>
>Message: 1
>Date: Sun, 11 Jan 2004 20:27:33 -0700
>From: Shyam <Shyam.Ramamurthy@oracle.com>
>Organization: Oracle
>CC: concurrency-interest@altair.cs.oswego.edu
>Subject: Re: [concurrency-interest] Re: AtomicInteger and AtomicLong should
> implement Number
>
>
>
>Larry Riedel wrote:
>
>  
>
>>>   
>>>
>>>      
>>>
>>It looks to me like think AtomicX provide a specific simple case of
>>confinement/synchronization under the control of the application
>>which happens to map cleanly to instructions which can be performed
>>orders of magnitude more quickly by the JVM or CPU than if they were
>>implemented them using the Java language level equivalents.  I do not
>>think they change the fundamental nature of the entities for which they
>>are providing that particular case of confinement/synchronization, or
>>that those entities which would benefit from the use of that efficient
>>implementation are necessarily inherently different in practice from
>>those which would not.
>> 
>>
>>    
>>
>
>A tangential comment on this : Would it make sense to have XYZ.atomicX 
>that would return a atomic version of X akin to 
>Collections.synchronizedMap?
>
>Thanks,
>Shyam
>
>  
>


From gregg.wonderly@pobox.com  Wed Jan 14 13:44:46 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Wed, 14 Jan 2004 07:44:46 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <000001c3da4f$df8e43a0$27fa8caa@mathcs.emory.edu>
References: <000001c3da4f$df8e43a0$27fa8caa@mathcs.emory.edu>
Message-ID: <400547CE.3010700@cox.net>


Dawid Kurzyniec wrote:
> If you have code like that, which does arithmetic on number wrappers
> rather than on flat primitives, you can't seriously claim that this
> particular application is concerned about memory allocation overhead
> caused by the wrappers. 

One wrapper is fine because this code works for Double, Integer, Byte, 
Short, Long etc.  Adding the use of AtomicX into this code will make it 
necessary to have a version for each type, and that will square the 
required number of instances if I have to use templates because of mixed 
types.

Dawid, you are failing to understand the argument.  You have some kind 
of myopic view of this issue clouded by the fact that any API that does 
have just native integer values and Maps that are non-value keyed is 
foreign and probably not useful or meaningful.

Gregg


From tim@peierls.net  Wed Jan 14 14:51:02 2004
From: tim@peierls.net (Tim Peierls)
Date: Wed, 14 Jan 2004 09:51:02 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <400547CE.3010700@cox.net>
References: <000001c3da4f$df8e43a0$27fa8caa@mathcs.emory.edu> <400547CE.3010700@cox.net>
Message-ID: <40055756.2070600@peierls.net>

Gregg Wonderly wrote:
> Dawid, you are failing to understand the argument.  You have some kind 
> of myopic view of this issue clouded by the fact that any API that does 
> have just native integer values and Maps that are non-value keyed is 
> foreign and probably not useful or meaningful.

How did this get to be such an emotional topic? If you really want to
use AtomicX instances as keys based on their mutable values instead of
their identities, no one is stopping you:

   class ComparableAtomicInteger extends AtomicInteger
                                 implements Comparable<ComparableAtomicInteger> {
       public ComparableAtomicInteger() {}
       public ComparableAtomicInteger(int value) { super(value); }
       public int hashCode() { return get(); }
       public boolean equals(Object o) {
           if (this == o)
               return true;
           if (!(o instanceof ComparableAtomicInteger))
               return false;
           return this.get() == ((ComparableAtomicInteger) o).get();
       }
       public int compareTo(ComparableAtomicInteger that) {
           int i1 = this.get();
           int i2 = that.get();
           return i1 < i2 ? -1 : (i1 == i2 ? 0 : 1);
       }
   }

Caveat emptor.

--tim



From dl@cs.oswego.edu  Wed Jan 14 15:18:48 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 14 Jan 2004 10:18:48 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: <4004966E.2080308@cox.net>
References: <000301c3d9f5$f1b287d0$a0fa8caa@mathcs.emory.edu> <4004966E.2080308@cox.net>
Message-ID: <40055DD8.7010205@cs.oswego.edu>

To try to recap decisions:

1. AtomicInteger extends Number to allow uniform access
to values by tools and utilities. (Similarly for toString
and serialization.)

2. It provides identity-based semantics for equality, as do
most stateful classes in Java.

3. In those cases where people want value-based equality etc
they can either rely on autoboxing, which provides reliable
semantics at the possible cost of overhead, or create subclasses
that add on particular equals, hashCode, and/or compareTo methods.

I believe that everyone has some straightforward path to getting desired
effects, and no reasonable usage is ruled out.

-Doug



From ccox@tripos.com  Wed Jan 14 16:30:13 2004
From: ccox@tripos.com (Curt Cox)
Date: Wed, 14 Jan 2004 10:30:13 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <40055DD8.7010205@cs.oswego.edu>
Message-ID: <MDEIJLCNINPJGNEJMGODEEDLCHAA.ccox@tripos.com>

Doug,

I don't know how germane it is, but I'm skeptical that
most stateful classes in Java provide identity-based equality
semantics.  The Collections Framework springs immediately to
mind.  This is just a gut feeling, I don't have any hard numbers.

Of course "most" is a pretty nebulous concept in this case.
Collections are heavily used.  Do they therefore count more
than other classes?  Do the objects used in collections count
for more than the collections themselves?

When the natural equality test is state-based,
there isn't much reason not to implement it, despite any
problems it causes when used as a map key.

1. If you somehow know there will be no state changes,
it is a safe map key
2. If you think there might be a problem with mutability,
you should have an immutable variant, too
3. IdentityHashMap means it can still be a map key even
in the face of state change
4. All the identity based information is still easily
accessible via == and System.identityHashCode()
5. Since both equality types are readily available,
there is less reason to hesitate making the class final.
I'm a believer in declaring classes final, unless they were
designed with extension in mind.

In short, defining state-based equality in the class usually
makes it easier for the user to pick the desired equality type.

- Curt

-----Original Message-----
From: concurrency-interest-admin@cs.oswego.edu
[mailto:concurrency-interest-admin@cs.oswego.edu]On Behalf Of Doug Lea
Sent: Wednesday, January 14, 2004 9:19 AM
To: gregg.wonderly@pobox.com
Cc: Dawid Kurzyniec; concurrency-interest@altair.cs.oswego.edu
Subject: Re: [concurrency-interest] Re: AtomicInteger and AtomicLong
should implement Number



To try to recap decisions:

1. AtomicInteger extends Number to allow uniform access
to values by tools and utilities. (Similarly for toString
and serialization.)

2. It provides identity-based semantics for equality, as do
most stateful classes in Java.

3. In those cases where people want value-based equality etc
they can either rely on autoboxing, which provides reliable
semantics at the possible cost of overhead, or create subclasses
that add on particular equals, hashCode, and/or compareTo methods.

I believe that everyone has some straightforward path to getting desired
effects, and no reasonable usage is ruled out.

-Doug


_______________________________________________
Concurrency-interest mailing list
Concurrency-interest@altair.cs.oswego.edu
http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest







From dawidk@mathcs.emory.edu  Wed Jan 14 17:37:12 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 14 Jan 2004 12:37:12 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <MDEIJLCNINPJGNEJMGODEEDLCHAA.ccox@tripos.com>
Message-ID: <000001c3dac5$0c8c9c60$a3fc8caa@mathcs.emory.edu>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Curt Cox
> Sent: Wednesday, January 14, 2004 11:30 AM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: RE: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 

> I'm a believer in declaring 
> classes final, unless they were designed with extension in mind.

I agree with Curt on that :)

I believe that the atomics should be kept final. Otherwise, it may
preclude or make it more difficult for JIT to perform some optimizations
(inline-out memory allocation and/or method calls). This is crucial for
low-level algorithms, for which these classes are primarily provided.

Occasional suicidal users can still craft enough rope by using
delegation (everybody can extend Number) and/or write custom external
comparators.

Regards,
Dawid


From larryr@saturn.sdsu.edu  Wed Jan 14 21:42:02 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 14 Jan 2004 21:42:02 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <MDEIJLCNINPJGNEJMGODEEDLCHAA.ccox@tripos.com>
Message-ID: <20040114214202.14697.qmail@home19.riedel.org>

> I'm skeptical that most stateful classes in Java provide
> identity-based equality semantics. [...]
> When the natural equality test is state-based, [...]

To me it seems intuitively pretty clear that introducing a facility
which adds atomic access semantics to an entity does not justify
changing the way that entity is compared with other entities of that
type.  So I think if the manifestation of the facility is to have a
class whose instances are surrogates for the entities, the surrogates
should, to the extent feasible, try to assume the type and comparison
semantics of those entities.  I think it is fair to assume that entities
which are fundamentally used as numeric values will have numeric
comparison semantics.

Also, I think if the phrase "at the same apparent relative location
inside the JVM" was used instead of "identity-based equality" to
describe the use of the "==" operator on a pair of Java reference values
(JLS 4.3), it might do a better job of making it clear that using Java
"==" as an equivalence operator for identity may have little or no
intuitive high level meaning.

It makes sense to me that relative location inside the JVM would be
important in the context of implementing atomic facilities in the JVM.
And for gut level implementation details of a particular method of a
particular class, I believe it is often expedient to decide to map
"==" onto a locally degenerate interpretation of equal identity.  But I
certainly wouldnt want to have to design my application around the idea
that "==" in Java is synonymous with "identity-based equality".

In situations where I want to partition/distinguish or order
entities/objects based on identity rather than state, I would not
want to be pressured towards using Java reference values to define
identity, or for the JDK to assume they are synonymous.  In the case
of the "Object" class, the root of the type hierarchy, I can imagine
that faced with a decision to throw an exception from equals() and
hashCode(), or try to produce some sort of degenerate implementation
to lower the barrier of entry for people to use the language, I might
choose the latter, but I would not see that indulgence as an excuse for
foundational classes that actually do something to balk at choosing a
more intuitively meaningful implementation.


Larry


From dawidk@mathcs.emory.edu  Thu Jan 15 02:53:46 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 14 Jan 2004 21:53:46 -0500
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <20040114214202.14697.qmail@home19.riedel.org>
Message-ID: <000001c3db12$cd2c4270$53fd8caa@mathcs.emory.edu>

> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu 
> [mailto:concurrency-interest-admin@cs.oswego.edu] On Behalf 
> Of Larry Riedel
> Sent: Wednesday, January 14, 2004 4:42 PM
> To: concurrency-interest@altair.cs.oswego.edu
> Subject: [concurrency-interest] Re: AtomicInteger and 
> AtomicLong should implement Number
> 
> To me it seems intuitively pretty clear that introducing a 
> facility which adds atomic access semantics to an entity does 
> not justify changing the way that entity is compared with 
> other entities of that type.  So I think if the manifestation 
> of the facility is to have a class whose instances are 
> surrogates for the entities, the surrogates should, to the 
> extent feasible, try to assume the type and comparison 
> semantics of those entities.  

I really like this argument, and I agree with it. The point where we
fail to agree is whether atomic classes are indeed surrogates for the
values they hold. I personally think they aren't (in other words, that
we have the "contains" rather than "is" relation here). It seems to be a
matter of taste, and opinions vary depending on background and earlier
experiences people have. Nevertheless, let me try to explain my point of
view a bit further. It is interesting to hypotetically consider what
would happen if the atomicity was added at the language level (as, I
suppose, many of us would like it to be). Let's assume that we have the
"atomic" field modifier and a hash map which accepts primitives as keys.
Then let's consider the following code:

class A {
  atomic int a;
  Map<String> m = new HashMap<String>();

  void foo() {
    a = 5;
    m.put(a, "5");
    m.put(6, "6");
    a++;
    String val5 = m.get(5);
    String val6 = m.get(a);
  }
}

Quick question before you read on: what would you expect val5 and val6
to be?

Here, the value of a variable which was used as a key is being changed
after using it as a key. Nevertheless, it seems natural to expect that
the code works, e.g. that the val5 gets assigned "5", and that val6 gets
assigned 6. In other words, it seems natural to assume that the mapping
is created by taking the momentary value of the variable rather than the
variable itself as a key. In yet another words, it seems natural to
expect to observe the behavior defined in JLS 15.2: "If an expression
denotes a variable, and a value is required for use in further
evaluation, then the value of that variable is used."

The equivalent code written using atomic classes is as follows:

class A {
  AtomicInteger a = new AtomicInteger();
  Map<String> m = new HashMap<String>();
  
  void foo() {
    a.set(5);
    m.put(a.get(), "5");
    m.put(6, "6");
    a.incrementAndGet();
    String val5 = m.get(5);
    String val6 = m.get(a.get());
  }
}

Note that I had to use "get()" twice in order to obtain the same
behavior as before. Otherwise, the variable itself would be taken as a
key, and the behavior of a Map would become undefined. It is as if
somehow in the previous example the "field pointer" was taken as a key
rather than a value of the variable.

In other words, it follows that "get()" is semantically equivalent to
the operation performed by Java runtime on the ordinary variable when it
is used in an expression (other than at the right hand side of an
assignment expression). Hence, I don't consider the neccessity to use
"get()" as a bad thing - it is simply reflecting the fact that the value
of the variable is being used rather than the variable itself. The lack
of the distinction between a variable and its value seems to be driving
this discussion.

> Also, I think if the phrase "at the same apparent relative 
> location inside the JVM" was used instead of "identity-based 
> equality" to describe the use of the "==" operator on a pair 
> of Java reference values (JLS 4.3), it might do a better job 
> of making it clear that using Java "==" as an equivalence 
> operator for identity may have little or no intuitive high 
> level meaning.

I'd say that this issue is a bit of a red herring here. JSR 166 group
has a well-defined goals, which do not include changing the "feel" or
the fundamentals of Java language. But I will actually try to defend the
meaningfulness of using "==" as an identity operator:

The Java heap contains Java objects. Objects may have references to
other objects. Thus, objects constitute a graph. Of course, at the lower
level you have some flat memory and "relative locations", but the JLS is
not concerned with such a low level. From the JLS point of view, the
heap simply contains objects constituting a graph. The objects in Java
are very distinguishable, concrete entities, and the "==" relation tests
whether two (usually distinct) references point to the same object in
the heap. As a consequence of their concretness, the most fine-grained
equivalence relation you may have in the set of Java objects is the one
where every single object constitutes an individual equivalence class.
This canonical equivalence relation is defined by the default
Object.equals() implementation. By overriding equals(), you can redefine
the equivalence relation to group multiple objects into equivalence
classes, but you cannot get any finer than Object.equals(), which makes
this one canonical and a natural default.

>From this point of view, and if you agree that atomics are variables,
there is nothing wrong with leaving atomics with default "equals()" --
it is OK since every two distinct atomic objects are distinct variables,
e.g. they do not refer to the same memory location. 

I would compare the atomic classes to java.lang.reflect.Field, which
also represents a variable. Would you argue that Field is a surrogate
for a value it represents? Would you expect Field to have value-based
equals? In fact, Field equals() is redefined to determine whether two
"Field" objects refer to the same named field in the same class; i.e.
the "equals" mean that they obtain their values from the same memory
offset given the object instance. Since every atomic class has its own
memory location, two atomics are always non-"equal" from this
perspective unless they are the same object in terms of "==".

Kind regards,
Dawid Kurzyniec


From gregg.wonderly@pobox.com  Wed Jan 14 15:22:13 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Wed, 14 Jan 2004 09:22:13 -0600
Subject: [ Tim Peierls ] [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: Your message of Wed, 14 Jan 2004 09:51:02 -0500.
 <40055756.2070600@peierls.net>
Message-ID: <1435.1074093733@skymaster.cytetech.com>

>How did this get to be such an emotional topic? If you really want to
>use AtomicX instances as keys based on their mutable values instead of
>their identities, no one is stopping you:
>
>   class ComparableAtomicInteger extends AtomicInteger
>                                 implements Comparable<ComparableAtomicInteger
 > {
>       public ComparableAtomicInteger() {}
>       public ComparableAtomicInteger(int value) { super(value); }

What everyone is supposing is that I want to and can add new code to
deal with this issue.  In some cases, sure enough, I can.  In others I can't

I am arguing to preserve the use of the existing classes that already
use Number implementations where equals() and compareTo() have a value based
implementation.

It's emotional because every argument is "but there is so little code to add"
or "you're already gonna change the code".  What I don't see is arguments
that include the whole reusablity, library, existing implementation issue.

The arguments against are emotional.  I am trying to present facts and use
cases that I am familar with.  I threw in the "myopic view" comment because
I don't know how else to classify Dawid's arguments that focus solely on the
"AtomicX can never be used as a Map key" issue.  It is true that there is an
issue with that particular case.  But, AtomicX being mutable does not create
a new problem.  There are plenty of Mutable classes that can be used as Keys
in Maps or that have Comparable implementations etc.  Mutability is thus not
a new issue at all.  People have already learned, or will learn after they
make the mistake that they can't use changing hashCode() classes in a Map
as keys.  This lesson has already been learned by many, including Dawid it
seems.

So, rather than restrict the use of these classes because one use case may be
problematic.  I think we should make the functionality of these classes be in
line with the existing Number instances that are native type containers so
that everyone can use these numeric values as numeric values and not have
to wrap them in some other container to get a value based equals() and
compareTo().

-----
gregg@cytetech.com  (Cyte Technologies Inc)

From gregg.wonderly@pobox.com  Wed Jan 14 15:23:06 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Wed, 14 Jan 2004 09:23:06 -0600
Subject: [ Doug Lea ] [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: Your message of Wed, 14 Jan 2004 10:18:48 -0500.
 <40055DD8.7010205@cs.oswego.edu>
Message-ID: <1503.1074093786@skymaster.cytetech.com>

>3. In those cases where people want value-based equality etc
>they can either rely on autoboxing, which provides reliable
>semantics at the possible cost of overhead, or create subclasses
>that add on particular equals, hashCode, and/or compareTo methods.

AtomicX classes are final last I looked

-----
gregg@cytetech.com  (Cyte Technologies Inc)

From notgermy@yahoo.com  Thu Jan 15 00:26:44 2004
From: notgermy@yahoo.com (Gary Moyer)
Date: Wed, 14 Jan 2004 16:26:44 -0800 (PST)
Subject: [concurrency-interest] differentiating between result-bearing and non- result-bearing actions
Message-ID: <20040115002644.73230.qmail@web60304.mail.yahoo.com>

Consider an array of ScheduledFuture objects that are representative of actions
that are both result-bearing and non- result-bearing.  To clarify a
result-bearing action references a java.util.concurrent.Callable<V> whereas a
non- result-bearing action references a java.lang.Runnable.  Is it possible to
differentiate one from the other?  Additionally, if the action is repeating
(e.g. created via scheduleAtFixedRate()) is it possible to retrieve the
associated period?

As an example scenario consider attempting to collect the results of all
result-bearing actions using said array.

Thanks,
-- Gary

__________________________________
Do you Yahoo!?
Yahoo! Hotjobs: Enter the "Signing Bonus" Sweepstakes
http://hotjobs.sweepstakes.yahoo.com/signingbonus

From eqmel@comcast.net  Thu Jan 15 04:19:18 2004
From: eqmel@comcast.net (Ronald Bense)
Date: Wed, 14 Jan 2004 22:19:18 -0600
Subject: [ Tim Peierls ] [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <1435.1074093733@skymaster.cytetech.com>
Message-ID: <00ac01c3db1e$be8624f0$0e01a8c0@redarrow>


> -----Original Message-----
> From: concurrency-interest-admin@cs.oswego.edu [mailto:concurrency-
...
> interest-admin@cs.oswego.edu] On Behalf Of Gregg G. Wonderly
> The arguments against are emotional.  ...

They shouldn't be.

> ...I threw in the "myopic view" comment because
> I don't know how else to classify Dawid's arguments that focus solely
on
> the "AtomicX can never be used as a Map key" issue.  

I personally think his argument is that they have a specific purpose,
and that purpose is not to be used anywhere currently Number objects are
used. 

I could also use StringBuffers as map keys or numbers, but that doesn't
mean I should.

> a new issue at all.  People have already learned, or will learn after
they
> make the mistake that they can't use changing hashCode() classes in a
Map
> as keys.  This lesson has already been learned by many, including
Dawid it
> seems.
> 
> So, rather than restrict the use of these classes because one use case
may
> be
> problematic.  I think we should make the functionality of these
classes be
> in
> line with the existing Number instances that are native type
containers so
> that everyone can use these numeric values as numeric values and not
have
> to wrap them in some other container to get a value based equals() and
> compareTo().

I still am not really convinced that they are "numeric" values in the
sense that Integers or other Numbers are. To me, they are a container
holding an int or long, which has atomic change properties and from
which I can obtain a snapshot of the contained value via the get method.

However, having said that, I could potentially see where a mutable
Number object has value, perhaps in embedded systems, where memory and
performance have much tighter constraints. In those situations, I could
see where these features could potentially be helpful. 

So, perhaps they should have full numeric capabilities, along with a
stern warning in the javadoc that this is provided only for special
circumstances and should not be used for hash keys or sorting due to the
mutability of the underlying value. (Too bad there's only the deprecated
tag to cause warnings...) 

Or, a second set of AtomicComparablexxxx classes could be created,
complete with the notation that these are extremely special purpose
classes, to be used very carefully....

My $0.02

Ron



From dl@cs.oswego.edu  Thu Jan 15 04:44:32 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 14 Jan 2004 23:44:32 -0500
Subject: [concurrency-interest] PooledExector -- not clear on execute()
 + waitWhenBlocked()
In-Reply-To: <1074019146.16219.409.camel@localhost.localdomain>
References: <1074019146.16219.409.camel@localhost.localdomain>
Message-ID: <40061AB0.7040402@cs.oswego.edu>

Elias Ross wrote:
> I've been trying to fix a bug in JBoss's JMS implementation.  I am 
> assuming during the Runnable.run() method an unchecked exception gets
>  thrown or the Thread.interrupt() is called and the pool eventually 
> becomes smaller and unusable.  Looking at the PooledExector class, it
>  isn't clear why this would be the case.  There are no obvious
> JavaDoc statements that explain this sort of thing can happen.


This is a known documentation lapse in dl.u.c that I need to address.
WaitWhenBlock policy is fairly fragile in dl.u.c.PooledExecutor: You
need to configure the pool so that is impossible for there to be zero
worker threads; otherwise you can expose yourself to races where
blocked task producers resume but there are no threads.

More generally, WaitWhenBlocked is rarely a good policy -- it invites
various lockups and deadlocks unless you are very careful. CallerRuns
is much better wrt concurrency control. So we do not even build
WaitWhenBlocked in to
ThreadPoolExecutor; you'd have to go to the trouble of defining it
yourself in those infrequent cases where you do need it. (I suspect not
ever inside JBoss.)

-Doug



From dawidk@mathcs.emory.edu  Thu Jan 15 04:56:37 2004
From: dawidk@mathcs.emory.edu (Dawid Kurzyniec)
Date: Wed, 14 Jan 2004 23:56:37 -0500
Subject: [ Tim Peierls ] [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <00ac01c3db1e$be8624f0$0e01a8c0@redarrow>
Message-ID: <000001c3db23$f6b6f6b0$6cfd8caa@mathcs.emory.edu>


> -----Original Message-----
> From: Ronald Bense [mailto:eqmel@comcast.net] 
> Sent: Wednesday, January 14, 2004 11:19 PM
> To: gregg.wonderly@pobox.com; 'Tim Peierls'
> Cc: 'Dawid Kurzyniec'; concurrency-interest@altair.cs.oswego.edu
> Subject: RE: [ Tim Peierls ] [concurrency-interest] Re: 
> AtomicInteger and AtomicLong should implement Number 
> 
> I still am not really convinced that they are "numeric" 
> values in the sense that Integers or other Numbers are. To 
> me, they are a container holding an int or long, which has 
> atomic change properties and from which I can obtain a 
> snapshot of the contained value via the get method.
> 
> However, having said that, I could potentially see where a 
> mutable Number object has value, perhaps in embedded systems, 
> where memory and performance have much tighter constraints. 
> In those situations, I could see where these features could 
> potentially be helpful. 

I often write low-level system code (I admit - not embedded systems),
but I never do any arithmetic on number wrappers. If you really have
tight performance/heap memory constraints, you don't write generic
algorithms which work on generic number wrappers in a type-neutral way,
but you rather settle with some degree of redundancy by providing
specialized versions working with primitive types. (java.util.Arrays
class is a good example). And usually you don't even have to, because
most of the time you know the types you work with. Some things are ints,
others are doubles, sometimes there are characters and bytes (but
usually within arrays), and you tend to have different algorithms for
all them. Greg claimed he had a valid use case for Numbers in embedded
systems, but he failed to prove it when challenged (and I attribute his
emotions to good intentions and strong beliefs, so no offense taken).

> So, perhaps they should have full numeric capabilities, along 
> with a stern warning in the javadoc that this is provided 
> only for special circumstances and should not be used for 
> hash keys or sorting due to the mutability of the underlying 
> value. (Too bad there's only the deprecated tag to cause warnings...) 

Well, I thought about that, but: 

First of all, people tend not to read javadoc if they believe they
understand the API. With autocompletion etc., I do it all the time.
(Although for equals() and hashCode(), I agree that it is a little
different, because you want to know how is equivalence defined)

But, more importantly: I doubt it is possible to document it in javadocs
in a way it does not sound, well, idiotic:

/** This class is intended to support efficient unsynchronized
concurrent atomic modifications
     of an int value. DON'T use the fact that this class is comparable
and overrides hashCode()
     unless the value is constant. (DOH!)*/
class AtomicInteger implements Comparable {
  /* returns a hashCode based on the value currently hold, to allow this
object serve as a hash key. 
   * But DON'T use it as a hash key unless the value is constant
(DOH!)*/
  public boolean hashCode() {...}

  /* compares two atomics. But DON'T rely on this method to sort or put
stuff in a tree map
   * unless both values are constant. (DOH! again)*/
  public int compareTo()
}

How can you avoid contradiction between the general purpose of the class
stated in the class doc and restrictions of the usage of hashCode()
etc., especially given the documentation of Object.hashCode() and
Comparable?...


While I was writing it, other thing stroke me: the value-based equals()
returning true does not even guarantee that the values EVER were the
same, given the inherent race condition between reading values of two
atomics and their possible concurrent modifications.

It is just to supplement my previously stated (and more significant)
objections regarding the comparable issue.

Regards,
Dawid


From dl@cs.oswego.edu  Thu Jan 15 05:31:11 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 15 Jan 2004 00:31:11 -0500
Subject: [ Doug Lea ] [concurrency-interest] Re: AtomicInteger and AtomicLong
 should implement Number
In-Reply-To: <1503.1074093786@skymaster.cytetech.com>
References: <1503.1074093786@skymaster.cytetech.com>
Message-ID: <4006259F.1030604@cs.oswego.edu>

Gregg G. Wonderly wrote:
>>3. In those cases where people want value-based equality etc
>>they can either rely on autoboxing, which provides reliable
>>semantics at the possible cost of overhead, or create subclasses
>>that add on particular equals, hashCode, and/or compareTo methods.
> 
> 
> AtomicX classes are final last I looked
> 

No; they are nonfinal but all atomic methods are final. (Although the
early-access version had some inconsitencies across classes in how this
was done (sorry.))

And we remain confident that the current AtomicX APIs are both
conceptually and pragmatically about right.

-Doug



From larryr@saturn.sdsu.edu  Thu Jan 15 06:54:57 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 15 Jan 2004 06:54:57 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <00ac01c3db1e$be8624f0$0e01a8c0@redarrow>
Message-ID: <20040115065457.16507.qmail@home19.riedel.org>

> [AtomicX] have a specific purpose, and that purpose is not to be
> used anywhere currently Number objects are used. 
> 
> I could also use StringBuffers as map keys or numbers, but that
> doesn't mean I should.
> 
> [...]
> 
> I still am not really convinced that they are "numeric" values
> in the sense that Integers or other Numbers are. To me, they
> are a container holding an int or long, which has atomic
> change properties and from which I can obtain a snapshot of
> the contained value via the get method.

I think it would have been fine and natural to have an
"AtomicPrimitiveVariable" and an "AtomicReferenceVariable",
corresponding to the two kinds of types in the Java language,
and to the wording ("atomic variables") of the JSR.

Having "LongAtomicPrimitiveVariable" and "IntAtomicPrimitiveVariable"
sounds pretty good to me too-- whatever most clearly distinguishes
the "container" from the "contained value".  The documentation could
hopefully provide some explanation for why what looks like it should
have been a feature of the compiler ("atomic int") has become a
class/entity inside the JVM ("IntAtomicPrimitiveVariable"), which would
make it clear that the way things are done is not because any sane
person would have wanted to do it that way, but because the alternative
was to continue with no atomicity facility at all, and so like with
most of the nice new things coming from JSRs, half of it is some sort
of workaround for the legacy of crud they had to preserve.


Larry


From gregg.wonderly@pobox.com  Thu Jan 15 15:26:53 2004
From: gregg.wonderly@pobox.com (Gregg G. Wonderly)
Date: Thu, 15 Jan 2004 09:26:53 -0600
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should
 implement Number
In-Reply-To: Your message of Wed, 14 Jan 2004 23:56:37 -0500.
 <000001c3db23$f6b6f6b0$6cfd8caa@mathcs.emory.edu>
Message-ID: <9124.1074180413@skymaster.cytetech.com>

>I often write low-level system code (I admit - not embedded systems),
>but I never do any arithmetic on number wrappers. If you really have
>tight performance/heap memory constraints, you don't write generic
>algorithms which work on generic number wrappers in a type-neutral way,
>but you rather settle with some degree of redundancy by providing
>specialized versions working with primitive types. (java.util.Arrays
>class is a good example).

This is a fact from peoples experience with really lousy embedded environments 
where support for objects is expensive and where native types really are 
faster.  Have you used the aJile aj-100 any?  It's fast, it runs byte codes 
natively.  An object member reference is thus not any more 'expensive' or 
'indeterminate in cost' than a native.  But, if you add another level of 
delegation by wrapping (as opposed to subclassing) then you will have more 
overhead.  Also, if I have to copy all of the existing AtomicX values into new 
Integer values so that I can sort, group or use a value based equals() and/or 
compare to, then I am doubling my use of Objects for that particular case.

I work in industries that do data aquisition in embedded systems.  There are 
often thousands of points of interest visible in user interfaces.  These 
points change based on low level data gathering devices (such as those that 
might be built using the aJ-100.  It is important to me to make the display of 
data changes as fast as possible.  It is important to minimize garbage 
creation because that is what causes hickups in the UI that make people not 
sure of what they are seeing.  There are all kinds of places where code can be 
instrumented with these classes (a profiling compiler can generate uses of 
these classes to watch code execution etc).  All over the place, there are 
numeric algorithms using Objects because that is what is the easiest to store 
in maps, vectors and other dynamically resizing containers.

Is the important thing about the AtomicX classes that they are objects or is 
the important thing in them the numeric value.  I contend that the information 
about these classes that is most important is the numeric value inside.  Thus, 
they really should provide numeric value based equals and implementing 
Comparable would be a great help.

If we can not agree on this, then perhaps considerable thought should be given 
to creating subclasses in this package that do provide value based equals() 
and compareTo() so that there is a standard way for that use case to be 
present in Java programs as well.

>And usually you don't even have to, because
>most of the time you know the types you work with. Some things are ints,
>others are doubles, sometimes there are characters and bytes (but
>usually within arrays), and you tend to have different algorithms for
>all them. Greg claimed he had a valid use case for Numbers in embedded
>systems, but he failed to prove it when challenged (and I attribute his
>emotions to good intentions and strong beliefs, so no offense taken).

It is personal taste in embedded development regarding how lowevel or how 
close to the hardware you are willing to program.  I try to stay as far away 
from the hardware level details as I can.  I create interfaces that describe 
what I need to do, and then write the low level classes that provide the how.  
This makes it much more likely that I can switch out the hardware.  I even 
study the implementation details of multiple pieces of hardware that might 
have to be used at a later date, and engineer the interface with the 
commonalities of all the hardware in mind.

So, if I had a numeric value that was part of details of the hardware and on 
some hardware it was 32bits and on other hardware it was 16bits and on another 
it was 64bits, then you bet that my interface would use Number to pass this 
thing around.  That way it really is independent.

Perhaps I'm crazy and consider more detail than others.  But, I really am 
serious about this issue, and I really think it is a step sideways (almost 
backwards) to add atomic integral value access and not have a value based 
comparison visible in the objects implementation.

>Well, I thought about that, but: 
>
>First of all, people tend not to read javadoc if they believe they
>understand the API. With autocompletion etc., I do it all the time.
>(Although for equals() and hashCode(), I agree that it is a little
>different, because you want to know how is equivalence defined)

These same people are going to see "extends Number" and go woohoo a Number.  
They are then going to skip reading the rest of the JavaDoc and findout after 
some time that equals() is not value based.  They are going to be surprised...

>But, more importantly: I doubt it is possible to document it in javadocs
>in a way it does not sound, well, idiotic:

You are concentrating on a single issue (mutability makes comparison 
impossible under every single possible situation).  As I have stated before 
mutability is an issue with each and every Java Object created or used by Java 
programmers.  It is not a new issue and it is not going to go away.

>While I was writing it, other thing stroke me: the value-based equals()
>returning true does not even guarantee that the values EVER were the
>same, given the inherent race condition between reading values of two
>atomics and their possible concurrent modifications.

You are still supposing that every single time these values are reference by a 
call to equals that they are going to be actively engaged by code that is 
changing the values.  I can not see this being a good argument.  It is a 
situation when the use of value based comparisons is problematic.  But, it is 
not the case that this will be the only time these values could be involved in 
a value based comparison.

Would you be in favor of a value based equals() and no Comparable 
implementation?

-----
gregg@cytetech.com  (Cyte Technologies Inc)



From larryr@saturn.sdsu.edu  Thu Jan 15 20:49:07 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 15 Jan 2004 20:49:07 -0000
Subject: [concurrency-interest] Re: AtomicInteger and AtomicLong should implement Number
In-Reply-To: <9124.1074180413@skymaster.cytetech.com>
Message-ID: <20040115204907.19121.qmail@home19.riedel.org>

> I contend that the information about these classes that is
> most important is the numeric value inside.

!!!

> I really think it is a step sideways (almost backwards) to add
> atomic integral value access and not have a value based comparison
> visible in the objects implementation.

!!!

> mutability is an issue with each and every Java Object created
> or used by Java programmers.  It is not a new issue and it is not
> going to go away.

!!!

> You are still supposing that every single time these values are
> reference by a call to equals that they are going to be actively
> engaged by code that is changing the values.  I can not see this
> being a good argument.

!!!


> I create interfaces that describe what I need to do, and then write
> the low level classes that provide the how.  This makes it much
> more likely that I can switch out the hardware.  I even study the
> implementation details of multiple pieces of hardware that might
> have to be used at a later date, and engineer the interface with the
> commonalities of all the hardware in mind.

I feel like the biggest ironies are that (1) what I wanted was an
interface to a common hardware facility, atomic compare-and-increment,
test-and-set, etc, not something which, if I want to use it for the
purpose of application efficiency/performance optimization, asks
me to care whether I should or shouldnt have an application which
makes assumptions about the state of a object which is not immutable,
and (2) these hardware facilities I am trying to use are themselves
oriented around NUMERIC VALUES, and yet there seems to be a feeling that
efficient atomic access to numeric values is somehow a marginal/fringe
use case.

Speaking of marginalized, it seems to me the walls are closing in on Java
since Python (and even VB.NET) is vastly more productive for the most common
applications, and support has crystallized with C and C++ to make the
barrier pretty low to use them to put together applications which need to be
very lean/fast or talk to hardware, and still be robust.  I think Java has a
history of making the cost of efficiency/performance too high to make it a
viable choice for a high efficiency/performance application, but it is too
arbitrarily cumbersome for making simple things simple.

It seemed to me like the changes for JDK 1.5 could make Java come closer
to a high efficiency/performance application development solution, but
it looks like maybe even the stuff in JDK 1.5 is going to make the
reality of making a high efficiency/performance Java application still
a little too far off because the JDK continues to put a lot of goopy
stuff (eg AtomicInteger) between the application and what it wants to
do.  But anyway independent of JSR-166, if objects can still only be
resurrected once, I think there is pretty much no real world hope to
develop efficient applications in Java, because the mechanisms are still
not there for effectively recycling garbage objects, and the core JDK
APIs are treacherously improvident about creating objects.


Larry


From notgermy@yahoo.com  Fri Jan 16 23:48:34 2004
From: notgermy@yahoo.com (Gary Moyer)
Date: Fri, 16 Jan 2004 15:48:34 -0800 (PST)
Subject: [concurrency-interest] differentiating between result-bearing and non- result-bearing actions
Message-ID: <20040116234834.8107.qmail@web60305.mail.yahoo.com>

I believe there is a problem with the overloaded use of Future.  From the
Future javadoc:

If you would like to use a Future for the sake of cancellability but not
provide a usable result, you can declare types of the form Future<?> and return
null as a result of the underlying task.

Thus Future.get() returns null when the instance is returned by any of the
following ScheduledExecutorService methods:

1: schedule(Runnable command, long delay, TimeUnit unit)
2: scheduleAtFixedRate(Runnable command, ...)
3: scheduleWithFixedDelay(Runnable command, ...)

What's confusing is null may likewise represent a "usable" result.  While it is
possible (but klunky) to determine the usable-ness of the result with cases 2
and 3, e.g.

    [NOTE: example assumes isDone() always returns false if task is repeating]

    Object result = future.get();
    if (result == null && future.isDone() == false) {
        // no result
    }

it is not possible to with case 1.

I would ask that if Future is going to be used in this capacity then it should
also provide a method to indicate the usable-ness of the result.

__________________________________
Do you Yahoo!?
Yahoo! Hotjobs: Enter the "Signing Bonus" Sweepstakes
http://hotjobs.sweepstakes.yahoo.com/signingbonus

From tim@peierls.net  Sat Jan 17 05:20:25 2004
From: tim@peierls.net (Tim Peierls)
Date: Sat, 17 Jan 2004 00:20:25 -0500
Subject: [concurrency-interest] differentiating between result-bearing
 and non- result-bearing actions
In-Reply-To: <20040116234834.8107.qmail@web60305.mail.yahoo.com>
References: <20040116234834.8107.qmail@web60305.mail.yahoo.com>
Message-ID: <4008C619.10207@peierls.net>

Gary Moyer wrote:
> Thus Future.get() returns null when the instance is returned by any of the
> following ScheduledExecutorService methods:
> 
> 1: schedule(Runnable command, long delay, TimeUnit unit)
> 2: scheduleAtFixedRate(Runnable command, ...)
> 3: scheduleWithFixedDelay(Runnable command, ...)
> 
> What's confusing is null may likewise represent a "usable" result.  ...
> I would ask that if Future is going to be used in this capacity then it should
> also provide a method to indicate the usable-ness of the result.

Not sure I understand how you could lose track of which futures are
ScheduledFuture<?> (for which the return value of get() is irrelevant),
but if this somehow did arise in practice, you could wrap your Runnables
up front as Callable<U>, where U is only used to denote unusable values.
If you use this approach, any null returns from get() will be legitimate
null values.

     private enum Unusable { VALUE }

     public static boolean usableValue(Object o) {
         return o != Unusable.VALUE;
     }

     public static ScheduledFuture<?> schedule(
             ScheduledExecutorService service, Runnable task,
             long delay, TimeUnit unit) {

         return service.schedule(Executors.callable(task, Unusable.VALUE),
                                 delay, unit);
     }

But it would be much better to keep track of Future<?> returns from
schedule(Runnable,...) separately from Future<T> returns from
schedule(Callable<T>,...). Then you won't be tempted to interpret
the result of calling get() on a Future<?>.

--tim



From dl@cs.oswego.edu  Wed Jan 21 19:51:42 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Wed, 21 Jan 2004 14:51:42 -0500
Subject: [concurrency-interest] differentiating between result-bearing
 and non- result-bearing actions
In-Reply-To: <4008C619.10207@peierls.net>
References: <20040116234834.8107.qmail@web60305.mail.yahoo.com>
 <4008C619.10207@peierls.net>
Message-ID: <16398.55374.371275.604870@altair.cs.oswego.edu>

I just noticed that we didn't reply about an embedded question in
Gary's first mail on this: We do not support a getPeriod() or similar
method because the values can mean different things depending on
whether you are doing fixed-rate vs fixed-delay scheduling.  While it
would be possible to add interfaces and methods to untangle this, they
would complicate APIs and usage to handle the uncommon desire to
extract these values, especially given the alternative of just
remembering the values yourself before calling schedule().

-Doug



From matthias.ernst@coremedia.com  Sat Jan 24 11:09:50 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Sat, 24 Jan 2004 12:09:50 +0100
Subject: [concurrency-interest] JSR 166 locks
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF8@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C3E26A.96083EA1
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Hi,
=20
I have a few remarks about locking:
=20
* Could one say that LockSupport#park/unpark are semantically equivalent =
to Thread.currentThread().wait() / someThread.notify() ?
* I've been reading a great deal of papers around the days of EVM/early =
Hotspot about the most efficient way to implement Java monitors (thin =
locks, ...). The obvious difference, of course, is that JSR 166 does not =
allow synchronization on every Java object, i.e. the whole space/object =
header issues do not arise. Besides that, how do the two implementations =
compare ? Now that CAS and volatile/mbars are available, would you say =
that the new implementations are up to par with their "native" =
equivalents ?
* I've been using the util.concurrent package for a long time now, and =
there is one big drawback of Java-defined locking primitives: it is =
impossible to spot locking states in thread dumps. Your application =
deadlocks and you cannot see why. A parked thread has no real =
association to a lock object anymore. Do you have any plans on VM =
support for that ? The only option I see is to iterate over all lock =
objects in the heap and look at their owner -- and that doesn't give me =
the locking order. Maybe I'll give it a shot with the new JVMTI. Well, =
all the nice synchronization constructs should save me from deadlocks in =
the first place ...
* Thank you for not throwing InterruptedException from 'lock'.
=20
Best
Matthias
=20
--=20
Matthias Ernst
CoreMedia - The Content Technology Experts


------_=_NextPart_001_01C3E26A.96083EA1
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML =
DIR=3Dltr><HEAD><META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1"></HEAD><BODY>=0A=
<DIV id=3DidOWAReplyText45499 dir=3Dltr>=0A=
<DIV dir=3Dltr>=0A=
<DIV><FONT face=3D"Courier New" color=3D#000000 size=3D2>Hi,</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>I have a few remarks about =0A=
locking:</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>* Could one say that =0A=
LockSupport#park/unpark are semantically equivalent to =0A=
Thread.currentThread().wait() / someThread.notify() ?</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>* I've been reading a great =
deal of papers =0A=
around the days of EVM/early Hotspot about the most efficient way to =
implement =0A=
Java monitors (thin locks, ...). The&nbsp;obvious difference, of course, =
is that =0A=
JSR 166 does not allow synchronization on every Java object, i.e. the =
whole =0A=
space/object header&nbsp;issues do not arise. Besides that, how do the =
two =0A=
implementations compare ? Now that CAS and volatile/mbars are available, =
would =0A=
you say that the new implementations are up to par with their "native" =0A=
equivalents ?</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>* I've been using the =
util.concurrent =0A=
package for a long time now, and there is one big drawback of =
Java-defined =0A=
locking primitives: it is impossible to spot locking states in thread =
dumps. =0A=
Your application deadlocks and you cannot see why. A parked thread has =
no real =0A=
association to a lock object anymore. Do you have any plans on VM =
support for =0A=
that ? The only option I see is to iterate over all lock objects in the =
heap and =0A=
look at their owner -- and that doesn't give me the locking order. Maybe =
I'll =0A=
give it a shot with the new JVMTI. Well, all the nice synchronization =
constructs =0A=
should save me from deadlocks in the first place ...</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>* Thank you for not throwing =0A=
InterruptedException from 'lock'.</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>Best</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>Matthias</FONT></DIV>=0A=
<DIV>&nbsp;</DIV>=0A=
<DIV>-- </DIV></DIV></DIV>=0A=
<DIV id=3DidSignature7184 dir=3Dltr>=0A=
<DIV><B><FONT face=3D"Courier New" color=3Dgray size=3D2><SPAN =
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">Matthias =0A=
Ernst<BR></SPAN></FONT></B><B><FONT face=3D"Courier New" color=3Dgray =
size=3D2><SPAN =0A=
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">CoreMedia =0A=
- The Content Technology Experts<BR></SPAN></FONT></B><B><FONT =0A=
face=3D"Courier New" color=3Dgray size=3D2><SPAN lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'"></DIV></SPAN></FONT></B></DIV></BODY></HTML>
------_=_NextPart_001_01C3E26A.96083EA1--


From dl@cs.oswego.edu  Sat Jan 24 14:20:27 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 24 Jan 2004 09:20:27 -0500
Subject: [concurrency-interest] JSR 166 locks
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF8@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF8@MARS.coremedia.com>
Message-ID: <16402.32555.920896.853593@altair.cs.oswego.edu>

> * Could one say that LockSupport#park/unpark are semantically
>   equivalent to Thread.currentThread().wait() / someThread.notify() ?

No, they are pure blocking/unblocking operations, that have no
"locking" semantics. For example they do not release and reacquire
locks as Object.wait does.  You'd almost never use park/unpark alone,
but only as the underlying blocking support for other lock, condition,
monitor, synchronization classes.

As the javadocs say, park/unpark are best thought of as replacements
for the deprecated Thread.suspend/resume that eliminate the race
problem that makes suspend/resume unusable.  (Digressing: we
considered simply replacing the old suspend/resume
specs/implementations in class Thread with these new semantics, but
instead hid them away in LockSupport because the methods are
essentially never useful except within other synchronization classes.
Placing them in Thread where people might find and use them by
accident would be a terrible API design choice.)

> 
> * I've been reading a great deal of papers around the days of
>   EVM/early Hotspot about the most efficient way to implement Java
>   monitors (thin locks, ...). The obvious difference, of course, is
>   that JSR 166 does not allow synchronization on every Java object,
>   i.e. the whole space/object header issues do not arise. Besides
>   that, how do the two implementations compare ? Now that CAS and
>   volatile/mbars are available, would you say that the new
>   implementations are up to par with their "native" equivalents ?

The main design goal for new ReentrantLock and related classes was
scalability and responsiveness under contention, which are better than
what you get with native locking on most JVMs.  Performance in
uncontended cases (i.e., pure overhead) was a secondary concern, but
is still good. (Another secondary goal was tunability; for example
being able to optionally force fairness.)  Measurements I've made show
that overhead on uncontended locks varies a fair amount across
platforms and usages. In some cases on some machines they are a little
faster, in others they are a little slower, but in all cases the
differences are small enough not to be a performance issue either way.
For example, if you replace native locks with ReentrantLock or others
in an application with no lock contention, you are unlikely to see
much of a difference. (Although with hotspot, "-client" mode is more
likely to see a slowdown, which is one of several reasons to prefer
"-server" mode for concurrent programs using JSR166 stuff.)  But any
application that encounters contention is likely to improve.

And if you come up with a better locking algorithm, we give you all
the tools to implement it. As you say, just about the only thing you
cannot do that a JVM can (*) is steal bits in object headers and the
like to represent lock status. But there's no motivation for you to so
this sort of thing anyway. Most of the tech papers on Java locking are
in large part trying to deal with the issue that 99% of Java objects
are never locked, so you need a compact but expandible representation
to reduce space consumption of average objects.  But if you are making
your own classes, you know they will be used for locking, so don't
need to be so obsessed about reducing space overhead when locking is
never used.

(*) For completeness: you also cannot do anything that falls outside
the JSR133 Java Memory Model. For example, you cannot do a write with
non-volatile semantics on a volatile variable. There have been a
couple of locking algorithms that involve such things, but they are at
best non-portable. Similarly, we don't support machine-specific atomic
instructions that can't be emulated across the different platforms
Java must be able to run on.

Disclaimer: I only know about performance etc on hotspot, not other
JVMs.  Hotspot is the reference implementation, and, as far as I know,
currently the only implementation. We have standing offers to other
JVM implementors to help them find the best ways to implement JSR166
native atomic, blocking, and timing support.

> 
> * I've been using the util.concurrent package for a long time now, and
>   there is one big drawback of Java-defined locking primitives: it is
>   impossible to spot locking states in thread dumps. Your application
>   deadlocks and you cannot see why. A parked thread has no real
>   association to a lock object anymore. Do you have any plans on VM
>   support for that ? The only option I see is to iterate over all lock
>   objects in the heap and look at their owner -- and that doesn't give
>   me the locking order. Maybe I'll give it a shot with the new
>   JVMTI. Well, all the nice synchronization constructs should save me
>   from deadlocks in the first place ...


Hotspot 1.5 with JVMTI will be aware of park/unpark.  (It also shows
up in stack traces. Try for example a stack dump (control-\ on unix)
on early-access hotspot + current jsr166.jar to see what JSR166 lock
code is doing.)  There is not yet extensive support, but between JVMTI
and the instrumentation methods (like getQueuedThreads) in
ReentrantLock etc, in principle you can de even better than currently
possible in diagnosing and analyzing problems because the lock
implementations and instrumentation methods are in Java proper. It
will probably take a while before people figure out good ways to
exploit this.

-Doug


From dl@cs.oswego.edu  Sat Jan 24 15:33:07 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 24 Jan 2004 10:33:07 -0500
Subject: [concurrency-interest] When do you use wait/notify?
Message-ID: <16402.36915.671548.253989@altair.cs.oswego.edu>

Ernst's mail prompted me to also send this, which I've been meaning to
do for a while:

We'd like to know, given what is in JSR166, what kinds of cases might
still arise where application writers will use error-prone code
involving especially wait/notify rather than higher-level
constructions. If you know of some, could you tell us?  It is very
unlikely that we will be able to immediately do anything constructive
with this information, but it would still be useful to know what kinds
of cases still exist. (As in my last mail, atomics, park/unpark, and
other lower-level features in the subpackages exist for the sake of
infrastructure developers who we expect to write customized
synchronization code, but this is a very different audience.)

As discussed a few times previously, the main area we know is lacking
is support for lightweight transactions (i.e, non-persistent,
unrelated to databases), for which we feel that there are still too
many different approaches and conflicting requirments to standardize
yet into JDK.

-Doug


From matthias.ernst@coremedia.com  Sat Jan 24 17:50:23 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Sat, 24 Jan 2004 18:50:23 +0100
Subject: [concurrency-interest] SingleThreadExecutor
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF9@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C3E2A2.8A833D3E
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Hi,
=20
is there a reason why Executors#singleThreadExecutor is created with =
corePoolSize=3D1 and not =3D0 ? I use worker queues a lot that have to =
work serialized but are often idle and I prefer to not have the thread =
lying around.
=20
Matthias
=20
--
Matthias Ernst
CoreMedia - The Content Technology Experts


------_=_NextPart_001_01C3E2A2.8A833D3E
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML =
DIR=3Dltr><HEAD><META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1"></HEAD><BODY>=0A=
<DIV id=3DidOWAReplyText68754 dir=3Dltr>=0A=
<DIV dir=3Dltr>=0A=
<DIV><FONT face=3D"Courier New" color=3D#000000 size=3D2>Hi,</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>is there a reason why =0A=
Executors#singleThreadExecutor is created with corePoolSize=3D1 and not =
=3D0 ? I use =0A=
worker queues a lot that have to&nbsp;work serialized but are often idle =
and I =0A=
prefer to not have the thread lying around.</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2>Matthias</FONT></DIV>=0A=
<DIV><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV></DIV></DIV>=0A=
<DIV id=3DidSignature67604 dir=3Dltr>=0A=
<DIV><B><FONT face=3D"Courier New" color=3Dgray size=3D2><SPAN =
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">--</SPAN></FONT></B></DIV>=0A=
<DIV><B><FONT face=3D"Courier New" color=3Dgray size=3D2><SPAN =
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">Matthias =0A=
Ernst<BR></SPAN></FONT></B><B><FONT face=3D"Courier New" color=3Dgray =
size=3D2><SPAN =0A=
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">CoreMedia =0A=
- The Content Technology Experts<BR></DIV></SPAN></FONT></B><B><FONT =0A=
face=3D"Courier New" color=3Dgray size=3D2><SPAN lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'"></SPAN></FONT></B></DIV></BODY></HTML>
------_=_NextPart_001_01C3E2A2.8A833D3E--


From dl@cs.oswego.edu  Sat Jan 24 18:12:02 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sat, 24 Jan 2004 13:12:02 -0500
Subject: [concurrency-interest] SingleThreadExecutor
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF9@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDF9@MARS.coremedia.com>
Message-ID: <16402.46450.594400.180483@altair.cs.oswego.edu>

> is there a reason why Executors#singleThreadExecutor is created with
> corePoolSize=1 and not =0 ? I use worker queues a lot that have to
> work serialized but are often idle and I prefer to not have the thread
> lying around.

The thread is only created upon demand (i.e., not until first task is
submitted), but using the singleThreadExecutor factory, will never
time out, die, and be replaced if idle for long periods. If you want
to do this, you can use one of the ThreadPoolExecutor concstructors.
But for the simple case, we keep things simple; avoiding here the need
for someone to pick a keep-alive time.

-Doug


From matthias.ernst@coremedia.com  Sat Jan 24 18:41:41 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Sat, 24 Jan 2004 19:41:41 +0100
Subject: [concurrency-interest] SingleThreadExecutor
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDFB@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C3E2A9.B4F8C501
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Well, you did pick a timeout for cachedThreadPool ...=20
I would suggest accordingly:
=20
    public static ExecutorService newSingleThreadExecutor() {
        return new DelegatedExecutorService
            (new ThreadPoolExecutor(0, 1,
                                    60, TimeUnit.SECONDS,
                                    new =
LinkedBlockingQueue<Runnable>()));
    }

=20
Matthias
--=20
Matthias Ernst
CoreMedia - The Content Technology Experts


------_=_NextPart_001_01C3E2A9.B4F8C501
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">=0A=
<HTML>=0A=
<HEAD>=0A=
=0A=
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.6944.0">=0A=
<TITLE>Re: [concurrency-interest] SingleThreadExecutor</TITLE>=0A=
</HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText66279 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 size=3D2>Well, =
you did pick a =0A=
timeout for cachedThreadPool ... </FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>I would suggest =0A=
accordingly:</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>&nbsp;&nbsp;&nbsp; =
public static =0A=
ExecutorService newSingleThreadExecutor() =0A=
{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new =0A=
DelegatedExecutorService<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp; =0A=
(new ThreadPoolExecutor(0, =0A=
1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&=
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =0A=
60, =0A=
TimeUnit.SECONDS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp; =0A=
new LinkedBlockingQueue&lt;Runnable&gt;()));<BR>&nbsp;&nbsp;&nbsp; =0A=
}<BR></FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>Matthias</FONT></DIV>=0A=
<DIV dir=3Dltr><B><FONT face=3D"Courier New" color=3Dgray size=3D2><SPAN =
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">-- =0A=
</SPAN></FONT></B></DIV></DIV>=0A=
<DIV id=3DidSignature33568 dir=3Dltr>=0A=
<DIV><B><FONT face=3D"Courier New" color=3Dgray size=3D2><SPAN =
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">Matthias =0A=
Ernst<BR></SPAN></FONT></B><B><FONT face=3D"Courier New" color=3Dgray =
size=3D2><SPAN =0A=
lang=3DEN-GB =0A=
style=3D"FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: gray; FONT-FAMILY: =
'Courier New'">CoreMedia =0A=
- The Content Technology Experts<BR></SPAN></FONT></B></DIV></DIV>=0A=
=0A=
</BODY>=0A=
</HTML>
------_=_NextPart_001_01C3E2A9.B4F8C501--


From larryr@saturn.sdsu.edu  Sat Jan 24 20:31:56 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 24 Jan 2004 20:31:56 -0000
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <16402.36915.671548.253989@altair.cs.oswego.edu>
Message-ID: <20040124203156.15866.qmail@home19.riedel.org>

> We'd like to know, given what is in JSR166, what kinds of cases
> might still arise where application writers will use error-prone
> code involving especially wait/notify rather than higher-level
> constructions. [...] (As in my last mail, atomics, park/unpark,
> and other lower-level features in the subpackages exist for the
> sake of infrastructure developers who we expect to write customized
> synchronization code, but this is a very different audience.)

Since I as an "application" and "infrastructure" developer have no
appreciation for the idea that application developers should not
want/expect/plan to be directly using those nominally "lower-level"
features, or for the idea that "higher-level" constructs built on them
are inherently less error prone in general practice for application
developers, it seems to me there may be significant misapprehensions
about Java application developers, and if so I think correcting those
misapprehensions may have the most significant positive effect on design
of the JDK APIs, assuming the measure of success is that the JDK APIs
are put to use in delivering new value to people.

I think the presentation via the JDK APIs of the capabilities provided
by the nominally "lower-level" constructs should be expected to be
used equally as well directly by "application" developers as through
"higher-level" constructs formed by "infrastructure" developers.  Since
many/most(/all?) of the capabilities provided by the JSR166 APIs are
fairly fundamental, as are the capabilities provided by the Java
language facilities and the java.lang.Object and java.lang.Thread
classes, I expect all of them to continue to be regularly directly used
by application developers, and I hope the JDK APIs will have been
designed with consideration that this is normal, natural, and desirable.


Larry


From ian.griffiths@yellow-b.com  Sun Jan 25 08:15:33 2004
From: ian.griffiths@yellow-b.com (Ian Griffiths)
Date: Sun, 25 Jan 2004 09:15:33 +0100
Subject: [concurrency-interest] When do you use wait/notify?
Message-ID: <WorldClient-F200401250915.AA15330120@yellow-b.com>

I am new to this list and should like to apologize if something has 
escaped my attention.

I still use wait notify to handle a very simple Future implementation.

In my application, I have a number of objects I may be asked to provide 
and have a very low priority thread that will instantiate them all over 
time.

However many of the objects may also be produced as by-products of 
other tasks that get them from other, parallel, processes or that 
create them in response to an urgent request. thus sparing my basic 
thread the tiresome job of re-calculating them from scratch.

To do this I use a very implementation of a Future:

package jet.util.concurrency;

/**
 * A Future is an object that encapsulates a value that may 
 * only appear at a later date.
 */
public interface Future {

	/**
	 * Method getValue.
	 * @return Object the value of the Future
	 * @throws InterruptedException If the wait is interrupted
	 */
    public Object getValue() throws InterruptedException;
	/**
	 * Method isSet Says whether a value has been set.
	 * @return boolean true if a value has been set.
	 */
    public boolean isSet();
	/**
	 * Method setValue.Set the value for this future
	 * @param value The value to be set.
	 */
    public void setValue(Object value);
}

The important point is that the Future is not linked to any specific 
task, as I do not know how it will be obtained when I create the Future.

Best Regards.


From jozart@blarg.net  Sun Jan 25 08:40:48 2004
From: jozart@blarg.net (Joseph Bowbeer)
Date: Sun, 25 Jan 2004 00:40:48 -0800
Subject: [concurrency-interest] When do you use wait/notify?
References: <WorldClient-F200401250915.AA15330120@yellow-b.com>
Message-ID: <016001c3e31e$eec07460$079a7cce@REPLICANT2>

Ian,

In what ways is the proposed java.util.concurrent.Future interface
deficient?


Comparing jet Future with juc Future,

1. I see that they both have get methods.

2. jet's isSet method looks similar to juc's isDone.

3. A notable difference is that jet provides a set method in the interface,
whereas juc only provides a set method in concrete impls such as FutureTask.



----- Original Message ----- 
From: "Ian Griffiths" <ian.griffiths@yellow-b.com>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Sunday, January 25, 2004 12:15 AM
Subject: [concurrency-interest] When do you use wait/notify?


I am new to this list and should like to apologize if something has
escaped my attention.

I still use wait notify to handle a very simple Future implementation.

In my application, I have a number of objects I may be asked to provide
and have a very low priority thread that will instantiate them all over
time.

However many of the objects may also be produced as by-products of
other tasks that get them from other, parallel, processes or that
create them in response to an urgent request. thus sparing my basic
thread the tiresome job of re-calculating them from scratch.

To do this I use a very implementation of a Future:

package jet.util.concurrency;

/**
 * A Future is an object that encapsulates a value that may
 * only appear at a later date.
 */
public interface Future {

/**
* Method getValue.
* @return Object the value of the Future
* @throws InterruptedException If the wait is interrupted
*/
    public Object getValue() throws InterruptedException;
/**
* Method isSet Says whether a value has been set.
* @return boolean true if a value has been set.
*/
    public boolean isSet();
/**
* Method setValue.Set the value for this future
* @param value The value to be set.
*/
    public void setValue(Object value);
}

The important point is that the Future is not linked to any specific
task, as I do not know how it will be obtained when I create the Future.

Best Regards.



From ian.griffiths@yellow-b.com  Sun Jan 25 09:24:01 2004
From: ian.griffiths@yellow-b.com (Ian Griffiths)
Date: Sun, 25 Jan 2004 10:24:01 +0100
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <016001c3e31e$eec07460$079a7cce@REPLICANT2>
References: <WorldClient-F200401250915.AA15330120@yellow-b.com> <016001c3e31e$eec07460$079a7cce@REPLICANT2>
Message-ID: <WorldClient-F200401251024.AA24010122@yellow-b.com>

Hi Joseph,

I agree that the interfaces are very similar. In fact, the spec for 
java.util.concurrent.Future is similar. Where I feel less happy is the 
cancel method, the JavaDoc says:

Cancellation is performed by the cancel method. Additional methods are 
provided to determine if the task completed normally or was cancelled. 
Once a computation has completed, the computation cannot be cancelled. 
If you would like to use a Future for the sake of cancellability but 
not provide a usable result, you can declare types of the form Future<?
> and return null as a result of the underlying task.

This gives me the impression that the essence of the Future is the 
asynchronous task that produces the result (and can be cancelled) 
rather than the result itself.

This feeling is reinforced when looking at the constructors of 
FutureTask which REQUIRES either a Runnable or a Callable parameter. 

In my case, I have one low-priority task which will eventually create a 
number of futures (i.e. not one task per Future as some results come in 
groups at the end of a calculation or are grouped in one XML file that 
is read at some point). 

However, as the application communicates with other processes, it 
receives values that have already been calculated on other machines. 
So, rather than discard them after use, it sets the appropriate Futures 
thus provoking notification of any threads that may have been waiting 
for a reply and freeing the base task of having to calculate its value.

There is also a mechanism for threads that are in a hurry and can't 
wait long for them to produce the values in a higher-priority thread 
which obviously also sets the Future for others to use.


In my case, I am unhappy with the cancel method as the future has no 
idea which task is going to calculate its contents and most tasks 
produce more than one Future, so killing them would stop other 
(necessary) values from being calculated!

Converting the system so that there is one task per Future would be 
incredibly inefficient (and may well swamp the VM with simultaneous 
threads)

I agree that I could easily create a class that implements the 
java.util.concurrency.Future interface and has a no-parameter 
constructor (and doesn't cancel anything). However, to do that would 
involve using cals to wait() and notifyAll(). Which was the question 
Doug Lea was asking.

Best Regards

Ian


-----Original Message-----
From: "Joseph Bowbeer" <jozart@blarg.net>
To: <concurrency-interest@altair.cs.oswego.edu>
Date: Sun, 25 Jan 2004 00:40:48 -0800
Subject: Re: [concurrency-interest] When do you use wait/notify?

> Ian,
> 
> In what ways is the proposed java.util.concurrent.Future interface
> deficient?
> 
> 
> Comparing jet Future with juc Future,
> 
> 1. I see that they both have get methods.
> 
> 2. jet's isSet method looks similar to juc's isDone.
> 
> 3. A notable difference is that jet provides a set method in the
> interface,
> whereas juc only provides a set method in concrete impls such as
> FutureTask.
> 
> 
> 
> ----- Original Message ----- 
> From: "Ian Griffiths" <ian.griffiths@yellow-b.com>
> To: <concurrency-interest@altair.cs.oswego.edu>
> Sent: Sunday, January 25, 2004 12:15 AM
> Subject: [concurrency-interest] When do you use wait/notify?
> 
> 
> I am new to this list and should like to apologize if something has
> escaped my attention.
> 
> I still use wait notify to handle a very simple Future
> implementation.
> 
> In my application, I have a number of objects I may be asked to
> provide
> and have a very low priority thread that will instantiate them all
> over
> time.
> 
> However many of the objects may also be produced as by-products of
> other tasks that get them from other, parallel, processes or that
> create them in response to an urgent request. thus sparing my basic
> thread the tiresome job of re-calculating them from scratch.
> 
> To do this I use a very implementation of a Future:
> 
> package jet.util.concurrency;
> 
> /**
>  * A Future is an object that encapsulates a value that may
>  * only appear at a later date.
>  */
> public interface Future {
> 
> /**
> * Method getValue.
> * @return Object the value of the Future
> * @throws InterruptedException If the wait is interrupted
> */
>     public Object getValue() throws InterruptedException;
> /**
> * Method isSet Says whether a value has been set.
> * @return boolean true if a value has been set.
> */
>     public boolean isSet();
> /**
> * Method setValue.Set the value for this future
> * @param value The value to be set.
> */
>     public void setValue(Object value);
> }
> 
> The important point is that the Future is not linked to any specific
> task, as I do not know how it will be obtained when I create the
> Future.
> 
> Best Regards.
> 
> 
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From dl@cs.oswego.edu  Sun Jan 25 14:05:14 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 25 Jan 2004 09:05:14 -0500
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <WorldClient-F200401251024.AA24010122@yellow-b.com>
References: <WorldClient-F200401250915.AA15330120@yellow-b.com>
 <016001c3e31e$eec07460$079a7cce@REPLICANT2>
 <WorldClient-F200401251024.AA24010122@yellow-b.com>
Message-ID: <16403.52506.461609.241877@altair.cs.oswego.edu>

> In my case, I am unhappy with the cancel method as the future has no 
> idea which task is going to calculate its contents and most tasks 
> produce more than one Future, so killing them would stop other 
> (necessary) values from being calculated!

(We in the expert group considered this issue several times: Some
applications cannot live without cancellability, and some cannot live
with it. But it wouldn't work out at all well to define parallel APIs
differing only with respect to this. The compromise was to allow the
cancel method to return false if it cannot, or just doesn't want to
cancel the task. So, "return false" is a valid implementation.)

> I agree that I could easily create a class that implements the 
> java.util.concurrency.Future interface and has a no-parameter 
> constructor (and doesn't cancel anything). However, to do that would 
> involve using cals to wait() and notifyAll(). 

Right. That's a great example; thanks!  While we set up interfaces to
allow such variants in concrete Future classes, we don't, and can't,
provide all of the support that you might need to build all possible
custom implementations.


-Doug

From dl@cs.oswego.edu  Sun Jan 25 14:17:40 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Sun, 25 Jan 2004 09:17:40 -0500
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <20040124203156.15866.qmail@home19.riedel.org>
References: <16402.36915.671548.253989@altair.cs.oswego.edu>
 <20040124203156.15866.qmail@home19.riedel.org>
Message-ID: <16403.53252.361915.753027@altair.cs.oswego.edu>

>  it seems to me there may be significant misapprehensions
> about Java application developers, and if so I think correcting those
> misapprehensions may have the most significant positive effect on design
> of the JDK APIs, 

Sorry that this came across in the wrong way!  I used "application
developers" as a shorthand for "people who will use the supplied
implementations" and "infrastructure developers" for "people who will
reimplement existing interfaces or create new ones". I probably should
have used different terminology.

-Doug


From ian.griffiths@yellow-b.com  Sun Jan 25 14:39:23 2004
From: ian.griffiths@yellow-b.com (Ian Griffiths)
Date: Sun, 25 Jan 2004 15:39:23 +0100
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <16403.52506.461609.241877@altair.cs.oswego.edu>
References: <WorldClient-F200401250915.AA15330120@yellow-b.com> <016001c3e31e$eec07460$079a7cce@REPLICANT2> <WorldClient-F200401251024.AA24010122@yellow-b.com> <16403.52506.461609.241877@altair.cs.oswego.edu>
Message-ID: <WorldClient-F200401251539.AA39230126@yellow-b.com>

Hi Doug,

Thanks for your reply. I was worried I had missed something important 
there and didn't know where to find it!

I feel that it would be usefull in a future (forgive the pun) version 
of the package to have a class that just contains a Future object (say 
BasicFuture) that is not associated to a task but that could be 
extended in a meaningfull way by developers. That would hide the nitty-
gritty of wait()s and notify()s and would allow you to do the fine 
tuning as the JDK develops (although in this case, there doesn't seem 
to be much to tune!).

Best Regards

Ian

-----Original Message-----
From: Doug Lea <dl@cs.oswego.edu>
To: "Ian Griffiths" <ian.griffiths@yellow-b.com>
Cc: concurrency-interest@altair.cs.oswego.edu
Date: Sun, 25 Jan 2004 09:05:14 -0500
Subject: Re: [concurrency-interest] When do you use wait/notify?

> > In my case, I am unhappy with the cancel method as the future has
> no 
> > idea which task is going to calculate its contents and most tasks 
> > produce more than one Future, so killing them would stop other 
> > (necessary) values from being calculated!
> 
> (We in the expert group considered this issue several times: Some
> applications cannot live without cancellability, and some cannot live
> with it. But it wouldn't work out at all well to define parallel APIs
> differing only with respect to this. The compromise was to allow the
> cancel method to return false if it cannot, or just doesn't want to
> cancel the task. So, "return false" is a valid implementation.)
> 
> > I agree that I could easily create a class that implements the 
> > java.util.concurrency.Future interface and has a no-parameter 
> > constructor (and doesn't cancel anything). However, to do that
> would 
> > involve using cals to wait() and notifyAll(). 
> 
> Right. That's a great example; thanks!  While we set up interfaces to
> allow such variants in concrete Future classes, we don't, and can't,
> provide all of the support that you might need to build all possible
> custom implementations.
> 
> 
> -Doug
> _______________________________________________
> Concurrency-interest mailing list
> Concurrency-interest@altair.cs.oswego.edu
> http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest


From larryr@saturn.sdsu.edu  Sun Jan 25 20:39:30 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 25 Jan 2004 20:39:30 -0000
Subject: [concurrency-interest] Re: When do you use wait/notify?
In-Reply-To: <16403.53252.361915.753027@altair.cs.oswego.edu>
Message-ID: <20040125203930.30844.qmail@home19.riedel.org>

> > it seems to me there may be significant misapprehensions about
> > Java application developers, and if so I think correcting those
> > misapprehensions may have the most significant positive effect
> > on design of the JDK APIs,
> 
> Sorry that this came across in the wrong way!  I used "application
> developers" as a shorthand for "people who will use the supplied
> implementations" and "infrastructure developers" for "people who will
> reimplement existing interfaces or create new ones". I probably should
> have used different terminology.

Assuming it is considered natural and proper for application developers
to be directly using all the JSR166 type operations as well as those in
java.lang.Thread and java.lang.Object, and of course the built-in Java
stuff like "synchronized", I think it would be great if the wait/notify
JavaDoc illustrated implementing wait/notify (et al) using the JSR166
APIs, calling attention to the idiosyncratic semantics of wait/notify,
such as that notify() requires the thread hold the lock of the object,
and wait() does not release the other locks held by the thread.  And
says in some euphemistic way that no sane person would have come up
with such perverse semantics, but now there are clean alternatives.


Larry


From dl@cs.oswego.edu  Mon Jan 26 12:28:04 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 26 Jan 2004 07:28:04 -0500
Subject: [concurrency-interest] beta2 review
Message-ID: <16405.2004.738585.132431@altair.cs.oswego.edu>

JSR166 is currently undergoing Tiger engineering process review for
incorporating all changes since November to be part of 1.5-beta2.
(Yes, this happens even before beta1 is officially out.) We also
invite you to play this QA game! If you come across typos, bad
wordings, or other problems. please let us know soon.  Also, any
reports of functionality problems would be very welcome, as would be
new test cases.

The ground rules here are no feature requests, and no API changes.
Just problems/errors/fixes.  

As usual, you can run the current versions of JSR166 APIs using even
the pre-beta1 early-access releases by following the instructions at
http://gee.cs.oswego.edu/dl/concurrency-interest/index.html (Although
the early-access release had a couple of unrelated bugs that seem to
show up most often running JSR166 code, so it may be hard to figure
out whether there is a problem we can address.)

-Doug


From dl@cs.oswego.edu  Mon Jan 26 13:17:14 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 26 Jan 2004 08:17:14 -0500
Subject: [concurrency-interest] SingleThreadExecutor
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDFB@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDDFB@MARS.coremedia.com>
Message-ID: <16405.4954.629132.485406@altair.cs.oswego.edu>

> Well, you did pick a timeout for cachedThreadPool ... 

Still, singleThreadExecutor should have as simply-described a set of
properties as possible. And in practice, it will hardly matter.
Keep-alive timeouts become important only when you have peak
thread demands that are much higher than average demands, which is an
issue that arises with pools (especially of the sort you get with
newCachedThreadPool settings), not single threaded executors.  It
would be very unusual, although possible, to encounter this kind of
problem by creating huge numbers of singleThreadExecutors. And even if
people do this, and find there is a problem, they can use the manual
constructor to control keep-alive settings as needed.  More likely,
they would decide to replace all these single-threaded executors
with a single pool.

All in all, it's a marginal preference issue, but one where I think it
is just barely preferable is to keep it as it is.

-Doug

From gregg.wonderly@pobox.com  Mon Jan 26 15:12:42 2004
From: gregg.wonderly@pobox.com (Gregg Wonderly)
Date: Mon, 26 Jan 2004 09:12:42 -0600
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <16402.36915.671548.253989@altair.cs.oswego.edu>
References: <16402.36915.671548.253989@altair.cs.oswego.edu>
Message-ID: <40152E6A.9030600@cox.net>


Doug Lea wrote:

> Ernst's mail prompted me to also send this, which I've been meaning to
> do for a while:
> 
> We'd like to know, given what is in JSR166, what kinds of cases might
> still arise where application writers will use error-prone code
> involving especially wait/notify rather than higher-level
> constructions.

I have many applications that utilize queues and worker threads.
I will use wait() and notify() to tell the workers that the containers
have stuff to do in them.  As part of my attempts to avoid synchronizing 
everywhere, I will typically have the worker threads call wait(timeout)
so that they can inspect the state of the world occasionally without 
notify having to be called.  This keeps missing notifies from causing 
the system to misbehave. It also allows work to be handled in bursts 
based on timeouts that I can change at runtime to tune the system's 
performance.  Finally, it allows debugging messages to be provided that 
tell me that those worker threads are still active.  And, when notify is 
used by the thread adding the work item, the workers can respond 
immediately if they are idle.

I typically do not use outward visible or container references in my 
wait() and notify() calls related to work notification.  This is done to 
keep circular references from getting in the way.  But, primarily, I try 
to design the synchronization so that it is minimized.  I do tend to use 
Vector and Hashtable for my containers so that I get atomic access to 
the mutation of the container without having to explicitly assert the 
synchonization which can be a source of bugs in and of itself.

My most heavily threaded applications do around 30 transactions a second 
with around 60 threads running simultaneously.  I've tuned these 
applications over the years by using SIGQUIT on unix to force a thread 
dump.  I then look at what synchronization is most visible.  I go back 
and revisit those areas of the code and try to establish whether the 
synchronization is necessary, or if the amount of work in the 
synchronized section can be minimized.

This is an indispensible feature that I understand will be 
programatically accessible in 1.5.

Gregg


From larryr@saturn.sdsu.edu  Mon Jan 26 16:04:48 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 26 Jan 2004 16:04:48 -0000
Subject: [concurrency-interest] Re: When do you use wait/notify?
In-Reply-To: <40152E6A.9030600@cox.net>
Message-ID: <20040126160448.2061.qmail@home19.riedel.org>

> [...] I've tuned these applications over the years by using SIGQUIT on
> unix to force a thread dump.  I then look at what synchronization is
> most visible.  I go back and revisit those areas of the code and try to
> establish whether the synchronization is necessary, or if the amount of
> work in the synchronized section can be minimized.
> 
> This is an indispensible feature that I understand will be programatically
> accessible in 1.5.

Seeing which threads have which locks?  I imagine the JPDA/JDI/JVMDI
will continue to have the capability to do the equivalent.  And maybe
the profiling thing, JSR-163?


Larry


From news@kav.dk  Mon Jan 26 20:30:06 2004
From: news@kav.dk (Kasper Nielsen)
Date: Mon, 26 Jan 2004 21:30:06 +0100
Subject: [concurrency-interest] Thread.getId()
Message-ID: <401578CE.5030106@kav.dk>

Hi,

After having read the javadoc for Thread.getId()
--------------------------
public long getId()

Returns the identifier of this Thread. The thread ID is a positive long 
number generated when this thread was created. The thread ID is unique 
and remains unchanged during its lifetime. When a thread is terminated, 
this thread ID may be reused.
--------------------------
I think it should be prohibited for the jvm to reuse a thread id, I 
simply can't see any reason why it should be allowed. If people are 
using the id in anyway across of thread initialization/termination it 
could potentially lead to confusion and/or errors.

- Kasper



From olivier.dupuy@hrdc-drhc.gc.ca  Mon Jan 26 20:49:06 2004
From: olivier.dupuy@hrdc-drhc.gc.ca (olivier.dupuy@hrdc-drhc.gc.ca)
Date: Mon, 26 Jan 2004 15:49:06 -0500
Subject: [concurrency-interest] Converting the AtomicXXXArray inner elements to an array
Message-ID: <0691D2A40A12164D88BC675BC8C4815C4CED33@NCEV02.hrdc-drhc.net>

Hello,

I was reviewing this week end the J.U.C. API for the good use I could do of it in a an existing commercial program.

It happens that this C/S program is multi threaded. Each thread collects statistics but the stats are kept together and as a consequence are protected against concurrent access using synchronization. I increment many counters based on the use of the API functions called by the clients and based on their parameters. Most of the threads update the statistics but on a regular basis they are extracted. AtomicInterger/LongArray would be a great fit for this job instead of the existing code.

This is my use case.

We have recently added contructors to the AtomicXXXArray classes for both convenience and speed. At this time, if you want to take a snapshot (>> understand a copy<<) of the AtomicXXXArray inner values for any purpose, you have no other choice than to get every element individually. This is OK but is it efficient (or elegant) ? Specially if you do it often, accessing to the array 'elements' through a method is more CPU intensive than doing a regular array access.

As in many other J.U.C. classes, a 'toArray' method returning an array of int/long would do the trick and would be quick to write even if I understand that in 1.5, custom code doing the copy can be more compact than before. I also understand that this conversion to an array is not "atomic".  However I tend to prefer JDK APIs to be complete when possible and having a method returning an array/Collection of its internal elements is quite standard through the JDK.

I don't see an immediate use for the same toArray method in the AtomicReferenceArray but someone can have one so I would suggest to add it too.

Olivier


From matthias.ernst@coremedia.com  Mon Jan 26 21:14:01 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Mon, 26 Jan 2004 22:14:01 +0100
Subject: [concurrency-interest] Re: When do you use wait/notify?
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDE01@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C3E451.523C9930
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Larry:
> Seeing which threads have which locks?  I imagine the JPDA/JDI/JVMDI
> will continue to have the capability to do the equivalent.  And maybe
> the profiling thing, JSR-163?

 =20
Actually that's what I tried to ask in one of my last emails. If I judge =
correctly there is no direct connection from a thread to a lock object; =
actually cannot be, since the lock is entirely an application-level =
concept. Threads only know of being parked and unparked.=20
=20
=20
A thread dump looks as follows:
=20
"Thread-1" prio=3D5 tid=3D0x00943468 nid=3D0xd10 waiting on condition =
[0x0154f000..0x0
154fa98]
        at java.lang.Thread.sleep(Native Method)
        at LockTest.doit(LockTest.java:13)
        at LockTest$2.run(LockTest.java:35)
=20
"Thread-0" prio=3D5 tid=3D0x00936068 nid=3D0xaf0 runnable =
[0x0144f000..0x0144fb18]
        at sun.misc.Unsafe.park(Native Method)
        at =
java.util.concurrent.locks.LockSupport.park(LockSupport.java:118)
        at =
java.util.concurrent.locks.ReentrantLock.waitForLock(ReentrantLock.java:4=
84)
        at =
java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:600)
        at LockTest.doit(LockTest.java:11)
        at LockTest$1.run(LockTest.java:24)
=20
Maybe #park could take an arbitrary argument that denotes the reason for =
being parked --- which would be accessible from JVMTI and maybe visible =
in a thread dump. In case of a lock, e.g., a thread dump could then =
display the lock's oid, owner and wait queue.
=20
=20
=20
BTW, I'm not able to run the current JSR 166 jar:
=20
C:\Documents and Settings\Matthias\j2se 1.5>\j2sdk1.5.0\bin\java =
-Xbootclasspath
/p:\tmp\jsr166.jar -classpath out LockTest
Error occurred during initialization of VM
java.lang.NoClassDefFoundError: sun/misc/JavaLangAccess
=20
Matthias
=20

------_=_NextPart_001_01C3E451.523C9930
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">=0A=
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">=0A=
<HTML>=0A=
<HEAD>=0A=
=0A=
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.6944.0">=0A=
<TITLE>[concurrency-interest] Re: When do you use wait/notify?</TITLE>=0A=
</HEAD>=0A=
<BODY>=0A=
<DIV id=3DidOWAReplyText24097 dir=3Dltr>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 size=3D2>=0A=
<DIV dir=3Dltr>Larry:</DIV>=0A=
<DIV dir=3Dltr>&gt; Seeing which threads have which locks?&nbsp; I =
imagine the =0A=
JPDA/JDI/JVMDI<BR>&gt; will continue to have the capability to do the =0A=
equivalent.&nbsp; And maybe<BR>&gt; the profiling thing, =
JSR-163?<BR></DIV>=0A=
<DIV dir=3Dltr>&nbsp;=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" color=3D#000000 =
size=3D2>Actually that's what =0A=
I tried to ask in one of my last emails. If I judge correctly there is =
no direct =0A=
connection from a thread to a lock object; actually cannot be, since the =
lock is =0A=
entirely an application-level concept. Threads only know of being parked =
and =0A=
unparked. </FONT></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>A thread dump looks as follows:</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>"Thread-1" prio=3D5 tid=3D0x00943468 nid=3D0xd10 waiting =
on condition =0A=
[0x0154f000..0x0<BR>154fa98]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
; at =0A=
java.lang.Thread.sleep(Native =0A=
Method)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at =0A=
LockTest.doit(LockTest.java:13)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp; at =0A=
LockTest$2.run(LockTest.java:35)</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>"Thread-0" prio=3D5 tid=3D0x00936068 nid=3D0xaf0 runnable =0A=
[0x0144f000..0x0144fb18]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
at =0A=
sun.misc.Unsafe.park(Native =0A=
Method)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at =0A=
java.util.concurrent.locks.LockSupport.park(LockSupport.java:118)<BR>&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =0A=
at =0A=
java.util.concurrent.locks.ReentrantLock.waitForLock(ReentrantLock.java:4=
84)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =0A=
at =
java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:600)</DI=
V>=0A=
<DIV dir=3Dltr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at =0A=
LockTest.doit(LockTest.java:11)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp; at =0A=
LockTest$1.run(LockTest.java:24)</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>Maybe #park could =
take an arbitrary =0A=
argument that denotes the reason for being parked --- which would be =
accessible =0A=
from JVMTI and maybe visible in a thread dump. In case of a lock, e.g., =
a thread =0A=
dump could then display the lock's oid, owner and wait =
queue.</FONT></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr>BTW, I'm not able to run the current JSR 166 =0A=
jar:</DIV></FONT></DIV></DIV>=0A=
<DIV dir=3Dltr>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>C:\Documents and =0A=
Settings\Matthias\j2se 1.5&gt;\j2sdk1.5.0\bin\java =0A=
-Xbootclasspath<BR>/p:\tmp\jsr166.jar -classpath out LockTest<BR>Error =
occurred =0A=
during initialization of VM<BR>java.lang.NoClassDefFoundError: =0A=
sun/misc/JavaLangAccess</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2></FONT>&nbsp;</DIV>=0A=
<DIV dir=3Dltr><FONT face=3D"Courier New" size=3D2>Matthias</FONT></DIV>=0A=
<DIV dir=3Dltr><FONT size=3D3></FONT>&nbsp;</DIV>=0A=
=0A=
</BODY>=0A=
</HTML>
------_=_NextPart_001_01C3E451.523C9930--


From jerome@coffeebreaks.org  Mon Jan 26 21:26:55 2004
From: jerome@coffeebreaks.org (Jerome Lacoste)
Date: Mon, 26 Jan 2004 22:26:55 +0100
Subject: [concurrency-interest] Thread.getId()
In-Reply-To: <401578CE.5030106@kav.dk>
References: <401578CE.5030106@kav.dk>
Message-ID: <1075152415.1168.88.camel@dolcevita.localnet>

On Mon, 2004-01-26 at 21:30, Kasper Nielsen wrote:
> Hi,
> 
> After having read the javadoc for Thread.getId()
> --------------------------
> public long getId()
> 
> Returns the identifier of this Thread. The thread ID is a positive long 
> number generated when this thread was created. The thread ID is unique 
> and remains unchanged during its lifetime. When a thread is terminated, 
> this thread ID may be reused.
> --------------------------
> I think it should be prohibited for the jvm to reuse a thread id, I 
> simply can't see any reason why it should be allowed. If people are 
> using the id in anyway across of thread initialization/termination it 
> could potentially lead to confusion and/or errors.

This clause seems to exist in order to handle the potential theoretical exhaustion of IDs. 
Otherwise one would have to specify error handling and force the implementations to be more complex than they need to be, especially for problems that will never be reached in real life.
As a consequence this less strict specification is a price to pay in order to make the API clean, and clients should find a different way to refer to the threads than by uniquely using their ids.

Correct me if I am wrong...

Jerome


From dholmes@dltech.com.au  Mon Jan 26 23:48:50 2004
From: dholmes@dltech.com.au (David Holmes)
Date: Tue, 27 Jan 2004 09:48:50 +1000
Subject: [concurrency-interest] When do you use wait/notify?
In-Reply-To: <40152E6A.9030600@cox.net>
Message-ID: <NFBBKALFDCPFIDBNKAPCOELDDMAA.dholmes@dltech.com.au>

Gregg Wonderly wrote:
> I have many applications that utilize queues and worker threads.
> I will use wait() and notify() to tell the workers that the 
> containers have stuff to do in them.

Will Executors not replace direct use of threads and work queues?

> I do tend to use Vector and Hashtable for my containers 

Will the new concurrent collections not suit your needs?

David Holmes

From dl@cs.oswego.edu  Tue Jan 27 01:07:36 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 26 Jan 2004 20:07:36 -0500
Subject: [concurrency-interest] Re: When do you use wait/notify?
In-Reply-To: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDE01@MARS.coremedia.com>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDE01@MARS.coremedia.com>
Message-ID: <16405.47576.926224.563883@altair.cs.oswego.edu>

> Actually that's what I tried to ask in one of my last emails.
> If I judge correctly there is no direct connection from a thread to
> a lock object

Sorry to misunderstand what you were asking.
Here's a sketch of one way to build lock tools:

1. Use the new Thread.getAllStackTraces() method
2. Run through traces, looking for ReentrantLock.lock calls
3. Print the locks (the ReentrantLock.toString() shows status.)
   Or use the instrumentation methods to create a waits-for graph 
   to find deadlocks. Or whatever.

Warning: I haven't done this, and don't even know if getAllStackTraces
is fully functional yet, but the intent is to make such tools
possible. (Also, I'm not sure offhand how to get from step 2 to 3
given what StackTraceElement provides.)

> BTW, I'm not able to run the current JSR 166 jar:

Ugh. Sorry. This means that the internal builds I must use to prepare
for beta2 are now incompatible with early-access build.  I should be
able to create a usable jar from some previous build, which I won't be
able to get to for a day or two. I'll post when I do.

-Doug


From larryr@saturn.sdsu.edu  Tue Jan 27 01:15:00 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 27 Jan 2004 01:15:00 -0000
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <1075152415.1168.88.camel@dolcevita.localnet>
Message-ID: <20040127011500.3886.qmail@home19.riedel.org>

> > > public long getId()
> > > I think it should be prohibited for the jvm to reuse a thread id, I 
> > > simply can't see any reason why it should be allowed.
> 
> This clause seems to exist in order to handle the potential theoretical
> exhaustion of IDs.

If the ID was incremented every nanosecond, would it wrap
around in less than 100 years?  It seems pretty crazy
to me as well, especially since it would be trivial to
implement using AtomicLong.getAndAdd(). :-)  Maybe there
was a predecessor that returned an int?


Larry


From brian@quiotix.com  Tue Jan 27 01:32:15 2004
From: brian@quiotix.com (Brian Goetz)
Date: Mon, 26 Jan 2004 17:32:15 -0800
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <20040127011500.3886.qmail@home19.riedel.org>
References: <1075152415.1168.88.camel@dolcevita.localnet>
Message-ID: <5.1.0.14.2.20040126172833.03b0e630@pop.quiotix.com>

> > > > public long getId()
> > > > I think it should be prohibited for the jvm to reuse a thread id, I
> > > > simply can't see any reason why it should be allowed.
> >
> > This clause seems to exist in order to handle the potential theoretical
> > exhaustion of IDs.
>
>If the ID was incremented every nanosecond, would it wrap
>around in less than 100 years?  It seems pretty crazy
>to me as well, especially since it would be trivial to
>implement using AtomicLong.getAndAdd(). :-)  Maybe there
>was a predecessor that returned an int?

This seems a sensible theory.  An int could easily wrap around in the 
lifetime of a long-running program (on the order of a month at 1000 
threads/second) but a long would take a loooooong time to wrap -- we will 
probably be using 256-bit processors long before then.



--
Brian Goetz
Quiotix Corporation
brian@quiotix.com           Tel: 650-843-1300            Fax: 650-324-8032

http://www.quiotix.com



From dl@cs.oswego.edu  Tue Jan 27 01:47:31 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Mon, 26 Jan 2004 20:47:31 -0500
Subject: [concurrency-interest] Converting the AtomicXXXArray inner elements to an array
In-Reply-To: <0691D2A40A12164D88BC675BC8C4815C4CED33@NCEV02.hrdc-drhc.net>
References: <0691D2A40A12164D88BC675BC8C4815C4CED33@NCEV02.hrdc-drhc.net>
Message-ID: <16405.49971.213777.769858@altair.cs.oswego.edu>

> We have recently added contructors to the AtomicXXXArray classes for
> both convenience and speed. At this time, if you want to take a
> snapshot (>> understand a copy<<) of the AtomicXXXArray inner values
> for any purpose, you have no other choice than to get every element
> individually. This is OK but is it efficient (or elegant) ? Specially
> if you do it often, accessing to the array 'elements' through a method
> is more CPU intensive than doing a regular array access.

I don't believe there is any advantage to doing this internally,
because the retrievals still have to obey volatile access semantics.
And JVMs are pretty good at eliminating the call overhead.
(Initialization was a different story, because there is an internal
barrier optimization that can be applied there, but nowhere else.)

There is still the argument of convenience though. My hesitation about
this the first time it was raised is that it is too easy to think that
a toArray method maintains atomicity (i.e., provides a snapshot of one
instant of time) when it cannot. And to mistakenly rely on this even
if you know it cannot.  Speaking for myself, I'd rather be reminded
about this by being forced to write a loop to avoid this sort of
subtle thinking error.  People who are less prone to making this kind
of mistake can always make a subclass with toArray.

-Doug


From matthias.ernst@coremedia.com  Tue Jan 27 07:42:10 2004
From: matthias.ernst@coremedia.com (Ernst, Matthias)
Date: Tue, 27 Jan 2004 08:42:10 +0100
Subject: [concurrency-interest] Re: When do you use wait/notify?
Message-ID: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDE02@MARS.coremedia.com>

This is a multi-part message in MIME format.

------_=_NextPart_001_01C3E4A9.120F4AD4
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

> Warning: I haven't done this, and don't even know if getAllStackTraces
> is fully functional yet, but the intent is to make such tools
> possible. (Also, I'm not sure offhand how to get from step 2 to 3
> given what StackTraceElement provides.)

Ok, thanks for the yet missing piece. I was exactly wondering how to =
navigate from a StackTraceElement to the Lock object. Currently =
StackTraceElements only give me the method object but not the value of =
'this'. So that is not possible right now, but it's wonderful that that =
information will be available in the future !

> Ugh. Sorry. This means that the internal builds I must use to prepare
> for beta2 are now incompatible with early-access build.  I should be
> able to create a usable jar from some previous build, which I won't be
> able to get to for a day or two. I'll post when I do.

No hurry.=20

Thanks
Matthias


------_=_NextPart_001_01C3E4A9.120F4AD4
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3Diso-8859-1">
<META NAME=3D"Generator" CONTENT=3D"MS Exchange Server version =
6.5.6944.0">
<TITLE>RE: [concurrency-interest] Re: When do you use =
wait/notify?</TITLE>
</HEAD>
<BODY>
<!-- Converted from text/plain format -->

<P><FONT SIZE=3D2>&gt; Warning: I haven't done this, and don't even know =
if getAllStackTraces<BR>
&gt; is fully functional yet, but the intent is to make such tools<BR>
&gt; possible. (Also, I'm not sure offhand how to get from step 2 to =
3<BR>
&gt; given what StackTraceElement provides.)<BR>
<BR>
Ok, thanks for the yet missing piece. I was exactly wondering how to =
navigate from a StackTraceElement to the Lock object. Currently =
StackTraceElements only give me the method object but not the value of =
'this'. So that is not possible right now, but it's wonderful that that =
information will be available in the future !<BR>
<BR>
&gt; Ugh. Sorry. This means that the internal builds I must use to =
prepare<BR>
&gt; for beta2 are now incompatible with early-access build.&nbsp; I =
should be<BR>
&gt; able to create a usable jar from some previous build, which I won't =
be<BR>
&gt; able to get to for a day or two. I'll post when I do.<BR>
<BR>
No hurry.<BR>
<BR>
Thanks<BR>
Matthias<BR>
</FONT>
</P>

</BODY>
</HTML>
------_=_NextPart_001_01C3E4A9.120F4AD4--


From dl@cs.oswego.edu  Tue Jan 27 12:38:02 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 27 Jan 2004 07:38:02 -0500
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <5.1.0.14.2.20040126172833.03b0e630@pop.quiotix.com>
References: <1075152415.1168.88.camel@dolcevita.localnet>
 <5.1.0.14.2.20040126172833.03b0e630@pop.quiotix.com>
Message-ID: <16406.23466.776576.543391@altair.cs.oswego.edu>

Even though all of the Thread API is in our docs, we (JSR166) didn't
have anything to do with getID(), which was put in as part of
management, monitoring, and profiling APIs (mainly JSR163 and JSR174).

I believe the spec is written conservatively to enable conforming
implmentations when Isolates (JSR121) finally become available. Each
Isolate will need a part of the ID range, and those ranges will need
to be reusable.

-Doug


From dl@cs.oswego.edu  Tue Jan 27 12:54:31 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Tue, 27 Jan 2004 07:54:31 -0500
Subject: [concurrency-interest] Re: When do you use wait/notify?
In-Reply-To: <16405.47576.926224.563883@altair.cs.oswego.edu>
References: <F34C8A704C489B46B9E9FBDBD1B91D5F0DDE01@MARS.coremedia.com>
 <16405.47576.926224.563883@altair.cs.oswego.edu>
Message-ID: <16406.24455.313115.646399@altair.cs.oswego.edu>


> > BTW, I'm not able to run the current JSR 166 jar:
> 
> Ugh. Sorry. This means that the internal builds I must use to prepare
> for beta2 are now incompatible with early-access build.  I should be
> able to create a usable jar from some previous build, which I won't be
> able to get to for a day or two. I'll post when I do.

Thanks to Ernst's help checking, the jsr166.jar at
  http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
now has a couple of added (but non-JSR166-related) classes in it that
appear to make it function OK again with the early-access release.

-Doug


From leou@us.ibm.com  Tue Jan 27 13:32:18 2004
From: leou@us.ibm.com (Leo Uzcategui)
Date: Tue, 27 Jan 2004 06:32:18 -0700
Subject: [concurrency-interest] Leo Uzcategui/Austin/IBM is out of the office.
Message-ID: <OF4129454A.FA09B62F-ON87256E28.004A5E50-87256E28.004A5E51@us.ibm.com>

--0__=08BBE4BBDFD9D8C08f9e8a93df938690918c08BBE4BBDFD9D8C0
Content-type: text/plain; charset=US-ASCII





I will be out of the office starting January 26, 2004 and will not return
until February 2, 2004.

For assistance, please contact Robin Redden at (512) 838-1542.
--0__=08BBE4BBDFD9D8C08f9e8a93df938690918c08BBE4BBDFD9D8C0
Content-type: text/html; charset=US-ASCII
Content-Disposition: inline

<html><body>
<p>I will be out of the office starting January 26, 2004 and will not return until February 2, 2004.<br>
<br>
For assistance, please contact Robin Redden at (512) 838-1542.<br>
</body></html>
--0__=08BBE4BBDFD9D8C08f9e8a93df938690918c08BBE4BBDFD9D8C0--


From larryr@saturn.sdsu.edu  Tue Jan 27 18:19:16 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 27 Jan 2004 18:19:16 -0000
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <16406.23466.776576.543391@altair.cs.oswego.edu>
Message-ID: <20040127181916.7307.qmail@home19.riedel.org>

> Even though all of the Thread API is in our docs, we (JSR166) didn't
> have anything to do with getID(), which was put in as part of
> management, monitoring, and profiling APIs (mainly JSR163 and JSR174).
> 
> I believe the spec is written conservatively to enable conforming
> implmentations when Isolates (JSR121) finally become available. Each
> Isolate will need a part of the ID range, and those ranges will need
> to be reusable.

It seems a shame to me that an API operation so significant
in the context of concurrency, and so fundamentally related
to concurrency, would be considered out of scope for an
active working group chartered specifically with concurrency
related APIs.

For me to be able to trivially and almost instantaneously
determine whether or not the thread executing my code already
executed the same (and/or some other) code before seems like a
capability which could be pretty valuable to me.  Is there a
different way to (nearly) as trivially and efficiently retrieve
from a thread a value I can uniquely and efficiently associate
in the same way with that thread for the lifespan of the [JVM],
regardless of the lifespan of the thread?


Larry


From blanshlu@netscape.net  Tue Jan 27 18:59:06 2004
From: blanshlu@netscape.net (Luke Blanshard)
Date: Tue, 27 Jan 2004 13:59:06 -0500
Subject: [concurrency-interest] Re: Thread.getId()
Message-ID: <3F3B86A7.490DC905.00948489@netscape.net>

Larry Riedel <larryr@saturn.sdsu.edu> wrote:

>... Is there a
>different way to (nearly) as trivially and efficiently retrieve
>from a thread a value I can uniquely and efficiently associate
>in the same way with that thread for the lifespan of the [JVM],
>regardless of the lifespan of the thread?

You mean, aside from the Thread object itself?

__________________________________________________________________
New! Unlimited Netscape Internet Service.
Only $9.95 a month -- Sign up today at http://isp.netscape.com/register
Act now to get a personalized email address!

Netscape. Just the Net You Need.

From pugh@cs.umd.edu  Tue Jan 27 19:24:46 2004
From: pugh@cs.umd.edu (Bill Pugh)
Date: Tue, 27 Jan 2004 14:24:46 -0500
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <3F3B86A7.490DC905.00948489@netscape.net>
References: <3F3B86A7.490DC905.00948489@netscape.net>
Message-ID: <p06020405bc3c6a6b07ae@[128.8.126.17]>

At 1:59 PM -0500 1/27/04, Luke Blanshard wrote:
>Larry Riedel <larryr@saturn.sdsu.edu> wrote:
>
>>... Is there a
>>different way to (nearly) as trivially and efficiently retrieve
>>from a thread a value I can uniquely and efficiently associate
>>in the same way with that thread for the lifespan of the [JVM],
>>regardless of the lifespan of the thread?
>
>You mean, aside from the Thread object itself?

Consider the following problem. You want to generate a log showing 
each write to a variable and the thread that performed the write. For 
logging purposes, you would need to have a unique, non-reused id for 
each thread.

Since it sounds like making Thread.getId() return unique values is 
impossible, it seems that the best solution is to have a WeakHashMap 
from threads to threadIds (perhaps Integer or Long objects). Not as 
simple as using Thread.getId(), but not too bad.


Bill

From matthias.ernst@coremedia.com  Tue Jan 27 19:27:55 2004
From: matthias.ernst@coremedia.com (matthias.ernst@coremedia.com)
Date: Tue, 27 Jan 2004 20:27:55 +0100 (CET)
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <20040127181916.7307.qmail@home19.riedel.org>
Message-ID: <Pine.LNX.4.33.0401272023350.8191-100000@bebop.coremedia.com>

On 27 Jan 2004, Larry Riedel wrote:

> For me to be able to trivially and almost instantaneously
> determine whether or not the thread executing my code already
> executed the same (and/or some other) code before seems like a
> capability which could be pretty valuable to me.

How about a thread local set of 'code that this thread already executed' ?

Instead of Thread.currentThread() == threadWhoExecuted(code) it would be
tlExecutedCode.get().contains(code).

Or did I get the question wrong ?

Matthias
-- 
Matthias Ernst
CoreMedia - Smart Content Technology

"Toll takes its time."


From larryr@saturn.sdsu.edu  Tue Jan 27 20:15:12 2004
From: larryr@saturn.sdsu.edu (Larry Riedel)
Date: 27 Jan 2004 20:15:12 -0000
Subject: [concurrency-interest] Re: Thread.getId()
In-Reply-To: <3F3B86A7.490DC905.00948489@netscape.net>
Message-ID: <20040127201512.7751.qmail@home19.riedel.org>

> > ... Is there a
> > different way to (nearly) as trivially and efficiently retrieve
> > from a thread a value I can uniquely and efficiently associate
> > in the same way with that thread for the lifespan of the [JVM],
> > regardless of the lifespan of the thread?
> 
> You mean, aside from the Thread object itself?

Like use weak/soft references and Reference.get() and "=="?
My feeling is that weak references are cumbersome enough to
introduce a higher level of complexity than using a numeric
primitive would in a context where the cost of using ThreadLocal
is considered too high in terms of complexity and performance,
where even the cost of an unsynchronized method call is not
considered negligible, and methods are invoked on the order of
a million of times per second.

Having a Thread.getId() which gives me a primitive value
guaranteed to uniquely identify that thread forever and is
implemented as something extremely close to "return this.id",
seems to me fairly compelling as far as cost/benefit in terms
of performance and complexity for something which comes for
free with the JDK.  Anything to do with weak references or
ThreadLocal values or which does not guarantee a unique value
forever seems like a quantum change of performance/complexity
cost/benefit which may make trying to distinguish one thread
from another not worth it.


Larry


From news@kav.dk  Thu Jan 29 09:01:07 2004
From: news@kav.dk (Kasper Nielsen)
Date: Thu, 29 Jan 2004 10:01:07 +0100
Subject: [concurrency-interest] beta2 review
In-Reply-To: <16405.2004.738585.132431@altair.cs.oswego.edu>
References: <16405.2004.738585.132431@altair.cs.oswego.edu>
Message-ID: <4018CBD3.8080409@kav.dk>

Doug Lea wrote:
> JSR166 is currently undergoing Tiger engineering process review for
> incorporating all changes since November to be part of 1.5-beta2.
> (Yes, this happens even before beta1 is officially out.) We also
> invite you to play this QA game! If you come across typos, bad
> wordings, or other problems. please let us know soon.  Also, any
> reports of functionality problems would be very welcome, as would be
> new test cases.
> 
> The ground rules here are no feature requests, and no API changes.
> Just problems/errors/fixes.  
> 
By no feature requests do you mean just for beta 2 or in general for 
util.concurrent?

- Kasper



From jozart@blarg.net  Thu Jan 29 09:21:35 2004
From: jozart@blarg.net (Joseph Bowbeer)
Date: Thu, 29 Jan 2004 01:21:35 -0800
Subject: [concurrency-interest] beta2 review
References: <16405.2004.738585.132431@altair.cs.oswego.edu> <4018CBD3.8080409@kav.dk>
Message-ID: <01ef01c3e649$4b075a40$89987cce@REPLICANT2>

> By no feature requests do you mean just for beta 2
> or in general for util.concurrent?

  or -gulp- never ever...

Standard beta rules, I believe: feature requests are accepted, but none will
be addressed until after the release.


----- Original Message ----- 
From: "Kasper Nielsen" <news@kav.dk>
To: <Concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, January 29, 2004 1:01 AM
Subject: Re: [concurrency-interest] beta2 review


Doug Lea wrote:
> JSR166 is currently undergoing Tiger engineering process review for
> incorporating all changes since November to be part of 1.5-beta2.
> (Yes, this happens even before beta1 is officially out.) We also
> invite you to play this QA game! If you come across typos, bad
> wordings, or other problems. please let us know soon.  Also, any
> reports of functionality problems would be very welcome, as would be
> new test cases.
>
> The ground rules here are no feature requests, and no API changes.
> Just problems/errors/fixes.
>
By no feature requests do you mean just for beta 2 or in general for
util.concurrent?

- Kasper


From news@kav.dk  Thu Jan 29 09:30:21 2004
From: news@kav.dk (Kasper Nielsen)
Date: Thu, 29 Jan 2004 10:30:21 +0100
Subject: [concurrency-interest] memory barriers
Message-ID: <4018D2AD.9030506@kav.dk>

Hi,

I was wondering if there exist some documents about exactly when an 
memory barrier is performed.

For example by reading http://gee.cs.oswego.edu/dl/cpj/jmm.html
---
  A writing thread releases a synchronization lock and a reading thread 
subsequently acquires that _same_ synchronization lock.
---
One get the impression that the following will not work

class foo
   int i=4
   fooHelper helper
   foo()
   {
     i=5
     synchronized(this){}
     helper.print()
   }

class fooHelper
   print(foo)
      synchronized(this)
      print(foo.i) //might read 4??


One really neat feature would be if ThreadGroup (and Thread) had a
(blocking) memorybarrier() method.
so when you did baseThreadGroup.memorybarrier you could rest assure that 
all threads had fresh data.

- Kasper


From jozart@blarg.net  Thu Jan 29 10:21:16 2004
From: jozart@blarg.net (Joseph Bowbeer)
Date: Thu, 29 Jan 2004 02:21:16 -0800
Subject: [concurrency-interest] memory barriers
References: <4018D2AD.9030506@kav.dk>
Message-ID: <022401c3e651$a1655ce0$89987cce@REPLICANT2>

Kasper Nielsen asks:

> print(foo.i) might write 4?

In your example, the same thread that constructs foo also calls
helper.print(foo), so the answer will always be 5.  Inside a single thread,
program order rules.

Btw, the code sample also illustrates the dangerous practice of "releasing"
the object reference before it has been fully constructed.

If one thread constructs foo and a different thread somehow calls
fooHelper.print(foo) before foo is fully constructed then print may write 4.


The JMM spec is unclear about memory barriers so they can removed when it is
determined they are not needed.  (In addition, memory barriers per se may
not exist on some platforms.)



----- Original Message ----- 
From: "Kasper Nielsen" <news@kav.dk>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, January 29, 2004 1:30 AM
Subject: [concurrency-interest] memory barriers


Hi,

I was wondering if there exist some documents about exactly when an
memory barrier is performed.

For example by reading http://gee.cs.oswego.edu/dl/cpj/jmm.html
---
  A writing thread releases a synchronization lock and a reading thread
subsequently acquires that _same_ synchronization lock.
---
One get the impression that the following will not work

class foo
   int i=4
   fooHelper helper
   foo()
   {
     i=5
     synchronized(this){}
     helper.print()
   }

class fooHelper
   print(foo)
      synchronized(this)
      print(foo.i) //might read 4??


One really neat feature would be if ThreadGroup (and Thread) had a
(blocking) memorybarrier() method.
so when you did baseThreadGroup.memorybarrier you could rest assure that
all threads had fresh data.

- Kasper


From news@kav.dk  Thu Jan 29 11:53:04 2004
From: news@kav.dk (Kasper Nielsen)
Date: Thu, 29 Jan 2004 12:53:04 +0100
Subject: [concurrency-interest] memory barriers
In-Reply-To: <022401c3e651$a1655ce0$89987cce@REPLICANT2>
References: <4018D2AD.9030506@kav.dk> <022401c3e651$a1655ce0$89987cce@REPLICANT2>
Message-ID: <4018F420.3060102@kav.dk>

Joseph Bowbeer wrote:
> Kasper Nielsen asks:
> 
> 
>>print(foo.i) might write 4?
> 
> 
> In your example, the same thread that constructs foo also calls
> helper.print(foo), so the answer will always be 5.  Inside a single thread,
> program order rules.

oops I meant something like (too early in the morning)

class foo
   int i=4
   void fooMethod()
   {
     i=5
     synchronized(SomeLook){}
   }
   void print()
      synchronized(SomeOtherLook){}
      print(i) //might read 4??

now
1. some thread calls fooMethod()
2. some other threads calls print() (but after fooMethod() has returned)

The question was really if the statement
------
Changes to fields made by one thread are guaranteed to be visible to 
other threads only under the following conditions:
...
A writing thread releases a synchronization lock and a reading thread
subsequently acquires that _same_ synchronization lock.
---------
do it really need to be the _same_ synchronization lock?

> 
> The JMM spec is unclear about memory barriers so they can removed when it is
> determined they are not needed.  (In addition, memory barriers per se may
> not exist on some platforms.)
> 
They have something similar on the .NET platform
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemthreadingthreadclassmemorybarriertopic.asp

- Kasper


From dl@cs.oswego.edu  Thu Jan 29 12:38:37 2004
From: dl@cs.oswego.edu (Doug Lea)
Date: Thu, 29 Jan 2004 07:38:37 -0500
Subject: [concurrency-interest] memory barriers
In-Reply-To: <4018F420.3060102@kav.dk>
References: <4018D2AD.9030506@kav.dk>
 <022401c3e651$a1655ce0$89987cce@REPLICANT2>
 <4018F420.3060102@kav.dk>
Message-ID: <16408.65229.806807.99576@altair.cs.oswego.edu>

> The question was really if the statement
> ------
> Changes to fields made by one thread are guaranteed to be visible to 
> other threads only under the following conditions:
> ...
> A writing thread releases a synchronization lock and a reading thread
> subsequently acquires that _same_ synchronization lock.
> ---------
> do it really need to be the _same_ synchronization lock?

Yes. 

And similarly, you can guarantee visibility using volatiles only if
you read the same volatile as the one written. Which explains why it
wouldn't do you much good to have a Thread.memoryBarrier operation.

The JSR133 revised Java memory model (in effect for JDK1.5) differs
from the old spec in establishing simple, uniform rules for these
cases. (There is also a new underlying abstract memory model.)
Sometime soon, JSR133 needs to put up the one-page programmer-oriented
summary of these. In the mean time, check out slides 17-18 of a talk I
did last month that covers some of this at
http://gee.cs.oswego.edu/dl/concurrency-interest/tiger-talk.pdf

See also the JMM site for lots more information:
  http://www.cs.umd.edu/~pugh/java/memoryModel/


> They have something similar on the .NET platform

This is mainly because they don't place volatile memory semantics on
the variables, but instead on the operations. Hoping not to start a
language flame-war, I'll note only the main tradeoffs:

  * The .net approach is more amenable to allowing "manual" tweaks and
     micro-optimizations that in Java would need to be done by the JVM
     or platform-dependent Java-level "intrinsics" code. (However, 1.5
     hotspot (especially -server) and JDK support code apply more such
     optimizations than most programmers know about.)

  * The .net approach will be harder to support on non-SMP-like
     platforms, for example cluster-VMs and distributed shared memory,
     but Java's model will apply to these in a straightforward way even
     though the underlying implementations will be very different.

-Doug


From jozart@blarg.net  Thu Jan 29 12:43:16 2004
From: jozart@blarg.net (Joseph Bowbeer)
Date: Thu, 29 Jan 2004 04:43:16 -0800
Subject: [concurrency-interest] memory barriers
References: <4018D2AD.9030506@kav.dk> <022401c3e651$a1655ce0$89987cce@REPLICANT2> <4018F420.3060102@kav.dk>
Message-ID: <024901c3e665$778b5050$89987cce@REPLICANT2>

Kasper Nielsen writes:

> Does it really need to be the _same_ synchronization lock?

Yup.  (Depending on how optimal the JVM is...)


> They have something similar [MemoryBarrier] on the .NET platform

Interesting.  If JMM achieves its goals then correctly synchronized Java
code will not only be more readable but will also soundly outperform .NET
code on multiprocessor Itaniums.


----- Original Message ----- 
From: "Kasper Nielsen" <news@kav.dk>
To: <concurrency-interest@altair.cs.oswego.edu>
Sent: Thursday, January 29, 2004 3:53 AM
Subject: Re: [concurrency-interest] memory barriers


Joseph Bowbeer wrote:
> Kasper Nielsen asks:
>
>
>>print(foo.i) might write 4?
>
>
> In your example, the same thread that constructs foo also calls
> helper.print(foo), so the answer will always be 5.  Inside a single
thread,
> program order rules.

oops I meant something like (too early in the morning)

class foo
   int i=4
   void fooMethod()
   {
     i=5
     synchronized(SomeLook){}
   }
   void print()
      synchronized(SomeOtherLook){}
      print(i) //might read 4??

now
1. some thread calls fooMethod()
2. some other threads calls print() (but after fooMethod() has returned)

The question was really if the statement
------
Changes to fields made by one thread are guaranteed to be visible to
other threads only under the following conditions:
...
A writing thread releases a synchronization lock and a reading thread
subsequently acquires that _same_ synchronization lock.
---------
do it really need to be the _same_ synchronization lock?

>
> The JMM spec is unclear about memory barriers so they can removed when it
is
> determined they are not needed.  (In addition, memory barriers per se may
> not exist on some platforms.)
>
They have something similar on the .NET platform
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemthreadingthreadclassmemorybarriertopic.asp

- Kasper


From pugh@cs.umd.edu  Thu Jan 29 22:17:35 2004
From: pugh@cs.umd.edu (Bill Pugh)
Date: Thu, 29 Jan 2004 17:17:35 -0500
Subject: [concurrency-interest] memory barriers
In-Reply-To: <4018F420.3060102@kav.dk>
References: <4018D2AD.9030506@kav.dk>
 <022401c3e651$a1655ce0$89987cce@REPLICANT2> <4018F420.3060102@kav.dk>
Message-ID: <p06020426bc3f34b06fd6@[128.8.126.17]>

At 12:53 PM +0100 1/29/04, Kasper Nielsen wrote:
>
>
>The question was really if the statement
>------
>Changes to fields made by one thread are guaranteed to be visible to 
>other threads only under the following conditions:
>...
>A writing thread releases a synchronization lock and a reading thread
>subsequently acquires that _same_ synchronization lock.
>---------
>do it really need to be the _same_ synchronization lock?

Yes, it needs to be the _same_ synchronization lock. Several reasons for this:

* It allows compilers and JVMs to remove synchronization on thread local
   objects.
* It allows more efficient implementation of synchronization on some SMPs
   (e.g., it doesn't require that synchronization involve a global memory
   barrier, which can be expensive on a system such as a large IA64 cluster).
* Code that depends on ordering by synchronization on two different locks
   is almost certainly broken. For example, in the code you gave, even if
   synchronization was a global memory barrier, there is nothing to 
prevent print
   from seeing the value 4, since you have no way of knowing that one
   synchronized preceded the other (in fact, their executions could overlap).

>
>>
>>The JMM spec is unclear about memory barriers so they can removed when it is
>>determined they are not needed.  (In addition, memory barriers per se may
>>not exist on some platforms.)

This is all described in the new JMM
	http://www.cs.umd.edu/~pugh/java/memoryModel


>>
>They have something similar on the .NET platform
>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemthreadingthreadclassmemorybarriertopic.asp
>
>

Yes, and it is a bad design choice, and the documentation is 
incorrect. They say:

>MemoryBarrier is required only on multiprocessor systems with weak 
>memory ordering (for example, a system employing multiple Intel 
>Itanium processors).

But in fact, ia32 architectures allow some reorderings, and need 
memory barriers or other synchronization constructs in certain 
circumstances. More importantly, I suspect we will get lots of C# 
code that, intentionally leaves out memory barriers, resulting in 
code that runs correctly only on ia32. When memory barriers are used, 
they will result in code slower than if proper synchronization had 
been used.

Bill Pugh

